                  WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
                    NULL, &pEnum);
        }
        else
        {
            hr = m_pIWbemServicesUser->ExecQuery (m_pbstrLanguage, m_pbstrQuery, 
                    WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY, 
                    NULL, &pEnum);
        }
        if ( SUCCEEDED (hr) )
        {
            //
            // Loop through the results retrieving the registry key and value names
            //
            while ( (hr = pEnum->Next(WBEM_INFINITE, 1, &pObject, &ulRet)) == WBEM_S_NO_ERROR )
            {
                hr = GetValuesAndInsertInRSOPObjectList (pObject, 
                        bIsComputer ? m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                        bIsComputer);

                pObject->Release ();

                if ( FAILED (hr) )
                    break;
            }

            pEnum->Release();

#if DBG
            int     nSpewIndex = 0;
            INT_PTR nUpperBound = 0;
            
            if ( bIsComputer )
                nUpperBound = m_rsopObjectArrayComputer.GetUpperBound ();
            else
                nUpperBound = m_rsopObjectArrayUser.GetUpperBound ();

            while ( nUpperBound >= nSpewIndex )
            {
                CRSOPObject* pCurrObject = 0;
                if ( bIsComputer )
                    pCurrObject = m_rsopObjectArrayComputer.GetAt (nSpewIndex);
                else
                    pCurrObject = m_rsopObjectArrayUser.GetAt (nSpewIndex);
                if ( !pCurrObject )
                    break;
                _TRACE (0, L"\t%d\t%s\t%s\t%s\n", pCurrObject->GetPrecedence (), 
                        (PCWSTR) pCurrObject->GetRegistryKey (),
                        (PCWSTR) pCurrObject->GetValueName (),
                        (PCWSTR) pCurrObject->GetPolicyName ());
                nSpewIndex++;
            }
#endif
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::BuildWMIList (): 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponentData::GetValuesAndInsertInRSOPObjectList (
           IWbemClassObject* pObject, 
           CRSOPObjectArray& rRsopObjectArray,
           bool bIsComputer)
{
    HRESULT         hr = S_OK;

    if ( !pObject )
        return E_POINTER;

    //
    // Check if the allocations succeeded
    //

    if ( m_pbstrLanguage && m_pbstrQuery && m_pbstrRegistryKey && 
            m_pbstrValueName && m_pbstrValue && 
            m_pbstrPrecedence && m_pbstrGPOid )
    {
        COleVariant varRegistryKey;
        COleVariant varValueName;
        COleVariant varValue;
        COleVariant varPrecedence;
        COleVariant varGPOid;
        hr = pObject->Get (m_pbstrRegistryKey, 0, &varRegistryKey, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pObject->Get (m_pbstrValueName, 0, &varValueName, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                hr = pObject->Get (m_pbstrValue, 0, &varValue, NULL, NULL);
                if (SUCCEEDED(hr))
                {
//#ifndef DBG
                    // only include objects that have a value name
                    if ( varValueName.bstrVal[0] )
//#endif
                    {
//#ifndef DBG
                        // Only include those objects that are in the system store registry 
                        // path or in the cryptography\autoenrollment path
                        if ( FoundInRSOPFilter (varRegistryKey.bstrVal) )
//#endif
                        {
                            hr = pObject->Get (m_pbstrPrecedence, 0, &varPrecedence, NULL, NULL);
                            if (SUCCEEDED(hr))
                            {
                                hr = pObject->Get (m_pbstrGPOid, 0, &varGPOid, NULL, NULL);
                                if (SUCCEEDED(hr))
                                {
                                    PWSTR lpGPOName = 0;

                                    hr = GetGPOFriendlyName ( 
                                                varGPOid.bstrVal,
                                                &lpGPOName,
                                                bIsComputer);

                                    if (SUCCEEDED(hr))
                                    {

                                        CRSOPObject* pRSOPObject = new CRSOPObject (
                                                varRegistryKey.bstrVal, 
                                                varValueName.bstrVal,
                                                lpGPOName,
                                                varPrecedence.uintVal,
                                                varValue,
                                                varGPOid.bstrVal);
                                        if ( pRSOPObject )
                                        {
                                            CRSOPObject*    pCurrObject = 0;
                                            int             nIndex = 0;
                                            bool            bInserted = false;
                                            INT_PTR         nUpperBound = rRsopObjectArray.GetUpperBound ();

                                            while ( nUpperBound >= nIndex )
                                            {
                                                pCurrObject = rRsopObjectArray.GetAt (nIndex);
                                                if ( !pCurrObject )
                                                    break;

                                                // Sort first by registry key name, 
                                                // then by value name, then by 
                                                // precedence
                                                // security review 2/22/2002 BryanWal ok
                                                int nCmpVal = wcscmp (pCurrObject->GetRegistryKey (),
                                                        pRSOPObject->GetRegistryKey ());
                                                if ( nCmpVal > 0 )
                                                {
                                                    rRsopObjectArray.InsertAt (nIndex, pRSOPObject);
                                                    bInserted = true;
                                                    break;
                                                }
                                                else if ( nCmpVal == 0 )
                                                {
                                                    // Sort by value name
                                                    // security review 2/22/2002 BryanWal ok
                                                    nCmpVal = wcscmp (pCurrObject->GetValueName (),
                                                            pRSOPObject->GetValueName ());
                                                    if ( nCmpVal > 0 )
                                                    {
                                                        rRsopObjectArray.InsertAt (nIndex, pRSOPObject);
                                                        bInserted = true;
                                                        break;
                                                    }
                                                    else if ( nCmpVal == 0 )
                                                    {
                                                        // Sort by precedence
                                                        if ( pCurrObject->GetPrecedence () >
                                                                pRSOPObject->GetPrecedence () )
                                                        {
                                                            rRsopObjectArray.InsertAt (nIndex, pRSOPObject);
                                                            bInserted = true;
                                                            break;
                                                        }
                                                        else if ( pCurrObject->GetPrecedence () ==
                                                                pRSOPObject->GetPrecedence () )
                                                        {
                                                            // The registry key, value name and precedence
                                                            // are the same - this is a duplicate. Pretend
                                                            // we've added it and move on.
                                                            bInserted = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                nIndex++;
                                            }
                                            if ( !bInserted )
                                                rRsopObjectArray.Add (pRSOPObject);
                                        }

                                        LocalFree (lpGPOName);
                                    }
                                    varGPOid.Clear ();
                                }

                                varPrecedence.Clear ();
                            }
                        }
                    }
                    varValue.Clear ();
                }

                varValueName.Clear ();
            }

            varRegistryKey.Clear ();
        }
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


HRESULT CCertMgrComponentData::GetGPOFriendlyName (PCWSTR pwszOID, PWSTR *ppwszGPOName, bool bIsComputer)
{
    ASSERT (pwszOID);
    if ( !pwszOID )
        return E_POINTER;

    ASSERT (ppwszGPOName);
    if ( !ppwszGPOName )
        return E_POINTER;


    HRESULT hr = S_OK;

    //
    // Set the default
    //

    *ppwszGPOName = NULL;


    //
    // Build the query
    //
    PCWSTR  pwszQueryFormat = L"SELECT name, id FROM RSOP_GPO where id=\"%s\"";
    // security review 2/22/2002 BryanWal ok
    PWSTR   pwszQuery = (PWSTR) ::LocalAlloc (LPTR, ((wcslen(pwszOID) + wcslen (pwszQueryFormat) + 1) * sizeof(WCHAR)));
    if ( pwszQuery )
    {
        // security review 2/22/2002 BryanWal ok
        wsprintf (pwszQuery, pwszQueryFormat, pwszOID);


        BSTR bstrQuery = SysAllocString (pwszQuery);
        if (bstrQuery)
        {
            //
            // Allocate BSTRs for the property names we want to retreive
            //

            BSTR bstrName = SysAllocString (TEXT("name"));
            if (bstrName)
            {
                //
                // Execute the query
                //

                IEnumWbemClassObject* pEnum = 0;
                if ( bIsComputer )
                {
                    hr = m_pIWbemServicesComputer->ExecQuery (m_pbstrLanguage, bstrQuery,
                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL, &pEnum);
                }
                else
                {
                    hr = m_pIWbemServicesUser->ExecQuery (m_pbstrLanguage, bstrQuery,
                            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
                            NULL, &pEnum);
                }


                if ( SUCCEEDED (hr) )
                {
                    //
                    // Loop through the results
                    //
                    IWbemClassObject*   pObjects[2] = {0, 0};
                    ULONG               ulRet = 0;
                    hr = pEnum->Next(WBEM_INFINITE, 1, pObjects, &ulRet);
                    if ( SUCCEEDED (hr) )
                    {
                        //
                        // Check for the "data not available case"
                        //

                        if (ulRet != 0)
                        {
                            //
                            // Get the name
                            //
                            VARIANT varGPOName;
                            hr = pObjects[0]->Get (bstrName, 0, &varGPOName, NULL, NULL);
                            if ( SUCCEEDED (hr) )
                            {
                                //
                                // Save the name
                                //

                                // security review 2/22/2002 BryanWal ok
                                *ppwszGPOName = (PWSTR) ::LocalAlloc (LPTR, (wcslen (varGPOName.bstrVal) + 1) * sizeof(WCHAR));

                                if ( *ppwszGPOName )
                                {
                                    // security review 2/22/2002 BryanWal ok
                                    wcscpy (*ppwszGPOName, varGPOName.bstrVal);

                                    VariantClear (&varGPOName);

                                    hr = S_OK;
                                }
                                else
                                {
                                    _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for GPO Name");
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            else
                            {
                                _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to get gponame in query results for %s with 0x%x\n",
                                          bstrQuery, hr);
                            }
                        }
                    }
                    else
                    {
                        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to get first item in query results for %s with 0x%x\n",
                                  bstrQuery, hr);
                    }

                    pEnum->Release ();
                }
                else
                {
                    _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to query for %s with 0x%x\n",
                              bstrQuery, hr);
                }

                SysFreeString (bstrName);
            }
            else
            {
               _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for name");
                hr = HRESULT_FROM_WIN32(ERROR_OUTOFMEMORY);
            }

            SysFreeString (bstrQuery);
        }
        else
        {
            _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for query");
            hr = E_OUTOFMEMORY;
        }
        ::LocalFree (pwszQuery);
    }
    else
    {
        _TRACE (0, L"CCertMgrComponentData::GetGPOFriendlyName: Failed to allocate memory for unicode query");
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
bool CCertMgrPKPolExtension::FoundInRSOPFilter (BSTR bstrKey) const
{
    ASSERT (bstrKey);
    if ( !bstrKey )
        return false;

    // security review 2/22/2002 BryanWal ok for all
    static  size_t  nRegPathLen = wcslen (CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH);
    static  size_t  nTrustedPublisherKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH);
    static  size_t  nDisallowedKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH);
	static  size_t  nSaferKeyLen = wcslen (SAFER_HKLM_REGBASE);
    static  size_t  nEFSKeyLen = wcslen (EFS_SETTINGS_REGPATH);


    //Include group policy system stores but not trusted publisher or disallowed
    // security review 2/22/2002 BryanWal ok for all
    if ( !_wcsnicmp (CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH, bstrKey, nRegPathLen) &&
				(_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH, 
						bstrKey, nTrustedPublisherKeyLen) &&
				_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH, 
						bstrKey, nDisallowedKeyLen)) )
    {
        return true;
    }
    else if ( !_wcsnicmp (SAFER_HKLM_REGBASE, bstrKey, nSaferKeyLen) ||
             !_wcsnicmp (EFS_SETTINGS_REGPATH, bstrKey, nEFSKeyLen) ||
             !_wcsicmp (AUTO_ENROLLMENT_KEY, bstrKey) )
    {
        return true;
    }
    else
        return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\cookie.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Cookie.cpp
//
//  Contents:   Implementation of CCertMgrCookie and related classes
//
//----------------------------------------------------------------------------


#include "stdafx.h"
#include <gpedit.h>
#include "cookie.h"
#include "storegpe.h"
#pragma warning(push, 3)
#include <atlimpl.cpp>
#pragma warning(pop)

DECLARE_INFOLEVEL(CertificateManagerSnapin)

USE_HANDLE_MACROS("CERTMGR(cookie.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcooki.cpp"
#include "stdutils.cpp"
#include "certifct.h"


//
// CCertMgrCookie
//

// returns <0, 0 or >0


CCertMgrCookie::CCertMgrCookie (CertificateManagerObjectType objecttype,
        LPCWSTR lpcszMachineName,
        LPCWSTR objectName)
    : CStoresMachineName (lpcszMachineName),
    m_objecttype (objecttype),
    m_objectName (objectName),
    m_resultDataID (0),
    m_nOpenPageCount (0),
    m_bIsSelected (false)
{
    ASSERT (IsValidObjectType (m_objecttype));
    if ( m_objectName.IsEmpty () )
    {
        AFX_MANAGE_STATE (AfxGetStaticModuleState ());
        VERIFY (m_objectName.LoadString (IDS_CERTIFICATE_MANAGER));
    }
}

CCertMgrCookie::~CCertMgrCookie ()
{
}


HRESULT CCertMgrCookie::CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult )
{
    ASSERT (pOtherCookie);

    CCertMgrCookie* pcookie = reinterpret_cast <CCertMgrCookie*>(pOtherCookie);
    ASSERT (pcookie);
    if ( pcookie && m_objecttype != pcookie->m_objecttype )
    {
        *pnResult = ((int)m_objecttype) - ((int)pcookie->m_objecttype); // arbitrary ordering
        return S_OK;
    }

    return E_UNEXPECTED;
}

CCookie* CCertMgrCookie::QueryBaseCookie(int i)
{
    ASSERT(!i);
    return (CCookie*)this;
}

int CCertMgrCookie::QueryNumCookies()
{
    return 1;
}

LPCWSTR CCertMgrCookie::GetObjectName()
{
    return m_objectName;
}

HRESULT CCertMgrCookie::Commit()
{
    return S_OK;
}

UINT CCertMgrCookie::IncrementOpenPageCount ()
{
    m_nOpenPageCount++;
    return m_nOpenPageCount;
}

UINT CCertMgrCookie::DecrementOpenPageCount ()
{
    ASSERT (0 != m_nOpenPageCount);
    if ( 0 != m_nOpenPageCount )
        m_nOpenPageCount--;

    return m_nOpenPageCount;
}

bool CCertMgrCookie::HasOpenPropertyPages () const
{
    return (0 != m_nOpenPageCount) ? true : false;
}

void CCertMgrCookie::SetSelected(bool bIsSelected)
{
    m_bIsSelected = bIsSelected;
}

bool CCertMgrCookie::IsSelected() const
{
    return m_bIsSelected;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CCertStore::CCertStore (
        CertificateManagerObjectType    objecttype,
        LPCSTR                          pszStoreProv,
        DWORD                           dwFlags,
        LPCWSTR                         lpcszMachineName,
        LPCWSTR                         objectName,
        const CString &                 pcszLogStoreName,
        const CString &                 pcszPhysStoreName,
        const SPECIAL_STORE_TYPE        storeType,
        const DWORD                     dwLocation,
        IConsole*                       pConsole,
        bool                            fIsComputerType /*= false*/)
    : CCertMgrCookie (objecttype,
        lpcszMachineName,
        objectName),
    m_hCertStore (0),
    m_dwFlags (dwFlags),
    m_storeProvider (pszStoreProv),
    m_pcszStoreName (pcszLogStoreName),
    m_storeType (storeType),
    m_bReadOnly (false),
    m_bUnableToOpenMsgDisplayed (false),
    m_dwLocation (dwLocation),
    m_pConsole (pConsole),
    m_bDirty (false),
    m_fReadOnlyFlagChecked (false),
    m_nCertCount (0),
    m_fCertCountValid (false),
    m_nLockCnt (0),
    m_fIsComputerType (fIsComputerType) 
{
    _TRACE (1, L"Entering CCertStore::CCertStore LS: %s  PS: %s\n",
            (LPCWSTR) pcszLogStoreName,
            (LPCWSTR) pcszPhysStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    if ( CERT_STORE_PROV_COLLECTION != pszStoreProv )
    {
        ASSERT (!pcszLogStoreName.IsEmpty ());
        if ( !pcszPhysStoreName.IsEmpty () )
            m_pcszStoreName += _T("\\") + pcszPhysStoreName;
    }
    ASSERT (m_pConsole);
    if ( m_pConsole )
        m_pConsole->AddRef ();
    _TRACE (-1, L"Leaving CCertStore::CCertStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
}


CCertStore::~CCertStore ()
{
    _TRACE (1, L"Entering CCertStore::~CCertStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
    Close (true);   // force close
    if ( m_pConsole )
        m_pConsole->Release ();
    _TRACE (-1, L"Leaving CCertStore::~CCertStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HCERTSTORE  CCertStore::GetStoreHandle (BOOL bSilent /* = FALSE*/, HRESULT* phr /* = 0*/)
{
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);

    DWORD   dwErr = 0;
    if ( !m_hCertStore )
    {
        void*   pvPara = 0;
        
        if ( CERT_STORE_PROV_COLLECTION != m_storeProvider )
            pvPara = (void*)(LPCWSTR) m_pcszStoreName;
        m_dwFlags |= CERT_STORE_SET_LOCALIZED_NAME_FLAG;

        _TRACE (0, L"Opening %s store\n", (LPCWSTR) m_pcszStoreName);
        m_hCertStore = ::CertOpenStore (m_storeProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                NULL,
                m_dwFlags | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                pvPara);
        if ( !m_hCertStore )
        {
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"Open of %s store failed. 0x%x\n", (LPCWSTR) m_pcszStoreName,
                    dwErr);
            _TRACE (0, L"Opening %s store (read-only)\n", (LPCWSTR) m_pcszStoreName);
            m_dwFlags |= CERT_STORE_READONLY_FLAG;
            m_hCertStore = ::CertOpenStore (m_storeProvider,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                    NULL,
                    m_dwFlags,
                    pvPara);
            if ( m_hCertStore )
                m_bReadOnly = true;
            else
            {
                dwErr = GetLastError ();
                if ( phr )
                    *phr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                            (PCWSTR) m_pcszStoreName, dwErr);           
            }
        }
        if ( !m_hCertStore )
        {
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"Open of %s store (read-only) failed. 0x%x\n", 
                    (LPCWSTR) m_pcszStoreName, dwErr);
            if ( CERT_STORE_PROV_FILENAME_W == m_storeProvider)
            {
                _TRACE (0, L"Open %s store (file-based).\n", (LPCWSTR) m_pcszStoreName);
                DWORD   cbData = 0;
                BYTE*   pbData = NULL;

                //get the BLOB from the file
                // ISSUE
                // NTRAID Bug9 538824: Certmgr: Memory leak if CertOpenStore fails.
                HRESULT hr = RetrieveBLOBFromFile ((LPCWSTR) m_pcszStoreName, 
                        &cbData, &pbData);
                if ( SUCCEEDED (hr) )
                {
                    //open a generic memory store
                    m_hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
                             0, NULL,
                             CERT_STORE_SET_LOCALIZED_NAME_FLAG | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                             NULL);


                    if ( m_hCertStore )
                    {
                        if ( !CertAddSerializedElementToStore (
                                m_hCertStore,
                                pbData,
                                cbData,
                                CERT_STORE_ADD_ALWAYS,
                                0,
                                CERT_STORE_ALL_CONTEXT_FLAG,
                                NULL,
                                NULL) )
                        {
                            // CertAddSerializedElementToStore failed.  This means this is probably a
                            // base64 certificate or a store containing a base64 certificate.  Open it
                            // up with CryptQueryObject.
                            _TRACE (0, L"CCertStore::GetStoreHandle () - File input is not a serialized element.\n");
                            DWORD           dwMsgAndCertEncodingType = 0;
                            DWORD           dwContentType = 0;
                            DWORD           dwFormatType = 0;
                            PCERT_CONTEXT   pCertContext = 0;
                            CERT_BLOB       certBlob;
                            HCERTSTORE      hCertStore = 0;

                            // security review 2/27/2002 BryanWal ok
                            ::ZeroMemory (&certBlob, sizeof (certBlob));
                            certBlob.cbData = cbData;
                            certBlob.pbData = pbData;
                            BOOL    bResult = ::CryptQueryObject (
                                        CERT_QUERY_OBJECT_BLOB, // CERT_QUERY_OBJECT_FILE,
                                        (void *) &certBlob, //(LPCWSTR) m_pcszStoreName,
                                        CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                                            CERT_QUERY_CONTENT_FLAG_CERT |
                                            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                                            CERT_QUERY_CONTENT_FLAG_PKCS7_UNSIGNED |
                                            CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED_EMBED,
                                        CERT_QUERY_FORMAT_FLAG_ALL,
                                        0,
                                        &dwMsgAndCertEncodingType,
                                        &dwContentType,
                                        &dwFormatType,
                                        &hCertStore,
                                        NULL,
                                        (const void **) &pCertContext);
                            if ( bResult && pCertContext )
                            {       
                                // The file contains a certificate context
                                hr = AddCertificateContext (pCertContext, 0, false);
                            }
                            else if ( bResult && hCertStore )
                            {
                                // The file contains a certificate store, so close the temporary memory store we created
                                // and assign the returned store handle to the global handle.
                                ::CertCloseStore (m_hCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
                                m_hCertStore = hCertStore;
                            }
                            else
                            {
                                CString caption;
                                CString message;
                                int     iRetVal = 0;

                                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                                VERIFY (message.LoadString (IDS_UNKNOWN_CERT_FILE_TYPE));

                                if ( m_pConsole )
                                    m_pConsole->MessageBox (message, caption, MB_ICONWARNING | MB_OK, &iRetVal);
                            }
                        }
                    }
                    else
                    {
                        free (pbData);
                        dwErr = GetLastError ();
                        _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                                (PCWSTR) m_pcszStoreName, dwErr);
                    }
                }
                else
                {
                    _TRACE (0, L"CCertStore::GetStoreHandle () - Unable to retrieve BLOB from file: %x.\n", hr);
                }
                if ( phr )
                    *phr = hr;
            }
        }
        else
        {
            _TRACE (0, L"Open of %s store succeeded.\n", (LPCWSTR) m_pcszStoreName);
        }
    }

    if ( !m_hCertStore && !m_bUnableToOpenMsgDisplayed && !bSilent && 
            (USERDS_STORE != GetStoreType ()) )
    {
        m_bUnableToOpenMsgDisplayed = true;
        CString caption;
        CString text;
        int     iRetVal = 0;

        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
        text.FormatMessage (IDS_UNABLE_TO_OPEN_STORE, GetStoreName (), 
                GetSystemMessage (dwErr));
        if ( m_pConsole )
            m_pConsole->MessageBox ( text, caption, MB_OK, &iRetVal);
    }

    return m_hCertStore;
}


//--------------------------------------------------------------------------------
//
//get the bytes from the file name
//
// Note; Memory is allocated via malloc.    S_OK is returned
//       via succees
//
//
//
//---------------------------------------------------------------------------------
HRESULT CCertStore::RetrieveBLOBFromFile (LPCWSTR pwszFileName, DWORD *pcb, BYTE **ppb)
{
    _TRACE (1, L"Entering CCertStore::RetrieveBLOBFromFile - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    HRESULT hr = S_OK;
    HANDLE  hFile = NULL;
    DWORD   dwBytesRead = 0;

    if(!pcb || !ppb || !pwszFileName)
        return E_INVALIDARG;

    *ppb=NULL;
    *pcb=0;

    // security review 2/27/2002 BryanWal - file name comes from command-line
    // ISSUE: Check valid length of path and file name here
    // NTRAID Bug9 566232 Security: Certmgr:  Check valid file name and path length before call to Create File
    // What is a reasonable file size?  PhilH says there is no real limit.
    hFile = ::CreateFile (pwszFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ,
                           NULL,                   // lpsa
                           OPEN_EXISTING,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL);
    if (INVALID_HANDLE_VALUE != hFile )
    {
        *pcb = GetFileSize(hFile, NULL);
        if ( INVALID_FILE_SIZE != *pcb )
        {
            *ppb = (BYTE *)malloc(*pcb);

            if ( *ppb )
            {
                // Read the pkcs7 message
                // security review 2/27/2002 BryanWal
                // What is a reasonable file size?  PhilH says there is no real limit.
                if ( !ReadFile(hFile,
                              *ppb,
                              *pcb,
                              &dwBytesRead,
                              NULL) ||
                       dwBytesRead != *pcb )
                {
                    free(*ppb);
                    *ppb=NULL;
                    hr = HRESULT_FROM_WIN32(GetLastError());;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"GetFileSize () returned 0x%x\n", dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }

         //close the file handle
        CloseHandle(hFile);
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CreateFile (OPEN_EXISTING, %s) failed: 0x%x\n", pwszFileName, dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }


    _TRACE (-1, L"Leaving CCertStore::RetrieveBLOBFromFile - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return S_OK;
}



bool CCertStore::IsReadOnly ()
{
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);

    // GetCertStore () sets the read-only checked flag
    // Optimization: If the flag is true, it's already been set.
    if ( !m_fReadOnlyFlagChecked )  
    {
        GetStoreHandle ();
        Close ();
        m_fReadOnlyFlagChecked = true;
    }

    return m_bReadOnly;
}


HRESULT CCertStore::Commit()
{
    _TRACE (1, L"Entering CCertStore::Commit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    HRESULT hr = CCertMgrCookie::Commit ();

    if ( m_hCertStore && !m_bReadOnly && m_bDirty )
    {
        BOOL    bResult = ::CertControlStore (m_hCertStore, 0,
                CERT_STORE_CTRL_COMMIT, NULL);
        if ( bResult )
            m_bDirty = false;
        else
        {
            DWORD   dwErr = GetLastError ();
            hr = HRESULT_FROM_WIN32 (dwErr);

            if ( E_ACCESSDENIED == hr )
            {
                m_bReadOnly = true;
                m_dwFlags |= CERT_STORE_READONLY_FLAG;
            }
            else
            {
                LPVOID  lpMsgBuf = 0;
                
                // security review 2/27/2002 BryanWal - ok - message from system
                FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                        NULL,
                        dwErr,
                        MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                         (LPWSTR) &lpMsgBuf,    0,    NULL);
                    
                // Display the string.
                CString caption;
                CString message;
                int     iRetVal = 0;

                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                message.FormatMessage (IDS_CANT_SAVE_STORE, GetStoreName (), (LPWSTR) lpMsgBuf);
                if ( m_pConsole )
                    m_pConsole->MessageBox ((LPCWSTR) message, (LPCWSTR) caption,
                            MB_OK, &iRetVal);
                // Free the buffer.
                LocalFree (lpMsgBuf);
            }
        }
    }

    _TRACE (-1, L"Leaving CCertStore::Commit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}


bool CCertStore::ContainsCertificates()
{
    _TRACE (1, L"Entering CCertStore::ContainsCertificates - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    bool    bResult = false;

    bResult = (GetCertCount () > 0);
    _TRACE (-1, L"Leaving CCertStore::ContainsCertificates - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bResult;
}

bool CCertStore::ContainsCRLs()
{
    _TRACE (1, L"Entering CCertStore::ContainsCRLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    bool    bResult = false;
    PCCRL_CONTEXT   pCRLContext = EnumCRLs (0);
    if ( !pCRLContext )
        bResult = false;
    else
    {
        ::CertFreeCRLContext (pCRLContext);
        bResult = true;
    }
    Close ();

    _TRACE (-1, L"Leaving CCertStore::ContainsCRLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bResult;
}

bool CCertStore::ContainsCTLs()
{
    _TRACE (1, L"Entering CCertStore::ContainsCTLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    bool    bResult = false;
    PCCTL_CONTEXT   pCTLContext = EnumCTLs (0);
    if ( !pCTLContext )
        bResult = false;
    else
    {
        ::CertFreeCTLContext (pCTLContext);
        bResult = true;
    }
    Close ();

    _TRACE (-1, L"Leaving CCertStore::ContainsCTLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bResult;
}


LPCWSTR CCertStore::GetLocalizedName()
{
//  _TRACE (1, L"Entering CCertStore::GetLocalizedName - %s\n",
//          (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    if ( m_localizedName.IsEmpty () )
    {
        m_localizedName = ::CryptFindLocalizedName (GetObjectName ());
        if ( m_localizedName.IsEmpty () )
        {
            DWORD       cbLocalizedName;
            HCERTSTORE  hStore = 0;
            bool        bStoreOpenedByThisMethod = false;

            // NTRAID# 366562 Safer:  Inconsistent drag-and-drop behavior for certificate rules
            if ( m_hCertStore )
                hStore = m_hCertStore;
            else
            {
                hStore = GetStoreHandle ();
                bStoreOpenedByThisMethod = true;
            }

            if ( hStore )
            {
                if ( CertGetStoreProperty(
                        hStore,
                        CERT_STORE_LOCALIZED_NAME_PROP_ID,
                        NULL,
                        &cbLocalizedName))
                {
                    LPWSTR  pwszLocalizedName = new WCHAR[cbLocalizedName/sizeof (WCHAR)];
                    if ( pwszLocalizedName )
                    {
                        // security review 2/27/2002 BryanWal ok
                        ::ZeroMemory (pwszLocalizedName, cbLocalizedName);
                        if ( CertGetStoreProperty(
                                hStore,
                                CERT_STORE_LOCALIZED_NAME_PROP_ID,
                                pwszLocalizedName,
                                &cbLocalizedName
                                ))
                        {
                            m_localizedName = pwszLocalizedName;
                            if ( m_localizedName == m_pcszStoreName )
                                m_localizedName = GetObjectName ();
                        }
                        
                        delete [] pwszLocalizedName;
                    }
                }

                if ( bStoreOpenedByThisMethod )
                    Close ();
            }
        }

        // If it's still empty, get the object name
        if ( m_localizedName.IsEmpty () )
            m_localizedName = GetObjectName ();
    }
//  _TRACE (-1, L"Leaving CCertStore::GetLocalizedName - %s\n",
//          (LPCWSTR) m_pcszStoreName);
    return (LPCWSTR) m_localizedName;
}

CString CCertStore::GetStoreName() const
{
//  _TRACE (0, L"Entering and leaving CCertStore::GetStoreName - %s\n",
//          (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    return m_pcszStoreName;
}


HRESULT CCertStore::AddCertificateContext(
        PCCERT_CONTEXT pContext, 
        LPCONSOLE pConsole, 
        bool bDeletePrivateKey, 
        PCCERT_CONTEXT* ppNewCertContext,
        bool* pbCertWasReplaced)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    _TRACE (1, L"Entering CCertStore::AddCertificateContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    ASSERT (pContext);
    if ( !pContext )
        return E_POINTER;

    if ( pbCertWasReplaced )
        *pbCertWasReplaced = false;

    HRESULT     hr = S_OK;
    HCERTSTORE  hCertStore = GetStoreHandle (FALSE, &hr);

    if ( hCertStore )
    {
        PCCERT_CONTEXT  pNewContext = 0;

        BOOL    bResult = ::CertAddCertificateContextToStore (hCertStore,
                ::CertDuplicateCertificateContext (pContext), CERT_STORE_ADD_NEW,
                &pNewContext);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"CertAddCertificateContextToStore () failed: 0x%x\n", dwErr);

            if ( CRYPT_E_EXISTS == dwErr )
            {
                if ( pConsole ) // if !pConsole then no popup is desired
                {
                    CCertificate    cert (pContext, this);
                    CString text;
                    CString caption;
                    int     iRetVal = 0;


                    text.FormatMessage (IDS_DUPLICATE_CERT,
                            (PCWSTR) GetLocalizedName (),
                            (PCWSTR) cert.GetFriendlyName (),
                            (PCWSTR) cert.GetSubjectName ());
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    hr = pConsole->MessageBox (text, caption, 
                            MB_YESNO | MB_DEFBUTTON2, &iRetVal);
                    if ( IDYES == iRetVal )
                    {
                        bResult = ::CertAddCertificateContextToStore (hCertStore,
                                        ::CertDuplicateCertificateContext (pContext), 
                                        CERT_STORE_ADD_REPLACE_EXISTING,
                                        &pNewContext);
                        if ( bResult )
                        {
                            if ( pbCertWasReplaced )
                                *pbCertWasReplaced = true;
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32 (GetLastError ());
                        }
                    }
                    else
                        hr = HRESULT_FROM_WIN32 (CRYPT_E_EXISTS);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
        }
        else
        {
            m_fCertCountValid = false;
            SetDirty ();
            ASSERT (pNewContext);
            if ( bDeletePrivateKey )
            {
                ::CertSetCertificateContextProperty (pNewContext,
                        CERT_KEY_PROV_INFO_PROP_ID, 0, NULL);
            }
        }

        if ( pNewContext && ppNewCertContext)
            *ppNewCertContext = pNewContext;
        Close ();
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertStore::AddCertificateContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

void CCertStore::IncrementCertCount ()
{
    m_nCertCount++;
}

int CCertStore::GetCertCount()
{
    _TRACE (1, L"Entering CCertStore::GetCertCount - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    if ( !m_fCertCountValid )
    {
        PCCERT_CONTEXT  pCertContext = 0;

        
        m_nCertCount = 0;
        while ( 1 )
        {
            pCertContext = EnumCertificates (pCertContext);
            if ( pCertContext )
                m_nCertCount++;
            else
                break;
        }
        Close ();
        m_fCertCountValid = true;
    }
    _TRACE (-1, L"Leaving CCertStore::GetCertCount - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_nCertCount;
}


BOOL CCertStore::operator ==(CCertStore &rStore)
{
    _TRACE (1, L"Entering CCertStore::operator == - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    BOOL    bResult = FALSE;

    if ( GetStoreHandle () == rStore.GetStoreHandle () )
        bResult = TRUE;

    Close ();
    rStore.Close ();
    _TRACE (-1, L"Leaving CCertStore::operator == - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bResult;
}

CCertificate* CCertStore::GetSubjectCertificate(PCERT_INFO pCertId)
{
    _TRACE (1, L"Entering CCertStore::GetSubjectCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    CCertificate* pCert = 0;

    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
    {
        PCCERT_CONTEXT pSignerCert =
                ::CertGetSubjectCertificateFromStore (
                        hCertStore,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        pCertId);
        if ( pSignerCert )
        {
            pCert = new CCertificate (pSignerCert, this);
        }
        Close ();
    }

    _TRACE (-1, L"Leaving CCertStore::GetSubjectCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pCert;
}

PCCERT_CONTEXT CCertStore::EnumCertificates(PCCERT_CONTEXT pPrevCertContext)
{
//  _TRACE (1, L"Entering CCertStore::EnumCertificates - %s\n",
//          (LPCWSTR) m_pcszStoreName);
    PCCERT_CONTEXT pCertContext = 0;

    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
        pCertContext = ::CertEnumCertificatesInStore (hCertStore, pPrevCertContext);


    m_fCertCountValid = false;

//  _TRACE (-1, L"Leaving CCertStore::EnumCertificates - %s\n",
//          (LPCWSTR) m_pcszStoreName);
    return pCertContext;
}

PCCTL_CONTEXT CCertStore::EnumCTLs(PCCTL_CONTEXT pPrevCtlContext)
{
    _TRACE (1, L"Entering CCertStore::EnumCTLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    PCCTL_CONTEXT pCTLContext = 0;


    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);

    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
        pCTLContext = ::CertEnumCTLsInStore (hCertStore, pPrevCtlContext);

    _TRACE (-1, L"Leaving CCertStore::EnumCTLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pCTLContext;
}

PCCRL_CONTEXT CCertStore::EnumCRLs(PCCRL_CONTEXT pPrevCrlContext)
{
    _TRACE (1, L"Entering CCertStore::EnumCRLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    PCCRL_CONTEXT pCRLContext = 0;

    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
        pCRLContext = ::CertEnumCRLsInStore (hCertStore, pPrevCrlContext);

    _TRACE (1, L"Entering CCertStore::EnumCRLs - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pCRLContext;
}

PCCERT_CONTEXT CCertStore::FindCertificate(
        DWORD dwFindFlags,
        DWORD dwFindType,
        const void * pvFindPara,
        PCCERT_CONTEXT pPrevCertContext)
{
    _TRACE (1, L"Entering CCertStore::FindCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    PCCERT_CONTEXT  pCertContext = 0;
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
        pCertContext = ::CertFindCertificateInStore (hCertStore,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                dwFindFlags, dwFindType, pvFindPara, pPrevCertContext);

    _TRACE (-1, L"Leaving CCertStore::FindCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pCertContext;
}


void CCertStore::FinalCommit()
{
    _TRACE (1, L"Entering CCertStore::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    // Called only from destructor
    if ( m_hCertStore && m_bDirty )
        ::CertControlStore (m_hCertStore, 0, CERT_STORE_CTRL_COMMIT, NULL);
    _TRACE (-1, L"Leaving CCertStore::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

bool CCertStore::AddCTLContext(PCCTL_CONTEXT pCtlContext)
{
    _TRACE (1, L"Entering CCertStore::AddCTLContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    BOOL        bResult = FALSE;
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
    {
        bResult = ::CertAddCTLContextToStore (hCertStore,
                pCtlContext,
                CERT_STORE_ADD_NEW,
                0);
        Close ();
    }
    if ( bResult )
        SetDirty ();
    
    _TRACE (-1, L"Leaving CCertStore::AddCTLContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bResult ? true : false;
}

bool CCertStore::AddCRLContext(PCCRL_CONTEXT pCrlContext)
{
    _TRACE (1, L"Entering CCertStore::AddCRLContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    BOOL        bResult = FALSE;
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
    {
        bResult = ::CertAddCRLContextToStore (hCertStore,
                pCrlContext,
                CERT_STORE_ADD_NEW,
                0);
        Close ();
    }
    if ( bResult )
        SetDirty ();
    _TRACE (-1, L"Leaving CCertStore::AddCRLContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bResult ? true : false;
}

PCCRL_CONTEXT CCertStore::GetCRL(PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD * pdwFlags)
{
    _TRACE (1, L"Entering CCertStore::GetCRL - %s\n",
            (LPCWSTR) m_pcszStoreName);
    PCCRL_CONTEXT pCRLContext = 0;

    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
    {
        pCRLContext = ::CertGetCRLFromStore (hCertStore, pIssuerContext,
                pPrevCrlContext, pdwFlags);
        Close ();
    }
    
    _TRACE (-1, L"Leaving CCertStore::GetCRL - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pCRLContext;
}

HRESULT CCertStore::Resync()
{
    _TRACE (1, L"Entering CCertStore::Resync - %s\n",
            (LPCWSTR) m_pcszStoreName);
    HRESULT     hr = S_OK;

    // 256803 CertMgr: F5 refresh of Certificates Current User - Active 
    // Directory User Object, overwrites UserCerificate DS object resulting 
    // in data loss
//  Close (true);
    if ( (CERT_STORE_PROV_COLLECTION != m_storeProvider) && 
            !m_bReadOnly && 
            CERTMGR_LOG_STORE_RSOP != m_objecttype )
    {
        FinalCommit ();
    }

    HCERTSTORE hCertStore = GetStoreHandle (FALSE);
    if ( hCertStore )
    {
        BOOL    bResult = ::CertControlStore (hCertStore, 0,
                CERT_STORE_CTRL_RESYNC, NULL);
        if ( !bResult )
        {
            DWORD   dwErr = GetLastError ();
            ASSERT (ERROR_NOT_SUPPORTED == dwErr);
            if ( ERROR_NOT_SUPPORTED != dwErr )
                hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    m_fCertCountValid = false;

    _TRACE (-1, L"Leaving CCertStore::Resync - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}



int CCertStore::GetCTLCount()
{
    _TRACE (1, L"Entering CCertStore::GetCTLCount - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype);
    int             nCTLCount = 0;
    PCCTL_CONTEXT   pCTLContext = 0;


    while ( 1 )
    {
        pCTLContext = EnumCTLs (pCTLContext);
        if ( pCTLContext )
            nCTLCount++;
        else
            break;
    }

    _TRACE (-1, L"Leaving CCertStore::GetCTLCount - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return nCTLCount;
}

HRESULT CCertStore::AddStoreToCollection(HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
{
    _TRACE (1, L"Entering CCertStore::AddStoreToCollection - %s\n",
            (LPCWSTR) m_pcszStoreName);
    HRESULT     hr = S_OK;
    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore && hSiblingStore)
    {
        BOOL    bResult = ::CertAddStoreToCollection (hCertStore,
                hSiblingStore,
                dwUpdateFlags,
                dwPriority);
        if ( bResult )
            SetDirty ();
        else
        {
            DWORD   dwErr = GetLastError ();
            ASSERT (ERROR_NOT_SUPPORTED == dwErr);
            if ( ERROR_NOT_SUPPORTED != dwErr )
                hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else
        hr = E_FAIL;

    Close ();
    _TRACE (-1, L"Leaving CCertStore::AddStoreToCollection - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

HRESULT CCertStore::AddStoreToCollection(CCertStore& siblingStore, DWORD dwUpdateFlags, DWORD dwPriority)
{
    _TRACE (1, L"Entering CCertStore::AddStoreToCollection - %s\n", 
            (LPCWSTR) m_pcszStoreName);
    HRESULT     hr = S_OK;
    HCERTSTORE  hSiblingStore = siblingStore.GetStoreHandle ();
    if ( hSiblingStore)
    {
        hr = AddStoreToCollection (hSiblingStore, dwUpdateFlags, dwPriority);
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertStore::AddStoreToCollection - %s\n", 
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

void CCertStore::SetDirty()
{
    _TRACE (1, L"Entering CCertStore::SetDirty - %s\n",
            (LPCWSTR) m_pcszStoreName);
    m_bDirty = true;
    _TRACE (-1, L"Leaving CCertStore::SetDirty - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

void CCertStore::Close(bool bForceClose)
{
//  _TRACE (1, L"Entering CCertStore::Close - %s\n",
//          (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
            CERTMGR_LOG_STORE_RSOP == m_objecttype ||
            CERTMGR_LOG_STORE == m_objecttype ||
            CERTMGR_PHYS_STORE == m_objecttype);
    if ( CERTMGR_LOG_STORE_GPE == m_objecttype || bForceClose )
    {
        if ( m_hCertStore && m_nLockCnt <= 0 )
        {
            if ( (CERT_STORE_PROV_COLLECTION != m_storeProvider) && 
                    !m_bReadOnly && 
                    CERTMGR_LOG_STORE_RSOP != m_objecttype )
            {
                FinalCommit ();
            }
            ::CertCloseStore (m_hCertStore, 0);
            _TRACE (-1, L"Leaving%s store closed\n", (LPCWSTR) m_pcszStoreName);
            m_hCertStore = 0;
            m_bDirty = false;
        }
    }
//  _TRACE (-1, L"Leaving CCertStore::Close - %s\n",
//          (LPCWSTR) m_pcszStoreName);
}

BOOL CCertStore::AddEncodedCTL(DWORD dwMsgAndCertEncodingType, const BYTE *pbCtlEncoded, DWORD cbCtlEncoded, DWORD dwAddDisposition, PCCTL_CONTEXT *ppCtlContext)
{
    BOOL    bResult = FALSE;

    HCERTSTORE  hCertStore = GetStoreHandle ();
    if ( hCertStore )
    {   
        bResult = ::CertAddEncodedCTLToStore (hCertStore,
                dwMsgAndCertEncodingType,
                pbCtlEncoded,
                cbCtlEncoded,
                dwAddDisposition, ppCtlContext);
        if ( bResult )
        {
            m_bDirty = true;
            Commit ();
        }
        Close ();
    }

    return bResult;
}

void CCertStore::InvalidateCertCount()
{
    m_fCertCountValid = false;
}

void CCertStore::Lock()
{
    m_nLockCnt++;
}

void CCertStore::Unlock()
{
    ASSERT (m_nLockCnt > 0);
    m_nLockCnt--;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CContainerCookie::CContainerCookie (CCertStore& rStore,
        CertificateManagerObjectType objectType,
        LPCWSTR lpcszMachineName,
        LPCWSTR objectName)
: CCertMgrCookie (objectType, lpcszMachineName, objectName),
    m_rCertStore (rStore)
{
    m_rCertStore.AddRef ();
    ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
        CERTMGR_CTL_CONTAINER == m_objecttype ||
        CERTMGR_CERT_CONTAINER == m_objecttype);
}


CContainerCookie::~CContainerCookie ()
{
    ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
        CERTMGR_CTL_CONTAINER == m_objecttype ||
        CERTMGR_CERT_CONTAINER == m_objecttype);
    m_rCertStore.Release ();
}


CCertStore& CContainerCookie::GetCertStore () const
{
    ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
        CERTMGR_CTL_CONTAINER == m_objecttype ||
        CERTMGR_CERT_CONTAINER == m_objecttype);
    return m_rCertStore;
}


HRESULT CContainerCookie::Commit()
{
    ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
        CERTMGR_CTL_CONTAINER == m_objecttype ||
        CERTMGR_CERT_CONTAINER == m_objecttype);
    CCertMgrCookie::Commit ();

    return m_rCertStore.Commit ();
}



///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CUsageCookie::CUsageCookie (
        CertificateManagerObjectType objecttype,
        LPCWSTR lpcszMachineName,
        LPCWSTR objectName)
: CCertMgrCookie (objecttype, lpcszMachineName, objectName),
    m_OIDListPos (0),
    m_nCertCount (0)
{
    ASSERT (CERTMGR_USAGE == m_objecttype);
}

CUsageCookie::~CUsageCookie ()
{
    ASSERT (CERTMGR_USAGE == m_objecttype);
    LPSTR   pszOID = 0;
    while ( !m_OIDList.IsEmpty () )
    {
        pszOID = m_OIDList.RemoveHead ();
        ASSERT (pszOID);
        if ( pszOID )
            delete [] pszOID;
    }
}

void CUsageCookie::AddOID (LPCSTR pszNewOID)
{
    ASSERT (pszNewOID);
    if ( !pszNewOID )
        return;

    ASSERT (CERTMGR_USAGE == m_objecttype);
    // security review 2/27/2002 BryanWal ok - the OID comes from CryptoAPI
    size_t cchNewOID = strlen (pszNewOID);
    LPSTR   pszOID = new char[cchNewOID+1];
    if ( pszOID )
    {
        // security review 2/27/2002 BryanWal ok
        ::ZeroMemory (pszOID, cchNewOID + 1);
        // security review 2/27/2002 BryanWal
        strcpy (pszOID, pszNewOID);
        m_OIDList.AddTail (pszOID);
    }
}

LPSTR CUsageCookie::GetFirstOID ()
{
    ASSERT (CERTMGR_USAGE == m_objecttype);
    LPSTR   pszOID = 0;

    m_OIDListPos = m_OIDList.GetHeadPosition ();
    if ( m_OIDListPos )
        pszOID = m_OIDList.GetNext (m_OIDListPos);

    return pszOID;
}

LPSTR CUsageCookie::GetNextOID ()
{
    ASSERT (CERTMGR_USAGE == m_objecttype);
    LPSTR   pszOID = 0;

    if ( m_OIDListPos )
        pszOID = m_OIDList.GetNext (m_OIDListPos);

    return pszOID;
}

int CUsageCookie::GetOIDCount () const
{
    ASSERT (CERTMGR_USAGE == m_objecttype);
    return (int)m_OIDList.GetCount ();
}

void CUsageCookie::SetCertCount(int nCertCount)
{
    m_nCertCount = nCertCount;
}

int CUsageCookie::GetCertCount() const
{
    return m_nCertCount;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
SPECIAL_STORE_TYPE GetSpecialStoreType (PCWSTR pwszStoreName)
{
    ASSERT (pwszStoreName);
    if ( !pwszStoreName )
        return NO_SPECIAL_TYPE;

    SPECIAL_STORE_TYPE  storeType = NO_SPECIAL_TYPE;

    // security review 2/27/2002 BryanWal ok
    if ( !_wcsicmp (pwszStoreName, MY_SYSTEM_STORE_NAME) )
        storeType = MY_STORE;
    else if ( !_wcsicmp (pwszStoreName, CA_SYSTEM_STORE_NAME) )
        storeType = CA_STORE;
    else if ( !_wcsicmp (pwszStoreName, ROOT_SYSTEM_STORE_NAME) )
        storeType = ROOT_STORE;
    else if ( !_wcsicmp (pwszStoreName, TRUST_SYSTEM_STORE_NAME) )
        storeType = TRUST_STORE;
    else if ( !_wcsicmp (pwszStoreName, USERDS_SYSTEM_STORE_NAME) )
        storeType = USERDS_STORE;
    else if ( !_wcsicmp (pwszStoreName, ACRS_SYSTEM_STORE_NAME) )
        storeType = ACRS_STORE;
    else if ( !_wcsicmp (pwszStoreName, REQUEST_SYSTEM_STORE_NAME) )
        storeType = REQUEST_STORE;
    else
    {
        // The stores might be concatenated with machine or services names.
        // Check for the token preceded by a slash.
        CString revStoreName (pwszStoreName);
        revStoreName.MakeReverse ();
        revStoreName.MakeUpper ();
        CString revToken (MY_SYSTEM_STORE_NAME);
        revToken.MakeReverse ();
        revToken += L"\\";
        
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = MY_STORE;
            goto Found;
        }

        revToken = CA_SYSTEM_STORE_NAME;
        revToken.MakeReverse ();
        revToken += L"\\";
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = CA_STORE;
            goto Found;
        }

        revToken = ROOT_SYSTEM_STORE_NAME;
        revToken.MakeReverse ();
        revToken += L"\\";
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = ROOT_STORE;
            goto Found;
        }

        revToken = TRUST_SYSTEM_STORE_NAME;
        revToken.MakeReverse ();
        revToken += L"\\";
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = TRUST_STORE;
            goto Found;
        }

        revToken = USERDS_SYSTEM_STORE_NAME;
        revToken.MakeReverse ();
        revToken += L"\\";
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = USERDS_STORE;
            goto Found;
        }

        revToken = ACRS_SYSTEM_STORE_NAME;
        revToken.MakeReverse ();
        revToken += L"\\";
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = ACRS_STORE;
            goto Found;
        }

        revToken = REQUEST_SYSTEM_STORE_NAME;
        revToken.MakeReverse ();
        revToken += L"\\";
        if ( 0 == revStoreName.Find (revToken) )
        {
            storeType = REQUEST_STORE;
            goto Found;
        }
    }

Found:

    return storeType;
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CEnrollmentNodeCookie::CEnrollmentNodeCookie (
        CertificateManagerObjectType    objecttype,
        LPCWSTR                         objectName,
        IGPEInformation*                pGPEInformation)
    : CCertMgrCookie (objecttype, 0, objectName),
    m_pGPEInformation (pGPEInformation)
{
    if ( m_pGPEInformation )
        m_pGPEInformation->AddRef ();
}

CEnrollmentNodeCookie::~CEnrollmentNodeCookie ()
{
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}

IGPEInformation* CEnrollmentNodeCookie::GetGPEInformation ()
{
    return m_pGPEInformation;
}

void CCertMgrCookie::Refresh()
{

}


SPECIAL_STORE_TYPE StoreNameToType (const CString& szStoreName)
{
    SPECIAL_STORE_TYPE  type = NO_SPECIAL_TYPE;

    if ( szStoreName == ACRS_SYSTEM_STORE_NAME )
        type = ACRS_STORE;
    else if ( szStoreName == ROOT_SYSTEM_STORE_NAME )
        type = ROOT_STORE;
    else if ( szStoreName == TRUST_SYSTEM_STORE_NAME )
        type = TRUST_STORE;
    else if ( szStoreName == EFS_SYSTEM_STORE_NAME )
        type  = EFS_STORE;
    else if ( szStoreName == SAFER_TRUSTED_PUBLISHER_STORE_NAME )
        type = SAFER_TRUSTED_PUBLISHER_STORE;
    else if ( szStoreName == SAFER_DISALLOWED_STORE_NAME )
        type = SAFER_DISALLOWED_STORE;

    return type;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\cookie.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       cookie.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CCertMgrComponent::Initialize)


#include "nodetype.h"
#pragma warning(push,3)
#include <efsstruc.h>
#pragma warning(pop)

// Name of Encrypting File System store
#define ACRS_SYSTEM_STORE_NAME      L"ACRS"
#define EFS_SYSTEM_STORE_NAME       L"EFS"
#define TRUST_SYSTEM_STORE_NAME     L"Trust"
#define ROOT_SYSTEM_STORE_NAME      L"Root"
#define MY_SYSTEM_STORE_NAME        L"MY"
#define CA_SYSTEM_STORE_NAME        L"CA"
#define USERDS_SYSTEM_STORE_NAME    L"UserDS"
#define REQUEST_SYSTEM_STORE_NAME   L"REQUEST"
#define SAFER_TRUSTED_PUBLISHER_STORE_NAME  L"TrustedPublisher"
#define SAFER_DISALLOWED_STORE_NAME         L"Disallowed"



/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.


class CCertificate; // forward declaration

class CCertMgrCookie : public CCookie,
                        public CStoresMachineName,
                        public CBaseCookieBlock
{
public:
    CCertMgrCookie (CertificateManagerObjectType objecttype,
            LPCWSTR lpcszMachineName = 0,
            LPCWSTR objectName = 0);

    virtual ~CCertMgrCookie ();

    // returns <0, 0 or >0
    virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult );
    
// CBaseCookieBlock
    virtual CCookie* QueryBaseCookie(int i);
    virtual int QueryNumCookies();

public:
    bool IsSelected () const;
    void SetSelected (bool bIsSelected);
    LPRESULTDATA m_resultDataID;
    virtual void Refresh ();
    virtual HRESULT Commit ();
    CString GetServiceName () const;
    void SetServiceName (CString &szManagedService);
    LPCWSTR GetObjectName ();
    const CertificateManagerObjectType m_objecttype;
    UINT    IncrementOpenPageCount ();
    UINT    DecrementOpenPageCount ();
    bool    HasOpenPropertyPages () const;

private:
    bool m_bIsSelected;
    CString m_objectName;
    UINT    m_nOpenPageCount;
};

typedef enum {
    NO_SPECIAL_TYPE = 0,
    MY_STORE,
    CA_STORE,
    ROOT_STORE,
    TRUST_STORE,
    USERDS_STORE,
    ACRS_STORE,
    EFS_STORE,
    REQUEST_STORE,
    SAFER_TRUSTED_PUBLISHER_STORE,
    SAFER_DISALLOWED_STORE
} SPECIAL_STORE_TYPE;
SPECIAL_STORE_TYPE GetSpecialStoreType(PCWSTR pwszStoreName);

SPECIAL_STORE_TYPE StoreNameToType (const CString& szStoreName);

class CCTL; // forward declaration
class CCertStore : public CCertMgrCookie
{
    friend CCTL;
public:
    virtual bool IsNullEFSPolicy()
    {
        return false;
    }
    void IncrementCertCount ();
    void Unlock ();
    void Lock ();
    void InvalidateCertCount();
    BOOL AddEncodedCTL (DWORD dwMsgAndCertEncodingType, 
            const BYTE* pbCtlEncoded, 
            DWORD cbCtlEncoded, 
            DWORD dwAddDisposition, 
            PCCTL_CONTEXT* ppCtlContext);
    virtual void Close (bool bForceClose = false);
    void SetDirty();
    HRESULT AddStoreToCollection(CCertStore& siblingStore, 
            DWORD dwUpdateFlags = 0, 
            DWORD dwPriority = 0);
    HRESULT AddStoreToCollection(HCERTSTORE hSiblingStore, 
            DWORD dwUpdateFlags = 0, 
            DWORD dwPriority = 0);
    int GetCTLCount ();
    inline DWORD GetLocation () { return m_dwLocation;}
    HRESULT Resync ();
    inline bool IsOpen()
    {
        // If m_hCertStore is 0, then this store hasn't been used for anything
        if ( !m_hCertStore )
            return false;
        else
            return true;
    }

    PCCRL_CONTEXT GetCRL (
                        PCCERT_CONTEXT pIssuerContext, 
                        PCCRL_CONTEXT pPrevCrlContext, 
                        DWORD* pdwFlags);
    bool AddCTLContext (PCCTL_CONTEXT pCtlContext);
    bool AddCRLContext (PCCRL_CONTEXT pCrlContext);
    PCCERT_CONTEXT FindCertificate (
                        DWORD dwFindFlags, 
                        DWORD dwFindType, 
                        const void *pvFindPara, 
                        PCCERT_CONTEXT pPrevCertContext);
    PCCRL_CONTEXT EnumCRLs (PCCRL_CONTEXT pPrevCrlContext);
    PCCTL_CONTEXT EnumCTLs (PCCTL_CONTEXT pPrevCtlContext);
    virtual PCCERT_CONTEXT EnumCertificates (PCCERT_CONTEXT pPrevCertContext);
    CCertificate* GetSubjectCertificate (PCERT_INFO pCertId);
    BOOL operator==(CCertStore&);
    int GetCertCount ();
    virtual HRESULT AddCertificateContext (
                PCCERT_CONTEXT pContext, 
                LPCONSOLE pConsole, 
                bool bDeletePrivateKey,
                PCCERT_CONTEXT* ppNewCertContext = 0,
                bool* pbCertWasReplaced = false);
    inline virtual void AddRef()
    {
        ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
                CERTMGR_LOG_STORE_RSOP == m_objecttype ||
                CERTMGR_LOG_STORE == m_objecttype ||
                CERTMGR_PHYS_STORE == m_objecttype);
        CCertMgrCookie::AddRef ();
    }

    inline virtual void Release ()
    {
        ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
                CERTMGR_LOG_STORE_RSOP == m_objecttype ||
                CERTMGR_LOG_STORE == m_objecttype ||
                CERTMGR_PHYS_STORE == m_objecttype);
        CCertMgrCookie::Release ();
    }

    CString GetStoreName () const;
    LPCWSTR GetLocalizedName();
    bool ContainsCTLs ();
    bool ContainsCRLs ();
    bool ContainsCertificates ();
    virtual HRESULT Commit ();
    virtual bool IsReadOnly ();
    inline const SPECIAL_STORE_TYPE GetStoreType () const
    {
        ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype ||
                CERTMGR_LOG_STORE_RSOP == m_objecttype ||
                CERTMGR_LOG_STORE == m_objecttype ||
                CERTMGR_PHYS_STORE == m_objecttype);
        return m_storeType;
    }

    CCertStore (CertificateManagerObjectType objecttype,
            LPCSTR pszStoreProv, 
            DWORD dwFlags, 
            LPCWSTR lpcszMachineName, 
            LPCWSTR objectName, 
            const CString & pcszLogStoreName, 
            const CString & pcszPhysStoreName,
            const SPECIAL_STORE_TYPE storeType,
            const DWORD dwLocation,
            IConsole* pConsole,
            bool  fIsComputerType = false);
    virtual ~CCertStore ();
    virtual HCERTSTORE  GetStoreHandle (BOOL bSilent = FALSE, HRESULT* phr = 0);
    virtual bool CanContain (CertificateManagerObjectType /*nodeType*/)
    {
        return false;
    }

    virtual bool IsMachineStore()
    {
        return false;
    }

    virtual bool IsComputerType ()
    {
        return m_fIsComputerType;
    }

    virtual void SetAdding ()
    {
    }
    virtual void SetDeleting ()
    {
    }

protected:
    virtual void FinalCommit();
    HRESULT RetrieveBLOBFromFile (LPCWSTR pwszFileName, DWORD *pcb, BYTE **ppb);

    bool        m_fCertCountValid;
    bool        m_bUnableToOpenMsgDisplayed;
    LPCSTR      m_storeProvider;
    DWORD       m_dwFlags;
    CString     m_pcszStoreName;
    bool        m_bReadOnly;
    HCERTSTORE  m_hCertStore;
    IConsole*   m_pConsole;
    bool        m_bDirty;
    bool        m_fIsComputerType;

private:
    int         m_nCertCount;
    bool        m_fReadOnlyFlagChecked;
    const DWORD m_dwLocation;
    CString     m_localizedName;
    const SPECIAL_STORE_TYPE    m_storeType;
    int         m_nLockCnt; // test
};


class CContainerCookie : public CCertMgrCookie
{
public:
    virtual HRESULT Commit ();
    inline const SPECIAL_STORE_TYPE GetStoreType () const
    {
        ASSERT (CERTMGR_CRL_CONTAINER == m_objecttype ||
            CERTMGR_CTL_CONTAINER == m_objecttype ||
            CERTMGR_CERT_CONTAINER == m_objecttype);
        return m_rCertStore.GetStoreType ();
    }

    CContainerCookie (CCertStore& rStore, 
        CertificateManagerObjectType objecttype, 
        LPCWSTR lpcszMachineName, 
        LPCWSTR objectName);
    virtual ~CContainerCookie ();
    CCertStore& GetCertStore () const;
private:
    CCertStore&  m_rCertStore;
};


class CUsageCookie : public CCertMgrCookie
{
public:
    int GetCertCount () const;
    void SetCertCount (int nCertCount);
    CUsageCookie ( 
        CertificateManagerObjectType objecttype, 
        LPCWSTR lpcszMachineName, 
        LPCWSTR objectName);
    void    AddOID (LPCSTR pszOID);
    virtual ~CUsageCookie ();
    LPSTR   GetFirstOID ();
    LPSTR   GetNextOID ();
    int     GetOIDCount () const;

private:
    int m_nCertCount;
    CTypedPtrList<CPtrList, LPSTR>  m_OIDList;
    POSITION                        m_OIDListPos;
};

#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\crl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       CRL.cpp
//
//  Contents:   implementation of the CCRL class.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "CRL.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCRL::CCRL(const PCCRL_CONTEXT pCRLContext, CCertStore& rCertStore) :
    CCertMgrCookie (CERTMGR_CRL),
    m_pCRLContext (::CertDuplicateCRLContext (pCRLContext)),
    m_rCertStore (rCertStore),
    m_pCRLInfo (0)
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    m_rCertStore.AddRef ();
    ASSERT (m_pCRLContext);
    if ( m_pCRLContext )
        m_pCRLInfo = m_pCRLContext->pCrlInfo;
}

CCRL::~CCRL()
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    m_rCertStore.Release ();
    if ( m_pCRLContext )
        ::CertFreeCRLContext (m_pCRLContext);
}

PCCRL_CONTEXT CCRL::GetCRLContext() const
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    return m_pCRLContext;
}

CCertStore& CCRL::GetCertStore() const  
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    return m_rCertStore;
}

CString CCRL::GetIssuerName ()
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    ASSERT (m_pCRLInfo);
    if ( m_pCRLInfo )
    {
        // Decode issuer name if not already present
        if ( m_szIssuerName.IsEmpty () )
        {
            HRESULT hResult = ConvertNameBlobToString (m_pCRLInfo->Issuer, 
                    m_szIssuerName);
            if ( !SUCCEEDED (hResult) )
                return _T("");
        }
    }
    else
        return _T("");


    return m_szIssuerName;
}

CString CCRL::GetEffectiveDate()
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    ASSERT (m_pCRLInfo);
    if ( m_pCRLInfo )
    {
        // Format date/time string if not already present
        if ( m_szEffectiveDate.IsEmpty () )
        {
            HRESULT hResult = FormatDate (m_pCRLInfo->ThisUpdate, m_szEffectiveDate);
            if ( !SUCCEEDED (hResult) )
                m_szEffectiveDate = _T("");
        }
    }
    else
        m_szEffectiveDate = _T("");

    return m_szEffectiveDate;
}

CString CCRL::GetNextUpdate()
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    ASSERT (m_pCRLInfo);
    if ( m_pCRLInfo )
    {
        // Format date/time string if not already present
        if ( m_szNextUpdate.IsEmpty () )
        {
            HRESULT hResult = FormatDate (m_pCRLInfo->NextUpdate, m_szNextUpdate);
            if ( !SUCCEEDED (hResult) )
                m_szNextUpdate = _T("");
        }
    }
    else
        m_szNextUpdate = _T("");

    return m_szNextUpdate;
}


int CCRL::CompareEffectiveDate (const CCRL& crl) const
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    int compVal = 0;

    ASSERT (m_pCRLInfo && crl.m_pCRLInfo);
    if ( m_pCRLInfo && crl.m_pCRLInfo )
    {
        compVal = ::CompareFileTime (&m_pCRLInfo->ThisUpdate, 
                &crl.m_pCRLInfo->ThisUpdate);
    }

    return compVal;
}

int CCRL::CompareNextUpdate (const CCRL& crl) const
{
    ASSERT (CERTMGR_CRL == m_objecttype);
    int compVal = 0;

    ASSERT (m_pCRLInfo && crl.m_pCRLInfo);
    if ( m_pCRLInfo && crl.m_pCRLInfo )
    {
        compVal = ::CompareFileTime (&m_pCRLInfo->NextUpdate, 
                &crl.m_pCRLInfo->NextUpdate);
    }

    return compVal;
}

void CCRL::Refresh()
{
    m_szEffectiveDate = L"";
    m_szIssuerName = L"";
    m_szNextUpdate = L"";
}

BOOL CCRL::DeleteFromStore()
{
    BOOL    bResult = FALSE;
    ASSERT (m_pCRLContext);
    if ( m_pCRLContext )
    {
        bResult = ::CertDeleteCRLFromStore (
                ::CertDuplicateCRLContext (m_pCRLContext));
        if ( bResult )
            m_rCertStore.SetDirty ();
    }

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\componentsafer.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:         cmponent.cpp
//
//  Contents:   Implementation of CCertMgrComponent
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <gpedit.h>
#include "compdata.h" // CCertMgrComponentData
#include "cmponent.h" // CCertMgrComponent
#include "SaferLevel.h"
#include "SaferEntry.h"
#include "storeGPE.h"
#include "SaferUtil.h"
#include "PolicyKey.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

HKEY g_hkeyLastSaferRegistryScope = 0;
extern PCWSTR pcszNEWLINE;


HRESULT CCertMgrComponent::AddSaferLevels(
        bool bIsComputer, 
        PCWSTR pszServerName,
        HKEY hGroupPolicyKey)
{
    _TRACE (1, L"Entering CCertMgrComponent::AddSaferLevels ()\n");
    HRESULT         hr = S_OK;
    CWaitCursor     cursor;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();

    if ( dataRef.m_pdwSaferLevels )
    {
        for (UINT nIndex = 0; 
                NO_MORE_SAFER_LEVELS != dataRef.m_pdwSaferLevels[nIndex] && SUCCEEDED (hr); 
                nIndex++)
        {
            CString         szLevel;

            switch (dataRef.m_pdwSaferLevels[nIndex])
            {
            case SAFER_LEVELID_FULLYTRUSTED:
            case SAFER_LEVELID_CONSTRAINED:
            case SAFER_LEVELID_DISALLOWED:
            case SAFER_LEVELID_NORMALUSER:
            case SAFER_LEVELID_UNTRUSTED:
                szLevel = SaferGetLevelFriendlyName (dataRef.m_pdwSaferLevels[nIndex], 
                        hGroupPolicyKey, bIsComputer);
                hr = AddLevel (szLevel, dataRef.m_pdwSaferLevels[nIndex], 
                        bIsComputer,
                        pszServerName);
                break;

            default:
                ASSERT (0);
                _TRACE (0, L"Unexpected safer level while enumerating levels: 0x%x\n", 
                        dataRef.m_pdwSaferLevels[nIndex]);
                break;
            }
        }
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertMgrComponent::AddSaferLevels (): 0x%x\n", hr);
    return hr;
}



HRESULT CCertMgrComponent::AddLevel (
            const CString& szLevel, 
            DWORD dwLevel, 
            bool fIsMachine, 
            PCWSTR pszServerName)
{
    _TRACE (1, L"Entering CCertMgrComponent::AddLevel ()\n");
    HRESULT         hr = S_OK;
    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
    CCookie&        rootCookie = dataRef.QueryBaseRootCookie ();


    RESULTDATAITEM  rdItem;
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&rdItem, sizeof (rdItem));
    rdItem.mask = RDI_STR | RDI_PARAM | RDI_IMAGE;
    rdItem.nCol = 0;

    CSaferLevel*    pNewLevel = new CSaferLevel (
            dwLevel,
            fIsMachine,
            pszServerName,
            szLevel,
            dataRef.m_pGPEInformation,
            fIsMachine ?
                dataRef.m_rsopObjectArrayComputer :
                dataRef.m_rsopObjectArrayUser);
    if ( pNewLevel )
    {
        if ( pNewLevel->IsDefault () )
        {
            rdItem.nImage = iIconDefaultSaferLevel;
            dataRef.m_dwDefaultSaferLevel = pNewLevel->GetLevel ();
        }
        else
            rdItem.nImage = iIconSaferLevel;
        rootCookie.m_listResultCookieBlocks.AddHead (pNewLevel);
        rdItem.str = MMC_TEXTCALLBACK ;
        rdItem.lParam = (LPARAM) pNewLevel;
        pNewLevel->m_resultDataID = m_pResultData;
        hr = m_pResultData->InsertItem (&rdItem);
        if ( FAILED (hr) )
        {
             _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    _TRACE (-1, L"Leaving CCertMgrComponent::AddLevel () : 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferEnumerateEntries (
            bool bIsComputer, 
            CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateEntries ()\n");
    HRESULT hr = S_OK;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
   
    if ( dataRef.m_pGPEInformation )
    {
        CPolicyKey policyKey (dataRef.m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                bIsComputer);
        hr = SetRegistryScope (policyKey.GetKey (), bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            hr = SaferEnumerateNonCertEntries (policyKey.GetKey (), 
                    bIsComputer);

            hr = SaferEnumerateCertEntries (
                    bIsComputer, 
                    pSaferEntries);
        }
    }
    else if ( dataRef.m_bIsRSOP )
    {
        hr = SaferEnumerateRSOPNonCertEntries (bIsComputer, pSaferEntries);

        hr = SaferEnumerateCertEntries (bIsComputer, 
                pSaferEntries);
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateEntries () : 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::SaferEnumerateRSOPNonCertEntries (
        bool bIsComputer, 
        CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateRSOPNonCertEntries\n");
    HRESULT                 hr = S_OK;
    int                     nIndex = 0;
    CCertMgrComponentData&  dataRef = QueryComponentDataRef ();
    CString                 szKeyStart (SAFER_HKLM_REGBASE);
    const CRSOPObjectArray* pObjectArray = bIsComputer ?
        dataRef.GetRSOPObjectArrayComputer () : dataRef.GetRSOPObjectArrayUser ();
    INT_PTR                 nUpperBound = pObjectArray->GetUpperBound ();

    szKeyStart += L"\\";
    szKeyStart += SAFER_CODEIDS_REGSUBKEY;
    // security review 2/22/2002 BryanWal ok
    size_t  nKeyStartLen = wcslen (szKeyStart);

    // Skip the common text and get the level
    long                dwLevel = 0;
    long                dwPreviousLevel = 0;
    CString             szLevel;
    CString             szType;   // hash, url, path
    SAFER_ENTRY_TYPE    type = SAFER_ENTRY_TYPE_UNKNOWN;    // hash, url, path
    SAFER_ENTRY_TYPE    previousType = SAFER_ENTRY_TYPE_UNKNOWN;
    CString             szGUID;
    GUID                guid;
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&guid, sizeof (guid));
    bool                bCreateNew = false;
    PSAFER_IDENTIFICATION_HEADER   pCaiCommon = 0;
    CString             szPreviousKey;
    CString             szKey;
    CRSOPObject* pCurrObject = 0;


    while ( nUpperBound >= nIndex )
    {
        if ( pCurrObject )
            szPreviousKey = pCurrObject->GetRegistryKey ();

        pCurrObject = pObjectArray->GetAt (nIndex);
        if ( pCurrObject )
        {
            szKey = pCurrObject->GetRegistryKey ();
            // security review 2/22/2002 BryanWal ok
            if ( !_wcsnicmp (szKey, szKeyStart, nKeyStartLen) )
            {
                // security review 2/22/2002 BryanWal ok
                szKey = szKey.Right ((int) (wcslen (szKey) - (nKeyStartLen + 1)));

                if ( !szKey.IsEmpty () )
                {
                    // get level
                    int nPos = szKey.Find (L'\\');
                    szLevel = szKey.Left (nPos);
                    dwPreviousLevel = dwLevel;
                    dwLevel = wcstol(szLevel, 0, 10);
                    // security review 2/22/2002 BryanWal ok
                    szKey = szKey.Right ((int)(wcslen (szKey) - (nPos + 1)));

                    // get type
                    nPos = szKey.Find (L'\\');
                    szType = szKey.Left (nPos);
                    if ( SAFER_PATHS_REGSUBKEY == szType )
                        type = SAFER_ENTRY_TYPE_PATH;
                    else if ( SAFER_HASHMD5_REGSUBKEY == szType )
                        type = SAFER_ENTRY_TYPE_HASH;
                    else if ( SAFER_SOURCEURL_REGSUBKEY == szType )
                        type = SAFER_ENTRY_TYPE_URLZONE;
                    else
                    {
                        ASSERT (0);
                    }

                    if ( SAFER_ENTRY_TYPE_UNKNOWN == previousType )
                        previousType = type;

                    // security review 2/22/2002 BryanWal ok
                    szKey = szKey.Right ((int) (wcslen (szKey) - (nPos + 1)));
                    
                    // get guid
                    if ( szKey != szGUID )
                    {
                        szGUID = szKey;
                        if ( !GuidFromString (&guid, szGUID) )
                            continue;

                        bCreateNew = true;
                    }
                    else
                        bCreateNew = false;

                    if ( bCreateNew && pCaiCommon )
                    {
                        // If we were working on an old one, create the 
                        // CSaferEntry with the available information and add 
                        // it to the result pane
                        hr = SaferFinishEntryAndAdd (previousType, pCaiCommon,
                                bIsComputer, dwPreviousLevel, pSaferEntries, 
                                szPreviousKey);
                        if ( SUCCEEDED (hr) )
                        {
                            pCaiCommon = 0;
                        }
                        else if ( E_OUTOFMEMORY == hr )
                        {
                            ::LocalFree (pCaiCommon);
                            pCaiCommon = 0;
                        }


                        previousType = type;
                    }

                    switch (type)
                    {
                    case SAFER_ENTRY_TYPE_PATH:
                        if ( bCreateNew )
                        {
                            ASSERT (!pCaiCommon);
                            pCaiCommon = (PSAFER_IDENTIFICATION_HEADER) 
                                ::LocalAlloc (LPTR, sizeof (SAFER_PATHNAME_IDENTIFICATION));
                            if ( pCaiCommon )
                            {
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.cbStructSize = 
                                        sizeof (SAFER_PATHNAME_IDENTIFICATION);
                                // security review 2/22/2002 BryanWal ok
                                memcpy (&((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid, 
                                        &guid, sizeof (((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid));
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.dwIdentificationType = 
                                        SaferIdentityTypeImageName;
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        
                        if ( SUCCEEDED (hr) && pCaiCommon )
                        {
                            if ( SAFER_IDS_DESCRIPTION_REGVALUE == pCurrObject->GetValueName () )
                            {
                                BSTR    bstr = 0;
                                if ( SUCCEEDED (pCurrObject->GetBSTR (&bstr)) )
                                {
                                    // security review 2/22/2002 BryanWal ok
                                    // security review 2/22/2002 BryanWal ok
                                    // will be null-terminated since 
                                    // length of bstr is less than target
                                    // buffer
                                    if ( SysStringLen (bstr) < SAFER_MAX_DESCRIPTION_SIZE)
                                    {
                                        wcsncpy (((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->Description, 
                                                bstr, 
                                                SAFER_MAX_DESCRIPTION_SIZE);
                                    }
                                    else
                                    {
                                        ASSERT (0);
                                    }
                                    SysFreeString (bstr);
                                }
                            }
                            else if ( SAFER_IDS_ITEMDATA_REGVALUE == pCurrObject->GetValueName () )
                            {
                                if ( MAX_PATH * sizeof (WCHAR) >= pCurrObject->GetBlobLength () )
                                {
                                    ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->ImageName = 
                                            (PWCHAR) pCurrObject->GetBlob ();
                                }
                                else
                                {
                                    ASSERT (0);
                                }
                            }
                            else if ( SAFER_IDS_LASTMODIFIED_REGVALUE == pCurrObject->GetValueName () )
                            {
                                pCurrObject->GetFileTime (
                                        ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->header.lastModified);
                            }
                            else if ( SAFER_IDS_SAFERFLAGS_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->dwSaferFlags = 
                                        pCurrObject->GetDWORDValue ();
                            }
                        }
                        break;

                    case SAFER_ENTRY_TYPE_HASH:
                        if ( bCreateNew )
                        {
                            ASSERT (!pCaiCommon);
                            pCaiCommon = (PSAFER_IDENTIFICATION_HEADER) 
                                ::LocalAlloc (LPTR, sizeof (SAFER_HASH_IDENTIFICATION));
                            if ( pCaiCommon )
                            {
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.cbStructSize = 
                                        sizeof (SAFER_HASH_IDENTIFICATION);
                                // security review 2/22/2002 BryanWal ok
                                memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid, 
                                        &guid, sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid));
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.dwIdentificationType = 
                                        SaferIdentityTypeImageHash;
                                // NTRAID# 424997 SAFER:  File hash not displayed on hash rule property sheets in RSOP mode.
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashSize = 16;
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        
                        if ( SUCCEEDED (hr) && pCaiCommon && !pCurrObject->GetValueName ().IsEmpty () )
                        {
                            if ( SAFER_IDS_ITEMDATA_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ASSERT (SAFER_MAX_HASH_SIZE >= pCurrObject->GetBlobLength ());
                                // security review 2/22/2002 BryanWal ok
                                if ( pCurrObject->GetBlobLength () <= sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageHash) )
                                {
                                    ::ZeroMemory (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageHash,
                                            sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageHash));
                                    memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageHash, 
                                            pCurrObject->GetBlob (),
                                            pCurrObject->GetBlobLength ());
                                }
                                else
                                {
                                    ASSERT (0);
                                }
                            }
                            else if ( SAFER_IDS_LASTMODIFIED_REGVALUE == pCurrObject->GetValueName () )
                            {
                                pCurrObject->GetFileTime (
                                        ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->header.lastModified);
                            }
                            else if ( SAFER_IDS_SAFERFLAGS_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->dwSaferFlags = 
                                        pCurrObject->GetDWORDValue ();
                            }
                            else if ( SAFER_IDS_FRIENDLYNAME_REGVALUE == pCurrObject->GetValueName () )
                            {
                                BSTR    bstr = 0;
                                if ( SUCCEEDED (pCurrObject->GetBSTR (&bstr)) )
                                {
                                    if ( SysStringLen (bstr) < SAFER_MAX_FRIENDLYNAME_SIZE )
                                    {
                                        // security review 2/22/2002 BryanWal ok
                                        // will be null-terminated since 
                                        // length of bstr is less than target
                                        // buffer
                                        wcsncpy (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->FriendlyName,
                                                bstr,
                                                SAFER_MAX_FRIENDLYNAME_SIZE);
                                    }
                                    else
                                    {
                                        ASSERT (0);
                                    }
                                    SysFreeString (bstr);
                                }
                            }
                            else if ( SAFER_IDS_HASHALG_REGVALUE == pCurrObject->GetValueName () )
                            {
                                // security review 2/22/2002 BryanWal ok
                                ASSERT (sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashAlgorithm) 
                                        == pCurrObject->GetBlobLength ());
                                if ( sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashAlgorithm) 
                                        == pCurrObject->GetBlobLength () )
                                {
                                    memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashAlgorithm, 
                                            pCurrObject->GetBlob (),
                                            pCurrObject->GetBlobLength ());
                                }
                            }
                            else if ( SAFER_IDS_ITEMSIZE_REGVALUE == pCurrObject->GetValueName () )
                            {
                                // security review 2/22/2002 BryanWal ok
                                ASSERT (sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageSize) 
                                        == pCurrObject->GetBlobLength ());
                                if ( sizeof (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageSize) 
                                        == pCurrObject->GetBlobLength () )
                                {
                                    memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->ImageSize, 
                                            pCurrObject->GetBlob (),
                                            pCurrObject->GetBlobLength ());
                                }
                            }
                            else if ( SAFER_IDS_DESCRIPTION_REGVALUE == pCurrObject->GetValueName () )
                            {
                                BSTR    bstr = 0;
                                if ( SUCCEEDED (pCurrObject->GetBSTR (&bstr)) )
                                {
                                    // security review 2/22/2002 BryanWal ok
                                    // security review 2/22/2002 BryanWal ok
                                    // will be null-terminated since 
                                    // length of bstr is less than target
                                    // buffer
                                    if ( SysStringLen (bstr) < SAFER_MAX_DESCRIPTION_SIZE )
                                    {
                                        wcsncpy (((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->Description, 
                                                bstr, 
                                                SAFER_MAX_DESCRIPTION_SIZE);
                                    }
                                    else
                                    {
                                        ASSERT (0);
                                    }
                                    SysFreeString (bstr);
                                }
                            }
                            else if ( SAFER_VALUE_NAME_HASH_SIZE == pCurrObject->GetValueName () )
                            {
                                ASSERT (sizeof (LARGE_INTEGER) == pCurrObject->GetBlobLength ());
                                if ( sizeof (LARGE_INTEGER) == pCurrObject->GetBlobLength () )
                                {
                                    // security review 2/22/2002 BryanWal ok
                                    memcpy (&((SAFER_HASH_IDENTIFICATION*)pCaiCommon)->HashSize, 
                                            pCurrObject->GetBlob (),
                                            pCurrObject->GetBlobLength ());
                                }
                                else
                                {
                                    ASSERT (0);
                                }
                            }

                        }
                        break;

                    case SAFER_ENTRY_TYPE_URLZONE:
                        if ( bCreateNew )
                        {
                            ASSERT (!pCaiCommon);
                            pCaiCommon = (PSAFER_IDENTIFICATION_HEADER) 
                                ::LocalAlloc (LPTR, sizeof (SAFER_URLZONE_IDENTIFICATION));
                            if ( pCaiCommon )
                            {
                                ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.cbStructSize = 
                                        sizeof (SAFER_URLZONE_IDENTIFICATION);
                                // security review 2/22/2002 BryanWal ok
                                memcpy (&((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.IdentificationGuid, 
                                        &guid, sizeof (GUID));
                                ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.dwIdentificationType = 
                                        SaferIdentityTypeUrlZone;
                            }
                            else
                                hr = E_OUTOFMEMORY;
                        }
                        
                        if ( SUCCEEDED (hr) && pCaiCommon )
                        {
                            if ( SAFER_IDS_ITEMDATA_REGVALUE == pCurrObject->GetValueName () )
                            {
                                if ( pCurrObject->GetBlobLength () == sizeof (((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->UrlZoneId) )
                                {
                                    // security review 2/22/2002 BryanWal ok
                                    memcpy (&((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->UrlZoneId, 
                                        pCurrObject->GetBlob (),
                                        pCurrObject->GetBlobLength ());
                                }
                                else
                                {
                                    ASSERT (0);
                                }
#if DBG
                                SAFER_URLZONE_IDENTIFICATION* pCaiUrlZone = 
                                            (SAFER_URLZONE_IDENTIFICATION*) pCaiCommon;
                                ASSERT (URLZONE_LOCAL_MACHINE == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_INTRANET == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_TRUSTED == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_INTERNET == pCaiUrlZone->UrlZoneId ||
                                        URLZONE_UNTRUSTED == pCaiUrlZone->UrlZoneId);
#endif DBG
                            }
                            else if ( SAFER_IDS_LASTMODIFIED_REGVALUE == pCurrObject->GetValueName () )
                            {
                                pCurrObject->GetFileTime (
                                        ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->header.lastModified);
                            }
                            else if ( SAFER_IDS_SAFERFLAGS_REGVALUE == pCurrObject->GetValueName () )
                            {
                                ((SAFER_URLZONE_IDENTIFICATION*)pCaiCommon)->dwSaferFlags = 
                                        pCurrObject->GetDWORDValue ();
                            }
                        }
                        break;

                    default:
                        ASSERT (0);
                        break;
                    }
                }
            }
        }
        else
            break;
        nIndex++;
    }

    if ( pCaiCommon )
    {
        // If we were working on an old one, create the 
        // CSaferEntry with the available information and add 
        // it to the result pane
        hr = SaferFinishEntryAndAdd (previousType, pCaiCommon,
                bIsComputer, dwLevel, pSaferEntries, 
                szPreviousKey);
        if ( SUCCEEDED (hr) )
        {
            pCaiCommon = 0;
        }
        else if ( E_OUTOFMEMORY == hr )
        {
            ::LocalFree (pCaiCommon);
            pCaiCommon = 0;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateRSOPNonCertEntries: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::SaferFinishEntryAndAdd (SAFER_ENTRY_TYPE previousType, 
            PSAFER_IDENTIFICATION_HEADER pCaiCommon, 
            bool bIsComputer, 
            long dwLevel,
            CSaferEntries* pSaferEntries, 
            const CString& szPreviousKey)
{
    HRESULT hr = S_OK;
    CString szSubjectName; 
    switch (previousType)
    {
    case SAFER_ENTRY_TYPE_PATH:
        szSubjectName = ((SAFER_PATHNAME_IDENTIFICATION*)pCaiCommon)->ImageName;
        break;

    case SAFER_ENTRY_TYPE_HASH:
        szSubjectName = ((PSAFER_HASH_IDENTIFICATION) (pCaiCommon))->FriendlyName;
        szSubjectName.Replace (pcszNEWLINE, L"  ");
        break;

    case SAFER_ENTRY_TYPE_URLZONE:
        szSubjectName = GetURLZoneFriendlyName (
                ((SAFER_URLZONE_IDENTIFICATION*) pCaiCommon)->UrlZoneId);
        break;

    default:
        ASSERT (0);
        break;
    }

    ASSERT (pCaiCommon);
    if ( pCaiCommon )
    {
        hr = InsertNewSaferEntry (
                previousType, 
                bIsComputer, 
                szSubjectName,
                pCaiCommon,
                dwLevel,
                pSaferEntries,
                QueryComponentDataRef ().m_pGPEInformation,
                0,
                szPreviousKey);
    }
    return hr; 
}


HRESULT CCertMgrComponent::InsertNewSaferEntry (
        SAFER_ENTRY_TYPE type, 
        bool bIsComputer, 
        PCWSTR pwcszObjectName, 
        PSAFER_IDENTIFICATION_HEADER pCaiCommon,
        DWORD dwLevel,
        CSaferEntries* pSaferEntries,
        IGPEInformation* pGPEInformation,
        CCertificate* pCert,
        PCWSTR pszRSOPRegistryKey)
{
    _TRACE (1, L"Entering CCertMgrComponent::InsertNewSaferEntry (%s)\n", pwcszObjectName);
    HRESULT hr = S_OK;

    switch (type)
    {
    case SAFER_ENTRY_TYPE_PATH:
        ASSERT (pCaiCommon && 
                SaferIdentityTypeImageName == pCaiCommon->dwIdentificationType);
        break;

    case SAFER_ENTRY_TYPE_HASH:
        ASSERT (pCaiCommon && 
                SaferIdentityTypeImageHash == pCaiCommon->dwIdentificationType);
        break;

    case SAFER_ENTRY_TYPE_URLZONE:
        ASSERT (pCaiCommon && 
                SaferIdentityTypeUrlZone == pCaiCommon->dwIdentificationType);
        break;

    case SAFER_ENTRY_TYPE_CERT:
        ASSERT (pCert);
        break;

    default:
        ASSERT (0);
        break;
    }

    CSaferEntry* pNewEntry = new CSaferEntry (
            type, 
            bIsComputer,
            L"", 
            pwcszObjectName,
            pCaiCommon,
            dwLevel,
            pGPEInformation,
            pCert,
            pSaferEntries,
            bIsComputer ? QueryComponentDataRef ().m_rsopObjectArrayComputer : 
                    QueryComponentDataRef ().m_rsopObjectArrayUser,
            pszRSOPRegistryKey);
    if ( pNewEntry )
    {
        RESULTDATAITEM  rdItem;

        // security review 2/22/2002 BryanWal ok
        ::ZeroMemory (&rdItem, sizeof (rdItem));
        rdItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        switch (type)
        {
        case SAFER_ENTRY_TYPE_HASH:
            rdItem.nImage = iIconSaferHashEntry;
            break;

        case SAFER_ENTRY_TYPE_PATH:
            rdItem.nImage = iIconSaferNameEntry;
            break;

        case SAFER_ENTRY_TYPE_CERT:
            rdItem.nImage = iIconSaferCertEntry;
            break;

        case SAFER_ENTRY_TYPE_URLZONE:
            rdItem.nImage = iIconSaferURLEntry;
            break;

        default:
            ASSERT (0);
            break;
        }
        rdItem.nCol = 0;
        rdItem.str = MMC_TEXTCALLBACK;
        QueryComponentDataRef ().QueryBaseRootCookie ().m_listResultCookieBlocks.AddHead (pNewEntry);
        rdItem.lParam = (LPARAM) pNewEntry;
        pNewEntry->m_resultDataID = m_pResultData;
        hr = m_pResultData->InsertItem (&rdItem);
        if ( FAILED (hr) )
        {
            _TRACE (0, L"IResultData::InsertItem () failed: 0x%x\n", hr);
        }
    }
    else
        hr = E_OUTOFMEMORY;

    _TRACE (-1, L"Leaving CCertMgrComponent::InsertNewSaferEntry (%s): 0x%x\n", pwcszObjectName, hr);
    return hr;
}

HRESULT CCertMgrComponent::SaferEnumerateNonCertEntries (
        HKEY hGroupPolicyKey, 
        bool bIsComputer)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateNonCertEntries ()\n");
    ASSERT (0 != g_hkeyLastSaferRegistryScope);
    HRESULT hr = S_OK;
    DWORD*  pdwLevels = 0;
    DWORD   cbBuffer = 0;

    SetRegistryScope (hGroupPolicyKey, bIsComputer);
    BOOL    bRVal = SaferGetPolicyInformation (
            SAFER_SCOPEID_REGISTRY,
            SaferPolicyLevelList,
            cbBuffer,
            pdwLevels,
            &cbBuffer,
            0);
    if ( !bRVal && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
    {
        DWORD   nLevels = cbBuffer/sizeof (DWORD);
        pdwLevels = new DWORD[nLevels];
        if ( pdwLevels )
        {
            bRVal = SaferGetPolicyInformation (
                SAFER_SCOPEID_REGISTRY,
                SaferPolicyLevelList,
                cbBuffer,
                pdwLevels,
                &cbBuffer,
                0);
            ASSERT (bRVal);
            if ( bRVal )
            {
                for (DWORD dwIndex = 0; dwIndex < nLevels; dwIndex++)
                {
                    hr = SaferEnumerateEntriesAtLevel (
                            bIsComputer,
                            hGroupPolicyKey, 
                            pdwLevels[dwIndex]);
                }
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n", 
                        dwErr);
            }
            delete [] pdwLevels;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if ( !bRVal )
    {
        ASSERT (0);
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n",
                dwErr);
    }


    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateNonCertEntries (): 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferEnumerateCertEntries (
        bool bIsComputer,
        CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateCertEntries ()\n");
    HRESULT hr = S_OK;
    CCertStore* pTrustedPublisherStore = 0;
    hr = pSaferEntries->GetTrustedPublishersStore (&pTrustedPublisherStore);
    if ( pTrustedPublisherStore )
    {
        hr = EnumSaferCertificates (
                bIsComputer, 
                *pTrustedPublisherStore, 
                pSaferEntries);
        if ( SUCCEEDED (hr) )
        {
            m_currResultNodeType = bIsComputer ?
                    CERTMGR_SAFER_COMPUTER_ENTRY : CERTMGR_SAFER_USER_ENTRY;
            m_pResultData->Sort (m_nSelectedSaferEntryColumn, 0, 
                    (long) m_currResultNodeType);
        }

        pTrustedPublisherStore->Release ();
    }
    else
        hr = E_OUTOFMEMORY;

    CCertStore* pDisallowedStore = 0;
    hr = pSaferEntries->GetDisallowedStore (&pDisallowedStore);
    if ( pDisallowedStore )
    {
        hr = EnumSaferCertificates (
                bIsComputer, 
                *pDisallowedStore, 
                pSaferEntries);
        if ( SUCCEEDED (hr) )
        {
            m_currResultNodeType = bIsComputer ?
                    CERTMGR_SAFER_COMPUTER_ENTRY : CERTMGR_SAFER_USER_ENTRY;
            m_pResultData->Sort (m_nSelectedSaferEntryColumn, 0, 
                    (long) m_currResultNodeType);
        }

        pDisallowedStore->Release ();
        pDisallowedStore = 0;
    }
    else
        hr = E_OUTOFMEMORY;


    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateCertEntries (): 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::EnumSaferCertificates (
        bool bIsComputer, 
        CCertStore& rCertStore, 
        CSaferEntries* pSaferEntries)
{
    if ( !pSaferEntries )
        return E_POINTER;

    _TRACE (1, L"Entering CCertMgrComponent::EnumCertificates\n");
    CWaitCursor     cursor;
    PCCERT_CONTEXT  pCertContext = 0;
    HRESULT         hr = 0;
    CCertificate*   pCert = 0;
    DWORD           dwLevelID = SAFER_TRUSTED_PUBLISHER_STORE == rCertStore.GetStoreType () ? 
                            SAFER_LEVELID_FULLYTRUSTED : SAFER_LEVELID_DISALLOWED;

    //  Iterate through the list of certificates in the system store,
    //  allocate new certificates with the CERT_CONTEXT returned,
    //  and store them in the certificate list.
    while ( 1 )
    {
        pCertContext = rCertStore.EnumCertificates (pCertContext);
        if ( !pCertContext )
            break;

        pCert =
            new CCertificate (pCertContext, &rCertStore);
        if ( pCert )
        {
            hr = InsertNewSaferEntry (SAFER_ENTRY_TYPE_CERT,
                    bIsComputer,
                    pCert->GetSubjectName (), 
                    0,
                    dwLevelID,
                    pSaferEntries,
                    QueryComponentDataRef ().m_pGPEInformation,
                    pCert);
            if ( FAILED (hr) )
                break;
            pCert->Release ();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }
    rCertStore.Close ();

    _TRACE (-1, L"Leaving CCertMgrComponent::EnumCertificates: 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferEnumerateEntriesAtLevel (
            bool bIsComputer, 
            HKEY hGroupPolicyKey, 
            DWORD dwLevel)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateEntriesAtLevel (%d)\n", dwLevel);
    SetRegistryScope (hGroupPolicyKey, bIsComputer);
    HRESULT     hr = S_OK;
    SAFER_LEVEL_HANDLE hLevel = 0;
    BOOL        bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
            dwLevel,
            SAFER_LEVEL_OPEN,
            &hLevel,
            hGroupPolicyKey);
    ASSERT (bRVal);
    if ( bRVal )
    {
        DWORD   dwBufferSize = 0;
        bRVal = SaferGetLevelInformation(hLevel, 
                SaferObjectAllIdentificationGuids,
                0,
                dwBufferSize,
                &dwBufferSize);
        if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
        {
            DWORD   nGuids = dwBufferSize/sizeof (GUID);
            GUID*   pGuids = new GUID[nGuids];
            if ( pGuids )
            {
                bRVal = SaferGetLevelInformation(hLevel, 
                        SaferObjectAllIdentificationGuids,
                        pGuids,
                        dwBufferSize,
                        &dwBufferSize);
                ASSERT (bRVal);
                if ( bRVal )
                {
                    for (DWORD dwIndex = 0; dwIndex < nGuids; dwIndex++)
                    {
                        hr = SaferGetSingleEntry (bIsComputer, hLevel, 
                                pGuids[dwIndex], dwLevel);
                    }
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"SaferGetLevelInformation (SaferObjectAllIdentificationGuids) failed: %d\n",
                            dwErr);
                }
                delete [] pGuids;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else if ( !bRVal )
        {
            DWORD   dwErr = GetLastError ();
            ASSERT (ERROR_NOT_FOUND == dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"SaferGetLevelInformation (SaferObjectAllIdentificationGuids) failed: %d\n",
                    dwErr);
        }

        VERIFY (SaferCloseLevel (hLevel));
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferCreateLevel (SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                dwLevel, dwErr);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateEntriesAtLevel () : 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::SaferGetSingleEntry(
        bool bIsComputer, 
        SAFER_LEVEL_HANDLE hLevel, 
        GUID &rEntryGuid,
        DWORD  dwLevelID)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferGetSingleEntry ()\n");
    ASSERT (0 != g_hkeyLastSaferRegistryScope);
    HRESULT hr = S_OK;
    DWORD   dwBufferSize = sizeof (SAFER_IDENTIFICATION_HEADER);
    SAFER_IDENTIFICATION_HEADER    caiCommon;
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&caiCommon, sizeof (caiCommon));
    caiCommon.cbStructSize = dwBufferSize;
    // security review 2/22/2002 BryanWal ok
    memcpy (&caiCommon.IdentificationGuid, &rEntryGuid, sizeof (GUID));


    BOOL bRVal = SaferGetLevelInformation(hLevel, 
            SaferObjectSingleIdentification,
            &caiCommon,
            dwBufferSize,
            &dwBufferSize);
    if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
    {
        PBYTE   pBytes = (PBYTE) LocalAlloc (LPTR, dwBufferSize);
        if ( pBytes )
        {
            SAFER_ENTRY_TYPE    saferEntryType = SAFER_ENTRY_TYPE_UNKNOWN;
            PSAFER_IDENTIFICATION_HEADER pCommon = (PSAFER_IDENTIFICATION_HEADER) pBytes;
            pCommon->cbStructSize = dwBufferSize;
            // security review 2/22/2002 BryanWal ok
            memcpy (&pCommon->IdentificationGuid, &rEntryGuid, sizeof (GUID));

            bRVal = SaferGetLevelInformation(hLevel, 
                    SaferObjectSingleIdentification,
                    pBytes,
                    dwBufferSize,
                    &dwBufferSize);
            ASSERT (bRVal);
            if ( bRVal )
            {
                CString   szObjectName;

                switch (pCommon->dwIdentificationType)
                {
                case SaferIdentityTypeImageName:
                    szObjectName = ((PSAFER_PATHNAME_IDENTIFICATION) (pCommon))->ImageName;
                    _TRACE (0, L"Reading safer path entry: %s\n", ((PSAFER_PATHNAME_IDENTIFICATION) (pCommon))->ImageName);
                    saferEntryType = SAFER_ENTRY_TYPE_PATH;
                    break;

                case SaferIdentityTypeImageHash:
                    szObjectName = ((PSAFER_HASH_IDENTIFICATION) (pCommon))->FriendlyName;

                    // replace new-line characters with spaces
                    szObjectName.Replace (pcszNEWLINE, L"  ");
                    saferEntryType = SAFER_ENTRY_TYPE_HASH;
                    break;

                case SaferIdentityTypeUrlZone:
                    szObjectName = GetURLZoneFriendlyName (
                            ((PSAFER_URLZONE_IDENTIFICATION) (pCommon))->UrlZoneId);
                    saferEntryType = SAFER_ENTRY_TYPE_URLZONE;
                    break;

                default:
                    ASSERT (0);
                    break;
                }

                hr = InsertNewSaferEntry (
                        saferEntryType, 
                        bIsComputer, 
                        szObjectName, 
                        pCommon,
                        dwLevelID,
                        0,
                        QueryComponentDataRef ().m_pGPEInformation,
                        0);
                if ( E_OUTOFMEMORY == hr )
                    ::LocalFree (pBytes);
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetLevelInformation (SaferObjectSingleIdentification) failed: %d\n",
                        dwErr);
            }
            // pBytes is freed in ~CSaferEntry
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if ( !bRVal )
    {
        ASSERT (0);
        DWORD   dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferGetLevelInformation (SaferObjectSingleIdentification) failed: %d\n",
                dwErr);
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferGetSingleEntry (): 0x%x\n", hr);
    return hr;
}


HRESULT CCertMgrComponent::DeleteSaferEntryFromResultPane (
        CSaferEntry * pSaferEntry, 
        LPDATAOBJECT pDataObject, 
        bool bDoCommit)
{
    _TRACE (1, L"Entering CCertMgrComponent::DeleteSaferEntryFromResultPane\n");
    HRESULT hr = S_OK;
    hr = pSaferEntry->Delete (bDoCommit);
    if ( SUCCEEDED (hr) )
    {
        HRESULTITEM itemID = 0;
        hr = m_pResultData->FindItemByLParam ( (LPARAM) pSaferEntry, &itemID);
        if ( SUCCEEDED (hr) )
        {
            hr = m_pResultData->DeleteItem (itemID, 0);
        }

        // If we can't succeed in removing this one item, then update the whole panel.
        if ( !SUCCEEDED (hr) )
        {
            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
        }
    }
    else
    {
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        // security review 2/22/2002 BryanWal ok
        text.FormatMessage (IDS_CANT_DELETE_SAFER_ENTRY, GetSystemMessage (hr));
        int     iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
                MB_OK, &iRetVal)));
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::DeleteSaferEntryFromResultPane: 0x%x\n", hr);
    return hr;
}

HRESULT CCertMgrComponent::OnNotifyCanPasteOutOfProc (LPBOOL pbCanHandle)
{
    if ( !pbCanHandle )
        return E_POINTER;

    CCertMgrComponentData& dataRef = QueryComponentDataRef ();
    CLSID   clsID;
    if ( SUCCEEDED (dataRef.GetClassID (&clsID)) )
    {
        if ( CLSID_SaferWindowsExtension == clsID )
            *pbCanHandle = TRUE;
    }

    return S_OK;    // snapins should redefine this
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\componentdatasafer.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001-2002.
//
//  File:       ComponentDataSafer.cpp
//
//  Contents:   Implementation of CCertMgrComponentData
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS ("CERTMGR (ComponentDataSafer.cpp)")
#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"
#include "cookie.h"
#include "Certifct.h"
#include "dlgs.h"
#pragma warning(push, 3)
#include <wintrust.h>
#include <cryptui.h>
#pragma warning(pop)
#include "storegpe.h"
#include "PolicyPrecedencePropertyPage.h"
#include "SaferLevelGeneral.h"
#include "SaferEntry.h"
#include "SaferEntryPathPropertyPage.h"
#include "SaferEntryPropertySheet.h"
#include "SaferEntryHashPropertyPage.h"
#include "SaferEntryCertificatePropertyPage.h"
#include "SaferEntryInternetZonePropertyPage.h"
#include "SaferTrustedPublishersPropertyPage.h"
#include "SaferDefinedFileTypesPropertyPage.h"
#include "SaferEnforcementPropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
    
extern HKEY g_hkeyLastSaferRegistryScope;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;


CSaferWindowsExtension::CSaferWindowsExtension() : CCertMgrComponentData () 
{
    SetHtmlHelpFileName (SAFER_WINDOWS_HELP_FILE);
    m_strLinkedHelpFile = SAFER_WINDOWS_LINKED_HELP_FILE;
};


HRESULT CCertMgrComponentData::AddSaferNewEntryMenuItems (LPCONTEXTMENUCALLBACK pContextMenuCallback, LONG lInsertionPointID)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferNewEntryMenuItems\n");
 	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
 	ASSERT (pContextMenuCallback);
    if ( !pContextMenuCallback )
        return E_POINTER;

 	HRESULT			hr = S_OK;
 
    ASSERT (m_pGPEInformation); // must not be RSOP
    if ( !m_pGPEInformation )
        return E_FAIL;


    hr = AddSingleMenuItem (pContextMenuCallback, 
            lInsertionPointID,
            IDS_SAFER_NEW_ENTRY_CERTIFICATE,
            IDS_SAFER_NEW_ENTRY_CERTIFICATE_HINT,
            IDM_SAFER_NEW_ENTRY_CERTIFICATE);

    if ( SUCCEEDED (hr) )
        hr = AddSingleMenuItem (pContextMenuCallback, 
                lInsertionPointID,
                IDS_SAFER_NEW_ENTRY_HASH,
                IDS_SAFER_NEW_ENTRY_HASH_HINT,
                IDM_SAFER_NEW_ENTRY_HASH);

    if ( SUCCEEDED (hr) )
        hr = AddSingleMenuItem (pContextMenuCallback, 
                lInsertionPointID,
                IDS_SAFER_NEW_ENTRY_INTERNET_ZONE,
                IDS_SAFER_NEW_ENTRY_INTERNET_ZONE_HINT,
                IDM_SAFER_NEW_ENTRY_INTERNET_ZONE);

    if ( SUCCEEDED (hr) )
        hr = AddSingleMenuItem (pContextMenuCallback, 
                lInsertionPointID,
                IDS_SAFER_NEW_ENTRY_PATH,
                IDS_SAFER_NEW_ENTRY_PATH_HINT,
                IDM_SAFER_NEW_ENTRY_PATH);

 	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferNewEntryMenuItems: 0x%x\n", hr);
 	return hr;
}

HRESULT CCertMgrComponentData::OnSetSaferLevelDefault (LPDATAOBJECT pDataObject)
{
 	_TRACE (1, L"Entering CCertMgrComponentData::OnSetSaferLevelDefault\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
 	ASSERT (pDataObject);
 	if ( !pDataObject )
 		return E_POINTER;

    ASSERT (m_pGPEInformation); // must not be RSOP
    if ( !m_pGPEInformation )
        return E_FAIL;

 	HRESULT			hr = S_OK;
 	CCertMgrCookie*	pCookie = ConvertCookie (pDataObject);
 	ASSERT (pCookie);
 	if ( pCookie )
 	{
        if ( pCookie->HasOpenPropertyPages () )
        {
            CString text;
            CString	caption;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
            VERIFY (text.LoadString (IDS_CANT_CHANGE_DEFAULT_PAGES_OPEN)); 
            int		iRetVal = 0;
            VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
	             MB_OK, &iRetVal)));
            return S_OK;
        }

        if ( CERTMGR_SAFER_COMPUTER_LEVEL == pCookie->m_objecttype ||
                CERTMGR_SAFER_USER_LEVEL == pCookie->m_objecttype )
        {
            CSaferLevel* pSaferLevel = dynamic_cast<CSaferLevel*>(pCookie);
            if ( pSaferLevel )
            {
                int iRetVal = IDYES;

                if ( pSaferLevel->GetLevel () < m_dwDefaultSaferLevel )
                {
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
                    VERIFY (text.LoadString (IDS_DEFAULT_LEVEL_CHANGE_WARNING));
                    m_pConsole->MessageBox (text, caption, 
                            MB_ICONWARNING | MB_YESNO, &iRetVal);
                }

                if ( IDYES == iRetVal )
                {
                    hr = pSaferLevel->SetAsDefault ();
                    if ( SUCCEEDED (hr) )
                    {
                        m_dwDefaultSaferLevel = pSaferLevel->GetLevel ();
                        if ( m_pConsole )
                            hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                    }
                    else
                    {
                        CString text;
                        CString caption;

                        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
                        // security review 2/22/2002 BryanWal ok
                        text.FormatMessage (IDS_CANT_SET_AS_DEFAULT, 
                                pSaferLevel->GetObjectName (),
                                GetSystemMessage (hr));
	                    iRetVal = 0;
                        ASSERT (m_pConsole);
	                    if ( m_pConsole )
	                    {
		                    HRESULT	hr1 = m_pConsole->MessageBox (text, caption,
			                    MB_ICONWARNING | MB_OK, &iRetVal);
		                    ASSERT (SUCCEEDED (hr1));
	                    }
                    }
                }
            }
        }
        else
            hr = E_FAIL;
    }
    _TRACE (-1, L"Leaving CCertMgrComponentData::OnSetSaferLevelDefault: 0x%x\n", hr);
    return hr;
}



HRESULT CCertMgrComponentData::AddSaferLevelPropPage (
        LPPROPERTYSHEETCALLBACK pCallback, 
        CSaferLevel* pSaferLevel, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferLevelPropPage\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback && pSaferLevel);
	if ( pCallback && pSaferLevel )
	{
		CSaferLevelGeneral * pLevelPage = new CSaferLevelGeneral (*pSaferLevel,
                m_bIsRSOP, lNotifyHandle, pDataObject, m_dwDefaultSaferLevel,
                this);
		if ( pLevelPage )
		{
			HPROPSHEETPAGE hLevelPage = MyCreatePropertySheetPage (&pLevelPage->m_psp);
            if ( hLevelPage )
            {
			    hr = pCallback->AddPage (hLevelPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
//                        CString regPath = SAFER_LEVELOBJECTS_REGKEY;
//                        regPath += L"\\";
//                        DWORD   dwLevel = pSaferLevel->GetLevel ();
//                        WCHAR   szLevel[16];
//                        regPath += _itow (dwLevel, szLevel, 10);

                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, SAFER_HKLM_REGBASE,
                                        SAFER_DEFAULTOBJ_REGVALUE,
                                        CERTMGR_SAFER_COMPUTER_LEVEL == pSaferLevel->m_objecttype);
	                    if ( pPrecedencePage )
	                    {
                            HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hLevelPage));
                }
            }
            else
                delete pLevelPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferLevelPropPage: 0x%x\n", hr);
	return hr;
}
    
HRESULT CCertMgrComponentData::OnCreateNewSaferPolicy (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnCreateNewSaferPolicy\n");    
    HRESULT hr = S_OK;
  	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
    {
        bool    bIsComputer = CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype;
        HKEY    hGroupPolicyKey = 0;
        hr = m_pGPEInformation->GetRegistryKey (
                bIsComputer ? 
                GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &hGroupPolicyKey);
        if ( SUCCEEDED (hr) )
        {
            BOOL bDefaultsActuallyPopulated = FALSE;
            BOOL bResult = ::SaferiPopulateDefaultsInRegistry(
                    hGroupPolicyKey, &bDefaultsActuallyPopulated);
            if ( bResult && bDefaultsActuallyPopulated )
            {
                m_pGPEInformation->PolicyChanged (TRUE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (TRUE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
            }

            ::RegCloseKey (hGroupPolicyKey);
        }

        CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
        if ( pSaferRootCookie )
            pSaferRootCookie->m_bCreateSaferNodes = true;

        if ( !m_pResultData )
            hr = GetResultData (&m_pResultData);

        if ( m_pResultData )
            hr = m_pResultData->DeleteAllRsltItems ();

        // Force scope item selection to for call to 
        // IComponent::QueryResultViewType ()
        hr = m_pComponentConsole->SelectScopeItem (pCookie->m_hScopeItem);
        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
        hr = OnNotifyExpand (pDataObject, TRUE, pCookie->m_hScopeItem);
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnCreateNewSaferPolicy: 0x%x\n", hr);    
    return hr;
}


HRESULT CCertMgrComponentData::OnDeleteSaferPolicy (LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnDeleteSaferPolicy\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    ASSERT (pDataObject);
    if ( !pDataObject )
        return E_POINTER;

    HRESULT hr = S_OK;

    if ( GetOpenSaferPageCount () == 0 )
    {
        CString text;
        CString	caption;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
        VERIFY (text.LoadString (IDS_CONFIRM_DELETE_SAFER_POLICY)); 
        int		iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
	         MB_YESNO | MB_ICONWARNING, &iRetVal)));

        if ( IDYES == iRetVal )
        {
  	        CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	        ASSERT (pCookie);
	        if ( pCookie )
            {
                bool    bIsComputer = CERTMGR_SAFER_COMPUTER_ROOT == pCookie->m_objecttype;
                HKEY    hGroupPolicyKey = 0;
                hr = m_pGPEInformation->GetRegistryKey (
                        bIsComputer ? 
                        GPO_SECTION_MACHINE : GPO_SECTION_USER,
		                &hGroupPolicyKey);
                if ( SUCCEEDED (hr) )
                {
                    DWORD   dwResult = 0;

                    // Delete "Safer" key
                    HKEY    hWindowsKey = 0;
                    LRESULT lResult = ::RegOpenKeyEx (hGroupPolicyKey,
                                L"Software\\Policies\\Microsoft\\Windows",
                                0,
                                // security review 2/22/2002 BryanWal ok
                                KEY_ALL_ACCESS, // KEY_ALL_ACCESS required to delete keys
                                &hWindowsKey);
                    if ( ERROR_SUCCESS == lResult )
                    {
                        dwResult = ::SHDeleteKey (hWindowsKey, L"Safer");
                        if ( ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult )
                        {
                            _TRACE (0, L"SHDeleteKey (\"Safer\") failed: 0x%x (%s)\n",
                                    dwResult, (PCWSTR) GetSystemMessage (dwResult));
                        }
                        ::RegCloseKey (hWindowsKey);
                    }

                    // Delete "SystemCertificates" safer keys
                    HKEY    hSysCertKey = 0;
                    lResult = ::RegOpenKeyEx (hGroupPolicyKey,
                                L"Software\\Policies\\Microsoft\\SystemCertificates",
                                0,
                                // security review 2/22/2002 BryanWal ok
                                KEY_ALL_ACCESS, // KEY_ALL_ACCESS required to delete keys
                                &hSysCertKey);
                    if ( ERROR_SUCCESS == lResult )
                    {
                        dwResult = ::SHDeleteKey (hSysCertKey, L"Disallowed");
                        if ( ERROR_SUCCESS == dwResult || ERROR_FILE_NOT_FOUND == dwResult )
                        {
                            dwResult = ::SHDeleteKey (hSysCertKey, L"TrustedPublisher");
                            if ( ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult )
                            {
                                _TRACE (0, L"SHDeleteKey (\"TrustedPublisher\") failed: 0x%x (%s)\n",
                                        dwResult, (PCWSTR) GetSystemMessage (dwResult));
                            }
                        }
                        else
                        {
                            _TRACE (0, L"SHDeleteKey (\"Disallowed\") failed: 0x%x (%s)\n",
                                    dwResult, (PCWSTR) GetSystemMessage (dwResult));
                        }


                        ::RegCloseKey (hSysCertKey);
                    }

                    if ( ERROR_SUCCESS != dwResult && ERROR_FILE_NOT_FOUND != dwResult )
                    {
                        CString text;
                        CString	caption;

                        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
                        // security review 2/22/2002 BryanWal ok
                        text.FormatMessage (IDS_CANT_DELETE_SAFER_POLICY, 
                                GetSystemMessage (dwResult)); 
                        int		iRetVal1 = 0;
                        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
	                         MB_OK, &iRetVal1)));
                    }

                    ::RegCloseKey (hGroupPolicyKey);
                }

                m_pGPEInformation->PolicyChanged (TRUE, 
                        FALSE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (TRUE, 
                        FALSE, &g_guidRegExt, &g_guidSnapin);

                CSaferRootCookie* pSaferRootCookie = dynamic_cast <CSaferRootCookie*> (pCookie);
                if ( pSaferRootCookie )
                    pSaferRootCookie->m_bCreateSaferNodes = false;

                if ( !m_pResultData )
                    hr = GetResultData (&m_pResultData);

                if ( m_pResultData )
                    hr = m_pResultData->DeleteAllRsltItems ();

                hr = DeleteChildren (pCookie->m_hScopeItem);

                // Force scope item selection to for call to 
                // IComponent::QueryResultViewType ()
                hr = m_pComponentConsole->SelectScopeItem (pCookie->m_hScopeItem);
                hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                hr = OnNotifyExpand (pDataObject, TRUE, pCookie->m_hScopeItem);
            }
            else
                hr = E_FAIL;
        }
    }
    else
    {
        CString text;
        CString	caption;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
        VERIFY (text.LoadString (IDS_CANT_DELETE_SAFER_PAGES_OPEN)); 
        int		iRetVal = 0;
        VERIFY (SUCCEEDED (m_pConsole->MessageBox (text, caption,
	         MB_OK, &iRetVal)));
        return S_OK;
    }

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnDeleteSaferPolicy: 0x%x\n", hr);    
    return hr;
}


HRESULT CCertMgrComponentData::OnNewSaferEntry(long nCommandID, LPDATAOBJECT pDataObject)
{
    _TRACE (1, L"Entering CCertMgrComponentData::OnNewSaferEntry ()\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    HRESULT                     hr = S_OK;

	CCertMgrCookie* pCookie = ConvertCookie (pDataObject);
	ASSERT (pCookie);
	if ( pCookie )
	{
        bool    bIsComputer = false;

        switch (pCookie->m_objecttype)
        {
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
            bIsComputer = true;
            break;

        case CERTMGR_SAFER_USER_ENTRIES:
            break;

        default:
            ASSERT (0);
            hr = E_FAIL;
            return hr;
        }

        CSaferEntries* pSaferEntries = dynamic_cast <CSaferEntries*> (pCookie);
        if ( !pSaferEntries )
            return E_UNEXPECTED;

        SAFER_ENTRY_TYPE  saferEntryType = SAFER_ENTRY_TYPE_UNKNOWN;
        switch (nCommandID)
        {
            case IDM_SAFER_NEW_ENTRY_PATH:
                saferEntryType = SAFER_ENTRY_TYPE_PATH;
                break;

            case IDM_SAFER_NEW_ENTRY_HASH:
                saferEntryType = SAFER_ENTRY_TYPE_HASH;
                break;

            case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
                saferEntryType = SAFER_ENTRY_TYPE_CERT;
                break;

            case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
                saferEntryType = SAFER_ENTRY_TYPE_URLZONE;
                break;

            default:
                ASSERT (0);
                break;
        }
		CSaferEntry* pSaferEntry = new CSaferEntry (
                saferEntryType,
                bIsComputer, 
                L"", 
                L"", 
                0, 
                (DWORD) AUTHZ_UNKNOWN_LEVEL,
                m_pGPEInformation, 
                0,
                pSaferEntries, 
                bIsComputer ? m_rsopObjectArrayComputer : m_rsopObjectArrayUser);
		ASSERT (pSaferEntry);
        if ( pSaferEntry )
        {
            UINT    nIDCaption = 0;

            switch (nCommandID)
            {
            case IDM_SAFER_NEW_ENTRY_PATH:
                nIDCaption = IDS_NEW_PATH_RULE;
                break;

            case IDM_SAFER_NEW_ENTRY_HASH:
                nIDCaption = IDS_NEW_HASH_RULE;
                break;

            case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
                nIDCaption = IDS_NEW_CERTIFICATE_RULE;
                break;

            case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
                nIDCaption = IDS_NEW_URLZONE_RULE;
                break;

            default:
                ASSERT (0);
                hr = E_FAIL;
                break;
            }

            CThemeContextActivator activator;
            HWND    hParent = 0;
			hr = m_pConsole->GetMainWindow (&hParent);
			ASSERT (SUCCEEDED (hr));
			if ( SUCCEEDED (hr) )
			{
				CWnd	parentWnd;
				VERIFY (parentWnd.Attach (hParent));

                CSaferEntryPropertySheet    propSheet (nIDCaption, &parentWnd);
                CSaferPropertyPage*         pPage = 0;
                bool                        bObjectCreated = false; 

                switch (nCommandID)
                {
                case IDM_SAFER_NEW_ENTRY_PATH:
                    {
                        CSaferEntryPathPropertyPage* pPropPage = new 
                                CSaferEntryPathPropertyPage (*pSaferEntry, 0, 
                                0, false, true, this, bIsComputer,
                                &bObjectCreated);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                case IDM_SAFER_NEW_ENTRY_HASH:
                    {
                        CSaferEntryHashPropertyPage* pPropPage = new 
                                CSaferEntryHashPropertyPage (*pSaferEntry, 0, 
                                0, false, this, bIsComputer,
                                &bObjectCreated);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                case IDM_SAFER_NEW_ENTRY_CERTIFICATE:
                    {
                        CSaferEntryCertificatePropertyPage* pPropPage = new 
                                CSaferEntryCertificatePropertyPage (*pSaferEntry,
                                pSaferEntries, 0, 0, false, this, true, 
                                m_pGPEInformation, bIsComputer,
                                &bObjectCreated);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                case IDM_SAFER_NEW_ENTRY_INTERNET_ZONE:
                    {
                        CSaferEntryInternetZonePropertyPage* pPropPage = new 
                                CSaferEntryInternetZonePropertyPage (*pSaferEntry, 
                                true, 0, 0, false, this, bIsComputer,
                                &bObjectCreated);
                        if ( pPropPage )
                        {
                            pPage = pPropPage;
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                    break;

                default:
                    hr = E_FAIL;
                    break;
                }


                if ( SUCCEEDED (hr) )
                {
                    propSheet.AddPage (pPage);

                    CThemeContextActivator activator;
                    INT_PTR iRet = propSheet.DoModal ();
                    if ( IDOK == iRet || bObjectCreated )
                    {
                        hr = m_pConsole->UpdateAllViews (pDataObject, 0, 0);
                    }
                }

                delete pSaferEntry;

				parentWnd.Detach ();
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CCertMgrComponentData::OnNewSaferEntry (): 0x%x\n", hr);
    return hr;
}

	
HRESULT	CCertMgrComponentData::AddSaferTrustedPublisherPropPages (
			LPPROPERTYSHEETCALLBACK pCallback,
            bool bIsMachineType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferTrustedPublisherPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CSaferTrustedPublishersPropertyPage * pTrustedPublisherPage = new 
                CSaferTrustedPublishersPropertyPage (
                    bIsMachineType,
                    m_pGPEInformation, this);
		if ( pTrustedPublisherPage )
		{
			HPROPSHEETPAGE hTrustedPublisherPage = MyCreatePropertySheetPage (&pTrustedPublisherPage->m_psp);
            if ( hTrustedPublisherPage )
            {
		        hr = pCallback->AddPage (hTrustedPublisherPage);
		        ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    // Add the precedence page if this is RSOP
                    if ( m_bIsRSOP )
                    {
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, 
                                        CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,
                                        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,
                                        bIsMachineType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = 
                                    MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
                                hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                            {
                                delete pPrecedencePage;
                            }
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hTrustedPublisherPage));
                }
            }
            else
                delete pTrustedPublisherPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferTrustedPublisherPropPages: 0x%x\n", hr);
	return hr;

}


	
HRESULT	CCertMgrComponentData::AddSaferDefinedFileTypesPropPages (
			LPPROPERTYSHEETCALLBACK pCallback,
            bool bIsComputerType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferDefinedFileTypesPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CSaferDefinedFileTypesPropertyPage * pDefinedFileTypesPage = new 
                CSaferDefinedFileTypesPropertyPage (
                    m_pGPEInformation,
                    m_bIsRSOP,
                    bIsComputerType ?
                            m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                    bIsComputerType,
                    this);
		if ( pDefinedFileTypesPage )
		{
			HPROPSHEETPAGE hDefinedFileTypesPage = MyCreatePropertySheetPage (&pDefinedFileTypesPage->m_psp);
            if ( hDefinedFileTypesPage )
            {
			    hr = pCallback->AddPage (hDefinedFileTypesPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, 
                                        SAFER_HKLM_REGBASE,
                                        SAFER_EXETYPES_REGVALUE,
                                        bIsComputerType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = 
                                    MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hDefinedFileTypesPage));
                }
            }
            else
                delete pDefinedFileTypesPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferDefinedFileTypesPropPages: 0x%x\n", hr);
	return hr;

}

HRESULT	CCertMgrComponentData::AddSaferEnforcementPropPages (
			LPPROPERTYSHEETCALLBACK pCallback,
            bool bIsComputerType)
{
	_TRACE (1, L"Entering CCertMgrComponentData::AddSaferEnforcementPropPages\n");
	HRESULT			hr = S_OK;
	ASSERT (pCallback);
	if ( pCallback )
	{
		CSaferEnforcementPropertyPage * pEnforcementPage = new 
                CSaferEnforcementPropertyPage (
                    m_pGPEInformation, this,
                    m_bIsRSOP,
                    bIsComputerType ?
                            m_rsopObjectArrayComputer : m_rsopObjectArrayUser,
                    bIsComputerType);
		if ( pEnforcementPage )
		{
			HPROPSHEETPAGE hEnforcementPage = MyCreatePropertySheetPage (&pEnforcementPage->m_psp);
            if ( hEnforcementPage )
            {
			    hr = pCallback->AddPage (hEnforcementPage);
			    ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    if ( m_bIsRSOP )
                    {
                        CPolicyPrecedencePropertyPage * pPrecedencePage = 
                                new CPolicyPrecedencePropertyPage (this, 
                                        SAFER_HKLM_REGBASE,
                                        SAFER_TRANSPARENTENABLED_REGVALUE,
                                        bIsComputerType);
	                    if ( pPrecedencePage )
	                    {
		                    HPROPSHEETPAGE hPrecedencePage = 
                                    MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                            if ( hPrecedencePage )
                            {
		                        hr = pCallback->AddPage (hPrecedencePage);
		                        ASSERT (SUCCEEDED (hr));
                                if ( FAILED (hr) )
                                    VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                            }
                            else
                                delete pPrecedencePage;
	                    }
	                    else
	                    {
		                    hr = E_OUTOFMEMORY;
	                    }
                    }
                }
                else
                {
                    VERIFY (::DestroyPropertySheetPage (hEnforcementPage));
                }
            }
            else
                delete pEnforcementPage;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}
	else
		hr = E_POINTER;

	_TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferEnforcementPropPages: 0x%x\n", hr);
	return hr;

}


HRESULT CCertMgrComponentData::AddSaferEntryPropertyPage (
        LPPROPERTYSHEETCALLBACK pCallback, 
        CCertMgrCookie* pCookie,
        LPDATAOBJECT pDataObject, 
        LONG_PTR lNotifyHandle)
{
    _TRACE (1, L"Entering CCertMgrComponentData::AddSaferEntryPropertyPage\n");
    ASSERT (pCallback && pCookie);
    if ( !pCallback || !pCookie )
        return E_POINTER;

    HRESULT hr = S_OK;
    bool    bIsComputer = false;

    switch (pCookie->m_objecttype)
    {
    case CERTMGR_SAFER_COMPUTER_ENTRY:
        bIsComputer = true;
        break;

    case CERTMGR_SAFER_USER_ENTRY:
        break;

    default:
        ASSERT (0);
        hr = E_FAIL;
        return hr;
    }

	CSaferEntry* pSaferEntry = dynamic_cast <CSaferEntry*> (pCookie);
	ASSERT (pSaferEntry);
    if ( pSaferEntry )
    {
        pSaferEntry->Refresh ();

        switch (pSaferEntry->GetType ())
        {
        case SAFER_ENTRY_TYPE_PATH:
            {
                CSaferEntryPathPropertyPage* pPage = new 
                        CSaferEntryPathPropertyPage (*pSaferEntry, 
                        lNotifyHandle, pDataObject, 
                        m_bIsRSOP, false, this, bIsComputer);
                if ( pPage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                    if ( hPage )
                    {
                        hr = pCallback->AddPage (hPage);
                        if ( FAILED (hr) )
                        {
                            VERIFY (::DestroyPropertySheetPage (hPage));
                        }
                    }
                    else
                        delete pPage;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            break;

        case SAFER_ENTRY_TYPE_HASH:
            {
                CSaferEntryHashPropertyPage* pPage = new 
                        CSaferEntryHashPropertyPage (*pSaferEntry, 
                        lNotifyHandle, pDataObject, 
                        m_bIsRSOP, this, bIsComputer);
                if ( pPage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                    if ( hPage )
                    {
                        hr = pCallback->AddPage (hPage);
                        if ( FAILED (hr) )
                        {
                            VERIFY (::DestroyPropertySheetPage (hPage));
                        }
                    }
                    else
                        delete pPage;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            break;

        case SAFER_ENTRY_TYPE_CERT:
            {
                CSaferEntries* pSaferEntries = 0;
                hr = pSaferEntry->GetSaferEntriesNode (&pSaferEntries);
                if ( SUCCEEDED (hr) )
                {
                    CSaferEntryCertificatePropertyPage* pPage = new 
                            CSaferEntryCertificatePropertyPage (*pSaferEntry, 
                            pSaferEntries, lNotifyHandle, pDataObject, 
                            m_bIsRSOP, this, false, m_pGPEInformation, bIsComputer);
                    if ( pPage )
                    {
                        HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                        if ( hPage )
                        {
                            hr = pCallback->AddPage (hPage);
                            if ( FAILED (hr) )
                            {
                                VERIFY (::DestroyPropertySheetPage (hPage));
                            }
                        }
                        else
                            delete pPage;
                    }
                    else
                        hr = E_OUTOFMEMORY;

                    pSaferEntries->Release ();
                }
            }
            break;

        case SAFER_ENTRY_TYPE_URLZONE:
            {
                CSaferEntryInternetZonePropertyPage* pPage = new 
                        CSaferEntryInternetZonePropertyPage (*pSaferEntry, 
                        false, lNotifyHandle, pDataObject,
                        m_bIsRSOP, this, bIsComputer);
                if ( pPage )
                {
                    HPROPSHEETPAGE hPage = MyCreatePropertySheetPage (&pPage->m_psp);
                    if ( hPage )
                    {
                        hr = pCallback->AddPage (hPage);
                        if ( FAILED (hr) )
                        {
                            VERIFY (::DestroyPropertySheetPage (hPage));
                        }
                    }
                    else
                        delete pPage;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            break;

        default:
            hr = E_FAIL;
            break;
        }

        if ( SUCCEEDED (hr) && m_bIsRSOP )
        {
            CString szValue;
            switch (pSaferEntry->GetType ())
            {
            case SAFER_ENTRY_TYPE_PATH:
            case SAFER_ENTRY_TYPE_HASH:
            case SAFER_ENTRY_TYPE_URLZONE:
                szValue = SAFER_IDS_ITEMDATA_REGVALUE;
                break;

            case SAFER_ENTRY_TYPE_CERT:
                szValue = STR_BLOB;
                break;

            default:
                ASSERT (0);
                break;
            }

            CPolicyPrecedencePropertyPage * pPrecedencePage = 
                    new CPolicyPrecedencePropertyPage (this, 
                            pSaferEntry->GetRSOPRegistryKey (),
                            szValue,
                            bIsComputer);
	        if ( pPrecedencePage )
	        {
		        HPROPSHEETPAGE hPrecedencePage = MyCreatePropertySheetPage (&pPrecedencePage->m_psp);
                if ( hPrecedencePage )
                {
		            hr = pCallback->AddPage (hPrecedencePage);
		            ASSERT (SUCCEEDED (hr));
                    if ( FAILED (hr) )
                        VERIFY (::DestroyPropertySheetPage (hPrecedencePage));
                }
                else
                    delete pPrecedencePage;
	        }
	        else
	        {
		        hr = E_OUTOFMEMORY;
	        }
        }
    }
    else
        hr = E_FAIL;
    
    _TRACE (-1, L"Leaving CCertMgrComponentData::AddSaferEntryPropertyPage: 0x%x\n", hr);
    return hr;
}

bool CSaferWindowsExtension::FoundInRSOPFilter (BSTR bstrKey) const
{
    ASSERT (bstrKey);
    if ( !bstrKey )
        return false;

    // security review 2/22/2002 BryanWal ok for all
    static  size_t  nSaferKeyLen = wcslen (SAFER_HKLM_REGBASE);
    static  size_t  nSaferPKKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH);
    static  size_t  nTrustedPublisherKeyLane = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH);
    static  size_t  nDisallowedKeyLen = 
                wcslen (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH);

    // security review 2/22/2002 BryanWal ok for all
    if ( !_wcsnicmp (SAFER_HKLM_REGBASE, bstrKey, nSaferKeyLen) ||
            !_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH, bstrKey, 
                    nSaferPKKeyLen) ||
            !_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH, 
                    bstrKey, nTrustedPublisherKeyLane) ||
            !_wcsnicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH, 
                    bstrKey, nDisallowedKeyLen) )
    {
        return true;
    }
    else
        return false;
}


HRESULT CCertMgrComponentData::SaferEnumerateLevels (bool bIsComputer)
{
    _TRACE (1, L"Entering CCertMgrComponent::SaferEnumerateLevels ()\n");
    HRESULT hr = S_OK;

    if ( !m_pdwSaferLevels )
    {
        if ( m_pGPEInformation )
        {
            DWORD   cbBuffer = 0;
            CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    bIsComputer);

            SetRegistryScope (policyKey.GetKey (), bIsComputer);
            BOOL    bRVal = SaferGetPolicyInformation(
                    SAFER_SCOPEID_REGISTRY,
                    SaferPolicyLevelList,
                    cbBuffer,
                    m_pdwSaferLevels,
                    &cbBuffer,
                    0);
            if ( !bRVal && GetLastError () == ERROR_INSUFFICIENT_BUFFER )
            {
                DWORD   nLevels = cbBuffer/sizeof (DWORD);
                m_pdwSaferLevels = new DWORD[nLevels+1];
                if ( m_pdwSaferLevels )
                {
                    // security review 2/22/2002 BryanWal ok
                    memset (m_pdwSaferLevels, NO_MORE_SAFER_LEVELS, 
                            sizeof (DWORD) * (nLevels + 1));
                    bRVal = SaferGetPolicyInformation(
                        SAFER_SCOPEID_REGISTRY,
                        SaferPolicyLevelList,
                        cbBuffer,
                        m_pdwSaferLevels,
                        &cbBuffer,
                        0);
                    ASSERT (bRVal);
                    if ( !bRVal )
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"SaferGetPolicyInformation(SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n", 
                                dwErr);
                    }
                }
                else
                    hr = E_OUTOFMEMORY;
            }
            else if ( !bRVal )
            {
                ASSERT (0);
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation(SAFER_SCOPEID_REGISTRY, SaferPolicyLevelList) failed: %d\n",
                        dwErr);
            }
        }
        else
        {
            // Is RSOP
            const int RSOP_SAFER_LEVELS = 3;    // SAFER_LEVELID_FULLYTRUSTED, SAFER_LEVELID_DISALLOWED + 1
            m_pdwSaferLevels = new DWORD[RSOP_SAFER_LEVELS];
            if ( m_pdwSaferLevels )
            {
                m_pdwSaferLevels[0] = SAFER_LEVELID_FULLYTRUSTED;
                m_pdwSaferLevels[1] = SAFER_LEVELID_DISALLOWED;
                m_pdwSaferLevels[2] = (DWORD) NO_MORE_SAFER_LEVELS;
            }
            else
                hr = E_OUTOFMEMORY;
        }
    }

    _TRACE (-1, L"Leaving CCertMgrComponent::SaferEnumerateLevels (): 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       debug.h
//
//  Contents:   Debugging macros and prototypes
//
//----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG == 1


void __cdecl _TRACE (int level, const wchar_t *format, ... );


//
// External functions
//

PCSTR StripDirPrefixA(PCSTR);



//
// These macros are used for asserting certain conditions. They are
// independent of the debugging level.
// These also require additional paranthesis to enclose the msg as
// shown below.
//

#ifdef _ASSERT
#undef _ASSERT
#undef _ASSERTMSG
#endif

#define _ASSERT(expr)                                                    \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
               _TRACE (0, L"Cert Template Snapin(Thread ID: %d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                DebugBreak();                                           \
            }                                                           \
        }


#define _ASSERTMSG(expr, msg)                                            \
        {                                                               \
            if (!(expr))                                                \
            {                                                           \
                _TRACE (0, L"Cert Template Snapin(%d): Assert: %s(%u)\n",               \
                         GetCurrentThreadId(),                          \
                         StripDirPrefixA(__FILE__), __LINE__);          \
                _TRACE (0, msg);                                           \
                _TRACE (0, "\n");                                         \
                DebugBreak();                                           \
            }                                                           \
        }

    void CheckDebugOutputLevel ();

#else // !DBG


#define _TRACE 
#define _ASSERTMSG(expr, msg)

#endif



#endif  // ifndef _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\disabledwarnings.h ===
// Copyright (c) 2000-2001 Microsoft Corporation
//
// pragma warnings
//
// 8 Feb 2000 sburns



// disable "symbols too long for debugger" warning: it happens a lot w/ STL

#pragma warning (disable: 4786)

// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)

// who cares about unreferenced inline removal?

#pragma warning (disable: 4514)
#pragma warning (disable : 4505)

// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)

// some stl templates are lousy signed/unsigned mismatches

#pragma warning (disable: 4018 4146)

// we like this extension

#pragma warning (disable: 4239)

// we don't always want copy constructors

#pragma warning (disable: 4511)

// we don't always want assignment operators

#pragma warning (disable: 4512)

// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\crl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       crl.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_CRL_H__6C3D4D38_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
#define AFX_CRL_H__6C3D4D38_3527_11D1_B4AD_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cookie.h"

class CCRL : public CCertMgrCookie  
{
public:
	BOOL DeleteFromStore ();
	virtual void Refresh();
	CCRL(const PCCRL_CONTEXT pCRLContext, CCertStore& CertStore);
	virtual ~CCRL();
	int CompareNextUpdate (const CCRL& crl) const;
	int CompareEffectiveDate (const CCRL& crl) const;
	PCCRL_CONTEXT GetCRLContext() const;
	CCertStore& GetCertStore() const;
	CString GetIssuerName ();
	CString GetNextUpdate ();
	CString GetEffectiveDate ();

private:
	CString m_szEffectiveDate;
	CString m_szNextUpdate;
	CString m_szIssuerName;
	CCertStore&			m_rCertStore;
	const PCCRL_CONTEXT	m_pCRLContext;
	PCRL_INFO			m_pCRLInfo;
};

#endif // !defined(AFX_CRL_H__6C3D4D38_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\ctl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       ctl.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if !defined(AFX_CTL_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
#define AFX_CTL_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "cookie.h"


class CCTL : public CCertMgrCookie  
{
public:
	BOOL DeleteFromStore ();
	virtual void Refresh();
	SPECIAL_STORE_TYPE GetStoreType () const;
	CString GetFriendlyName ();
	CString GetPurpose ();
	CCTL (const PCCTL_CONTEXT pCTLContext, 
			CCertStore& rCertStore, 
			CertificateManagerObjectType objectType = CERTMGR_CTL,
			CTypedPtrList<CPtrList, CCertStore*>*	pStoreList = 0);
	virtual ~CCTL();

	int CompareNextUpdate (const CCTL& ctl) const;
	int CompareEffectiveDate (const CCTL& ctl) const;
	PCCTL_CONTEXT GetCTLContext() const;
	CCertStore& GetCertStore() const;
	CString GetIssuerName ();
	CString GetNextUpdate ();
	CString GetEffectiveDate ();
    CString GetSHAHash();

protected:
    PCCTL_CONTEXT GetNewCTLContext();
	void FormatEnhancedKeyUsagePropertyString (CString& string);
	HRESULT GetSignerInfo (CString & signerName);
    CString CCTL::GetGenericHash(DWORD dwPropId);

private:
	CCertStore*								m_pStoreCollection;
	CString									m_szFriendlyName;
	CString									m_szPurpose;
	CCertStore&								m_rCertStore;
	PCCTL_CONTEXT						    m_pCTLContext;
	CString									m_szEffectiveDate;
	CString									m_szNextUpdate;
	CString									m_szIssuerName;
	PCTL_INFO								m_pCTLInfo;
	CTypedPtrList<CPtrList, CCertStore*>	m_storeList;
    HCERTSTORE                              m_hExtraStore;
    CString                                 m_szSHAHash;
};

#endif // !defined(AFX_CTL_H__6C3D4D37_3527_11D1_B4AD_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\ctl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       CTL.cpp
//
//  Contents:   implementation of the CCTL class.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "CTL.h"
#include "certifct.h"


USE_HANDLE_MACROS("CERTMGR(ctl.cpp)")  

////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCTL::CCTL (const PCCTL_CONTEXT pCTLContext, 
            CCertStore& rCertStore, 
            CertificateManagerObjectType objectType,
            CTypedPtrList<CPtrList, CCertStore*>*   pStoreList) :
    CCertMgrCookie (objectType),
        m_pCTLContext (::CertDuplicateCTLContext (pCTLContext)),
    m_rCertStore (rCertStore),
    m_pStoreCollection (0),
    m_hExtraStore (0)
{
    _TRACE (1, L"Entering CCTL::CCTL\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    m_rCertStore.AddRef ();
    ASSERT (m_pCTLContext);
    if ( m_pCTLContext )
        m_pCTLInfo = m_pCTLContext->pCtlInfo;

    m_pStoreCollection = new CCertStore (CERTMGR_LOG_STORE, CERT_STORE_PROV_COLLECTION, 0,
            L"", L"", L"", L"", NO_SPECIAL_TYPE, 0, rCertStore.m_pConsole);
    if ( m_pStoreCollection )
    {
        m_pStoreCollection->AddStoreToCollection (m_rCertStore);

        m_hExtraStore = CertOpenStore(
                                CERT_STORE_PROV_MSG, 
                                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
                                NULL, 
                                NULL,
                                (const void *) pCTLContext->hCryptMsg);
        if ( m_hExtraStore )
            m_pStoreCollection->AddStoreToCollection (m_hExtraStore);
        else
        {
            _TRACE (0, L"CertOpenStore (CERT_STORE_PROV_MSG) failed: 0x%x\n", 
                    GetLastError ());       
        }
        if ( pStoreList )
        {
            for (POSITION pos = pStoreList->GetHeadPosition (); pos; )
            {
                CCertStore* pStore = pStoreList->GetNext (pos);
                ASSERT (pStore);
                if ( pStore )
                {
                    m_pStoreCollection->AddStoreToCollection (*pStore);
                    pStore->AddRef ();
                    m_storeList.AddTail (pStore);
                }
            }
        }
    }
    _TRACE (-1, L"Leaving CCTL::CCTL\n");
}

CCTL::~CCTL()
{
    _TRACE (1, L"Entering CCTL::~CCTL\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);


    if ( m_pStoreCollection )
    {
        delete m_pStoreCollection;
        m_pStoreCollection = 0;
    }

    CCertStore* pStore = 0;

    // Clean up store list
    while (!m_storeList.IsEmpty () )
    {
        pStore = m_storeList.RemoveHead ();
        ASSERT (pStore);
        if ( pStore )
            pStore->Release ();
    }

    if ( m_hExtraStore )
    {
        CertCloseStore (m_hExtraStore, 0);
        m_hExtraStore = 0;
    }

    m_rCertStore.Release ();
    if ( m_pCTLContext )
        ::CertFreeCTLContext (m_pCTLContext);
    _TRACE (-1, L"Leaving CCTL::~CCTL\n");
}


PCCTL_CONTEXT CCTL::GetCTLContext() const
{
    _TRACE (1, L"Entering CCTL::GetCTLContext\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    _TRACE (-1, L"Leaving CCTL::GetCTLContext\n");
    return m_pCTLContext;
}

CCertStore& CCTL::GetCertStore() const  
{
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    return m_rCertStore;
}

CString CCTL::GetIssuerName ()
{
    _TRACE (1, L"Entering CCTL::GetIssuerName\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    ASSERT (m_pCTLInfo);
    if ( m_pCTLInfo )
    {
        // Decode issuer name if not already present
        if ( m_szIssuerName.IsEmpty () )
        {
            HRESULT hResult = GetSignerInfo (m_szIssuerName);
            if ( !SUCCEEDED (hResult) )
                VERIFY (m_szIssuerName.LoadString (IDS_NOT_AVAILABLE));
        }
    }

    _TRACE (-1, L"Leaving CCTL::GetIssuerName\n");
    return m_szIssuerName;
}

CString CCTL::GetEffectiveDate()
{
    _TRACE (1, L"Entering CCTL::GetEffectiveDate\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    ASSERT (m_pCTLInfo);
    if ( m_pCTLInfo )
    {
        // Format date/time string if not already present
        if ( m_szEffectiveDate.IsEmpty () )
        {
            HRESULT hResult = FormatDate (m_pCTLInfo->ThisUpdate, m_szEffectiveDate);
            if ( !SUCCEEDED (hResult) )
                m_szEffectiveDate = _T("");
        }
    }
    else
        m_szEffectiveDate = _T("");

    _TRACE (-1, L"Leaving CCTL::GetEffectiveDate\n");
    return m_szEffectiveDate;
}

CString CCTL::GetNextUpdate()
{
    _TRACE (1, L"Entering CCTL::GetNextUpdate\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    ASSERT (m_pCTLInfo);
    if ( m_pCTLInfo )
    {
        // Format date/time string if not already present
        if ( m_szNextUpdate.IsEmpty () )
        {
            HRESULT hResult = FormatDate (m_pCTLInfo->NextUpdate, m_szNextUpdate);
            if ( !SUCCEEDED (hResult) )
                m_szNextUpdate = _T("");
        }
    }
    else
        m_szNextUpdate = _T("");

    _TRACE (-1, L"Leaving CCTL::GetNextUpdate\n");
    return m_szNextUpdate;
}

CString CCTL::GetPurpose()
{
    _TRACE (1, L"Entering CCTL::GetPurpose\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    ASSERT (m_pCTLInfo);
    if ( m_pCTLInfo )
    {
        // Format date/time string if not already present
        if ( m_szPurpose.IsEmpty () )
            FormatEnhancedKeyUsagePropertyString (m_szPurpose);
    }
    _TRACE (-1, L"Leaving CCTL::GetPurpose\n");
    return m_szPurpose;
}


void CCTL::FormatEnhancedKeyUsagePropertyString (CString& string)
{
    _TRACE (1, L"Entering CCTL::FormatEnhancedKeyUsagePropertyString\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    ASSERT (m_pCTLInfo);
    if ( m_pCTLInfo )
    {
        CString     usageName;
        CTL_USAGE&  usage = m_pCTLInfo->SubjectUsage;


        for (DWORD dwIndex = 0; dwIndex < usage.cUsageIdentifier; dwIndex++)
        {
            if ( MyGetOIDInfo (usageName, usage.rgpszUsageIdentifier[dwIndex]) )
            {
                // add delimeter if not first iteration
                if ( dwIndex )
                    string += _T(", ");
                string += usageName;
            }
        }
    }
    _TRACE (-1, L"Leaving CCTL::FormatEnhancedKeyUsagePropertyString\n");
}


HRESULT CCTL::GetSignerInfo (CString & signerName)
{
    _TRACE (1, L"Entering CCTL::GetSignerInfo\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    HRESULT     hResult = S_OK;
    
    //
    // Use CryptMsg to crack the encoded PKCS7 Signed Message
    //
    HCRYPTMSG   hMsg = ::CryptMsgOpenToDecode (X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                      0,              
                                      0,
                                      0,
                                      NULL,           
                                      NULL);
    ASSERT (hMsg);
    if ( hMsg )
    {
        BOOL    bResult = ::CryptMsgUpdate (hMsg, m_pCTLContext->pbCtlEncoded,
                m_pCTLContext->cbCtlEncoded, TRUE);
        ASSERT (bResult);
        if ( bResult )
        {
            //
            // get the encoded signer BLOB
            //
            DWORD       cbEncodedSigner = 0;
            bResult = ::CryptMsgGetParam (hMsg, CMSG_ENCODED_SIGNER, 0, NULL,
                    &cbEncodedSigner);
            if ( bResult && cbEncodedSigner )
            {
                BYTE*   pbEncodedSigner = (PBYTE) ::LocalAlloc (LPTR, cbEncodedSigner);
                if ( pbEncodedSigner )
                {
                    bResult = ::CryptMsgGetParam (hMsg, CMSG_ENCODED_SIGNER, 0,
                            pbEncodedSigner, &cbEncodedSigner);
                    ASSERT (bResult);
                    if ( bResult )
                    {
                        DWORD   cbSignerInfo = 0;
                        //
                        // decode the EncodedSigner info
                        //
                        bResult = ::CryptDecodeObject (
                                PKCS_7_ASN_ENCODING | CRYPT_ASN_ENCODING,
                                PKCS7_SIGNER_INFO,
                                pbEncodedSigner,
                                cbEncodedSigner,
                                0,
                                NULL,
                                &cbSignerInfo);
                        ASSERT (bResult);
                        if ( bResult )
                        {
                            PCMSG_SIGNER_INFO   pbSignerInfo = (PCMSG_SIGNER_INFO) ::LocalAlloc (LPTR, cbSignerInfo);
                            if ( pbSignerInfo )
                            {
                                bResult = ::CryptDecodeObject (
                                        PKCS_7_ASN_ENCODING|CRYPT_ASN_ENCODING,
                                        PKCS7_SIGNER_INFO,
                                        pbEncodedSigner,
                                        cbEncodedSigner,
                                        0,
                                        pbSignerInfo,
                                        &cbSignerInfo);
                                ASSERT (bResult);
                                if ( bResult )
                                {
                                    DWORD       cbCertInfo = 0;
                                    //
                                    // get the signers cert context
                                    //
                                    bResult = ::CryptMsgGetParam (hMsg,
                                                     CMSG_SIGNER_CERT_INFO_PARAM,
                                                     0,
                                                     NULL,               
                                                     &cbCertInfo);
                                    ASSERT (bResult);
                                    if ( bResult && cbEncodedSigner )
                                    {
                                        CERT_INFO*  pCertInfo = (CERT_INFO *) ::LocalAlloc (LPTR, cbCertInfo);
                                        if ( pCertInfo )
                                        {
                                            bResult = ::CryptMsgGetParam (hMsg,
                                                  CMSG_SIGNER_CERT_INFO_PARAM,
                                                  0,
                                                  pCertInfo,
                                                  &cbCertInfo);
                                            ASSERT (bResult);
                                            if ( bResult )
                                            {
                                                CCertificate* pCert = 
                                                        m_pStoreCollection->GetSubjectCertificate (pCertInfo);
                                                if ( pCert )
                                                {
                                                    signerName = pCert->GetSubjectName ();
                                                    pCert->Release ();
                                                }
                                                else
                                                    hResult = E_FAIL;
                                            }

                                            ::LocalFree (pCertInfo);
                                        }
                                        else
                                        {
                                            hResult = E_OUTOFMEMORY;
                                        }
                                    }
                                }
                                ::LocalFree (pbSignerInfo);
                            }
                            else
                            {
                                hResult = E_OUTOFMEMORY;
                            }
                        }
                    }
                    ::LocalFree (pbEncodedSigner);
                }
                else
                {
                    hResult = E_OUTOFMEMORY;
                }
            }
            else
                hResult = E_FAIL;
        }
        bResult = ::CryptMsgClose (hMsg);
        ASSERT (bResult);
    }
    else
        hResult = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CCTL::GetSignerInfo\n");
    return hResult;
}


int CCTL::CompareEffectiveDate (const CCTL& ctl) const
{
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    int compVal = 0;

    ASSERT (m_pCTLInfo && ctl.m_pCTLInfo);
    if ( m_pCTLInfo && ctl.m_pCTLInfo )
    {
        compVal = ::CompareFileTime (&m_pCTLInfo->ThisUpdate, 
                &ctl.m_pCTLInfo->ThisUpdate);
    }

    return compVal;
}

int CCTL::CompareNextUpdate (const CCTL& ctl) const
{
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    int compVal = 0;

    ASSERT (m_pCTLInfo && ctl.m_pCTLInfo);
    if ( m_pCTLInfo && ctl.m_pCTLInfo )
    {
        compVal = ::CompareFileTime (&m_pCTLInfo->NextUpdate, 
                &ctl.m_pCTLInfo->NextUpdate);
    }

    return compVal;
}

CString CCTL::GetFriendlyName()
{
    _TRACE (1, L"Entering CCTL::GetFriendlyName\n");
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    ASSERT (m_pCTLContext);
    if ( m_pCTLContext && m_szFriendlyName.IsEmpty () )
    {   
        DWORD   cbData = 0;
        BOOL bResult = ::CertGetCTLContextProperty (
                m_pCTLContext,
                CERT_FRIENDLY_NAME_PROP_ID,
                NULL,
                &cbData);
        if ( bResult )
        {
            LPWSTR  pszName = new WCHAR[cbData];
            if ( pszName )
            {
                // security review 2/22/2002 BryanWal ok
                ::ZeroMemory (pszName, cbData * sizeof (WCHAR));
                bResult = ::CertGetCTLContextProperty (
                        m_pCTLContext,
                        CERT_FRIENDLY_NAME_PROP_ID,
                        pszName,
                        &cbData);
                ASSERT (bResult);
                if ( bResult )
                {
                    m_szFriendlyName = pszName;
                }
                else
                {
                    VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
                }
                delete [] pszName;
            }
        }
        else
        {
            if ( GetLastError () == CRYPT_E_NOT_FOUND )
            {
                VERIFY (m_szFriendlyName.LoadString (IDS_NONE));
            }
            else
            {
                ASSERT (0);
                VERIFY (m_szFriendlyName.LoadString (IDS_NOT_AVAILABLE));
            }
        }
    }
    _TRACE (-1, L"Leaving CCTL::GetFriendlyName\n");
    return m_szFriendlyName;
}

SPECIAL_STORE_TYPE CCTL::GetStoreType() const
{
    ASSERT (CERTMGR_AUTO_CERT_REQUEST == m_objecttype ||
            CERTMGR_CTL == m_objecttype);
    return m_rCertStore.GetStoreType ();
}

void CCTL::Refresh()
{
    m_szEffectiveDate = L"";
    m_szFriendlyName = L"";
    m_szIssuerName = L"";
    m_szNextUpdate = L"";
    m_szPurpose = L"";
}


BOOL CCTL::DeleteFromStore()
{
    _TRACE (1, L"Entering CCTL::DeleteFromStore\n");
    BOOL    bResult = FALSE;

    PCCTL_CONTEXT pCTLContext = GetNewCTLContext ();
    if ( pCTLContext )
    {
        bResult = ::CertDeleteCTLFromStore (pCTLContext);
        if ( bResult )
        {
            m_rCertStore.InvalidateCertCount ();
            m_rCertStore.SetDirty ();
            m_rCertStore.SetDeleting ();
            HRESULT hr = m_rCertStore.Commit ();
            m_rCertStore.SetAdding ();
            if ( SUCCEEDED (hr) )
                m_rCertStore.Resync ();
            else
                bResult = FALSE;
        }
        m_rCertStore.Close ();
    }

    _TRACE (-1, L"Leaving CCTL::DeleteFromStore\n");
    return bResult;
}

PCCTL_CONTEXT CCTL::GetNewCTLContext()
{
    _TRACE (1, L"Entering CCTL::GetNewCTLContext\n");
    PCCTL_CONTEXT   pCTLContext = 0;
    HCERTSTORE      hCertStore = m_rCertStore.GetStoreHandle ();
    if ( hCertStore )
    {
        DWORD   cbData = 20;
        BYTE    certHash[20];
        BOOL bReturn = ::CertGetCTLContextProperty (
                m_pCTLContext,
                CERT_SHA1_HASH_PROP_ID,
                certHash,
                &cbData);
        ASSERT (bReturn);
        if ( bReturn )
        {
            CRYPT_DATA_BLOB blob = {sizeof (certHash), certHash};
            pCTLContext = CertFindCTLInStore(
                hCertStore,
                0,
                0,
                CTL_FIND_SHA1_HASH,
                &blob,
                0);
            if ( pCTLContext )
            {
                ::CertFreeCTLContext (m_pCTLContext);
                m_pCTLContext = ::CertDuplicateCTLContext (pCTLContext);
            }
        }
    }

    _TRACE (-1, L"Leaving CCTL::GetNewCTLContext\n");
    return pCTLContext;
}

CString CCTL::GetSHAHash()
{
//  _TRACE (1, L"Entering CCTL::GetSHAHash\n");
    ASSERT (m_pCTLContext);
    if ( m_pCTLContext && m_szSHAHash.IsEmpty ())
    {
        m_szSHAHash = GetGenericHash (CERT_SHA1_HASH_PROP_ID);
    }
//  _TRACE (-1, L"Leaving CCTL::GetSHAHash\n");
    return m_szSHAHash;
}


CString CCTL::GetGenericHash(DWORD dwPropId)
{
//  _TRACE (1, L"Entering CCTL::GetGenericHash\n");
    CString szHash;


    DWORD   cbData = 0;
    BOOL    bReturn = ::CertGetCTLContextProperty (
            m_pCTLContext,
            dwPropId,
            NULL,
            &cbData);
    if ( bReturn )
    {
        cbData += 2;  // for null terminator
        BYTE* pCTLHash = new BYTE[cbData];
        if ( pCTLHash )
        {
            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (pCTLHash, cbData);
            bReturn = CertGetCTLContextProperty (
                    m_pCTLContext,
                    dwPropId,
                    pCTLHash,
                    &cbData);
            ASSERT (bReturn);
            if ( bReturn )
            {
                DataToHex (pCTLHash, szHash, cbData, false);
            }
            delete [] pCTLHash;
        }
    }
//  _TRACE (-1, L"Leaving CCTL::GetGenericHash\n");
    return szHash;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\dataobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       DataObj.cpp
//
//  Contents:   Implementation of data object classes
//
//----------------------------------------------------------------------------

#include "stdafx.h"

USE_HANDLE_MACROS("CERTMGR(dataobj.cpp)")

#include <gpedit.h>
#include "compdata.h"
#include "dataobj.h"

#pragma warning(push,3)
#include <sceattch.h>
#pragma warning(pop)
#include "uuids.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"


// IDataObject interface implementation

CCertMgrDataObject::CCertMgrDataObject()
		: m_pCookie (0),
		m_objecttype (CERTMGR_SNAPIN),
		m_dataobjecttype (CCT_UNINITIALIZED),
		m_dwLocation (0),
		m_pGPEInformation (0),
		m_pRSOPInformation (0),
        m_pbMultiSelData(NULL),
        m_cbMultiSelData(0),
		m_bMultiSelDobj(false),
		m_iCurr(0)
{
}

HRESULT CCertMgrDataObject::GetDataHere(
	FORMATETC __RPC_FAR *pFormatEtcIn,
	STGMEDIUM __RPC_FAR *pMedium)
{
    HRESULT hr = DV_E_FORMATETC;
	
	const CLIPFORMAT cf=pFormatEtcIn->cfFormat;
	if (cf == m_CFNodeType)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const GUID* pguid = GetObjectTypeGUID( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			hr = s.Write(pguid, sizeof(GUID));
		}
		else
			hr = E_UNEXPECTED;
	}
	else if (cf == m_CFSnapInCLSID)
	{
		stream_ptr s(pMedium);
		hr =  s.Write(&m_SnapInCLSID, sizeof(GUID));
	}
	else if (cf == m_CFNodeTypeString)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			const BSTR strGUID = GetObjectTypeString( m_pCookie->m_objecttype );
			stream_ptr s(pMedium);
			hr = s.Write(strGUID);
		}
		else
			hr = E_UNEXPECTED;
	}
	else if (cf == m_CFDisplayName)
	{
		hr = PutDisplayName(pMedium);
	}
	else if (cf == m_CFDataObjectType)
	{
		stream_ptr s(pMedium);
		hr = s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
	}
	else if (cf == m_CFMachineName)
	{
		if ( IsValidObjectType (m_pCookie->m_objecttype) )
		{
			stream_ptr s(pMedium);
			hr = s.Write(m_pCookie->QueryNonNULLMachineName());
		}
		else
			hr = E_UNEXPECTED;
	}
	else if (cf == m_CFRawCookie)
	{
		stream_ptr s(pMedium);


		if ( m_pCookie )
		{
			// CODEWORK This cast ensures that the data format is
			// always a CCookie*, even for derived subclasses
			if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie ||
					IsValidObjectType (m_pCookie->m_objecttype) )
			{
				CCookie* pcookie = (CCookie*) m_pCookie;
				hr = s.Write(reinterpret_cast<PBYTE>(&pcookie), sizeof(m_pCookie));
			}
			else
				hr = E_UNEXPECTED;
		}
	}
	else if ( cf == m_CFSCE_GPTUnknown )
	{
		hr = CreateGPTUnknown (pMedium);
    }
	else if ( cf == m_CFSCE_RSOPUnknown )
	{
		hr = CreateRSOPUnknown (pMedium);
    }
	else if ( cf == m_CFMultiSel )
	{
		hr = CreateMultiSelectObject (pMedium);
	}
	else if (cf == m_CFSnapinPreloads)
	{
		stream_ptr s(pMedium);
		// If this is TRUE, then the next time this snapin is loaded, it will
		// be preloaded to give us the opportunity to change the root node
		// name before the user sees it.
		hr = s.Write (reinterpret_cast<PBYTE>(&m_fAllowOverrideMachineName), sizeof (BOOL));
	}

	return hr;
}

HRESULT CCertMgrDataObject::Initialize(
	CCertMgrCookie*			pcookie,
	DATA_OBJECT_TYPES		type,
	BOOL					fAllowOverrideMachineName,
	DWORD					dwLocation,
	CString					szManagedUser,
	CString					szManagedComputer,
	CString					szManagedService,
	CCertMgrComponentData&	refComponentData)
{
	if ( !pcookie || m_pCookie )
	{
		ASSERT(FALSE);
		return S_OK;	// Initialize must not fail
	}

	m_dataobjecttype = type;
	m_pCookie = pcookie;
	m_fAllowOverrideMachineName = fAllowOverrideMachineName;
	m_dwLocation = dwLocation;
	m_szManagedUser = szManagedUser;
	m_szManagedComputer = szManagedComputer;
	m_szManagedService = szManagedService;

	if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie )
		((CRefcountedObject*)m_pCookie)->AddRef();
	VERIFY( SUCCEEDED(refComponentData.GetClassID(&m_SnapInCLSID)) );
	return S_OK;
}


CCertMgrDataObject::~CCertMgrDataObject()
{
	if ( m_pGPEInformation )
	{
		m_pGPEInformation->Release ();
		m_pGPEInformation = 0;
	}
	
	if ( m_pRSOPInformation )
	{
		m_pRSOPInformation->Release ();
		m_pRSOPInformation = 0;
	}
	
	if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) != m_pCookie &&
			m_pCookie && IsValidObjectType (m_pCookie->m_objecttype) )
	{
		((CRefcountedObject*)m_pCookie)->Release();
	}
    if (m_pbMultiSelData)
        delete m_pbMultiSelData;

    for (int i=0; i < m_rgCookies.GetSize(); ++i)
    {
        m_rgCookies[i]->Release();
    }
}

void CCertMgrDataObject::AddCookie(CCertMgrCookie* pCookie)
{
    m_rgCookies.Add(pCookie);
    pCookie->AddRef();
}

HRESULT CCertMgrDataObject::PutDisplayName(STGMEDIUM* pMedium)
	// Writes the "friendly name" to the provided storage medium
	// Returns the result of the write operation
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	CString strDisplayName = m_pCookie->QueryTargetServer();
	CString	formattedName;

	switch (m_dwLocation)
	{
	case CERT_SYSTEM_STORE_CURRENT_USER:
		VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_USER));
		break;

	case CERT_SYSTEM_STORE_LOCAL_MACHINE:
		if (strDisplayName.IsEmpty())
		{
			VERIFY (formattedName.LoadString (IDS_SCOPE_SNAPIN_TITLE_LOCAL_MACHINE));
		}
		else
			formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_MACHINE, strDisplayName);
		break;

	case CERT_SYSTEM_STORE_CURRENT_SERVICE:
	case CERT_SYSTEM_STORE_SERVICES:
		if (strDisplayName.IsEmpty())
		{
			// Get this machine name and add it to the string.
			formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE_LOCAL_MACHINE,
					m_szManagedService);
		}
		else
		{
			formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_SERVICE,
					m_szManagedService, strDisplayName);
		}
		break;

	// These next two titles can only be set from the debugger.  They are used
	// to create custom .MSC files.
	case -1:
		formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_CERT_MGR_CURRENT_USER);
		break;

	case 0:
		formattedName.FormatMessage (IDS_SCOPE_SNAPIN_TITLE_FILE);
		break;

	default:
		ASSERT (0);
		break;
	}

	stream_ptr s (pMedium);
	return s.Write (formattedName);
}

// Register the clipboard formats
CLIPFORMAT CCertMgrDataObject::m_CFDisplayName =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CCertMgrDataObject::m_CFMachineName =
								(CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
								(CLIPFORMAT)RegisterClipboardFormat(L"CERTMGR_SNAPIN_RAW_COOKIE");
CLIPFORMAT CCertMgrDataObject::m_CFMultiSel =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
CLIPFORMAT CCertMgrDataObject::m_CFMultiSelDobj =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
CLIPFORMAT CCertMgrDataObject::m_CFSCEModeType =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_SCE_MODE_TYPE);
CLIPFORMAT CCertMgrDataObject::m_CFSCE_GPTUnknown =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_SCE_GPT_UNKNOWN);
CLIPFORMAT CCertMgrDataObject::m_CFSCE_RSOPUnknown =
								(CLIPFORMAT)RegisterClipboardFormat(CCF_SCE_RSOP_UNKNOWN);
CLIPFORMAT CCertMgrDataObject::m_CFMultiSelDataObjs =
							    (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);


void CCertMgrDataObject::SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData)
{
    m_pbMultiSelData = pbMultiSelData;
    m_cbMultiSelData = cbMultiSelData;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertMgrComponentData::QueryDataObject (
		MMC_COOKIE cookie,
		DATA_OBJECT_TYPES type,
		LPDATAOBJECT* ppDataObject)
{
	if ( MMC_MULTI_SELECT_COOKIE == cookie )
	{
		return QueryMultiSelectDataObject (cookie, type, ppDataObject);
	}
	CCertMgrCookie* pUseThisCookie =
			(CCertMgrCookie*) ActiveBaseCookie (
			reinterpret_cast<CCookie*> (cookie));

	CComObject<CCertMgrDataObject>* pDataObject = 0;
	HRESULT hRes = CComObject<CCertMgrDataObject>::CreateInstance(&pDataObject);
	if ( FAILED(hRes) )
		return hRes;

	if ( m_szManagedUser.IsEmpty () )
		m_szManagedUser = m_szLoggedInUser;

	m_szManagedComputer = pUseThisCookie->QueryTargetServer();
	if ( m_szManagedComputer.IsEmpty () && m_strMachineNamePersist.CompareNoCase (m_szThisComputer) ) // !=
    {
        m_szManagedComputer = m_strMachineNamePersist;
    }
	if ( m_szManagedComputer.IsEmpty () )
		m_szManagedComputer = pUseThisCookie->QueryNonNULLMachineName ();
	if ( m_szManagedComputer.IsEmpty () )
		m_szManagedComputer = m_szThisComputer;

    // Raid bug 278491	US: Cert search for a remote computer application 
    // fails to search certs on a remote computer, instead running a search 
    // on Local machine
    if ( m_szManagedComputer.CompareNoCase (m_szThisComputer) )
        pUseThisCookie->SetMachineName (m_szManagedComputer);

    // Truncate leading "\\"
    // security review 2/27/2002 BryanWal ok
    if ( !wcsncmp (m_szManagedComputer, L"\\\\", 2) )
        m_szManagedComputer = m_szManagedComputer.Mid (2);

	HRESULT hr = pDataObject->Initialize (
			pUseThisCookie,
			type,
			m_fAllowOverrideMachineName,
			m_dwLocationPersist,
			m_szManagedUser,
			m_szManagedComputer,
			m_szManagedServiceDisplayName,
			*this);
	if ( FAILED(hr) )
	{
		delete pDataObject;
		return hr;
	}

	if ( m_pGPEInformation )
		pDataObject->SetGPTInformation (m_pGPEInformation);
	if ( m_bIsRSOP )
    {
        IRSOPInformation*   pRSOPInformation = 0;

        switch (pUseThisCookie->m_objecttype)
        {
	    case CERTMGR_CERT_POLICIES_COMPUTER:
        case CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS:
        case CERTMGR_SAFER_COMPUTER_ROOT:
        case CERTMGR_SAFER_COMPUTER_LEVELS:
        case CERTMGR_SAFER_COMPUTER_ENTRIES:
        case CERTMGR_SAFER_COMPUTER_LEVEL:
        case CERTMGR_SAFER_COMPUTER_ENTRY:
        case CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES:
            pRSOPInformation = m_pRSOPInformationComputer;
            break;

	    case CERTMGR_CERT_POLICIES_USER:
        case CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS:
        case CERTMGR_SAFER_USER_ROOT:
        case CERTMGR_SAFER_USER_LEVELS:
        case CERTMGR_SAFER_USER_ENTRIES:
        case CERTMGR_SAFER_USER_LEVEL:
        case CERTMGR_SAFER_USER_ENTRY:
        case CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS:
        case CERTMGR_SAFER_USER_DEFINED_FILE_TYPES:
        case CERTMGR_SAFER_COMPUTER_ENFORCEMENT:
        case CERTMGR_SAFER_USER_ENFORCEMENT:
            pRSOPInformation = m_pRSOPInformationUser;
            break;

        case CERTMGR_CERTIFICATE:
        case CERTMGR_LOG_STORE:
	    case CERTMGR_PHYS_STORE:
	    case CERTMGR_USAGE:
	    case CERTMGR_CRL_CONTAINER:
	    case CERTMGR_CTL_CONTAINER:
	    case CERTMGR_CERT_CONTAINER:
	    case CERTMGR_CRL:
	    case CERTMGR_CTL:
	    case CERTMGR_AUTO_CERT_REQUEST:
	    case CERTMGR_LOG_STORE_GPE:
        case CERTMGR_LOG_STORE_RSOP:
        default:
            pRSOPInformation = m_pRSOPInformationComputer;
            break;
        }
		pDataObject->SetRSOPInformation (pRSOPInformation);
    }
    pDataObject->AddRef();
	*ppDataObject = pDataObject;
	return hr;
}

typedef CArray<GUID, const GUID&> CGUIDArray;

void GuidArray_Add(CGUIDArray& rgGuids, const GUID& guid)
{
    for (INT_PTR i=rgGuids.GetUpperBound(); i >= 0; --i)
    {
        if (rgGuids[i] == guid)
            break;
    }

    if (i < 0)
        rgGuids.Add(guid);
}

HRESULT CCertMgrComponentData::QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                            LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    if (ppDataObject == NULL)
        return E_POINTER;

	HRESULT		hr = S_OK;
    CGUIDArray	rgGuids;

    // Determine the items selected
    ASSERT(m_pResultData != NULL);
    RESULTDATAITEM rdi;
    // security review 2/27/2002 BryanWal ok
    ::ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = TVIS_SELECTED;

	CCookiePtrArray	rgCookiesSelected;
    while (m_pResultData->GetNextItem (&rdi) == S_OK)
    {
        const GUID* pguid;
        CCertMgrCookie* pCookie = reinterpret_cast <CCertMgrCookie*> (rdi.lParam);
        if ( pCookie )
        {
			rgCookiesSelected.Add (pCookie);
			switch (pCookie->m_objecttype)
			{
			case CERTMGR_CERTIFICATE:
				pguid = &NODEID_CertMgr_CERTIFICATE;
				break;

			case CERTMGR_CTL:
				pguid = &NODEID_CertMgr_CTL;
				break;

			case CERTMGR_CRL:
				pguid = &NODEID_CertMgr_CRL;
				break;

			case CERTMGR_AUTO_CERT_REQUEST:
				pguid = &NODEID_CertMgr_AUTOCERT;
				break;

            case CERTMGR_SAFER_COMPUTER_ENTRY:
                pguid = &NODEID_Safer_COMPUTER_ENTRY;
                break;

            case CERTMGR_SAFER_USER_ENTRY:
                pguid = &NODEID_Safer_USER_ENTRY;
                break;

			default:
				ASSERT (0);
				continue;
			}
        }
        else
        {
			hr = E_INVALIDARG;
			break;
        }

        GuidArray_Add(rgGuids, *pguid);
    }

    CComObject<CCertMgrDataObject>* pObject;
    CComObject<CCertMgrDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
	pObject->Initialize ((CCertMgrCookie*) cookie,
				type,
				m_fAllowOverrideMachineName,
				m_dwLocationPersist,
				m_szManagedUser,
				m_szManagedComputer,
				m_szManagedServiceDisplayName,
				*this);
    pObject->SetMultiSelDobj();



    // Store the coclass with the data object
    UINT cb = (UINT)(rgGuids.GetSize() * sizeof(GUID));
    GUID* pGuid = new GUID[(UINT)rgGuids.GetSize()];
	if ( pGuid )
	{
        // security review 2/27/2002 BryanWal ok
        ::CopyMemory(pGuid, rgGuids.GetData(), cb);
		pObject->SetMultiSelData((BYTE*)pGuid, cb);
		for (int i=0; i < rgCookiesSelected.GetSize(); ++i)
		{
			pObject->AddCookie(rgCookiesSelected[i]);
		}

		return  pObject->QueryInterface(
				IID_PPV_ARG (IDataObject, ppDataObject));
	}
	else
		return E_OUTOFMEMORY;
}


HRESULT CCertMgrDataObject::SetGPTInformation(IGPEInformation * pGPTInformation)
{
	HRESULT hr = S_OK;

	if  ( pGPTInformation )
	{
		m_pGPEInformation = pGPTInformation;
		m_pGPEInformation->AddRef ();
	}
	else
		hr = E_POINTER;

	return hr;
}

HRESULT CCertMgrDataObject::SetRSOPInformation(IRSOPInformation * pRSOPInformation)
{
	HRESULT hr = S_OK;

	if  ( pRSOPInformation )
	{
		m_pRSOPInformation = pRSOPInformation;
		m_pRSOPInformation->AddRef ();
	}
	else
		hr = E_POINTER;

	return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateGPTUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to GPT's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertMgrDataObject::CreateGPTUnknown(LPSTGMEDIUM lpMedium)
{
   HRESULT hr = S_OK;
   LPUNKNOWN pUnk = 0;

   if ( !m_pGPEInformation )
   {
      //
      // If we don't have a pointer to a GPT interface then we must not
      // be in a mode where we're extending GPT and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   hr = m_pGPEInformation->QueryInterface (
		IID_PPV_ARG (IUnknown, &pUnk));
   if ( SUCCEEDED(hr) )
   {
      return Create (&pUnk, sizeof(pUnk), lpMedium);
   }
   else
   {
      return hr;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CreateRSOPUnknown
//
//  Synopsis:   Fill the hGlobal in [lpMedium] with a pointer to RSOP's
//              IUnknown interface.  The object requesting this will be
//              responsible for Releasing the interface
//
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertMgrDataObject::CreateRSOPUnknown(LPSTGMEDIUM lpMedium)
{
   HRESULT hr = S_OK;
   LPUNKNOWN pUnk = 0;

   if ( !m_pRSOPInformation )
   {
      //
      // If we don't have a pointer to a GPT interface then we must not
      // be in a mode where we're extending GPT and we can't provide a
      // pointer to its IUnknown
      //
      return E_UNEXPECTED;
   }

   hr = m_pRSOPInformation->QueryInterface (
		IID_PPV_ARG (IUnknown, &pUnk));
   if ( SUCCEEDED(hr) )
   {
      return Create (&pUnk, sizeof(pUnk), lpMedium);
   }
   else
   {
      return hr;
   }
}

//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::Create
//
//  Synopsis:   Fill the hGlobal in [lpmedium] with the data in pBuffer
//
//  Arguments:  [pBuffer]  - [in] the data to be written
//              [len]      - [in] the length of that data
//              [lpMedium] - [in,out] where to store the data
//  History:
//
//---------------------------------------------------------------------------
HRESULT CCertMgrDataObject::Create (const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
   HRESULT hr = DV_E_TYMED;

   //
   // Do some simple validation
   //
   if (pBuffer == NULL || lpMedium == NULL)
      return E_POINTER;

   //
   // Make sure the type medium is HGLOBAL
   //
   if (lpMedium->tymed == TYMED_HGLOBAL) {
      //
      // Create the stream on the hGlobal passed in
      //
      LPSTREAM lpStream = 0;
      hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

	  ASSERT (SUCCEEDED (hr));
      if (SUCCEEDED(hr))
	  {
         //
         // Write to the stream the number of bytes
         //
         ULONG written = 0;
         hr = lpStream->Write(pBuffer, len, &written);
		 ASSERT (SUCCEEDED (hr));

         //
         // Because we told CreateStreamOnHGlobal with 'FALSE',
         // only the stream is released here.
         // Note - the caller (i.e. snap-in, object) will free the HGLOBAL
         // at the correct time.  This is according to the IDataObject specification.
         //
         lpStream->Release();
      }
   }

   return hr;
}


//+----------------------------------------------------------------------------
//
//  Method:     CCertMgrDataObject::CreateMultiSelectObject
//
//  Synopsis:   this is to create the list of types selected
//
//-----------------------------------------------------------------------------

HRESULT CCertMgrDataObject::CreateMultiSelectObject(LPSTGMEDIUM lpMedium)
{
    ASSERT(m_pbMultiSelData != 0);
    ASSERT(m_cbMultiSelData != 0);
    if ( !m_pbMultiSelData || !m_cbMultiSelData )
        return E_FAIL;
    if ( !lpMedium )
        return E_POINTER;

    lpMedium->tymed = TYMED_HGLOBAL;
    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                                      (m_cbMultiSelData + sizeof(DWORD)));
    if (lpMedium->hGlobal == NULL)
        return STG_E_MEDIUMFULL;

    BYTE* pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    if ( pb )
    {
        *((DWORD*)pb) = m_cbMultiSelData / sizeof(GUID);
        pb += sizeof(DWORD);
        // security review 2/27/2002 BryanWal ok
        ::CopyMemory(pb, m_pbMultiSelData, m_cbMultiSelData);

        ::GlobalUnlock(lpMedium->hGlobal);
    }
    else
    {
        ::GlobalFree (lpMedium->hGlobal);
        return HRESULT_FROM_WIN32 (GetLastError ());
    }

	return S_OK;
}




LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject)
{
	if (lpDataObject == NULL)
		return NULL;

	SMMCDataObjects * pDO = NULL;

	STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
	FORMATETC formatetc = { CCertMgrDataObject::m_CFMultiSelDataObjs, NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

	if ( FAILED (lpDataObject->GetData (&formatetc, &stgmedium)) )
	{
		return NULL;
	}
	else
	{
		pDO = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);
		return pDO->lpDataObject[0]; //assume that ours is the 1st
	}
}

STDMETHODIMP CCertMgrDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetc->cfFormat == m_CFMultiSel)
    {
        ASSERT(((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie);
        if ( ((CCertMgrCookie*) MMC_MULTI_SELECT_COOKIE) == m_pCookie )
        {
            hr = CreateMultiSelectObject (lpMedium);
        }
        else
            hr = E_FAIL;
    }

    return hr;
}

STDMETHODIMP CCertMgrDataObject::Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;

    if ((rgelt == NULL) ||
        ((celt > 1) && (pceltFetched == NULL)))
    {
        hr = E_INVALIDARG;
        CHECK_HRESULT(hr);
        return hr;
    }

    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    if (pceltFetched)
        *pceltFetched = celtTemp;

    if (celtTemp == 0)
        return S_FALSE;

    for (ULONG i=0; i < celtTemp; ++i)
    {
        rgelt[i] = reinterpret_cast<MMC_COOKIE>(m_rgCookies[m_iCurr++]);
    }

    return (celtTemp < celt) ? S_FALSE : S_OK;
}

STDMETHODIMP CCertMgrDataObject::Skip(ULONG celt)
{
    ULONG celtTemp = (ULONG)(m_rgCookies.GetSize() - m_iCurr);
    celtTemp = (celt < celtTemp) ? celt : celtTemp;

    m_iCurr += celtTemp;

    return (celtTemp < celt) ? S_FALSE : S_OK;
}


STDMETHODIMP CCertMgrDataObject::Reset(void)
{
    m_iCurr = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\dbg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dbg.h
//
//  Contents:   
//
//----------------------------------------------------------------------------


#pragma warning(push, 3)
#include "StdDbg.h"
#pragma warning(pop)

#if DBG==1
    DECLARE_DEBUG(CertificateManagerSnapin)
    #define DBG_COMP    CertificateManagerSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       debug.cpp
//
//  Contents:   Debugging support
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <strsafe.h>

#if DBG == 1
static int indentLevel = 0;

#define DEBUG_OUTPUT_NONE       0
#define DEBUG_OUTPUT_ERROR      1
#define DEBUG_OUTPUT_WARNING    2
#define DEBUG_OUTPUT_TRACE      3
#define DEBUGLEVEL  L"debugOutput"

static bool             g_fDebugOutputLevelInit = false;
static unsigned long    g_ulDebugOutput = DEBUG_OUTPUT_NONE;

void __cdecl _TRACE (int level, const wchar_t *format, ... )
{
    if ( g_ulDebugOutput > DEBUG_OUTPUT_NONE )
    {
        va_list arglist;
        const size_t DEBUG_BUF_LEN = 512;
        WCHAR Buffer[DEBUG_BUF_LEN];
        Buffer[0] = 0;

        if ( level < 0 )
            indentLevel += level;
        //
        // Format the output into a buffer and then print it.
        //
        wstring strTabs;

        for (int nLevel = 0; nLevel < indentLevel; nLevel++)
            strTabs += L"  ";

        OutputDebugStringW (strTabs.c_str ());

        va_start(arglist, format);

        // security review 2/27/2002 BryanWal
        // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
        // NTRAID Bug9 611409 prefast: certmgr: debug.cpp(52) : warning 53: 
        //          Call to '_vsnwprintf' may not zero-terminate string 'Buffer'.
        // Don't check return value - we don't care if this gets truncated as
        // it's just debugging output
        if ( SUCCEEDED (::StringCchVPrintf (Buffer,
                        DEBUG_BUF_LEN,
                        format,
                        arglist)) )
        {   
            // check return value to quiet prefast
        }

        if ( Buffer[0] )
            OutputDebugStringW (Buffer);

        va_end(arglist);

        if ( level > 0 )
            indentLevel += level;
    }
}


PCSTR StripDirPrefixA (PCSTR pszPathName)

/*++

Routine Description:

    Strip the directory prefix off a filename (ANSI version)

Arguments:

    pstrFilename - Pointer to filename string

Return Value:

    Pointer to the last component of a filename (without directory prefix)

--*/

{
    ASSERT (pszPathName);
    if ( !pszPathName )
        return 0;

    // security review 2/27/2002 BryanWal ok
    DWORD dwLen = lstrlenA (pszPathName);

    pszPathName += dwLen - 1;       // go to the end

    while (*pszPathName != '\\' && dwLen--)
    {
        pszPathName--;
    }

    return pszPathName + 1;
}

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------
void CheckDebugOutputLevel ()
{
    if ( g_fDebugOutputLevelInit ) 
        return;

    g_fDebugOutputLevelInit = true;
    HKEY    hKey = 0;
    DWORD   dwDisposition = 0;
    LONG lResult = ::RegCreateKeyEx (HKEY_LOCAL_MACHINE, // handle of an open key
            DEBUGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            // security review 2/27/2002 BryanWal ok
            KEY_ALL_ACCESS,    // desired security access - required to create new key
            NULL,     // address of key security structure
            &hKey,      // address of buffer for opened handle
            &dwDisposition);  // address of disposition value buffer
    if (lResult == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(unsigned long);
        DWORD   dwType = REG_DWORD;
        // security review 2/27/2002 BryanWal ok
        lResult = ::RegQueryValueExW (hKey, DEBUGLEVEL, NULL, &dwType,
                                (LPBYTE)&g_ulDebugOutput, &dwSize);
        if (lResult != ERROR_SUCCESS)
        {
            g_ulDebugOutput = DEBUG_OUTPUT_NONE;
            if ( ERROR_FILE_NOT_FOUND == lResult )
            {
                // security review 2/27/2002 BryanWal ok
                ::RegSetValueExW (hKey, DEBUGLEVEL, 0, REG_DWORD,
                        (LPBYTE)&g_ulDebugOutput, sizeof (g_ulDebugOutput));
            }
        }
        else
        {
            ASSERT (REG_DWORD == dwType);
        }
        ::RegCloseKey(hKey);
    }
}

#endif  // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\dataobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       dataobj.h
//
//  Contents:
//
//----------------------------------------------------------------------------

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__


// For use in multiple selection.
LPDATAOBJECT ExtractMultiSelect (LPDATAOBJECT lpDataObject);


class CCertMgrDataObject : public CDataObject
{
	DECLARE_NOT_AGGREGATABLE(CCertMgrDataObject)

public:

// debug refcount
#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

	CCertMgrDataObject();

	virtual ~CCertMgrDataObject();

	STDMETHODIMP Next(ULONG celt, MMC_COOKIE* rgelt, ULONG *pceltFetched);
	STDMETHODIMP Skip(ULONG celt);
	STDMETHODIMP Reset(void);
	void AddCookie(CCertMgrCookie* pCookie);
	virtual HRESULT Initialize (
			CCertMgrCookie* pcookie,
			DATA_OBJECT_TYPES type,
			BOOL fAllowOverrideMachineName,
			DWORD	dwLocation,
			CString	szManagedUser,
			CString szManagedComputer,
			CString szManagedService,
			CCertMgrComponentData& refComponentData);

	// IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
		FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

    HRESULT PutDisplayName(STGMEDIUM* pMedium);
	HRESULT PutServiceName(STGMEDIUM* pMedium);
	void SetMultiSelData(BYTE* pbMultiSelData, UINT cbMultiSelData);
	STDMETHODIMP GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(IsMultiSelect)(void)
    {
        return (m_rgCookies.GetSize() > 1) ? S_OK : S_FALSE;
    }

protected:
	HRESULT CreateMultiSelectObject(LPSTGMEDIUM lpMedium);
	HRESULT Create (const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
	HRESULT CreateGPTUnknown(LPSTGMEDIUM lpMedium) ;
	HRESULT CreateRSOPUnknown(LPSTGMEDIUM lpMedium) ;
	CCertMgrCookie* m_pCookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
	CertificateManagerObjectType m_objecttype;
	DATA_OBJECT_TYPES m_dataobjecttype;
	BOOL m_fAllowOverrideMachineName;	// From CCertMgrComponentData
	GUID m_SnapInCLSID;

public:
	HRESULT SetGPTInformation (IGPEInformation* pGPTInformation);
	HRESULT SetRSOPInformation (IRSOPInformation* pRSOPInformation);

	// Clipboard formats
	static CLIPFORMAT m_CFDisplayName;
	static CLIPFORMAT m_CFMachineName;
    static CLIPFORMAT m_CFMultiSel;        // Required for multiple selection
    static CLIPFORMAT m_CFMultiSelDobj;    // Required for multiple selection
	static CLIPFORMAT m_CFSCEModeType;	 // For SCE snapin mode type
	static CLIPFORMAT m_CFSCE_GPTUnknown;	 // For IUnknown of GPT (which SCE extends)
	static CLIPFORMAT m_CFSCE_RSOPUnknown;	 // For IUnknown of GPT (which SCE extends)
	static CLIPFORMAT m_CFMultiSelDataObjs;// for Multiple selection

private:
    // data member used by IEnumCookies
    ULONG							m_iCurr;
	CCookiePtrArray					m_rgCookies;
	bool							m_bMultiSelDobj;
	IGPEInformation*				m_pGPEInformation;
	IRSOPInformation*				m_pRSOPInformation;
    BYTE*							m_pbMultiSelData;
    UINT							m_cbMultiSelData;
	CString							m_szManagedComputer;
	CString							m_szManagedUser;
	CString							m_szManagedService;
	DWORD							m_dwLocation;

public:
    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = true;
    }
}; // CCertMgrDataObject

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\efsgeneralpropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001-2002.
//
//  File:       EFSGeneralPropertyPage.cpp
//
//  Contents:   Implementation of CEFSGeneralPropertyPage
//
//----------------------------------------------------------------------------
// EFSGeneralPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "EFSGeneralPropertyPage.h"
#include "compdata.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CEFSGeneralPropertyPage property page

CEFSGeneralPropertyPage::CEFSGeneralPropertyPage(CCertMgrComponentData* pCompData, bool bIsMachine) 
: CHelpPropertyPage(CEFSGeneralPropertyPage::IDD),
    m_bIsMachine (bIsMachine),
    m_hGroupPolicyKey (0),
    m_pGPEInformation (pCompData ? pCompData->GetGPEInformation () : 0),
    m_pCompData (pCompData),
    m_bDirty (false)
{
	//{{AFX_DATA_INIT(CEFSGeneralPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    if ( m_pCompData )
        m_pCompData->AddRef ();

    if ( m_pGPEInformation )
    {
        HRESULT hResult = m_pGPEInformation->GetRegistryKey (m_bIsMachine ?
                GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
    } 
}

CEFSGeneralPropertyPage::~CEFSGeneralPropertyPage()
{
    if ( m_pCompData )
        m_pCompData->Release ();
}

void CEFSGeneralPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEFSGeneralPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEFSGeneralPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CEFSGeneralPropertyPage)
	ON_BN_CLICKED(IDC_TURN_ON_EFS, OnTurnOnEfs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEFSGeneralPropertyPage message handlers

BOOL CEFSGeneralPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
    // The regkey to disable EFS is:
    // HKLM\Software\Policies\Microsoft\Windows NT\CurrentVersion\EFS\EfsConfiguration   DWORD 0x00000001 =>Disable EFS

    // If this is the RSOP, make it read-only
    if ( !m_pGPEInformation )
    {
        // Make the page read-only
        GetDlgItem (IDC_TURN_ON_EFS)->EnableWindow (FALSE);

        RSOPGetEFSFlags ();
    }
    else
    {
        GPEGetEFSFlags ();
    }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CEFSGeneralPropertyPage::GPEGetEFSFlags()
{

    HKEY hKey = 0;
    LONG lResult = ::RegOpenKeyEx (m_hGroupPolicyKey,         // handle to open key
            EFS_SETTINGS_REGPATH,  // subkey name
            0,   // reserved
            KEY_READ, // security access mask
            &hKey);    // handle to open key
    if ( ERROR_SUCCESS == lResult )
    {
        // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        // security review 2/22/2002 BryanWal ok
        lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
		        EFS_SETTINGS_REGVALUE,  // address of name of value to query
			    0,              // reserved
	            &dwType,        // address of buffer for value type
		        (LPBYTE) &dwData,       // address of data buffer
			    &cbData);           // address of data buffer size);
		ASSERT ((ERROR_SUCCESS == lResult && REG_DWORD == dwType) || ERROR_FILE_NOT_FOUND == lResult);
        if ( (ERROR_SUCCESS == lResult && REG_DWORD == dwType) || ERROR_FILE_NOT_FOUND == lResult )
		{
            if ( 0 == dwData )  // 0 means enable EFS
                SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
		}
        else
            DisplaySystemError (NULL, lResult);

        ::RegCloseKey (hKey);
    }
    else    // no key means EFS enabled
        SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
}

void CEFSGeneralPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CEFSGeneralPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_TURN_ON_EFS,    IDH_TURN_ON_EFS,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_TURN_ON_EFS:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CEFSGeneralPropertyPage::DoContextHelp\n");
}

void CEFSGeneralPropertyPage::RSOPGetEFSFlags()
{
    if ( m_pCompData )
    {
        const CRSOPObjectArray* pObjectArray = 
                m_bIsMachine ? m_pCompData->GetRSOPObjectArrayComputer () : 
                        m_pCompData->GetRSOPObjectArrayUser ();
        int     nIndex = 0;
        bool    bFound = false;
        // NOTE: rsop object array is sorted first by registry key, then by precedence
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // Consider only entries from this store
                // security review 2/22/2002 BryanWal ok
                if ( !_wcsicmp (EFS_SETTINGS_REGPATH, pObject->GetRegistryKey ()) &&
						!_wcsicmp (EFS_SETTINGS_REGVALUE, pObject->GetValueName ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    if ( 0 == pObject->GetDWORDValue () )  // 0 means enable EFS
                        SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
                    bFound = true;
                    break;
                }
            }
            else
                break;

            nIndex++;
        }

        if ( !bFound )  // not found means EFS enabled
            SendDlgItemMessage (IDC_TURN_ON_EFS, BM_SETCHECK, BST_CHECKED);
    }
}

BOOL CEFSGeneralPropertyPage::OnApply() 
{
    if ( m_bDirty && m_pGPEInformation )
    {
        // Unchecked means disable EFS - set flag to 1
        if ( BST_UNCHECKED == SendDlgItemMessage (IDC_TURN_ON_EFS, BM_GETCHECK) )
        {
            // Create Key
            HKEY    hKey = 0;
            DWORD   dwDisposition = 0;
            LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
                    EFS_SETTINGS_REGPATH,     // address of subkey name
                    0,   // reserved
                    L"",       // address of class string
                    REG_OPTION_NON_VOLATILE,      // special options flag
                    // security review 2/22/2002 BryanWal ok
                    KEY_SET_VALUE,    // desired security access
                    NULL,     // address of key security structure
			        &hKey,      // address of buffer for opened handle
		            &dwDisposition);  // address of disposition value buffer
	        ASSERT (lResult == ERROR_SUCCESS);
            if ( lResult == ERROR_SUCCESS )
            {
                DWORD   dwData = 0x01;   // 0 means disable EFS
                DWORD   cbData = sizeof (dwData);
                lResult = ::RegSetValueEx (hKey,
				            EFS_SETTINGS_REGVALUE, // address of value to set
				            0,              // reserved
				            REG_DWORD,          // flag for value type
				            (CONST BYTE *) &dwData, // address of value data
				            cbData);        // size of value data);
                ASSERT (ERROR_SUCCESS == lResult);
                if ( ERROR_SUCCESS == lResult )
	            {
			        // TRUE means we're changing the machine policy only
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidExtension, &g_guidSnapin);
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidRegExt, &g_guidSnapin);
		        }
		        else
                    DisplaySystemError (m_hWnd, lResult);

                ::RegCloseKey (hKey);
            }
        }
        else
        {
            // Delete Key
            HKEY hKey = 0;
            LONG lResult = ::RegOpenKeyEx (m_hGroupPolicyKey,         // handle to open key
                    EFS_SETTINGS_REGPATH,  // subkey name
                    0,   // reserved
                    // security review 2/22/2002 BryanWal ok KEY_ALL_ACCESS required to delete
                    KEY_ALL_ACCESS, // security access mask
                    &hKey);    // handle to open key
            if ( ERROR_SUCCESS == lResult )
            {
                lResult =  ::RegDeleteValue (hKey,       // handle of key to query
		                EFS_SETTINGS_REGVALUE);
                ASSERT (ERROR_SUCCESS == lResult);
                if ( ERROR_SUCCESS == lResult )
                {
			        // TRUE means we're changing the machine policy only
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidExtension, &g_guidSnapin);
                    m_pGPEInformation->PolicyChanged (m_bIsMachine ? TRUE : FALSE, 
                            TRUE, &g_guidRegExt, &g_guidSnapin);
                }
                else if ( ERROR_FILE_NOT_FOUND != lResult )
                {
                    CString text;
                    CString caption;

                    // security review 2/22/2002 BryanWal ok
                    text.FormatMessage (IDS_CANNOT_SET_EFS_VALUE, lResult);
                    VERIFY (caption.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));

                    MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                    return FALSE;
                }

                ::RegCloseKey (hKey);
            }  
            else if ( ERROR_FILE_NOT_FOUND != lResult ) // expected error
            {
                CString text;
                CString caption;

                // security review 2/22/2002 BryanWal ok
                text.FormatMessage (IDS_CANNOT_SET_EFS_VALUE, lResult);
                VERIFY (caption.LoadString (IDS_PUBLIC_KEY_POLICIES_NODE_NAME));

                MessageBox (text, caption, MB_OK | MB_ICONWARNING);
                return FALSE;
            }
        }
    }
	
	return CHelpPropertyPage::OnApply();
}

void CEFSGeneralPropertyPage::OnTurnOnEfs() 
{
	SetModified ();
    m_bDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\efsgeneralpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       EFSGeneralPropertyPage.h
//
//  Contents:   Declaration of CEFSGeneralPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_EFSGENERALPROPERTYPAGE_H__C1A52682_9D6B_4436_AD3E_F47232BF7B88__INCLUDED_)
#define AFX_EFSGENERALPROPERTYPAGE_H__C1A52682_9D6B_4436_AD3E_F47232BF7B88__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// EFSGeneralPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEFSGeneralPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CEFSGeneralPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CEFSGeneralPropertyPage(CCertMgrComponentData* pCompData, bool bIsMachine);
	~CEFSGeneralPropertyPage();

// Dialog Data
	//{{AFX_DATA(CEFSGeneralPropertyPage)
	enum { IDD = IDD_EFS_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CEFSGeneralPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CEFSGeneralPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnTurnOnEfs();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void RSOPGetEFSFlags ();
    virtual void DoContextHelp (HWND hWndControl);
    void GPEGetEFSFlags();

private:
    const bool              m_bIsMachine;
    CCertMgrComponentData*  m_pCompData;
	IGPEInformation*	    m_pGPEInformation;
	HKEY				    m_hGroupPolicyKey;
    bool                    m_bDirty;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_EFSGENERALPROPERTYPAGE_H__C1A52682_9D6B_4436_AD3E_F47232BF7B88__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\finddlglistctrl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       FindDlgListCtrl.h
//
//  Contents:   Implementation for cert find dialog list control
//
//----------------------------------------------------------------------------
// FindDlgListCtrl.cpp : implementation file
//

#include "stdafx.h"
#include <winuser.h>
#include "certmgr.h"
#include "FindDlgListCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFindDlgListCtrl

CFindDlgListCtrl::CFindDlgListCtrl() :
    m_bSubclassed (false)
{
}

CFindDlgListCtrl::~CFindDlgListCtrl()
{
}


BEGIN_MESSAGE_MAP(CFindDlgListCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CFindDlgListCtrl)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFindDlgListCtrl message handlers

// Grab the Enter key.  Let all others through
LRESULT OnMyGetDlgCode (HWND hWnd, WPARAM /*wParam*/, LPARAM lParam)
{
    if ( hWnd )
    {
        MSG* pMsg = (MSG*)lParam;
        if ( pMsg )
        {
            if ( ( WM_KEYDOWN == pMsg->message ) &&
                ( VK_RETURN == LOWORD (pMsg->wParam)) )
            {
                return DLGC_WANTALLKEYS;
            }
        }
    }

    return 0;
}

WNDPROC g_wpOrigEditProc = 0;

// Subclass procedure 
LRESULT APIENTRY EditSubclassProc(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam) 
{ 
    if ( WM_GETDLGCODE == uMsg ) 
    {
        LRESULT lResult = OnMyGetDlgCode (hWnd, wParam, lParam); 
        if ( lResult )
            return lResult; // otherwise, call the def proc
    }


 
    return ::CallWindowProc (g_wpOrigEditProc, hWnd, uMsg, 
        wParam, lParam); 
}

void CFindDlgListCtrl::OnDestroy() 
{
    ::SetWindowLongPtr (m_hWnd, GWLP_WNDPROC, 
                (LONG_PTR) g_wpOrigEditProc); 

    CListCtrl::OnDestroy();
}

// Subclass the edit control so that we can overload processing for 
// WM_GETDLGCODE
// We want to trap this message in the edit control and request all codes when 
// the Enter key is pressed and allow default processing at all other times.
LRESULT CFindDlgListCtrl::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
{
    if ( 0x1003 == message )  // I can't find a #define for this message
    {
        if ( m_hWnd && !m_bSubclassed )
        {
            // Subclass the edit control. 
            g_wpOrigEditProc = (WNDPROC) ::SetWindowLongPtr (m_hWnd, 
                    GWLP_WNDPROC, reinterpret_cast <LONG_PTR>(EditSubclassProc)); 
            m_bSubclassed = true;
        }
    }
    
    return CListCtrl::WindowProc(message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\finddlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002
//
//  File:       FindDlg.cpp
//
//  Contents:   implementation Find certificate dialog
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#pragma warning(push, 3)
#include <process.h>
#pragma warning(pop)
#include "mbstring.h"
#include "FindDlg.h"
#include "cookie.h"
#include <wintrust.h>
#include <cryptui.h>
#include "compdata.h"
USE_HANDLE_MACROS("CERTMGR(finddlg.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFindDialog dialog
const WCHAR chLEFT_TO_RIGHT = 0x200e;


CFindDialog::CFindDialog (CWnd* pParent,
        const CString &pcszMachineName,
        const CString &szFileName,
        CCertMgrComponentData* pCompData)
    : CHelpDialog(CFindDialog::IDD, pParent),
    m_cyOriginal (0),
    m_fWindowExpandedOnce (false),
    m_cyMin (0),
    m_cxBtnMargin (0),
    m_cxMin (0),
    m_cxAnimMargin (0),
    m_cxStoreListMargin (0),
    m_cxContainMargin (0),
    m_cxTabMargin (0),
    m_cxFieldListMargin (0),
    m_cxResultListMargin (0),
    m_szMachineName (pcszMachineName),
    m_bAnimationRunning (false),
    m_szFileName (szFileName),
    m_hSearchThread (0),
    m_singleLock (&m_critSec, FALSE),
    m_pCompData (pCompData),
    m_bConsoleRefreshRequired (false),
    m_hCancelSearchEvent (0),
    m_bInitComplete (false),
    m_bViewArchivedCerts (pCompData->ShowArchivedCerts ()),
    m_bStoreIsOpenedToViewArchiveCerts (pCompData->ShowArchivedCerts ())
{
    _TRACE (1, L"Entering CFindDialog::CFindDialog\n");
    //{{AFX_DATA_INIT(CFindDialog)
    m_szContains = _T("");
    m_szSearchField = _T("");
    m_szSelectedStore = _T("");
    //}}AFX_DATA_INIT

    // Get name of logged-in user
    DWORD   dwSize = 0;
    ::GetUserName (0, &dwSize);
    ASSERT (dwSize > 0);
    if ( dwSize > 0 )
    {
        BOOL bRet = ::GetUserName (m_szLoggedInUser.GetBufferSetLength (dwSize), &dwSize);
        ASSERT (bRet);
        m_szLoggedInUser.ReleaseBuffer ();
    }

    // security review 2/22/2002 BryanWal ok
    m_hCancelSearchEvent = CreateEvent(
        NULL,   // pointer to security attributes
        TRUE,  // flag for manual-reset event
        FALSE, // flag for initial state
        L"CancelSearchEvent");     // pointer to event-object name
    if ( !m_hCancelSearchEvent )
    {
        _TRACE (0, L"CreateEvent (CancelSearchEvent) failed: 0x%x\n", GetLastError ());
    }
    _TRACE (-1, L"Leaving CFindDialog::CFindDialog\n");
}


CFindDialog::~CFindDialog ()
{
    _TRACE (1, L"Entering CFindDialog::~CFindDialog\n");
    if ( m_hSearchThread )
        StopSearch ();
    if ( m_hCancelSearchEvent )
        CloseHandle (m_hCancelSearchEvent);
    _TRACE (-1, L"Leaving CFindDialog::~CFindDialog\n");
}

void CFindDialog::DoDataExchange(CDataExchange* pDX)
{
    CHelpDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CFindDialog)
    DDX_Control(pDX, IDC_STORE_LIST, m_storeList);
    DDX_Control(pDX, IDC_STOP, m_stopBtn);
    DDX_Control(pDX, IDC_RESULT_LIST, m_resultsList);
    DDX_Control(pDX, IDC_NEW_SEARCH, m_newSearchBtn);
    DDX_Control(pDX, IDC_FIND_NOW, m_findNowBtn);
    DDX_Control(pDX, IDC_FIELD_LIST, m_fieldList);
    DDX_Control(pDX, IDC_ANIMATE, m_animate);
    DDX_Text(pDX, IDC_CONTAINS_TEXT, m_szContains);
    DDX_CBString(pDX, IDC_FIELD_LIST, m_szSearchField);
    DDX_CBString(pDX, IDC_STORE_LIST, m_szSelectedStore);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFindDialog, CHelpDialog)
    //{{AFX_MSG_MAP(CFindDialog)
    ON_BN_CLICKED(IDC_FIND_NOW, OnFindNow)
    ON_WM_SIZING()
    ON_WM_DESTROY()
    ON_BN_CLICKED(IDC_NEW_SEARCH, OnNewSearch)
    ON_BN_CLICKED(IDC_STOP, OnStop)
    ON_NOTIFY(NM_RCLICK, IDC_RESULT_LIST, OnRclickResultList)
    ON_NOTIFY(NM_DBLCLK, IDC_RESULT_LIST, OnDblclkResultList)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_RESULT_LIST, OnColumnclickResultList)
    ON_EN_CHANGE(IDC_CONTAINS_TEXT, OnChangeContainsText)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_RESULT_LIST, OnItemchangedResultList)
    ON_WM_CONTEXTMENU()
    ON_WM_SIZE()
    ON_CBN_SELCHANGE(IDC_FIELD_LIST, OnSelchangeFieldList)
    //}}AFX_MSG_MAP
    ON_COMMAND(IDM_PROPERTIES, OnProperties)
    ON_COMMAND(ID_VIEW, OnView)
    ON_COMMAND(ID_ENROLL_SAME_KEY, OnEnrollSameKey)
    ON_COMMAND(ID_ENROLL_NEW_KEY, OnEnrollNewKey)
    ON_COMMAND(ID_FILE_DELETE, OnFileDelete)
    ON_COMMAND(ID_FILE_EXPORT, OnFileExport)
    ON_COMMAND(ID_FILE_RENEW_NEW_KEY, OnFileRenewNewKey)
    ON_COMMAND(ID_FILE_RENEW_SAME_KEY, OnFileRenewSameKey)
    ON_COMMAND(ID_EDIT_INVERTSELECTION, OnEditInvertselection)
    ON_COMMAND(ID_EDIT_SELECTALL, OnEditSelectall)
    ON_COMMAND(ID_FILE_PROPERTIES, OnFileProperties)
    ON_COMMAND(ID_HELP_HELPTOPICS, OnHelpHelptopics)
    ON_COMMAND(IDM_VIEW_DETAILS, OnViewDetails)
    ON_COMMAND(ID_VIEW_LARGEICONS, OnViewLargeicons)
    ON_COMMAND(IDM_VIEW_LIST, OnViewList)
    ON_COMMAND(ID_VIEW_SMALLICONS, OnViewSmallicons)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_NOTIFY(LVN_KEYDOWN, IDC_RESULT_LIST, OnLvnKeydownResultList)
    ON_NOTIFY(NM_SETFOCUS, IDC_RESULT_LIST, OnNMSetfocusResultList)
    ON_NOTIFY(NM_KILLFOCUS, IDC_RESULT_LIST, OnNMKillfocusResultList)
END_MESSAGE_MAP()


BOOL CFindDialog::OnInitDialog()
{
    _TRACE (1, L"Entering CFindDialog::OnInitDialog\n");
    CHelpDialog::OnInitDialog();



    // Set up the menu
    HMENU   hMenu = ::LoadMenu (AfxGetInstanceHandle (),
                MAKEINTRESOURCE (IDR_FIND_DLG_MENU));
    ASSERT (hMenu);
    if ( hMenu )
    {
        if (::SetMenu (m_hWnd, hMenu) )
        {
            // Disable these menu items until the window is expanded when searching
            VERIFY (::EnableMenuItem (hMenu, ID_VIEW_LARGEICONS, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_VIEW_SMALLICONS, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_LIST, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_DETAILS, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_DELETE, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_EXPORT, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_PROPERTIES, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_VIEW, MF_GRAYED) != -1);
        }
        else
            ASSERT (0);
    }

    SetUpResultList ();

    // Size window to hide list view until search is performed
    HideResultList ();

    // Initialize animation
    VERIFY (m_animate.Open (IDR_FINDCERT_AVI));

    // Set up cert store list
    AddLogicalStoresToList ();

    // Set cert field list
    AddFieldsToList ();

    m_findNowBtn.EnableWindow (FALSE);
    m_stopBtn.EnableWindow (FALSE);
    m_newSearchBtn.EnableWindow (FALSE);
    
    m_bInitComplete = true;
    _TRACE (-1, L"Leaving CFindDialog::OnInitDialog\n");
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CFindDialog::OnFindNow()
{
    _TRACE (1, L"Entering CFindDialog::OnFindNow\n");
    // Disable the controls during the search
    GetDlgItem (IDC_CONTAINS_TEXT)->EnableWindow (FALSE);
    m_resultsList.EnableWindow (FALSE);
    m_fieldList.EnableWindow (FALSE);
    m_storeList.EnableWindow (FALSE);
    m_findNowBtn.EnableWindow (FALSE);
    m_newSearchBtn.EnableWindow (FALSE);
    m_stopBtn.EnableWindow (TRUE);
    m_stopBtn.SetFocus ();

    VERIFY (m_animate.Play (0, (UINT) -1, (UINT) -1));
    m_bAnimationRunning = true;
    UpdateData (TRUE);
    DeleteAllResultItems ();


    if ( !m_fWindowExpandedOnce )
    {
//        ChangeToSizableFrame ();
        ExpandWindow ();
    }

    DoSearch ();

    EnableMenuItems ();

}

void CFindDialog::EnableMenuItems ()
{
    _TRACE (1, L"Entering CFindDialog::EnableMenuItems\n");
    HMENU   hMenu = ::GetMenu (m_hWnd);
    ASSERT (hMenu);
    if ( hMenu )
    {
        int nCnt = m_resultsList.GetItemCount ();
        if ( nCnt > 0 )
        {
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_ENABLED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_ENABLED) != -1);
        }
        else
        {
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_GRAYED) != -1);
        }

        UINT    nSelCnt = m_resultsList.GetSelectedCount ();

        VERIFY (::EnableMenuItem (hMenu, ID_FILE_DELETE,
                (nSelCnt >= 1) ? MF_ENABLED : MF_GRAYED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_FILE_EXPORT,
                (nSelCnt >= 1) ? MF_ENABLED : MF_GRAYED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_FILE_PROPERTIES,
                (nSelCnt == 1) ? MF_ENABLED : MF_GRAYED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_VIEW,
                (nSelCnt == 1) ? MF_ENABLED : MF_GRAYED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY, MF_GRAYED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY, MF_GRAYED) != -1);
        if ( nSelCnt == 1 )
        {
            int             nSelItem = 0;
            CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
            ASSERT (pCert);
            if ( pCert )
            {
                bool bIsMyStore = (pCert->GetStoreType () == MY_STORE);
                if ( bIsMyStore && CERT_SYSTEM_STORE_SERVICES != m_pCompData->GetLocation () )
                {
                    VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY,
                            MF_ENABLED) != -1);
                    VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY,
                            MF_ENABLED) != -1);
                }
            }
        }   
    }   
    _TRACE (-1, L"Leaving CFindDialog::EnableMenuItems\n");
}


void CFindDialog::OnSize (UINT nType, int cx, int cy)
{
    CHelpDialog::OnSize (nType, cx, cy);

    MoveControls ();
}


void CFindDialog::OnSizing (UINT nSide, LPRECT lpRect)
{
    _TRACE (1, L"Entering CFindDialog::OnSizing\n");
    int cyHeight = lpRect->bottom - lpRect->top;
    int cxWidth = lpRect->right - lpRect->left;

    // If the user has never pressed "Find Now", don't let the user expand the window down
    // Don't let the user shrink the window below it's initial state - I don't want to deal with
    // control compression!
    switch (nSide)
    {
    case WMSZ_BOTTOM:
        if ( !m_fWindowExpandedOnce )
            lpRect->top = lpRect->bottom - m_cyMin;
        else
        {
            if ( cyHeight < m_cyMin )
                lpRect->bottom = lpRect->top + m_cyMin;
        }
        break;
        
    case WMSZ_BOTTOMLEFT:
        if ( cxWidth < m_cxMin )
            lpRect->left = lpRect->right - m_cxMin;
        if ( !m_fWindowExpandedOnce )
            lpRect->top = lpRect->bottom - m_cyMin;
        else
        {
            if ( cyHeight < m_cyMin )
                lpRect->bottom = lpRect->top + m_cyMin;
        }
        break;
        
    case WMSZ_BOTTOMRIGHT:
        if ( cxWidth < m_cxMin )
            lpRect->right = lpRect->left + m_cxMin;
        if ( !m_fWindowExpandedOnce )
            lpRect->bottom = lpRect->top + m_cyMin;
        else
        {
            if ( cyHeight < m_cyMin )
                lpRect->bottom = lpRect->top + m_cyMin;
        }
        break;
        
    case WMSZ_TOP:
        if ( !m_fWindowExpandedOnce )
            lpRect->top = lpRect->bottom - m_cyMin;
        else
        {
            if ( cyHeight < m_cyMin )
                lpRect->top = lpRect->bottom - m_cyMin;
        }
        break;
        
    case WMSZ_TOPLEFT:
        if ( cxWidth < m_cxMin )
            lpRect->left = lpRect->right - m_cxMin;
        if ( !m_fWindowExpandedOnce )
            lpRect->top = lpRect->bottom - m_cyMin;
        else
        {
            if ( cyHeight < m_cyMin )
                lpRect->top = lpRect->bottom - m_cyMin;
        }
        break;
        
    case WMSZ_TOPRIGHT:
        if ( cxWidth < m_cxMin )
            lpRect->right = lpRect->left + m_cxMin;
        if ( !m_fWindowExpandedOnce )
            lpRect->top = lpRect->bottom - m_cyMin;
        else
        {
            if ( cyHeight < m_cyMin )
                lpRect->top = lpRect->bottom - m_cyMin;
        }
        break;
        
    case WMSZ_RIGHT:
        if ( cxWidth < m_cxMin )
            lpRect->right = lpRect->left + m_cxMin;
        break;
        
    case WMSZ_LEFT:
        if ( cxWidth < m_cxMin )
            lpRect->left = lpRect->right - m_cxMin;
        break;
        
    default:
        break;
    }
    
    
    CHelpDialog::OnSizing (nSide, lpRect);

    _TRACE (-1, L"Leaving CFindDialog::OnSizing\n");
}


void CFindDialog::MoveControls ()
{
    _TRACE (1, L"Entering CFindDialog::MoveControls\n");

    if ( !m_hWnd || !m_bInitComplete )
        return;

    // Only come down here if the window has already been created.

    // Keep buttons glued to the right
    CRect   rcDlg;
    GetWindowRect (&rcDlg); // returned in screen coords
    ScreenToClient (&rcDlg);    


    // Move "Stop" button
    CRect   rcCtrl;
    m_stopBtn.GetWindowRect (&rcCtrl);  // returned in screen coords
    ScreenToClient (&rcCtrl);
    int cxCtrl = rcCtrl.right - rcCtrl.left;
    rcCtrl.right = rcDlg.right - m_cxBtnMargin;
    rcCtrl.left = rcCtrl.right - cxCtrl;
    m_stopBtn.MoveWindow (rcCtrl);  // child window coords relative to parent client

    // Move "Find Now" button
    m_findNowBtn.GetWindowRect (&rcCtrl);   // returned in screen coords
    ScreenToClient (&rcCtrl);
    cxCtrl = rcCtrl.right - rcCtrl.left;
    rcCtrl.right = rcDlg.right - m_cxBtnMargin;
    rcCtrl.left = rcCtrl.right - cxCtrl;
    m_findNowBtn.MoveWindow (rcCtrl);   // child window coords relative to parent client

    // Move "New Search" button
    m_newSearchBtn.GetWindowRect (&rcCtrl); // returned in screen coords
    ScreenToClient (&rcCtrl);
    cxCtrl = rcCtrl.right - rcCtrl.left;
    rcCtrl.right = rcDlg.right - m_cxBtnMargin;
    rcCtrl.left = rcCtrl.right - cxCtrl;
    m_newSearchBtn.MoveWindow (rcCtrl); // child window coords relative to parent client

    // Move animation control
    m_animate.GetWindowRect (&rcCtrl);  // returned in screen coords
    ScreenToClient (&rcCtrl);
    cxCtrl = rcCtrl.right - rcCtrl.left;
    rcCtrl.right = rcDlg.right - m_cxAnimMargin;
    rcCtrl.left = rcCtrl.right - cxCtrl;
    m_animate.MoveWindow (rcCtrl);  // child window coords relative to parent client

    // Stretch store list control
    m_storeList.GetWindowRect (&rcCtrl);    // returned in screen coords
    ScreenToClient (&rcCtrl);
    rcCtrl.right = rcDlg.right - m_cxStoreListMargin;
    m_storeList.MoveWindow (rcCtrl);    // child window coords relative to parent client

    // Stretch "contains" edit control
    GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowRect (&rcCtrl);
    ScreenToClient (&rcCtrl);
    rcCtrl.right = rcDlg.right - m_cxContainMargin;
    GetDlgItem (IDC_CONTAINS_TEXT)->MoveWindow (rcCtrl);
    
    // Stretch field list control
    m_singleLock.Lock ();
    m_fieldList.GetWindowRect (&rcCtrl);    // returned in screen coords
    m_singleLock.Unlock ();
    ScreenToClient (&rcCtrl);
    rcCtrl.right = rcDlg.right - m_cxFieldListMargin;
    m_singleLock.Lock ();
    m_fieldList.MoveWindow (rcCtrl);    // child window coords relative to parent client
    m_singleLock.Unlock ();
    m_fieldList.InvalidateRect (NULL, TRUE);

    // Stretch list view to right edge and to bottom
    int cyResultListMargin = 0;
    if ( m_statusBar.m_hWnd )
    {
        // If the status bar has already been created, we need to take that
        // account when we resize the list view
        CRect   rcStatusBar;
        m_statusBar.GetWindowRect (&rcStatusBar);
        cyResultListMargin = (rcStatusBar.bottom - rcStatusBar.top)
            + ::GetSystemMetrics (SM_CYDLGFRAME);
    }

    m_resultsList.GetWindowRect (&rcCtrl);  // returned in screen coords
    ScreenToClient (&rcCtrl);
    rcCtrl.right = rcDlg.right - m_cxResultListMargin;
    if ( m_fWindowExpandedOnce )
        rcCtrl.bottom = rcDlg.bottom - cyResultListMargin;
    m_resultsList.MoveWindow (rcCtrl);  // child window coords relative to parent client

    // Resize last column to fill results list window
    int nNewWidth = rcCtrl.right - (m_resultsList.GetColumnWidth (COL_ISSUED_TO) +
        m_resultsList.GetColumnWidth (COL_ISSUED_BY) +
        m_resultsList.GetColumnWidth (COL_EXPIRATION_DATE) +
        m_resultsList.GetColumnWidth (COL_PURPOSES) +
        m_resultsList.GetColumnWidth (COL_FRIENDLY_NAME));
    if ( nNewWidth > m_resultsList.GetColumnWidth (COL_SOURCE_STORE) )
        VERIFY (m_resultsList.SetColumnWidth (COL_SOURCE_STORE, nNewWidth));



    // Stretch status bar to right edge
    if ( m_statusBar.m_hWnd )
    {
        m_statusBar.GetWindowRect (&rcCtrl);    // returned in screen coords
        ScreenToClient (&rcCtrl);
        int cyCtrl = rcCtrl.bottom - rcCtrl.top;
        rcCtrl.right = rcDlg.right;
        rcCtrl.bottom = rcDlg.bottom;
        rcCtrl.top = rcCtrl.bottom - cyCtrl;
        m_statusBar.MoveWindow (rcCtrl);    // child window coords relative to parent client
    }
    _TRACE (-1, L"Leaving CFindDialog::MoveControls\n");
}


typedef struct _ENUM_ARG {
    DWORD                   dwFlags;
    CComboBox*              m_pComboBox;
    LPCWSTR                 m_szMachineName;
    IConsole*               m_pConsole;
    bool                    m_bViewArchivedCerts;
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumFindDlgSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD dwFlags,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void* /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    _TRACE (1, L"Entering EnumFindDlgSysCallback\n");
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;

    // Create new cookies
    SPECIAL_STORE_TYPE  storeType = GetSpecialStoreType ((LPWSTR) pwszSystemStore);

    //
    // We will not expose the ACRS store for machines or users.  It is not
    // interesting or useful at this level.  All Auto Cert Requests should
    // be managed only at the policy level.
    //
    if ( ACRS_STORE != storeType )
    {
        if ( pEnumArg->m_bViewArchivedCerts  )
            dwFlags |= CERT_STORE_ENUM_ARCHIVED_FLAG;


        CCertStore* pNewCookie = new CCertStore (CERTMGR_LOG_STORE,
                CERT_STORE_PROV_SYSTEM,
                dwFlags, pEnumArg->m_szMachineName,
                (LPCWSTR) pwszSystemStore,
                (LPCWSTR) pwszSystemStore,
                _T(""), storeType,
                dwFlags,
                pEnumArg->m_pConsole);
        if ( pNewCookie )
        {
            CString storeName = _T("    ");
            int     iResult = 0;
            LPCWSTR localizedName = pNewCookie->GetLocalizedName ();

            if ( localizedName )
                storeName += localizedName;
            else
                storeName += (LPWSTR) pwszSystemStore;
            
            iResult = pEnumArg->m_pComboBox->AddString ((LPCWSTR) storeName);
            ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
            if ( CB_ERR != iResult && CB_ERRSPACE != iResult)
            {
                iResult = pEnumArg->m_pComboBox->SetItemDataPtr (iResult, (void*) pNewCookie);
                ASSERT (CB_ERR != iResult);
            }
            else
                pNewCookie->Release ();
        }
    }

    _TRACE (-1, L"Leaving EnumFindDlgSysCallback\n");
    return TRUE;
}


void CFindDialog::AddLogicalStoresToList ()
{
    _TRACE (1, L"Entering CFindDialog::AddLogicalStoresToList\n");
    CString     text;
    CWaitCursor cursor;

    VERIFY (text.LoadString (IDS_ALL_STORES));
    VERIFY (m_storeList.AddString (text) >= 0);
    VERIFY (m_storeList.SetCurSel (0) != CB_ERR);

    DWORD       dwFlags = m_pCompData->GetLocation ();
    ENUM_ARG    EnumArg;

    // security review 2/22/2002 BryanWal ok     
    ::ZeroMemory (&EnumArg, sizeof(EnumArg));
    EnumArg.dwFlags = dwFlags;
    EnumArg.m_szMachineName = m_szMachineName;
    EnumArg.m_pComboBox = &m_storeList;
    EnumArg.m_pConsole = m_pCompData->m_pConsole;
    EnumArg.m_bViewArchivedCerts = 
            m_bViewArchivedCerts || m_pCompData->ShowArchivedCerts ();
    CString location;
    void*   pvPara = 0;


    if ( !m_pCompData->GetManagedService ().IsEmpty () )
    {
        if ( !m_szMachineName.IsEmpty () )
        {
            location = m_szMachineName + _T("\\") +
                    m_pCompData->GetManagedService ();
            pvPara = (void *) (LPCWSTR) location;
        }
        else
            pvPara = (void *) (LPCWSTR) m_pCompData->GetManagedService ();
    }
    else if ( !m_szMachineName.IsEmpty () )
    {
        pvPara = (void *) (LPCWSTR) m_szMachineName;
    }

    if ( m_szFileName.IsEmpty () )
    {
        // This is not a file store but some kind of system store.
        if ( !::CertEnumSystemStore (dwFlags, pvPara, &EnumArg, EnumFindDlgSysCallback) )
        {
            DWORD   dwErr = GetLastError ();
            CString caption;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            if ( ERROR_ACCESS_DENIED == dwErr )
            {
                VERIFY (text.LoadString (IDS_NO_PERMISSION));

            }
            else
            {
                text.FormatMessage (IDS_CANT_ENUMERATE_SYSTEM_STORES, GetSystemMessage (dwErr));
            }
            CThemeContextActivator activator;
            MessageBox (text, caption, MB_OK);
            if ( ERROR_BAD_NETPATH == dwErr )
            {
                // Close dialog
                PostMessage (WM_CLOSE, 0, 0L);
            }
        }
    }
    else
    {
        //  CertOpenStore with provider type of:
        //  CERT_STORE_PROV_FILE or CERT_STORE_PROV_FILENAME_A
        //  or CERT_STORE_PROV_FILENAME_W.
        //  See online documentation or wincrypt.h for more info.
        // Create new cookies
        CCertStore* pNewCookie = new CCertStore (
                CERTMGR_LOG_STORE,
                CERT_STORE_PROV_FILENAME_W,
                0,
                m_szMachineName,
                m_szFileName, m_szFileName, _T(""), NO_SPECIAL_TYPE,
                m_pCompData->GetLocation (),
                m_pCompData->m_pConsole);
        if ( pNewCookie )
        {
            CString storeName = _T("    ");
            
            storeName += m_szFileName;

            int iResult = m_storeList.AddString ((LPCWSTR) storeName);
            ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
            if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
            {
                iResult = m_storeList.SetItemDataPtr (iResult, (void*) pNewCookie);
                ASSERT (CB_ERR != iResult);
            }
        }
    }
    _TRACE (-1, L"Leaving CFindDialog::AddLogicalStoresToList\n");
}


void CFindDialog::OnDestroy()
{
    _TRACE (1, L"Entering CFindDialog::OnDestroy\n");
    // In case a search is running when the user destroys the window, stop it!
    StopSearch ();

    CHelpDialog::OnDestroy();
    
    CloseAllStores ();  

    DeleteAllResultItems ();

    m_imageListNormal.Destroy ();
    m_imageListSmall.Destroy ();
    _TRACE (-1, L"Leaving CFindDialog::OnDestroy\n");
}

void CFindDialog::CloseAllStores ()
{
    CCertStore* pCookie = 0;
    const   int nCnt = m_storeList.GetCount ();

    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        pCookie = (CCertStore*) m_storeList.GetItemDataPtr (nIndex);
        if ( pCookie )  // one of the items has no cookie
            pCookie->Release ();
    }

    m_storeList.ResetContent ();
}


void CFindDialog::AddFieldsToList()
{
    _TRACE (1, L"Entering CFindDialog::AddFieldsToList\n");
    CString text;
    int     iResult = 0;


    VERIFY (text.LoadString (IDS_FIND_MD5_HASH));
    iResult = m_fieldList.AddString (text);
    ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
    if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
        VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_MD5_HASH) != CB_ERR);

    VERIFY (text.LoadString (IDS_FIND_SHA1_HASH));
    iResult = m_fieldList.AddString (text);
    ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
    if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
        VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_SHA1_HASH) != CB_ERR);

    VERIFY (text.LoadString (IDS_FIND_SUBJECT_NAME));
    iResult = m_fieldList.AddString (text);
    ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
    if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
        VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_SUBJECT_STR_W) != CB_ERR);

    VERIFY (text.LoadString (IDS_FIND_ISSUER_NAME));
    iResult = m_fieldList.AddString (text);
    ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
    if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
    {
        VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_ISSUER_STR_W) != CB_ERR);
        VERIFY (m_fieldList.SetCurSel (iResult) != CB_ERR);
    }

    VERIFY (text.LoadString (IDS_COLUMN_SERIAL_NUMBER));
    iResult = m_fieldList.AddString (text);
    ASSERT (CB_ERR != iResult && CB_ERRSPACE != iResult);
    if ( CB_ERR != iResult && CB_ERRSPACE != iResult )
        VERIFY (m_fieldList.SetItemData (iResult, CERT_FIND_SERIAL_NUMBER) != CB_ERR);
    _TRACE (-1, L"Leaving CFindDialog::AddFieldsToList\n");
}

void CFindDialog::OnNewSearch()
{
    _TRACE (1, L"Entering CFindDialog::OnNewSearch\n");
    CString caption;
    CString text;

    VERIFY (text.LoadString (IDS_CLEAR_SEARCH));
    VERIFY (caption.LoadString (IDS_FIND_CERT));
    CThemeContextActivator activator;
    if ( MessageBox (text, caption, MB_ICONQUESTION | MB_OKCANCEL) == IDOK )
    {
        DeleteAllResultItems ();
        m_singleLock.Lock ();
        VERIFY (m_fieldList.SetCurSel (0) != CB_ERR);
        m_singleLock.Unlock ();

        VERIFY (text.LoadString (IDS_ALL_STORES));
        int nIndex = m_storeList.FindStringExact (-1, text);
        ASSERT (CB_ERR != nIndex);
        if ( CB_ERR != nIndex )
            VERIFY (m_storeList.SetCurSel (nIndex) != CB_ERR);
        GetDlgItem (IDC_CONTAINS_TEXT)->SetWindowText (L"");

        CString statusText;
        VERIFY (statusText.LoadString (IDS_NO_CERTS_FOUND));
        if ( m_statusBar.m_hWnd )
            m_statusBar.SetWindowText (statusText);
        m_newSearchBtn.EnableWindow (FALSE);

        HMENU   hMenu = ::GetMenu (m_hWnd);
        ASSERT (hMenu);
        if ( hMenu )
        {
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_DELETE, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_EXPORT, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_PROPERTIES, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_VIEW, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_SAME_KEY, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_FILE_RENEW_NEW_KEY, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_GRAYED) != -1);
            VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_GRAYED) != -1);
        }   

        GetDlgItem (IDC_CONTAINS_TEXT)->SetFocus ();
    }
    _TRACE (-1, L"Leaving CFindDialog::OnNewSearch\n");
}


void CFindDialog::OnStop()
{
    _TRACE (1, L"Entering CFindDialog::OnStop\n");
    StopSearch ();
    _TRACE (-1, L"Leaving CFindDialog::OnStop\n");
}


void CFindDialog::StopSearch()
{
    _TRACE (1, L"Entering CFindDialog::StopSearch\n");
    if ( m_bAnimationRunning )
    {
        VERIFY (m_animate.Stop ());
        m_bAnimationRunning = false;
    }
    VERIFY (m_animate.Seek (0));

    if ( m_hSearchThread && WaitForSingleObject (m_hSearchThread, 0) != WAIT_OBJECT_0 )  
    {
        VERIFY (SetEvent (m_hCancelSearchEvent));
        if ( WaitForSingleObject (m_hSearchThread, 5000) != WAIT_OBJECT_0 )
        {
            RestoreAfterSearchSettings ();
        }
    }
    
    _TRACE (-1, L"Leaving CFindDialog::StopSearch\n");
}


void CFindDialog::ExpandWindow()
{
    _TRACE (1, L"Entering CFindDialog::ExpandWindow\n");
    ASSERT (!m_fWindowExpandedOnce);
    if ( m_fWindowExpandedOnce )
        return;

    m_fWindowExpandedOnce = true;

    CRect   rcDlg;
    GetWindowRect (&rcDlg);
    VERIFY (SetWindowPos (&wndTop, rcDlg.left, rcDlg.top,
            rcDlg.right - rcDlg.left,
            m_cyOriginal,
            SWP_NOMOVE | SWP_NOOWNERZORDER));

    // Create the status bar
    CRect   rcStatusBar;
    CThemeContextActivator activator;
    VERIFY (m_statusBar.Create (WS_CHILD | WS_VISIBLE | CCS_BOTTOM | SBARS_SIZEGRIP,
            rcStatusBar, this, 1));
    if ( m_statusBar.m_hWnd )
        m_statusBar.GetWindowRect (&rcStatusBar);
    int cyResultListMargin = (rcStatusBar.bottom - rcStatusBar.top)
            + ::GetSystemMetrics (SM_CYDLGFRAME);

    // Stretch list view to right edge and to bottom
    GetWindowRect (&rcDlg);
    ScreenToClient (&rcDlg);    
    CRect   rcCtrl;
    m_resultsList.GetWindowRect (&rcCtrl);  // returned in screen coords
    ScreenToClient (&rcCtrl);
    m_cxResultListMargin = (rcDlg.right - rcCtrl.right); // + ::GetSystemMetrics (SM_CXDLGFRAME);
    rcCtrl.right = rcDlg.right - m_cxResultListMargin;
    rcCtrl.bottom = rcDlg.bottom - cyResultListMargin;
    m_resultsList.MoveWindow (rcCtrl);  // child window coords relative to parent client

    // Permanently enable some menu items
    HMENU   hMenu = ::GetMenu (m_hWnd);
    ASSERT (hMenu);
    if ( hMenu)
    {
        VERIFY (::EnableMenuItem (hMenu, ID_VIEW_LARGEICONS, MF_ENABLED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_VIEW_SMALLICONS, MF_ENABLED) != -1);
        VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_LIST, MF_ENABLED) != -1);
        VERIFY (::EnableMenuItem (hMenu, IDM_VIEW_DETAILS, MF_ENABLED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_EDIT_SELECTALL, MF_ENABLED) != -1);
        VERIFY (::EnableMenuItem (hMenu, ID_EDIT_INVERTSELECTION, MF_ENABLED) != -1);
    }
    _TRACE (-1, L"Leaving CFindDialog::ExpandWindow\n");
}



//DWORD WINAPI FindThreadFunc (LPVOID lpvThreadParm)
void __cdecl FindThreadFunc (LPVOID lpvThreadParm)
{
    _TRACE (1, L"Entering FindThreadFunc\n");
    AFX_MANAGE_STATE (AfxGetStaticModuleState ());
    CFindDialog*    pFindDlg = (CFindDialog*) lpvThreadParm;
    ASSERT (pFindDlg);
    if ( !pFindDlg )
        return; // dwResult;

    pFindDlg->m_singleLock.Lock ();
    int     nCurSel = pFindDlg->m_fieldList.GetCurSel ();
    pFindDlg->m_singleLock.Unlock ();
    ASSERT (CB_ERR != nCurSel);
    if ( CB_ERR != nCurSel )
    {
        CString     statusText;
        pFindDlg->m_singleLock.Lock ();
        DWORD       dwFindType = (DWORD)pFindDlg->m_fieldList.GetItemData (nCurSel);
        pFindDlg->m_singleLock.Unlock ();
        CString     szFindText;


        statusText.LoadString (IDS_SEARCHING);
        if ( pFindDlg->m_statusBar.m_hWnd )
        {
            pFindDlg->m_statusBar.SetWindowText (statusText);
            pFindDlg->GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowText (szFindText);
        }

        // Bug 218084 - in BiDi, string may be prepended with Left-to-Right 
        // mark (0x200e).  See if this character is present.  If so, omit it 
        // from the search.  Check for multiple occurances.
        while ( chLEFT_TO_RIGHT == szFindText.GetAt (0) )
        {
            szFindText = ((PCWSTR) szFindText) + 1;
        }

        switch (dwFindType)
        {
        case CERT_FIND_SUBJECT_STR_W:
        case CERT_FIND_ISSUER_STR_W:
            pFindDlg->SearchForNames (szFindText, dwFindType);
            break;

        case CERT_FIND_MD5_HASH:
            pFindDlg->SearchForText (szFindText, CERT_MD5_HASH_PROP_ID);
            break;

        case CERT_FIND_SHA1_HASH:
            pFindDlg->SearchForText (szFindText, CERT_SHA1_HASH_PROP_ID);
            break;

        case CERT_FIND_SERIAL_NUMBER:
            pFindDlg->SearchForText (szFindText, CERT_FIND_SERIAL_NUMBER);
            break;

        default:
            {
                CThemeContextActivator activator;
                AfxMessageBox (_T("Search type not implemented"), MB_OK);
            }
            break;
        }


        int     nCnt = pFindDlg->m_resultsList.GetItemCount ();
        ASSERT (-1 != nCnt);
        switch (nCnt)
        {
        case -1:
        case 0:
            VERIFY (statusText.LoadString (IDS_NO_CERTS_FOUND));
            break;

        case 1:
            VERIFY (statusText.LoadString (IDS_1_CERT_FOUND));
            break;

            break;

        default:
            statusText.FormatMessage (IDS_X_CERTS_FOUND, nCnt);
            break;
        }
        pFindDlg->m_statusBar.SetWindowText (statusText);
    }

    pFindDlg->RestoreAfterSearchSettings ();

    _TRACE (-1, L"Leaving FindThreadFunc\n");

    pFindDlg->m_hSearchThread = 0;
    _endthread ();
}

void CFindDialog::DoSearch()
{
    _TRACE (1, L"Entering CFindDialog::DoSearch\n");
    CWaitCursor waitCursor;

    // Because FindThreadFunc calls c-runtime functions, use _beginthread instead of CreateThread.
    // BoundsChecker warns that using CreateThread here results in small memory leaks
 
    VERIFY (ResetEvent (m_hCancelSearchEvent));
    m_hSearchThread = (HANDLE) _beginthread (FindThreadFunc, 0, reinterpret_cast <void*> (this));
    ASSERT (m_hSearchThread);
    _TRACE (-1, L"Leaving CFindDialog::DoSearch\n");
}


void CFindDialog::SearchForTextOnStore (DWORD dwPropId, CString &szFindText,
        CCertStore& rCertStore)
{
    _TRACE (1, L"Entering CFindDialog::SearchForTextOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
    // NOTE: szFindText is already in upper case
    CWaitCursor         cursor;
    PCCERT_CONTEXT      pCertContext = 0;
    CCertificate*       pCert = 0;
    CString             szCertText;
    int                 nPos = 0;


    // Remove all spaces from szFindText
    RemoveSpaces (szFindText);

    //  Iterate through the list of certificates in the system store,
    //  allocate new certificates with the CERT_CONTEXT returned,
    //  and store them in the certificate list if they meet search criteria
    while ( WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0) )
    {
        pCertContext = rCertStore.EnumCertificates (pCertContext);
        if ( !pCertContext )
            break;
        pCert =
            new CCertificate (pCertContext, &rCertStore);
        if ( pCert )
        {
            switch (dwPropId)
            {
            case CERT_MD5_HASH_PROP_ID:
                szCertText = pCert->GetMD5Hash ();
                break;

            case CERT_SHA1_HASH_PROP_ID:
                szCertText = pCert->GetSHAHash ();
                break;

            case CERT_FIND_SERIAL_NUMBER:
                szCertText = pCert->GetSerialNumber ();
                RemoveSpaces (szCertText);
                break;

            default:
                ASSERT (0);
                return;
            }

            szCertText.MakeUpper ();
            nPos = szCertText.Find (szFindText);
            if ( -1 != nPos )
            {
                pCert->AddRef ();

                // Add cert to list control
                InsertItemInList (pCert);
            }
            pCert->Release ();
        }
    }
    rCertStore.Close ();
    _TRACE (-1, L"Leaving CFindDialog::SearchForTextOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
}


void CFindDialog::SearchForNameOnStore (DWORD dwFindFlags, DWORD dwFindType,
        void * pvPara, CCertStore& rCertStore)
{
    _TRACE (1, L"Entering CFindDialog::SearchForNameOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
    PCCERT_CONTEXT      pPrevCertContext = 0;
    PCCERT_CONTEXT      pCertContext = 0;
    CCertificate*       pCert = 0;
    DWORD               dwErr = 0;


    while ( WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0) )
    {
        pCertContext = rCertStore.FindCertificate (
                    dwFindFlags,
                    dwFindType,
                    pvPara,
                    pPrevCertContext);
        if ( !pCertContext )
        {
            dwErr = GetLastError ();
            switch (dwErr)
            {
            case ERROR_SUCCESS:
                break;

            case CRYPT_E_NOT_FOUND: // We're done.  No more certificates.
            case ERROR_FILE_NOT_FOUND:
                break;

            default:
                if ( !rCertStore.GetStoreHandle () )
                {
                    CString text;
                    CString caption;

                    text.FormatMessage 
                            (IDS_CANNOT_OPEN_CERT_STORE_TO_FIND_CERT_BY_PURPOSE,
                            rCertStore.GetLocalizedName ());
                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                    MessageBox (text, caption, MB_ICONWARNING | MB_OK);
                    break;
                }
                else
                    DisplaySystemError ();
                break;
            }
            break;
        }
        pCert = new CCertificate (pCertContext, &rCertStore);
        if ( pCert )
            InsertItemInList (pCert); // Add cert to list control
        else
            break;

        pPrevCertContext = pCertContext;
    }
    rCertStore.Close ();
    _TRACE (-1, L"Leaving CFindDialog::SearchForNameOnStore - %s\n",
            (LPCWSTR) rCertStore.GetStoreName ());
}


void CFindDialog::InsertItemInList(CCertificate * pCert)
{
    _TRACE (1, L"Entering CFindDialog::InsertItemInList\n");
    LV_ITEM lvItem;
    int     iItem = m_resultsList.GetItemCount ();
    int iResult = 0;

    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iItem = iItem;
    lvItem.iSubItem = COL_ISSUED_TO;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetSubjectName ();
    lvItem.iImage = 0;
    lvItem.lParam = (LPARAM) pCert;
    iItem = m_resultsList.InsertItem (&lvItem);
    ASSERT (-1 != iItem);
    if ( -1 == iItem )
        return;

    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = COL_ISSUED_BY;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetIssuerName ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = COL_EXPIRATION_DATE;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetValidNotAfter ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = COL_PURPOSES;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetEnhancedKeyUsage ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = COL_FRIENDLY_NAME;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetFriendlyName ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    _TRACE (-1, L"Leaving CFindDialog::InsertItemInList\n");

    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItem;
    lvItem.iSubItem = COL_SOURCE_STORE;
    if ( pCert->GetCertStore () )
        lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetCertStore ()->GetLocalizedName ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    _TRACE (-1, L"Leaving CFindDialog::InsertItemInList\n");

}


void CFindDialog::RefreshItemInList (CCertificate * pCert, int nItem)
{
    _TRACE (1, L"Entering CFindDialog::RefreshItemInList\n");
    LV_ITEM lvItem;
    int iResult = 0;

    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
    lvItem.iItem = nItem;
    lvItem.iSubItem = COL_ISSUED_TO;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetSubjectName ();
    lvItem.iImage = 0;
    lvItem.lParam = (LPARAM) pCert;
    iResult = m_resultsList.SetItem (&lvItem); 
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItem;
    lvItem.iSubItem = COL_ISSUED_BY;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetIssuerName ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItem;
    lvItem.iSubItem = COL_EXPIRATION_DATE;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetValidNotAfter ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItem;
    lvItem.iSubItem = COL_PURPOSES;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetEnhancedKeyUsage ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);
    
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&lvItem, sizeof (lvItem));
    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = nItem;
    lvItem.iSubItem = COL_FRIENDLY_NAME;
    lvItem.pszText = (LPWSTR)(LPCWSTR) pCert->GetFriendlyName ();
    iResult = m_resultsList.SetItem (&lvItem);
    ASSERT (-1 != iResult);

    VERIFY (m_resultsList.Update (nItem));
    _TRACE (-1, L"Leaving CFindDialog::RefreshItemInList\n");
}


void CFindDialog::DeleteAllResultItems()
{
    _TRACE (1, L"Entering CFindDialog::DeleteAllResultItems\n");
    int nCnt = m_resultsList.GetItemCount ();
    ASSERT (-1 != nCnt);
    CCertificate*   pCert = 0;

    for (int nIndex = 0; nIndex < nCnt; nIndex++)
    {
        pCert = (CCertificate*) m_resultsList.GetItemData (nIndex);
        ASSERT (pCert);
        if ( pCert )
            pCert->Release ();
    }

    VERIFY (m_resultsList.DeleteAllItems ());
    _TRACE (-1, L"Leaving CFindDialog::DeleteAllResultItems\n");
}

void CFindDialog::OnRclickResultList(NMHDR* pNMHDR, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnRclickResultList\n");

    m_hWndWhatsThis = 0;
    CMenu bar;
    if ( bar.LoadMenu(IDR_FIND_DLG_CONTEXT_MENU) )
    {
        CMenu& popup = *bar.GetSubMenu (0);
        ASSERT(popup.m_hMenu);
        CPoint  point;
        NM_LISTVIEW* pnmv = (NM_LISTVIEW FAR *) pNMHDR;
        bool    bIsMyStore = false;
        if ( -1 == pnmv->iItem )
            return;     // mouse not over valid item

        DWORD_PTR dwItemData = m_resultsList.GetItemData (pnmv->iItem);
        ASSERT (dwItemData);
        if ( dwItemData )
        {
            CCertificate* pCert = (CCertificate*) dwItemData;
            bIsMyStore = (pCert->GetStoreType () == MY_STORE);
        }

        int nSelCnt = m_resultsList.GetSelectedCount ();
        switch (nSelCnt)
        {
        case 0:
            popup.EnableMenuItem (ID_VIEW, MF_GRAYED);
            popup.EnableMenuItem (IDM_PROPERTIES, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_EXPORT, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_DELETE, MF_GRAYED);
            break;

        case 1:
            popup.EnableMenuItem (ID_VIEW, MF_ENABLED);
            popup.EnableMenuItem (IDM_PROPERTIES, MF_ENABLED);
            if ( bIsMyStore && CERT_SYSTEM_STORE_SERVICES != m_pCompData->GetLocation () )
            {
                popup.EnableMenuItem (ID_ENROLL_NEW_KEY, MF_ENABLED);
                popup.EnableMenuItem (ID_ENROLL_SAME_KEY, MF_ENABLED);
                popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_ENABLED);
                popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_ENABLED);
            }
            else
            {
                popup.EnableMenuItem (ID_ENROLL_NEW_KEY, MF_GRAYED);
                popup.EnableMenuItem (ID_ENROLL_SAME_KEY, MF_GRAYED);
                popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_GRAYED);
                popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_GRAYED);
            }
            popup.EnableMenuItem (ID_FILE_EXPORT, MF_ENABLED);
            popup.EnableMenuItem (ID_FILE_DELETE, MF_ENABLED);
            break;

        default:
            popup.EnableMenuItem (ID_VIEW, MF_GRAYED);
            popup.EnableMenuItem (IDM_PROPERTIES, MF_GRAYED);
            popup.EnableMenuItem (ID_ENROLL_NEW_KEY, MF_GRAYED);
            popup.EnableMenuItem (ID_ENROLL_SAME_KEY, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_RENEW_NEW_KEY, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_RENEW_SAME_KEY, MF_GRAYED);
            popup.EnableMenuItem (ID_FILE_EXPORT, MF_ENABLED);
            popup.EnableMenuItem (ID_FILE_DELETE, MF_ENABLED);
            break;
        }
        GetCursorPos (&point);
        m_hWndWhatsThis = GetDlgItem (IDC_RESULT_LIST)->m_hWnd;
        popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
            point.x, point.y,
            this); // route commands through main window
    }
    
    *pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnRclickResultList\n");
}


void CFindDialog::ChangeViewStyle (DWORD dwNewStyle)
{
    _TRACE (1, L"Entering CFindDialog::ChangeViewStyle\n");
    if ( m_resultsList.m_hWnd )
    {
        DWORD dwStyle = ::GetWindowLong (m_resultsList.m_hWnd, GWL_STYLE);
        ::SetWindowLong (m_resultsList.m_hWnd, GWL_STYLE,
                (dwStyle & ~LVS_TYPEMASK) | dwNewStyle);        
    }
    _TRACE (-1, L"Leaving CFindDialog::ChangeViewStyle\n");
}


void CFindDialog::OnDelete()
{
    _TRACE (1, L"Entering CFindDialog::OnDelete\n");
    if ( m_resultsList.m_hWnd )
    {
        int             nCnt = m_resultsList.GetItemCount ();
        ASSERT (nCnt >= 1);
        CCertificate*   pCert = 0;
        CString         text;
        CString         caption;
        int             nSelCnt = m_resultsList.GetSelectedCount ();
        ASSERT (nSelCnt >= 1);

        VERIFY (text.LoadString (1 == nSelCnt ? IDS_CONFIRM_DELETE : IDS_CONFIRM_DELETE_MULTIPLE));
        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));

        CThemeContextActivator activator;
        if ( MessageBox (text, caption, MB_ICONWARNING | MB_YESNO) == IDYES )
        {
            UINT    flag = 0;
            while (--nCnt >= 0)
            {
                flag = ListView_GetItemState (m_resultsList.m_hWnd, nCnt, LVIS_SELECTED);
                if ( flag & LVNI_SELECTED )
                {
                    pCert = (CCertificate*) m_resultsList.GetItemData (nCnt);
                    ASSERT (pCert);
                    if ( pCert )
                    {
                        if ( pCert->DeleteFromStore (true) )
                        {
                            m_bConsoleRefreshRequired = true;
                            if ( m_resultsList.DeleteItem (nCnt) )
                                pCert->Release ();
                        }
                        else
                        {
                            DWORD dwErr = GetLastError ();
                            ASSERT (E_ACCESSDENIED == dwErr);
                            if ( E_ACCESSDENIED == dwErr )
                            {
                                DisplaySystemError ();
                            }
                        }
                    }
                }
            }
        }
        
        EnableMenuItems ();
    }
    _TRACE (-1, L"Leaving CFindDialog::OnDelete\n");
}

DWORD CFindDialog::DisplaySystemError()
{
    LPVOID lpMsgBuf;
    DWORD   dwErr = GetLastError ();

    // security review 2/22/2002 BryanWal ok - message from system  
    ::FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            dwErr,
            MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPWSTR) &lpMsgBuf,    0,    NULL );
        
    // Display the string.
    CString caption;
    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
    CThemeContextActivator activator;
    MessageBox ((LPWSTR) lpMsgBuf, (LPCWSTR) caption, MB_OK);
    // Free the buffer.
    LocalFree (lpMsgBuf);

    return dwErr;
}


CCertificate* CFindDialog::GetSelectedCertificate (int * pnSelItem)
{
    _TRACE (1, L"Entering CFindDialog::GetSelectedCertificate\n");
    CCertificate*   pCert = 0;

    if ( m_resultsList.m_hWnd )
    {
        int nCnt = m_resultsList.GetItemCount ();
        int nSelCnt = m_resultsList.GetSelectedCount ();
        ASSERT (1 == nSelCnt);


        if ( 1 == nSelCnt )
        {
            UINT    flag = 0;
            while (--nCnt >= 0)
            {
                flag = ListView_GetItemState (m_resultsList.m_hWnd, nCnt, LVIS_SELECTED);
                if ( flag & LVNI_SELECTED )
                {
                    pCert = (CCertificate*) m_resultsList.GetItemData (nCnt);
                    ASSERT (pCert);
                    if ( pCert && pnSelItem )
                        *pnSelItem = nCnt;
                    break;
                }
            }
        }
    }

    _TRACE (-1, L"Leaving CFindDialog::GetSelectedCertificate\n");
    return pCert;
}

void CFindDialog::OnProperties()
{
    _TRACE (1, L"Entering CFindDialog::OnProperties\n");
    int             nSelItem = 0;
    CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
    ASSERT (pCert);
    if ( pCert )
    {
        HCERTSTORE*     pPropPageStores = new HCERTSTORE[1];
        if ( pPropPageStores && pCert->GetCertStore () )
        {
            pPropPageStores[0] = pCert->GetCertStore ()->GetStoreHandle ();


            CRYPTUI_VIEWCERTIFICATEPROPERTIES_STRUCT    sps;


            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (&sps, sizeof (sps));
            sps.dwSize = sizeof (sps);
            sps.hwndParent = m_hWnd;
            sps.dwFlags = 0;
            sps.pCertContext = pCert->GetNewCertContext ();
            sps.cStores = 1;
            sps.rghStores = pPropPageStores;


            BOOL fPropertiesChanged = FALSE;
            CThemeContextActivator activator;
            BOOL bResult = ::CryptUIDlgViewCertificateProperties (&sps, &fPropertiesChanged);
            if ( bResult )
            {
                if ( fPropertiesChanged )
                {
                    m_bConsoleRefreshRequired = true;
                    if ( pCert->GetCertStore () )
                        pCert->GetCertStore ()->SetDirty ();
                    pCert->Refresh ();
                    RefreshItemInList (pCert, nSelItem);
                }
            }

            if ( pCert->GetCertStore () )
                pCert->GetCertStore ()->Close ();
            delete [] pPropPageStores;
        }
        else //bug 427959, Yanggao, 7/16/2001
        {
            if( pPropPageStores )
                delete [] pPropPageStores;
        }
    }
    _TRACE (-1, L"Leaving CFindDialog::OnProperties\n");
}

void CFindDialog::OnView()
{
    _TRACE (1, L"Entering CFindDialog::OnView\n");
    int             nSelItem = 0;
    CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
    ASSERT (pCert);
    if ( pCert )
    {
        LaunchCommonCertDialog (pCert, nSelItem);
    }
    _TRACE (-1, L"Leaving CFindDialog::OnView\n");
}

void CFindDialog::OnFileDelete()
{
    _TRACE (1, L"Entering CFindDialog::OnFileDelete\n");
    OnDelete ();
    _TRACE (-1, L"Leaving CFindDialog::OnFileDelete\n");
}

void CFindDialog::OnEnrollNewKey()
{
    _TRACE (1, L"Entering CFindDialog::OnEnrollNewKey\n");
    OnEnroll (true);
    _TRACE (-1, L"Leaving CFindDialog::OnEnrollNewKey\n");
}

void CFindDialog::OnEnrollSameKey()
{
    _TRACE (1, L"Entering CFindDialog::OnEnrollSameKey\n");
    OnEnroll (false);
    _TRACE (-1, L"Leaving CFindDialog::OnEnrollSameKey\n");
}

void CFindDialog::OnEnroll(bool bNewKey)
{
    _TRACE (1, L"Entering CFindDialog::OnEnroll\n");
    int             nSelItem = 0;
    CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
    ASSERT (pCert);
    if ( pCert )
    {
        CRYPTUI_WIZ_CERT_REQUEST_PVK_CERT   pvkCert;
        CRYPTUI_WIZ_CERT_REQUEST_PVK_NEW    pvkNew;
        CRYPTUI_WIZ_CERT_REQUEST_INFO       cri;
        CRYPT_KEY_PROV_INFO                 ckpi;

        // security review 2/22/2002 BryanWal ok
        ::ZeroMemory (&cri, sizeof (cri));
        cri.dwSize = sizeof (cri);
        cri.dwPurpose = CRYPTUI_WIZ_CERT_ENROLL;

        // User wants to manage user account
        //  pass in NULL to machine name and to account name
        // User wants to manage local machine account
        //  pass in NULL for account name and result of ::GetComputerName ()
        //  to machine name
        // User want to manage remote machine
        //  pass in NULL for account name and machine name for machineName
        // User wants to manage remote account on remote machine
        //  pass in account name for accountName and machine name for machineName
        // TODO: Ensure that this is NULL if the local machine
        switch (m_pCompData->GetLocation ())
        {
        case CERT_SYSTEM_STORE_CURRENT_SERVICE:
        case CERT_SYSTEM_STORE_SERVICES:
            cri.pwszMachineName = (LPCWSTR) m_szMachineName;
            cri.pwszAccountName = (LPCWSTR) m_pCompData->GetManagedService ();
            break;

        case CERT_SYSTEM_STORE_CURRENT_USER:
            cri.pwszMachineName = NULL;
            cri.pwszAccountName = NULL;
            break;

        case CERT_SYSTEM_STORE_LOCAL_MACHINE:
            cri.pwszMachineName = (LPCWSTR) m_szMachineName;
            cri.pwszAccountName = NULL;
            break;

        default:
            ASSERT (0);
            return;
            break;
        }

        if ( bNewKey )
        {
            cri.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_NEW;
            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (&pvkNew, sizeof (pvkNew));
            pvkNew.dwSize = sizeof (pvkNew);
            cri.pPvkNew = &pvkNew;
            if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_pCompData->GetLocation () )
            {
                // security review 2/22/2002 BryanWal ok
                ::ZeroMemory (&ckpi, sizeof (ckpi));
                ckpi.dwFlags = CRYPT_MACHINE_KEYSET;
                pvkNew.pKeyProvInfo = &ckpi;
            }
        }
        else
        {
            if ( IsLocalComputername (m_pCompData->m_szManagedComputer) )
            {
                DWORD   dwFlags = 0;

                if ( CERT_SYSTEM_STORE_LOCAL_MACHINE == m_pCompData->m_dwLocationPersist )
                    dwFlags = CRYPT_FIND_MACHINE_KEYSET_FLAG;
                if ( !::CryptFindCertificateKeyProvInfo (
                        pCert->GetCertContext (), dwFlags, 0) )
                {
                    DWORD   dwErr = GetLastError ();
                    _TRACE (0, L"CryptFindCertificateKeyProvInfo () failed: 0x%x\n",
                            dwErr);
                    CString text;
                    CString caption;
                    CThemeContextActivator activator;

                    text.FormatMessage (IDS_NO_PRIVATE_KEY, 
                            GetSystemMessage (dwErr));
                    VERIFY (caption.LoadString (IDS_REQUEST_CERT_SAME_KEY));
                    MessageBox (text, caption, MB_OK);
                    return;
                }
            }
            cri.dwPvkChoice = CRYPTUI_WIZ_CERT_REQUEST_PVK_CHOICE_CERT;
            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (&pvkCert, sizeof (pvkCert));
            pvkCert.dwSize = sizeof (pvkCert);
            pvkCert.pCertContext = pCert->GetCertContext ();
            cri.pPvkCert = &pvkCert;
        }
        CString dnName;
        dnName.FormatMessage (L"CN=%1", m_szLoggedInUser);
        cri.pwszCertDNName = (LPWSTR) (LPCWSTR) dnName;

            
        DWORD           status = 0;
        PCCERT_CONTEXT  pNewCertContext = 0;
        BOOL            bResult = FALSE;
        CThemeContextActivator activator;
        while (1)
        {
            bResult = ::CryptUIWizCertRequest (
                bNewKey ? CRYPTUI_WIZ_CERT_REQUEST_REQUIRE_NEW_KEY : 0, 
                m_hWnd, 
                NULL,
                &cri, &pNewCertContext, &status);
            if ( !bResult && HRESULT_FROM_WIN32 (NTE_TOKEN_KEYSET_STORAGE_FULL) == GetLastError () )
            {
                // NTRAID# 299089 Enrollment Wizard: Should return some 
                // meaningful message when users fail to enroll/renew on a 
                // smart card
                if ( !bNewKey )
                    break;

                CString text;
                CString caption;

                VERIFY (text.LoadString (IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY));
                VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                if ( IDYES == MessageBox (text, caption, MB_YESNO) )
                {
                    bNewKey = false;
                }
                else
                    break;
            }
            else
                break;
        }

        if ( pNewCertContext )
            CertFreeCertificateContext (pNewCertContext);
    }

    ResetMenu ();
    _TRACE (-1, L"Leaving CFindDialog::OnEnroll\n");
}

void CFindDialog::OnFileExport()
{
    _TRACE (1, L"Entering CFindDialog::OnFileExport\n");
    UINT    nSelCnt = m_resultsList.GetSelectedCount ();
    if ( 1 == nSelCnt )
    {
        int             nSelItem = 0;
        CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
        ASSERT (pCert);
        if ( pCert )
        {
            CRYPTUI_WIZ_EXPORT_INFO cwi;

            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (&cwi, sizeof (cwi));
            cwi.dwSize = sizeof (cwi);
            cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_CONTEXT;
            cwi.pCertContext = pCert->GetCertContext ();

            CThemeContextActivator activator;
            ::CryptUIWizExport (
                    0,
                    m_hWnd,
                    0,
                    &cwi,
                    NULL);
        }
    }
    else if ( nSelCnt > 1 )
    {
        HCERTSTORE  hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
                0, NULL, 0, NULL);
        ASSERT (hCertStore);
        if ( hCertStore )
        {
            CCertificate*   pCert = 0;
            int             nCnt = m_resultsList.GetItemCount ();
            UINT            flag = 0;
            BOOL            bResult = FALSE;
            while (--nCnt >= 0)
            {
                flag = ListView_GetItemState (m_resultsList.m_hWnd, nCnt, LVIS_SELECTED);
                if ( flag & LVNI_SELECTED )
                {
                    pCert = (CCertificate*) m_resultsList.GetItemData (nCnt);
                    ASSERT (pCert);
                    if ( pCert )
                    {
                        bResult = ::CertAddCertificateContextToStore (
                                hCertStore,
                                ::CertDuplicateCertificateContext (pCert->GetCertContext ()),
                                CERT_STORE_ADD_NEW, 0);
                        ASSERT (bResult);
                        if ( !bResult )
                            break;
                    }
                }
            }

            // Call Export Wizard
            CRYPTUI_WIZ_EXPORT_INFO cwi;
            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (&cwi, sizeof (cwi));
            cwi.dwSize = sizeof (cwi);
            cwi.dwSubjectChoice = CRYPTUI_WIZ_EXPORT_CERT_STORE_CERTIFICATES_ONLY;
            cwi.hCertStore = hCertStore;

            CThemeContextActivator activator;
            bResult = ::CryptUIWizExport (
                    0,
                    m_hWnd,
                    0,
                    &cwi,
                    NULL);

            VERIFY (::CertCloseStore (hCertStore, CERT_CLOSE_STORE_CHECK_FLAG));
        }
        else
        {
            _TRACE (0, L"CertOpenStore (CERT_STORE_PROVIDER_MEMORY) failed: 0x%x\n", 
                    GetLastError ());       
        }
    }
    _TRACE (-1, L"Leaving CFindDialog::OnFileExport\n");
}


void CFindDialog::OnFileRenewNewKey()
{
    _TRACE (1, L"Entering CFindDialog::OnFileRenewNewKey\n");
    OnFileRenew (true);
    _TRACE (-1, L"Leaving CFindDialog::OnFileRenewNewKey\n");
}

void CFindDialog::OnFileRenewSameKey()
{
    _TRACE (1, L"Entering CFindDialog::OnFileRenewSameKey\n");
    OnFileRenew (false);
    _TRACE (-1, L"Leaving CFindDialog::OnFileRenewSameKey\n");
}

void CFindDialog::OnFileRenew(bool bNewKey)
{
    _TRACE (1, L"Entering CFindDialog::OnFileRenew\n");
    int             nSelItem = 0;
    CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
    ASSERT (pCert);
    if ( pCert )
    {
        RenewCertificate (
                pCert, 
                bNewKey, 
                m_szMachineName, 
                m_pCompData->GetLocation (),
                m_pCompData->GetManagedComputer (), 
                m_pCompData->GetManagedService (), 
                m_hWnd, 
                0,
                0);
    }

    ResetMenu ();

    _TRACE (-1, L"Leaving CFindDialog::OnFileRenew\n");
}

void CFindDialog::OnEditInvertselection()
{
    _TRACE (1, L"Entering CFindDialog::OnEditInvertselection\n");
    if ( m_resultsList.m_hWnd )
    {
        int iItem = -1;
        while ((iItem = ListView_GetNextItem (m_resultsList.m_hWnd, iItem, 0)) != -1)
        {
            UINT flag;

            // flip the selection bit on each item
            flag = ListView_GetItemState (m_resultsList.m_hWnd, iItem, LVIS_SELECTED);
            flag ^= LVNI_SELECTED;
            ListView_SetItemState (m_resultsList.m_hWnd, iItem, flag, LVIS_SELECTED);
        }
    }
    _TRACE (-1, L"Leaving CFindDialog::OnEditInvertselection\n");
}

void CFindDialog::OnEditSelectall()
{
    _TRACE (1, L"Entering CFindDialog::OnEditSelectall\n");
    if ( m_resultsList.m_hWnd )
        ListView_SetItemState (m_resultsList.m_hWnd, -1, LVIS_SELECTED, LVIS_SELECTED);
    _TRACE (-1, L"Leaving CFindDialog::OnEditSelectall\n");
}


void CFindDialog::OnFileProperties()
{
    _TRACE (1, L"Entering CFindDialog::OnFileProperties\n");
    OnProperties ();
    _TRACE (-1, L"Leaving CFindDialog::OnFileProperties\n");
}

void CFindDialog::OnHelpHelptopics()
{
    _TRACE (1, L"Entering CFindDialog::OnHelpHelptopics\n");
    CComPtr<IDisplayHelp>   spDisplayHelp;

    HRESULT hr = m_pCompData->m_pConsole->QueryInterface (
            IID_PPV_ARG (IDisplayHelp, &spDisplayHelp));
    ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) )
    {
        CString helpTopic;

        UINT nLen = ::GetSystemWindowsDirectory (helpTopic.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
        helpTopic.ReleaseBuffer();
        if (0 == nLen)
        {
            ASSERT(FALSE);
            return;
        }

        helpTopic += L"\\help\\";
        helpTopic += CM_LINKED_HELP_FILE; //CM_HELP_FILE; //CM_LINKED_HELP_FILE;
        helpTopic += L"::/";
        helpTopic += CM_HELP_TOPIC;
        hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) helpTopic));
        ASSERT (SUCCEEDED (hr));
    }
    if ( !SUCCEEDED (hr) )
    {
        CString caption;
        CString text;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_FIND_CERT));
        text.FormatMessage (IDS_CERTMGR_CHM_NOT_FOUND, CM_HELP_FILE);
        MessageBox (text, caption, MB_OK);
    }
    _TRACE (-1, L"Leaving CFindDialog::OnHelpHelptopics\n");
}


void CFindDialog::OnViewDetails()
{
    _TRACE (1, L"Entering CFindDialog::OnViewDetails\n");
    ChangeViewStyle (LVS_REPORT);
    _TRACE (-1, L"Leaving CFindDialog::OnViewDetails\n");
}

void CFindDialog::OnViewLargeicons()
{
    _TRACE (1, L"Entering CFindDialog::OnViewLargeicons\n");
    ChangeViewStyle (LVS_ICON);
    _TRACE (-1, L"Leaving CFindDialog::OnViewLargeicons\n");
}


void CFindDialog::OnViewList()
{
    _TRACE (1, L"Entering CFindDialog::OnViewList\n");
    ChangeViewStyle (LVS_LIST);
    _TRACE (-1, L"Leaving CFindDialog::OnViewList\n");
}

void CFindDialog::OnViewSmallicons()
{
    _TRACE (1, L"Entering CFindDialog::OnViewSmallicons\n");
    ChangeViewStyle (LVS_SMALLICON);
    _TRACE (-1, L"Leaving CFindDialog::OnViewSmallicons\n");
}


HRESULT CFindDialog::SearchForNames(const CString & szFindText, DWORD dwFindType)
{
    _TRACE (1, L"Entering CFindDialog::SearchForNames - %s\n", (LPCWSTR) szFindText);
    HRESULT             hr = S_OK;
    void*               pvFindPara = (void*) (LPCWSTR) szFindText;
    int                 nCurSel = m_storeList.GetCurSel ();
    CCertStore*         pStore = (CCertStore*) m_storeList.GetItemData (nCurSel);
    DWORD               dwFindFlags = 0;


    if ( pStore )
    {
        SearchForNameOnStore (dwFindFlags, dwFindType, pvFindPara,
                    *pStore);
    }
    else
    {
        // if pStore is 0, then search on all stores in store list
        int nCnt = m_storeList.GetCount ();
        ASSERT (CB_ERR != nCnt);
        for (int nIndex = 0; 
                nIndex < nCnt && WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0); 
                nIndex++)
        {
            pStore = (CCertStore*) m_storeList.GetItemData (nIndex);
            if ( pStore )
            {
                SearchForNameOnStore (dwFindFlags, dwFindType,
                        pvFindPara, *pStore);
            }
        }
    }

    _TRACE (-1, L"Leaving CFindDialog::SearchForNames - %s\n", (LPCWSTR) szFindText);
    return hr;
}


HRESULT CFindDialog::SearchForText (CString & szFindText, DWORD dwPropId)
{
    _TRACE (1, L"Entering CFindDialog::SearchForText - %s\n", (LPCWSTR) szFindText);
    HRESULT     hr = S_OK;
    int         nCurSel = m_storeList.GetCurSel ();
    CCertStore* pStore = (CCertStore*) m_storeList.GetItemData (nCurSel);


    szFindText.MakeUpper ();

    if ( pStore && pStore->GetStoreHandle () )
    {
        SearchForTextOnStore (dwPropId, szFindText, *pStore);
        pStore->Close ();
    }
    else
    {
        // if hCertStore is 0, then search on all stores in store list
        int nCnt = m_storeList.GetCount ();
        ASSERT (CB_ERR != nCnt);
        for (int nIndex = 0; 
                nIndex < nCnt && WAIT_TIMEOUT == WaitForSingleObject (m_hCancelSearchEvent, 0); 
                nIndex++)
        {
            pStore = (CCertStore*) m_storeList.GetItemData (nIndex);
            if ( pStore )
            {
                SearchForTextOnStore (dwPropId,
                        szFindText, *pStore);
                pStore->Close ();
            }
        }
    }

    _TRACE (-1, L"Leaving CFindDialog::SearchForText - %s\n", (LPCWSTR) szFindText);
    return hr;
}

void CFindDialog::RemoveSpaces(CString & text)
{
    _TRACE (1, L"Entering CFindDialog::RemoveSpaces - %s\n", (LPCWSTR) text);
    text.TrimLeft ();
    text.TrimRight ();

    int     nLen = text.GetLength ();
    LPCWSTR pszText = text.GetBuffer (nLen);
    int     nResultLen = nLen+2;
    LPWSTR  pszResult = new WCHAR[nResultLen];
    if ( pszResult )
    {
        while (--nResultLen >= 0)
            pszResult[nResultLen] = 0;

        nResultLen = 0;
        for (int nText = 0; nText < nLen; nText++)
        {
            if ( _T(" ")[0] != pszText[nText] )
                pszResult[nResultLen++] = pszText[nText];
        }
        text.ReleaseBuffer ();
        text = pszResult;
        delete [] pszResult;
    }
    _TRACE (-1, L"Leaving CFindDialog::RemoveSpaces - %s\n", (LPCWSTR) text);
}

void CFindDialog::OnDblclkResultList(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnDblclkResultList\n");
    OnOpen ();

    *pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnDblclkResultList\n");
}


int CALLBACK CFindDialog::CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CCertificate*   pCert1 = (CCertificate*) lParam1;
    CCertificate*   pCert2 = (CCertificate*) lParam2;
    int             compVal = 0;

    ASSERT (pCert1 && pCert2);
    if ( pCert1 && pCert2 )
    {
        switch (lParamSort)
        {
        case COL_ISSUED_TO:
            compVal = LocaleStrCmp (pCert1->GetSubjectName (), pCert2->GetSubjectName ());
            break;

        case COL_ISSUED_BY:
            compVal = LocaleStrCmp (pCert1->GetIssuerName (), pCert2->GetIssuerName ());
            break;

        case COL_EXPIRATION_DATE:
            compVal = pCert1->CompareExpireDate (*pCert2);
            break;

        case COL_PURPOSES:
            compVal = LocaleStrCmp (pCert1->GetEnhancedKeyUsage (), pCert2->GetEnhancedKeyUsage ());
            break;

        case COL_FRIENDLY_NAME:
            compVal = LocaleStrCmp (pCert1->GetFriendlyName (), pCert2->GetFriendlyName ());
            break;

        case COL_SOURCE_STORE:
            if ( pCert1->GetCertStore () && pCert2->GetCertStore () )
                compVal = LocaleStrCmp (pCert1->GetCertStore ()->GetLocalizedName (), 
                        pCert2->GetCertStore ()->GetLocalizedName ());
            break;

        default:
            ASSERT (0);
            break;
        }
    }

    return compVal;
}

void CFindDialog::OnColumnclickResultList(NMHDR* pNMHDR, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnColumnclickResultList\n");
    CWaitCursor cursor;
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    BOOL bResult = m_resultsList.SortItems (CompareFunc, pNMListView->iSubItem);
    ASSERT (bResult);
    *pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnColumnclickResultList\n");
}

void CFindDialog::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CFindDialog::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_STORE_LIST,     IDH_FIND_STORE_LIST,
        IDC_CONTAINS_TEXT,  IDH_FIND_CONTAINS_TEXT,
        IDC_FIELD_LIST,     IDH_FIND_FIELD_LIST,
        IDC_FIND_NOW,       IDH_FIND_FIND_NOW,
        IDC_STOP,           IDH_FIND_STOP,
        IDC_NEW_SEARCH,     IDH_FIND_NEW_SEARCH,
        IDC_RESULT_LIST,    IDH_FIND_RESULT_LIST,
        0, 0
    };


    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_STORE_LIST:
    case IDC_CONTAINS_TEXT:
    case IDC_FIELD_LIST:
    case IDC_FIND_NOW:
    case IDC_STOP:
    case IDC_NEW_SEARCH:
    case IDC_RESULT_LIST:
        // Display context help for a control
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CFindDialog::DoContextHelp\n");
}

void CFindDialog::OnChangeContainsText()
{
    _TRACE (1, L"Entering CFindDialog::OnChangeContainsText\n");
    int nLen = GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowTextLength ();

    // If the text starts with the invisible Left-to-Right marker, don't count
    // it in the length
    UpdateData (TRUE);
    int nIndex = 0;
    while ( chLEFT_TO_RIGHT == m_szContains.GetAt (nIndex) )
    {
        nLen--;
        nIndex++;
    }
 
    m_findNowBtn.EnableWindow (nLen ? TRUE : FALSE);
    _TRACE (-1, L"Leaving CFindDialog::OnChangeContainsText\n");
}

void CFindDialog::RestoreAfterSearchSettings()
{
    _TRACE (1, L"Entering CFindDialog::RestoreAfterSearchSettings\n");
    if ( m_bAnimationRunning )
    {
        VERIFY (m_animate.Stop ());
        m_bAnimationRunning = false;
    }
    VERIFY (m_animate.Seek (0));

    // Reenable the controls
    m_stopBtn.EnableWindow (FALSE);
    m_findNowBtn.EnableWindow (TRUE);
    m_newSearchBtn.EnableWindow (TRUE);
    GetDlgItem (IDC_CONTAINS_TEXT)->EnableWindow (TRUE);
    m_resultsList.EnableWindow (TRUE);
    m_fieldList.EnableWindow (TRUE);
    m_storeList.EnableWindow (TRUE);
    
    m_resultsList.SetFocus ();
    EnableMenuItems ();

    // NTRAID# 281799 Cert UI: Cert Snapin:  Accessibility:  Focus indicator 
    // cannot be seen in certificate list in Find Certificates
    int nIndex = m_resultsList.GetTopIndex();
    m_resultsList.SetFocus ();
    m_resultsList.SetItemState (nIndex, LVIS_FOCUSED, LVIS_FOCUSED);

    _TRACE (-1, L"Leaving CFindDialog::RestoreAfterSearchSettings\n");
}

//
// Initialize the result list view
//
void CFindDialog::SetUpResultList()
{
    _TRACE (1, L"Entering CFindDialog::SetUpResultList\n");
    // Set up result list view
    COLORREF    cr = RGB (255, 0, 255);
    CThemeContextActivator activator;
    VERIFY (m_imageListNormal.Create (IDB_CERTIFICATE_LARGE, 32, 0, cr));
    VERIFY (m_imageListSmall.Create (IDB_CERTIFICATE_SMALL, 16, 0, cr));
    m_resultsList.SetImageList (CImageList::FromHandle (m_imageListSmall), LVSIL_SMALL);
    m_resultsList.SetImageList (CImageList::FromHandle (m_imageListNormal), LVSIL_NORMAL);

    int colWidths[NUM_COLS] = {100, 100, 100, 100, 100, 400};

    // Add "Issued To" column
    CString szText;
    VERIFY (szText.LoadString (IDS_ISSUED_TO));
    VERIFY (m_resultsList.InsertColumn (COL_ISSUED_TO, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_ISSUED_TO], COL_ISSUED_TO) != -1);

    // Add "Issued By" column
    VERIFY (szText.LoadString (IDS_ISSUED_BY));
    VERIFY (m_resultsList.InsertColumn (COL_ISSUED_BY, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_ISSUED_BY], COL_ISSUED_BY) != -1);

    // Add "Expiration Date" column
    VERIFY (szText.LoadString (IDS_COLUMN_EXPIRATION_DATE));
    VERIFY (m_resultsList.InsertColumn (COL_EXPIRATION_DATE, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_EXPIRATION_DATE], COL_EXPIRATION_DATE) != -1);

    // Add "Purposes" column
    VERIFY (szText.LoadString (IDS_COLUMN_PURPOSE));
    VERIFY (m_resultsList.InsertColumn (COL_PURPOSES, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_PURPOSES], COL_PURPOSES) != -1);

    // Add "Friendly Name" column
    VERIFY (szText.LoadString (IDS_COLUMN_FRIENDLY_NAME));
    VERIFY (m_resultsList.InsertColumn (COL_FRIENDLY_NAME, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_FRIENDLY_NAME], COL_FRIENDLY_NAME) != -1);

    // Add "Source Store" column
    VERIFY (szText.LoadString (IDS_COLUMN_SOURCE_STORE));
    VERIFY (m_resultsList.InsertColumn (COL_SOURCE_STORE, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_SOURCE_STORE], COL_SOURCE_STORE) != -1);

    // Set to full-row select
    DWORD   dwExstyle = m_resultsList.GetExtendedStyle ();
    m_resultsList.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);

    _TRACE (-1, L"Leaving CFindDialog::SetUpResultList\n");
}

//
// Hide the portion of the dialog containing the result list.  This part
// becomes visible when a search is performed.
//
void CFindDialog::HideResultList()
{
    _TRACE (1, L"Entering CFindDialog::HideResultList\n");
    // Size window to hide list view until search is performed
    CRect   rcList;
    m_resultsList.GetWindowRect (&rcList);
    ScreenToClient (&rcList);
    CRect   rcDlg;
    GetWindowRect (&rcDlg);
    ScreenToClient (&rcDlg);

    int cyCaption = ::GetSystemMetrics (SM_CYCAPTION);
    m_cyOriginal = (rcDlg.bottom - rcDlg.top) + cyCaption;
    m_cyMin = (rcList.top - rcDlg.top) + cyCaption - 16;
    m_cxMin = rcDlg.right - rcDlg.left;
    VERIFY (SetWindowPos (&wndTop, rcDlg.left, rcDlg.top,
            rcDlg.right - rcDlg.left,
            m_cyMin,
            SWP_NOMOVE | SWP_NOOWNERZORDER));

    //
    // Get information about the spatial relationship of the controls to the window.
    // We will need this later for expanding and resizing the dialog.
    // Get right margin to maintain distance of buttons to right side
    //
    CRect   rcCtrl;
    m_stopBtn.GetWindowRect (&rcCtrl);
    ScreenToClient (&rcCtrl);
    m_cxBtnMargin = rcDlg.right - rcCtrl.right;

    m_animate.GetWindowRect (&rcCtrl);
    ScreenToClient (&rcCtrl);
    m_cxAnimMargin = rcDlg.right - rcCtrl.right;

    m_storeList.GetWindowRect (&rcCtrl);
    ScreenToClient (&rcCtrl);
    m_cxStoreListMargin = rcDlg.right - rcCtrl.right;

    GetDlgItem (IDC_CONTAINS_TEXT)->GetWindowRect (&rcCtrl);
    ScreenToClient (&rcCtrl);
    m_cxContainMargin = rcDlg.right - rcCtrl.right;
    
    m_fieldList.GetWindowRect (&rcCtrl);
    ScreenToClient (&rcCtrl);
    m_cxFieldListMargin = rcDlg.right - rcCtrl.right;
    _TRACE (-1, L"Leaving CFindDialog::HideResultList\n");
}


void CFindDialog::OnItemchangedResultList(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
    _TRACE (1, L"Entering CFindDialog::OnItemchangedResultList\n");
    EnableMenuItems ();
    *pResult = 0;
    _TRACE (-1, L"Leaving CFindDialog::OnItemchangedResultList\n");
}

void CFindDialog::OnOpen()
{
    _TRACE (1, L"Entering CFindDialog::OnOpen\n");
    int             nSelItem = 0;
    CCertificate*   pCert = GetSelectedCertificate (&nSelItem);
    ASSERT (pCert);
    if ( pCert )
    {
        VERIFY (SUCCEEDED (LaunchCommonCertDialog (pCert, nSelItem)));
    }
    _TRACE (-1, L"Leaving CFindDialog::OnOpen\n");
}

HRESULT CFindDialog::LaunchCommonCertDialog (CCertificate* pCert, const int nItem)
{
    _TRACE (1, L"Entering CFindDialog::LaunchCommonCertDialog\n");
    ASSERT (pCert);
    if ( !pCert )
        return E_POINTER;

    HRESULT hr = S_OK;

    CTypedPtrList<CPtrList, CCertStore*>    storeList;

    //  Add the Root store first on a remote machine.
    if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
    {
        storeList.AddTail (new CCertStore (CERTMGR_LOG_STORE,
                CERT_STORE_PROV_SYSTEM,
                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                (LPCWSTR) m_pCompData->GetManagedComputer (),
                ROOT_SYSTEM_STORE_NAME,
                ROOT_SYSTEM_STORE_NAME,
                _T (""), ROOT_STORE,
                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                m_pCompData->m_pConsole));
    }
    CCertStore* pStore = pCert->GetCertStore ();
    if ( pStore )
    {
        pStore->AddRef ();
        storeList.AddTail (pStore);

        hr = m_pCompData->EnumerateLogicalStores (&storeList);
        if ( SUCCEEDED (hr) )
        {
            POSITION pos = 0;
            POSITION prevPos = 0;

            // Validate store handles
            for (pos = storeList.GetHeadPosition ();
                    pos;)
            {
                prevPos = pos;
                pStore = storeList.GetNext (pos);
                ASSERT (pStore);
                if ( pStore )
                {
                    // Do not open the userDS store
                    if ( USERDS_STORE == pStore->GetStoreType () )
                    {
                        storeList.RemoveAt (prevPos);
                        pStore->Release ();
                        pStore = 0;
                    }
                    else
                    {
                        if ( !pStore->GetStoreHandle () )
                        {
                            CString caption;
                            CString text;
                            CThemeContextActivator activator;

                            text.FormatMessage (IDS_CANT_OPEN_STORE_AND_FAIL, pStore->GetLocalizedName ());
                            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
                            hr = E_FAIL;
                            break;
                        }
                    }
                }
            }

            // Proceed only if all handles are valid 
            if ( SUCCEEDED (hr) )
            {
                CRYPTUI_VIEWCERTIFICATE_STRUCT  vcs;
                // security review 2/22/2002 BryanWal ok
                ::ZeroMemory (&vcs, sizeof (vcs));
                vcs.dwSize = sizeof (vcs);
                vcs.hwndParent = m_hWnd;
                
                //  Set these flags only on a remote machine.
                if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
                    vcs.dwFlags = CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
                else
                    vcs.dwFlags = 0;

                vcs.pCertContext = pCert->GetNewCertContext ();
                vcs.cStores = (DWORD)storeList.GetCount ();
                vcs.rghStores = new HCERTSTORE[vcs.cStores];
                if ( vcs.rghStores )
                {
                    DWORD           index = 0;

                    for (pos = storeList.GetHeadPosition ();
                            pos && index < vcs.cStores;
                            index++)
                    {
                        pStore = storeList.GetNext (pos);
                        ASSERT (pStore);
                        if ( pStore )
                        {
                            vcs.rghStores[index] = pStore->GetStoreHandle ();
                        }
                    }
                    BOOL fPropertiesChanged = FALSE;
                    CThemeContextActivator activator;
                    BOOL bResult = ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);
                    if ( bResult )
                    {
                        if ( fPropertiesChanged )
                        {
                            m_bConsoleRefreshRequired = true;
                            if ( pCert->GetCertStore () )
                                pCert->GetCertStore ()->SetDirty ();
                            pCert->Refresh ();
                            RefreshItemInList (pCert, nItem);
                        }
                    }
                    delete vcs.rghStores;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }

        // Release all the stores in the list.
        while (!storeList.IsEmpty () )
        {
            pStore = storeList.RemoveHead ();
            ASSERT (pStore);
            if ( pStore )
            {
                pStore->Close ();
                pStore->Release ();
            }
        }
    }

    _TRACE (-1, L"Leaving CFindDialog::LaunchCommonCertDialog\n");
    return hr;
}


void CFindDialog::ChangeToSizableFrame()
{
    _TRACE (1, L"Entering CFindDialog::ChangeToSizableFrame\n");
    LONG    lStyle = ::GetWindowLong (m_hWnd, GWL_STYLE);

    if ( lStyle )
    {
        lStyle &= ~DS_MODALFRAME;
        lStyle |= WS_THICKFRAME;
        if ( !::SetWindowLong (m_hWnd, GWL_STYLE, lStyle) )
        {
            _TRACE (0, L"SetWindowLong () failed: 0x%x\n", GetLastError ());
        }
    }
    else
    {
        _TRACE (0, L"GetWindowLong () failed: 0x%x\n", GetLastError ());
    }
    _TRACE (-1, L"Leaving CFindDialog::ChangeToSizableFrame\n");
}


void CFindDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint scrPoint) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CFindDialog::OnContextMenu\n");
    CMenu   bar;
    CPoint  clPoint;
    clPoint.x = scrPoint.x;
    clPoint.y = scrPoint.y;
    ScreenToClient (&clPoint);


    // Get the handle of the window under the point.
    CWnd* pChild = ChildWindowFromPoint (
            clPoint,  // in client coordinates
            CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
    if ( pChild && pChild->m_hWnd != GetDlgItem (IDC_RESULT_LIST)->m_hWnd )
    {
        m_hWndWhatsThis = 0;
        
        if ( GetDlgItem (IDC_STORE_LIST)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_FIND_NOW)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_STOP)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_NEW_SEARCH)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_RESULT_LIST)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_CONTAINS_TEXT)->m_hWnd == pChild->m_hWnd ||
                GetDlgItem (IDC_FIELD_LIST)->m_hWnd == pChild->m_hWnd )
        {
            m_hWndWhatsThis = pChild->m_hWnd;
        }

        
        if ( m_hWndWhatsThis )
        {
            if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
            {
                CMenu& popup = *bar.GetSubMenu (0);
                ASSERT(popup.m_hMenu);

                if ( !popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
                        scrPoint.x,    // in screen coordinates
                        scrPoint.y,    // in screen coordinates
                        this) ) // route commands through main window
                {
                    m_hWndWhatsThis = 0;
                }
            }
            else
                m_hWndWhatsThis = 0;
        }
    }

    _TRACE (-1, L"Leaving CFindDialog::OnContextMenu\n");
}

bool CFindDialog::ConsoleRefreshRequired() const
{
    return m_bConsoleRefreshRequired;
}



void CFindDialog::ResetMenu()
{
    // Set up the menu
    if ( !::GetMenu (m_hWnd) )
    {
        HMENU   hMenu = ::LoadMenu (AfxGetInstanceHandle (),
                    MAKEINTRESOURCE (IDR_FIND_DLG_MENU));
        ASSERT (hMenu);
        if ( hMenu )
        {
            if (::SetMenu (m_hWnd, hMenu) )
                EnableMenuItems ();
        }
    }
}


void CFindDialog::OnCancel() 
{
    if ( m_hSearchThread && WaitForSingleObject (m_hSearchThread, 0) != WAIT_OBJECT_0 )
    {
        CString caption;
        CString text;

        VERIFY (text.LoadString (IDS_FIND_CLICK_STOP_BEFORE_CLOSING));
        VERIFY (caption.LoadString (IDS_FIND_CERT));
        CThemeContextActivator activator;
        MessageBox (text, caption, MB_OK);

        return;
    }

    CHelpDialog::OnCancel();
}

void CFindDialog::OnSelchangeFieldList() 
{
    // If searching on MD5 or SHA1 hash, always search archived certs
    // Otherwise, only search archived certs if user has chosen to view
    // archived certs in the main options dialog
    int nFindFieldSel = m_fieldList.GetCurSel ();
    if ( nFindFieldSel >= 0 )
    {
        DWORD_PTR   dwFindType = m_fieldList.GetItemData (nFindFieldSel);
        switch (dwFindType)
        {
        case CERT_FIND_MD5_HASH:
        case CERT_FIND_SHA1_HASH:
            // If not already opened to view archived certs, do it.
            if ( !m_bViewArchivedCerts || !m_bStoreIsOpenedToViewArchiveCerts )
            {
                m_bViewArchivedCerts = true;
                m_bStoreIsOpenedToViewArchiveCerts = true;

                CloseAndReopenStores ();
            }
            break;

        case CERT_FIND_SUBJECT_STR_W:
        case CERT_FIND_ISSUER_STR_W:
        case CERT_FIND_SERIAL_NUMBER:
            // If ShowArchivedCerts () is true, then the stores are always
            // opened to view archived certs, so there is no need to change.
            // Therefore we only need to test for change if the method
            // returns false.
            if ( !m_pCompData->ShowArchivedCerts () )
            {
                if ( m_bViewArchivedCerts || m_bStoreIsOpenedToViewArchiveCerts )
                {
                    m_bViewArchivedCerts = false;
                    m_bStoreIsOpenedToViewArchiveCerts = false;

                    CloseAndReopenStores ();
                }
            }
        default:
            break;
        }
    }
}

void CFindDialog::CloseAndReopenStores ()
{
    // save the name of the selected store. If there is no name,
    // then "All Certificates Stores" (the default) is selected.
    CString szSelectedStoreName;
    bool    bAllStoresSelected = false;
    int     nCurSel = m_storeList.GetCurSel ();
    if ( nCurSel >= 0 )
    {
        CCertStore* pStore = (CCertStore*) m_storeList.GetItemData (nCurSel);
        if ( pStore )
            szSelectedStoreName = pStore->GetStoreName ();
        else
            bAllStoresSelected = true;
    }

    CloseAllStores ();

    // rebuilds the store list and loses selection
    AddLogicalStoresToList ();

    // If the "All Certificate Stores" is not selected, find the
    // previously selected store and select it again.
    if ( !bAllStoresSelected ) 
    {
        int nCnt = m_storeList.GetCount ();
        ASSERT (CB_ERR != nCnt);
        for (int nIndex = 0; 
                nIndex < nCnt; 
                nIndex++)
        {
            CCertStore* pStore = (CCertStore*) m_storeList.GetItemData (nIndex);
            if ( pStore )
            {
                if ( pStore->GetStoreName () == szSelectedStoreName )
                {
                    m_storeList.SetCurSel (nIndex);
                    break;
                }
            }
        }
    }
}

void CFindDialog::OnLvnKeydownResultList(NMHDR *pNMHDR, LRESULT *pResult)
{
    LPNMLVKEYDOWN pLVKeyDown = reinterpret_cast<LPNMLVKEYDOWN>(pNMHDR);
    
    if ( pLVKeyDown && IDC_RESULT_LIST == pLVKeyDown->hdr.idFrom )
    {
        if ( VK_RETURN == pLVKeyDown->wVKey )
        {
            OnProperties ();
            *pResult = 1;
            return;
        }
    }

    *pResult = 0;
}

void CFindDialog::OnNMSetfocusResultList(NMHDR* /*pNMHDR*/, LRESULT *pResult)
{
    // Kill "default button" style on Find Now button
    SendMessage (DM_SETDEFID, MAKEWPARAM (IDC_RESULT_LIST, 0), 0);
    SendDlgItemMessage (IDC_FIND_NOW, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
    *pResult = 0;
}

void CFindDialog::OnNMKillfocusResultList(NMHDR* /*pNMHDR*/, LRESULT *pResult)
{
    // Add "default button" style to Find Now button
    // Make the OK button the default
    SendMessage (DM_SETDEFID, MAKEWPARAM (IDC_FIND_NOW, 0), 0);
    SendDlgItemMessage (IDC_FIND_NOW, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\finddlglistctrl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       FindDlgListCtrl.h
//
//  Contents:   Base class for cert find dialog list control
//
//----------------------------------------------------------------------------
#if !defined(AFX_FINDDLGLISTCTRL_H__02F18BC6_6AE5_41CA_8F5B_7280B6F39FF5__INCLUDED_)
#define AFX_FINDDLGLISTCTRL_H__02F18BC6_6AE5_41CA_8F5B_7280B6F39FF5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FindDlgListCtrl.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFindDlgListCtrl window

class CFindDlgListCtrl : public CListCtrl
{
// Construction
public:
	CFindDlgListCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFindDlgListCtrl)
	protected:
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFindDlgListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CFindDlgListCtrl)
	afx_msg void OnDestroy();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

private:
	bool m_bSubclassed;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FINDDLGLISTCTRL_H__02F18BC6_6AE5_41CA_8F5B_7280B6F39FF5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\finddlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       FindDlg.h
//
//  Contents:   Base class for cert find dialog
//
//----------------------------------------------------------------------------\

#if !defined(AFX_FINDDLG_H__013A1C28_2930_11D1_B48F_00C04FB94F17__INCLUDED_)
#define AFX_FINDDLG_H__013A1C28_2930_11D1_B48F_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// FindDlg.h : header file
//
#include "certifct.h"
#include "FindDlgListCtrl.h"

/////////////////////////////////////////////////////////////////////////////
// CFindDialog dialog

#define CERT_FIND_SERIAL_NUMBER     0x0000FFFE
class CCertMgrComponentData;    //forward declaration
class CFindDialog : public CHelpDialog
{
// Construction
public:
    CFindDialog (CWnd* pParent,
            const CString &pcszMachineName,
            const CString &szFileName,
            CCertMgrComponentData* pCompData); 

    virtual ~CFindDialog ();

// Dialog Data
    //{{AFX_DATA(CFindDialog)
    enum { IDD = IDD_FIND };
    CComboBox   m_storeList;
    CButton m_stopBtn;
    CFindDlgListCtrl    m_resultsList;
    CButton m_newSearchBtn;
    CButton m_findNowBtn;
    CComboBox   m_fieldList;
    CAnimateCtrl    m_animate;
    CString m_szContains;
    CString m_szSearchField;
    CString m_szSelectedStore;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFindDialog)
    public:
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    static int CALLBACK CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
    void RemoveSpaces (CString & text);

public:
    HRESULT SearchForText (CString & szFindText, DWORD dwPropId);
    HRESULT SearchForNames (const CString& szFindText, DWORD dwFindType);


protected:
    void CloseAllStores ();
    void DoContextHelp (HWND hWndControl);
    void ChangeToSizableFrame ();
    HRESULT LaunchCommonCertDialog (CCertificate* pCert, const int nItem);
    void OnOpen();
    CCertificate* GetSelectedCertificate (OUT int * nSelectedItem = NULL);
    DWORD DisplaySystemError ();
    void OnDelete ();
    void ChangeViewStyle (DWORD dwStyle);
    void DeleteAllResultItems ();
    void RefreshItemInList(CCertificate * pCert, int nItem);
    void InsertItemInList (CCertificate* pCert);
    void SearchForTextOnStore (DWORD dwPropId, 
            CString &szFindName, CCertStore& rCertStore);
    void SearchForNameOnStore (DWORD dwFindFlags, DWORD dwFindType, 
            void* pvPara, CCertStore& rCertStore);
    void DoSearch ();
    void ExpandWindow ();
    void StopSearch ();
    void AddFieldsToList ();
    void AddLogicalStoresToList ();
    void MoveControls ();
    void CloseAndReopenStores ();

    // Generated message map functions
    //{{AFX_MSG(CFindDialog)
    virtual BOOL OnInitDialog();
    afx_msg void OnFindNow();
    afx_msg void OnSizing( UINT nSide, LPRECT lpRect );
    afx_msg void OnDestroy();
    afx_msg void OnNewSearch();
    afx_msg void OnStop();
    afx_msg void OnRclickResultList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnDblclkResultList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnclickResultList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnChangeContainsText();
    afx_msg void OnItemchangedResultList(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    virtual void OnCancel();
    afx_msg void OnSelchangeFieldList();
    //}}AFX_MSG
    afx_msg void OnProperties();
    afx_msg void OnView();
    afx_msg void OnFileDelete();
    void OnEnroll(bool bNewKey);
    afx_msg void OnEnrollNewKey();
    afx_msg void OnEnrollSameKey();
    afx_msg void OnFileExport();
    void OnFileRenew(bool bNewKey);
    afx_msg void OnFileRenewNewKey();
    afx_msg void OnFileRenewSameKey();
    afx_msg void OnEditInvertselection();
    afx_msg void OnEditSelectall();
    afx_msg void OnFileProperties();
    afx_msg void OnHelpHelptopics();
    afx_msg void OnViewDetails();
    afx_msg void OnViewLargeicons();
    afx_msg void OnViewList();
    afx_msg void OnViewSmallicons();
    DECLARE_MESSAGE_MAP()

    enum {
        COL_ISSUED_TO = 0,
        COL_ISSUED_BY,
        COL_EXPIRATION_DATE,
        COL_PURPOSES,
        COL_FRIENDLY_NAME,
        COL_SOURCE_STORE,
        NUM_COLS    // must be last
    };
private:
    void EnableMenuItems ();
    void HideResultList();
    void SetUpResultList();

    HANDLE          m_hCancelSearchEvent;
    bool            m_bConsoleRefreshRequired;
    CCertMgrComponentData* m_pCompData;
    CString         m_szLoggedInUser;
    const CString   m_szManagedService;
    const CString   m_szFileName;
    bool            m_bAnimationRunning;
    CString         m_szMachineName;
    int             m_cyMin;
    int             m_cxMin;
    bool            m_fWindowExpandedOnce;
    int             m_cyOriginal;
    int             m_cxBtnMargin;
    int             m_cxAnimMargin;
    int             m_cxStoreListMargin;
    int             m_cxContainMargin;
    int             m_cxTabMargin;
    int             m_cxFieldListMargin;
    int             m_cxResultListMargin;
    WTL::CImageList m_imageListSmall;
    WTL::CImageList m_imageListNormal;
    bool            m_bInitComplete;
    bool            m_bViewArchivedCerts;
    bool            m_bStoreIsOpenedToViewArchiveCerts;

public:
    void ResetMenu();
    
    bool ConsoleRefreshRequired () const;
    void RestoreAfterSearchSettings();
    CCriticalSection    m_critSec;
    CSingleLock         m_singleLock;
    CStatusBarCtrl      m_statusBar;
    HANDLE              m_hSearchThread;
    afx_msg void OnLvnKeydownResultList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnNMSetfocusResultList(NMHDR *pNMHDR, LRESULT *pResult);
    afx_msg void OnNMKillfocusResultList(NMHDR *pNMHDR, LRESULT *pResult);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FINDDLG_H__013A1C28_2930_11D1_B48F_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\gpepage.h ===
#if !defined(AFX_GPEPAGE_H__61B8B05B_7B0C_11D1_85DF_00C04FB94F17__INCLUDED_)
#define AFX_GPEPAGE_H__61B8B05B_7B0C_11D1_85DF_00C04FB94F17__INCLUDED_
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       gpepage.h
//
//  Contents:   
//
//----------------------------------------------------------------------------

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// GPEPage.h : header file
//

class CCertMgrComponentData; // forward declaration

/////////////////////////////////////////////////////////////////////////////
// CGPERootGeneralPage dialog
class CCertStoreGPE;	// forward declaration

class CGPERootGeneralPage : public CHelpPropertyPage
{
// Construction
public:
	CGPERootGeneralPage(CCertMgrComponentData* pCompData, bool fIsComputerType);
	virtual ~CGPERootGeneralPage();

// Dialog Data
	//{{AFX_DATA(CGPERootGeneralPage)
	enum { IDD = IDD_GPE_GENERAL };
	CButton	m_enableUserRootStoreBtn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGPERootGeneralPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
	virtual void OnOK();

// Implementation
protected:
    virtual void DoContextHelp (HWND hWndControl);
    bool SetGPEFlags (DWORD dwFlags, BOOL bRemoveFlag);
	bool IsCurrentUserRootEnabled () const;
	void GPEGetUserRootFlags ();
    void RSOPGetUserRootFlags (const CCertMgrComponentData* pCompData);

	void SaveCheck();
	// Generated message map functions
	//{{AFX_MSG(CGPERootGeneralPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnableUserRootStore();
	afx_msg void OnSetDisableLmAuthFlag();
	afx_msg void OnUnsetDisableLmAuthFlag();
	afx_msg void OnUnsetDisableNtAuthRequiredFlag();
	afx_msg void OnSetDisableNtAuthRequiredFlag();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	HKEY				    m_hUserRootFlagsKey;
	DWORD				    m_dwGPERootFlags;
	IGPEInformation*	    m_pGPEInformation;
	HKEY				    m_hGroupPolicyKey;
    bool                    m_fIsComputerType;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GPEPAGE_H__61B8B05B_7B0C_11D1_85DF_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\gpepage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       GPEPage.cpp
//
//  Contents:   Implementation of CGPERootGeneralPage
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "GPEPage.h"
#include "storegpe.h"
#include "CompData.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidSnapin;
extern GUID g_guidRegExt;


/////////////////////////////////////////////////////////////////////////////
// CGPERootGeneralPage property page


CGPERootGeneralPage::CGPERootGeneralPage(CCertMgrComponentData* pCompData,
        bool fIsComputerType) :
    CHelpPropertyPage(CGPERootGeneralPage::IDD),
    m_dwGPERootFlags (0),
    m_hUserRootFlagsKey (0),
    m_hGroupPolicyKey (0),
    m_pGPEInformation (pCompData->GetGPEInformation ()),
    m_fIsComputerType (fIsComputerType)
{
    //{{AFX_DATA_INIT(CGPERootGeneralPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();

        HRESULT hResult = m_pGPEInformation->GetRegistryKey (GPO_SECTION_MACHINE,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
        if ( SUCCEEDED (hResult) )
		    GPEGetUserRootFlags ();
    } 
    else 
        RSOPGetUserRootFlags (pCompData);
}

CGPERootGeneralPage::~CGPERootGeneralPage()
{
    if ( m_hUserRootFlagsKey )
        ::RegCloseKey (m_hUserRootFlagsKey);
    if ( m_hGroupPolicyKey )
        ::RegCloseKey (m_hGroupPolicyKey);
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}

void CGPERootGeneralPage::DoDataExchange(CDataExchange* pDX)
{
    CHelpPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CGPERootGeneralPage)
    DDX_Control(pDX, IDC_ENABLE_USER_ROOT_STORE, m_enableUserRootStoreBtn);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGPERootGeneralPage, CHelpPropertyPage)
    //{{AFX_MSG_MAP(CGPERootGeneralPage)
    ON_BN_CLICKED(IDC_ENABLE_USER_ROOT_STORE, OnEnableUserRootStore)
    ON_BN_CLICKED(IDC_SET_DISABLE_LM_AUTH_FLAG, OnSetDisableLmAuthFlag)
	ON_BN_CLICKED(IDC_UNSET_DISABLE_LM_AUTH_FLAG, OnUnsetDisableLmAuthFlag)
	ON_BN_CLICKED(IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG, OnUnsetDisableNtAuthRequiredFlag)
	ON_BN_CLICKED(IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG, OnSetDisableNtAuthRequiredFlag)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGPERootGeneralPage message handlers


BOOL CGPERootGeneralPage::OnInitDialog()
{
    CHelpPropertyPage::OnInitDialog();

    // If this is the RSOP, make it read-only
    if ( !m_pGPEInformation )
    {
        // Make the page read-only
        m_enableUserRootStoreBtn.EnableWindow (FALSE);
        GetDlgItem (IDC_SET_DISABLE_LM_AUTH_FLAG)->EnableWindow (FALSE);
        GetDlgItem (IDC_UNSET_DISABLE_LM_AUTH_FLAG)->EnableWindow (FALSE);
        GetDlgItem (IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG)->EnableWindow (FALSE);
        GetDlgItem (IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG)->EnableWindow (FALSE);
    }

    if ( IsCurrentUserRootEnabled () )
		m_enableUserRootStoreBtn.SetCheck (BST_CHECKED);

    if ( m_dwGPERootFlags & CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG )
        SendDlgItemMessage (IDC_SET_DISABLE_LM_AUTH_FLAG, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_UNSET_DISABLE_LM_AUTH_FLAG, BM_SETCHECK, BST_CHECKED);
 
    if ( m_dwGPERootFlags & CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG )
        SendDlgItemMessage (IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_SETCHECK, BST_CHECKED);
 
 
	return TRUE;  // return TRUE unless you set the focus to a control
      // EXCEPTION: OCX Property Pages should return FALSE
}

void CGPERootGeneralPage::OnOK()
{
    if ( m_pGPEInformation )
    {
	    SaveCheck ();
	    CHelpPropertyPage::OnOK ();
    }
}

void CGPERootGeneralPage::SaveCheck()
{
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        bool    bRetVal = false;

        if ( m_enableUserRootStoreBtn.GetCheck () == BST_CHECKED )
            bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG, TRUE); // remove flag
        else
            bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG, FALSE); // set flag

        if ( bRetVal )
        {
            if ( BST_CHECKED == SendDlgItemMessage (IDC_SET_DISABLE_LM_AUTH_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG, FALSE);	// set flag
            else if ( BST_CHECKED == SendDlgItemMessage (IDC_UNSET_DISABLE_LM_AUTH_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_LM_AUTH_FLAG, TRUE);	// remove flag
        }
        
        if ( bRetVal )
        {
            if ( BST_CHECKED == SendDlgItemMessage (IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG, FALSE);	// set flag
            else if ( BST_CHECKED == SendDlgItemMessage (IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG, BM_GETCHECK) )
                bRetVal = SetGPEFlags ((DWORD) CERT_PROT_ROOT_DISABLE_NT_AUTH_REQUIRED_FLAG, TRUE);	// remove flag
        }

        if ( bRetVal )
        {
			// TRUE means we're changing the machine policy only
            m_pGPEInformation->PolicyChanged (TRUE, TRUE, &g_guidExtension, &g_guidSnapin);
            m_pGPEInformation->PolicyChanged (TRUE, TRUE, &g_guidRegExt, &g_guidSnapin);
        }
    }
}

void CGPERootGeneralPage::OnEnableUserRootStore()
{
    SetModified (TRUE);
}


void CGPERootGeneralPage::OnSetDisableLmAuthFlag()
{
    SetModified (TRUE);
}

bool CGPERootGeneralPage::SetGPEFlags (DWORD dwFlags, BOOL bRemoveFlag)
{
    bool    bRetVal = false;

    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        // security review 2/27/2002 BryanWal ok
        LONG    lResult =  ::RegQueryValueEx (m_hUserRootFlagsKey,       // handle of key to query
		            CERT_PROT_ROOT_FLAGS_VALUE_NAME,  // address of name of value to query
			        0,              // reserved
				    &dwType,        // address of buffer for value type
				    (LPBYTE) &dwData,       // address of data buffer
				    &cbData);           // address of data buffer size);
	    ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
        {
            if ( ERROR_SUCCESS == lResult && REG_DWORD != dwType )
            {
                ASSERT (0);
                return false;
            }

            if ( bRemoveFlag )
                dwData &= ~dwFlags;
            else
                dwData |= dwFlags;

            lResult = ::RegSetValueEx (m_hUserRootFlagsKey,
				    CERT_PROT_ROOT_FLAGS_VALUE_NAME, // address of value to set
				    0,              // reserved
				    REG_DWORD,          // flag for value type
				    (CONST BYTE *) &dwData, // address of value data
				    cbData);        // size of value data);
            ASSERT (ERROR_SUCCESS == lResult);
            if ( ERROR_SUCCESS == lResult )
		    {
                m_dwGPERootFlags = dwData;
                bRetVal = true;
		    }
		    else
                DisplaySystemError (m_hWnd, lResult);
        }
        else
            DisplaySystemError (m_hWnd, lResult);
    }

    return bRetVal;
}

bool CGPERootGeneralPage::IsCurrentUserRootEnabled() const
{
    if (m_dwGPERootFlags & CERT_PROT_ROOT_DISABLE_CURRENT_USER_FLAG)
        return false;
    else
        return true;
}

void CGPERootGeneralPage::RSOPGetUserRootFlags(const CCertMgrComponentData* pCompData)
{
    if ( pCompData )
    {
        const CRSOPObjectArray* pObjectArray = m_fIsComputerType ?
                pCompData->GetRSOPObjectArrayComputer () : 
                pCompData->GetRSOPObjectArrayUser ();
        int     nIndex = 0;

        // NOTE: rsop object array is sorted first by registry key, then by precedence
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // Consider only entries from this store
                // security review 2/27/2002 BryanWal ok
                if ( !wcscmp (CERT_PROT_ROOT_FLAGS_REGPATH, pObject->GetRegistryKey ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    m_dwGPERootFlags = pObject->GetDWORDValue ();
                    break;
                }
            }
            else
                break;

            nIndex++;
        }
    }
}

void CGPERootGeneralPage::GPEGetUserRootFlags()
{
    DWORD   dwDisposition = 0;

    // security review 2/27/2002 BryanWal ok
    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            CERT_PROT_ROOT_FLAGS_REGPATH,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,            // special options flag
            KEY_QUERY_VALUE | KEY_SET_VALUE,    // desired security access
            NULL,     // address of key security structure
			&m_hUserRootFlagsKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (lResult == ERROR_SUCCESS);
    if ( lResult == ERROR_SUCCESS )
    {
        // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        // security review 2/27/2002 BryanWal ok
        lResult =  ::RegQueryValueEx (m_hUserRootFlagsKey,       // handle of key to query
		        CERT_PROT_ROOT_FLAGS_VALUE_NAME,  // address of name of value to query
			    0,              // reserved
	            &dwType,        // address of buffer for value type
		        (LPBYTE) &dwData,       // address of data buffer
			    &cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            if ( REG_DWORD == dwType )
            {
                m_dwGPERootFlags = dwData;
            }
		}
        else
            DisplaySystemError (NULL, lResult);
    }
    else
        DisplaySystemError (NULL, lResult);
}


void CGPERootGeneralPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CGPERootGeneralPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_ENABLE_USER_ROOT_STORE,                 IDH_GPEPAGE_ENABLE_USER_ROOT_STORE,
        IDC_SET_DISABLE_LM_AUTH_FLAG,               IDH_SET_DISABLE_LM_AUTH_FLAG,
        IDC_UNSET_DISABLE_LM_AUTH_FLAG,             IDH_UNSET_DISABLE_LM_AUTH_FLAG,
        IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG,      IDH_SET_DISABLE_NT_AUTH_REQUIRED_FLAG,
        IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG,    IDH_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_ENABLE_USER_ROOT_STORE:
    case IDC_SET_DISABLE_LM_AUTH_FLAG:
    case IDC_UNSET_DISABLE_LM_AUTH_FLAG:
    case IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG:
    case IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CGPERootGeneralPage::DoContextHelp\n");
}


void CGPERootGeneralPage::OnUnsetDisableLmAuthFlag() 
{
	SetModified (TRUE);
}

void CGPERootGeneralPage::OnUnsetDisableNtAuthRequiredFlag() 
{
	SetModified (TRUE);
}

void CGPERootGeneralPage::OnSetDisableNtAuthRequiredFlag() 
{
	SetModified (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\helpids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       helpids.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------

// IDD_FIND
#define	IDH_FIND_STORE_LIST			            100000001
#define	IDH_FIND_CONTAINS_TEXT		            100000003
#define	IDH_FIND_FIELD_LIST			            100000004
#define	IDH_FIND_FIND_NOW			            100000005
#define	IDH_FIND_STOP				            100000006
#define	IDH_FIND_NEW_SEARCH			            100000007
#define	IDH_FIND_RESULT_LIST		            100000008

// IDD_PASSWORD
#define IDH_PASSWORD_PASSWORD1                  100000009
#define IDH_PASSWORD_PASSWORD2                  100000010

// IDD_VIEW_OPTIONS
#define IDH_OPTIONS_VIEW_BY_PURPOSE             100000011
#define IDH_OPTIONS_VIEW_BY_STORE               100000012
#define IDH_OPTIONS_SHOW_PHYSICAL               100000013
#define IDH_OPTIONS_SHOW_ARCHIVED               100000014

// IDD_AUTO_CERT_REQUEST_GENERAL
#define IDH_ACRPAGE_CERT_TYPE                   100000017
#define IDH_ACRPAGE_CERT_PURPOSES               100000018
#define IDH_ACRPAGE_CA_LIST                     100000019

// IDD_POLICY_PRECEDENCE
#define IDH_POLICY_PRECEDENCE                   100000020

// IDD_PROPPAGE_AUTOENROLL
#define IDH_AUTOENROLL_DISABLE_ALL              100000021
#define IDH_AUTOENROLL_ENABLE                   100000022
#define IDH_AUTOENROLL_ENABLE_PENDING           100000023
#define IDH_AUTOENROLL_ENABLE_TEMPLATE          100000024

// IDD_SAFER_LEVEL_GENERAL
#define IDH_SAFER_LEVEL_NAME                    100000030
#define IDH_SAFER_LEVEL_DESCRIPTION             100000031
#define IDH_SAFER_LEVEL_SET_AS_DEFAULT          100000032
#define IDH_SAFER_LEVEL_STATUS                  100000033

// IDD_SAFER_TRUSTED_PUBLISHER
#define IDH_TP_BY_END_USER                      100000040
#define IDH_TP_BY_LOCAL_COMPUTER_ADMIN          100000041
#define IDH_TP_BY_ENTERPRISE_ADMIN              100000042
#define IDH_TP_REV_CHECK_PUBLISHER              100000043
#define IDH_TP_REV_CHECK_TIMESTAMP              100000044

// IDD_SAFER_DEFINED_FILE_TYPES
#define IDH_DEFINED_FILE_TYPES                  100000050
#define IDH_DELETE_DEFINED_FILE_TYPE            100000051
#define IDH_DEFINED_FILE_TYPE_EDIT              100000052
#define IDH_ADD_DEFINED_FILE_TYPE               100000053

// IDD_SAFER_ENTRY_CERTIFICATE
#define IDH_CERT_ENTRY_SUBJECT_NAME             100000060
#define IDH_CERT_ENTRY_BROWSE                   100000061
#define IDH_CERT_ENTRY_SECURITY_LEVEL           100000062
#define IDH_CERT_ENTRY_DESCRIPTION              100000066
#define IDH_CERT_ENTRY_LAST_MODIFIED            100000067

// IDD_SAFER_ENTRY_PATH
#define IDH_PATH_ENTRY_PATH                     100000070
#define IDH_PATH_ENTRY_SECURITY_LEVEL           100000072
#define IDH_PATH_ENTRY_DESCRIPTION              100000076
#define IDH_PATH_ENTRY_LAST_MODIFIED            100000077
#define IDH_PATH_ENTRY_BROWSE_FOLDER            100000078

// IDD_SAFER_ENTRY_HASH
#define IDH_HASH_ENTRY_APPLICATION_NAME         100000080
#define IDH_HASH_ENTRY_BROWSE                   100000081
#define IDH_HASH_ENTRY_SECURITY_LEVEL           100000082
#define IDH_HASH_ENTRY_DESCRIPTION              100000084
#define IDH_HASH_ENTRY_LAST_MODIFIED            100000085
#define IDH_HASH_HASHED_FILE_PATH               100000086

// IDD_SAFER_ENTRY_INTERNET_ZONE
#define IDH_IZONE_ENTRY_ZONES                   100000090
#define IDH_IZONE_ENTRY_SECURITY_LEVEL          100000091
#define IDH_IZONE_ENTRY_DESCRIPTION             100000095
#define IDH_IZONE_ENTRY_LAST_MODIFIED           100000096

// IDD_GPE_GENERAL
#define IDH_GPEPAGE_ENABLE_USER_ROOT_STORE      100000015
#define IDH_SET_DISABLE_LM_AUTH_FLAG            100000100
#define IDH_UNSET_DISABLE_LM_AUTH_FLAG          100000101
#define IDH_SET_DISABLE_NT_AUTH_REQUIRED_FLAG   100000102
#define IDH_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG 100000103

// IDD_SAFER_ENFORCEMENT
#define IDH_ALL_EXCEPT_LIBS                     100000110
#define IDH_ALL_SOFTWARE_FILES                  100000111
#define IDH_APPLY_TO_ALL_USERS                  100000112
#define IDH_APPLY_EXCEPT_ADMINS                 100000113

// IDD_EFS_GENERAL
#define IDH_TURN_ON_EFS                         100000120
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\nodetype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       nodetype.h
//
//  Contents:   Declaration of CertificateManagerObjectType
//
//----------------------------------------------------------------------------

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _CertificateManagerObjectType {
	CERTMGR_MULTISEL = MMC_MULTI_SELECT_COOKIE,
	CERTMGR_INVALID = SPECIAL_COOKIE_MIN - 1,
	CERTMGR_SNAPIN = 0,
	CERTMGR_CERTIFICATE,
	CERTMGR_LOG_STORE,
	CERTMGR_PHYS_STORE,
	CERTMGR_USAGE,
	CERTMGR_CRL_CONTAINER,
	CERTMGR_CTL_CONTAINER,
	CERTMGR_CERT_CONTAINER,
	CERTMGR_CRL,
	CERTMGR_CTL,
	CERTMGR_AUTO_CERT_REQUEST,
	CERTMGR_CERT_POLICIES_USER,
	CERTMGR_CERT_POLICIES_COMPUTER,
	CERTMGR_LOG_STORE_GPE,
    CERTMGR_LOG_STORE_RSOP,
    CERTMGR_PKP_AUTOENROLLMENT_COMPUTER_SETTINGS,
    CERTMGR_PKP_AUTOENROLLMENT_USER_SETTINGS,
    CERTMGR_SAFER_COMPUTER_ROOT,
    CERTMGR_SAFER_USER_ROOT,
    CERTMGR_SAFER_COMPUTER_LEVELS,
    CERTMGR_SAFER_USER_LEVELS,
    CERTMGR_SAFER_COMPUTER_ENTRIES,
    CERTMGR_SAFER_USER_ENTRIES,
    CERTMGR_SAFER_COMPUTER_LEVEL,
    CERTMGR_SAFER_USER_LEVEL,
    CERTMGR_SAFER_COMPUTER_ENTRY,
    CERTMGR_SAFER_USER_ENTRY,
    CERTMGR_SAFER_COMPUTER_TRUSTED_PUBLISHERS,
    CERTMGR_SAFER_USER_TRUSTED_PUBLISHERS,
    CERTMGR_SAFER_COMPUTER_DEFINED_FILE_TYPES,
    CERTMGR_SAFER_USER_DEFINED_FILE_TYPES,
    CERTMGR_SAFER_USER_ENFORCEMENT,
    CERTMGR_SAFER_COMPUTER_ENFORCEMENT,
	CERTMGR_NUMTYPES		//must be last
} CertificateManagerObjectType, *PCertificateManagerObjectType;

inline bool IsValidObjectType (CertificateManagerObjectType objecttype)
{ 
	return (objecttype >= CERTMGR_SNAPIN && objecttype < CERTMGR_NUMTYPES); 
}


#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\locate.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       locate.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_LOCATE_H__DE5E8115_A351_11D1_861B_00C04FB94F17__INCLUDED_)
#define AFX_LOCATE_H__DE5E8115_A351_11D1_861B_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Locate.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizLocate dialog

class CAddEFSWizLocate : public CWizard97PropertyPage
{
    DECLARE_DYNCREATE(CAddEFSWizLocate)

// Construction
public:
    CAddEFSWizLocate();
    ~CAddEFSWizLocate();

// Dialog Data
    //{{AFX_DATA(CAddEFSWizLocate)
    enum { IDD = IDD_ADD_EFS_AGENT_SELECT_USER };
    CListCtrl   m_UserAddList;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CAddEFSWizLocate)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardBack();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CAddEFSWizLocate)
    afx_msg void OnBrowseDir();
    afx_msg void OnBrowseFile();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void EnableControls ();

private:
    DWORD GetCertNameFromCertContext(PCCERT_CONTEXT pCertContext, PWSTR *ppwszUserCertName);
    HRESULT FindUserFromDir();
    bool IsCertificateRevoked (PCCERT_CONTEXT pCertContext);
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOCATE_H__DE5E8115_A351_11D1_861B_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\helppropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       HelpPropertyPage.h
//
//  Contents:   Declaration of CHelpPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
#define AFX_HELPPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// HelpPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpPropertyPage : public CAutoDeletePropPage
{
// Construction
public:
	CHelpPropertyPage(UINT uIDD);
	virtual ~CHelpPropertyPage();

// Dialog Data
	//{{AFX_DATA(CHelpPropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpPropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpPropertyPage)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

    HWND            m_hWndWhatsThis;
};


/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage dialog

class CHelpDialog : public CDialog
{
// Construction
public:
	CHelpDialog(UINT uIDD, CWnd* pParentWnd);
	~CHelpDialog();

// Dialog Data
	//{{AFX_DATA(CHelpDialog)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CHelpDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CHelpDialog)
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	afx_msg void OnWhatsThis();
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);

    HWND            m_hWndWhatsThis;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\helppropertypage.cpp ===
// HelpPropertyPage.cpp : implementation file
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage property page


CHelpPropertyPage::CHelpPropertyPage(UINT uIDD) : 
    CAutoDeletePropPage(uIDD),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpPropertyPage::~CHelpPropertyPage()
{
}

void CHelpPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpPropertyPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CHelpPropertyPage)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpPropertyPage message handlers
void CHelpPropertyPage::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpPropertyPage::OnWhatsThis\n");
}

BOOL CHelpPropertyPage::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpPropertyPage::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnHelp\n");
    return TRUE;
}

void CHelpPropertyPage::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpPropertyPage::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpPropertyPage::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpPropertyPage::OnContextMenu\n");
}


/////////////////////////////////////////////////////////////////////////////
// CHelpDialog property page


CHelpDialog::CHelpDialog(UINT uIDD, CWnd* pParentWnd) : 
    CDialog(uIDD, pParentWnd),
    m_hWndWhatsThis (0)
{
	//{{AFX_DATA_INIT(CHelpDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CHelpDialog::~CHelpDialog()
{
}

void CHelpDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CHelpDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CHelpDialog, CDialog)
	//{{AFX_MSG_MAP(CHelpDialog)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_COMMAND(IDM_WHATS_THIS, OnWhatsThis)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CHelpDialog message handlers
void CHelpDialog::OnWhatsThis()
{
    _TRACE (1, L"Entering CHelpDialog::OnWhatsThis\n");
    // Display context help for a control
    if ( m_hWndWhatsThis )
    {
        DoContextHelp (m_hWndWhatsThis);
    }
    _TRACE (-1, L"Leaving CHelpDialog::OnWhatsThis\n");
}

BOOL CHelpDialog::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CHelpDialog::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        // Display context help for a control
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CHelpDialog::OnHelp\n");
    return TRUE;
}

void CHelpDialog::DoContextHelp (HWND /*hWndControl*/)
{
}

void CHelpDialog::OnContextMenu(CWnd* /*pWnd*/, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CHelpDialog::OnContextMenu\n");
	CMenu bar;
	if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
	{
		CMenu& popup = *bar.GetSubMenu (0);
		ASSERT(popup.m_hMenu);

		if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
			    point.x,    // in screen coordinates
				point.y,    // in screen coordinates
			    this) ) // route commands through main window
		{
			m_hWndWhatsThis = 0;
			ScreenToClient (&point);
			CWnd* pChild = ChildWindowFromPoint (
					point,  // in client coordinates
					CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
			if ( pChild )
				m_hWndWhatsThis = pChild->m_hWnd;
	    }
	}

    _TRACE (-1, L"Leaving CHelpDialog::OnContextMenu\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\locate.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       locate.cpp
//
//  Contents:   Implementation of Add EFS Agent Wizard Location Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "AddSheet.h"
#include "Locate.h"
#pragma warning(push, 3)
#include <initguid.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <winldap.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
#include <efsstruc.h>
#pragma warning(pop)

USE_HANDLE_MACROS("CERTMGR(locate.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define szCertAttr  _T ("?userCertificate")

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizLocate property page

IMPLEMENT_DYNCREATE(CAddEFSWizLocate, CWizard97PropertyPage)

CAddEFSWizLocate::CAddEFSWizLocate() : CWizard97PropertyPage(CAddEFSWizLocate::IDD)
{
    //{{AFX_DATA_INIT(CAddEFSWizLocate)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    VERIFY (m_szHeaderTitle.LoadString (IDS_EFS_LOCATE_TITLE));
    VERIFY (m_szHeaderSubTitle.LoadString (IDS_EFS_LOCATE_SUBTITLE));
    InitWizard97 (FALSE);
}

CAddEFSWizLocate::~CAddEFSWizLocate()
{
}

void CAddEFSWizLocate::DoDataExchange(CDataExchange* pDX)
{
    CWizard97PropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddEFSWizLocate)
    DDX_Control (pDX, IDC_ADDLIST, m_UserAddList);
    //}}AFX_DATA_MAP
    InitWizard97 (FALSE);
}


BEGIN_MESSAGE_MAP(CAddEFSWizLocate, CWizard97PropertyPage)
    //{{AFX_MSG_MAP(CAddEFSWizLocate)
    ON_BN_CLICKED (IDC_BROWSE_DIR, OnBrowseDir)
    ON_BN_CLICKED (IDC_BROWSE_FILE, OnBrowseFile)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizLocate message handlers

BOOL CAddEFSWizLocate::OnSetActive ()
{
    BOOL bResult = CWizard97PropertyPage::OnSetActive ();

    EnableControls ();
    
    return bResult;
}

void CAddEFSWizLocate::OnBrowseDir ()
{
    FindUserFromDir (); 
    EnableControls ();
}

void CAddEFSWizLocate::OnBrowseFile ()
{
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_CERTFILEFILTER));

    // replace "|" with 0;
    // security review 2/27/2002 BryanWal ok
    const size_t  nFilterLen = wcslen (szFileFilter) + 1;
    PWSTR   pszFileFilter = new WCHAR [nFilterLen];
    if ( pszFileFilter )
    {
        // security review 2/27/2002 BryanWal ok
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }

        WCHAR           szFile[MAX_PATH];
        // security review 2/27/2002 BryanWal ok
        ::ZeroMemory (szFile, sizeof (szFile));
        OPENFILENAME    ofn;
        // security review 2/27/2002 BryanWal ok
        ::ZeroMemory (&ofn, sizeof (ofn));

        ofn.lStructSize = sizeof (OPENFILENAME);
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = (PCWSTR) pszFileFilter; 
        ofn.lpstrFile = szFile; 
        ofn.nMaxFile = MAX_PATH; 
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; 


        BOOL bResult = ::GetOpenFileName (&ofn);
        if ( bResult )
        {
            CString szFileName = ofn.lpstrFile;
            //
            // Open cert store from the file
            //

            HCERTSTORE      hCertStore = NULL;
            PVOID           FileNameVoidP = (PVOID) (LPCWSTR)szFileName;
            PCCERT_CONTEXT  pCertContext = NULL;
            DWORD           dwEncodingType = 0;
            DWORD           dwContentType = 0;
            DWORD           dwFormatType = 0;

            BOOL    bReturn = ::CryptQueryObject (
                    CERT_QUERY_OBJECT_FILE,
                    FileNameVoidP,
                    CERT_QUERY_CONTENT_FLAG_ALL,
                    CERT_QUERY_FORMAT_FLAG_ALL,
                    0,
                    &dwEncodingType,
                    &dwContentType,
                    &dwFormatType,
                    &hCertStore,
                    NULL,
                    (const void **)&pCertContext);

            ASSERT (bReturn);
            if ( bReturn )
            {
                //
                // Success. See what we get back. A store or a cert.
                //

                if (  (dwContentType == CERT_QUERY_CONTENT_SERIALIZED_STORE)
                        && hCertStore)
                {

                    CERT_ENHKEY_USAGE   enhKeyUsage;
                    // security review 2/27/2002 BryanWal ok
                    ::ZeroMemory (&enhKeyUsage, sizeof (enhKeyUsage));
                    enhKeyUsage.cUsageIdentifier = 1;
                    enhKeyUsage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;
                    //
                    // We get the certificate store
                    //
                    pCertContext = ::CertFindCertificateInStore (
                            hCertStore,
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            0,
                            CERT_FIND_ENHKEY_USAGE,
                            &enhKeyUsage,
                            NULL);
                    if ( !pCertContext )
                    {
                        CString caption;
                        CString text;
                        CThemeContextActivator activator;

                        VERIFY (text.LoadString (IDS_EFS_FILE_HAS_NO_EFS_USAGE));
                        VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                        MessageBox (text, caption, MB_OK);
                        return;
                    }

                    if ( hCertStore )
                        ::CertCloseStore (hCertStore, 0);
                }
                else if ( (dwContentType != CERT_QUERY_CONTENT_CERT) || !pCertContext )
                {
                    //
                    // Neither a valid cert file nor a store file we like.
                    //

                    if ( hCertStore )
                        ::CertCloseStore (hCertStore, 0);

                    if  ( pCertContext )
                        ::CertFreeCertificateContext (pCertContext);

                    CString ErrMsg;
                    CThemeContextActivator activator;

                    VERIFY (ErrMsg.LoadString (IDS_CERTFILEFORMATERR));
                    MessageBox (ErrMsg);
                    return;

                }

                if ( hCertStore )
                {
                    ::CertCloseStore (hCertStore, 0);
                    hCertStore = NULL;
                }

                //
                // Add the user
                //

                if ( CertHasEFSKeyUsage (pCertContext) )
                {
                    //
                    // We got the cert. Add it to the structure. We need get the subject name first.
                    //
                    
                    // verify that certificate is not revoked
                    if ( !IsCertificateRevoked (pCertContext) )
                    {
                        // verify that certificate is valid
                        if ( 0 == CertVerifyTimeValidity (NULL, pCertContext->pCertInfo) )
                        {
                            LPWSTR  pszUserCertName = 0;
                            INT_PTR iRetCode = GetCertNameFromCertContext (
                                    pCertContext,
                                    &pszUserCertName);

                            if ( ERROR_SUCCESS != iRetCode )
                            {
                                if  ( pCertContext )
                                {
                                    ::CertFreeCertificateContext (pCertContext);
                                }

                                return;
                            }
                            CAddEFSWizSheet*    pAddSheet = reinterpret_cast <CAddEFSWizSheet*> (m_pWiz);
                            ASSERT (pAddSheet);
                            if ( !pAddSheet )
                                return;

                            EFS_CERTIFICATE_BLOB    certBlob;

                            certBlob.cbData = pCertContext->cbCertEncoded;
                            certBlob.pbData = pCertContext->pbCertEncoded;
                            certBlob.dwCertEncodingType = pCertContext->dwCertEncodingType;
                            iRetCode = pAddSheet->Add (
                                    NULL,
                                    pszUserCertName,
                                    (PVOID)&certBlob,
                                    NULL,
                                    USERADDED,
                                    pCertContext);

                            if ( (ERROR_SUCCESS != iRetCode) && (CRYPT_E_EXISTS != iRetCode) )
                            {
                                //
                                // Error in adding the user
                                //

                                ::CertFreeCertificateContext (pCertContext);
                                pCertContext = NULL;
                            }
                            else
                            {
                                //
                                // Add the user to the list box.
                                //

                                if ( iRetCode == ERROR_SUCCESS )
                                {
                                    LV_ITEM fillItem;
                                    CString userUnknown;

                                    try {
                                        if (!userUnknown.LoadString (IDS_UNKNOWNUSER))
                                        {
                                            ASSERT (0);
                                            userUnknown.Empty ();
                                        }
                                    }
                                    catch (...)
                                    {
                                        userUnknown.Empty ();
                                    }

                                    fillItem.mask = LVIF_TEXT;
                                    fillItem.iItem = 0;
                                    fillItem.iSubItem = 0;
                                    if ( userUnknown.IsEmpty () )
                                    {
                                        fillItem.pszText = _T ("");
                                    }
                                    else
                                    {
                                        fillItem.pszText = userUnknown.GetBuffer (userUnknown.GetLength () + 1);
                                    }
                                    fillItem.iItem = m_UserAddList.InsertItem (&fillItem);
                                    if ( !userUnknown.IsEmpty () )
                                    {
                                        userUnknown.ReleaseBuffer ();
                                    }

                                    if ( fillItem.iItem != -1 )
                                    {
                                        fillItem.pszText = pszUserCertName;
                                        fillItem.iSubItem = 1;
                                        m_UserAddList.SetItem (&fillItem);
                                    }
                                    else
                                    {
                                        pAddSheet->Remove (NULL,  pszUserCertName);
                                    }
                                    pszUserCertName = NULL;
                                }
                                else
                                {
                                    //
                                    // Already deleted inside the Add.
                                    //

                                    pszUserCertName = NULL;
                                }
                            }

                            if (pszUserCertName)
                            {
                                delete [] pszUserCertName;
                                pszUserCertName = NULL;
                            }
                        }
                        else
                        {
                            CString text;
                            CString caption;
                            CThemeContextActivator activator;

    
                            VERIFY (text.LoadString (IDS_EFS_CERT_IS_NOT_VALID));
                            VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                            MessageBox (text, caption, MB_OK);
                        }

                    }
                }
                else
                {
                    CString caption;
                    CString text;
                    CThemeContextActivator activator;

                    VERIFY (text.LoadString (IDS_EFS_FILE_HAS_NO_EFS_USAGE));
                    VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                    MessageBox (text, caption, MB_OK);
                }
            }
            else
            {
                //
                // Fail. Get the error code.
                //
                DWORD   dwErr = GetLastError ();
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                text.FormatMessage (IDS_CERTFILEOPENERR, 
                        szFileName, GetSystemMessage (dwErr));
                MessageBox (text, caption);
            }
        }

        delete [] pszFileFilter;
    }

    EnableControls ();
}


HRESULT CAddEFSWizLocate::FindUserFromDir ()
{
    HRESULT             hr = S_OK;
    LPWSTR              pszListUserName = NULL;
    LPWSTR              pszUserCertName = NULL;

    FORMATETC           fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM           medium = { TYMED_NULL, NULL, NULL };

    ICommonQuery*       pCommonQuery = NULL;
    OPENQUERYWINDOW     oqw;
    DSQUERYINITPARAMS   dqip;
    bool                bCheckDS = false;
    HANDLE              hDS = NULL;
    CAddEFSWizSheet*    pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
    ASSERT (pAddSheet);
    if ( !pAddSheet )
        return E_POINTER;

    // security review 2/27/2002 BryanWal ok
    hr = ::CoCreateInstance (CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER,
            IID_ICommonQuery, (LPVOID*)&pCommonQuery);

    ASSERT (SUCCEEDED (hr));
    if ( SUCCEEDED (hr) )
    {
        dqip.cbStruct = sizeof (dqip);
        dqip.dwFlags = DSQPF_SHOWHIDDENOBJECTS |
                       DSQPF_ENABLEADMINFEATURES;

        dqip.pDefaultScope = NULL;  //szScopeLocn

        oqw.cbStruct = sizeof (oqw);
        oqw.dwFlags = OQWF_OKCANCEL |
                    //    OQWF_SINGLESELECT |
                        OQWF_DEFAULTFORM |
                        OQWF_REMOVEFORMS ;
        oqw.clsidHandler = CLSID_DsQuery;
        oqw.pHandlerParameters = &dqip;
        oqw.clsidDefaultForm = CLSID_DsFindPeople;

        IDataObject* pDataObject = NULL;

        hr = pCommonQuery->OpenQueryWindow (m_hWnd, &oqw, &pDataObject);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) && pDataObject )
        {
            // Fill the list view

            fmte.cfFormat = pAddSheet->GetDataFormat ();
            hr = pDataObject->GetData (&fmte, &medium);
            // A return of DV_E_FORMATETC (0x80040064) here can mean that
            // nothing was selected in the query window
            if ( SUCCEEDED (hr) )
            {
                LPDSOBJECTNAMES pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;

                hr = DsBind (NULL, NULL, &hDS);
                if ( SUCCEEDED (hr) )
                {
                    //
                    //  We are going to use the DS to crack the names
                    //

                    bCheckDS = true;
                }


                if ( pDsObjects->cItems )
                {
                    // Verify that each user has a cert that allows the necessary
                    // action (efs decryption)
                    for ( UINT i = 0 ; i < pDsObjects->cItems ; i++ )
                    {
                        PWSTR           pszTemp = (PWSTR)
                             ( ( (LPBYTE)pDsObjects)+pDsObjects->aObjects[i].offsetName);
                        DS_NAME_RESULT* pUserName = NULL;
                        PSID            userSID = NULL;
                        DWORD           cbSid = 0;
                        PWSTR           pszReferencedDomainName = NULL;
                        DWORD           cbReferencedDomainName = 0;
                        SID_NAME_USE    SidUse;


                        //
                        // Get rid of the head :\\
                        //

                        LPWSTR pszSearch = wcschr (pszTemp, _T (':'));
                        if (pszSearch && (pszSearch[1] == _T ('/')) && (pszSearch[2] == _T ('/')))
                        {
                            pszTemp = pszSearch + 3;
                        }

                        if ( bCheckDS )
                        {
                            hr = DsCrackNames (
                                                    hDS,
                                                    DS_NAME_NO_FLAGS,
                                                    DS_FQDN_1779_NAME,
                                                    DS_NT4_ACCOUNT_NAME,
                                                    1,
                                                    &pszTemp,
                                                    &pUserName
                                                   );

                            if ( SUCCEEDED (hr) && pUserName )
                            {
                                if ( ( pUserName->cItems > 0 ) && (DS_NAME_NO_ERROR == pUserName->rItems[0].status))
                                {
                                    //
                                    // Save the NT4 name first, in case we cannot get the principle name
                                    //

                                    pszListUserName = new WCHAR[wcslen (pUserName->rItems[0].pName) + 1];
                                    if (pszListUserName)
                                    {
                                        // security review 2/27/2002 BryanWal ok
                                        wcscpy (pszListUserName, pUserName->rItems[0].pName);
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    }

                                    BOOL    bReturn =  ::LookupAccountName (
                                                NULL,
                                                pUserName->rItems[0].pName,
                                                userSID,
                                                &cbSid,
                                                pszReferencedDomainName,
                                                &cbReferencedDomainName,
                                                &SidUse
                                               );

                                    hr = GetLastError ();
                                    if ( !bReturn && (HRESULT_FROM_WIN32 (ERROR_INSUFFICIENT_BUFFER) == hr) )
                                    {
                                        //
                                        // We are expecting this error
                                        //

                                        userSID = new BYTE[cbSid];
                                        pszReferencedDomainName =  new WCHAR[cbReferencedDomainName];
                                        if ( userSID && pszReferencedDomainName )
                                        {
                                            bReturn =  ::LookupAccountName (
                                                        NULL,
                                                        pUserName->rItems[0].pName,
                                                        userSID,
                                                        &cbSid,
                                                        pszReferencedDomainName,
                                                        &cbReferencedDomainName,
                                                        &SidUse);

                                            delete [] pszReferencedDomainName;
                                            pszReferencedDomainName = NULL;
                                            if (!bReturn)
                                            {
                                                //
                                                // Get SID failed. We can live with it.
                                                //

                                                userSID = NULL;
                                            }
                                        }
                                        else
                                        {
                                            if (userSID)
                                            {
                                                delete [] userSID;
                                                userSID = NULL;
                                            }
                                            if (pszReferencedDomainName)
                                            {
                                                delete [] pszReferencedDomainName;
                                                pszReferencedDomainName = NULL;
                                            }
                                            hr = E_OUTOFMEMORY;
                                            break;
                                        }
                                    }
                                    else
                                    {
                                        ASSERT (!bReturn);
                                        userSID = NULL;
                                    }
                                }
                            }
                            else
                            {
                                //
                                // Cannot get the NT4 name. Set the SID to NULL. Go on.
                                //

                                userSID = NULL;
                            }

                            if (pUserName)
                            {
                                DsFreeNameResult (pUserName);
                                pUserName = NULL;
                            }

                            hr = DsCrackNames (
                                    hDS,
                                    DS_NAME_NO_FLAGS,
                                    DS_FQDN_1779_NAME,
                                    DS_USER_PRINCIPAL_NAME,
                                    1,
                                    &pszTemp,
                                    &pUserName);

                            ASSERT (SUCCEEDED (hr));
                            if ( (HRESULT_FROM_WIN32 (ERROR_SUCCESS) == hr) &&
                                  ( pUserName->cItems > 0 ) &&
                                  (DS_NAME_NO_ERROR == pUserName->rItems[0].status) )
                            {
                                //
                                // We got the principal name
                                //

                                LPWSTR  pszTmpNameStr =
                                        new WCHAR[wcslen (pUserName->rItems[0].pName) + 1];
                                if ( pszTmpNameStr )
                                {
                                    // security review 2/27/2002 BryanWal ok
                                    wcscpy (pszTmpNameStr, pUserName->rItems[0].pName);
                                    delete [] pszListUserName;
                                    pszListUserName = pszTmpNameStr;
                                }
                                else
                                {
                                    hr = ERROR_OUTOFMEMORY;
                                }
                            }
                        }

                        if ( (HRESULT_FROM_WIN32 (ERROR_OUTOFMEMORY) != hr) && ( !pszListUserName))
                        {
                            //
                            // Use the LDAP name
                            //
                            pszListUserName = new WCHAR[wcslen (pszTemp)+1];
                            if ( pszListUserName )
                            {
                                // security review 2/27/2002 BryanWal ok    
                                wcscpy (pszListUserName, pszTemp);
                            }
                            else
                            {
                                hr = ERROR_OUTOFMEMORY;
                            }

                        }

                        if (pUserName)
                        {
                            DsFreeNameResult (pUserName);
                            pUserName = NULL;
                        }

                        if ( HRESULT_FROM_WIN32 (ERROR_OUTOFMEMORY) != hr )
                        {
                            //
                            // Now is the time to get the certificate
                            //
                            PCWSTR  pszHeader1 = L"LDAP://";
                            PCWSTR  pszHeader2 = L"LDAP:///";
                            PWSTR   pszLdapUrl = new WCHAR[wcslen (pszTemp) +
                                        wcslen (pszHeader2) +   // pszHeader2 because it's the longer of the two
                                        wcslen (szCertAttr) + 2];

                            if ( pszLdapUrl )
                            {
                                PCWSTR  szCN = L"CN=";
                                //
                                // This is really not necessary. MS should make the name convention consistant.
                                //
                                // security review 2/27/2002 BryanWal ok
                                if ( !wcsncmp (pszTemp, szCN, wcslen (szCN)) )
                                {
                                    // pszTemp is object name without server
                                    wcscpy (pszLdapUrl, pszHeader2);
                                }
                                else
                                    wcscpy (pszLdapUrl, pszHeader1);
                                wcscat (pszLdapUrl, pszTemp);
                                wcscat (pszLdapUrl, szCertAttr);

                                hr = ERROR_SUCCESS;
                                HCERTSTORE hDSCertStore = ::CertOpenStore (
                                        sz_CERT_STORE_PROV_LDAP,
                                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                        NULL,
                                        CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                                        (void*) pszLdapUrl);
                                //
                                // In case delete change the result of GetLastError ()
                                //

                                hr = GetLastError ();

                                if (hDSCertStore)
                                {
                                    CERT_ENHKEY_USAGE   enhKeyUsage;

                                    // security review 2/27/2002 BryanWal ok
                                    ::ZeroMemory (&enhKeyUsage, sizeof (enhKeyUsage));
                                    enhKeyUsage.cUsageIdentifier = 1;
                                    enhKeyUsage.rgpszUsageIdentifier = new LPSTR[1];
                                    if ( enhKeyUsage.rgpszUsageIdentifier )
                                    {
                                        enhKeyUsage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;
                                        //
                                        // We get the certificate store
                                        //
                                        PCCERT_CONTEXT  pCertContext =
                                                ::CertFindCertificateInStore (
                                                    hDSCertStore,
                                                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                                    0,
                                                    CERT_FIND_ENHKEY_USAGE,
                                                    &enhKeyUsage,
                                                    NULL);
                                        if ( pCertContext )
                                        {
                                            if ( CertHasEFSKeyUsage (pCertContext) )
                                            {
                                                // check to see if cert is revoked
                                                if ( !IsCertificateRevoked (pCertContext) )
                                                {
                                                    // verify that certificate is valid
                                                    if ( 0 == CertVerifyTimeValidity (NULL, pCertContext->pCertInfo) )
                                                    {
                                                        //
                                                        // We got the certificate. Add it to the lists.
                                                        // Get the certificate display name first
                                                        //

                                                        hr = GetCertNameFromCertContext (
                                                                pCertContext,
                                                                &pszUserCertName);

                                                        //
                                                        // Add the user
                                                        //

                                                        EFS_CERTIFICATE_BLOB certBlob;

                                                        certBlob.cbData = pCertContext->cbCertEncoded;
                                                        certBlob.pbData = pCertContext->pbCertEncoded;
                                                        certBlob.dwCertEncodingType = pCertContext->dwCertEncodingType;
                                                        hr = pAddSheet->Add (
                                                                pszListUserName,
                                                                pszUserCertName,
                                                                (PVOID)&certBlob,
                                                                userSID,
                                                                USERADDED,
                                                                pCertContext);

                                                        if ( FAILED (hr) && (HRESULT_FROM_WIN32 (CRYPT_E_EXISTS) != hr) )
                                                        {
                                                            //
                                                            // Error in adding the user
                                                            //

                                                            ::CertFreeCertificateContext (pCertContext);
                                                            pCertContext = NULL;
                                                        }
                                                        else
                                                        {
                                                            //
                                                            // Add the user to the list box.
                                                            //

                                                            if ( SUCCEEDED (hr) )
                                                            {
                                                                LV_ITEM fillItem;

                                                                fillItem.mask = LVIF_TEXT;
                                                                fillItem.iItem = 0;
                                                                fillItem.iSubItem = 0;

                                                                fillItem.pszText = pszListUserName;
                                                                fillItem.iItem = m_UserAddList.InsertItem (&fillItem);

                                                                if ( fillItem.iItem == -1 )
                                                                {
                                                                    pAddSheet->Remove ( pszListUserName,  pszUserCertName);
                                                                }
                                                                else
                                                                {
                                                                    fillItem.pszText = pszUserCertName;
                                                                    fillItem.iSubItem = 1;
                                                                    m_UserAddList.SetItem (&fillItem);
                                                                }
                                                            }

                                                            //
                                                            //Either deleted (CRYPT_E_EXISTS) or should not be freed (ERROR_SUCCESS)
                                                            //

                                                            pszListUserName = NULL;
                                                            pszUserCertName = NULL;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        CString text;
                                                        CString caption;
                                                        CThemeContextActivator activator;

    
                                                        VERIFY (text.LoadString (IDS_EFS_CERT_IS_NOT_VALID));
                                                        VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                                                        MessageBox (text, caption, MB_OK);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                CString caption;
                                                CString text;
                                                CThemeContextActivator activator;

                                                VERIFY (text.LoadString (IDS_USER_OBJECT_HAS_NO_CERTS));
                                                VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                                                MessageBox (text, caption, MB_OK);
                                            }
                                        }
                                        else
                                        {
                                            CString text;
                                            CString caption;
                                            CThemeContextActivator activator;

                                            
                                            VERIFY (text.LoadString (IDS_USER_OBJECT_HAS_NO_CERTS));
                                            VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
                                            MessageBox (text, caption, MB_OK);
                                        }
                                        delete [] enhKeyUsage.rgpszUsageIdentifier;
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                    }

                                    delete [] userSID;
                                    userSID = NULL;
                                    if (pszListUserName)
                                    {
                                        delete [] pszListUserName;
                                        pszListUserName = NULL;
                                    }
                                    if (pszUserCertName)
                                    {
                                        delete [] pszUserCertName;
                                        pszUserCertName = NULL;
                                    }
                                    if ( hDSCertStore )
                                    {
                                        CertCloseStore (hDSCertStore, 0);
                                        hDSCertStore = NULL;
                                    }
                                }
                                else
                                {
                                    //
                                    // Failed to open the cert store
                                    //
                                    delete [] userSID;
                                    userSID = NULL;
                                    if (pszListUserName)
                                    {
                                        delete [] pszListUserName;
                                        pszListUserName = NULL;
                                    }
                                    if (pszUserCertName)
                                    {
                                        delete [] pszUserCertName;
                                        pszUserCertName = NULL;
                                    }
                                    CString caption;
                                    CString text;
                                    CThemeContextActivator activator;

                                    VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                                    text.FormatMessage (IDS_UNABLE_TO_OPEN_EFS_STORE, pszLdapUrl, 
                                            GetSystemMessage (hr));
                                    ::MessageBox (NULL, text, caption, MB_OK);
                                }
                                delete [] pszLdapUrl;
                                pszLdapUrl = NULL;
                            }
                            else
                            {
                                hr = ERROR_OUTOFMEMORY;
                            }

                        }
                        if ( HRESULT_FROM_WIN32 (ERROR_OUTOFMEMORY) == hr )
                        {
                            //
                            // Free the memory. Delete works for NULL. No check is needed.
                            //
                            delete [] userSID;
                            userSID = NULL;
                            delete [] pszListUserName;
                            pszListUserName = NULL;
                            delete [] pszUserCertName;
                            pszUserCertName = NULL;
                        }

                    }//For
                }

                if (bCheckDS)
                {
                    DsUnBindW ( &hDS);
                }

                ReleaseStgMedium (&medium);
            }

            pDataObject->Release ();
        }

        pCommonQuery->Release ();
    }

    return hr;
}

DWORD CAddEFSWizLocate::GetCertNameFromCertContext (
        PCCERT_CONTEXT pCertContext, PWSTR *ppwszUserCertName)
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the user name from the certificate
// Arguments:
//      pCertContext -- Cert Context
//      pszUserCertName -- User name
//                                  ( Caller is responsible to delete this memory using delete [] )
//  Return Value:
//      ERROR_SUCCESS if succeed.
//      If No Name if found. "USER_UNKNOWN is returned".
//
//////////////////////////////////////////////////////////////////////
{
    if ( !ppwszUserCertName || !pCertContext)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppwszUserCertName = NULL;

    CString szSubjectName = ::GetNameString (pCertContext, 0);
    if ( !szSubjectName.IsEmpty () )
    {
        // security review 2/27/2002 BryanWal ok
        *ppwszUserCertName = new WCHAR[wcslen (szSubjectName) + 1];
        if ( *ppwszUserCertName )
        {
            // security review 2/27/2002 BryanWal ok
            wcscpy (*ppwszUserCertName, szSubjectName);
        }
        else
            return ERROR_NOT_ENOUGH_MEMORY;
    }
    else
        return ERROR_FILE_NOT_FOUND;

    return ERROR_SUCCESS;
}

BOOL CAddEFSWizLocate::OnInitDialog ()
{
    CWizard97PropertyPage::OnInitDialog ();
    CString userNameTitle;
    CString userDNTitle;
    RECT    rcList;

    try {   
        m_UserAddList.GetClientRect (&rcList);
        DWORD   dwColWidth = (rcList.right - rcList.left)/2;
        VERIFY (userNameTitle.LoadString (IDS_USERCOLTITLE));
        VERIFY (userDNTitle.LoadString (IDS_DNCOLTITLE));
        m_UserAddList.InsertColumn (0, userNameTitle, LVCFMT_LEFT, dwColWidth);
        m_UserAddList.InsertColumn (1, userDNTitle, LVCFMT_LEFT, dwColWidth);
    }
    catch (...){
    }
    
    CAddEFSWizSheet* pAddSheet = reinterpret_cast <CAddEFSWizSheet*> (m_pWiz);
    ASSERT (pAddSheet);
    if ( pAddSheet )
    {
        if ( pAddSheet->m_bMachineIsStandAlone )
            GetDlgItem (IDC_BROWSE_DIR)->EnableWindow (FALSE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CAddEFSWizLocate::OnWizardBack ()
{
    CAddEFSWizSheet *pAddSheet = reinterpret_cast <CAddEFSWizSheet *> (m_pWiz);
    ASSERT (pAddSheet);
    if ( !pAddSheet )
        return -1;

    pAddSheet->ClearUserList ();    
    m_UserAddList.DeleteAllItems ();
    return CWizard97PropertyPage::OnWizardBack ();
}

void CAddEFSWizLocate::EnableControls ()
{
    if ( m_UserAddList.GetItemCount () <= 0 )
    {
        GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK);
    }
    else
        GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT | PSWIZB_BACK);
}

bool CAddEFSWizLocate::IsCertificateRevoked (PCCERT_CONTEXT pCertContext)
{
    ASSERT (pCertContext);
    if ( !pCertContext )
        return true;

    bool                    bIsRevoked = false;
    const DWORD             cNumCerts = 1;
    PVOID                   rgpvContext[cNumCerts] = {(PVOID)pCertContext};
    CERT_REVOCATION_PARA    crp;
    CERT_REVOCATION_STATUS  crs;

    ::ZeroMemory (&crp, sizeof (crp));
    crp.cbSize = sizeof (crp);
    ::ZeroMemory (&crs, sizeof (crs));
    crs.cbSize = sizeof (crs);
    
    BOOL bResult = ::CertVerifyRevocation (
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CERT_CONTEXT_REVOCATION_TYPE,
            cNumCerts,
            rgpvContext,
            0,                                      // dwFlags
            &crp,
            &crs);
    if ( !bResult )
    {
        DWORD   dwErr = GetLastError ();
        CString text;
        CString caption;
        CThemeContextActivator activator;


        VERIFY (caption.LoadString (IDS_ADD_RECOVERY_AGENT));
        if ( CRYPT_E_REVOKED == HRESULT_FROM_WIN32 (dwErr) )
        {
            text.FormatMessage (IDS_EFS_CERT_IS_REVOKED, GetSystemMessage (dwErr));
            MessageBox (text, caption, MB_OK);

            bIsRevoked = true;
        }
        else
        {
            text.FormatMessage (IDS_EFS_CERT_REVOCATION_NOT_VERIFIED, GetSystemMessage (GetLastError ()));
            if ( IDNO == MessageBox (text, caption, MB_YESNO) )
                bIsRevoked = true;
        }
    }
    else
        bIsRevoked = false;

    return bIsRevoked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\options.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       options.h
//
//  Contents:   CViewOptionsDlg - snapin-wide view options
//
//----------------------------------------------------------------------------
#if !defined(AFX_OPTIONS_H__191D8831_D3A8_11D1_955E_0000F803A951__INCLUDED_)
#define AFX_OPTIONS_H__191D8831_D3A8_11D1_955E_0000F803A951__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// options.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CViewOptionsDlg dialog
class CCertMgrComponentData;	// forward declaration

class CViewOptionsDlg : public CHelpDialog
{
// Construction
public:
	CViewOptionsDlg(CWnd* pParent, CCertMgrComponentData* pCompData);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CViewOptionsDlg)
	enum { IDD = IDD_VIEW_OPTIONS };
	CButton	m_showPhysicalButton;
	CButton	m_viewByStoreBtn;
	CButton	m_viewByPurposeBtn;
	BOOL	m_bShowPhysicalStores;
	BOOL	m_bShowArchivedCerts;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CViewOptionsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void DoContextHelp (HWND hWndControl);

	// Generated message map functions
	//{{AFX_MSG(CViewOptionsDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnViewByPurpose();
	afx_msg void OnViewByStore();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	CCertMgrComponentData*	m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OPTIONS_H__191D8831_D3A8_11D1_955E_0000F803A951__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\options.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998-2001.
//
//  File:       options.cpp
//
//  Contents:   CViewOptionsDlg - snapin-wide view options
//
//----------------------------------------------------------------------------
// options.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "options.h"
#include "compdata.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CViewOptionsDlg dialog


CViewOptionsDlg::CViewOptionsDlg(CWnd* pParent, CCertMgrComponentData* pCompData)
	: CHelpDialog(CViewOptionsDlg::IDD, pParent),
	m_pCompData (pCompData)
{
	ASSERT (m_pCompData);
	//{{AFX_DATA_INIT(CViewOptionsDlg)
	m_bShowPhysicalStores = FALSE;
	m_bShowArchivedCerts = FALSE;
	//}}AFX_DATA_INIT
}


void CViewOptionsDlg::DoDataExchange(CDataExchange* pDX)
{
	CHelpDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CViewOptionsDlg)
	DDX_Control(pDX, IDC_SHOW_PHYSICAL, m_showPhysicalButton);
	DDX_Control(pDX, IDC_VIEW_BY_STORE, m_viewByStoreBtn);
	DDX_Control(pDX, IDC_VIEW_BY_PURPOSE, m_viewByPurposeBtn);
	DDX_Check(pDX, IDC_SHOW_PHYSICAL, m_bShowPhysicalStores);
	DDX_Check(pDX, IDC_SHOW_ARCHIVED, m_bShowArchivedCerts);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CViewOptionsDlg, CHelpDialog)
	//{{AFX_MSG_MAP(CViewOptionsDlg)
	ON_BN_CLICKED(IDC_VIEW_BY_PURPOSE, OnViewByPurpose)
	ON_BN_CLICKED(IDC_VIEW_BY_STORE, OnViewByStore)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewOptionsDlg message handlers

BOOL CViewOptionsDlg::OnInitDialog() 
{
	CHelpDialog::OnInitDialog();
	
	if ( m_pCompData )
	{
		BOOL	bIsFileView = !m_pCompData->m_szFileName.IsEmpty ();

		if ( bIsFileView )
			m_showPhysicalButton.ShowWindow (SW_HIDE);

		m_bShowArchivedCerts = m_pCompData->m_bShowArchivedCertsPersist;
		m_bShowPhysicalStores = m_pCompData->m_bShowPhysicalStoresPersist;

		if ( IDM_STORE_VIEW == m_pCompData->m_activeViewPersist )
			m_viewByStoreBtn.SetCheck (1);
		else
		{
			m_viewByPurposeBtn.SetCheck (1);
			m_showPhysicalButton.EnableWindow (FALSE);
		}

		UpdateData (FALSE);
	}

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CViewOptionsDlg::OnOK() 
{
	UpdateData (TRUE);

	if ( m_pCompData )
	{
		m_pCompData->m_bShowArchivedCertsPersist = m_bShowArchivedCerts;
		m_pCompData->m_bShowPhysicalStoresPersist = m_bShowPhysicalStores;

		if ( m_viewByStoreBtn.GetCheck () )
			m_pCompData->m_activeViewPersist = IDM_STORE_VIEW;
		else
			m_pCompData->m_activeViewPersist = IDM_USAGE_VIEW;
	}
	CHelpDialog::OnOK();
}

void CViewOptionsDlg::OnViewByPurpose() 
{
	if ( m_viewByPurposeBtn.GetCheck () )
		m_showPhysicalButton.EnableWindow (FALSE);
	else
		m_showPhysicalButton.EnableWindow (TRUE);
}

void CViewOptionsDlg::OnViewByStore() 
{
	if ( m_viewByStoreBtn.GetCheck () )
		m_showPhysicalButton.EnableWindow (TRUE);
	else
		m_showPhysicalButton.EnableWindow (FALSE);
}

void CViewOptionsDlg::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CViewOptionsDlg::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_VIEW_BY_PURPOSE,    IDH_OPTIONS_VIEW_BY_PURPOSE,
        IDC_VIEW_BY_STORE,      IDH_OPTIONS_VIEW_BY_STORE,
        IDC_SHOW_PHYSICAL,      IDH_OPTIONS_SHOW_PHYSICAL,
        IDC_SHOW_ARCHIVED,      IDH_OPTIONS_SHOW_ARCHIVED,
        0, 0
    };


    // Display context help for a control
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_VIEW_BY_PURPOSE:
    case IDC_VIEW_BY_STORE:
    case IDC_SHOW_PHYSICAL:
    case IDC_SHOW_ARCHIVED:
    case IDOK:
    case IDCANCEL:
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CViewOptionsDlg::DoContextHelp\n");
}

void CViewOptionsDlg::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    // point is in screen coordinates
    _TRACE (1, L"Entering CViewOptionsDlg::OnContextMenu\n");

	if ( pWnd->m_hWnd == GetDlgItem (IDC_VIEW_BY_PURPOSE)->m_hWnd ||
			pWnd->m_hWnd == GetDlgItem (IDC_VIEW_BY_STORE)->m_hWnd ||
			pWnd->m_hWnd == GetDlgItem (IDC_SHOW_PHYSICAL)->m_hWnd ||
			pWnd->m_hWnd == GetDlgItem (IDC_SHOW_ARCHIVED)->m_hWnd )
	{
		CMenu bar;
		if ( bar.LoadMenu(IDR_WHATS_THIS_CONTEXT_MENU1) )
		{
			CMenu& popup = *bar.GetSubMenu (0);
			ASSERT(popup.m_hMenu);

			if ( popup.TrackPopupMenu (TPM_RIGHTBUTTON | TPM_LEFTBUTTON,
					point.x,    // in screen coordinates
					point.y,    // in screen coordinates
					this) ) // route commands through main window
			{
				m_hWndWhatsThis = 0;
				CPoint  clPoint (point);
				ScreenToClient (&clPoint);
				CWnd* pChild = ChildWindowFromPoint (
						clPoint,  // in client coordinates
						CWP_SKIPINVISIBLE | CWP_SKIPTRANSPARENT);
				if ( pChild )
				{
					// Check to see if the window returned is the group box.
					// If it is, we want to get the child windows that lie in
					// the group box, since we're 
					// not interested in the group box itself.
					CWnd* pGroup = GetDlgItem (IDC_VIEW_MODE_GROUP);
					if ( pChild->m_hWnd == pGroup->m_hWnd )
					{
						CRect   rc;

						// Try the "Certificate Purpose" control
						pChild = GetDlgItem (IDC_VIEW_BY_PURPOSE);
						if ( pChild )
						{
							pChild->GetWindowRect (&rc);
							if ( rc.PtInRect (point) )
								m_hWndWhatsThis = pChild->m_hWnd;
							else
							{
								// Try the "Logical Certificate Stores" control
								pChild = GetDlgItem (IDC_VIEW_BY_STORE);
								if ( pChild )
								{
									pChild->GetWindowRect (&rc);
									if ( rc.PtInRect (point) )
										m_hWndWhatsThis = pChild->m_hWnd;
								}
							}
						}
                    
					}
					else
						m_hWndWhatsThis = pChild->m_hWnd;
				}
			}
		}
	}

    _TRACE (-1, L"Leaving CViewOptionsDlg::OnContextMenu\n");

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\policykey.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyKey.h
//
//  Contents:   Definition of CPolicyKey
//
//----------------------------------------------------------------------------
#ifndef __POLICYKEY_H
#define __POLICYKEY_H

class CPolicyKey 
{
public:
    CPolicyKey (IGPEInformation* pGPEInformation, PCWSTR pszKey, bool fIsMachine);
    ~CPolicyKey ();

    HKEY GetKey () const;

private:
    HKEY    m_hKeyGroupPolicy;
    HKEY    m_hSubKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\persist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Persist.cpp
//
//  Contents:   Implementation of persistence
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include "compdata.h"

USE_HANDLE_MACROS("CERTMGR(persist.cpp)")


#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LPCWSTR PchGetMachineNameOverride();    // Defined in chooser.cpp

/////////////////////////////////////////////////
//  The _dwMagicword is the internal version number.
//  Increment this number if you make a file format change.
#define _dwMagicword    10001


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertMgrComponentData::Load(IStream __RPC_FAR *pIStream)
{
    _TRACE (1, L"Entering CCertMgrComponentData::Load ()\n");
    HRESULT hr = S_OK;

#ifndef DONT_PERSIST
    ASSERT (pIStream);
    XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );
    PWSTR wcszMachineName = NULL;
    PWSTR wcszServiceName = NULL;

    do  {
        // Read the magic word from the stream
        DWORD dwMagicword;
        hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
        if ( FAILED(hr) )
            break;
 
        if (dwMagicword != _dwMagicword)
        {
            // We have a version mismatch
            _TRACE (0, L"INFO: CCertMgrComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
            hr = E_FAIL;
            break;
        }

        // read m_activeViewPersist from stream
        hr = pIStream->Read (&m_activeViewPersist, 
                sizeof(m_activeViewPersist), NULL);
        if ( FAILED(hr) )
            break;

        // read m_dwLocationPersist from stream
        hr = pIStream->Read (&m_dwLocationPersist, 
                sizeof(m_dwLocationPersist), NULL);
        if ( FAILED(hr) )
            break;

        // read m_bShowPhysicalStoresPersist from stream
        hr = pIStream->Read (&m_bShowPhysicalStoresPersist, 
                sizeof(m_bShowPhysicalStoresPersist), NULL);
        if ( FAILED(hr) )
            break;

        // read m_bShowArchivedCertsPersist from stream
        hr = pIStream->Read (&m_bShowArchivedCertsPersist, 
                sizeof(m_bShowArchivedCertsPersist), NULL);
        if ( FAILED(hr) )
            break;

        // read flags from stream
        DWORD dwFlags;
        hr = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), NULL );
        if ( FAILED(hr) )
            break;

        SetPersistentFlags(dwFlags);

        // read server name from stream
        // NTRAID#NTBUG9 736602-2002/11/14-ericb AV if MSC file stores computer name
        // The stored length is bytes.
        DWORD cbLen = 0;
        hr = pIStream->Read (&cbLen, 4, NULL);
        if ( FAILED (hr) )
            break;

        ASSERT (cbLen <= MAX_PATH * sizeof (WCHAR));

        wcszMachineName = (PWSTR) LocalAlloc (LPTR, cbLen);
        if (!wcszMachineName)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = pIStream->Read ((PVOID) wcszMachineName, cbLen, NULL);
        if ( FAILED (hr) )
            break;
        
        // ensure null-termination
        // NTRAID#NTBUG9 736602-2002/11/14-ericb AV if MSC file stores computer name
        // Don't index a WCHAR array using a byte count.
        wcszMachineName[(cbLen/sizeof(WCHAR))-1] = 0;

        // Skip leading "\\", if present
        // security review 2/27/2002 BryanWal ok
        if ( !wcsncmp (wcszMachineName, L"\\\\", 2) )
            m_strMachineNamePersist = wcszMachineName + 2;
        else
            m_strMachineNamePersist = wcszMachineName;

        PCWSTR pszMachineNameT = PchGetMachineNameOverride ();
        if ( m_fAllowOverrideMachineName && pszMachineNameT )
        {
            // Allow machine name override
        }
        else
        {
            pszMachineNameT = wcszMachineName;
        }

        // Truncate leading "\\"
        // security review 2/27/2002 BryanWal ok
        if ( !wcsncmp (pszMachineNameT, L"\\\\", 2) )
            pszMachineNameT += 2;

        QueryRootCookie().SetMachineName (pszMachineNameT);

        // read service name from stream
        // NTRAID#NTBUG9 736602-2002/11/14-ericb AV if MSC file stores computer name
        // The stored length is in bytes.
        cbLen = 0;
        hr = pIStream->Read (&cbLen, 4, NULL);
        if ( FAILED (hr) )
            break;

        ASSERT (cbLen <= MAX_PATH * sizeof (WCHAR));

        wcszServiceName = (PWSTR) LocalAlloc (LPTR, cbLen);
        if (!wcszServiceName)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        hr = pIStream->Read ((PVOID) wcszServiceName, cbLen, NULL);
        if ( FAILED (hr) )
            break;

        // ensure null-termination
        // NTRAID#NTBUG9 736602-2002/11/14-ericb AV if MSC file stores computer name
        // Don't index a WCHAR array using a byte count.
        wcszServiceName[(cbLen/sizeof(WCHAR))-1] = 0;

        m_szManagedServicePersist = wcszServiceName;

        if ( !m_szManagedServicePersist.IsEmpty () )
        {
            // get the display name of this service
            DWORD   dwErr = 0;
            SC_HANDLE   hScManager = ::OpenSCManager (pszMachineNameT,
                            SERVICES_ACTIVE_DATABASE,
                            SC_MANAGER_ENUMERATE_SERVICE);
            if ( hScManager ) 
            {
                DWORD   chBuffer = 0;
                BOOL bResult = ::GetServiceDisplayName (
                        hScManager,  // handle to SCM database
                        m_szManagedServicePersist, // service name
                        NULL,  // display name
                        &chBuffer);    // size of display name buffer
                if ( !bResult )
                {
                    dwErr = GetLastError ();
                    if ( ERROR_INSUFFICIENT_BUFFER == dwErr )
                    {
                        PWSTR   pwszDisplayName = new WCHAR[++chBuffer];

                        if ( pwszDisplayName )
                        {
                            bResult = ::GetServiceDisplayName (
                                    hScManager,  // handle to SCM database
                                    m_szManagedServicePersist, // service name
                                    pwszDisplayName,  // display name
                                    &chBuffer);    // size of display name buffer
                            if ( bResult )
                                m_szManagedServiceDisplayName = pwszDisplayName;
                            else
                            {
                                dwErr = GetLastError ();
                                _TRACE (0, L"GetServiceDisplayName (%s) failed: 0x%x\n",
                                        (PCWSTR) m_szManagedServicePersist, dwErr);
                            }

                            delete [] pwszDisplayName;
                        }
                    }
                    else
                    {
                        dwErr = GetLastError ();
                        _TRACE (0, L"GetServiceDisplayName (%s) failed: 0x%x\n",
                                (PCWSTR) m_szManagedServicePersist, dwErr);
                    }
                }

                bResult = ::CloseServiceHandle (hScManager);
                ASSERT (bResult);
                if ( !bResult )
                {
                    dwErr = GetLastError ();
                    _TRACE (0, L"CloseServiceHandle () failed: 0x%x\n", dwErr);
                }
            }
            else
            {
                dwErr = GetLastError ();
                _TRACE (0, L"OpenSCManager (%s) failed: 0x%x\n", pszMachineNameT, dwErr);
            }
        }
    }
    while (0);

    if (wcszMachineName)
        LocalFree(wcszMachineName);
    if (wcszServiceName)
        LocalFree(wcszServiceName);

#endif
    _TRACE (-1, L"Leaving CCertMgrComponentData::Load (): 0x%x\n", hr);
    return hr;
}


/////////////////////////////////////////////////////////////////////
STDMETHODIMP CCertMgrComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
    _TRACE (-1, L"Entering CCertMgrComponentData::Save ()\n");
    HRESULT hr = S_OK;

#ifndef DONT_PERSIST
    ASSERT (pIStream);
    XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

    do {
        // Store the magic word to the stream
        DWORD dwMagicword = _dwMagicword;
        hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
        if ( FAILED(hr) )
            break;

        // Persist m_activeViewPersist
        hr = pIStream->Write (&m_activeViewPersist, 
                sizeof (m_activeViewPersist), NULL);
        if ( FAILED(hr) )
            break;

        // Persist m_dwLocationPersist
        hr = pIStream->Write (&m_dwLocationPersist, 
                sizeof (m_dwLocationPersist), NULL);
        if ( FAILED(hr) )
            break;

        // Persist m_bShowPhysicalStoresPersist
        hr = pIStream->Write (&m_bShowPhysicalStoresPersist, 
                sizeof (m_bShowPhysicalStoresPersist), NULL);
        if ( FAILED(hr) )
            break;

        // Persist m_bShowArchivedCertsPersist
        hr = pIStream->Write (&m_bShowArchivedCertsPersist, 
                sizeof (m_bShowArchivedCertsPersist), NULL);
        if ( FAILED(hr) )
            break;

        // persist flags
        DWORD dwFlags = GetPersistentFlags();
        hr = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
        if ( FAILED(hr) )
            break;

        // Persist machine name length and machine name
        LPCWSTR wcszMachineName = m_strMachineNamePersist;
        // security review 2/27/2002 BryanWal ok
        DWORD cbLen = (DWORD) (wcslen (wcszMachineName) + 1) * sizeof (WCHAR);
        ASSERT( 4 == sizeof(DWORD) );
        hr = pIStream->Write (&cbLen, 4, NULL);
        if ( FAILED(hr) )
            break;

        hr = pIStream->Write (wcszMachineName, cbLen, NULL);
        if ( FAILED (hr) )
            break;

        // Persist service name length and service name
        LPCWSTR wcszServiceName = m_szManagedServicePersist;
        // security review 2/27/2002 BryanWal ok
        cbLen = (DWORD) (wcslen (wcszServiceName) + 1) * sizeof (WCHAR);
        ASSERT (4 == sizeof (DWORD));
        hr = pIStream->Write (&cbLen, 4, NULL);
        if ( FAILED (hr) )
            break;

        hr = pIStream->Write (wcszServiceName, cbLen, NULL);
        if ( FAILED (hr) )
            break;
    }
    while (0);
#endif

    _TRACE (-1, L"Leaving CCertMgrComponentData::Save (): 0x%x\n", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\policyprecedencepropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       PolicyPrecedencePropertyPage.cpp
//
//  Contents:   Implementation of PolicyPrecedencePropertyPage
//
//----------------------------------------------------------------------------
// PolicyPrecedencePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "compdata.h"
#include "PolicyPrecedencePropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {
    COL_GPO_NAME = 0,
    COL_SETTING,
    NUM_COLS
};

/////////////////////////////////////////////////////////////////////////////
// CPolicyPrecedencePropertyPage property page

CPolicyPrecedencePropertyPage::CPolicyPrecedencePropertyPage(
        const CCertMgrComponentData* pCompData, 
        const CString& szRegPath,
        PCWSTR  pszValueName,
        bool bIsComputer) 
: CHelpPropertyPage(CPolicyPrecedencePropertyPage::IDD)
{
	//{{AFX_DATA_INIT(CPolicyPrecedencePropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    ASSERT (pCompData);
    if ( !pCompData )
        return;

    ASSERT (pszValueName);
    if ( !pszValueName )
        return;

    const CRSOPObjectArray* pObjectArray = bIsComputer ? 
            pCompData->GetRSOPObjectArrayComputer () : pCompData->GetRSOPObjectArrayUser ();
    int     nIndex = 0;
    // NOTE: rsop object array is sorted first by registry key, then by precedence
    INT_PTR nUpperBound = pObjectArray->GetUpperBound ();
    bool    bFound = false;
    // security review 2/22/2002 BryanWal ok
    size_t  nLenRegPath = wcslen (szRegPath);
    UINT    nLastPrecedenceFound = 0;

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
        if ( pObject )
        {
            // Consider only entries from this store
            // security review 2/22/2002 BryanWal ok
            if ( !_wcsnicmp (szRegPath, pObject->GetRegistryKey (), nLenRegPath) )
            {
                // If the value is present, check for that, too
                if ( pszValueName )
                {
                    if ( !wcscmp (STR_BLOB, pszValueName) )
                    {
                        // If not equal to "Blob" or "Blob0", then continue
                        // security review 2/22/2002 BryanWal ok
                        if ( wcscmp (STR_BLOB, pObject->GetValueName ()) &&
                                wcscmp (STR_BLOB0, pObject->GetValueName ()) )
                        {
					        nIndex++;
					        continue;
                        }
                    }
                    // security review 2/22/2002 BryanWal ok
                    else if ( wcscmp (pszValueName, pObject->GetValueName ()) ) // not equal
                    {
					    nIndex++;
					    continue;
				    }
                }

                bFound = true;
                // While we are only interested, for example, in the Root store,
                // there is no object ending in "Root", so we just want to get 
                // any object from the root store and to find, essentially, how
                // many policies we're dealing with.  So get one object from
                // each precedence level.
                if ( pObject->GetPrecedence () > nLastPrecedenceFound )
                {
                    nLastPrecedenceFound = pObject->GetPrecedence ();

					// If there is a value, we want that, otherwise we only want the key
                    if ( pszValueName || pObject->GetValueName ().IsEmpty () ) 
                    {
                        CRSOPObject* pNewObject = new CRSOPObject (*pObject);
                        if ( pNewObject )
                            m_rsopObjectArray.Add (pNewObject);
                    }
                }
            }
            else if ( bFound )
            {
                // Since the list is sorted, and we've already found the 
                // desired RSOP objects and no longer are finding them, 
                // there aren't any more.  We can optimize and break here.
                break;
            }
        }
        else
            break;

        nIndex++;
    }
}

CPolicyPrecedencePropertyPage::~CPolicyPrecedencePropertyPage()
{
    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pCurrObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pCurrObject )
        {
            delete pCurrObject;
        }
        nIndex++;
    }
    m_rsopObjectArray.RemoveAll ();
}

void CPolicyPrecedencePropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPolicyPrecedencePropertyPage)
	DDX_Control(pDX, IDC_POLICY_PRECEDENCE, m_precedenceTable);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPolicyPrecedencePropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CPolicyPrecedencePropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPolicyPrecedencePropertyPage message handlers

BOOL CPolicyPrecedencePropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
	int	colWidths[NUM_COLS] = {200, 100};

	// Add "Policy Name" column
	CString	szText;
	VERIFY (szText.LoadString (IDS_PRECEDENCE_TABLE_GPO_NAME));
	VERIFY (m_precedenceTable.InsertColumn (COL_GPO_NAME, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_GPO_NAME], COL_GPO_NAME) != -1);

	// Add "Setting" column
	VERIFY (szText.LoadString (IDS_PRECEDENCE_TABLE_SETTING));
	VERIFY (m_precedenceTable.InsertColumn (COL_SETTING, (LPCWSTR) szText,
			LVCFMT_LEFT, colWidths[COL_SETTING], COL_SETTING) != -1);
	
    // Set to full-row select
    DWORD   dwExstyle = m_precedenceTable.GetExtendedStyle ();
    m_precedenceTable.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);

    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            InsertItemInList (pObject);
        }
        else
            break;

        nIndex++;
    }


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CPolicyPrecedencePropertyPage::InsertItemInList(const CRSOPObject * pObject)
{
    _TRACE (1, L"CPolicyPrecedencePropertyPage::InsertItemInList\n");
	LV_ITEM	lvItem;
	int		iItem = m_precedenceTable.GetItemCount ();
	int iResult = 0;

    // security review 2/22/2002 BryanWal ok
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_GPO_NAME;
	lvItem.pszText = (LPWSTR)(LPCWSTR) pObject->GetPolicyName ();
	lvItem.iImage = 0;
    lvItem.lParam = 0;
	iItem = m_precedenceTable.InsertItem (&lvItem);
	ASSERT (-1 != iItem);
	if ( -1 == iItem )
		return;

    CString szEnabled;
    CString szDisabled;

    VERIFY (szEnabled.LoadString (IDS_ENABLED));
    VERIFY (szDisabled.LoadString (IDS_DISABLED));
    // security review 2/22/2002 BryanWal ok
	::ZeroMemory (&lvItem, sizeof (lvItem));
	lvItem.mask = LVIF_TEXT;
	lvItem.iItem = iItem;
    lvItem.iSubItem = COL_SETTING;
    lvItem.pszText = (LPWSTR)(LPCWSTR) ((1 == pObject->GetPrecedence ()) ? szEnabled : szDisabled);
	iResult = m_precedenceTable.SetItem (&lvItem);
	ASSERT (-1 != iResult);
	
    _TRACE (-1, L"Leaving CPolicyPrecedencePropertyPage::InsertItemInList\n");
}

void CPolicyPrecedencePropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CPolicyPrecedencePropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_POLICY_PRECEDENCE,  IDH_POLICY_PRECEDENCE,
        0, 0
    };
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_POLICY_PRECEDENCE:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CPolicyPrecedencePropertyPage::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\policyprecedencepropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       PolicyPrecedencePropertyPage.h
//
//  Contents:   Declaration of CPolicyPrecedencePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_POLICYPRECEDENCEPROPERTYPAGE_H__A28637BD_1A87_4410_9EC4_33CD9165FAD3__INCLUDED_)
#define AFX_POLICYPRECEDENCEPROPERTYPAGE_H__A28637BD_1A87_4410_9EC4_33CD9165FAD3__INCLUDED_
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PolicyPrecedencePropertyPage.h : header file
//
#include "RSOPObject.h"

/////////////////////////////////////////////////////////////////////////////
// CPolicyPrecedencePropertyPage dialog
class CCertMgrComponentData;    // forward declaration
class CCertStore;               // forward declaration

class CPolicyPrecedencePropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CPolicyPrecedencePropertyPage(
            const CCertMgrComponentData* pCompData, 
            const CString& szRegPath,
            PCWSTR  pszValueName,
            bool    bIsComputer);
	~CPolicyPrecedencePropertyPage();

// Dialog Data
	//{{AFX_DATA(CPolicyPrecedencePropertyPage)
	enum { IDD = IDD_POLICY_PRECEDENCE };
	CListCtrl	m_precedenceTable;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPolicyPrecedencePropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPolicyPrecedencePropertyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void InsertItemInList(const CRSOPObject * pObject);
    virtual void DoContextHelp (HWND hWndControl);
    
private:
    CRSOPObjectArray    m_rsopObjectArray;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_POLICYPRECEDENCEPROPERTYPAGE_H__A28637BD_1A87_4410_9EC4_33CD9165FAD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\policykey.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       PolicyKey.cpp
//
//  Contents:   Implementation of CPolicyKey
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "PolicyKey.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CPolicyKey::CPolicyKey (IGPEInformation* pGPEInformation, PCWSTR pszKey, bool fIsMachineType)
:   m_hKeyGroupPolicy (0),
    m_hSubKey (0)
{
    ASSERT (pszKey);
    if ( pGPEInformation )
    {
        HRESULT hr = pGPEInformation->GetRegistryKey (
                fIsMachineType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hKeyGroupPolicy);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            if ( pszKey && pszKey[0] )
            {
                DWORD   dwDisposition = 0;
                LONG lResult = ::RegCreateKeyEx (m_hKeyGroupPolicy, // handle of an open key
                        pszKey,     // address of subkey name
                        0,       // reserved
                        L"",       // address of class string
                        REG_OPTION_NON_VOLATILE,      // special options flag
                        // security review 2/22/2002 BryanWal ok - needed for deletion
                        KEY_ALL_ACCESS,    // desired security access
                        NULL,         // address of key security structure
                        &m_hSubKey,      // address of buffer for opened handle
                        &dwDisposition);  // address of disposition value buffer
                ASSERT (lResult == ERROR_SUCCESS);
                if ( lResult != ERROR_SUCCESS )
                {
                    _TRACE (0, L"RegCreateKeyEx (%s) failed: %d\n", pszKey, 
                            lResult);
                }
            }
        }
        else
        {
            _TRACE (0, L"IGPEInformation::GetRegistryKey (%s) failed: 0x%x\n", 
                    fIsMachineType ? 
                        L"GPO_SECTION_MACHINE" : L"GPO_SECTION_USER",
                    hr);
        }
    }
}

CPolicyKey::~CPolicyKey ()
{
    if ( m_hSubKey )
        ::RegCloseKey (m_hSubKey);

    if ( m_hKeyGroupPolicy )
        ::RegCloseKey (m_hKeyGroupPolicy);
}

HKEY CPolicyKey::GetKey () const
{
    if (m_hSubKey) 
        return m_hSubKey;
    else
    {
        return m_hKeyGroupPolicy;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by certmgr.rc
//
#define IDS_USERCOLTITLE                1
#define IDS_ADDTITLE                    3
#define IDS_CERTFILEFILTER              8
#define IDS_CERTFILEOPENERR             9
#define IDS_CERTFILEFORMATERR           10
#define IDS_UNKNOWNUSER                 11
#define IDS_DNCOLTITLE                  12
#define IDS_NOCERTNAME                  13
#define IDS_SAFER_WINDOWS_EXTENSION_REGISTRY 14
#define IDS_CERTMGR_DESC                101
#define IDD_ADD_EFS_AGENT_COMPLETION    102
#define IDD_ADD_EFS_AGENT_SELECT_USER   103
#define IDD_ADD_EFS_AGENT_WELCOME       104
#define IDR_FINDCERT_AVI                105
#define IDD_PROPPAGE_AUTOENROLL         107
#define IDS_COLUMN_ISSUER               110
#define IDS_SCOPE_SNAPIN_TITLE_MACHINE  190
#define IDS_SCOPE_SNAPIN_TITLE_SERVICE  191
#define IDS_CERT_CANNOT_BE_PASTED       192
#define IDS_SCOPE_SNAPIN_TITLE_LOCAL_MACHINE 193
#define IDS_PKP_AUTOENROLLMENT_SETTINGS 194
#define IDS_COLUMN_LOG_CERTIFICATE_STORE 195
#define IDS_SNAPINSAFERWINDOWSABOUT_DESCRIPTION 196
#define IDS_PUBLIC_KEY_POLICIES_NODE_NAME 197
#define IDD_ACR_SETUP_WELCOME           198
#define IDS_SAFER_LEVELS_NODE_NAME      198
#define IDS_SAFER_ENTRIES_NODE_NAME     199
#define IDS_COLUMN_NAME                 200
#define IDC_PERSONAL_ACCT               201
#define IDS_COLUMN_DESCRIPTION          201
#define IDC_SERVICE_ACCT                202
#define IDS_COLUMN_TYPE                 202
#define IDC_MACHINE_ACCT                203
#define IDS_COLUMN_LEVEL                203
#define IDS_COLUMN_LAST_MODIFIED_DATE   204
#define IDS_ENROLL                      205
#define IDS_NEW_PATH_RULE               206
#define IDS_RENEW_NEW_KEY               207
#define IDS_RENEW_NEW_KEY_HINT          208
#define IDS_RENEW_SAME_KEY              209
#define IDS_RENEW_SAME_KEY_HINT         210
#define IDS_REQUEST_CERT_SAME_KEY       211
#define IDS_RENEW_CERT_SAME_KEY         212
#define IDS_IMPORT                      213
#define IDS_IMPORT_HINT                 214
#define IDS_EXPORT                      215
#define IDS_EXPORT_HINT                 216
#define IDC_STORE_LIST                  216
#define IDC_CONTAINS_TEXT               217
#define IDS_NEW_AUTO_CERT_REQUEST       217
#define IDI_CERTIFICATE                 218
#define IDC_FIELD_LIST                  218
#define IDS_NEW_AUTO_CERT_REQUEST_HINT  218
#define IDS_CERTMGR_SAFER_WINDOWS_DESC  219
#define IDS_SAFER_WINDOWS_NODE_NAME     220
#define IDC_FIND_NOW                    222
#define IDS_SAFER_PATH_CONTAINS_INVALID_CHARS 222
#define IDC_STOP                        223
#define IDC_NEW_SEARCH                  224
#define IDC_RESULT_LIST                 225
#define IDS_SAFER_SET_DEFAULT           225
#define IDC_ANIMATE                     226
#define IDS_SAFER_SET_DEFAULT_HINT      226
#define IDC_VIEW_BY_PURPOSE             227
#define IDS_NEW_HASH_RULE               228
#define IDS_MS_CERT_MGR                 229
#define IDS_NEW_CERTIFICATE_RULE        231
#define IDS_COLUMN_SUBJECT              233
#define IDS_COLUMN_EXPIRATION_DATE      234
#define IDS_VIEW                        235
#define IDS_VIEW_HINT                   236
#define IDS_FIND                        237
#define IDS_FIND_HINT                   238
#define IDS_PRECEDENCE_TABLE_GPO_NAME   239
#define IDS_PRECEDENCE_TABLE_SETTING    240
#define IDS_ENROLL_NEW_CERT             241
#define IDS_ENROLL_NEW_CERT_HINT        242
#define IDS_ENABLED                     243
#define IDS_DISABLED                    244
#define IDD_PROPPAGE_CHOOSE_ACCOUNT     245
#define IDS_COLUMN_EFFECTIVE_DATE       245
#define IDD_PROPPAGE_CHOOSE_SERVICE     246
#define IDS_SCOPE_SNAPIN_TITLE_USER     246
#define IDS_CANT_SET_AS_DEFAULT         247
#define IDS_NOT_AVAILABLE               248
#define IDD_FIND                        248
#define IDS_COLUMN_FRIENDLY_NAME        249
#define IDS_COLUMN_PURPOSE              250
#define IDS_SAFER_NEW_ENTRY_PATH        251
#define IDS_SAFER_NEW_ENTRY_PATH_HINT   252
#define IDS_CERTIFICATES                253
#define IDR_FIND_DLG_MENU               253
#define IDS_ISSUED_TO                   254
#define IDB_CERTIFICATE_SMALL           254
#define IDS_ISSUED_BY                   255
#define IDB_CERTIFICATE_LARGE           255
#define IDS_SAFER_NEW_ENTRY_HASH        256
#define IDR_FIND_DLG_CONTEXT_MENU       257
#define IDS_SNAPINABOUT_DESCRIPTION     259
#define IDS_COLUMN_NEXT_UPDATE          260
#define IDS_FIND_SUBJECT_NAME           261
#define IDS_FIND_ISSUER_NAME            262
#define IDS_SAFER_NEW_ENTRY_CERTIFICATE_HINT 263
#define IDS_SAFER_NEW_ENTRY_INTERNET_ZONE 264
#define IDS_SAFER_NEW_ENTRY_INTERNET_ZONE_HINT 265
#define IDS_ALL_STORES                  266
#define IDS_SAFER_NEW_ENTRY_CERTIFICATE 267
#define IDS_FIND_CERT                   268
#define IDS_CLEAR_SEARCH                269
#define IDS_SEARCHING                   270
#define IDS_1_CERT_FOUND                271
#define IDS_NO_CERTS_FOUND              272
#define IDS_X_CERTS_FOUND               273
#define IDS_FIND_MD5_HASH               274
#define IDS_FIND_SHA1_HASH              275
#define IDI_CTL                         276
#define IDC_POLICY_PRECEDENCE           276
#define IDS_COLUMN_SOURCE_STORE         276
#define IDS_SAFER_NEW_ENTRY_HASH_HINT   277
#define IDI_CRL                         277
#define IDS_EXPORT_STORE                278
#define IDS_EXPORT_STORE_HINT           279
#define IDC_ACCT_NAME                   280
#define IDD_AUTO_CERT_REQUEST_GENERAL   280
#define IDS_CTL_EXPORT_HINT             281
#define IDC_BROWSE                      281
#define IDS_CTL_VIEW_HINT               282
#define IDC_INSTRUCTIONS                282
#define IDD_ACR_SETUP_TYPE              282
#define IDS_ANY                         283
#define IDS_NONE                        284
#define IDD_ACR_SETUP_FINAL             284
#define IDS_COLUMN_OBJECT_TYPE          285
#define IDD_GPE_GENERAL                 285
#define IDS_COLUMN_PHYS_CERTIFICATE_STORE 286
#define IDC_CERT_TYPE                   286
#define IDS_SCOPE_SNAPIN_TITLE_CERT_MGR_CURRENT_USER 287
#define IDS_CERTIFICATE_MANAGER_REGISTRY 288
#define IDC_CERT_PURPOSES               288
#define IDS_CERTIFICATE_TRUST_LISTS     290
#define IDC_CA_LIST                     290
#define IDS_EDIT                        291
#define IDS_CTL_EDIT_HINT               292
#define IDS_NEW_CTL                     293
#define IDS_NEW_CTL_HINT                294
#define IDC_CERT_TYPES                  294
#define IDS_DUPLICATE_CERT              295
#define IDC_USE_SMARTCARD               295
#define IDC_SHOW_PHYSICAL               295
#define IDS_DUPLICATE_CTL               296
#define IDC_BOLD_STATIC                 296
#define IDS_DUPLICATE_CRL               297
#define IDC_CHOICES_LIST                299
#define IDS_ENROLL_CERT_WITH_NEW_KEY    299
#define IDS_ENROLL_CERT_WITH_NEW_KEY_HINT 300
#define IDC_STATICB_BOLD                300
#define IDS_CONFIRM_DELETE_ROOT_CERT    301
#define IDS_CONFIRM_DELETE_CA_CERT      302
#define IDC_ENABLE_USER_ROOT_STORE      302
#define IDS_CONFIRM_DELETE_MY_CERT      303
#define IDC_PASSWORD1                   303
#define IDS_CONFIRM_DELETE_CTL          304
#define IDC_PASSWORD2                   304
#define IDS_CONFIRM_DELETE_CRL          305
#define IDS_SELECT_SERVICE_ON_LOCAL_MACHINE 306
#define IDS_NO_PRIVATE_KEY              307
#define IDS_WARNING_CERT_COPY_W_PRIVATE_KEY 308
#define IDC_VIEW_BY_STORE               308
#define IDS_CERTIFICATE_COPY            309
#define IDC_SHOW_ARCHIVED               309
#define IDS_DOMAIN_ROOT_CERT_AUTHS_NODE_NAME 310
#define IDS_ENCRYPTING_FILE_SYSTEM_NODE_NAME 311
#define IDS_ADD_DATA_RECOVERY_AGENT     312
#define IDS_ADD_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT 314
#define IDC_SAFER_LEVEL_DESCRIPTION     314
#define IDC_DEFINED_FILE_TYPE_EDIT      314
#define IDC_CERT_ENTRY_SUBJECT_NAME     314
#define IDC_HASH_HASHED_FILE_PATH       314
#define IDS_CREATE                      315
#define IDC_BIGBOLD                     315
#define IDS_CREATE_DOMAIN_ENCRYPTED_RECOVERY_AGENT_HINT 316
#define IDS_AUTOMATIC_CERT_REQUEST_SETTINGS_NODE_NAME 317
#define IDC_VIEW_MODE_GROUP             317
#define IDS_ENCRYPTED_RECOVERY_AGENT    320
#define IDS_ACRS_WIZARD_SHEET_CAPTION   322
#define IDS_CERTIFICATE_TYPE_COLUMN_NAME 323
#define IDS_PURPOSES_ALLOWED_COLUMN_NAME 324
#define IDS_ADD_RECOVERY_AGENT          325
#define IDS_USER_OBJECT_HAS_NO_CERTS    326
#define IDS_COLUMN_SERIAL_NUMBER        327
#define IDI_AUTO_CERT_REQUEST           328
#define IDD_PASSWORD                    329
#define IDS_MUST_SELECT_CERT_TYPE       338
#define IDS_COLUMN_AUTO_CERT_REQUEST    340
#define IDS_CONFIRM_DELETE_ACR          341
#define IDS_EFS_FILE_HAS_NO_EFS_USAGE   342
#define IDS_EXPORT_AND_DELETE_EFS_KEY   343
#define IDS_CREATE_AUTO_CERT_REQUEST    344
#define IDS_PASSWORDS_DONT_MATCH        345
#define IDS_SET_PASSWORD                346
#define IDS_CANCEL_NO_CREATE_PFX        347
#define IDS_ERROR_RETRIEVING_SELECTED_CERT_TYPE 348
#define IDS_CERTIFICATE_AUTHORITIES     354
#define IDS_ERROR_READING_ACR_PURPOSES  357
#define IDS_ERROR_READING_ACR_CERTTYPE  358
#define IDS_ACR_EDIT_HINT               361
#define IDS_CRL_VIEW_HINT               362
#define IDS_CRL_EXPORT_HINT             363
#define IDS_SMALLFONTNAME               364
#define IDS_SMALLFONTSIZE               365
#define IDS_REGISTER_CERTMGR            366
#define IDS_INSUFFICIENT_RIGHTS_TO_REGISTER_CERTMGR 367
#define IDS_ACRS_TYPE_TITLE             368
#define IDS_ACRS_TYPE_SUBTITLE          369
#define IDS_EFS_LOCATE_TITLE            372
#define IDB_ACRS_BANNER                 373
#define IDS_EFS_LOCATE_SUBTITLE         373
#define IDB_ACRS_WATERMARK              374
#define IDS_UNABLE_TO_OPEN_STORE        375
#define IDB_RECOVERY_WATERMARK          375
#define IDS_UNABLE_TO_OPEN_EFS_STORE    376
#define IDB_RECOVERY_BANNER             376
#define IDS_SAVE_PFX_FILTER             377
#define IDD_VIEW_OPTIONS                377
#define IDI_CERTMGR                     379
#define IDS_WARNING_MULTI_CERT_COPY_W_PRIVATE_KEY_MULTI 380
#define IDB_CERTMGR_SMALL               380
#define IDS_CONFIRM_DELETE_ROOT_MULTI_CERT 381
#define IDB_CERTMGR_LARGE               381
#define IDS_CONFIRM_DELETE_CA_MULTI_CERT 382
#define IDS_CONFIRM_DELETE_MY_MULTI_CERT 383
#define IDR_WHATS_THIS_CONTEXT_MENU1    383
#define IDS_CONFIRM_DELETE_MULTI        384
#define IDS_CONFIRM_DELETE_MULT_CERT_BY_PURPOSE 385
#define IDS_CERT_MGR_SCE_EXTENSION_REGISTRY 386
#define IDS_OPTIONS                     387
#define IDS_OPTIONS_HINT                388
#define IDS_CANT_SAVE_STORE             390
#define IDS_STATUS                      391
#define IDS_INIT_POLICY                 393
#define IDS_INIT_POLICY_HINT            394
#define IDS_DEL_POLICY                  395
#define IDS_DEL_POLICY_HINT             396
#define IDS_CONFIRM_DELETE_EFS_POLICY   397
#define IDS_STATUS_NO_CERTS             398
#define IDS_STATUS_ONE_CERT             399
#define IDS_STATUS_X_CERTS              400
#define IDS_STATUS_NO_CERTS_USAGE       401
#define IDS_STATUS_ONE_CERT_USAGE       402
#define IDS_STATUS_X_CERTS_USAGE        403
#define IDS_COLUMN_STATUS               404
#define IDS_CERTMGR_CHM_NOT_FOUND       405
#define IDS_STATUS_NO_AUTOENROLLMENT_OBJECTS 406
#define IDS_STATUS_ONE_AUTOENROLLMENT_OBJECT 407
#define IDS_STATUS_X_AUTOENROLLMENT_OBJECTS 408
#define IDS_STATUS_NO_CTLS              409
#define IDS_STATUS_ONE_CTL              410
#define IDS_STATUS_X_CTLS               411
#define IDS_CERT_COULD_NOT_BE_VALIDATED 412
#define IDS_UNKNOWN_CERT_FILE_TYPE      413
#define IDS_SNAPINPKPABOUT_DESCRIPTION  418
#define IDM_VIEW_LIST                   419
#define IDM_VIEW_DETAILS                420
#define IDS_CONFIRM_DELETE              421
#define ID_ENROLL_SAME_KEY              422
#define IDS_CONFIRM_DELETE_MULTIPLE     423
#define ID_FILE_RENEW_NEW_KEY           424
#define IDS_CERTIFICATE_MANAGER         425
#define ID_FILE_RENEW_SAME_KEY          426
#define IDS_CERTIFICATE_REVOCATION_LIST 427
#define ID_ENROLL_NEW_KEY               428
#define IDS_CERTIFICATE_TRUST_LIST      429
#define IDM_WHATS_THIS                  430
#define IDS_ENROLL_CERT_WITH_SAME_KEY   431
#define IDS_ENROLL_CERT_WITH_SAME_KEY_HINT 432
#define IDS_SCOPE_SNAPIN_TITLE_FILE     433
#define IDS_CANT_OPEN_STORE_AND_FAIL    435
#define IDS_CHANGE_COMPUTER             436
#define IDS_CHANGE_COMPUTER_HINT        437
#define IDS_SCOPE_SNAPIN_TITLE_SERVICE_LOCAL_MACHINE 438
#define IDS_NO_PERMISSION               439
#define IDS_CANT_ENUMERATE_SYSTEM_STORES 440
#define IDS_CANT_DELETE_CERT_FROM_SYSTEM_STORE 441
#define IDD_POLICY_PRECEDENCE           441
#define IDC_AUTOENROLL_DISABLE_ALL      441
#define IDC_TP_BY_END_USER              441
#define IDC_SET_DISABLE_LM_AUTH_FLAG    441
#define IDC_ALL_EXCEPT_LIBS             441
#define IDC_AUTOENROLL_ENABLE           442
#define IDD_SAFER_LEVEL_GENERAL         442
#define IDS_URLZONE_TRUSTED             442
#define IDC_TP_BY_LOCAL_COMPUTER_ADMIN  442
#define IDC_UNSET_DISABLE_LM_AUTH_FLAG  442
#define IDC_ALL_SOFTWARE_FILES          442
#define IDC_AUTOENROLL_ENABLE_PENDING   443
#define IDI_AUTOENROLL                  443
#define IDD_SAFER_ENTRY_PATH            443
#define IDS_URLZONE_INTERNET            443
#define IDC_TP_REV_CHECK_PUBLISHER      443
#define IDC_SAFER_LEVEL_STATUS          443
#define IDC_TURN_ON_EFS                 443
#define IDC_AUTOENROLL_ENABLE_TEMPLATE  444
#define IDI_SAFER_LEVEL                 444
#define IDD_SAFER_ENTRY_HASH            444
#define IDS_URLZONE_UNTRUSTED           444
#define IDC_TP_REV_CHECK_TIMESTAMP      444
#define IDS_URLZONE_LOCAL_MACHINE       445
#define IDI_DEFAULT_SAFER_LEVEL         445
#define IDD_SAFER_ENTRY_INTERNET_ZONE   445
#define IDD_SAFER_ENTRY_CERTIFICATE     446
#define IDS_URLZONE_INTRANET            446
#define IDI_SAFER_HASH_ENTRY            447
#define IDS_URLZONE_UNKNOWN             447
#define IDD_SAFER_DEFINED_FILE_TYPES    447
#define IDC_SAFER_LEVEL_NAME            448
#define IDI_SAFER_URL_ENTRY             448
#define IDS_CodeIdentityType_ImageName  448
#define IDD_SAFER_TRUSTED_PUBLISHER     448
#define IDI_SAFER_NAME_ENTRY            449
#define IDS_CodeIdentityType_ImageHash  449
#define IDC_TP_BY_ENTERPRISE_ADMIN      449
#define IDD_SAFER_ENFORCEMENT           449
#define IDS_CodeIdentityType_UrlZone    450
#define IDI_SETTINGS                    450
#define IDC_DEFINED_FILE_TYPES          450
#define IDD_EFS_GENERAL                 450
#define IDS_CodeIdentityType_Certificate 451
#define IDC_DELETE_DEFINED_FILE_TYPE    451
#define IDS_SAFER_TRUSTED_PUBLISHERS    452
#define IDC_ADD_DEFINED_FILE_TYPE       452
#define IDI_SAFER_CERT_ENTRY            452
#define IDS_SAFER_DEFINED_FILE_TYPES    453
#define IDC_CERT_ENTRY_BROWSE           453
#define IDI_SAFER_WINDOWS_SNAPIN        453
#define IDC_CERT_ENTRY_SECURITY_LEVEL   454
#define IDB_SAFERWINDOWS_LARGE          454
#define IDC_CERT_ENTRY_DESCRIPTION      457
#define IDS_SAFER_PATH_ENTRY_FILE_FILTER 457
#define IDC_CERT_ENTRY_LAST_MODIFIED    458
#define IDS_URLZONE_LOCAL_MACHINE_DESCRIPTION 458
#define IDC_PATH_ENTRY_PATH             459
#define IDS_URLZONE_INTRANET_DESCRIPTION 459
#define IDS_URLZONE_TRUSTED_DESCRIPTION 460
#define IDC_PATH_ENTRY_SECURITY_LEVEL   461
#define IDS_URLZONE_INTERNET_DESCRIPTION 461
#define IDS_URLZONE_UNTRUSTED_DESCRIPTION 462
#define IDS_SAFER_PATH_EMPTY            463
#define IDC_PATH_ENTRY_DESCRIPTION      465
#define IDS_CANT_DELETE_SAFER_ENTRY     465
#define IDC_PATH_ENTRY_LAST_MODIFIED    466
#define IDS_CONFIRM_DELETE_SAFER_ENTRY  466
#define IDC_HASH_ENTRY_HASHFILE_DETAILS 467
#define IDS_CONFIRM_DELETE_MULTI_SAFER_ENTRY 467
#define IDC_PATH_ENTRY_BROWSE           467
#define IDC_HASH_ENTRY_BROWSE           468
#define IDS_CANNOT_HASH_FILE            468
#define IDC_HASH_ENTRY_SECURITY_LEVEL   469
#define IDS_NO_APPLICATION_SELECTED     469
#define IDS_FILE_CANNOT_BE_READ         470
#define IDS_CANNOT_GET_FILESIZE         471
#define IDS_ERROR_SAVING_ENTRY          472
#define IDC_HASH_ENTRY_DESCRIPTION      473
#define IDS_FT_EXTENSIONS               473
#define IDC_HASH_ENTRY_LAST_MODIFIED    474
#define IDS_FT_FILE_TYPES               474
#define IDC_IZONE_ENTRY_ZONES           475
#define IDS_CONFIRM_DELETE_FILE_TYPE    475
#define IDC_IZONE_ENTRY_SECURITY_LEVEL  476
#define IDS_CONFIRM_DELETE_FILE_TYPE_MULTIPLE 476
#define IDS_FILE_TYPE_ALREADY_IN_LIST   477
#define IDS_BYTES                       478
#define IDS_KB                          479
#define IDC_IZONE_ENTRY_DESCRIPTION     480
#define IDS_IS_DEFAULT_LEVEL            480
#define IDC_IZONE_ENTRY_LAST_MODIFIED   481
#define IDS_DEFAULT_LEVEL_CHANGE_WARNING 481
#define IDC_SAFER_CERT_VIEW             482
#define IDC_SAFER_LEVEL_SET_AS_DEFAULT  483
#define IDS_SELECT_A_FOLDER             484
#define IDS_FILE_CONTAINS_NO_CERT       485
#define IDC_HASH_INSTRUCTIONS           485
#define IDS_SAFER_CERTFILEFILTER        486
#define IDC_HASH_TITLE                  486
#define IDS_HASH_STRING_INVALID_CHAR    487
#define IDS_HASH_STRING_TOO_LONG        488
#define IDS_HASH_TITLE                  489
#define IDS_NEW_URLZONE_RULE            490
#define IDC_DATE_LAST_MODIFIED_LABEL    491
#define IDS_URLZONE_TITLE               491
#define IDC_URLZONE_TITLE               492
#define IDS_PATH_TITLE                  492
#define IDC_PATH_TITLE                  493
#define IDS_CERTIFICATE_TITLE           493
#define IDC_CERTIFICATE_TITLE           494
#define IDS_HASH_INVALID_LENGTH         494
#define IDS_PULSEAUTOENROLL             495
#define IDS_PULSEAUTOENROLL_HINT        496
#define IDS_CANT_OPEN_AUTOENROLL_EVENT  497
#define IDS_CANT_SET_CONSTRAINED_AS_DEFAULT 498
#define IDS_FILE                        499
#define IDC_LEVEL_INSTRUCTIONS          501
#define IDC_UNSET_DISABLE_NT_AUTH_REQUIRED_FLAG 502
#define IDS_SAFER_ENFORCEMENT           502
#define IDC_SET_DISABLE_NT_AUTH_REQUIRED_FLAG 503
#define IDS_HASH_STRING_BAD_FORMAT      503
#define IDS_SHBROWSEFORFOLDER_TITLE     504
#define IDS_CAN_SET_SAFER_ENFORCEMENT   505
#define IDC_APPLY_TO_ALL_USERS          505
#define IDS_CANT_DELETE_OBJECT_PAGES_OPEN 506
#define IDC_APPLY_EXCEPT_ADMINS         506
#define IDS_USER_MUST_ENTER_HASH        507
#define IDC_DEFINED_FILE_TYPE_EDIT_INSTRUCTIONS 507
#define IDS_CANT_CHANGE_DEFAULT_PAGES_OPEN 508
#define IDC_DEFINED_FILE_TYPE_EDIT_LABEL 508
#define IDS_CANT_REFRESH_PAGES_OPEN     509
#define IDC_CERT_ENTRY_SUBJECT_NAME_LABEL 509
#define IDS_ZERO_BYTE_FILE_CANNOT_HASH  510
#define IDS_COLUMN_TEMPLATE_NAME        511
#define IDS_SMARTCARD_FULL_REUSE_PRIVATE_KEY 512
#define IDS_SAFER_NOT_SUPPORTED         513
#define IDS_CANNOT_SET_EFS_VALUE        514
#define IDS_FIND_CLICK_STOP_BEFORE_CLOSING 515
#define IDS_NEW_SAFER_POLICY            516
#define IDS_NEW_SAFER_POLICY_HINT       517
#define IDS_SAFER_NO_POLICY_TITLE       518
#define IDS_SAFER_NO_POLICY_TEXT        519
#define IDS_DESIGNATED_FILE_TYPES_NOT_FOUND 520
#define IDS_NO_CERT_TEMPLATES_INSTALLED 521
#define IDS_CANNOT_OPEN_CERT_STORE_TO_FIND_CERT_BY_PURPOSE 522
#define IDS_CERT_CANNOT_BE_PASTED_CANT_OPEN_STORE 523
#define IDS_DELETE_SAFER_POLICY         524
#define IDS_DELETE_SAFER_POLICY_HINT    525
#define IDS_CANT_DELETE_SAFER_POLICY    526
#define IDS_CANCEL_BECAUSE_CERT_HAS_BEEN_DELETED 527
#define IDS_CANNOT_CREATE_DATA_RECOVERY_AGENT 528
#define IDS_CANT_DELETE_SAFER_PAGES_OPEN 529
#define IDS_CONFIRM_DELETE_SAFER_POLICY 530
#define IDS_SAFER_EXTENSION_CONTAINS_INVALID_CHARS 531
#define IDS_EFS_CERT_IS_REVOKED         532
#define IDS_EFS_CERT_IS_NOT_VALID       533
#define IDS_EFS_CERT_REVOCATION_NOT_VERIFIED 534
#define IDC_BROWSE_DIR                  1003
#define IDC_BROWSE_FILE                 1004
#define IDC_ADDLIST                     1005
#define IDC_WIZARD_STATIC_BIG_BOLD1     1008
#define IDS_LARGEFONTNAME               6157
#define IDS_LARGEFONTSIZE               6158
#define IDS_EFS_NO_POLICY_TITLE         6159
#define IDS_EFS_NO_POLICY_TEXT          6160
#define IDS_EFS_NO_POLICY_TEXT_RSOP     6161
#define ID_FILE_RENEW                   32768
#define ID_FILE_EXPORT                  32769
#define ID_FILE_DELETE                  32770
#define ID_FILE_PROPERTIES              32771
#define ID_EDIT_SELECTALL               32773
#define ID_EDIT_INVERTSELECTION         32774
#define ID_VIEW_LARGEICONS              32775
#define ID_VIEW_SMALLICONS              32776
#define ID_HELP_HELPTOPICS              32779
#define IDM_PROPERTIES                  32782
#define ID_VIEW                         32786
#define IDS_CANT_ADD_CERT               32787
#define IDS_SAFER_MUST_CHOOSE_CERT      32788
#define IDS_SIGNED_FILE_HASH_FAILURE    32789

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        502
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         510
#define _APS_NEXT_SYMED_VALUE           107
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\rsopobject.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       RSOPObject.cpp
//
//  Contents:   Implementation of CRSOPObject
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <AutoEnr.h>
#include <winsafer.h>
#include <winsaferp.h>
#include <gpedit.h>
#include "RSOPObject.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CRSOPObject::CRSOPObject (
        const CString& szRegistryKey, 
        const CString& szValueName, 
        const CString& szPolicyName,
        UINT precedence, 
        COleVariant& varValue,
        const CString& szPolicyOID)
    : CObject (),
    m_szRegistryKey (szRegistryKey),
    m_szValueName (szValueName),
    m_szPolicyName (szPolicyName),
    m_precedence (precedence),
    m_vtType (0),
    m_pbyBlob (0),
    m_sizeArray (0),
    m_bstr (0),
    m_szPolicyOID (szPolicyOID)
{
    if ( szValueName.IsEmpty () )
    {
        // Do nothing, but avoid all the string comparisons
    }
    // security review 2/22/2002 BryanWal ok
    else if ( !_wcsicmp (SAFER_IDS_DESCRIPTION_REGVALUE, szValueName) ||
        !_wcsicmp (SAFER_IDS_FRIENDLYNAME_REGVALUE, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_FULLY_TRUSTED, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_NORMAL_USER, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_CONSTRAINED, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_UNTRUSTED, szValueName) ||
        !_wcsicmp (SAFER_IDS_LEVEL_DESCRIPTION_DISALLOWED, szValueName) )
    {
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        HRESULT hr = BstrFromVector(pArray, &m_bstr);
        if ( SUCCEEDED (hr) )
        {
            m_vtType = VT_BSTR;
        }
    }
    else if ( !_wcsicmp (SAFER_IDS_LASTMODIFIED_REGVALUE, szValueName) )
    {
        m_vtType = VT_ARRAY;
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        if ( pArray )
        {
            BYTE HUGEP *pByte = 0;

            // Get a pointer to the elements of the array.
            HRESULT hr = SafeArrayAccessData(pArray, (void HUGEP**)&pByte);
            if ( SUCCEEDED (hr) )
            {
                m_sizeArray = pArray->rgsabound->cElements;
                ASSERT (m_sizeArray == sizeof (FILETIME));
                if ( m_sizeArray == sizeof (FILETIME) )
                {
                    memcpy (&m_fileTime, pByte, sizeof (m_fileTime));
                }

                SafeArrayUnaccessData (pArray);
            }
        }
    }   
    else if ( !_wcsicmp (STR_BLOBCOUNT, szValueName) ||
            !_wcsicmp (STR_BLOBLENGTH, szValueName) ||
            !_wcsicmp (CERT_PROT_ROOT_FLAGS_VALUE_NAME, szValueName) ||
			!_wcsicmp (AUTO_ENROLLMENT_POLICY, szValueName) ||
            !_wcsicmp (SAFER_IDS_SAFERFLAGS_REGVALUE, szValueName) ||
            !_wcsicmp (CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, szValueName) ||
            !_wcsicmp (SAFER_TRANSPARENTENABLED_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_VALUE_NAME_HASH_SIZE, szValueName) ||
            !_wcsicmp (SAFER_VALUE_NAME_DEFAULT_LEVEL, szValueName) ||
            !_wcsicmp (EFS_SETTINGS_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_POLICY_SCOPE, szValueName) )
    {
        m_vtType = VT_I4;
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        if ( pArray )
        {
            BYTE HUGEP *pByte = 0;

            // Get a pointer to the elements of the array.
            HRESULT hr = SafeArrayAccessData(pArray, (void HUGEP**)&pByte);
            if ( SUCCEEDED(hr) )
            {
				ASSERT (pArray->rgsabound->cElements == sizeof (m_dwValue));
                if ( pArray->rgsabound->cElements == sizeof (m_dwValue) )
                {
                    // security review 2/22/2002 BryanWal ok
				    memcpy (&m_dwValue, pByte, sizeof (m_dwValue));
                }
                SafeArrayUnaccessData (pArray);
            }
        }
    }
    else if ( !wcsncmp (STR_BLOB, szValueName, wcslen (STR_BLOB)) ||
            !_wcsicmp (SAFER_IDS_ITEMDATA_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_IDS_ITEMSIZE_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_IDS_HASHALG_REGVALUE, szValueName) ||
            !_wcsicmp (SAFER_EXETYPES_REGVALUE, szValueName) )
    {
        // Blob, Blob0, Blob1, etc.
        m_vtType = VT_ARRAY;
        SAFEARRAY* pArray = (SAFEARRAY*) varValue.parray;
        if ( pArray )
        {
            BYTE HUGEP *pByte = 0;

            // Get a pointer to the elements of the array.
            HRESULT hr = SafeArrayAccessData(pArray, (void HUGEP**)&pByte);
            if ( SUCCEEDED (hr) )
            {
                m_sizeArray = pArray->rgsabound->cElements;
                m_pbyBlob = new BYTE[m_sizeArray];
                if ( m_pbyBlob )
                {
                    // security review 2/22/2002 BryanWal ok
                    memcpy (m_pbyBlob, pByte, m_sizeArray);
                }

                SafeArrayUnaccessData (pArray);
            }
        }
    }
    else if ( !_wcsicmp (CERT_EFSBLOB_VALUE_NAME, szValueName) )
    {
    }
    else
    {
        _TRACE (0, L"CRSOPObject::CRSOPObject (): Value unaccounted for: %s\n", 
                szValueName);
    }
}

CRSOPObject::CRSOPObject (const CRSOPObject& rObject)
:
    m_szRegistryKey (rObject.m_szRegistryKey),
    m_szValueName (rObject.m_szValueName),
    m_szPolicyName (rObject.m_szPolicyName),
    m_precedence (rObject.m_precedence),
    m_vtType (rObject.m_vtType),
    m_pbyBlob (0),
    m_sizeArray (rObject.m_sizeArray),
    m_bstr (0),
    m_szPolicyOID (rObject.m_szPolicyOID)
{
    ASSERT (!m_szRegistryKey.IsEmpty ());
    ASSERT (!m_szPolicyName.IsEmpty ());
    ASSERT (!m_szPolicyOID.IsEmpty ());

    if ( VT_ARRAY == m_vtType )
    {
        m_pbyBlob = new BYTE[m_sizeArray];
        if ( m_pbyBlob )
        {
            // security review 2/22/2002 BryanWal ok
            memcpy (m_pbyBlob, rObject.m_pbyBlob, m_sizeArray);
        }
    }
    else if ( VT_I4 == m_vtType )
    {
        m_dwValue = rObject.m_dwValue;
    }

    // security review 2/22/2002 BryanWal ok
    memcpy (&m_fileTime, &rObject.m_fileTime, sizeof (m_fileTime));

    if ( rObject.m_bstr )
        m_bstr = SysAllocString (rObject.m_bstr);
}

CRSOPObject::~CRSOPObject ()
{
    if ( VT_ARRAY == m_vtType && m_pbyBlob )
        delete [] m_pbyBlob;

    if ( m_bstr )
        SysFreeString (m_bstr);
}

HRESULT CRSOPObject::GetBSTR (BSTR* pBstr) const
{
    HRESULT hr = S_OK;
    if ( pBstr )
    {
        if ( m_bstr ) 
            *pBstr = SysAllocString ((PCWSTR) m_bstr);
        else
            hr = E_NOTIMPL;
    }
    else 
        hr = E_POINTER;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\rsopobject.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       RSOPObject.h
//
//  Contents:
//
//----------------------------------------------------------------------------

#ifndef __RSOPOBJECT_H_INCLUDED__
#define __RSOPOBJECT_H_INCLUDED__
#include <wbemcli.h>

class CRSOPObject : public CObject 
{
public:
    CRSOPObject (
            const CString& szRegistryKey, 
            const CString& szValueName, 
            const CString& szPolicyName,
            UINT precedence, 
            COleVariant& variant,
            const CString& szPolicyOID);
    CRSOPObject (const CRSOPObject& rObject);
    virtual ~CRSOPObject ();

    CString GetRegistryKey () const
    {
        return m_szRegistryKey;
    }

    UINT    GetPrecedence () const
    {
        return m_precedence;
    }

    CString GetValueName () const
    {
        return m_szValueName;
    }

    CString GetPolicyOID () const
    {
        return m_szPolicyOID;
    }

    BYTE*   GetBlob () const
    {
        ASSERT (VT_ARRAY == m_vtType);
        BYTE*   pByte = 0;
        if ( VT_ARRAY == m_vtType )
            pByte = m_pbyBlob;

        return pByte;
    }

    size_t GetBlobLength () const
    {
        return m_sizeArray;
    }

    DWORD GetDWORDValue () const
    {
        ASSERT (VT_I4 == m_vtType);
        if ( VT_I4 == m_vtType )
            return m_dwValue;
        else
            return 0;
    }

    CString GetPolicyName () const
    {
        return m_szPolicyName;
    }

    void GetFileTime (FILETIME& fileTime) const
    {
        // security review 2/22/2002 BryanWal ok
        memcpy (&fileTime, &m_fileTime, sizeof (fileTime));
    }

    HRESULT GetBSTR (BSTR* pBstr) const;

private:
    const CString   m_szRegistryKey;
    const CString   m_szValueName;
    const UINT      m_precedence;
    CString         m_szPolicyName;
    size_t          m_sizeArray;
    BSTR            m_bstr;
    FILETIME        m_fileTime;
    const CString   m_szPolicyOID;

public:
    CIMTYPE m_vtType;
    union {
        DWORD       m_dwValue;
        BYTE HUGEP* m_pbyBlob;
    }; 
};

typedef CTypedPtrArray<CObArray,CRSOPObject*> CRSOPObjectArray;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferenforcementpropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEnforcementPropertyPage.h
//
//  Contents:   Declaration of CSaferEnforcementPropertyPage
//
//----------------------------------------------------------------------------
// SaferEnforcementPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certmgr.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferEnforcementPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CSaferEnforcementPropertyPage property page

// The "TransparentEnforcement" flag has the following values:
//	0 = disable all transparent hooks (in CreateProcess and LoadLibrary)
//	1 = enable transparent hooks for CreateProcess
//	2 = enable transparent hooks for CreateProcess and LoadLibrary
#define SAFER_TRANSPARENT_ENFORCEMENT_DISABLE_ALL               0
#define SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS     1
#define SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL                2

CSaferEnforcementPropertyPage::CSaferEnforcementPropertyPage(
            IGPEInformation* pGPEInformation,
            CCertMgrComponentData* pCompData,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputer) 
: CHelpPropertyPage(CSaferEnforcementPropertyPage::IDD),
    m_pGPEInformation (pGPEInformation),
    m_hGroupPolicyKey (0),
    m_fIsComputerType (bIsComputer),
    m_bReadOnly (bReadOnly),
    m_rsopObjectArray (rsopObjectArray),
    m_dwEnforcement (0),
    m_bDirty (false),
    m_dwScopeFlags (0),
    m_pCompData (pCompData)
{
	//{{AFX_DATA_INIT(CSaferEnforcementPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    if ( m_pCompData )
    {
        m_pCompData->AddRef ();
        m_pCompData->IncrementOpenSaferPageCount ();
    }

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        HRESULT hr = m_pGPEInformation->GetRegistryKey (
                m_fIsComputerType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hr));
        if ( SUCCEEDED (hr) )
        {
            DWORD   cbBuffer = sizeof (DWORD);
            CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_fIsComputerType);

            SetRegistryScope (policyKey.GetKey (), bIsComputer);
            BOOL    bRVal = SaferGetPolicyInformation (
                    SAFER_SCOPEID_REGISTRY,
                    SaferPolicyEnableTransparentEnforcement,
                    cbBuffer,
                    &m_dwEnforcement,
                    &cbBuffer,
                    0);
            if ( !bRVal )
            {
                ASSERT (0);
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyEnableTransparentEnforcement) failed: %d\n",
                        dwErr);
            }

            
            bRVal = SaferGetPolicyInformation (
                    SAFER_SCOPEID_REGISTRY,
                    SaferPolicyScopeFlags,
                    cbBuffer,
                    &m_dwScopeFlags,
                    &cbBuffer,
                    0);
            if ( !bRVal )
            {
                ASSERT (0);
                DWORD   dwErr = GetLastError ();
                hr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyScopeFlags) failed: %d\n",
                        dwErr);
            }
        }
    }
    else
    {
        RSOPGetEnforcement ();
    }
}

CSaferEnforcementPropertyPage::~CSaferEnforcementPropertyPage()
{
    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
    }

    if ( m_pCompData )
    {
        m_pCompData->DecrementOpenSaferPageCount ();
        m_pCompData->Release ();
        m_pCompData = 0;
    }
}

void CSaferEnforcementPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferEnforcementPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEnforcementPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferEnforcementPropertyPage)
	ON_BN_CLICKED(IDC_ALL_EXCEPT_LIBS, OnAllExceptLibs)
	ON_BN_CLICKED(IDC_ALL_SOFTWARE_FILES, OnAllSoftwareFiles)
	ON_BN_CLICKED(IDC_APPLY_EXCEPT_ADMINS, OnApplyExceptAdmins)
	ON_BN_CLICKED(IDC_APPLY_TO_ALL_USERS, OnApplyToAllUsers)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEnforcementPropertyPage message handlers
void CSaferEnforcementPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEnforcementPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_ALL_EXCEPT_LIBS, IDH_ALL_EXCEPT_LIBS,
        IDC_ALL_SOFTWARE_FILES, IDH_ALL_SOFTWARE_FILES,
        IDC_APPLY_TO_ALL_USERS, IDH_APPLY_TO_ALL_USERS,
        IDC_APPLY_EXCEPT_ADMINS, IDH_APPLY_EXCEPT_ADMINS,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_ALL_EXCEPT_LIBS:
    case IDC_ALL_SOFTWARE_FILES:
    case IDC_APPLY_TO_ALL_USERS:
    case IDC_APPLY_EXCEPT_ADMINS:
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEnforcementPropertyPage::DoContextHelp\n");
}

void CSaferEnforcementPropertyPage::RSOPGetEnforcement()
{
    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();
    bool    bEnforcementFlagFound = false;
    bool    bScopeFlagFound = false;
    CString szKeyName = SAFER_HKLM_REGBASE;
    szKeyName += L"\\";
    szKeyName += SAFER_CODEIDS_REGSUBKEY;


    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            if ( pObject->GetRegistryKey () == szKeyName &&
                    pObject->GetValueName () == SAFER_TRANSPARENTENABLED_REGVALUE &&
                    1 == pObject->GetPrecedence ())
            {
                m_dwEnforcement = pObject->GetDWORDValue ();
                bEnforcementFlagFound = true;
            }
            else if ( pObject->GetRegistryKey () == szKeyName &&
                    pObject->GetValueName () == SAFER_POLICY_SCOPE &&
                    1 == pObject->GetPrecedence ())
            {
                m_dwScopeFlags = pObject->GetDWORDValue ();
                bScopeFlagFound = true;
            }
        }
        else
            break;

        if ( bScopeFlagFound && bEnforcementFlagFound )
            break;

        nIndex++;
    }
}

void CSaferEnforcementPropertyPage::OnAllExceptLibs() 
{
    // SetModify only if setting changed
    if ( !(m_dwEnforcement & SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS) )
    {
        SetModified ();
        m_bDirty = true;
    }
}

void CSaferEnforcementPropertyPage::OnAllSoftwareFiles() 
{
    // SetModify only if setting changed
    if ( !(m_dwEnforcement & SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL) )
    {
        SetModified ();
        m_bDirty = true;
    }
}

BOOL CSaferEnforcementPropertyPage::OnApply() 
{
    _TRACE (1, L"Entering CSaferEnforcementPropertyPage::OnApply ()\n");
    if ( m_bDirty && m_pGPEInformation)
    {
	    if ( BST_CHECKED == SendDlgItemMessage (IDC_ALL_EXCEPT_LIBS,
                BM_GETCHECK) )
        {
            m_dwEnforcement = SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS;
        }
        else if ( BST_CHECKED == SendDlgItemMessage (IDC_ALL_SOFTWARE_FILES,
                BM_GETCHECK) )
        {
            m_dwEnforcement = SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL;
        }

	    if ( BST_CHECKED == SendDlgItemMessage (IDC_APPLY_EXCEPT_ADMINS,
                BM_GETCHECK) )
        {
            m_dwScopeFlags = 1;
        }
        else if ( BST_CHECKED == SendDlgItemMessage (IDC_APPLY_TO_ALL_USERS,
                BM_GETCHECK) )
        {
            m_dwScopeFlags = 0;
        }

        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_fIsComputerType);
        SetRegistryScope (policyKey.GetKey (), m_fIsComputerType);
        DWORD   cbData = sizeof (m_dwEnforcement);
        BOOL    bRVal = SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                SaferPolicyEnableTransparentEnforcement, cbData, 
                    &m_dwEnforcement, 0);
        if ( bRVal )
        {
            cbData = sizeof (m_dwScopeFlags);
            bRVal = SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                SaferPolicyScopeFlags, cbData, 
                    &m_dwScopeFlags, 0);
            if ( bRVal )
            {
			    // TRUE means we're changing the machine policy only
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyScopeFlags, %d failed: 0x%x\n",
                        m_dwEnforcement, dwErr);
                CString text;
                CString caption;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_CAN_SET_SAFER_ENFORCEMENT, GetSystemMessage (dwErr));
                MessageBox (text, caption);

                return FALSE;
            }
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY, SaferPolicyEnableTransparentEnforcement, %d failed: 0x%x\n",
                    m_dwEnforcement, dwErr);
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_CAN_SET_SAFER_ENFORCEMENT, GetSystemMessage (dwErr));
            MessageBox (text, caption);

            return FALSE;
        }

        
        m_bDirty = false;
    }
	
    _TRACE (-1, L"Leaving CSaferEnforcementPropertyPage::OnApply ()\n");
	return CHelpPropertyPage::OnApply();
}

BOOL CSaferEnforcementPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
	switch (m_dwEnforcement)
    {
    case SAFER_TRANSPARENT_ENFORCEMENT_DISABLE_ALL:
        break;

    case SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_CREATE_PROCESS:
        SendDlgItemMessage (IDC_ALL_EXCEPT_LIBS, BM_SETCHECK, BST_CHECKED);
        break;

    case SAFER_TRANSPARENT_ENFORCEMENT_ENABLE_ALL:
        SendDlgItemMessage (IDC_ALL_SOFTWARE_FILES, BM_SETCHECK, BST_CHECKED);
        break;

    default:
        ASSERT (0);
        break;
    }
	
    if ( 1 == m_dwScopeFlags )
    {
        SendDlgItemMessage (IDC_APPLY_EXCEPT_ADMINS, BM_SETCHECK, BST_CHECKED);
    }
    else
    {
        SendDlgItemMessage (IDC_APPLY_TO_ALL_USERS, BM_SETCHECK, BST_CHECKED);
    }

    if ( m_bReadOnly )
    {
        GetDlgItem (IDC_ALL_EXCEPT_LIBS)->EnableWindow (FALSE);
        GetDlgItem (IDC_ALL_SOFTWARE_FILES)->EnableWindow (FALSE);
        GetDlgItem (IDC_APPLY_TO_ALL_USERS)->EnableWindow (FALSE);
        GetDlgItem (IDC_APPLY_EXCEPT_ADMINS)->EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CSaferEnforcementPropertyPage::OnApplyExceptAdmins() 
{
    // SetModify only if setting changed
    if ( 1 != m_dwScopeFlags )
    {
	    SetModified ();
        m_bDirty = true;
    }
}

void CSaferEnforcementPropertyPage::OnApplyToAllUsers() 
{
    // SetModify only if setting changed
    if ( 1 == m_dwScopeFlags )
    {
    	SetModified ();
        m_bDirty = true;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferdefinedfiletypespropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferDefinedFileTypesPropertyPage.h
//
//  Contents:   Declaration of CSaferDefinedFileTypesPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERDEFINEDFILETYPESPROPERTYPAGE_H__1358E7A4_DE44_4747_A5AA_38EF0C3EEE1A__INCLUDED_)
#define AFX_SAFERDEFINEDFILETYPESPROPERTYPAGE_H__1358E7A4_DE44_4747_A5AA_38EF0C3EEE1A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferDefinedFileTypesPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaferDefinedFileTypesPropertyPage dialog
class CCertMgrComponentData; // forward declaration

class CSaferDefinedFileTypesPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CString GetFileTypeDescription (PCWSTR pszExtension);
	CSaferDefinedFileTypesPropertyPage(
            IGPEInformation* pGPEInformation,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputerType,
            CCertMgrComponentData* pCompData);
	~CSaferDefinedFileTypesPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferDefinedFileTypesPropertyPage)
	enum { IDD = IDD_SAFER_DEFINED_FILE_TYPES };
	CButton	m_addButton;
	CEdit	m_fileTypeEdit;
	CListCtrl	m_definedFileTypes;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferDefinedFileTypesPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void GetRSOPDefinedFileTypes();
    void DisplayExtensions (PWSTR pszExtensions, size_t nBytes);
    HRESULT GetFileTypeIcon (PCWSTR pszExtension, int* piIcon);
	// Generated message map functions
	//{{AFX_MSG(CSaferDefinedFileTypesPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnDeleteDefinedFileType();
	afx_msg void OnAddDefinedFileType();
	afx_msg void OnItemchangedDefinedFileTypes(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChangeDefinedFileTypeEdit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);

private:
    bool ValidateExtension(const CString& szExtension);
    int  InsertItemInList(PCWSTR pszExtension);
	void GetDefinedFileTypes();

    IGPEInformation*	                m_pGPEInformation;
    HKEY                                m_hGroupPolicyKey;
    DWORD                               m_dwTrustedPublisherFlags;
    bool                                m_fIsComputerType;
    CImageList                          m_systemImageList;
    bool                                m_bSystemImageListCreated;
    const bool                          m_bReadOnly;
    CRSOPObjectArray&                   m_rsopObjectArray;
    CCertMgrComponentData*              m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERDEFINEDFILETYPESPROPERTYPAGE_H__1358E7A4_DE44_4747_A5AA_38EF0C3EEE1A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferenforcementpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEnforcementPropertyPage.h
//
//  Contents:   Declaration of CSaferEnforcementPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENFORCEMENTPROPERTYPAGE_H__92727CF5_8AC5_42E7_AAEA_1C91573D4B40__INCLUDED_)
#define AFX_SAFERENFORCEMENTPROPERTYPAGE_H__92727CF5_8AC5_42E7_AAEA_1C91573D4B40__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEnforcementPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaferEnforcementPropertyPage dialog
class CSaferEnforcementPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferEnforcementPropertyPage(
            IGPEInformation* pGPEInformation,
            CCertMgrComponentData* pCompData,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputer);
	~CSaferEnforcementPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEnforcementPropertyPage)
	enum { IDD = IDD_SAFER_ENFORCEMENT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEnforcementPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    void DoContextHelp (HWND hWndControl);
    void RSOPGetEnforcement();

	// Generated message map functions
	//{{AFX_MSG(CSaferEnforcementPropertyPage)
	afx_msg void OnAllExceptLibs();
	afx_msg void OnAllSoftwareFiles();
	virtual BOOL OnInitDialog();
	afx_msg void OnApplyExceptAdmins();
	afx_msg void OnApplyToAllUsers();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    IGPEInformation*    m_pGPEInformation;
    HKEY                m_hGroupPolicyKey;
    const bool          m_fIsComputerType;
    const bool          m_bReadOnly;
    CRSOPObjectArray&   m_rsopObjectArray;
    DWORD               m_dwEnforcement;
    bool                m_bDirty;
    DWORD               m_dwScopeFlags;
    CCertMgrComponentData* m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENFORCEMENTPROPERTYPAGE_H__92727CF5_8AC5_42E7_AAEA_1C91573D4B40__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferdefinedfiletypespropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferDefinedFileTypesPropertyPage.h
//
//  Contents:   Declaration of CSaferDefinedFileTypesPropertyPage
//
//----------------------------------------------------------------------------
// SaferDefinedFileTypesPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certmgr.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferDefinedFileTypesPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

enum {
    COL_EXTENSIONS = 0,
    COL_FILETYPES,
    NUM_COLS
};

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

const UINT MAX_EXTENSION_LENGTH = 128;

/////////////////////////////////////////////////////////////////////////////
// CSaferDefinedFileTypesPropertyPage property page

CSaferDefinedFileTypesPropertyPage::CSaferDefinedFileTypesPropertyPage(
            IGPEInformation* pGPEInformation,
            bool bReadOnly,
            CRSOPObjectArray& rsopObjectArray,
            bool bIsComputer,
            CCertMgrComponentData* pCompData) 
    : CHelpPropertyPage(CSaferDefinedFileTypesPropertyPage::IDD),
    m_pGPEInformation (pGPEInformation),
    m_hGroupPolicyKey (0),
    m_dwTrustedPublisherFlags (0),
    m_fIsComputerType (bIsComputer),
    m_bReadOnly (bReadOnly),
    m_rsopObjectArray (rsopObjectArray),
    m_pCompData (pCompData)
{
    if ( m_pCompData )
    {
        m_pCompData->AddRef ();
        m_pCompData->IncrementOpenSaferPageCount ();
    }

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        HRESULT hr = m_pGPEInformation->GetRegistryKey (
                m_fIsComputerType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
                &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hr));
    }
}

CSaferDefinedFileTypesPropertyPage::~CSaferDefinedFileTypesPropertyPage()
{
    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
    }

    m_systemImageList.Detach ();

    if ( m_pCompData )
    {
        m_pCompData->DecrementOpenSaferPageCount ();
        m_pCompData->Release ();
        m_pCompData = 0;
    }
}

void CSaferDefinedFileTypesPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CHelpPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSaferDefinedFileTypesPropertyPage)
    DDX_Control(pDX, IDC_ADD_DEFINED_FILE_TYPE, m_addButton);
    DDX_Control(pDX, IDC_DEFINED_FILE_TYPE_EDIT, m_fileTypeEdit);
    DDX_Control(pDX, IDC_DEFINED_FILE_TYPES, m_definedFileTypes);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferDefinedFileTypesPropertyPage, CHelpPropertyPage)
    //{{AFX_MSG_MAP(CSaferDefinedFileTypesPropertyPage)
    ON_BN_CLICKED(IDC_DELETE_DEFINED_FILE_TYPE, OnDeleteDefinedFileType)
    ON_BN_CLICKED(IDC_ADD_DEFINED_FILE_TYPE, OnAddDefinedFileType)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_DEFINED_FILE_TYPES, OnItemchangedDefinedFileTypes)
    ON_EN_CHANGE(IDC_DEFINED_FILE_TYPE_EDIT, OnChangeDefinedFileTypeEdit)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferDefinedFileTypesPropertyPage message handlers
void CSaferDefinedFileTypesPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CAutoenrollmentPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_DEFINED_FILE_TYPES, IDH_DEFINED_FILE_TYPES,
        IDC_DELETE_DEFINED_FILE_TYPE, IDH_DELETE_DEFINED_FILE_TYPE,
        IDC_DEFINED_FILE_TYPE_EDIT, IDH_DEFINED_FILE_TYPE_EDIT,
        IDC_ADD_DEFINED_FILE_TYPE, IDH_ADD_DEFINED_FILE_TYPE,
        0, 0
    };
    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_DEFINED_FILE_TYPES:
    case IDC_DELETE_DEFINED_FILE_TYPE:
    case IDC_DEFINED_FILE_TYPE_EDIT:
    case IDC_ADD_DEFINED_FILE_TYPE:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CAutoenrollmentPropertyPage::DoContextHelp\n");
}


BOOL CSaferDefinedFileTypesPropertyPage::OnApply() 
{
    BOOL bRVal = TRUE;

    if ( m_definedFileTypes.m_hWnd && m_pGPEInformation )
    {
        int nCharacters = 0;
        int nCnt = m_definedFileTypes.GetItemCount ();
        
        if ( nCnt > 0 )
        {
            // iterate through and count the desired lengths
            while (--nCnt >= 0)
            {
                CString szText = m_definedFileTypes.GetItemText (nCnt, COL_EXTENSIONS);
                size_t  cchText = wcslen (szText);
                ASSERT (cchText <= MAX_EXTENSION_LENGTH);
                if ( cchText <= MAX_EXTENSION_LENGTH )
                    nCharacters += szText.GetLength () + 1;
            }

            PWSTR   pszItems = (PWSTR) ::LocalAlloc (LPTR, nCharacters * sizeof (WCHAR));
            if ( pszItems )
            {
                PWSTR   pszPtr = pszItems;
                nCnt = m_definedFileTypes.GetItemCount ();

                while (--nCnt >= 0)
                {
                    CString szText = m_definedFileTypes.GetItemText (nCnt, COL_EXTENSIONS);
                    // security review 2/22/2002 BryanWal ok
                    size_t  cchText = wcslen (szText);
                    ASSERT (cchText <= MAX_EXTENSION_LENGTH);
                    if ( cchText <= MAX_EXTENSION_LENGTH )
                    {
                        wcscpy (pszPtr, szText);
                        pszPtr += szText.GetLength () + 1;
                    }
                }

                HRESULT hr = SaferSetDefinedFileTypes (m_hWnd, m_hGroupPolicyKey,
                            pszItems, nCharacters * sizeof (WCHAR));
                if ( SUCCEEDED (hr) )
                {
                    // TRUE means we're changing the machine policy only
                    m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                            TRUE, &g_guidExtension, &g_guidSnapin);
                    m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                            TRUE, &g_guidRegExt, &g_guidSnapin);
                }
                else
                    bRVal = FALSE;
                ::LocalFree (pszItems);
            }
        }
        else
        {
            HRESULT hr = SaferSetDefinedFileTypes (m_hWnd, m_hGroupPolicyKey, 0, 0);
            if ( FAILED (hr) )
                bRVal = FALSE;
        }
        
        GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
    }

    if ( bRVal )
    {
        return CHelpPropertyPage::OnApply();
    }
    else
        return FALSE;
}

BOOL CSaferDefinedFileTypesPropertyPage::OnInitDialog() 
{
    CHelpPropertyPage::OnInitDialog();
    

    int colWidths[NUM_COLS] = {100, 200};

    SHFILEINFO sfi;
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&sfi, sizeof(sfi));
    HIMAGELIST hil = reinterpret_cast<HIMAGELIST> (
        SHGetFileInfo (
            L"C:\\", 
            0, 
            &sfi, 
            sizeof(sfi), 
            SHGFI_SYSICONINDEX | SHGFI_SMALLICON)
    );
    ASSERT (hil);
    if (hil)
    {
        m_systemImageList.Attach (hil);
        m_definedFileTypes.SetImageList (&m_systemImageList, LVSIL_SMALL);
    }

    // Add "Extensions" column
    CString szText;
    VERIFY (szText.LoadString (IDS_FT_EXTENSIONS));
    VERIFY (m_definedFileTypes.InsertColumn (COL_EXTENSIONS, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_EXTENSIONS], COL_EXTENSIONS) != -1);

    // Add "File Types" column
    VERIFY (szText.LoadString (IDS_FT_FILE_TYPES));
    VERIFY (m_definedFileTypes.InsertColumn (COL_FILETYPES, (LPCWSTR) szText,
            LVCFMT_LEFT, colWidths[COL_FILETYPES], COL_FILETYPES) != -1);
    m_definedFileTypes.SetColumnWidth (COL_FILETYPES, LVSCW_AUTOSIZE_USEHEADER);

    // Set to full-row select
    DWORD   dwExstyle = m_definedFileTypes.GetExtendedStyle ();
    m_definedFileTypes.SetExtendedStyle (dwExstyle | LVS_EX_FULLROWSELECT);

    if ( m_pGPEInformation && m_hGroupPolicyKey )
        GetDefinedFileTypes ();
    else
        GetRSOPDefinedFileTypes ();

    GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
    GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (FALSE);

    if ( m_bReadOnly )
    {
        m_fileTypeEdit.EnableWindow (FALSE); 
        GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
        GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
        GetDlgItem (IDC_DEFINED_FILE_TYPE_EDIT_INSTRUCTIONS)->EnableWindow (FALSE);
        GetDlgItem (IDC_DEFINED_FILE_TYPE_EDIT_LABEL)->EnableWindow (FALSE);
    }

    m_fileTypeEdit.SetLimitText (MAX_EXTENSION_LENGTH);  // limit in BYTES

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CSaferDefinedFileTypesPropertyPage::DisplayExtensions (PWSTR pszExtensions, size_t nBytes)
{
    if ( pszExtensions )
    {
        size_t  bytesRead = 0;

        while (bytesRead < nBytes)
        {
            // security review 2/22/2002 BryanWal ok
            size_t nLen = wcslen (pszExtensions) + 1;
            if ( nLen > 1 && (nLen - 1) <= MAX_EXTENSION_LENGTH )
            {
                InsertItemInList (pszExtensions);
                pszExtensions += nLen;
                bytesRead += nLen * sizeof (WCHAR);
            }
            else
                break;  // was last one
        }
    }
}

void CSaferDefinedFileTypesPropertyPage::GetRSOPDefinedFileTypes()
{
    int     nIndex = 0;
    INT_PTR nUpperBound = m_rsopObjectArray.GetUpperBound ();

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            if ( pObject->GetRegistryKey () == SAFER_COMPUTER_CODEIDS_REGKEY &&
                    pObject->GetValueName () == SAFER_EXETYPES_REGVALUE &&
                    1 == pObject->GetPrecedence () )
            {
                DisplayExtensions ((PWSTR) pObject->GetBlob (), pObject->GetBlobLength ());
                // NTRAID# 465064 SAFER:  Designated File Types contains 
                // information from all GPOs but is still displayed in RSOP.
                break;
            }
        }
        else
            break;

        nIndex++;
    }
}

void CSaferDefinedFileTypesPropertyPage::GetDefinedFileTypes()
{
    DWORD   dwDisposition = 0;

    HKEY    hKey = 0;
    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            SAFER_COMPUTER_CODEIDS_REGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            // security review 2/22/2002 BryanWal ok
            KEY_QUERY_VALUE,    // desired security access
            NULL,     // address of key security structure
            &hKey,      // address of buffer for opened handle
            &dwDisposition);  // address of disposition value buffer
    ASSERT (ERROR_SUCCESS == lResult);
    if ( ERROR_SUCCESS == lResult )
    {

        // Read value
        DWORD   dwType = REG_MULTI_SZ;
        DWORD   cbData = 0;
        // security review 2/22/2002 BryanWal ok
        lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
                SAFER_EXETYPES_REGVALUE,  // address of name of value to query
                0,              // reserved
                &dwType,        // address of buffer for value type
                0,       // address of data buffer
                &cbData);           // address of data buffer size);

        if ( ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType )
        {
            PBYTE   pData = (PBYTE) ::LocalAlloc (LPTR, cbData);
            if ( pData )
            {
                // security review 2/22/2002 BryanWal ok
                lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
                        SAFER_EXETYPES_REGVALUE,  // address of name of value to query
                        0,              // reserved
                    &dwType,        // address of buffer for value type
                    pData,       // address of data buffer
                    &cbData);           // address of data buffer size);
                ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
                if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
                {
                    DisplayExtensions ((PWSTR) pData, cbData);
                }
                else
                    DisplaySystemError (m_hWnd, lResult);

                ::LocalFree (pData);
            }
        }
        else 
        {
            CString caption;
            CString text;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_DESIGNATED_FILE_TYPES_NOT_FOUND, 
                    GetSystemMessage (lResult));
            MessageBox (text, caption, MB_OK);
        }

        RegCloseKey (hKey);
    }
    else
        DisplaySystemError (m_hWnd, lResult);
}

int CSaferDefinedFileTypesPropertyPage::InsertItemInList(PCWSTR pszExtension)
{
    _TRACE (1, L"CSaferDefinedFileTypesPropertyPage::InsertItemInList\n");
    ASSERT (pszExtension);
    if ( !pszExtension )
        return -1;

    int nCnt = m_definedFileTypes.GetItemCount ();
    while (--nCnt >= 0)
    {
        CString szText = m_definedFileTypes.GetItemText (nCnt, COL_EXTENSIONS);
        // security review 2/22/2002 BryanWal ok
        if ( !_wcsicmp (szText, pszExtension) )
        {
            if ( m_pGPEInformation )  
            {
                // is not RSOP.  If RSOP, multiple entries might be added
                // because we're getting the stuff from different policies
                // We don't want a message in that case, we'll just ignore
                // the duplication.
                CString caption;
                CString text;
                CThemeContextActivator activator;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_FILE_TYPE_ALREADY_IN_LIST, pszExtension);
                MessageBox (text, caption, MB_OK);
            }

            return -1;
        }
    }

    LV_ITEM lvItem;
    int     iItem = m_definedFileTypes.GetItemCount ();
    int     iResult = 0;
    int     iIcon = 0;

    if ( SUCCEEDED (GetFileTypeIcon (pszExtension, &iIcon)) )
    {
        // security review 2/22/2002 BryanWal ok
        ::ZeroMemory (&lvItem, sizeof (lvItem));
        lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
        lvItem.iItem = iItem;
        lvItem.iSubItem = COL_EXTENSIONS;
        lvItem.pszText = const_cast <PWSTR> (pszExtension);
        lvItem.iImage = iIcon;
        lvItem.lParam = 0;
        iItem = m_definedFileTypes.InsertItem (&lvItem);
        ASSERT (-1 != iItem);
        if ( -1 != iItem )
        {
            CString szDescription = GetFileTypeDescription (pszExtension);
            // security review 2/22/2002 BryanWal ok
            ::ZeroMemory (&lvItem, sizeof (lvItem));
            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = iItem;
            lvItem.iSubItem = COL_FILETYPES;
            lvItem.pszText = const_cast <PWSTR> ((PCWSTR) szDescription);
            iResult = m_definedFileTypes.SetItem (&lvItem);
            ASSERT (-1 != iResult);
        }
    }
    else
        iItem = -1;

    _TRACE (-1, L"Leaving CSaferDefinedFileTypesPropertyPage::InsertItemInList\n");
    return iItem;
}

///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetFileTypeIcon
//  Purpose:    Return the file icon belonging to the specified extension
//  Inputs:     pszExtension - contains the extension, without a leading period
//  Outputs:    piIcon - the offset into the system image list containing the 
//              file type icon
//  Return:     S_OK if success, error code on failure
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CSaferDefinedFileTypesPropertyPage::GetFileTypeIcon (PCWSTR pszExtension, int* piIcon)
{
    HRESULT     hr = S_OK;
    SHFILEINFO  sfi;

    ASSERT (pszExtension);
    if ( !pszExtension )
        return E_POINTER;

    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&sfi, sizeof (sfi));
   
    CString     szExtension (L".");
    szExtension += pszExtension;

    if ( 0 != SHGetFileInfo (
            szExtension, 
            FILE_ATTRIBUTE_NORMAL,
            &sfi, 
            sizeof (SHFILEINFO), 
            SHGFI_USEFILEATTRIBUTES | SHGFI_SMALLICON | SHGFI_ICON) )
    {
        *piIcon = sfi.iIcon;
        DestroyIcon(sfi.hIcon);                
    }
    else
        hr = E_FAIL;

    return hr;
}

void CSaferDefinedFileTypesPropertyPage::OnDeleteDefinedFileType() 
{
    if ( m_definedFileTypes.m_hWnd )
    {
        int             nCnt = m_definedFileTypes.GetItemCount ();
        ASSERT (nCnt >= 1);
        CString         text;
        CString         caption;
        int             nSelCnt = m_definedFileTypes.GetSelectedCount ();
        ASSERT (nSelCnt >= 1);

        VERIFY (text.LoadString (1 == nSelCnt ? IDS_CONFIRM_DELETE_FILE_TYPE : 
                IDS_CONFIRM_DELETE_FILE_TYPE_MULTIPLE));
        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));

        CThemeContextActivator activator;
        if ( MessageBox (text, caption, MB_ICONWARNING | MB_YESNO) == IDYES )
        {
            UINT    flag = 0;
            while (--nCnt >= 0)
            {
                flag = ListView_GetItemState (m_definedFileTypes.m_hWnd, nCnt, LVIS_SELECTED);
                if ( flag & LVNI_SELECTED )
                {
                    m_definedFileTypes.DeleteItem (nCnt);
                }
            }
            GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
            GetDlgItem (IDC_DEFINED_FILE_TYPE_EDIT)->SetFocus ();
        }
    }

    SetModified ();
}

void CSaferDefinedFileTypesPropertyPage::OnAddDefinedFileType() 
{
    _TRACE (1, L"Entering CSaferDefinedFileTypesPropertyPage::OnAddDefinedFileType ()\n");
    CString szExtension;

    // Get text, strip off leading "." and whitespace, if present, add to list control, clear text field
    m_fileTypeEdit.GetWindowText (szExtension);
    szExtension.TrimLeft ();
    PWSTR   pszExtension = szExtension.GetBuffer (szExtension.GetLength ());

    if ( pszExtension[0] == L'.' )
    {
        CString szDotlessExtension = ++pszExtension;
        szExtension = szDotlessExtension;
    }

    szExtension.ReleaseBuffer ();


    // strip off trailing whitespace
    szExtension.TrimRight ();

    if ( ValidateExtension (szExtension) )
    {
        // security review 2/22/2002 BryanWal ok
        size_t  cchExtension = wcslen (szExtension);
        if ( cchExtension > 0 && cchExtension <= MAX_EXTENSION_LENGTH )
        {
            int nItem = InsertItemInList (szExtension);
            if ( -1 != nItem )
            {
                VERIFY (m_definedFileTypes.EnsureVisible (nItem, FALSE));
            }
            SetModified ();
        }


        m_fileTypeEdit.SetWindowText (L"");
        GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (FALSE);
        GetDlgItem (IDC_DEFINED_FILE_TYPE_EDIT)->SetFocus ();

        // Bug 265587 Safer Windows:  Add button on Designated File Types 
        // properties should be the default button when it is enabled.
        //
        // Set the OK button as the default push button
        //
        GetParent()->SendMessage(DM_SETDEFID, IDOK, 0);

        //
        // Force the Add button to redraw itself
        //
        m_addButton.SendMessage(BM_SETSTYLE,
                    BS_DEFPUSHBUTTON,
                    MAKELPARAM(TRUE, 0));
                   
        //
        // Force the previous default button to redraw itself
        //
        m_addButton.SendMessage (BM_SETSTYLE,
                   BS_PUSHBUTTON,
                   MAKELPARAM(TRUE, 0));    
    }

    _TRACE (-1, L"Leaving CSaferDefinedFileTypesPropertyPage::OnAddDefinedFileType ()\n");
}

void CSaferDefinedFileTypesPropertyPage::OnItemchangedDefinedFileTypes(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
    // NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    
    if ( !m_bReadOnly )
    {
        UINT    nSelCnt = m_definedFileTypes.GetSelectedCount ();
        GetDlgItem (IDC_DELETE_DEFINED_FILE_TYPE)->EnableWindow (nSelCnt > 0);
    }
    
    *pResult = 0;
}

void CSaferDefinedFileTypesPropertyPage::OnChangeDefinedFileTypeEdit() 
{
    CString szText;

    m_fileTypeEdit.GetWindowText (szText);
    PWSTR   pszText = szText.GetBuffer (szText.GetLength ());

    while ( iswspace (pszText[0]) )
        pszText++;
    if ( pszText[0] == L'.' )
        pszText++;
    

    GetDlgItem (IDC_ADD_DEFINED_FILE_TYPE)->EnableWindow (0 != pszText[0]); // is not empty

    if ( 0 != pszText[0] )
    {
        // Bug 265587 Safer Windows:  Add button on Designated File Types 
        // properties should be the default button when it is enabled.
        //
        // Set the add button as the default push button
        //
        GetParent()->SendMessage(DM_SETDEFID, (WPARAM)m_addButton.GetDlgCtrlID(), 0);

        //
        // Force the Add button to redraw itself
        //
        m_addButton.SendMessage(BM_SETSTYLE,
                    BS_DEFPUSHBUTTON,
                    MAKELPARAM(TRUE, 0));
                       
        //
        // Force the previous default button to redraw itself
        //
        ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                           IDOK,
                           BM_SETSTYLE,
                           BS_PUSHBUTTON,
                           MAKELPARAM(TRUE, 0));    

        ::SendDlgItemMessage(GetParent()->GetSafeHwnd(),
                           IDCANCEL,
                           BM_SETSTYLE,
                           BS_PUSHBUTTON,
                           MAKELPARAM(TRUE, 0));    
    }

    szText.ReleaseBuffer ();
}


///////////////////////////////////////////////////////////////////////////////
//
//  Method:     GetFileTypeDescription
//  Purpose:    Return the file type description belonging to the specified
//              extension
//  Inputs:     pszExtension - contains the extension, without a leading period
//  Return:     the file type
//
///////////////////////////////////////////////////////////////////////////////
CString CSaferDefinedFileTypesPropertyPage::GetFileTypeDescription(PCWSTR pszExtension)
{
    ASSERT (pszExtension);
    if ( !pszExtension )
        return L"";

    CString     strFPath (L".");
    strFPath += pszExtension;
    SHFILEINFO  sfi;
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&sfi, sizeof(sfi));

    DWORD_PTR   dwRet = SHGetFileInfo (
        strFPath, 
        FILE_ATTRIBUTE_NORMAL, 
        &sfi, 
        sizeof(sfi), 
        SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME);
    if ( !dwRet )
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"SHGetFileInfo (%s) failed: %d\n", dwErr);
        return L"";
    }

    CString szBuf = sfi.szTypeName;
    if ( szBuf.IsEmpty () )
    {
        szBuf = pszExtension;
        szBuf += L" ";

        CString szText;
        VERIFY (szText.LoadString (IDS_FILE));
        szBuf += szText;
    }

    return szBuf;
}

bool CSaferDefinedFileTypesPropertyPage::ValidateExtension(const CString& szExtension)
{
    bool    bRVal = true;

    PCWSTR szInvalidCharSet = ILLEGAL_FAT_CHARS; 


    if ( -1 != szExtension.FindOneOf (szInvalidCharSet) )
    {
        bRVal = false;
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        CString charsWithSpaces;

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        text.FormatMessage (IDS_SAFER_EXTENSION_CONTAINS_INVALID_CHARS, charsWithSpaces);

        CThemeContextActivator activator;
        MessageBox (text, caption, MB_OK);
        m_fileTypeEdit.SetFocus ();
    }

    return bRVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentry.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntry.cpp
//
//  Contents:   Implementation of CSaferEntry
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "SaferEntry.h"
#include "PolicyKey.h"
#include "SaferLevel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HKEY g_hkeyLastSaferRegistryScope;
const DWORD AUTHZ_UNKNOWN_LEVEL = 0xFFFFFFFF;
extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;
extern PCWSTR pcszNEWLINE;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaferEntry::CSaferEntry (
        SAFER_ENTRY_TYPE saferEntryType,
        bool bIsMachine, 
        PCWSTR pszMachineName, 
        PCWSTR pszObjectName, 
        PSAFER_IDENTIFICATION_HEADER pAuthzInfo,
        DWORD   dwLevelID,
        IGPEInformation* pGPEInformation,
        CCertificate* pCertificate,
        CSaferEntries* pSaferEntries,
        CRSOPObjectArray& rRSOPArray,
        PCWSTR pszRSOPRegistryKey)
: CCertMgrCookie (bIsMachine ? CERTMGR_SAFER_COMPUTER_ENTRY : CERTMGR_SAFER_USER_ENTRY, 
        pszMachineName, pszObjectName),
    m_pAuthzInfo (pAuthzInfo),
    m_dwLevelID (dwLevelID),
    m_dwOriginalLevelID (dwLevelID),
    m_pCertificate (pCertificate),
    m_pSaferEntries (pSaferEntries),
    m_pGPEInformation (pGPEInformation),
    m_saferEntryType (saferEntryType),
    m_dwFlags (0),
    m_bDeleted (false),
    m_cbFileHash (0),
    m_UrlZoneId (0),
    m_szRSOPRegistryKey (pszRSOPRegistryKey),
    m_hashAlgid (0),
    m_bIsComputer (bIsMachine)
{
    // security review 2/22/2002 BryanWal ok
    ::ZeroMemory (&m_nHashFileSize, sizeof (m_nHashFileSize));
    ::SecureZeroMemory (m_rgbFileHash, sizeof (m_rgbFileHash));

    m_szDisplayName = pszObjectName;

    if ( m_pCertificate )
        m_pCertificate->AddRef ();

    if ( m_pSaferEntries )
        m_pSaferEntries->AddRef ();

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();

        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                bIsMachine);

        if ( AUTHZ_UNKNOWN_LEVEL == m_dwLevelID )
        {
            // Bug 264556	Set better Security level defaults for new Safer rules
            m_dwLevelID = CSaferLevel::ReturnDefaultLevel (
                m_pGPEInformation, 
                m_bIsComputer, 
                rRSOPArray);
            if ( SAFER_LEVELID_FULLYTRUSTED == m_dwLevelID )
                m_dwLevelID = SAFER_LEVELID_DISALLOWED;
            else
                m_dwLevelID = SAFER_LEVELID_FULLYTRUSTED;
        }
        m_szLevelFriendlyName = SaferGetLevelFriendlyName (m_dwLevelID, 
                policyKey.GetKey (), m_bIsComputer); 
    }
    else
    {
        m_szLevelFriendlyName = SaferGetLevelFriendlyName (m_dwLevelID, 0, 
                m_bIsComputer);
    }

    if ( SAFER_ENTRY_TYPE_URLZONE == m_saferEntryType )
    {
        if ( m_pAuthzInfo )
        {
            ASSERT (SaferIdentityTypeUrlZone == m_pAuthzInfo->dwIdentificationType);
            PSAFER_URLZONE_IDENTIFICATION pURLEntry = 
                    reinterpret_cast <PSAFER_URLZONE_IDENTIFICATION> (m_pAuthzInfo);
            ASSERT (pURLEntry->header.cbStructSize == 
                    sizeof (SAFER_URLZONE_IDENTIFICATION));
            m_UrlZoneId = pURLEntry->UrlZoneId;
        }
        else
        {
            // This is a new entry
            m_UrlZoneId = URLZONE_TRUSTED;
        }
    }
}


CSaferEntry::~CSaferEntry()
{
    if ( m_pAuthzInfo )
        LocalFree (m_pAuthzInfo);
    if ( m_pCertificate )
        m_pCertificate->Release ();
    if ( m_pSaferEntries )
        m_pSaferEntries->Release ();
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}


CString CSaferEntry::GetDescription()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString     szDescription;

    if ( SAFER_ENTRY_TYPE_URLZONE == m_saferEntryType )
    {
        switch (m_UrlZoneId)
        {
            case URLZONE_LOCAL_MACHINE:
                VERIFY (szDescription.LoadString (IDS_URLZONE_LOCAL_MACHINE_DESCRIPTION));
                break;

            case URLZONE_INTRANET:
                VERIFY (szDescription.LoadString (IDS_URLZONE_INTRANET_DESCRIPTION));
                break;

            case URLZONE_TRUSTED:
                VERIFY (szDescription.LoadString (IDS_URLZONE_TRUSTED_DESCRIPTION));
                break;

            case URLZONE_INTERNET:
                VERIFY (szDescription.LoadString (IDS_URLZONE_INTERNET_DESCRIPTION));
                break;

            case URLZONE_UNTRUSTED:
                VERIFY (szDescription.LoadString (IDS_URLZONE_UNTRUSTED_DESCRIPTION));
                break;

            default:
                ASSERT (0);
                break;
        }
    }
    else if ( m_pAuthzInfo )
    {
        switch (m_pAuthzInfo->dwIdentificationType)
        {
        case SaferIdentityTypeImageName:
            {
                PSAFER_PATHNAME_IDENTIFICATION    pNameEntry = 
                        (PSAFER_PATHNAME_IDENTIFICATION) m_pAuthzInfo;
                ASSERT (pNameEntry->header.cbStructSize >= 
                        sizeof (SAFER_PATHNAME_IDENTIFICATION));
                szDescription = pNameEntry->Description;
            }
            break;

        case SaferIdentityTypeImageHash:
            {
                PSAFER_HASH_IDENTIFICATION pHashEntry = 
                        (PSAFER_HASH_IDENTIFICATION) m_pAuthzInfo;
                ASSERT (pHashEntry->header.cbStructSize == 
                        sizeof (SAFER_HASH_IDENTIFICATION));
                szDescription = pHashEntry->Description;
            }
            break;

        case SaferIdentityTypeUrlZone:
            ASSERT (0);
            break;

        default:
            ASSERT (0);
            break;
        }
    }
    else if ( m_pCertificate )
    {
        // Is certificate
        szDescription = m_pCertificate->GetDescription ();
    }

    m_szDescription = szDescription;
    return szDescription;
}

SAFER_ENTRY_TYPE CSaferEntry::GetType () const
{
    return m_saferEntryType;
}


CString CSaferEntry::GetTypeString() const
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CString szType;
    switch (m_saferEntryType)
    {
    case SAFER_ENTRY_TYPE_PATH:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_ImageName));
        break;

    case SAFER_ENTRY_TYPE_HASH:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_ImageHash));
        break;

    case SAFER_ENTRY_TYPE_URLZONE:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_UrlZone));
        break;

    case SAFER_ENTRY_TYPE_CERT:
        VERIFY (szType.LoadString (IDS_CodeIdentityType_Certificate));
        break;

    default:
        ASSERT (0);
        break;
    }

    return szType;
}

CString CSaferEntry::GetLevelFriendlyName() const
{
    return m_szLevelFriendlyName;
}

CString CSaferEntry::GetShortLastModified() const
{
    CString     szDate;

    if ( m_pAuthzInfo )
    {
        VERIFY (SUCCEEDED (FormatDate (m_pAuthzInfo->lastModified, szDate, DATE_SHORTDATE, true)) );
    }
    else if ( m_pCertificate )
    {
        szDate = m_pCertificate->GetShortLastModified ();
    }

    return szDate;
}

CString CSaferEntry::GetLongLastModified() const
{
    CString     szDate;

    if ( m_pAuthzInfo )
    {
        VERIFY (SUCCEEDED (FormatDate (m_pAuthzInfo->lastModified, szDate, DATE_LONGDATE, true)) );
    }
    else if ( m_pCertificate )
    {
        szDate = m_pCertificate->GetLongLastModified ();
    }

    return szDate;
}

HRESULT CSaferEntry::GetCertificate(CCertificate **ppCert)
{
    ASSERT (ppCert);
    if ( !ppCert )
        return E_POINTER;

    if ( !m_pCertificate )
        return E_NOTIMPL;

    *ppCert = m_pCertificate;
    m_pCertificate->AddRef ();

    return S_OK;
}

HRESULT CSaferEntry::SetCertificate(CCertificate *pCert)
{
    ASSERT (m_pSaferEntries);
    if ( !m_pSaferEntries )
        return E_FAIL;

    HRESULT hr = S_OK;
    CCertStore* pStore = 0;

    switch (m_dwLevelID)
    {
    case SAFER_LEVELID_FULLYTRUSTED:
        hr = m_pSaferEntries->GetTrustedPublishersStore (&pStore);
        break;

    case SAFER_LEVELID_DISALLOWED:
        hr = m_pSaferEntries->GetDisallowedStore (&pStore);
        break;

    default:
        hr = E_FAIL;
        break;
    }

    if ( SUCCEEDED (hr) )
    {
        if ( m_pCertificate )
        {
            m_pCertificate->DeleteFromStore (false);
            m_pCertificate->Release ();
            m_pCertificate = 0;
        }

        if ( pCert )
        {
            m_pCertificate = pCert;
            m_pCertificate->AddRef ();
            hr = pStore->AddCertificateContext (m_pCertificate->GetCertContext (), 0, false);
            if ( SUCCEEDED (hr) )
            {
                m_pCertificate->GetNewCertContext ();
            }
        }
    }

    if ( pStore )
    {
        pStore->Release ();
        pStore = 0;
    }

    return hr;
}

void CSaferEntry::SetDescription(const CString& szDescription)
{
    m_szDescription = szDescription;
}

HRESULT CSaferEntry::GetSaferEntriesNode(CSaferEntries **ppSaferEntries)
{
    if ( !ppSaferEntries )
        return E_POINTER;

    if ( !m_pSaferEntries )
        return E_NOTIMPL;

    m_pSaferEntries->AddRef ();
    *ppSaferEntries = m_pSaferEntries;

    return S_OK;
}

DWORD CSaferEntry::GetLevel() const
{
    return m_dwLevelID;
}

HRESULT CSaferEntry::SetLevel(DWORD dwLevelID)
{
    HRESULT hr = S_OK;
    if ( m_dwLevelID != dwLevelID )
    {
        m_dwLevelID = dwLevelID;

        // Get the new "friendly name"
        if ( m_pGPEInformation )
        {
            CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsComputer);
            m_szLevelFriendlyName = SaferGetLevelFriendlyName (dwLevelID, 
                    policyKey.GetKey (),
                    m_bIsComputer); 
        }
        else
        {
            m_szLevelFriendlyName = SaferGetLevelFriendlyName (dwLevelID, 0,
                   m_bIsComputer);
        }
    }

    return hr;
}

CString CSaferEntry::GetPath()
{
    _TRACE (1, L"Entering CSaferEntry::GetPath()\n");
    CString szPath;
#ifdef DBG
    PWSTR   pszPath = 0;
#endif

    if ( m_pAuthzInfo )
    {
        if ( SaferIdentityTypeImageName == m_pAuthzInfo->dwIdentificationType )
        {
            PSAFER_PATHNAME_IDENTIFICATION pNameEntry =
                    (PSAFER_PATHNAME_IDENTIFICATION) m_pAuthzInfo;
            ASSERT (pNameEntry->header.cbStructSize >= 
                    sizeof (SAFER_PATHNAME_IDENTIFICATION));
            ASSERT (SaferIdentityTypeImageName == m_pAuthzInfo->dwIdentificationType);
            szPath = pNameEntry->ImageName;
#ifdef DBG
            pszPath = pNameEntry->ImageName;
#endif
        }
    }

    m_szPath = szPath;
#ifdef DBG
    _TRACE (-1, L"Leaving CSaferEntry::GetPath(): %s, %s\n", pszPath,
            (PCWSTR) szPath);
#endif
    return szPath;
}

void CSaferEntry::SetPath(const CString &szPath)
{
    m_szPath = szPath;
}

HRESULT CSaferEntry::Save()
{
    _TRACE (1, L"Entering CSaferEntry::Save\n");
    HRESULT hr = S_OK;

    ASSERT (!m_bDeleted);
    if ( m_bDeleted )
        return E_FAIL;

    if ( m_pCertificate )
    {
        // NTRAID# 461474 SAFER:  last modified date is being updated 
        // everytime the rules are refreshed.
        m_pCertificate->GetNewCertContext ();
        hr = m_pCertificate->SetDescription (m_szDescription);
        if ( SUCCEEDED (hr) )
        {
            hr = m_pCertificate->SetLastModified ();
            if ( SUCCEEDED (hr) )
            {
                // If the level has changed, then the cert must be removed 
                // from the current level store added to the new one.
                if ( m_dwOriginalLevelID != m_dwLevelID )
                {
                    CCertStore* pStore = 0;
                    switch (m_dwLevelID)
                    {
                    case SAFER_LEVELID_FULLYTRUSTED:
                        hr = m_pSaferEntries->GetTrustedPublishersStore (&pStore);
                        break;

                    case SAFER_LEVELID_DISALLOWED:
                        hr = m_pSaferEntries->GetDisallowedStore (&pStore);
                        break;

                    default:
                        hr = E_FAIL;
                        break;
                    }

                    if ( SUCCEEDED (hr) )
                    {
                        m_pCertificate->DeleteFromStore (true);
                        hr = pStore->AddCertificateContext (m_pCertificate->GetCertContext (), 0, false);
                        if ( SUCCEEDED (hr) )
                        {
                            m_pCertificate->SetStore (pStore);
                            hr = PolicyChanged ();
                        }
                    }

                    if ( pStore )
                    {
                        pStore->Release ();
                        pStore = 0;
                    }
                }

                if ( SUCCEEDED (hr) )
                    m_szDisplayName = m_pCertificate->GetSubjectName ();
            }
        }
    }
    else if ( m_pGPEInformation )
    {
        BOOL    bRVal = TRUE;
        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsComputer);
        hr = SetRegistryScope  (policyKey.GetKey (), m_bIsComputer);
        if ( SUCCEEDED (hr) )
        {

            DWORD   dwInBufferSize = 0;
            switch (m_saferEntryType)
            {
                case SAFER_ENTRY_TYPE_PATH:
                    dwInBufferSize = sizeof (SAFER_PATHNAME_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_HASH:
                    dwInBufferSize = sizeof (SAFER_HASH_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_URLZONE:
                    dwInBufferSize = sizeof (SAFER_URLZONE_IDENTIFICATION);
                    break;

                default:
                    ASSERT (0);
                    break;
            }

            SAFER_LEVEL_HANDLE hLevel = 0;

            // If this entry is not being created for the first time
            // and the level has changed, delete this object from its original
            // level.
            if ( m_pAuthzInfo && 
                    AUTHZ_UNKNOWN_LEVEL != m_dwOriginalLevelID && 
                    m_dwOriginalLevelID != m_dwLevelID )
            {
                bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                        m_dwOriginalLevelID,
                        SAFER_LEVEL_OPEN,
                        &hLevel,
                        policyKey.GetKey ());
                ASSERT (bRVal);
                if ( bRVal )
                {
                    SAFER_IDENTIFICATION_TYPES dwIdentificationType =
                            m_pAuthzInfo->dwIdentificationType;
                    m_pAuthzInfo->dwIdentificationType = (SAFER_IDENTIFICATION_TYPES) 0; // 0 will cause deletion

                    bRVal = SaferSetLevelInformation(hLevel,
                             SaferObjectSingleIdentification,
                             m_pAuthzInfo,
                             m_pAuthzInfo->cbStructSize);
                    ASSERT (bRVal);
                    if ( !bRVal )
                    {
                        DWORD   dwErr = GetLastError ();
                        _TRACE (0, L"Attempt to delete entry using SaferSetLevelInformation(SaferObjectSingleIdentification) failed: %d\n", dwErr);
                        hr = HRESULT_FROM_WIN32 (dwErr);
                    }
                    m_pAuthzInfo->dwIdentificationType = dwIdentificationType; // restore type
                            
                    VERIFY (SaferCloseLevel(hLevel));
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"SaferCreateLevel(SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                            m_dwOriginalLevelID, dwErr);
                }
            }

            if ( SUCCEEDED (hr) )
            {
                // If this is new, create and initialize a new info structure
                if ( !m_pAuthzInfo )
                {
                    // generate guid
                    GUID    guid;
                    hr = CoCreateGuid (&guid);
                    if ( SUCCEEDED (hr) )
                    {
                        m_pAuthzInfo = (PSAFER_IDENTIFICATION_HEADER)
                                ::LocalAlloc (LPTR, dwInBufferSize);
                        if ( m_pAuthzInfo )
                        {
                            m_pAuthzInfo->cbStructSize = dwInBufferSize;
                            // security review 2/22/2002 BryanWal ok
                            memcpy (&m_pAuthzInfo->IdentificationGuid, &guid, sizeof (m_pAuthzInfo->IdentificationGuid));
                        }
                        else
                            hr = E_OUTOFMEMORY;
                    }
                }

                if ( SUCCEEDED (hr) )
                {
                    switch (m_saferEntryType)
                    {
                    case SAFER_ENTRY_TYPE_PATH:
                        {
                            m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageName;
                            PSAFER_PATHNAME_IDENTIFICATION    pNameEntry = 
                                    reinterpret_cast<PSAFER_PATHNAME_IDENTIFICATION> (m_pAuthzInfo);
                            ASSERT (pNameEntry->header.cbStructSize >= 
                                    sizeof (SAFER_PATHNAME_IDENTIFICATION));

                            ASSERT (wcslen (m_szDescription) < SAFER_MAX_DESCRIPTION_SIZE);
                            if ( wcslen (m_szDescription) < SAFER_MAX_DESCRIPTION_SIZE )
                            {
                                // Security Review 3/21/2002 BryanWal - This is 
                                // okay because we're copying to 1 character less
                                // than the length of the buffer
                                wcsncpy (pNameEntry->Description, m_szDescription, SAFER_MAX_DESCRIPTION_SIZE);
                            }
                            pNameEntry->ImageName = const_cast <PWCHAR>((PCWSTR) m_szPath);
                            pNameEntry->dwSaferFlags = m_dwFlags;
                        }
                        break;

                    case SAFER_ENTRY_TYPE_HASH:
                        {
                            m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageHash;
                            PSAFER_HASH_IDENTIFICATION pHashEntry = 
                                    reinterpret_cast<PSAFER_HASH_IDENTIFICATION>(m_pAuthzInfo);
                            ASSERT (pHashEntry->header.cbStructSize == 
                                    sizeof (SAFER_HASH_IDENTIFICATION));

                            ASSERT (wcslen (m_szHashFriendlyName) < SAFER_MAX_FRIENDLYNAME_SIZE);
                            if ( wcslen (m_szHashFriendlyName) < SAFER_MAX_FRIENDLYNAME_SIZE )
                            {
                                // Security Review 3/21/2002 BryanWal - This is 
                                // okay because we're copying to 1 character less
                                // than the length of the buffer
                                wcsncpy (pHashEntry->FriendlyName, m_szHashFriendlyName, 
                                        SAFER_MAX_FRIENDLYNAME_SIZE);
                            }

                            ASSERT (wcslen (m_szDescription) < SAFER_MAX_DESCRIPTION_SIZE);
                            if ( wcslen (m_szDescription) < SAFER_MAX_DESCRIPTION_SIZE )
                            {
                                // Security Review 3/21/2002 BryanWal - This is 
                                // okay because we're copying to 1 character less
                                // than the length of the buffer
                                wcsncpy (pHashEntry->Description, 
                                        m_szDescription, 
                                        SAFER_MAX_DESCRIPTION_SIZE);
                            }
                            pHashEntry->dwSaferFlags = m_dwFlags;

                            // Security Review 3/21/2002 BryanWal - This is 
                            // okay 
                            memcpy (pHashEntry->ImageHash, m_rgbFileHash, 
                                    sizeof (pHashEntry->ImageHash));
                            pHashEntry->HashSize = m_cbFileHash;
                            // Security Review 3/21/2002 BryanWal - This is 
                            // okay
                            memcpy (&pHashEntry->ImageSize, &m_nHashFileSize, sizeof (pHashEntry->ImageSize));
                            pHashEntry->HashAlgorithm = m_hashAlgid;
                        }
                        break;

                    case SAFER_ENTRY_TYPE_URLZONE:
                        {
                            m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeUrlZone;
                            PSAFER_URLZONE_IDENTIFICATION pURLEntry = 
                                    reinterpret_cast <PSAFER_URLZONE_IDENTIFICATION> (m_pAuthzInfo);
                            ASSERT (pURLEntry->header.cbStructSize == 
                                    sizeof (SAFER_URLZONE_IDENTIFICATION));
                            pURLEntry->dwSaferFlags = m_dwFlags;
                            pURLEntry->UrlZoneId = m_UrlZoneId;
                        }
                        break;
                    }

                    bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                            m_dwLevelID,
                            SAFER_LEVEL_OPEN,
                            &hLevel,
                            policyKey.GetKey ());
                    ASSERT (bRVal);
                    if ( bRVal )
                    {
                        bRVal = SaferSetLevelInformation(hLevel,
                                    SaferObjectSingleIdentification,
                                    m_pAuthzInfo, m_pAuthzInfo->cbStructSize);
                        if ( bRVal )
                        {
                            switch ( m_saferEntryType )
                            {
                            case SAFER_ENTRY_TYPE_HASH:
                                m_szDisplayName = m_szHashFriendlyName;
                                m_szDisplayName.Replace (pcszNEWLINE, L"  ");
                                break;

                            case SAFER_ENTRY_TYPE_PATH:
                                m_szDisplayName = m_szPath;
                                break;

                            case SAFER_ENTRY_TYPE_URLZONE:
                                m_szDisplayName = GetURLZoneFriendlyName (m_UrlZoneId);
                                break;

                            default:
                                ASSERT (0);
                                break;
                            }
                        

                            hr = PolicyChanged ();
                            if ( SUCCEEDED (hr) )
                            {
                                m_dwOriginalLevelID = m_dwLevelID;
                            }
                        }
                        else
                        {
                            DWORD   dwErr = GetLastError ();
                            _TRACE (0, L"SaferSetLevelInformation(SaferObjectSingleIdentification) failed: %d\n",
                                    dwErr);
                            hr = HRESULT_FROM_WIN32 (dwErr);
                        }
                        VERIFY (SaferCloseLevel(hLevel));
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"SaferCreateLevel(AUTHZSCOPID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                                m_dwLevelID, dwErr);
                    }
                }
            }
        }    
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CSaferEntry::Save: 0x%x\n", hr);
    return hr;
}

HRESULT CSaferEntry::PolicyChanged()
{
    _TRACE (1, L"Entering CSaferEntry::PolicyChanged\n");
    HRESULT hr = E_FAIL;

    if ( m_pGPEInformation )
    {
        hr = m_pGPEInformation->PolicyChanged (
                m_bIsComputer ? TRUE : FALSE,
                TRUE, &g_guidExtension, &g_guidSnapin);
        hr = m_pGPEInformation->PolicyChanged (
                m_bIsComputer ? TRUE : FALSE,
                TRUE, &g_guidRegExt, &g_guidSnapin);
    }

    _TRACE (-1, L"Leaving CSaferEntry::PolicyChanged\n");
    return hr;
}

void CSaferEntry::SetFlags(DWORD dwFlags)
{
    m_dwFlags = dwFlags;
}

HRESULT CSaferEntry::GetFlags(DWORD &dwFlags)
{
    HRESULT hr = S_OK;

    if ( m_pAuthzInfo )
    {
        switch (m_saferEntryType)
        {
        case SAFER_ENTRY_TYPE_PATH:
            {
                m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageName;
                PSAFER_PATHNAME_IDENTIFICATION    pNameEntry = 
                        reinterpret_cast<PSAFER_PATHNAME_IDENTIFICATION>(m_pAuthzInfo);
                ASSERT (pNameEntry->header.cbStructSize >= 
                        sizeof (SAFER_PATHNAME_IDENTIFICATION));
                dwFlags = pNameEntry->dwSaferFlags;
            }
            break;

        case SAFER_ENTRY_TYPE_HASH:
            {
                m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeImageHash;
                PSAFER_HASH_IDENTIFICATION pHashEntry = 
                        reinterpret_cast<PSAFER_HASH_IDENTIFICATION>(m_pAuthzInfo);
                ASSERT (pHashEntry->header.cbStructSize == 
                        sizeof (SAFER_HASH_IDENTIFICATION));
                dwFlags = pHashEntry->dwSaferFlags;
            }
            break;

        case SAFER_ENTRY_TYPE_URLZONE:
            {
                m_pAuthzInfo->dwIdentificationType = SaferIdentityTypeUrlZone;
                PSAFER_URLZONE_IDENTIFICATION pURLEntry = 
                        reinterpret_cast<PSAFER_URLZONE_IDENTIFICATION>(m_pAuthzInfo);
                ASSERT (pURLEntry->header.cbStructSize == 
                        sizeof (SAFER_URLZONE_IDENTIFICATION));
                dwFlags = pURLEntry->dwSaferFlags;
            }
            break;

        default:
            hr = E_FAIL;
            break;
        }
    }
    else if ( m_pCertificate )
    {
        hr = E_NOTIMPL;
    }

    return hr;
}

HRESULT CSaferEntry::Delete(bool bCommit)
{
    _TRACE (1, L"Entering CSaferEntry::Delete\n");
    HRESULT hr = S_OK;
    
    ASSERT (!m_bDeleted);
    if ( m_bDeleted )
        return E_FAIL;

    if ( m_pCertificate )
    {
        BOOL bRVal = m_pCertificate->DeleteFromStore (bCommit);
        if ( bRVal )
        {
            m_bDeleted = true;
        }
        else
        {
		    DWORD	dwErr = GetLastError ();
		    hr = HRESULT_FROM_WIN32 (dwErr);
        }
    }
    else if ( m_pGPEInformation )
    {
        BOOL    bRVal = TRUE;
        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsComputer);
        hr = SetRegistryScope  (policyKey.GetKey (), m_bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwInBufferSize = 0;
            switch (m_saferEntryType)
            {
                case SAFER_ENTRY_TYPE_PATH:
                    dwInBufferSize = sizeof (SAFER_PATHNAME_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_HASH:
                    dwInBufferSize = sizeof (SAFER_HASH_IDENTIFICATION);
                    break;

                case SAFER_ENTRY_TYPE_URLZONE:
                    dwInBufferSize = sizeof (SAFER_URLZONE_IDENTIFICATION);
                    break;

                default:
                    ASSERT (0);
                    break;
            }

            SAFER_LEVEL_HANDLE hLevel = 0;

            if ( m_pAuthzInfo )
            {
                bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                        m_dwOriginalLevelID,
                        SAFER_LEVEL_OPEN,
                        &hLevel,
                        policyKey.GetKey ());
                ASSERT (bRVal);
                if ( bRVal )
                {
                    SAFER_IDENTIFICATION_TYPES dwIdentificationType =
                            m_pAuthzInfo->dwIdentificationType;
                    m_pAuthzInfo->dwIdentificationType = (SAFER_IDENTIFICATION_TYPES) 0; // 0 will cause deletion

                    bRVal = SaferSetLevelInformation(hLevel,
                             SaferObjectSingleIdentification,
                             m_pAuthzInfo,
                             m_pAuthzInfo->cbStructSize);
                    ASSERT (bRVal);
                    if ( bRVal )
                    {
                        m_bDeleted = true;
                        if ( bCommit )
                        {
                            hr = m_pGPEInformation->PolicyChanged (
                                    m_bIsComputer ? TRUE : FALSE,
                                    TRUE, &g_guidExtension, &g_guidSnapin);
                            hr = m_pGPEInformation->PolicyChanged (
                                    m_bIsComputer ? TRUE : FALSE,
                                    TRUE, &g_guidRegExt, &g_guidSnapin);
                        }
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        _TRACE (0, L"Attempt to delete entry using SaferSetLevelInformation(SaferObjectSingleIdentification) failed: %d\n", dwErr);
                        hr = HRESULT_FROM_WIN32 (dwErr);
                    }
                    m_pAuthzInfo->dwIdentificationType = dwIdentificationType;   
                            
                    VERIFY (SaferCloseLevel(hLevel));  // restore type
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"SaferCreateLevel(AUTHZSCOPID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                            m_dwOriginalLevelID, dwErr);
                }
            }
        }    
    }
    else
        hr = E_FAIL;

    _TRACE (-1, L"Leaving CSaferEntry::Delete: 0x%x\n", hr);
    return hr;
}

HRESULT CSaferEntry::GetHash(BYTE rgbFileHash[SAFER_MAX_HASH_SIZE], DWORD& cbFileHash, __int64& nFileSize, ALG_ID& algId) const
{
    HRESULT hr = S_OK;

    if ( m_pAuthzInfo )
    {
        if ( SAFER_ENTRY_TYPE_HASH == m_saferEntryType )
        {
            PSAFER_HASH_IDENTIFICATION pHashEntry = 
                    reinterpret_cast<PSAFER_HASH_IDENTIFICATION>(m_pAuthzInfo);
            ASSERT (pHashEntry->header.cbStructSize == 
                    sizeof (SAFER_HASH_IDENTIFICATION));

            // security review - 3/21/2002 BryanWal OK
            ::SecureZeroMemory (rgbFileHash, SAFER_MAX_HASH_SIZE);
            ASSERT (pHashEntry->HashSize <= SAFER_MAX_HASH_SIZE);
            if ( pHashEntry->HashSize <= SAFER_MAX_HASH_SIZE )
            {
                memcpy (rgbFileHash, pHashEntry->ImageHash, pHashEntry->HashSize);
                cbFileHash = pHashEntry->HashSize;
            }
            else
                hr = E_FAIL;

            // security review - 3/21/2002 BryanWal OK
            memcpy (&nFileSize, &pHashEntry->ImageSize, sizeof (nFileSize));
            algId = pHashEntry->HashAlgorithm;
        }
        else
            hr = E_NOTIMPL;
    }
    else
        hr = E_FAIL;

    return hr;
}

HRESULT CSaferEntry::SetHash (
            BYTE    rgbFileHash[SAFER_MAX_HASH_SIZE], 
            DWORD   cbFileHash, 
            __int64 nFileSize, 
            ALG_ID   hashAlgid)
{
    ASSERT (cbFileHash <= SAFER_MAX_HASH_SIZE);
    if ( cbFileHash > SAFER_MAX_HASH_SIZE )
        return E_FAIL;

    ASSERT (rgbFileHash);
    if ( !rgbFileHash )
        return E_POINTER;

    m_nHashFileSize = nFileSize;
    m_cbFileHash = cbFileHash;
    // Security review 2/25/2002 BryanWal ok
    ::SecureZeroMemory (m_rgbFileHash, sizeof (m_rgbFileHash));
    ASSERT (cbFileHash <= SAFER_MAX_HASH_SIZE);
    if ( cbFileHash <= SAFER_MAX_HASH_SIZE )
        memcpy (m_rgbFileHash, rgbFileHash, cbFileHash);
    else
        return E_FAIL;

    m_hashAlgid = hashAlgid;

    return S_OK;
}

DWORD CSaferEntry::GetURLZoneID() const
{
    return m_UrlZoneId;
}

void CSaferEntry::SetURLZoneID(DWORD dwURLZoneID)
{
    m_UrlZoneId = dwURLZoneID;
}

CString CSaferEntry::GetHashFriendlyName()
{
    CString szFriendlyName;

    if ( m_szHashFriendlyName.IsEmpty () )
    {
        if ( m_pAuthzInfo )
        {
            if ( SaferIdentityTypeImageHash == m_pAuthzInfo->dwIdentificationType )
            {
                PSAFER_HASH_IDENTIFICATION pHashEntry = 
                        (PSAFER_HASH_IDENTIFICATION) m_pAuthzInfo;
                ASSERT (pHashEntry->header.cbStructSize == 
                        sizeof (SAFER_HASH_IDENTIFICATION));
                m_szHashFriendlyName = pHashEntry->FriendlyName;
            }
        }
    }
    
    return m_szHashFriendlyName;
}

void CSaferEntry::SetHashFriendlyName(const CString &szFriendlyName)
{
    m_szHashFriendlyName = szFriendlyName;
}

int CSaferEntry::CompareLastModified (const CSaferEntry& saferEntry) const
{
	int	compVal = 0;

    FILETIME    thisFt;
    FILETIME    inFt;

    if ( m_pAuthzInfo )
        thisFt = m_pAuthzInfo->lastModified;
    else if ( m_pCertificate )
    {
        if ( FAILED (m_pCertificate->GetLastModifiedFileTime (thisFt)) )
            return 0;
    }
    else
    {
        ASSERT (0);
        return 0;
    }

    if ( saferEntry.m_pAuthzInfo )
        inFt = saferEntry.m_pAuthzInfo->lastModified;
    else if ( saferEntry.m_pCertificate )
    {
        if ( FAILED (saferEntry.m_pCertificate->GetLastModifiedFileTime (inFt)) )
            return 0;
    }
    else
    {
        ASSERT (0);
        return 0;
    }

	compVal = ::CompareFileTime (&thisFt, &inFt);

	return compVal;
}

CString CSaferEntry::GetRSOPRegistryKey () const
{
    CString szRegistryKey;
    if ( m_pCertificate )
    {
        if ( SAFER_LEVELID_FULLYTRUSTED == m_dwLevelID )
            szRegistryKey = CERT_TRUST_PUB_SAFER_GROUP_POLICY_TRUSTED_PUBLISHER_STORE_REGPATH;
        else
            szRegistryKey = CERT_TRUST_PUB_SAFER_GROUP_POLICY_DISALLOWED_STORE_REGPATH;

        szRegistryKey += STR_REGKEY_CERTIFICATES;
        szRegistryKey += L"\\";
        //szRegistryKey += m_pCertificate->GetMD5Hash ();
        szRegistryKey += m_pCertificate->GetSHAHash ();
    }
    else
        szRegistryKey = m_szRSOPRegistryKey;

    ASSERT (!szRegistryKey.IsEmpty ());
    return szRegistryKey;
}


void CSaferEntry::Refresh()
{
    _TRACE (1, L"Entering CSaferEntry::Refresh ()\n");
    if ( m_pAuthzInfo )
    {
        if ( m_pGPEInformation )
        {
            SAFER_LEVEL_HANDLE hLevel = 0;
            CPolicyKey policyKey (m_pGPEInformation, 
                            SAFER_HKLM_REGBASE, 
                            m_bIsComputer);
            BOOL        bRVal = SaferCreateLevel(SAFER_SCOPEID_REGISTRY,
                            m_dwLevelID,
                            SAFER_LEVEL_OPEN,
                            &hLevel,
                            policyKey.GetKey ());
            if ( bRVal )
            {
                DWORD   dwBufferSize = sizeof (SAFER_IDENTIFICATION_HEADER);
                bRVal = SaferGetLevelInformation (hLevel, 
                            SaferObjectSingleIdentification,
                            m_pAuthzInfo,
                            dwBufferSize,
                            &dwBufferSize);
                if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
                {
                    PBYTE   pBytes = (PBYTE) LocalAlloc (LPTR, dwBufferSize);
                    if ( pBytes )
                    {
                        PSAFER_IDENTIFICATION_HEADER pCommon = (PSAFER_IDENTIFICATION_HEADER) pBytes;
                        pCommon->cbStructSize = dwBufferSize;
                        // security review 2/25/2002 BryanWal ok
                        memcpy (&pCommon->IdentificationGuid, &m_pAuthzInfo->IdentificationGuid, 
                                sizeof (pCommon->IdentificationGuid));

                        bRVal = SaferGetLevelInformation (hLevel, 
                                SaferObjectSingleIdentification,
                                pBytes,
                                dwBufferSize,
                                &dwBufferSize);
                        ASSERT (bRVal);
                        if ( bRVal )
                        {
                            LocalFree (m_pAuthzInfo);
                            m_pAuthzInfo = (PSAFER_IDENTIFICATION_HEADER) pBytes;
                        }
                        else
                        {
                            _TRACE (0, L"SaferGetLevelInformation () failed: %d\n", GetLastError ());
                        }
                    }
                }

                VERIFY (SaferCloseLevel(hLevel));
            }
            else
            {
                _TRACE (0, L"SaferCreateLevel() failed: %d\n", GetLastError ());
            }
        }
        else
        {
            // Is RSOP
        }
    }
    _TRACE (-1, L"Leaving CSaferEntry::Refresh ()\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentrycertificatepropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryCertificatePropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryCertificatePropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryCertificatePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include <softpub.h>
#include "compdata.h"
#include "certmgr.h"
#include "SaferEntryCertificatePropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryCertificatePropertyPage property page

CSaferEntryCertificatePropertyPage::CSaferEntryCertificatePropertyPage(
        CSaferEntry& rSaferEntry,
        CSaferEntries* pSaferEntries,
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        CCertMgrComponentData* pCompData,
        bool bNew,
        IGPEInformation* pGPEInformation,
        bool bIsMachine,
        bool* pbObjectCreated /* = 0 */) : 
    CSaferPropertyPage(CSaferEntryCertificatePropertyPage::IDD, pbObjectCreated, 
            pCompData, rSaferEntry, bNew, lNotifyHandle, pDataObject, bReadOnly,
            bIsMachine),
    m_bStoresEnumerated (false),
    m_bCertificateChanged (false),
    m_pCertContext (0),
    m_pSaferEntries (pSaferEntries),
    m_pOriginalStore (0),
    m_pGPEInformation (pGPEInformation),
    m_bFirst (true)
{
    //{{AFX_DATA_INIT(CSaferEntryCertificatePropertyPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    // security review 2/25/2002 BryanWal ok
    ::ZeroMemory (&m_selCertStruct, sizeof (m_selCertStruct));

    if ( m_pSaferEntries )
        m_pSaferEntries->AddRef ();
}

CSaferEntryCertificatePropertyPage::~CSaferEntryCertificatePropertyPage()
{
    // Clean up enumerated store list
    for (DWORD dwIndex = 0; dwIndex < m_selCertStruct.cDisplayStores; dwIndex++)
    {
        ASSERT (m_selCertStruct.rghDisplayStores);
        if ( m_selCertStruct.rghDisplayStores[dwIndex] )
            ::CertCloseStore (m_selCertStruct.rghDisplayStores[dwIndex], CERT_CLOSE_STORE_FORCE_FLAG);
    }
    if ( m_selCertStruct.rghDisplayStores )
        delete [] m_selCertStruct.rghDisplayStores;

//    if ( m_pCertContext )
//        CertFreeCertificateContext (m_pCertContext);

    if ( m_pSaferEntries )
    {
        m_pSaferEntries->Release ();
        m_pSaferEntries = 0;
    }

    if ( m_pOriginalStore )
    {
        m_pOriginalStore->Release ();
        m_pOriginalStore = 0;
    }
}

void CSaferEntryCertificatePropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CSaferPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSaferEntryCertificatePropertyPage)
    DDX_Control(pDX, IDC_CERT_ENTRY_DESCRIPTION, m_descriptionEdit);
    DDX_Control(pDX, IDC_CERT_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryCertificatePropertyPage, CSaferPropertyPage)
    //{{AFX_MSG_MAP(CSaferEntryCertificatePropertyPage)
    ON_BN_CLICKED(IDC_CERT_ENTRY_BROWSE, OnCertEntryBrowse)
    ON_EN_CHANGE(IDC_CERT_ENTRY_DESCRIPTION, OnChangeCertEntryDescription)
    ON_CBN_SELCHANGE(IDC_CERT_ENTRY_SECURITY_LEVEL, OnSelchangeCertEntrySecurityLevel)
    ON_BN_CLICKED(IDC_SAFER_CERT_VIEW, OnSaferCertView)
    ON_EN_SETFOCUS(IDC_CERT_ENTRY_SUBJECT_NAME, OnSetfocusCertEntrySubjectName)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryCertificatePropertyPage message handlers
void CSaferEntryCertificatePropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryCertificatePropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_CERT_ENTRY_SUBJECT_NAME, IDH_CERT_ENTRY_SUBJECT_NAME,
        IDC_CERT_ENTRY_BROWSE, IDH_CERT_ENTRY_BROWSE,
        IDC_CERT_ENTRY_SECURITY_LEVEL, IDH_CERT_ENTRY_SECURITY_LEVEL,
        IDC_CERT_ENTRY_DESCRIPTION, IDH_CERT_ENTRY_DESCRIPTION,
        IDC_CERT_ENTRY_LAST_MODIFIED, IDH_CERT_ENTRY_LAST_MODIFIED,
        0, 0
    };


    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_CERT_ENTRY_SUBJECT_NAME:
    case IDC_CERT_ENTRY_BROWSE:
    case IDC_CERT_ENTRY_SECURITY_LEVEL:
    case IDC_CERT_ENTRY_DESCRIPTION:
    case IDC_CERT_ENTRY_LAST_MODIFIED:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryCertificatePropertyPage::DoContextHelp\n");
}


BOOL CSaferEntryCertificatePropertyPage::OnInitDialog() 
{
    CSaferPropertyPage::OnInitDialog();
    
    HRESULT hr = S_OK;
    DWORD   dwLevelID = m_rSaferEntry.GetLevel ();

    ASSERT (SAFER_LEVELID_FULLYTRUSTED == dwLevelID || SAFER_LEVELID_DISALLOWED == dwLevelID);
    switch (dwLevelID)
    {
    case SAFER_LEVELID_FULLYTRUSTED:
        hr = m_pSaferEntries->GetTrustedPublishersStore (&m_pOriginalStore);
        break;

    case SAFER_LEVELID_DISALLOWED:
        hr = m_pSaferEntries->GetDisallowedStore (&m_pOriginalStore);
        break;

    default:
        break;
    }

    CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsMachine);
    InitializeSecurityLevelComboBox (m_securityLevelCombo, true, dwLevelID, 
            policyKey.GetKey (), m_pCompData->m_pdwSaferLevels,
            m_bIsMachine);

    m_descriptionEdit.SetLimitText (SAFER_MAX_DESCRIPTION_SIZE-1);
    m_descriptionEdit.SetWindowText (m_rSaferEntry.GetDescription ());

    SetDlgItemText (IDC_CERT_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

    CCertificate*   pCert = 0;
    hr = m_rSaferEntry.GetCertificate (&pCert);
    if ( SUCCEEDED (hr) && pCert )
    {
        ASSERT (!m_pCertContext);
        m_pCertContext = CertDuplicateCertificateContext (pCert->GetCertContext ());
        if ( m_pCertContext )
            SetDlgItemText (IDC_CERT_ENTRY_SUBJECT_NAME, ::GetNameString (m_pCertContext, 0));
        pCert->Release ();
    }

    if ( !m_pCertContext )
    {
        GetDlgItem (IDC_SAFER_CERT_VIEW)->EnableWindow (FALSE);
        GetDlgItem (IDC_CERT_ENTRY_SUBJECT_NAME)->EnableWindow (FALSE);
        GetDlgItem (IDC_CERT_ENTRY_SUBJECT_NAME_LABEL)->EnableWindow (FALSE);
    }

    if ( m_bReadOnly )
    {
        m_descriptionEdit.EnableWindow (FALSE);
        m_securityLevelCombo.EnableWindow (FALSE);
        GetDlgItem (IDC_CERT_ENTRY_BROWSE)->EnableWindow (FALSE);
    }

    if ( !m_bDirty )
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_CERTIFICATE_TITLE));
        SetDlgItemText (IDC_CERTIFICATE_TITLE, szText);
    }
    else
    {
        GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_HIDE);
        GetDlgItem (IDC_CERT_ENTRY_LAST_MODIFIED)->ShowWindow (SW_HIDE);
    }

    GetDlgItem (IDC_CERT_ENTRY_BROWSE)->SetFocus ();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

typedef struct _ENUM_ARG {
    DWORD               dwFlags;
    DWORD*              pcDisplayStores;          
    HCERTSTORE **       prghDisplayStores;        
} ENUM_ARG, *PENUM_ARG;

static BOOL WINAPI EnumSaferStoresSysCallback(
    IN const void* pwszSystemStore,
    IN DWORD /*dwFlags*/,
    IN PCERT_SYSTEM_STORE_INFO /*pStoreInfo*/,
    IN OPTIONAL void * /*pvReserved*/,
    IN OPTIONAL void *pvArg
    )
{
    PENUM_ARG pEnumArg = (PENUM_ARG) pvArg;
    void*       pvPara = (void*)pwszSystemStore;



    HCERTSTORE  hNewStore  = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
                CERT_SYSTEM_STORE_CURRENT_USER, pvPara);
    if ( !hNewStore )
    {
        hNewStore = ::CertOpenStore (CERT_STORE_PROV_SYSTEM, 
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL, 
                CERT_SYSTEM_STORE_CURRENT_USER | CERT_STORE_READONLY_FLAG, pvPara);
    }
    if ( hNewStore )
    {
        DWORD       dwCnt = *(pEnumArg->pcDisplayStores);
        HCERTSTORE* phStores = 0;

        phStores = new HCERTSTORE[dwCnt+1];
        if ( phStores )
        {
            DWORD   dwIndex = 0;
            if ( *(pEnumArg->prghDisplayStores) )
            {
                for (; dwIndex < dwCnt; dwIndex++)
                {
                    phStores[dwIndex] = (*(pEnumArg->prghDisplayStores))[dwIndex];
                }
                delete [] (*(pEnumArg->prghDisplayStores));
            }
            (*(pEnumArg->pcDisplayStores))++;
            (*(pEnumArg->prghDisplayStores)) = phStores;
            (*(pEnumArg->prghDisplayStores))[dwIndex] = hNewStore;
        }
        else
        {
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
    }

    return TRUE;
}

void CSaferEntryCertificatePropertyPage::OnCertEntryBrowse() 
{
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_SAFER_CERTFILEFILTER));

    // replace "|" with 0;
    // security review 2/25/2002 BryanWal ok
    const size_t  nFilterLen = wcslen (szFileFilter) + 1; //+1 is for null-term
    PWSTR   pszFileFilter = new WCHAR [nFilterLen];
    if ( pszFileFilter )
    {
        // security review 2/25/2002 BryanWal ok
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }

        WCHAR           szFile[MAX_PATH];
        // security review 2/25/2002 BryanWal ok
        ::ZeroMemory (szFile, sizeof (szFile));
        OPENFILENAME    ofn;
        // security review 2/25/2002 BryanWal ok
        ::ZeroMemory (&ofn, sizeof (ofn));

        ofn.lStructSize = sizeof (OPENFILENAME);
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = (PCWSTR) pszFileFilter; 
        ofn.lpstrFile = szFile; 
        ofn.nMaxFile = MAX_PATH; 
        ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; 


        BOOL bResult = ::GetOpenFileName (&ofn);
        if ( bResult )
        {
            CString szFileName = ofn.lpstrFile;
            //
            // Open cert store from the file
            //

            HCERTSTORE      hCertStore = NULL;
            PVOID           FileNameVoidP = (PVOID) (LPCWSTR)szFileName;
            PCCERT_CONTEXT  pCertContext = NULL;
            DWORD           dwEncodingType = 0;
            DWORD           dwContentType = 0;
            DWORD           dwFormatType = 0;

            BOOL    bReturn = ::CryptQueryObject (
                    CERT_QUERY_OBJECT_FILE,
                    FileNameVoidP,
                    CERT_QUERY_CONTENT_FLAG_ALL,
                    CERT_QUERY_FORMAT_FLAG_ALL,
                    0,
                    &dwEncodingType,
                    &dwContentType,
                    &dwFormatType,
                    &hCertStore,
                    NULL,
                    (const void **)&pCertContext);
            if ( bReturn )
            {
                //
                // Success. See what we get back. A store or a cert.
                //

                if (  (dwContentType == CERT_QUERY_CONTENT_SERIALIZED_STORE)
                        && hCertStore)
                {

                    CERT_ENHKEY_USAGE   enhKeyUsage;
                    // security review 2/25/2002 BryanWal ok
                    ::ZeroMemory (&enhKeyUsage, sizeof (enhKeyUsage));
                    enhKeyUsage.cUsageIdentifier = 1;
                    enhKeyUsage.rgpszUsageIdentifier[0] = szOID_EFS_RECOVERY;
                    //
                    // We get the certificate store
                    //
                    pCertContext = ::CertFindCertificateInStore (
                            hCertStore,
                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                            0,
                            CERT_FIND_ENHKEY_USAGE,
                            &enhKeyUsage,
                            NULL);
                    if ( !pCertContext )
                    {
                        CString caption;
                        CString text;
                        CThemeContextActivator activator;

                        VERIFY (text.LoadString (IDS_FILE_CONTAINS_NO_CERT));
                        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                        MessageBox (text, caption, MB_OK);
                    }

                    if ( hCertStore )
                        ::CertCloseStore (hCertStore, 0);
                }
                else if ( CERT_QUERY_CONTENT_PKCS7_SIGNED_EMBED == dwContentType )
                {
                    GetCertFromSignedFile (szFileName);
                }
                else if ( (dwContentType != CERT_QUERY_CONTENT_CERT) || !pCertContext )
                {
                    //
                    // Neither a valid cert file nor a store file we like.
                    //

                    if ( hCertStore )
                        ::CertCloseStore (hCertStore, 0);

                    if  ( pCertContext )
                        ::CertFreeCertificateContext (pCertContext);

                    CString ErrMsg;
                    CThemeContextActivator activator;

                    VERIFY (ErrMsg.LoadString (IDS_CERTFILEFORMATERR));
                    MessageBox (ErrMsg);
                    return;

                }

                if ( pCertContext )
                {
                    if ( m_pCertContext )
                        CertFreeCertificateContext (m_pCertContext);
            
                    m_pCertContext = pCertContext;
                    if ( m_pCertContext )
                    {
                        SetDlgItemText (IDC_CERT_ENTRY_SUBJECT_NAME, ::GetNameString (m_pCertContext, 0));
                        GetDlgItem (IDC_SAFER_CERT_VIEW)->EnableWindow (TRUE);
                        GetDlgItem (IDC_CERT_ENTRY_SUBJECT_NAME)->EnableWindow (TRUE);
                        GetDlgItem (IDC_CERT_ENTRY_SUBJECT_NAME_LABEL)->EnableWindow (TRUE);
                    }

                    m_bCertificateChanged = true;
                    m_bDirty = true;
                    SetModified ();
                }

                if ( hCertStore )
                {
                    ::CertCloseStore (hCertStore, 0);
                    hCertStore = NULL;
                }
            }
            else
            {
                GetCertFromSignedFile (szFileName);
            }
        }

        delete [] pszFileFilter;
    }
}

void CSaferEntryCertificatePropertyPage::GetCertFromSignedFile (const CString& szFilePath)
{
    _TRACE (1, L"Entering CSaferEntryCertificatePropertyPage::GetCertFromSignedFile (%s)\n",
            (PCWSTR) szFilePath);
    // NTRAID# 477409 SAFER: New certificate rules can't pull a 
    // certificate out of a file.
    DWORD                   dwErr = 0;
    DWORD                   dwUIChoice = WTD_UI_NONE;
    DWORD                   dwProvFlags = WTD_REVOCATION_CHECK_NONE;    
    WINTRUST_FILE_INFO      WinTrustFileInfo;
    WINTRUST_DATA           WinTrustData;
    HRESULT                 hr = S_OK;
    GUID                    wvtProvGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;


    // security review 2/25/2002 BryanWal ok
    ::ZeroMemory(&WinTrustFileInfo, sizeof(WinTrustFileInfo));
    ::ZeroMemory(&WinTrustData, sizeof(WinTrustData));

    //
    // Setup structure to call WVT.
    //
    WinTrustFileInfo.cbStruct = sizeof (WINTRUST_FILE_INFO);
    WinTrustFileInfo.pcwszFilePath = (PCWSTR) szFilePath;


    WinTrustData.cbStruct          = sizeof(WINTRUST_DATA);
    WinTrustData.dwUIChoice        = dwUIChoice;
    WinTrustData.dwUnionChoice     = WTD_CHOICE_FILE;
    WinTrustData.dwStateAction     = WTD_STATEACTION_VERIFY;
    WinTrustData.pFile             = &WinTrustFileInfo;
    WinTrustData.dwProvFlags       = dwProvFlags;


    hr = ::WinVerifyTrust (NULL, &wvtProvGuid, &WinTrustData);
    if ( SUCCEEDED (hr) )
    {
        PCRYPT_PROVIDER_DATA pProvData = 
                WTHelperProvDataFromStateData (
                        WinTrustData.hWVTStateData);
        if ( pProvData )
        {
            PCRYPT_PROVIDER_SGNR pProvSigner = 
                ::WTHelperGetProvSignerFromChain (pProvData, 0, FALSE, 0);
            if ( pProvSigner )
            {
                PCRYPT_PROVIDER_CERT pProvCert = 
                    ::WTHelperGetProvCertFromChain (pProvSigner, 0);
                if ( pProvCert )
                {
                    if ( m_pCertContext )
                        ::CertFreeCertificateContext (m_pCertContext);

                    // TODO:  Do we need to duplicate context here?
                    m_pCertContext = ::CertDuplicateCertificateContext 
                            (pProvCert->pCert);
                    if ( m_pCertContext )
                    {
                        SetDlgItemText (IDC_CERT_ENTRY_SUBJECT_NAME, ::GetNameString (m_pCertContext, 0));
                        GetDlgItem (IDC_SAFER_CERT_VIEW)->EnableWindow (TRUE);
                    }

                    m_bCertificateChanged = true;
                    m_bDirty = true;
                    SetModified ();

                    //now close the data
                    WinTrustData.dwStateAction = WTD_STATEACTION_CLOSE;
                    if ( S_OK != ::WinVerifyTrust (NULL, &wvtProvGuid, 
                            &WinTrustData))
                    {
                        dwErr = GetLastError ();
                        _TRACE (0, L"error calling WVT during close %d\n", dwErr);
                    }
                }
                else
                {
                    dwErr = GetLastError ();
                    _TRACE (0, L"error calling WTHelperGetProvCertFromChain %d\n", dwErr);
                }
            }
            else
            {
                dwErr = GetLastError ();
                _TRACE (0, L"error calling WTHelperGetProvSignerFromChain %d\n", 
                        dwErr);
            }
        }
        else
        {
            dwErr = GetLastError ();
            _TRACE (0, L"error calling WTHelperProvDataFromStateData %d\n", 
                    dwErr);
        }
    }
    else
    {
        dwErr = GetLastError ();
        _TRACE (0, L"error calling WVT %d for %s\n", 
                dwErr, (PCWSTR) szFilePath);
    }

    if ( 0 != dwErr )
    {
        //
        // Fail. Get the error code.
        //
        CString text;
        CString caption;
        CThemeContextActivator activator;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        text.FormatMessage (IDS_CERTFILEOPENERR, szFilePath, 
                GetSystemMessage (dwErr));
        MessageBox (text, caption);
    }
    _TRACE (-1, L"Leaving CSaferEntryCertificatePropertyPage::GetCertFromSignedFile (%s): %x\n",
            (PCWSTR) szFilePath, dwErr);
}

BOOL CSaferEntryCertificatePropertyPage::OnApply() 
{
    if ( !m_bReadOnly )
    {
        ASSERT (m_pSaferEntries);
        if ( !m_pSaferEntries )
            return FALSE;

        CThemeContextActivator activator;
        if ( !m_pCertContext )
        {
            CString     text;
            CString     caption;

            VERIFY (text.LoadString (IDS_SAFER_MUST_CHOOSE_CERT));
            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            MessageBox (text, caption, MB_OK);
            GetDlgItem (IDC_CERT_ENTRY_BROWSE)->SetFocus ();
            return FALSE;
        }

        if ( m_bDirty )
        {
            int nCurSel = m_securityLevelCombo.GetCurSel ();
            ASSERT (CB_ERR < nCurSel);
            if ( CB_ERR < nCurSel )
            {
                CCertStore* pTrustedPublishersStore = 0;
        
                HRESULT hr = m_pSaferEntries->GetTrustedPublishersStore (&pTrustedPublishersStore);
                ASSERT (SUCCEEDED (hr));
                if ( SUCCEEDED (hr) )
                {
                    CCertStore* pDisallowedStore = 0;
                    hr = m_pSaferEntries->GetDisallowedStore (&pDisallowedStore);
                    ASSERT (SUCCEEDED (hr));
                    if ( SUCCEEDED (hr) )
                    {
                        DWORD_PTR dwLevel = m_securityLevelCombo.GetItemData (nCurSel);
                        m_rSaferEntry.SetLevel ((DWORD) dwLevel);

                        CCertStore* pStore = (SAFER_LEVELID_FULLYTRUSTED == dwLevel) ?
                                pTrustedPublishersStore : pDisallowedStore;
                        CCertificate*   pCert = 0;
                        hr = m_rSaferEntry.GetCertificate (&pCert);
                        if ( E_NOTIMPL == hr )
                        {
                            // This is a new entry

                            if ( m_pOriginalStore )
                                m_pOriginalStore->Release ();
                            m_pOriginalStore = pStore;
                            m_pOriginalStore->AddRef ();

                            CCertificate* pNewCert = new CCertificate (
                                    m_pCertContext,
                                    pStore);
                            if ( pNewCert )
                            {
                                hr = m_rSaferEntry.SetCertificate (pNewCert);
                                pNewCert->Release ();
                            }
                            else
                                hr = E_OUTOFMEMORY;

                            if ( SUCCEEDED (hr) )
                            {
                                CString szDescription;
                                m_descriptionEdit.GetWindowText (szDescription);
                                m_rSaferEntry.SetDescription (szDescription);

                                hr = m_rSaferEntry.Save ();
                                if ( SUCCEEDED (hr) )
                                {
                                    pStore->Commit ();
                                    if ( m_lNotifyHandle )
                                        MMCPropertyChangeNotify (
                                                m_lNotifyHandle,  // handle to a notification
                                                (LPARAM) m_pDataObject);          // unique identifier
                                    
                                    if ( m_pbObjectCreated )
                                        *m_pbObjectCreated = true;

                                    m_rSaferEntry.Refresh ();
                                    
                                    GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_SHOW);
                                    GetDlgItem (IDC_CERT_ENTRY_LAST_MODIFIED)->ShowWindow (SW_SHOW);
                                    GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->UpdateWindow ();
                                    GetDlgItem (IDC_CERT_ENTRY_LAST_MODIFIED)->UpdateWindow ();
                                    SetDlgItemText (IDC_CERT_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

                                    m_bDirty = false;
                                }
                                else
                                {
                                    CString text;
                                    CString caption;

                                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                                    text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

                                    MessageBox (text, caption, MB_OK);
                                }
                            }
                            if ( pCert )
                                pCert->Release ();
                        }
                        else
                        {
                            // We're modifying an existing entry
                            ASSERT (m_pSaferEntries);
                            if ( m_pSaferEntries )
                            {
                                // 1. If original cert has been changed, it must be removed from its 
                                // store and the new one added to the appropriate store
                                // 2. If the security level was changed.  The cert 
                                // removed from the original store, which must be Committed and
                                // released.  The cert must then be added to the new store.
                                // 3. If both the cert and the level have been changed, same as step 2.
                                if ( m_bCertificateChanged )
                                {
                                    CCertificate* pNewCert = new CCertificate (
                                            ::CertDuplicateCertificateContext (m_pCertContext),
                                            pStore);
                                    if ( pNewCert )
                                    {
                                        hr = m_rSaferEntry.SetCertificate (pNewCert);
                                    }
                                }
                            }

                            CString szDescription;
                            m_descriptionEdit.GetWindowText (szDescription);
                            m_rSaferEntry.SetDescription (szDescription);

                            hr = m_rSaferEntry.SetLevel ((DWORD) dwLevel);
                            if ( SUCCEEDED (hr) )
                            {
                                hr = m_rSaferEntry.Save ();
                                if ( SUCCEEDED (hr) )
                                {
                                    pDisallowedStore->Commit ();
                                    pTrustedPublishersStore->Commit ();

                                    if ( m_lNotifyHandle )
                                        MMCPropertyChangeNotify (
                                                m_lNotifyHandle,  // handle to a notification
                                                (LPARAM) m_pDataObject);          // unique identifier
 
                                    if ( m_pbObjectCreated )
                                        *m_pbObjectCreated = true;

                                    m_rSaferEntry.Refresh ();
                                    
                                    GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_SHOW);
                                    GetDlgItem (IDC_CERT_ENTRY_LAST_MODIFIED)->ShowWindow (SW_SHOW);
                                    GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->UpdateWindow ();
                                    GetDlgItem (IDC_CERT_ENTRY_LAST_MODIFIED)->UpdateWindow ();
                                    SetDlgItemText (IDC_CERT_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

                                    m_bDirty = false;
                                }
                                else
                                {
                                    CString text;
                                    CString caption;

                                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                                    text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

                                    MessageBox (text, caption, MB_OK);
                                }
                            }
                            if ( pCert )
                                pCert->Release ();
                        }

                        pDisallowedStore->Release ();
                    }

                    pTrustedPublishersStore->Release ();
                }
            }
        }
    }

    if ( !m_bDirty )
        return CSaferPropertyPage::OnApply();
    else
        return FALSE;
}

void CSaferEntryCertificatePropertyPage::OnChangeCertEntryDescription() 
{
    m_bDirty = true;
    SetModified (); 
}

void CSaferEntryCertificatePropertyPage::OnSelchangeCertEntrySecurityLevel() 
{
    m_bDirty = true;
    SetModified (); 
}

void CSaferEntryCertificatePropertyPage::OnSaferCertView() 
{
    LaunchCommonCertDialog ();
}

void CSaferEntryCertificatePropertyPage::LaunchCommonCertDialog ()
{
    _TRACE (1, L"Entering CSaferEntryCertificatePropertyPage::LaunchCommonCertDialog\n");
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    if ( !m_pCertContext )
        return;

    HRESULT                                 hr = S_OK;
    CWaitCursor                             waitCursor;
    CTypedPtrList<CPtrList, CCertStore*>    storeList;

    //  Add the Root store first on a remote machine.
    if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
    {
        storeList.AddTail (new CCertStore (CERTMGR_LOG_STORE,
                CERT_STORE_PROV_SYSTEM,
                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                (LPCWSTR) m_pCompData->GetManagedComputer (),
                ROOT_SYSTEM_STORE_NAME,
                ROOT_SYSTEM_STORE_NAME,
                _T (""), ROOT_STORE,
                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                m_pCompData->m_pConsole));
    }

    hr = m_pCompData->EnumerateLogicalStores (&storeList);
    if ( SUCCEEDED (hr) )
    {
          POSITION pos = 0;
          POSITION prevPos = 0;

          // Validate store handles
        for (pos = storeList.GetHeadPosition ();
                pos;)
        {
               prevPos = pos;
            CCertStore* pStore = storeList.GetNext (pos);
            ASSERT (pStore);
            if ( pStore )
            {
                // Do not open the userDS store
                if ( USERDS_STORE == pStore->GetStoreType () )
                {
                    storeList.RemoveAt (prevPos);
                    pStore->Release ();
                    pStore = 0;
                }
                else
                {
                    if ( !pStore->GetStoreHandle () )
                    {
                        CString caption;
                        CString text;
                        CThemeContextActivator activator;

                        text.FormatMessage (IDS_CANT_OPEN_STORE_AND_FAIL, pStore->GetLocalizedName ());
                        VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
                        MessageBox (text, caption, MB_ICONWARNING | MB_OK);
                        break;
                    }
                }
            }
        }

          // Proceed only if all handles are valid 
          if ( SUCCEEDED (hr) )
          {
             CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
             // security review 2/25/2002 BryanWal ok
             ::ZeroMemory (&vcs, sizeof (vcs));
             vcs.dwSize = sizeof (vcs);
             vcs.hwndParent = m_hWnd;

             //  Set these flags only on a remote machine.
             if ( !IsLocalComputername (m_pCompData->GetManagedComputer ()) )
                 vcs.dwFlags = CRYPTUI_DONT_OPEN_STORES | CRYPTUI_WARN_UNTRUSTED_ROOT;
             else
                 vcs.dwFlags = 0;

             vcs.pCertContext = m_pCertContext;
             vcs.cStores = (DWORD)storeList.GetCount ();
             vcs.rghStores = new HCERTSTORE[vcs.cStores];
             if ( vcs.rghStores )
             {
                 CCertStore*        pStore = 0;
                 DWORD          index = 0;

                 for (pos = storeList.GetHeadPosition ();
                         pos && index < vcs.cStores;
                         index++)
                 {
                     pStore = storeList.GetNext (pos);
                     ASSERT (pStore);
                     if ( pStore )
                     {
                         vcs.rghStores[index] = pStore->GetStoreHandle ();
                     }
                 }

                 BOOL fPropertiesChanged = FALSE;
                 _TRACE (0, L"Calling CryptUIDlgViewCertificate()\n");
                 CThemeContextActivator activator;
                 ::CryptUIDlgViewCertificate (&vcs, &fPropertiesChanged);

                 delete vcs.rghStores;
             }
             else
                 hr = E_OUTOFMEMORY;
        }

        while (!storeList.IsEmpty () )
        {
            CCertStore* pStore = storeList.RemoveHead ();
            if ( pStore )
            {
                pStore->Close ();
                pStore->Release ();
            }
        }
    }

    _TRACE (-1, L"Leaving CSaferEntryCertificatePropertyPage::LaunchCommonCertDialog: 0x%x\n", hr);
}

void CSaferEntryCertificatePropertyPage::OnSetfocusCertEntrySubjectName() 
{
    if ( m_bFirst )
    {
        SendDlgItemMessage (IDC_CERT_ENTRY_SUBJECT_NAME, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentrycertificatepropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryCertificatePropertyPage.h
//
//  Contents:   Declaration of CSaferEntryCertificatePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
#define AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryCertificatePropertyPage.h : header file
//
#include <cryptui.h>
#include "SaferUtil.h"
#include "SaferPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryCertificatePropertyPage dialog
class CSaferEntryCertificatePropertyPage : public CSaferPropertyPage
{
// Construction
public:
	CSaferEntryCertificatePropertyPage(CSaferEntry& rSaferEntry,
            CSaferEntries* pSaferEntries,
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            CCertMgrComponentData* pCompData,
            bool bNew,
            IGPEInformation* pGPEInformation,
            bool bIsMachine,
            bool* pbObjectCreated = 0);
	~CSaferEntryCertificatePropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryCertificatePropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_CERTIFICATE };
	CEdit	m_descriptionEdit;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryCertificatePropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryCertificatePropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnCertEntryBrowse();
	afx_msg void OnChangeCertEntryDescription();
	afx_msg void OnSelchangeCertEntrySecurityLevel();
	afx_msg void OnSaferCertView();
	afx_msg void OnSetfocusCertEntrySubjectName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void GetCertFromSignedFile (const CString& szFilePath);
    virtual void DoContextHelp (HWND hWndControl);
    void LaunchCommonCertDialog ();

private:
	CCertStore*                         m_pOriginalStore;
    CRYPTUI_SELECTCERTIFICATE_STRUCT    m_selCertStruct;
    bool                                m_bStoresEnumerated;
    bool                                m_bCertificateChanged;
    PCCERT_CONTEXT	                    m_pCertContext;
    CSaferEntries*                      m_pSaferEntries;
    IGPEInformation*                    m_pGPEInformation;
    bool                                m_bFirst;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYCERTIFICATEPROPERTYPAGE_H__C75F826D_B054_45CC_B440_34F44645FF90__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentry.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntry.h
//
//  Contents:   Declaration of CSaferEntry
//
//----------------------------------------------------------------------------

#if !defined(AFX_SAFERENTRY_H__CF4D8002_5484_40E9_B4F6_CC4A0030D738__INCLUDED_)
#define AFX_SAFERENTRY_H__CF4D8002_5484_40E9_B4F6_CC4A0030D738__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <winsafer.h>
#include "cookie.h"
#include "certifct.h"
#include "SaferUtil.h"

typedef enum {
    SAFER_ENTRY_TYPE_UNKNOWN = 0,
    SAFER_ENTRY_TYPE_HASH,
    SAFER_ENTRY_TYPE_PATH,
    SAFER_ENTRY_TYPE_URLZONE,
    SAFER_ENTRY_TYPE_CERT
} SAFER_ENTRY_TYPE;

extern const DWORD AUTHZ_UNKNOWN_LEVEL;

class CSaferEntry : public CCertMgrCookie  
{
public:
	CSaferEntry (
            SAFER_ENTRY_TYPE    saferEntryType,
            bool bIsMachine, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName, 
            PSAFER_IDENTIFICATION_HEADER pAuthzInfo,
            DWORD   dwLevelID,
            IGPEInformation* m_pGPEInformation,
            CCertificate*       pCertificate,
            CSaferEntries*      pSaferEntries,
            CRSOPObjectArray&   rRSOPArray,
            PCWSTR              pszRSOPRegistryKey = 0);

    virtual ~CSaferEntry();

public:
	virtual void Refresh ();
    CString GetRSOPRegistryKey () const;
	void SetHashFriendlyName (const CString& szFriendlyName);
	CString GetHashFriendlyName ();
	void SetURLZoneID (DWORD dwURLZoneID);
    int CompareLastModified (const CSaferEntry& saferEntry) const;
	HRESULT Delete (bool bCommit);
	HRESULT GetCertificate (CCertificate** ppCert);
	CString GetDescription ();
	HRESULT GetFlags (DWORD& dwFlags);
    HRESULT GetHash (
                BYTE rgbFileHash[SAFER_MAX_HASH_SIZE], 
                DWORD& cbFileHash, 
                __int64& m_nFileSize, 
                ALG_ID& algId) const;
	CString GetShortLastModified () const;
	CString GetLongLastModified () const;
	DWORD GetLevel () const;
	CString GetLevelFriendlyName () const;
	CString GetPath ();
	HRESULT GetSaferEntriesNode (CSaferEntries** ppSaferEntries);
    SAFER_ENTRY_TYPE GetType () const;
   	CString GetTypeString () const;
	DWORD GetURLZoneID() const;
    HRESULT PolicyChanged();
	HRESULT Save ();
	HRESULT SetCertificate (CCertificate* pCert);
	void SetDescription(const CString& szDescription);
	void SetFlags (DWORD dwFlags);
	HRESULT SetHash (
                BYTE    rgbFileHash[SAFER_MAX_HASH_SIZE], 
                DWORD   cbFileHash, 
                __int64 m_nFileSize, 
                ALG_ID   hashAlgid);
	HRESULT SetLevel (DWORD dwLevelID);
	void SetPath (const CString& szPath);
    CString GetDisplayName () const
    {
        return m_szDisplayName;
    }

private:
	CString m_szHashFriendlyName;
	DWORD                               m_dwFlags;
    PSAFER_IDENTIFICATION_HEADER   m_pAuthzInfo;
    DWORD                               m_dwLevelID;
    DWORD                               m_dwOriginalLevelID;
    CString                             m_szLevelFriendlyName;
    CCertificate*                       m_pCertificate;
    CSaferEntries*                      m_pSaferEntries;
    IGPEInformation*                    m_pGPEInformation;
    const SAFER_ENTRY_TYPE              m_saferEntryType;
    CString                             m_szDescription;
    CString                             m_szPath;
    bool                                m_bDeleted;
    BYTE                                m_rgbFileHash[SAFER_MAX_HASH_SIZE];
    DWORD                               m_cbFileHash;
    DWORD                               m_UrlZoneId;
    __int64                             m_nHashFileSize;
    ALG_ID                              m_hashAlgid;
    CString                             m_szDisplayName;
    CString                             m_szRSOPRegistryKey;
    const bool                          m_bIsComputer;
};

#endif // !defined(AFX_SAFERENTRY_H__CF4D8002_5484_40E9_B4F6_CC4A0030D738__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentryinternetzonepropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryInternetZonePropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryInternetZonePropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryInternetZonePropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "certmgr.h"
#include "compdata.h"
#include "SaferEntryInternetZonePropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryInternetZonePropertyPage property page

CSaferEntryInternetZonePropertyPage::CSaferEntryInternetZonePropertyPage(
        CSaferEntry& rSaferEntry, 
        bool bNew, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        CCertMgrComponentData* pCompData,
        bool bIsMachine,
        bool* pbObjectCreated /* = 0 */) 
: CSaferPropertyPage(CSaferEntryInternetZonePropertyPage::IDD, pbObjectCreated, 
        pCompData, rSaferEntry, bNew, lNotifyHandle, pDataObject, bReadOnly,
        bIsMachine)
{
    //{{AFX_DATA_INIT(CSaferEntryInternetZonePropertyPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CSaferEntryInternetZonePropertyPage::~CSaferEntryInternetZonePropertyPage()
{
}

void CSaferEntryInternetZonePropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CSaferPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSaferEntryInternetZonePropertyPage)
    DDX_Control(pDX, IDC_IZONE_ENTRY_ZONES, m_internetZoneCombo);
    DDX_Control(pDX, IDC_IZONE_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryInternetZonePropertyPage, CSaferPropertyPage)
    //{{AFX_MSG_MAP(CSaferEntryInternetZonePropertyPage)
    ON_CBN_SELCHANGE(IDC_IZONE_ENTRY_SECURITY_LEVEL, OnSelchangeIzoneEntrySecurityLevel)
    ON_CBN_SELCHANGE(IDC_IZONE_ENTRY_ZONES, OnSelchangeIzoneEntryZones)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CSaferEntryInternetZonePropertyPage message handlers
BOOL CSaferEntryInternetZonePropertyPage::OnInitDialog() 
{
    CSaferPropertyPage::OnInitDialog();
    

    // Set up User Notification combo box
    DWORD   dwFlags = 0;
    m_rSaferEntry.GetFlags (dwFlags);

    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        CPolicyKey policyKey (m_pCompData->m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsMachine);
        InitializeSecurityLevelComboBox (m_securityLevelCombo, false,
                m_rSaferEntry.GetLevel (), policyKey.GetKey (), 
                m_pCompData->m_pdwSaferLevels,
                m_bIsMachine);

        InitializeInternetZoneComboBox (m_rSaferEntry.GetURLZoneID ());

        SendDlgItemMessage (IDC_IZONE_ENTRY_DESCRIPTION, EM_LIMITTEXT, SAFER_MAX_DESCRIPTION_SIZE-1, 0);
        SetDlgItemText (IDC_IZONE_ENTRY_DESCRIPTION, m_rSaferEntry.GetDescription ());

        SetDlgItemText (IDC_IZONE_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

        if ( m_bReadOnly )
        {
            m_securityLevelCombo.EnableWindow (FALSE);
            m_internetZoneCombo.EnableWindow (FALSE);
        }

        if ( !m_bDirty )
        {
            CString szText;

            VERIFY (szText.LoadString (IDS_URLZONE_TITLE));
            SetDlgItemText (IDC_URLZONE_TITLE, szText);
        }
        else
        {
            GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_HIDE);
            GetDlgItem (IDC_IZONE_ENTRY_LAST_MODIFIED)->ShowWindow (SW_HIDE);
        }
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


void CSaferEntryInternetZonePropertyPage::InitializeInternetZoneComboBox (DWORD UrlZoneId)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CString szText;
    VERIFY (szText.LoadString (IDS_URLZONE_LOCAL_MACHINE));
    int nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_LOCAL_MACHINE == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_LOCAL_MACHINE));

    }

    VERIFY (szText.LoadString (IDS_URLZONE_INTRANET));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_INTRANET == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_INTRANET));
    }
    
    VERIFY (szText.LoadString (IDS_URLZONE_TRUSTED));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_TRUSTED == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_TRUSTED));
    }
    
    VERIFY (szText.LoadString (IDS_URLZONE_INTERNET));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_INTERNET == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_INTERNET));
    }
    
    VERIFY (szText.LoadString (IDS_URLZONE_UNTRUSTED));
    nItem = m_internetZoneCombo.AddString (szText);
    ASSERT (nItem >= 0);
    if ( nItem >= 0 )
    {
        if ( URLZONE_UNTRUSTED == UrlZoneId )
            VERIFY (CB_ERR != m_internetZoneCombo.SetCurSel (nItem));
        VERIFY (CB_ERR != m_internetZoneCombo.SetItemData (nItem, URLZONE_UNTRUSTED));
    }
    
}


void CSaferEntryInternetZonePropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryInternetZonePropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_IZONE_ENTRY_ZONES, IDH_IZONE_ENTRY_ZONES,
        IDC_IZONE_ENTRY_SECURITY_LEVEL, IDH_IZONE_ENTRY_SECURITY_LEVEL,
        IDC_IZONE_ENTRY_DESCRIPTION, IDH_IZONE_ENTRY_DESCRIPTION,
        IDC_IZONE_ENTRY_LAST_MODIFIED, IDH_IZONE_ENTRY_LAST_MODIFIED,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_IZONE_ENTRY_ZONES:
    case IDC_IZONE_ENTRY_SECURITY_LEVEL:
    case IDC_IZONE_ENTRY_DESCRIPTION:
    case IDC_IZONE_ENTRY_LAST_MODIFIED:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryInternetZonePropertyPage::DoContextHelp\n");
}

BOOL CSaferEntryInternetZonePropertyPage::OnApply() 
{
    if ( m_bDirty && !m_bReadOnly )
    {
        // Set the level
        int nCurSel = m_securityLevelCombo.GetCurSel ();
        ASSERT (CB_ERR != nCurSel);
        m_rSaferEntry.SetLevel ((DWORD) m_securityLevelCombo.GetItemData (nCurSel));

        int nSel = m_internetZoneCombo.GetCurSel ();
        ASSERT (CB_ERR != nSel);
        if ( CB_ERR != nSel )
        {
            DWORD_PTR   dwURLZoneID = m_internetZoneCombo.GetItemData (nSel);
            ASSERT (CB_ERR != dwURLZoneID);
            if ( CB_ERR != dwURLZoneID )
                m_rSaferEntry.SetURLZoneID ((DWORD) dwURLZoneID);
        }

        HRESULT hr = m_rSaferEntry.Save ();
        if ( SUCCEEDED (hr) )
        {
            if ( m_lNotifyHandle )
                MMCPropertyChangeNotify (
                        m_lNotifyHandle,  // handle to a notification
                        (LPARAM) m_pDataObject);          // unique identifier
 
            if ( m_pbObjectCreated )
                *m_pbObjectCreated = true;

            m_rSaferEntry.Refresh ();
            GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_SHOW);
            GetDlgItem (IDC_IZONE_ENTRY_LAST_MODIFIED)->ShowWindow (SW_SHOW);
            GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->UpdateWindow ();
            GetDlgItem (IDC_IZONE_ENTRY_LAST_MODIFIED)->UpdateWindow ();
            SetDlgItemText (IDC_IZONE_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());
            m_bDirty = false;
        }
        else
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
            return FALSE;
        }
    }
    return CSaferPropertyPage::OnApply();
}

void CSaferEntryInternetZonePropertyPage::OnSelchangeIzoneEntrySecurityLevel() 
{
    m_bDirty = true;
    SetModified ();
}

void CSaferEntryInternetZonePropertyPage::OnSelchangeIzoneEntryZones() 
{
    int nSel = m_internetZoneCombo.GetCurSel ();
    ASSERT (CB_ERR != nSel);
    if ( CB_ERR != nSel )
    {
        DWORD_PTR   dwURLZoneID = m_internetZoneCombo.GetItemData (nSel);
        ASSERT (CB_ERR != dwURLZoneID);
        if ( CB_ERR != dwURLZoneID )
            m_rSaferEntry.SetURLZoneID ((DWORD) dwURLZoneID);
    }
    
    SetDlgItemText (IDC_IZONE_ENTRY_DESCRIPTION, m_rSaferEntry.GetDescription ());
    m_bDirty = true;
    SetModified ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentryhashpropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryHashPropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryHashPropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryHashPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include <Imagehlp.h>
#include "certmgr.h"
#include "compdata.h"
#include "SaferEntryHashPropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

PCWSTR pcszNEWLINE = L"\x00d\x00a";

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryHashPropertyPage property page

CSaferEntryHashPropertyPage::CSaferEntryHashPropertyPage(
        CSaferEntry& rSaferEntry, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        CCertMgrComponentData* pCompData,
        bool bIsMachine,
        bool* pbObjectCreated /* = 0 */) 
: CSaferPropertyPage(CSaferEntryHashPropertyPage::IDD, pbObjectCreated, 
        pCompData, rSaferEntry, false, lNotifyHandle, pDataObject, bReadOnly,
        bIsMachine),
    m_cbFileHash (0),
    m_hashAlgid (0),
    m_bFirst (true)
{
    // security review 2/25/2002 BryanWal ok
    ::ZeroMemory (&m_nFileSize, sizeof (m_nFileSize));
    ::ZeroMemory (m_rgbFileHash, sizeof (m_rgbFileHash));

    //{{AFX_DATA_INIT(CSaferEntryHashPropertyPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_rSaferEntry.GetHash (m_rgbFileHash, m_cbFileHash, m_nFileSize, 
            m_hashAlgid);
}

CSaferEntryHashPropertyPage::~CSaferEntryHashPropertyPage()
{
}

void CSaferEntryHashPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CSaferPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSaferEntryHashPropertyPage)
    DDX_Control(pDX, IDC_HASH_ENTRY_HASHFILE_DETAILS, m_hashFileDetailsEdit);
    DDX_Control(pDX, IDC_HASH_ENTRY_DESCRIPTION, m_descriptionEdit);
    DDX_Control(pDX, IDC_HASH_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryHashPropertyPage, CSaferPropertyPage)
    //{{AFX_MSG_MAP(CSaferEntryHashPropertyPage)
    ON_BN_CLICKED(IDC_HASH_ENTRY_BROWSE, OnHashEntryBrowse)
    ON_EN_CHANGE(IDC_HASH_ENTRY_DESCRIPTION, OnChangeHashEntryDescription)
    ON_CBN_SELCHANGE(IDC_HASH_ENTRY_SECURITY_LEVEL, OnSelchangeHashEntrySecurityLevel)
    ON_EN_CHANGE(IDC_HASH_HASHED_FILE_PATH, OnChangeHashHashedFilePath)
    ON_EN_SETFOCUS(IDC_HASH_HASHED_FILE_PATH, OnSetfocusHashHashedFilePath)
    ON_EN_CHANGE(IDC_HASH_ENTRY_HASHFILE_DETAILS, OnChangeHashEntryHashfileDetails)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryHashPropertyPage message handlers
void CSaferEntryHashPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryHashPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_HASH_ENTRY_HASHFILE_DETAILS, IDH_HASH_ENTRY_APPLICATION_NAME,
        IDC_HASH_ENTRY_BROWSE, IDH_HASH_ENTRY_BROWSE,
        IDC_HASH_ENTRY_DESCRIPTION, IDH_HASH_ENTRY_DESCRIPTION,
        IDC_HASH_ENTRY_LAST_MODIFIED, IDH_HASH_ENTRY_LAST_MODIFIED,
        IDC_HASH_HASHED_FILE_PATH, IDH_HASH_HASHED_FILE_PATH,
        IDC_HASH_ENTRY_SECURITY_LEVEL, IDH_HASH_ENTRY_SECURITY_LEVEL,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_HASH_ENTRY_HASHFILE_DETAILS:
    case IDC_HASH_ENTRY_BROWSE:
    case IDC_HASH_ENTRY_DESCRIPTION:
    case IDC_HASH_ENTRY_LAST_MODIFIED:
    case IDC_HASH_HASHED_FILE_PATH:
    case IDC_HASH_ENTRY_SECURITY_LEVEL:
        if ( !::WinHelp (
                hWndControl,
                GetF1HelpFilename(),
                HELP_WM_HELP,
                (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryHashPropertyPage::DoContextHelp\n");
}

BOOL CSaferEntryHashPropertyPage::OnInitDialog() 
{
    CSaferPropertyPage::OnInitDialog();
    
    DWORD   dwFlags = 0;
    m_rSaferEntry.GetFlags (dwFlags);

    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        CPolicyKey policyKey (m_pCompData->m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsMachine);
        InitializeSecurityLevelComboBox (m_securityLevelCombo, false,
                m_rSaferEntry.GetLevel (), policyKey.GetKey (), 
                m_pCompData->m_pdwSaferLevels,
                m_bIsMachine);

        m_hashFileDetailsEdit.SetWindowText (m_rSaferEntry.GetHashFriendlyName ());
        m_descriptionEdit.SetLimitText (SAFER_MAX_DESCRIPTION_SIZE-1);
        m_descriptionEdit.SetWindowText (m_rSaferEntry.GetDescription ());

        SetDlgItemText (IDC_HASH_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());

        SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_LIMITTEXT, 64);

        if ( m_bReadOnly )
        {
            SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_SETREADONLY, TRUE);

            m_securityLevelCombo.EnableWindow (FALSE);
            GetDlgItem (IDC_HASH_ENTRY_BROWSE)->EnableWindow (FALSE);
        
            m_descriptionEdit.SendMessage (EM_SETREADONLY, TRUE);

            m_hashFileDetailsEdit.SendMessage (EM_SETREADONLY, TRUE);
        }

        if ( m_cbFileHash )
        {
            // Only allow editing on the creation of a new hash
            SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_SETREADONLY, TRUE);

            FormatAndDisplayHash ();

            CString szText;

            VERIFY (szText.LoadString (IDS_HASH_TITLE));
            SetDlgItemText (IDC_HASH_TITLE, szText);
            SetDlgItemText (IDC_HASH_INSTRUCTIONS, L"");
        }
        else
        {
            GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_HIDE);
            GetDlgItem (IDC_HASH_ENTRY_LAST_MODIFIED)->ShowWindow (SW_HIDE);
        }
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
 *  [alanau]
 *
 *  MyGetFileVersionInfo: Maps a file directly without using LoadLibrary.  This ensures
 *   that the right version of the file is examined without regard to where the loaded image
 *   is.  Since this is a local function, it allocates the memory which is freed by the caller.
 *   This makes it slightly more efficient than a GetFileVersionInfoSize/GetFileVersionInfo pair.
 */
BOOL CSaferEntryHashPropertyPage::MyGetFileVersionInfo(PCWSTR lpszFilename, PVOID *lpVersionInfo)
{
    HINSTANCE   hinst = 0;
    HRSRC       hVerRes = 0;
    HANDLE      hFile = NULL;
    HANDLE      hMapping = NULL;
    LPVOID      pDllBase = NULL;
    VERHEAD     *pVerHead = 0;
    BOOL        bResult = FALSE;
    DWORD       dwHandle = 0;
    DWORD       dwLength = 0;

    ASSERT (lpszFilename);
    if ( !lpszFilename )
        return FALSE;

    ASSERT (lpVersionInfo);
    if (!lpVersionInfo)
        return FALSE;

    *lpVersionInfo = NULL;

    // security review 2/25/2002 BryanWal ok - we're only opening this to read
    // We shouldn't have to worry about file name canonicalization here since 
    // we're only opening the file to read and the user can only do this by 
    // hand here.
    __try {        
        hFile = ::CreateFile( lpszFilename,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                0,
                NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            // security review 2/25/2002 BryanWal ok - file path is from GetOpenFileName
            hMapping = ::CreateFileMapping (hFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL);
            if ( hMapping )
            {
                // NTRAID - 554171 Safer: MapViewOfFileEx should be protected with SEH - potential exception
                pDllBase = ::MapViewOfFileEx( hMapping,
                                           FILE_MAP_READ,
                                           0,
                                           0,
                                           0,
                                           NULL);
                if ( pDllBase )
                {
                    hinst = (HMODULE)((ULONG_PTR)pDllBase | 0x00000001);


                    hVerRes = FindResource(hinst, MAKEINTRESOURCE(VS_VERSION_INFO), VS_FILE_INFO);
                    if (hVerRes == NULL)
                    {
                        // Probably a 16-bit file.  Fall back to system APIs.
                        dwLength = GetFileVersionInfoSize(lpszFilename, &dwHandle);
                        if( !dwLength )
                        {
                            if(!GetLastError())
                                SetLastError(ERROR_RESOURCE_DATA_NOT_FOUND);
                            __leave;
                        }

                        *lpVersionInfo = ::LocalAlloc (LPTR, dwLength);
                        if ( !(*lpVersionInfo) )
                            __leave;

                        if(!GetFileVersionInfo(lpszFilename, 0, dwLength, *lpVersionInfo))
                            __leave;

                        bResult = TRUE;
                        __leave;
                    }   
            
                    pVerHead = (VERHEAD*)LoadResource(hinst, hVerRes);
                    if ( pVerHead )
                    {
                        // security review 2/25/2002 BryanWal
                        *lpVersionInfo = ::LocalAlloc (LPTR, pVerHead->wTotLen);
                        if ( *lpVersionInfo )
                        {
                            // security review 2/25/2002 BryanWal ok
                            memcpy(*lpVersionInfo, (PVOID)pVerHead, pVerHead->wTotLen);
                            bResult = TRUE;
                        }
                    }
                }
            }
        }
    } 
    __finally 
    {
        if (hFile)
            CloseHandle(hFile);
        if (hMapping)
            CloseHandle(hMapping);
        if (pDllBase)
            UnmapViewOfFile(pDllBase);
        if (*lpVersionInfo && bResult == FALSE)
            ::LocalFree (*lpVersionInfo);
    }

    return bResult;
}


///////////////////////////////////////////////////////////////////////////////
//
// Method:  OnHashEntryBrowse
//
// Purpose: Allow the user to browse for a file, then create a hash and an
//          output string for use as the friendly name, using the following
//          rules:
//
//          If either the product name or description information is found in 
//          the version resource, provide the following (in order):
//
//          Description
//          Product name
//          Company name
//          File name
//          Fixed file version
//
//          Details:
//          1) Use the fixed file version, since that is what is shown in the 
//              Windows Explorer properties.
//          2) Prefer the long file name to the 8.3 name.
//          3) Delimit the fields with '\n'.
//          4) If the field is missing, don't output the field or the delimiter
//          5) Instead of displaying the file version on a new line, display 
//              it after the file name in parens, as in "Filename (1.0.0.0)"
//          6) Since we are limited to 256 TCHARs, we have to accomodate long 
//              text. First, format the text as described above to determine 
//              its length. If it is too long, truncate one field at a time in 
//              the following order: Company name, Description, Product name. 
//              To truncate a field, set it to a maximum of 60 TCHARs, then 
//              append a "...\n" to visually indicate that the field was 
//              truncated. Lastly, if the text is still to long, use the 8.3 
//              file name instead of the long filename.
//
//          If neither the product name nor description information is found, 
//          provide the following (in order):
//
//          File name
//          File size
//          File last modified date
//
//          Details:
//          1) If the file size is < 1 KB, display the number in bytes, as in 
//              "123 bytes". If the file size is >= 1 KB, display in KB, as in 
//              "123 KB". Of course, 1 KB is 1024 bytes. Note that the older 
//              style format "123K" is no longer used in Windows.
//          2) For the last modified date, use the short format version in the 
//              user's current locale.
//          3) Delimit the fields with '\n'.
//          4) If the field is missing, don't output the field or the delimiter
//
///////////////////////////////////////////////////////////////////////////////

void CSaferEntryHashPropertyPage::OnHashEntryBrowse() 
{
    CString szFileFilter;
    VERIFY (szFileFilter.LoadString (IDS_SAFER_PATH_ENTRY_FILE_FILTER));

    // replace "|" with 0;
    // security review 2/25/2002 BryanWal ok
    const size_t  nFilterLen = wcslen (szFileFilter) + 1; // + 1 for null term.
    PWSTR   pszFileFilter = new WCHAR [nFilterLen];
    if ( pszFileFilter )
    {
        // security review 2/25/2002 BryanWal ok
        wcscpy (pszFileFilter, szFileFilter);
        for (int nIndex = 0; nIndex < nFilterLen; nIndex++)
        {
            if ( L'|' == pszFileFilter[nIndex] )
                pszFileFilter[nIndex] = 0;
        }

        WCHAR           szFile[MAX_PATH];
        // security review 2/25/2002 BryanWal ok
        ::ZeroMemory (szFile, sizeof (szFile));
        ASSERT (wcslen (m_szLastOpenedFile) < MAX_PATH);
        // security review 2/25/2002 BryanWal ok - m_szLastOpenedFile always comes from GetOpenFileName ()
        wcsncpy (szFile, m_szLastOpenedFile, MAX_PATH - 1);

        OPENFILENAME    ofn;
        // security review 2/25/2002 BryanWal ok
        ::ZeroMemory (&ofn, sizeof (ofn));

        ofn.lStructSize = sizeof (OPENFILENAME);
        ofn.hwndOwner = m_hWnd;
        ofn.lpstrFilter = (PCWSTR) pszFileFilter; 
        ofn.lpstrFile = szFile; 
        ofn.nMaxFile = MAX_PATH; 
        ofn.Flags = OFN_DONTADDTORECENT | 
            OFN_FORCESHOWHIDDEN | OFN_HIDEREADONLY; 


        CThemeContextActivator activator;
        BOOL bResult = ::GetOpenFileName (&ofn);
        if ( bResult )
        {
            m_szLastOpenedFile = ofn.lpstrFile;
            // security review 2/25/2002 BryanWal ok - filename is from GetOpenFileName ()
            HANDLE  hFile = ::CreateFile(
                    ofn.lpstrFile,                         // file name
                    GENERIC_READ,                      // access mode
                    FILE_SHARE_READ,                          // share mode
                    0, // SD
                    OPEN_EXISTING,                // how to create
                    FILE_ATTRIBUTE_NORMAL,                 // file attributes
                    0 );                       // handle to template file
            if ( INVALID_HANDLE_VALUE != hFile )
            {
                bResult = GetFileSizeEx(
                        hFile,              // handle to file
                        (PLARGE_INTEGER) &m_nFileSize);  // file size
                if ( !bResult )
                {
                    DWORD   dwErr = GetLastError ();
                    CloseHandle (hFile);
                    _TRACE (0, L"GetFileSizeEx () failed: 0x%x\n", dwErr);
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    text.FormatMessage (IDS_CANNOT_GET_FILESIZE, ofn.lpstrFile, 
                            GetSystemMessage (dwErr));

                    MessageBox (text, caption, MB_OK);
                    
                    return;
                }

                if ( 0 == m_nFileSize )
                {
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    text.FormatMessage (IDS_ZERO_BYTE_FILE_CANNOT_HASH, ofn.lpstrFile);

                    MessageBox (text, caption, MB_OK);
                    
                    return;
                }

                FILETIME    ftLastModified;
                HRESULT     hr = S_OK;

                bResult = ::GetFileTime (hFile, // handle to file
                        0,    // creation time
                        0,  // last access time
                        &ftLastModified);    // last write time

                // security review 2/25/2002 BryanWal ok
                ::ZeroMemory (m_rgbFileHash, sizeof (m_rgbFileHash));
    
                // NTRAID 622838 SAFER UI: Always use MD5 hash on DLLs.
                if ( FileIsDLL (ofn.lpstrFile) )
                {
                    // File is DLL - look for MD5 hash
                    m_hashAlgid = 0;
                    hr = ComputeMD5Hash (hFile, m_rgbFileHash, m_cbFileHash);
                    if ( SUCCEEDED (hr) )
                    {
                        if ( SHA1_HASH_LEN == m_cbFileHash )
                            m_hashAlgid = CALG_SHA;
                        else if ( MD5_HASH_LEN == m_cbFileHash )
                            m_hashAlgid = CALG_MD5;
                        else
                        {
                            ASSERT (0);
                        }
                    }
                }
                else
                {
                    hr = GetSignedFileHash (ofn.lpstrFile, m_rgbFileHash, 
                            &m_cbFileHash, &m_hashAlgid);
                    if ( FAILED (hr) )
                    {
                        if ( TRUST_E_NOSIGNATURE == hr )
                        {
                            // File is not signed - look for MD5 hash
                            m_hashAlgid = 0;
                            hr = ComputeMD5Hash (hFile, m_rgbFileHash, m_cbFileHash);
                            if ( SUCCEEDED (hr) )
                            {
                                if ( SHA1_HASH_LEN == m_cbFileHash )
                                    m_hashAlgid = CALG_SHA;
                                else if ( MD5_HASH_LEN == m_cbFileHash )
                                    m_hashAlgid = CALG_MD5;
                                else
                                {
                                    ASSERT (0);
                                }
                            }
                        }
                        else
                        {
                            // NTRAID #476946 SAFER UI: If hash of signed file 
                            // fails, MD5 hash should not be called
                            CString text;
                            CString caption;

                            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                            text.FormatMessage (IDS_SIGNED_FILE_HASH_FAILURE, 
                                    ofn.lpstrFile, GetSystemMessage (hr));

                            MessageBox (text, caption, MB_OK);
                    
                            return;
                        }
                    }
                }

                VERIFY (CloseHandle (hFile));
                hFile = 0;

                if ( SUCCEEDED (hr) )
                {
                    FormatAndDisplayHash ();

                    PBYTE pData = 0;
                    bResult = MyGetFileVersionInfo (ofn.lpstrFile, (LPVOID*) &pData);
                    if ( bResult )
                    {
                        CString infoString = BuildHashFileInfoString (pData);
                        m_hashFileDetailsEdit.SetWindowText (infoString);


                        m_bDirty = true;
                        SetModified ();
                    }
                    else
                    {
                        CString infoString (wcsrchr(ofn.lpstrFile, L'\\') + 1);
                        CString szDate;

                        infoString += pcszNEWLINE;
                        WCHAR   szBuffer[32];
                        CString szText;
                        if ( m_nFileSize < 1024 )
                        {
                            // ISSUE - convert to strsafe, wsnprintf?
                            // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
                            wsprintf (szBuffer, L"%u", m_nFileSize);
                            infoString += szBuffer;
                            VERIFY (szText.LoadString (IDS_BYTES));
                            infoString += L" ";
                            infoString += szText;
                        }
                        else
                        {
                            __int64    nFileSize = m_nFileSize;
                            nFileSize += 1024; // this causes us to round up
                            nFileSize /= 1024;
                            // ISSUE - convert to strsafe, wsnprintf?
                            // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
                            wsprintf (szBuffer, L"%u ", nFileSize);
                            infoString += szBuffer;
                            VERIFY (szText.LoadString (IDS_KB));
                            infoString += L" ";
                            infoString += szText;
                        }

                        hr = FormatDate (ftLastModified, szDate, 
                                DATE_SHORTDATE, true);
                    
                        if ( SUCCEEDED (hr) )
                        {
                            infoString += pcszNEWLINE;
                            infoString += szDate;
                        }

                        m_hashFileDetailsEdit.SetWindowText (infoString);
                        m_bDirty = true;
                        SetModified ();
                    }

                    if ( pData )
                        ::LocalFree (pData);
                }
                else
                {
                    CString text;
                    CString caption;

                    VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                    text.FormatMessage (IDS_CANNOT_HASH_FILE, ofn.lpstrFile, 
                            GetSystemMessage (hr));

                    MessageBox (text, caption, MB_OK);
                }
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"CreateFile (%s, OPEN_EXISTING) failed: 0x%x\n", 
                        ofn.lpstrFile, dwErr);

                CString text;
                CString caption;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_FILE_CANNOT_BE_READ, ofn.lpstrFile, 
                        GetSystemMessage (dwErr));

                MessageBox (text, caption, MB_OK);
            }
        }   

        delete [] pszFileFilter;
    }
}

bool CSaferEntryHashPropertyPage::FileIsDLL (const CString& szFilePath)
{
    _TRACE (1, L"Entering CSaferEntryHashPropertyPage::FileIsDLL (%s)\n", (PCWSTR) szFilePath);
    bool bFileIsDLL = false;

    int nLen = ::WideCharToMultiByte (
            ::GetACP (),    // code page
            0,              // flags            
            szFilePath,     // widechar string to convert
            -1,             // length of widechar string, -1 means assume null termination
            0,              // char buffer to receive string - ignored if next parameter is 0
            0,              // length of buffer, 0 means return needed length
            0,
            0);
    if ( nLen > 0 )
    {
        PSTR pszFilePath = new char[nLen];
        if ( pszFilePath )
        {
            nLen = ::WideCharToMultiByte (
                    ::GetACP (),    // code page
                    0,              // flags            
                    szFilePath,     // widechar string to convert
                    -1,             // length of widechar string, -1 means assume null termination
                    pszFilePath,    // char buffer to receive string
                    nLen,           // length of buffer
                    0,
                    0);
            if ( nLen > 0 )
            {
                PLOADED_IMAGE pLoadedImage = ::ImageLoad (pszFilePath, NULL);
                if ( pLoadedImage )
                {
                    if ( IMAGE_FILE_DLL & pLoadedImage->Characteristics )
                        bFileIsDLL = true;
            
                    VERIFY (::ImageUnload (pLoadedImage));
                }
                else
                {
                    _TRACE (0, L"ImageLoad (%s) failed: 0x%x\n", (PCWSTR) szFilePath, GetLastError ());
                }
            }
            else
            {
                _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", szFilePath, 
                        GetLastError ());
            }

            delete [] pszFilePath;
        }
    }
    else
    {
        _TRACE (0, L"WideCharToMultiByte (%s) failed: 0x%x\n", szFilePath, 
                GetLastError ());
    }

    _TRACE (-1, L"Leaving CSaferEntryHashPropertyPage::FileIsDLL (%s): %s\n", 
            (PCWSTR) szFilePath, bFileIsDLL ? L"true" : L"false");
    return bFileIsDLL;
}

/***************************************************************************\
*
* BuildHashFileInfoString()
*
*  Given a file name, GetVersion retrieves the version
*    information from the specified file.
*
*
\***************************************************************************/
const PWSTR VERSION_INFO_KEY_ROOT = L"\\StringFileInfo\\";

CString CSaferEntryHashPropertyPage::BuildHashFileInfoString (const PVOID pData)
{
    CString szInfoString;
    PVOID   lpInfo = 0;
    UINT    cch = 0;
    CString key;
    WCHAR   szBuffer[10];
    CString keyBase;

    // ISSUE - convert to strsafe, wsnprintf?
    // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
    wsprintf (szBuffer, L"%04X", GetUserDefaultLangID ());
    wcscat (szBuffer, L"04B0");
    
    keyBase = VERSION_INFO_KEY_ROOT;
    keyBase += szBuffer;
    keyBase += L"\\";
    
    CString productName;
    CString description;
    CString companyName;
    CString fileName;
    CString fileVersion;
    CString internalName;
 

    key = keyBase + L"ProductName";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        productName = (PWSTR) lpInfo;
    }
    else
    {
        productName = GetAlternateLanguageVersionInfo (pData, L"ProductName");
    }


    key = keyBase + L"FileDescription";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        description = (PWSTR) lpInfo;
    }
    else
    {
        description = GetAlternateLanguageVersionInfo (pData, L"FileDescription");
    }

    key = keyBase + L"CompanyName";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        companyName = (PWSTR) lpInfo;
    }
    else
    {
        companyName = GetAlternateLanguageVersionInfo (pData, L"CompanyName");
    }

    key = keyBase + L"OriginalFilename";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        fileName = (PWSTR) lpInfo;
    }
    else
    {
        fileName = GetAlternateLanguageVersionInfo (pData, L"OriginalFilename");
    }

    key = keyBase + L"InternalName";
    if ( VerQueryValue (pData, const_cast <PWSTR>((PCWSTR) key), &lpInfo, &cch) )
    {
        internalName = (PWSTR) lpInfo;
    }
    else
    {
        internalName = GetAlternateLanguageVersionInfo (pData, L"InternalName");
    }

    // Get Fixedlength fileInfo
    VS_FIXEDFILEINFO *pFixedFileInfo = 0;
    if ( VerQueryValue (pData, L"\\", (PVOID*) &pFixedFileInfo, &cch) )
    {
        WCHAR   szFileVer[32];

        // ISSUE - convert to strsafe, wsnprintf?
        // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
        wsprintf(szFileVer, L"%u.%u.%u.%u",
                HIWORD(pFixedFileInfo->dwFileVersionMS),
                LOWORD(pFixedFileInfo->dwFileVersionMS),
                HIWORD(pFixedFileInfo->dwFileVersionLS),
                LOWORD(pFixedFileInfo->dwFileVersionLS));
        fileVersion = szFileVer;
    }

    int nLen = 0;
    do {
        szInfoString = ConcatStrings (productName, description, companyName, 
                fileName, fileVersion, internalName);
        nLen = szInfoString.GetLength ();
        if ( nLen >= SAFER_MAX_FRIENDLYNAME_SIZE )
        {
            if ( CheckLengthAndTruncateToken (companyName) )
                continue;

            if ( CheckLengthAndTruncateToken (description) )
                continue;

            if ( CheckLengthAndTruncateToken (productName) )
                continue;

            szInfoString.SetAt (SAFER_MAX_FRIENDLYNAME_SIZE-4, 0);
            szInfoString += L"...";
        }
    } while (nLen >= SAFER_MAX_FRIENDLYNAME_SIZE);

    return szInfoString;
}

CString CSaferEntryHashPropertyPage::GetAlternateLanguageVersionInfo (PVOID pData, PCWSTR pszVersionField)
{
    PVOID   lpInfo = 0;
    UINT    cch = 0;
    CString szInfo;
    UINT    cbTranslate = 0;
    struct LANGANDCODEPAGE {
      WORD wLanguage;
      WORD wCodePage;
    } *lpTranslate;

    // Read the list of languages and code pages.

    VerQueryValue(pData, 
                  L"\\VarFileInfo\\Translation",
                  (LPVOID*)&lpTranslate,
                  &cbTranslate);

    // Read the file description for each language and code page.

    for (UINT i=0; i < (cbTranslate/sizeof(struct LANGANDCODEPAGE)); i++ )
    {
        WCHAR   SubBlock[256];
        // ISSUE - convert to strsafe, wsnprintf?
        // NTRAID Bug9 538774 Security: certmgr.dll : convert to strsafe string functions
        wsprintf( SubBlock, 
                L"\\StringFileInfo\\%04x%04x\\%s",
                lpTranslate[i].wLanguage,
                lpTranslate[i].wCodePage,
                pszVersionField);

        // Retrieve file description for language and code page "i". 
        if ( VerQueryValue(pData, 
                    SubBlock, 
                    &lpInfo, 
                    &cch) )
        {
            szInfo = (PWSTR) lpInfo;
            break;
        }
    }

    return szInfo;
}

bool CSaferEntryHashPropertyPage::CheckLengthAndTruncateToken (CString& token)
{
    bool        bResult = false;
    const int   nMAX_ITEM_LEN = 60;

    int nItemLen = token.GetLength ();
    if ( nItemLen > nMAX_ITEM_LEN )
    {
        token.SetAt (nMAX_ITEM_LEN-5, 0);
        token += L"...";
        token += pcszNEWLINE;
        bResult = true;
    }

    return bResult;
}

CString CSaferEntryHashPropertyPage::ConcatStrings (
            const CString& productName, 
            const CString& description, 
            const CString& companyName,
            const CString& fileName, 
            const CString& fileVersion,
            const CString& internalName)
{
    CString szInfoString;

    // format to be as follows:
    //
    // ATTRIB.EXE (5.1.2600.0)
    // InternalModuleName (if present. If not present just skip)
    // Attribute Utility
    // Microsoft Windows Operating System
    // Microsoft Corporation

    if ( !fileName.IsEmpty () )
        szInfoString += fileName;

    if ( !fileVersion.IsEmpty () )
    {
        szInfoString += L" (";
        szInfoString += fileVersion + L")";
    }

    if ( !szInfoString.IsEmpty () )
        szInfoString += pcszNEWLINE;

    if ( !internalName.IsEmpty () )
        szInfoString += internalName + pcszNEWLINE;

    if ( !description.IsEmpty () )
        szInfoString += description + pcszNEWLINE;

    if ( !productName.IsEmpty () )
        szInfoString += productName + pcszNEWLINE;

    if ( !companyName.IsEmpty () )
        szInfoString += companyName;

    return szInfoString;
}

BOOL CSaferEntryHashPropertyPage::OnApply() 
{
    CString szText;
    CThemeContextActivator activator;

    GetDlgItemText (IDC_HASH_HASHED_FILE_PATH, szText);

    if ( szText.IsEmpty () )
    {
        CString szCaption;

        VERIFY (szCaption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        VERIFY (szText.LoadString (IDS_USER_MUST_ENTER_HASH));

        MessageBox (szText, szCaption, MB_OK);

        GetDlgItem (IDC_HASH_HASHED_FILE_PATH)->SetFocus ();
        return FALSE;
    }

    if ( !m_bReadOnly && m_bDirty )
    {
        if ( !ConvertStringToHash ((PCWSTR) szText) )
        {
            GetDlgItem (IDC_HASH_HASHED_FILE_PATH)->SetFocus ();
            return FALSE;
        }

        // Get image size and hash type
        bool    bBadFormat = false;
        int nFirstColon = szText.Find (L":", 0);
        if ( -1 != nFirstColon )
        {
            int nSecondColon = szText.Find (L":", nFirstColon+1);
            if ( -1 != nSecondColon )
            {
                CString szImageSize = szText.Mid (nFirstColon+1, nSecondColon - (nFirstColon + 1));
                // security review 2/25/2002 BryanWal ok
                CString szHashType = szText.Right (((int) wcslen (szText)) - (nSecondColon + 1));


                m_nFileSize = wcstol (szImageSize, 0, 10);
                m_hashAlgid = wcstol (szHashType, 0, 10);
            }
            else
                bBadFormat = true;
        }
        else
            bBadFormat = true;

        if ( bBadFormat )
        {
            CString caption;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (szText.LoadString (IDS_HASH_STRING_BAD_FORMAT));

            MessageBox (szText, caption, MB_OK);

            return FALSE;
        }
       



        if ( !m_cbFileHash )
        {
            CString caption;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (szText.LoadString (IDS_NO_APPLICATION_SELECTED));

            MessageBox (szText, caption, MB_OK);
            GetDlgItem (IDC_HASH_ENTRY_BROWSE)->SetFocus ();
            return FALSE;
        }

        if ( m_bDirty )
        {
            // Set the level
            int nCurSel = m_securityLevelCombo.GetCurSel ();
            ASSERT (CB_ERR != nCurSel);
            m_rSaferEntry.SetLevel ((DWORD) m_securityLevelCombo.GetItemData (nCurSel));

            // Set description
            m_descriptionEdit.GetWindowText (szText);
            m_rSaferEntry.SetDescription (szText);

            // Set friendly name
            m_hashFileDetailsEdit.GetWindowText (szText);
            m_rSaferEntry.SetHashFriendlyName (szText);

            // Get and save flags
            DWORD   dwFlags = 0;

            m_rSaferEntry.SetFlags (dwFlags);

            m_rSaferEntry.SetHash (m_rgbFileHash, m_cbFileHash, m_nFileSize, m_hashAlgid);
            HRESULT hr = m_rSaferEntry.Save ();
            if ( SUCCEEDED (hr) )
            {
                if ( m_lNotifyHandle )
                    MMCPropertyChangeNotify (
                            m_lNotifyHandle,  // handle to a notification
                            (LPARAM) m_pDataObject);          // unique identifier

                if ( m_pbObjectCreated )
                    *m_pbObjectCreated = true;

                m_rSaferEntry.Refresh ();
                GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_SHOW);
                GetDlgItem (IDC_HASH_ENTRY_LAST_MODIFIED)->ShowWindow (SW_SHOW);
                GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->UpdateWindow ();
                GetDlgItem (IDC_HASH_ENTRY_LAST_MODIFIED)->UpdateWindow ();
                SetDlgItemText (IDC_HASH_ENTRY_LAST_MODIFIED, m_rSaferEntry.GetLongLastModified ());
                m_bDirty = false;
            }
            else
            {
                CString caption;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                if ( HRESULT_FROM_WIN32 (ERROR_INVALID_PARAMETER) != hr )
                    szText.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));
                else
                    VERIFY (szText.LoadString (IDS_HASH_STRING_BAD_FORMAT));

                MessageBox (szText, caption, MB_OK);

                return FALSE;
            }
        }
    }
    
    return CSaferPropertyPage::OnApply();
}

void CSaferEntryHashPropertyPage::OnChangeHashEntryDescription() 
{
    m_bDirty = true;
    SetModified ();
}

void CSaferEntryHashPropertyPage::OnSelchangeHashEntrySecurityLevel() 
{
    m_bDirty = true;
    SetModified ();
}

void CSaferEntryHashPropertyPage::OnChangeHashHashedFilePath() 
{
    m_bDirty = true;
    SetModified ();
}

bool CSaferEntryHashPropertyPage::FormatMemBufToString(PWSTR *ppString, PBYTE pbData, DWORD cbData)
{   
    const WCHAR     RgwchHex[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                              '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};

    DWORD   i = 0;
    PBYTE   pb;
    
    *ppString = (LPWSTR) LocalAlloc (LPTR, ((cbData * 3) * sizeof(WCHAR)));
    if ( !*ppString )
    {
        return false;
    }

    //
    // copy to the buffer
    //
    pb = pbData;
    while (pb <= &(pbData[cbData-1]))
    {   
        (*ppString)[i++] = RgwchHex[(*pb & 0xf0) >> 4];
        (*ppString)[i++] = RgwchHex[*pb & 0x0f];
        pb++;         
    }
    (*ppString)[i] = 0;
    
    return true;
}

bool CSaferEntryHashPropertyPage::ConvertStringToHash (PCWSTR pszString)
{
    _TRACE (1, L"Entering CSaferEntryHashPropertyPage::ConvertStringToHash (%s)\n", pszString);
    bool    bRetVal = true;
    BYTE    rgbFileHash[SAFER_MAX_HASH_SIZE];
    // security review 2/25/2002 BryanWal ok
    ::ZeroMemory (rgbFileHash, sizeof (rgbFileHash));

    DWORD   cbFileHash = 0;
    DWORD   dwNumHashChars = 0;
    bool    bFirst = true;
    bool    bEndOfHash = false;
    CThemeContextActivator activator;

    for (int nIndex = 0; !bEndOfHash && pszString[nIndex] && bRetVal; nIndex++)
    {
        if ( cbFileHash >= SAFER_MAX_HASH_SIZE )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_HASH_STRING_TOO_LONG, SAFER_MAX_HASH_SIZE, SAFER_MAX_HASH_SIZE/4);
            _TRACE (0, L"%s", (PCWSTR) text);

            VERIFY (text.LoadString (IDS_HASH_STRING_BAD_FORMAT));
            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
            bRetVal = false;
            break;
        }
        dwNumHashChars++;
        
        switch (pszString[nIndex])
        {
        case L'0':
            bFirst = !bFirst;
            break;

        case L'1':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x10;
            else
                rgbFileHash[cbFileHash] |= 0x01;
            bFirst = !bFirst;
            break;

        case L'2':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x20;
            else
                rgbFileHash[cbFileHash] |= 0x02;
            bFirst = !bFirst;
            break;

        case L'3':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x30;
            else
                rgbFileHash[cbFileHash] |= 0x03;
            bFirst = !bFirst;
            break;

        case L'4':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x40;
            else
                rgbFileHash[cbFileHash] |= 0x04;
            bFirst = !bFirst;
            break;

        case L'5':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x50;
            else
                rgbFileHash[cbFileHash] |= 0x05;
            bFirst = !bFirst;
            break;

        case L'6':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x60;
            else
                rgbFileHash[cbFileHash] |= 0x06;
            bFirst = !bFirst;
            break;

        case L'7':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x70;
            else
                rgbFileHash[cbFileHash] |= 0x07;
            bFirst = !bFirst;
            break;

        case L'8':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x80;
            else
                rgbFileHash[cbFileHash] |= 0x08;
            bFirst = !bFirst;
            break;

        case L'9':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0x90;
            else
                rgbFileHash[cbFileHash] |= 0x09;
            bFirst = !bFirst;
            break;

        case L'a':
        case L'A':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xA0;
            else
                rgbFileHash[cbFileHash] |= 0x0A;
            bFirst = !bFirst;
            break;

        case L'b':
        case L'B':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xB0;
            else
                rgbFileHash[cbFileHash] |= 0x0B;
            bFirst = !bFirst;
            break;

        case L'c':
        case L'C':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xC0;
            else
                rgbFileHash[cbFileHash] |= 0x0C;
            bFirst = !bFirst;
            break;

        case L'd':
        case L'D':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xD0;
            else
                rgbFileHash[cbFileHash] |= 0x0D;
            bFirst = !bFirst;
            break;

        case L'e':
        case L'E':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xE0;
            else
                rgbFileHash[cbFileHash] |= 0x0E;
            bFirst = !bFirst;
            break;

        case L'f':
        case L'F':
            if ( bFirst )
                rgbFileHash[cbFileHash] |= 0xF0;
            else
                rgbFileHash[cbFileHash] |= 0x0F;
            bFirst = !bFirst;
            break;

        case L':':
            // end of hash
            bEndOfHash = true;
            bFirst = !bFirst;
            dwNumHashChars--; // ':' already counted, subtract it
            break;

        default:
            bRetVal = false;
            {
                CString caption;
                CString text;
                WCHAR   szChar[2];

                szChar[0] = pszString[nIndex];
                szChar[1] = 0;

                VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
                text.FormatMessage (IDS_HASH_STRING_INVALID_CHAR, szChar);
                _TRACE (0, L"%s", (PCWSTR) text);

                VERIFY (text.LoadString (IDS_HASH_STRING_BAD_FORMAT));

                MessageBox (text, caption, MB_ICONWARNING | MB_OK);
            }
            break;
        }

        if ( bFirst )
            cbFileHash++;
    }

    if ( bRetVal )
    {
        //  2 characters map to 1 each byte in the hash
        if ( MD5_HASH_LEN != dwNumHashChars/2 && SHA1_HASH_LEN != dwNumHashChars/2 )
        {
            CString caption;
            CString text;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (text.LoadString (IDS_HASH_INVALID_LENGTH));
            _TRACE (0, L"%s", (PCWSTR) text);

            VERIFY (text.LoadString (IDS_HASH_STRING_BAD_FORMAT));

            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
            bRetVal = false;
        }
        else
        {
            m_cbFileHash = cbFileHash;

            // security review 2/25/2002 BryanWal ok
            memcpy (m_rgbFileHash, rgbFileHash, sizeof (m_rgbFileHash));
        }
    }

    _TRACE (-1, L"Leaving CSaferEntryHashPropertyPage::ConvertStringToHash (): %s\n", 
            bRetVal ? L"true" : L"false");
    return bRetVal;
}

void CSaferEntryHashPropertyPage::OnSetfocusHashHashedFilePath() 
{
    if ( m_bFirst )
    {
        if ( true == m_bReadOnly )
            SendDlgItemMessage (IDC_HASH_HASHED_FILE_PATH, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}

void CSaferEntryHashPropertyPage::FormatAndDisplayHash ()
{
    PWSTR   pwszText = 0;

    if ( FormatMemBufToString (&pwszText, m_rgbFileHash, m_cbFileHash) && pwszText )
    {
        // security review 2/25/2002 BryanWal ok - 
        // NOTICE: MSDN indicates result can be up to 33 bytes (for ltoa, so 
        // I assume it's 33 wide-chars for ltow)
        WCHAR   szAlgID[34];
        _ltow (m_hashAlgid, szAlgID, 10);
    
        PCWSTR  szFormat = L"%s:%ld:";
        static size_t cchWidthFormat = wcslen (szFormat); // no need to recalculate every time
        PCWSTR  szInt64Max = L"18,446,744,073,709,551,615"; // from MSDN
        static size_t cchWidthInt64Max = wcslen (szInt64Max); // no need to recalculate every time

        // security review 2/25/2002 BryanWal ok
        // NTRAID# 554409 Security: Safer: buffer overflow: need to alloc string buf dynamically
        PWSTR   pszFormattedText = new WCHAR[wcslen (pwszText) + cchWidthFormat + wcslen (szAlgID) + cchWidthInt64Max + 1];
        if ( pszFormattedText )
        {
            // security review 2/25/2002 BryanWal
            wsprintf (pszFormattedText, szFormat, pwszText, 
                    m_nFileSize);
            wcscat (pszFormattedText, szAlgID);
            SetDlgItemText (IDC_HASH_HASHED_FILE_PATH, 
                    pszFormattedText);
            delete [] pszFormattedText;
        }
        ::LocalFree (pwszText);
    }
}

void CSaferEntryHashPropertyPage::OnChangeHashEntryHashfileDetails() 
{
    SetModified (); 
    m_bDirty = true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentryinternetzonepropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryInternetZonePropertyPage.h
//
//  Contents:   Declaration of CSaferEntryInternetZonePropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYINTERNETZONEPROPERTYPAGE_H__2C1B5841_0334_4763_8AEF_1EE611B1958B__INCLUDED_)
#define AFX_SAFERENTRYINTERNETZONEPROPERTYPAGE_H__2C1B5841_0334_4763_8AEF_1EE611B1958B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryInternetZonePropertyPage.h : header file
//
#include "SaferPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryInternetZonePropertyPage dialog

class CSaferEntryInternetZonePropertyPage : public CSaferPropertyPage
{
// Construction
public:
	CSaferEntryInternetZonePropertyPage(
            CSaferEntry& rSaferEntry, 
            bool bNew, 
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            CCertMgrComponentData* pCompData,
            bool bIsMachine,
            bool* pbObjectCreated = 0);
	~CSaferEntryInternetZonePropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryInternetZonePropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_INTERNET_ZONE };
	CComboBox	m_internetZoneCombo;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryInternetZonePropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryInternetZonePropertyPage)
    virtual BOOL OnInitDialog();	
	afx_msg void OnSelchangeIzoneEntrySecurityLevel();
	afx_msg void OnSelchangeIzoneEntryZones();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    void InitializeInternetZoneComboBox (DWORD UrlZoneId);

private:
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYINTERNETZONEPROPERTYPAGE_H__2C1B5841_0334_4763_8AEF_1EE611B1958B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentryhashpropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryHashPropertyPage.h
//
//  Contents:   Declaration of CSaferEntryHashPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYHASHPROPERTYPAGE_H__9F1BE911_6A3E_4BBA_8BE9_BFE3B29D2A6F__INCLUDED_)
#define AFX_SAFERENTRYHASHPROPERTYPAGE_H__9F1BE911_6A3E_4BBA_8BE9_BFE3B29D2A6F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryHashPropertyPage.h : header file
//
#include "SaferPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryHashPropertyPage dialog

class CSaferEntryHashPropertyPage : public CSaferPropertyPage
{
// Construction
public:
    CSaferEntryHashPropertyPage(
            CSaferEntry& rSaferEntry, 
            LONG_PTR lNotifyHandle, 
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            CCertMgrComponentData*   pCompData,
            bool bIsMachine,
            bool* pbObjectCreated = 0);
    ~CSaferEntryHashPropertyPage();

// Dialog Data
    //{{AFX_DATA(CSaferEntryHashPropertyPage)
    enum { IDD = IDD_SAFER_ENTRY_HASH };
    CEdit   m_hashFileDetailsEdit;
    CEdit   m_descriptionEdit;
    CComboBox   m_securityLevelCombo;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSaferEntryHashPropertyPage)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSaferEntryHashPropertyPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnHashEntryBrowse();
    afx_msg void OnChangeHashEntryDescription();
    afx_msg void OnSelchangeHashEntrySecurityLevel();
    afx_msg void OnChangeHashHashedFilePath();
    afx_msg void OnSetfocusHashHashedFilePath();
    afx_msg void OnChangeHashEntryHashfileDetails();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    BOOL MyGetFileVersionInfo(PCWSTR lpszFilename, PVOID *lpVersionInfo);
    CString BuildHashFileInfoString (const PVOID szBuff);
    CString ConcatStrings (
                const CString& productName, 
                const CString& description, 
                const CString& companyName,
                const CString& fileName, 
                const CString& fileVersion,
                const CString& internalName);
    bool CheckLengthAndTruncateToken (CString& token);
    virtual void DoContextHelp (HWND hWndControl);
    bool FormatMemBufToString (PWSTR *ppString, PBYTE pbData, DWORD cbData);
    bool ConvertStringToHash (PCWSTR pszString);
    void FormatAndDisplayHash ();
    CString GetAlternateLanguageVersionInfo (PVOID pData, PCWSTR pszVersionField);
    bool FileIsDLL (const CString& szFilePath);

private:
    CString             m_szLastOpenedFile;
    BYTE                m_rgbFileHash[SAFER_MAX_HASH_SIZE];
    DWORD               m_cbFileHash;
    __int64             m_nFileSize;
    ALG_ID              m_hashAlgid;
    bool                m_bFirst;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYHASHPROPERTYPAGE_H__9F1BE911_6A3E_4BBA_8BE9_BFE3B29D2A6F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentrypathpropertypage.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryPathPropertyPage.cpp
//
//  Contents:   Implementation of CSaferEntryPathPropertyPage
//
//----------------------------------------------------------------------------
// SaferEntryPathPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include <gpedit.h>
#include "certmgr.h"
#include "compdata.h"
#include "SaferEntryPathPropertyPage.h"
#include "SaferUtil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryPathPropertyPage property page

CSaferEntryPathPropertyPage::CSaferEntryPathPropertyPage(
        CSaferEntry& rSaferEntry,
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        bool bNew,
        CCertMgrComponentData* pCompData,
        bool bIsMachine,
        bool* pbObjectCreated /* = 0 */)
: CSaferPropertyPage(CSaferEntryPathPropertyPage::IDD, pbObjectCreated, 
        pCompData, rSaferEntry, bNew, lNotifyHandle, pDataObject, bReadOnly,
        bIsMachine),
    m_bFirst (true),
    m_pidl (0),
    m_bDialogInitInProgress (false)
{
    //{{AFX_DATA_INIT(CSaferEntryPathPropertyPage)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
}

CSaferEntryPathPropertyPage::~CSaferEntryPathPropertyPage()
{
    if ( m_pidl )
    {
        LPMALLOC pMalloc = 0;
        if ( SUCCEEDED (SHGetMalloc (&pMalloc)) )
        {
           pMalloc->Free (m_pidl);
           pMalloc->Release ();
        }
    }
}

void CSaferEntryPathPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CSaferPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSaferEntryPathPropertyPage)
    DDX_Control(pDX, IDC_PATH_ENTRY_DESCRIPTION, m_descriptionEdit);
    DDX_Control(pDX, IDC_PATH_ENTRY_PATH, m_pathEdit);
    DDX_Control(pDX, IDC_PATH_ENTRY_SECURITY_LEVEL, m_securityLevelCombo);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferEntryPathPropertyPage, CSaferPropertyPage)
    //{{AFX_MSG_MAP(CSaferEntryPathPropertyPage)
    ON_EN_CHANGE(IDC_PATH_ENTRY_DESCRIPTION, OnChangePathEntryDescription)
    ON_CBN_SELCHANGE(IDC_PATH_ENTRY_SECURITY_LEVEL, OnSelchangePathEntrySecurityLevel)
    ON_EN_CHANGE(IDC_PATH_ENTRY_PATH, OnChangePathEntryPath)
    ON_BN_CLICKED(IDC_PATH_ENTRY_BROWSE, OnPathEntryBrowse)
    ON_EN_SETFOCUS(IDC_PATH_ENTRY_PATH, OnSetfocusPathEntryPath)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryPathPropertyPage message handlers
void CSaferEntryPathPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferEntryPathPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_PATH_ENTRY_PATH, IDH_PATH_ENTRY_PATH,
        IDC_PATH_ENTRY_SECURITY_LEVEL, IDH_PATH_ENTRY_SECURITY_LEVEL,
        IDC_PATH_ENTRY_DESCRIPTION, IDH_PATH_ENTRY_DESCRIPTION,
        IDC_PATH_ENTRY_LAST_MODIFIED, IDH_PATH_ENTRY_LAST_MODIFIED,
        IDC_PATH_ENTRY_BROWSE, IDH_PATH_ENTRY_BROWSE_FOLDER,
        0, 0
    };

    switch (::GetDlgCtrlID (hWndControl))
    {
    case IDC_PATH_ENTRY_PATH:
    case IDC_PATH_ENTRY_SECURITY_LEVEL:
    case IDC_PATH_ENTRY_DESCRIPTION:
    case IDC_PATH_ENTRY_LAST_MODIFIED:
    case IDC_PATH_ENTRY_BROWSE:
        if ( !::WinHelp (
            hWndControl,
            GetF1HelpFilename(),
            HELP_WM_HELP,
        (DWORD_PTR) help_map) )
        {
            _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());
        }
        break;

    default:
        break;
    }
    _TRACE (-1, L"Leaving CSaferEntryPathPropertyPage::DoContextHelp\n");
}

BOOL CSaferEntryPathPropertyPage::OnInitDialog()
{
    CSaferPropertyPage::OnInitDialog();
    m_bDialogInitInProgress = true;

    // NTRAID# 456950 SAFER:  Path text box on new path rule property sheet 
    // accepts more than MAX_PATH characters.
    SendDlgItemMessage (IDC_PATH_ENTRY_PATH, EM_LIMITTEXT, MAX_PATH-1, 0);

    if ( m_bDirty )  // bNew
    {
        GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_HIDE);
        GetDlgItem (IDC_PATH_ENTRY_LAST_MODIFIED)->ShowWindow (SW_HIDE);
    }
    else
    {
        CString szText;

        VERIFY (szText.LoadString (IDS_PATH_TITLE));
        SetDlgItemText (IDC_PATH_TITLE, szText);
    }


    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        CPolicyKey policyKey (m_pCompData->m_pGPEInformation,
                    SAFER_HKLM_REGBASE,
                    m_bIsMachine);
        InitializeSecurityLevelComboBox (m_securityLevelCombo, false,
                m_rSaferEntry.GetLevel (), policyKey.GetKey (), 
                m_pCompData->m_pdwSaferLevels,
                m_bIsMachine);

        // Initialize path
        _TRACE (0, L"Getting path: %s\n", (PCWSTR) m_rSaferEntry.GetPath ());
        m_pathEdit.SetWindowText (m_rSaferEntry.GetPath ());

        // Initialize description
        m_descriptionEdit.SetLimitText (SAFER_MAX_DESCRIPTION_SIZE-1);
        m_descriptionEdit.SetWindowText (m_rSaferEntry.GetDescription ());

        SetDlgItemText (IDC_PATH_ENTRY_LAST_MODIFIED,
                m_rSaferEntry.GetLongLastModified ());

        if ( m_bReadOnly )
        {
            m_pathEdit.SetReadOnly ();
            m_descriptionEdit.SetReadOnly ();
            m_securityLevelCombo.EnableWindow (FALSE);
            GetDlgItem (IDC_PATH_ENTRY_BROWSE)->EnableWindow (FALSE);
        }
    }

    m_bDialogInitInProgress = false;
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CSaferEntryPathPropertyPage::OnApply()
{
    if ( m_bDirty && !m_bReadOnly )
    {
        if ( !ValidateEntryPath () )
            return FALSE;

        // Set the level
        int nCurSel = m_securityLevelCombo.GetCurSel ();
        ASSERT (CB_ERR != nCurSel);
        m_rSaferEntry.SetLevel ((DWORD) m_securityLevelCombo.GetItemData (nCurSel));

        CString szText;

        m_pathEdit.GetWindowText (szText);
        if ( szText.IsEmpty () )
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            VERIFY (text.LoadString (IDS_SAFER_PATH_EMPTY));

            MessageBox (text, caption, MB_OK);
            m_pathEdit.SetFocus ();

            return FALSE;
        }

        m_rSaferEntry.SetPath (szText);

        m_descriptionEdit.GetWindowText (szText);
        m_rSaferEntry.SetDescription (szText);

        HRESULT hr = m_rSaferEntry.Save ();
        if ( SUCCEEDED (hr) )
        {
            if ( m_lNotifyHandle )
                MMCPropertyChangeNotify (
                        m_lNotifyHandle,  // handle to a notification
                        (LPARAM) m_pDataObject);          // unique identifier

            if ( m_pbObjectCreated )
                *m_pbObjectCreated = true;
            m_bDirty = false;

            // NTRAID# 462382 SAFER:  Apply button doesn't update date last 
            // modified on rules property sheets.
            m_rSaferEntry.Refresh ();
            GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->ShowWindow (SW_SHOW);
            GetDlgItem (IDC_PATH_ENTRY_LAST_MODIFIED)->ShowWindow (SW_SHOW);
            GetDlgItem (IDC_DATE_LAST_MODIFIED_LABEL)->UpdateWindow ();
            GetDlgItem (IDC_PATH_ENTRY_LAST_MODIFIED)->UpdateWindow ();
            SetDlgItemText (IDC_PATH_ENTRY_LAST_MODIFIED,
                    m_rSaferEntry.GetLongLastModified ());        
        }
        else
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
            text.FormatMessage (IDS_ERROR_SAVING_ENTRY, GetSystemMessage (hr));

            MessageBox (text, caption, MB_OK);
            return FALSE;
        }
    }
    
    return CSaferPropertyPage::OnApply();
}

void CSaferEntryPathPropertyPage::OnChangePathEntryDescription()
{
    if ( !m_bDialogInitInProgress )
    {
        m_bDirty = true;
        SetModified (); 
    }
}

void CSaferEntryPathPropertyPage::OnSelchangePathEntrySecurityLevel()
{
    if ( !m_bDialogInitInProgress )
    {
        m_bDirty = true;
        SetModified (); 
    }
}

void CSaferEntryPathPropertyPage::OnChangePathEntryPath()
{
    if ( !m_bDialogInitInProgress )
    {
        m_bDirty = true;
        SetModified (); 
    }
}

//+--------------------------------------------------------------------------
//
//  Function:   BrowseCallbackProc
//
//  Synopsis:   Callback procedure for File & Folder adding SHBrowseForFolder
//              to set the title bar appropriately
//
//  Arguments:  [hwnd]   - the hwnd of the browse dialog
//              [uMsg]   - the message from the dialog
//              [lParam] - message dependant
//              [pData]  - PIDL from last successful call to SHBrowseForFolder
//
//  Returns:    0
//
//---------------------------------------------------------------------------
int CSaferEntryPathPropertyPage::BrowseCallbackProc (HWND hwnd, UINT uMsg, LPARAM /*lParam*/, LPARAM pData)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch(uMsg)
    {
        case BFFM_INITIALIZED:
            {
                CString szTitle;
                VERIFY (szTitle.LoadString (IDS_SHBROWSEFORFOLDER_TITLE));
                ::SetWindowText (hwnd, szTitle);

                if ( pData )
                    ::SendMessage (hwnd, BFFM_SETSELECTION, FALSE, pData);
            }
            break;

        default:
            break;
    }
    return 0;
}

void CSaferEntryPathPropertyPage::OnPathEntryBrowse()
{
    _TRACE (1, L"Entering CSaferEntryPathPropertyPage::OnPathEntryBrowse()\n");
    CString     szTitle;
    VERIFY (szTitle.LoadString (IDS_SELECT_A_FOLDER));
    WCHAR       szDisplayName[MAX_PATH];
    BROWSEINFO  bi;
    // security review 2/25/2002 BryanWal ok
    ::ZeroMemory (&bi, sizeof (bi));

    bi.hwndOwner = m_hWnd;
    bi.pidlRoot = 0;
    bi.pszDisplayName = szDisplayName;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_NEWDIALOGSTYLE | BIF_VALIDATE | BIF_BROWSEINCLUDEFILES;
    bi.lpfn = BrowseCallbackProc;
    bi.lParam = (LPARAM) m_pidl;
    bi.iImage = 0;

    // security review 2/25/2002 BryanWal ok
    // NOTICE: MSDN affirms size of pszDisplayName buffer is assumed to be MAX_PATH
    LPITEMIDLIST pidl = ::SHBrowseForFolder (&bi);
    if ( pidl )
    {
        CString szFolderPath;
        BOOL bRVal = ::SHGetPathFromIDList (pidl, szFolderPath.GetBuffer (MAX_PATH));
        szFolderPath.ReleaseBuffer();

        if ( bRVal )
        {
           LPMALLOC pMalloc = 0;
           if ( SUCCEEDED (SHGetMalloc (&pMalloc)) )
           {
               if ( m_pidl )
                   pMalloc->Free (m_pidl);
               pMalloc->Release ();
               m_pidl = pidl;
           }

           m_pathEdit.SetWindowText (szFolderPath);
           m_bDirty = true;
           SetModified ();
        }
    }
    _TRACE (-1, L"Leaving CSaferEntryPathPropertyPage::OnPathEntryBrowse()\n");
}


bool CSaferEntryPathPropertyPage::ValidateEntryPath()
{
    bool    bRVal = true;
    CString szPath;

    m_pathEdit.GetWindowText (szPath);

    PCWSTR szInvalidCharSet = ILLEGAL_FAT_CHARS; 


    if ( -1 != szPath.FindOneOf (szInvalidCharSet) )
    {
        bRVal = false;
        CString text;
        CString caption;

        VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_NODE_NAME));
        CString charsWithSpaces;

        UINT nIndex = 0;
        while (szInvalidCharSet[nIndex])
        {
            charsWithSpaces += szInvalidCharSet[nIndex];
            charsWithSpaces += L"  ";
            nIndex++;
        }
        text.FormatMessage (IDS_SAFER_PATH_CONTAINS_INVALID_CHARS, charsWithSpaces);

        CThemeContextActivator activator;
        MessageBox (text, caption, MB_OK);
        m_pathEdit.SetFocus ();
    }

    return bRVal;
}

void CSaferEntryPathPropertyPage::OnSetfocusPathEntryPath()
{
    if ( m_bFirst )
    {
        if ( true == m_bReadOnly )
            SendDlgItemMessage (IDC_PATH_ENTRY_PATH, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentrypathpropertypage.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferEntryPathPropertyPage.h
//
//  Contents:   Declaration of CSaferEntryPathPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERENTRYPATHPROPERTYPAGE_H__B32CBA62_1C9A_4763_AA55_B32E25FF2426__INCLUDED_)
#define AFX_SAFERENTRYPATHPROPERTYPAGE_H__B32CBA62_1C9A_4763_AA55_B32E25FF2426__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferEntryPathPropertyPage.h : header file
//
#include "SaferPropertyPage.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferEntryPathPropertyPage dialog

class CSaferEntryPathPropertyPage : public CSaferPropertyPage
{

// Construction
public:
	CSaferEntryPathPropertyPage(
            CSaferEntry& rSaferEntry, 
            LONG_PTR lNotifyHandle, 
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            bool bNew,
            CCertMgrComponentData* pCompData,
            bool bIsMachine,
            bool* pbObjectCreated = 0);
	~CSaferEntryPathPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferEntryPathPropertyPage)
	enum { IDD = IDD_SAFER_ENTRY_PATH };
	CEdit	m_descriptionEdit;
	CEdit	m_pathEdit;
	CComboBox	m_securityLevelCombo;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferEntryPathPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferEntryPathPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangePathEntryDescription();
	afx_msg void OnSelchangePathEntrySecurityLevel();
	afx_msg void OnChangePathEntryPath();
	afx_msg void OnPathEntryBrowse();
	afx_msg void OnSetfocusPathEntryPath();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    static int BrowseCallbackProc (HWND hwnd,UINT uMsg, LPARAM lParam, LPARAM pData);
	bool ValidateEntryPath();

private:
    bool                m_bFirst;
    LPITEMIDLIST        m_pidl;
    bool                m_bDialogInitInProgress;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERENTRYPATHPROPERTYPAGE_H__B32CBA62_1C9A_4763_AA55_B32E25FF2426__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentrypropertysheet.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryPropertySheet.cpp
//
//  Contents:   Implementation of CSaferEntryPropertySheet
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include "SaferEntryPropertySheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define WM_SETOKDEFAULT     WM_APP + 2001

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaferEntryPropertySheet::CSaferEntryPropertySheet(UINT nIDCaption, CWnd *pParentWnd)
: CPropertySheet (nIDCaption, pParentWnd)
{

}

CSaferEntryPropertySheet::~CSaferEntryPropertySheet()
{

}

BEGIN_MESSAGE_MAP(CSaferEntryPropertySheet, CPropertySheet)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE (WM_SETOKDEFAULT, OnSetOKDefault)
END_MESSAGE_MAP()

BOOL CSaferEntryPropertySheet::OnInitDialog() 
{
    _TRACE (1, L"Entering CSaferEntryPropertySheet::OnInitDialog ()\n");
	CPropertySheet::OnInitDialog();
	
    LONG    dwStyle = GetWindowLong (m_hWnd, GWL_STYLE);

    dwStyle |= DS_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_STYLE, dwStyle);
    
    dwStyle = GetWindowLong (m_hWnd, GWL_EXSTYLE);
    dwStyle |= WS_EX_DLGMODALFRAME | WS_EX_CONTEXTHELP;
    SetWindowLong (m_hWnd, GWL_EXSTYLE, dwStyle);

    // Make the OK button the default
    PostMessage (WM_SETOKDEFAULT, 0, 0);

    _TRACE (-1, L"Leaving CSaferEntryPropertySheet::OnInitDialog ()\n");
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

LRESULT CSaferEntryPropertySheet::OnSetOKDefault (WPARAM, LPARAM)
{
    // Make the OK button the default
    SendMessage (DM_SETDEFID, MAKEWPARAM (IDOK, 0), 0);
    SendDlgItemMessage (IDOK, BM_SETSTYLE, BS_DEFPUSHBUTTON, MAKELPARAM(TRUE, 0));

    SendDlgItemMessage (IDCANCEL, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));


    return 0;
}


BOOL CSaferEntryPropertySheet::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    _TRACE (1, L"Entering CSaferEntryPropertySheet::OnHelp\n");
   
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
    if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        DoContextHelp ((HWND) pHelpInfo->hItemHandle);
    }

    _TRACE (-1, L"Leaving CSaferEntryPropertySheet::OnHelp\n");

    return TRUE;
}

void CSaferEntryPropertySheet::DoContextHelp (HWND hWndControl)
{
	_TRACE (1, L"Entering CSaferEntryPropertySheet::DoContextHelp\n");
    const int	IDC_COMM_APPLYNOW = 12321;
	const int	IDH_COMM_APPLYNOW = 28447;
    const DWORD aHelpIDs_PropSheet[]=
    {
		IDC_COMM_APPLYNOW, IDH_COMM_APPLYNOW,
        0, 0
    };

    PWSTR  pszHelpFile = 0;
	switch (::GetDlgCtrlID (hWndControl))
	{
    case IDC_COMM_APPLYNOW:
        pszHelpFile = const_cast <PWSTR> (WINDOWS_HELP);
        break;

	default:
		// Display context help for a control
        pszHelpFile = const_cast<PWSTR> ((PCWSTR)GetF1HelpFilename());
		break;
	}

	if ( !::WinHelp (
			hWndControl,
			pszHelpFile,
			HELP_WM_HELP,
			(DWORD_PTR) aHelpIDs_PropSheet) )
	{
		_TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());        
	}

    _TRACE (-1, L"Leaving CSaferEntryPropertySheet::DoContextHelp\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferentrypropertysheet.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferEntryPropertySheet.h
//
//  Contents:   Declaration of CSaferEntryPropertySheet
//
//----------------------------------------------------------------------------

#if !defined(AFX_SAFERENTRYPROPERTYSHEET_H__A9834C09_038E_4430_A4C4_5CBB9045E3A9__INCLUDED_)
#define AFX_SAFERENTRYPROPERTYSHEET_H__A9834C09_038E_4430_A4C4_5CBB9045E3A9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSaferEntryPropertySheet : public CPropertySheet  
{
public:
	CSaferEntryPropertySheet(UINT nIDCaption, CWnd *pParentWnd);
	virtual ~CSaferEntryPropertySheet();

protected:
    virtual BOOL OnInitDialog();

	// Generated message map functions
	//{{AFX_MSG(CSaferEntryPropertySheet)
	//}}AFX_MSG
    afx_msg LRESULT OnSetOKDefault (WPARAM, LPARAM);
	DECLARE_MESSAGE_MAP()

    BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	virtual void DoContextHelp (HWND hWndControl);

private:
};

#endif // !defined(AFX_SAFERENTRYPROPERTYSHEET_H__A9834C09_038E_4430_A4C4_5CBB9045E3A9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferlevel.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevel.h
//
//  Contents:   Declaration of CSaferLevel
//
//----------------------------------------------------------------------------

#if !defined(AFX_SAFERLEVEL_H__894DD3C5_A1A4_4DD5_8853_5F999D8F3FF5__INCLUDED_)
#define AFX_SAFERLEVEL_H__894DD3C5_A1A4_4DD5_8853_5F999D8F3FF5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "cookie.h"
#include "RSOPObject.h"

class CSaferLevel : public CCertMgrCookie  
{
public:
	CSaferLevel(
            DWORD dwSaferLevel, 
            bool bIsMachine, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName,
            IGPEInformation* pGPEInformation,
            CRSOPObjectArray& rRSOPArray);
	virtual ~CSaferLevel();

    DWORD GetLevel () const
    {
        return m_dwSaferLevel;
    }

  	bool IsDefault ();
	HRESULT SetAsDefault ();
	CString GetDescription () const;

    static DWORD ReturnDefaultLevel (
            IGPEInformation* pGPEInformation, 
            bool bIsComputer, 
            CRSOPObjectArray& rRSOPArray);

private:
	CString m_szLevel;
	const bool          m_bIsComputer;
	CString             m_szDescription;
	const DWORD         m_dwSaferLevel;
    IGPEInformation*    m_pGPEInformation;
    CRSOPObjectArray&   m_rRSOPArray;
};

#endif // !defined(AFX_SAFERLEVEL_H__894DD3C5_A1A4_4DD5_8853_5F999D8F3FF5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferlevelgeneral.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferLevelGeneral.cpp
//
//  Contents:   Implementation of CSaferLevelGeneral
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <gpedit.h>
#include <winsafer.h>
#include <compdata.h>
#include "SaferLevelGeneral.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSaferLevelGeneral property page

CSaferLevelGeneral::CSaferLevelGeneral(
        CSaferLevel& rSaferLevel, 
        bool bReadOnly, 
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        DWORD dwDefaultSaferLevel,
        CCertMgrComponentData* pCompData) 
    : CHelpPropertyPage(CSaferLevelGeneral::IDD),
    m_rSaferLevel (rSaferLevel),
    m_bReadOnly (bReadOnly),
    m_bSetAsDefault (false),
    m_lNotifyHandle (lNotifyHandle),
    m_bDirty (false),
    m_pDataObject (pDataObject),
    m_dwDefaultSaferLevel (dwDefaultSaferLevel),
    m_bFirst (true),
    m_bLevelChanged (false),
    m_pCompData (pCompData)
{
	//{{AFX_DATA_INIT(CSaferLevelGeneral)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
    m_rSaferLevel.IncrementOpenPageCount ();

    if ( m_pCompData )
    {
        m_pCompData->AddRef ();
        m_pCompData->IncrementOpenSaferPageCount ();
    }
}

CSaferLevelGeneral::~CSaferLevelGeneral()
{
    if ( m_lNotifyHandle )
    {
        if ( m_bLevelChanged )
        {
            MMCPropertyChangeNotify (
                    m_lNotifyHandle,  // handle to a notification
                   (LPARAM) m_pDataObject);          // unique identifier
        }
        MMCFreeNotifyHandle (m_lNotifyHandle);
    }
    m_rSaferLevel.DecrementOpenPageCount ();

    if ( m_pCompData )
    {
        m_pCompData->DecrementOpenSaferPageCount ();
        m_pCompData->Release ();
        m_pCompData = 0;
    }
}

void CSaferLevelGeneral::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferLevelGeneral)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferLevelGeneral, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferLevelGeneral)
	ON_BN_CLICKED(IDC_SAFER_LEVEL_SET_AS_DEFAULT, OnSaferLevelSetAsDefault)
	ON_EN_SETFOCUS(IDC_SAFER_LEVEL_DESCRIPTION, OnSetfocusSaferLevelDescription)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferLevelGeneral message handlers

void CSaferLevelGeneral::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferLevelGeneral::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_SAFER_LEVEL_NAME,           IDH_SAFER_LEVEL_NAME,
        IDC_SAFER_LEVEL_DESCRIPTION,    IDH_SAFER_LEVEL_DESCRIPTION,
        IDC_SAFER_LEVEL_SET_AS_DEFAULT, IDH_SAFER_LEVEL_SET_AS_DEFAULT,
        IDC_SAFER_LEVEL_STATUS, IDH_SAFER_LEVEL_STATUS,
        0, 0
    };
    if ( !::WinHelp (
        hWndControl,
        GetF1HelpFilename(),
        HELP_WM_HELP,
    (DWORD_PTR) help_map) )
    {
        _TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
    }
    _TRACE (-1, L"Leaving CSaferLevelGeneral::DoContextHelp\n");
}


BOOL CSaferLevelGeneral::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();
	
    SetDlgItemText (IDC_SAFER_LEVEL_NAME, m_rSaferLevel.GetObjectName ());

    SetDlgItemText (IDC_SAFER_LEVEL_DESCRIPTION, m_rSaferLevel.GetDescription ());

    if ( m_rSaferLevel.IsDefault () )
    {
        m_bSetAsDefault = true;
        CString text;
        VERIFY (text.LoadString (IDS_IS_DEFAULT_LEVEL));
        SetDlgItemText (IDC_SAFER_LEVEL_STATUS, text);
        GetDlgItem (IDC_SAFER_LEVEL_SET_AS_DEFAULT)->EnableWindow (FALSE);
        GetDlgItem (IDC_LEVEL_INSTRUCTIONS)->EnableWindow (FALSE);
    }

    if ( m_bReadOnly ||  ( SAFER_LEVELID_DISALLOWED != m_rSaferLevel.GetLevel () &&
            SAFER_LEVELID_FULLYTRUSTED != m_rSaferLevel.GetLevel ()  &&
            SAFER_LEVELID_NORMALUSER != m_rSaferLevel.GetLevel () ) )
    {
        CString text;

        if ( SAFER_LEVELID_CONSTRAINED == m_rSaferLevel.GetLevel () )
        {
            VERIFY (text.LoadString (IDS_CANT_SET_CONSTRAINED_AS_DEFAULT));
            SetDlgItemText (IDC_LEVEL_INSTRUCTIONS, text);
        }
        GetDlgItem (IDC_SAFER_LEVEL_SET_AS_DEFAULT)->EnableWindow (FALSE);
        GetDlgItem (IDC_LEVEL_INSTRUCTIONS)->EnableWindow (FALSE);
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


BOOL CSaferLevelGeneral::OnApply ()
{
    if ( !m_bReadOnly && m_bDirty )
    {
        HRESULT hr = S_OK;
        BOOL    bResult = FALSE;


        if ( m_bSetAsDefault )
            hr = m_rSaferLevel.SetAsDefault ();
        if ( SUCCEEDED (hr) )
        {
            m_bLevelChanged = true;
            bResult =  CHelpPropertyPage::OnApply ();
        }
        else
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
            text.FormatMessage (IDS_CANT_SET_AS_DEFAULT, m_rSaferLevel.GetObjectName (),
                    GetSystemMessage (hr));
            MessageBox (text, caption, MB_ICONWARNING | MB_OK);
        }

        return bResult;
    }
    else
        return CHelpPropertyPage::OnApply ();
}

void CSaferLevelGeneral::OnSaferLevelSetAsDefault() 
{
    if ( !m_bSetAsDefault )
    {
        int     iRet = IDYES;

        if ( m_rSaferLevel.GetLevel () < m_dwDefaultSaferLevel )
        {
            CString text;
            CString caption;
            CThemeContextActivator activator;

            VERIFY (caption.LoadString (IDS_SAFER_WINDOWS_EXTENSION_REGISTRY));
            VERIFY (text.LoadString (IDS_DEFAULT_LEVEL_CHANGE_WARNING));
            iRet = MessageBox (text, caption, MB_ICONWARNING | MB_YESNO);
        }

        if ( IDYES == iRet )
        {
            m_dwDefaultSaferLevel = m_rSaferLevel.GetLevel ();
            m_bDirty = true;
	        m_bSetAsDefault = true;
            CString text;
            VERIFY (text.LoadString (IDS_IS_DEFAULT_LEVEL));
            SetDlgItemText (IDC_SAFER_LEVEL_STATUS, text);
            SetModified (TRUE);
            GetDlgItem (IDC_SAFER_LEVEL_SET_AS_DEFAULT)->EnableWindow (FALSE);
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// This method traps keyboard commands from the dialog, which has only 
// disabled controls, usually.  That prevented the closing of the dialog
// when the user pressed ESC.
// 222693 SAFER: Pressing ESC doesn't dismiss SAFER Level dialogs
///////////////////////////////////////////////////////////////////////////////
BOOL CSaferLevelGeneral::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	WORD    id = LOWORD (wParam);

    if ( IDCANCEL == id )
    {
        GetParent ()->SendMessage (WM_COMMAND, wParam, lParam);
    }
	
	return CHelpPropertyPage::OnCommand(wParam, lParam);
}

void CSaferLevelGeneral::OnSetfocusSaferLevelDescription() 
{
    if ( m_bFirst )
    {
        SendDlgItemMessage (IDC_SAFER_LEVEL_DESCRIPTION, EM_SETSEL, (WPARAM) 0, 0);
        m_bFirst = false;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferlevelgeneral.h ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevelGeneral.h
//
//  Contents:   Declaration of CSaferLevelGeneral
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERLEVELGENERAL_H__C8398890_ED8E_40E1_AEE6_91BFD32257B1__INCLUDED_)
#define AFX_SAFERLEVELGENERAL_H__C8398890_ED8E_40E1_AEE6_91BFD32257B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "SaferLevel.h"

/////////////////////////////////////////////////////////////////////////////
// CSaferLevelGeneral dialog
class CCertMgrComponentData; //forward declaration

class CSaferLevelGeneral : public CHelpPropertyPage
{
// Construction
public:
	CSaferLevelGeneral (
            CSaferLevel& rSaferLevel, 
            bool bReadOnly, 
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            DWORD dwDefaultSaferLevel,
            CCertMgrComponentData* pCompData);
	~CSaferLevelGeneral();

// Dialog Data
	//{{AFX_DATA(CSaferLevelGeneral)
	enum { IDD = IDD_SAFER_LEVEL_GENERAL };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferLevelGeneral)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferLevelGeneral)
	virtual BOOL OnInitDialog();
	afx_msg void OnSaferLevelSetAsDefault();
	afx_msg void OnSetfocusSaferLevelDescription();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
	virtual BOOL OnApply();

private:
    CSaferLevel&            m_rSaferLevel;
    const bool              m_bReadOnly;
    bool                    m_bSetAsDefault;
    LONG_PTR                m_lNotifyHandle;
    bool                    m_bDirty;
    LPDATAOBJECT            m_pDataObject;
    DWORD                   m_dwDefaultSaferLevel;
    bool                    m_bFirst;
    bool                    m_bLevelChanged;
    CCertMgrComponentData* m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERLEVELGENERAL_H__C8398890_ED8E_40E1_AEE6_91BFD32257B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferlevel.cpp ===
//+---------------------------------------------------------------------------
/////////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferLevel.cpp
//
//  Contents:   Implementation of CSaferLevel
//
//----------------------------------------------------------------------------
#include "stdafx.h"

#include <gpedit.h>
#include <winsafer.h>
#include <wintrust.h>
#include "SaferLevel.h"
#include "SaferUtil.h"
#include "PolicyKey.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

extern const DWORD AUTHZ_UNKNOWN_LEVEL;

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSaferLevel::CSaferLevel(
        DWORD dwSaferLevel, 
        bool bIsMachine, 
        PCWSTR pszMachineName, 
        PCWSTR pszObjectName,
        IGPEInformation* pGPEInformation,
        CRSOPObjectArray& rRSOPArray)
: CCertMgrCookie (bIsMachine ? CERTMGR_SAFER_COMPUTER_LEVEL : CERTMGR_SAFER_USER_LEVEL, 
        pszMachineName, pszObjectName),
    m_dwSaferLevel (dwSaferLevel),
    m_bIsComputer (bIsMachine),
    m_pGPEInformation (pGPEInformation),
    m_rRSOPArray (rRSOPArray)
{
    if ( m_pGPEInformation )
        m_pGPEInformation->AddRef ();

    // OK to pass in NULL for m_pGPEInformation
    CPolicyKey policyKey (m_pGPEInformation, 
                    SAFER_HKLM_REGBASE, 
                    m_bIsComputer);
    m_szDescription = SaferGetLevelDescription (dwSaferLevel, policyKey.GetKey (),
            m_bIsComputer);
}

CSaferLevel::~CSaferLevel()
{
    if ( m_pGPEInformation )
        m_pGPEInformation->Release ();
}

CString CSaferLevel::GetDescription() const
{
    return m_szDescription;
}

HRESULT CSaferLevel::SetAsDefault()
{
    _TRACE (1, L"Entering CSaferLevel::SetAsDefault ()\n");
    HRESULT hr = S_OK;

    if ( m_pGPEInformation )
    {
        CPolicyKey policyKey (m_pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                m_bIsComputer);
        hr = SetRegistryScope (policyKey.GetKey (), m_bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwData = GetLevel ();
            DWORD   cbData = sizeof (dwData);
            BOOL    bRVal = SaferSetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                    SaferPolicyDefaultLevel, cbData, &dwData, policyKey.GetKey ());
            if ( bRVal )
            {
			    // TRUE means we're changing the machine policy only
                m_pGPEInformation->PolicyChanged (m_bIsComputer ? TRUE : FALSE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (m_bIsComputer ? TRUE : FALSE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (GetLastError ());
            }
        }
    }
    else
        hr = E_UNEXPECTED;

    _TRACE (-1, L"Leaving CSaferLevel::SetAsDefault (): 0x%x\n", hr);
    return hr;
}

DWORD CSaferLevel::ReturnDefaultLevel (
        IGPEInformation* pGPEInformation, 
        bool bIsComputer, 
        CRSOPObjectArray& rRSOPArray)
{
    _TRACE (1, L"Entering CSaferLevel::IsDefault ()\n");
    DWORD   dwDefaultLevelID = AUTHZ_UNKNOWN_LEVEL;


    if ( pGPEInformation )
    {
        CPolicyKey policyKey (pGPEInformation, 
                SAFER_HKLM_REGBASE, 
                bIsComputer);

        HRESULT hr = SetRegistryScope (policyKey.GetKey (), bIsComputer);
        if ( SUCCEEDED (hr) )
        {
            DWORD   dwData = 0;
            DWORD   cbData = sizeof (dwData);
            DWORD   dwRetSize = 0;
            BOOL    bRVal = SaferGetPolicyInformation (SAFER_SCOPEID_REGISTRY,
	                    SaferPolicyDefaultLevel, cbData, &dwData, &dwRetSize,
                        policyKey.GetKey ());
            if ( bRVal )
            {
                dwDefaultLevelID = dwData;
	        }
        }
    }
    else 
    {
        int     nIndex = 0;
        INT_PTR nUpperBound = rRSOPArray.GetUpperBound ();
        CString szKeyName = SAFER_HKLM_REGBASE;
        szKeyName += L"\\";
        szKeyName += SAFER_CODEIDS_REGSUBKEY;


        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pCurrObject = rRSOPArray.GetAt (nIndex);
            if ( pCurrObject )
            {
                if ( szKeyName == pCurrObject->GetRegistryKey () && 
                        SAFER_DEFAULTOBJ_REGVALUE == pCurrObject->GetValueName () )
                {
                    DWORD   dwLevelID = pCurrObject->GetDWORDValue ();
                    dwDefaultLevelID = dwLevelID;
                    break;
                }
            }
            nIndex++;
        }

        if ( AUTHZ_UNKNOWN_LEVEL == dwDefaultLevelID ) // level was not found in RSOP data
            dwDefaultLevelID = SAFER_LEVELID_FULLYTRUSTED;
    }

    _TRACE (1, L"Entering CSaferLevel::ReturnDefaultLevel (): %d\n", dwDefaultLevelID);
    return dwDefaultLevelID;
}

bool CSaferLevel::IsDefault()
{
    _TRACE (1, L"Entering CSaferLevel::IsDefault ()\n");
    bool    bResult = false;
    DWORD   dwDefaultLevelID = CSaferLevel::ReturnDefaultLevel (
                m_pGPEInformation, m_bIsComputer, m_rRSOPArray);
    if ( GetLevel () == dwDefaultLevelID )
        bResult = true;


    _TRACE (1, L"Entering CSaferLevel::IsDefault (): %s\n", bResult ? L"true" : L"false");
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferpropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001-2002.
//
//  File:       SaferPropertPage.cpp
//
//  Contents:   Implementation of CSaferPropertyPage
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CSaferPropertyPage::CSaferPropertyPage(UINT uIDD, bool* pbObjectCreated,
        CCertMgrComponentData* pCompData,
        CSaferEntry& rSaferEntry,
        bool bNew,
        LONG_PTR lNotifyHandle,
        LPDATAOBJECT pDataObject,
        bool bReadOnly,
        bool bIsMachine) :
    CHelpPropertyPage (uIDD),
    m_pbObjectCreated (pbObjectCreated),
    m_pCompData (pCompData),
    m_rSaferEntry (rSaferEntry),
    m_bDirty (bNew),
    m_lNotifyHandle (lNotifyHandle),
    m_pDataObject (pDataObject),
    m_bReadOnly (bReadOnly),
    m_bIsMachine (bIsMachine)
{
    m_rSaferEntry.AddRef ();
    m_rSaferEntry.IncrementOpenPageCount ();

    if ( m_pCompData )
    {
        m_pCompData->AddRef ();
        m_pCompData->IncrementOpenSaferPageCount ();
    }
}


CSaferPropertyPage::~CSaferPropertyPage()
{
    m_rSaferEntry.DecrementOpenPageCount ();
    m_rSaferEntry.Release ();

    if ( m_pCompData )
    {
        m_pCompData->DecrementOpenSaferPageCount ();
        m_pCompData->Release ();
        m_pCompData = 0;
    }

    if ( m_lNotifyHandle )
    {
        MMCFreeNotifyHandle (m_lNotifyHandle);
        m_lNotifyHandle = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferpropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001-2002.
//
//  File:       SaferPropertPage.h
//
//  Contents:   Definition of CSaferPropertyPage
//
//----------------------------------------------------------------------------
#ifndef __SAFERPROPERTYPAGE_H
#define __SAFERPROPERTYPAGE_H

#include "SaferEntry.h"

class CSaferPropertyPage : public CHelpPropertyPage
{
public:
    CSaferPropertyPage(UINT uIDD, bool* pbObjectCreated,
            CCertMgrComponentData* pCompData,
            CSaferEntry& rSaferEntry,
            bool bNew,
            LONG_PTR lNotifyHandle,
            LPDATAOBJECT pDataObject,
            bool bReadOnly,
            bool bIsMachine);

	virtual ~CSaferPropertyPage();

public:
    bool*    m_pbObjectCreated;

protected:
    CSaferEntry&        m_rSaferEntry;
    bool                m_bDirty;
    LONG_PTR            m_lNotifyHandle;
    LPDATAOBJECT        m_pDataObject;
    const bool          m_bReadOnly;
    bool                m_bIsMachine;
    CCertMgrComponentData* m_pCompData;
};


#endif // #ifndef __SAFERPROPERTYPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferstore.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferStore.h
//
//  Contents:   Definition of CCertStoreSafer
//
//----------------------------------------------------------------------------
#ifndef __SAFERSTORE_H
#define __SAFERSTORE_H

#include "StoreGPE.h"
#include "PolicyKey.h"

class CCertStoreSafer : public CCertStoreGPE
{
public:
    CCertStoreSafer ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			IGPEInformation * pGPTInformation,
			const GUID& compDataGUID,
			IConsole* pConsole);
    ~CCertStoreSafer ();

    virtual HKEY GetGroupPolicyKey ();

private:
    CPolicyKey  m_policyKey;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferstore.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2001.
//
//  File:       SaferStore.cpp
//
//  Contents:   Implementation of CSaferStore
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "SaferStore.h"
#include "PolicyKey.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CCertStoreSafer::CCertStoreSafer ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			IGPEInformation * pGPTInformation,
			const GUID& compDataGUID,
			IConsole* pConsole)
: CCertStoreGPE (dwFlags, lpcszMachineName, objectName, pcszLogStoreName, 
        pcszPhysStoreName, pGPTInformation, compDataGUID, pConsole),
    m_policyKey (pGPTInformation, 
            L"", m_fIsComputerType)
{
}

CCertStoreSafer::~CCertStoreSafer ()
{
}

HKEY CCertStoreSafer::GetGroupPolicyKey ()
{
    return m_policyKey.GetKey ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\safertrustedpublisherspropertypage.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferTrustedPublishersPropertyPage.h
//
//  Contents:   Declaration of CSaferTrustedPublishersPropertyPage
//
//----------------------------------------------------------------------------
// SaferTrustedPublishersPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "certmgr.h"
#include <gpedit.h>
#include "compdata.h"
#include "SaferTrustedPublishersPropertyPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

/////////////////////////////////////////////////////////////////////////////
// CSaferTrustedPublishersPropertyPage property page

CSaferTrustedPublishersPropertyPage::CSaferTrustedPublishersPropertyPage(
        bool fIsMachineType, IGPEInformation* pGPEInformation,
        CCertMgrComponentData* pCompData) 
    : CHelpPropertyPage(CSaferTrustedPublishersPropertyPage::IDD),
    m_pGPEInformation (pGPEInformation),
    m_hGroupPolicyKey (0),
    m_dwTrustedPublisherFlags (0),
    m_fIsComputerType (fIsMachineType),
    m_bRSOPValueFound (false),
    m_pCompData (pCompData)
{
    // NTRAID# 263969	Safer Windows:  "Enterprise Administrators" radio 
    // button should be disabled on Trusted Publishers property sheet for 
    // computers in workgroups.
    ASSERT (m_pCompData);
    if ( m_pCompData )
    {
        m_pCompData->AddRef ();
        m_pCompData->IncrementOpenSaferPageCount ();
    }

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        HRESULT hResult = m_pGPEInformation->GetRegistryKey (
                m_fIsComputerType ? GPO_SECTION_MACHINE : GPO_SECTION_USER,
		        &m_hGroupPolicyKey);
        ASSERT (SUCCEEDED (hResult));
        if ( SUCCEEDED (hResult) )
		    GetTrustedPublisherFlags ();
    }
    else
        RSOPGetTrustedPublisherFlags (pCompData);
  
	//{{AFX_DATA_INIT(CSaferTrustedPublishersPropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSaferTrustedPublishersPropertyPage::~CSaferTrustedPublishersPropertyPage()
{
    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
    }

    if ( m_pCompData )
    {
        m_pCompData->DecrementOpenSaferPageCount ();
        m_pCompData->Release ();
        m_pCompData = 0;
    }
}

void CSaferTrustedPublishersPropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CHelpPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSaferTrustedPublishersPropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSaferTrustedPublishersPropertyPage, CHelpPropertyPage)
	//{{AFX_MSG_MAP(CSaferTrustedPublishersPropertyPage)
	ON_BN_CLICKED(IDC_TP_BY_END_USER, OnTpByEndUser)
	ON_BN_CLICKED(IDC_TP_BY_LOCAL_COMPUTER_ADMIN, OnTpByLocalComputerAdmin)
	ON_BN_CLICKED(IDC_TP_BY_ENTERPRISE_ADMIN, OnTpByEnterpriseAdmin)
	ON_BN_CLICKED(IDC_TP_REV_CHECK_PUBLISHER, OnTpRevCheckPublisher)
	ON_BN_CLICKED(IDC_TP_REV_CHECK_TIMESTAMP, OnTpRevCheckTimestamp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSaferTrustedPublishersPropertyPage message handlers
void CSaferTrustedPublishersPropertyPage::DoContextHelp (HWND hWndControl)
{
    _TRACE (1, L"Entering CSaferTrustedPublishersPropertyPage::DoContextHelp\n");
    static const DWORD help_map[] =
    {
        IDC_TP_BY_END_USER, IDH_TP_BY_END_USER,
        IDC_TP_BY_LOCAL_COMPUTER_ADMIN, IDH_TP_BY_LOCAL_COMPUTER_ADMIN,
        IDC_TP_BY_ENTERPRISE_ADMIN, IDH_TP_BY_ENTERPRISE_ADMIN,
        IDC_TP_REV_CHECK_PUBLISHER, IDH_TP_REV_CHECK_PUBLISHER,
        IDC_TP_REV_CHECK_TIMESTAMP, IDH_TP_REV_CHECK_TIMESTAMP,
        0, 0
    };
    switch (::GetDlgCtrlID (hWndControl))
    {
	case IDC_TP_BY_END_USER:
	case IDC_TP_BY_LOCAL_COMPUTER_ADMIN:
	case IDC_TP_BY_ENTERPRISE_ADMIN:
	case IDC_TP_REV_CHECK_PUBLISHER:
	case IDC_TP_REV_CHECK_TIMESTAMP:
		if ( !::WinHelp (
			hWndControl,
			GetF1HelpFilename(),
			HELP_WM_HELP,
		(DWORD_PTR) help_map) )
		{
			_TRACE (0, L"WinHelp () failed: 0x%x\n", GetLastError ());    
		}
		break;

	default:
		break;
	}
    _TRACE (-1, L"Leaving CSaferTrustedPublishersPropertyPage::DoContextHelp\n");
}


BOOL CSaferTrustedPublishersPropertyPage::OnInitDialog() 
{
	CHelpPropertyPage::OnInitDialog();

    if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG )
        SendDlgItemMessage (IDC_TP_REV_CHECK_PUBLISHER, BM_SETCHECK, BST_CHECKED);

    if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG )
        SendDlgItemMessage (IDC_TP_REV_CHECK_TIMESTAMP, BM_SETCHECK, BST_CHECKED);

    if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST )
        SendDlgItemMessage (IDC_TP_BY_ENTERPRISE_ADMIN, BM_SETCHECK, BST_CHECKED);
    else if ( m_dwTrustedPublisherFlags & CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST )
        SendDlgItemMessage (IDC_TP_BY_LOCAL_COMPUTER_ADMIN, BM_SETCHECK, BST_CHECKED);
    else
        SendDlgItemMessage (IDC_TP_BY_END_USER, BM_SETCHECK, BST_CHECKED);

    if ( !m_pGPEInformation )
    {
        // Is RSOP
        GetDlgItem (IDC_TP_REV_CHECK_PUBLISHER)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_REV_CHECK_TIMESTAMP)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_BY_ENTERPRISE_ADMIN)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_BY_LOCAL_COMPUTER_ADMIN)->EnableWindow (FALSE);
        GetDlgItem (IDC_TP_BY_END_USER)->EnableWindow (FALSE);
    }
	
    // NTRAID# 263969	Safer Windows:  "Enterprise Administrators" radio 
    // button should be disabled on Trusted Publishers property sheet for 
    // computers in workgroups.
    if ( m_pCompData->ComputerIsStandAlone () )
        GetDlgItem (IDC_TP_BY_ENTERPRISE_ADMIN)->EnableWindow (FALSE);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CSaferTrustedPublishersPropertyPage::GetTrustedPublisherFlags()
{
    DWORD   dwDisposition = 0;

    HKEY    hKey = 0;
    LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
            CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            // security review 2/25/2002 BryanWal ok
            KEY_QUERY_VALUE,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (lResult == ERROR_SUCCESS);
    if ( lResult == ERROR_SUCCESS )
    {
        // Read value
        DWORD   dwType = REG_DWORD;
        DWORD   dwData = 0;
        DWORD   cbData = sizeof (dwData);

        // security review 2/25/2002 BryanWal ok
        lResult =  ::RegQueryValueEx (hKey,       // handle of key to query
		        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME,  // address of name of value to query
			    0,              // reserved
	        &dwType,        // address of buffer for value type
		    (LPBYTE) &dwData,       // address of data buffer
			&cbData);           // address of data buffer size);
		ASSERT (ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult);
        if ( ERROR_SUCCESS == lResult || ERROR_FILE_NOT_FOUND == lResult )
		{
            if ( REG_DWORD == dwType )
                m_dwTrustedPublisherFlags = dwData;
		}
        else
            DisplaySystemError (m_hWnd, lResult);

        RegCloseKey (hKey);
    }
    else
        DisplaySystemError (m_hWnd, lResult);
}

void CSaferTrustedPublishersPropertyPage::OnTpByEndUser() 
{
    if ( m_dwTrustedPublisherFlags & 
        (CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST | 
            CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST) )
    {
        m_dwTrustedPublisherFlags = 0;
        SetModified ();	
    }
}

void CSaferTrustedPublishersPropertyPage::OnTpByLocalComputerAdmin() 
{
    if ( !(m_dwTrustedPublisherFlags & CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST) )
    {
        m_dwTrustedPublisherFlags = CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST;
	    SetModified ();	
    }
}

void CSaferTrustedPublishersPropertyPage::OnTpByEnterpriseAdmin() 
{
    if ( !(m_dwTrustedPublisherFlags & CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST) )
    {
        m_dwTrustedPublisherFlags = CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST;
        SetModified ();		
    }
}

void CSaferTrustedPublishersPropertyPage::OnTpRevCheckPublisher() 
{
    SetModified ();		
}

void CSaferTrustedPublishersPropertyPage::OnTpRevCheckTimestamp() 
{
    SetModified ();		
}

BOOL CSaferTrustedPublishersPropertyPage::OnApply() 
{
    if ( m_pGPEInformation )
    {
        DWORD   dwFlags = 0;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_REV_CHECK_PUBLISHER, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_CHECK_PUBLISHER_REV_FLAG;
            
        if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_REV_CHECK_TIMESTAMP, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_CHECK_TIMESTAMP_REV_FLAG;

        if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_BY_ENTERPRISE_ADMIN, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_ALLOW_ENTERPRISE_ADMIN_TRUST;
        else if ( BST_CHECKED == SendDlgItemMessage (IDC_TP_BY_LOCAL_COMPUTER_ADMIN, BM_GETCHECK) )
            dwFlags |= CERT_TRUST_PUB_ALLOW_MACHINE_ADMIN_TRUST;
        else
            dwFlags |= CERT_TRUST_PUB_ALLOW_END_USER_TRUST;
        
        HKEY    hKey = 0;
        DWORD   dwDisposition = 0;
        LONG lResult = ::RegCreateKeyEx (m_hGroupPolicyKey, // handle of an open key
                CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH,     // address of subkey name
                0,       // reserved
                L"",       // address of class string
                REG_OPTION_NON_VOLATILE,      // special options flag
                // security review 2/25/2002 BryanWal ok
                KEY_SET_VALUE,    // desired security access
                NULL,     // address of key security structure
			    &hKey,      // address of buffer for opened handle
		        &dwDisposition);  // address of disposition value buffer
	    ASSERT (lResult == ERROR_SUCCESS);
        if ( lResult == ERROR_SUCCESS )
        {
            DWORD   cbData = sizeof (dwFlags);
            lResult = ::RegSetValueEx (hKey,
				        CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, // address of value to set
				        0,              // reserved
				        REG_DWORD,          // flag for value type
				        (CONST BYTE *) &dwFlags, // address of value data
				        cbData);        // size of value data);
            ASSERT (ERROR_SUCCESS == lResult);
            if ( ERROR_SUCCESS == lResult )
		    {
			    // TRUE means we're changing the machine policy only
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidExtension, &g_guidSnapin);
                m_pGPEInformation->PolicyChanged (m_fIsComputerType ? TRUE : FALSE, 
                        TRUE, &g_guidRegExt, &g_guidSnapin);
		    }
		    else
                DisplaySystemError (m_hWnd, lResult);

            RegCloseKey (hKey);
        }
    }
	
	return CHelpPropertyPage::OnApply();
}

void CSaferTrustedPublishersPropertyPage::RSOPGetTrustedPublisherFlags(const CCertMgrComponentData* pCompData)
{
    if ( pCompData )
    {
        int     nIndex = 0;
        // NOTE: rsop object array is sorted first by registry key, then by precedence
        const CRSOPObjectArray* pObjectArray = m_fIsComputerType ?
                pCompData->GetRSOPObjectArrayComputer () : pCompData->GetRSOPObjectArrayUser ();
        INT_PTR nUpperBound = pObjectArray->GetUpperBound ();

        while ( nUpperBound >= nIndex )
        {
            CRSOPObject* pObject = pObjectArray->GetAt (nIndex);
            if ( pObject )
            {
                // security review 2/25/2002 BryanWal ok
                if ( !_wcsicmp (CERT_TRUST_PUB_SAFER_GROUP_POLICY_REGPATH, pObject->GetRegistryKey ()) &&
						!_wcsicmp (CERT_TRUST_PUB_AUTHENTICODE_FLAGS_VALUE_NAME, pObject->GetValueName ()) )
                {
					ASSERT (1 == pObject->GetPrecedence ());
                    m_dwTrustedPublisherFlags = pObject->GetDWORDValue ();
                    m_bRSOPValueFound = true;
                    break;
                }
            }
            else
                break;

            nIndex++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\safertrustedpublisherspropertypage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferTrustedPublishersPropertyPage.h
//
//  Contents:   Declaration of CSaferTrustedPublishersPropertyPage
//
//----------------------------------------------------------------------------
#if !defined(AFX_SAFERTRUSTEDPUBLISHERSPROPERTYPAGE_H__B152D75D_6D04_4893_98AF_C070B66DB0E0__INCLUDED_)
#define AFX_SAFERTRUSTEDPUBLISHERSPROPERTYPAGE_H__B152D75D_6D04_4893_98AF_C070B66DB0E0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SaferTrustedPublishersPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSaferTrustedPublishersPropertyPage dialog

class CSaferTrustedPublishersPropertyPage : public CHelpPropertyPage
{
// Construction
public:
	CSaferTrustedPublishersPropertyPage(
            bool fIsMachineType, 
            IGPEInformation* pGPEInformation,
            CCertMgrComponentData* pCompData);
	~CSaferTrustedPublishersPropertyPage();

// Dialog Data
	//{{AFX_DATA(CSaferTrustedPublishersPropertyPage)
	enum { IDD = IDD_SAFER_TRUSTED_PUBLISHER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSaferTrustedPublishersPropertyPage)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSaferTrustedPublishersPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnTpByEndUser();
	afx_msg void OnTpByLocalComputerAdmin();
	afx_msg void OnTpByEnterpriseAdmin();
	afx_msg void OnTpRevCheckPublisher();
	afx_msg void OnTpRevCheckTimestamp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    virtual void DoContextHelp (HWND hWndControl);
    void GetTrustedPublisherFlags();
    void RSOPGetTrustedPublisherFlags(const CCertMgrComponentData* pCompData);

private:
    IGPEInformation*    m_pGPEInformation;
    HKEY                m_hGroupPolicyKey;
    DWORD               m_dwTrustedPublisherFlags;
    bool                m_fIsComputerType;
    bool                m_bRSOPValueFound;
    CCertMgrComponentData* m_pCompData;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SAFERTRUSTEDPUBLISHERSPROPERTYPAGE_H__B152D75D_6D04_4893_98AF_C070B66DB0E0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferUtil.cpp
//
//  Contents:   Utility methods for Software Restriction Policies extension
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include <wintrust.h>
#include <crypto\wintrustp.h>
#include <softpub.h>
#include "SaferUtil.h"
#include "SaferEntry.h"
#include <winsaferp.h>


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HKEY g_hkeyLastSaferRegistryScope;
bool g_bIsComputer = false;

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;

void InitializeSecurityLevelComboBox (
        CComboBox& comboBox, 
        bool bLimit, 
        DWORD dwLevelID, 
        HKEY hGroupPolicyKey,
        DWORD* pdwSaferLevels,
        bool bIsComputer)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( !hGroupPolicyKey )  // is RSOP
    {
        CString szText = SaferGetLevelFriendlyName (dwLevelID, 
                hGroupPolicyKey, bIsComputer);
        int nItem = comboBox.AddString (szText);
        ASSERT (nItem >= 0);
        if ( nItem >= 0 )
        {
            VERIFY (CB_ERR != comboBox.SetItemData (nItem, dwLevelID));
            VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
        }

        return;
    }

    if ( pdwSaferLevels )
    {
        for (UINT nIndex = 0; 
                NO_MORE_SAFER_LEVELS != pdwSaferLevels[nIndex]; 
                nIndex++)
        {
            CString szText;
            int     nItem = 0;

            switch (pdwSaferLevels[nIndex])
            {
            case SAFER_LEVELID_FULLYTRUSTED:
                szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                        hGroupPolicyKey, bIsComputer);
                nItem = comboBox.AddString (szText);
                ASSERT (nItem >= 0);
                if ( nItem >= 0 )
                {
                    VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                    if ( pdwSaferLevels[nIndex] == dwLevelID || AUTHZ_UNKNOWN_LEVEL == dwLevelID)
                        VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                }
                break;

            case SAFER_LEVELID_CONSTRAINED:
                if ( !bLimit )
                {
                    szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                            hGroupPolicyKey, bIsComputer);
                    nItem = comboBox.AddString (szText);
                    ASSERT (nItem >= 0);
                    if ( nItem >= 0 )
                    {
                        VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                        if ( pdwSaferLevels[nIndex] == dwLevelID )
                            VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                    }
                }
                break;

            case SAFER_LEVELID_DISALLOWED:
                szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                        hGroupPolicyKey, bIsComputer);
                nItem = comboBox.AddString (szText);
                ASSERT (nItem >= 0);
                if ( nItem >= 0 )
                {
                    VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                    if ( pdwSaferLevels[nIndex] == dwLevelID )
                        VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                }
                break;

            case SAFER_LEVELID_NORMALUSER:
            case SAFER_LEVELID_UNTRUSTED:
                if ( !bLimit )
                {
                    if ( hGroupPolicyKey )
                    {
                        szText = SaferGetLevelFriendlyName (pdwSaferLevels[nIndex], 
                                hGroupPolicyKey, bIsComputer);
                        nItem = comboBox.AddString (szText);
                        ASSERT (nItem >= 0);
                        if ( nItem >= 0 )
                        {
                            VERIFY (CB_ERR != comboBox.SetItemData (nItem, pdwSaferLevels[nIndex]));
                            if ( pdwSaferLevels[nIndex] == dwLevelID )
                                VERIFY (CB_ERR != comboBox.SetCurSel (nItem));
                        }
                    }
                }
                break;

            default:
                ASSERT (0);
                break;
            }
        }
    }
}

class CLevelPair {
public:
    CLevelPair () :
        m_dwLevelID ((DWORD) -1)
    {
    }
    virtual ~CLevelPair () {}

    DWORD   m_dwLevelID;
    CString m_szLevelName;
};

CString SaferGetLevelFriendlyName (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer)
{
    CString             szLevelName;
    SAFER_LEVEL_HANDLE  hLevel = 0;
    BOOL                bRVal = FALSE;
    const int           NUM_LEVEL_PAIRS = 10;
    static CLevelPair   levelPairs[NUM_LEVEL_PAIRS];

    for (int nLevelIndex = 0; nLevelIndex < NUM_LEVEL_PAIRS; nLevelIndex++)
    {
        if ( -1 == levelPairs[nLevelIndex].m_dwLevelID )
            break;
        else if ( dwLevelID == levelPairs[nLevelIndex].m_dwLevelID )
        {
            return levelPairs[nLevelIndex].m_szLevelName;
        }
    }

    if ( hGroupPolicyKey )
    {
        if ( !g_hkeyLastSaferRegistryScope )
            SetRegistryScope (hGroupPolicyKey, bIsComputer);
        
        
        bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                hGroupPolicyKey);
    }
    else
    {
        bRVal = SaferCreateLevel (SAFER_SCOPEID_MACHINE,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                0);
    }

    if ( bRVal )
    {
        DWORD   dwBufferSize = 0;
        DWORD   dwErr = 0;
        bRVal = SaferGetLevelInformation(hLevel, 
                SaferObjectFriendlyName,
                0,
                dwBufferSize,
                &dwBufferSize);
        if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
        {
            PWSTR  pszLevelName = (PWSTR) LocalAlloc (LPTR, dwBufferSize);
            if ( pszLevelName )
            {
                bRVal = SaferGetLevelInformation(hLevel, 
                        SaferObjectFriendlyName,
                        pszLevelName,
                        dwBufferSize,
                        &dwBufferSize);
                ASSERT (bRVal);
                if ( bRVal )
                {
                    szLevelName = pszLevelName;
                }
                else
                {
                    dwErr = GetLastError ();
                    _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                            dwErr);
                }

                LocalFree (pszLevelName);
            }
        }
        else if ( !bRVal )
        {
            dwErr = GetLastError ();
            _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                    dwErr);
        }

        VERIFY (SaferCloseLevel (hLevel));
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"SaferCloseLevel (SAFER_SCOPEID_REGISTRY, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                dwLevelID, dwErr);
    }

    if ( nLevelIndex < NUM_LEVEL_PAIRS && !szLevelName.IsEmpty () )
    {
        levelPairs[nLevelIndex].m_dwLevelID = dwLevelID;
        levelPairs[nLevelIndex].m_szLevelName = szLevelName;
    }
    return szLevelName;
}

CString SaferGetLevelDescription (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer)
{
    CString             szDescription;
    SAFER_LEVEL_HANDLE  hLevel = 0;
    BOOL                bRVal = FALSE;

    if ( hGroupPolicyKey )
    {
        if ( !g_hkeyLastSaferRegistryScope )
            SetRegistryScope (hGroupPolicyKey, bIsComputer);
        
        bRVal = SaferCreateLevel (SAFER_SCOPEID_REGISTRY,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                hGroupPolicyKey);
    }
    else
    {
        if ( g_hkeyLastSaferRegistryScope )
            SetRegistryScope (0, bIsComputer);
        bRVal = SaferCreateLevel (SAFER_SCOPEID_MACHINE,
                dwLevelID,
                SAFER_LEVEL_OPEN,
                &hLevel,
                0);
    }

    ASSERT (bRVal);
    if ( bRVal )
    {
        DWORD   dwBufferSize = 0;
        DWORD   dwErr = 0;
        bRVal = SaferGetLevelInformation(hLevel, 
                SaferObjectDescription,
                0,
                dwBufferSize,
                &dwBufferSize);
        if ( !bRVal && ERROR_INSUFFICIENT_BUFFER == GetLastError () )
        {
            PWSTR  pszDescription = (PWSTR) LocalAlloc (LPTR, dwBufferSize);
            if ( pszDescription )
            {
                bRVal = SaferGetLevelInformation(hLevel, 
                        SaferObjectDescription,
                        pszDescription,
                        dwBufferSize,
                        &dwBufferSize);
                ASSERT (bRVal);
                if ( bRVal )
                {
                    szDescription = pszDescription;
                }
                else
                {
                    dwErr = GetLastError ();
                    _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                            dwErr);
                }

                LocalFree (pszDescription);
            }
        }
        else if ( !bRVal )
        {
            dwErr = GetLastError ();
            _TRACE (0, L"SaferGetLevelInformation(SaferObjectFriendlyName) failed: %d\n", 
                    dwErr);
        }

        if ( ERROR_NOT_FOUND == dwErr || szDescription.IsEmpty () )
        {
            VERIFY (szDescription.LoadString (IDS_NOT_AVAILABLE));
        }

        VERIFY (SaferCloseLevel (hLevel));
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"SaferCreateLevel (%s, 0x%x, SAFER_LEVEL_OPEN) failed: %d\n",
                hGroupPolicyKey ? L"SAFER_SCOPEID_REGISTRY" : L"SAFER_SCOPEID_MACHINE", 
                dwLevelID, dwErr);
    }

    return szDescription;
}


HRESULT SaferGetLevelID (SAFER_LEVEL_HANDLE hLevel, DWORD& dwLevelID)
{
    ASSERT (0 != g_hkeyLastSaferRegistryScope);
    DWORD   dwBufferSize = sizeof (DWORD);
    HRESULT hr = S_OK;

    BOOL bRVal = SaferGetLevelInformation(hLevel, 
        SaferObjectLevelId,
        &dwLevelID,
        dwBufferSize,
        &dwBufferSize);
    ASSERT (bRVal);
    if ( !bRVal )
    {
        DWORD dwErr = GetLastError ();
        hr = HRESULT_FROM_WIN32 (dwErr);
        _TRACE (0, L"SaferGetLevelInformation(SaferObjectLevelId) failed: %d\n", 
                dwErr);
    }

    return hr;
}


CSaferEntries::CSaferEntries(
        bool bIsMachine, 
        PCWSTR pszMachineName, 
        PCWSTR pszObjectName, 
        IGPEInformation* pGPEInformation,
        IRSOPInformation* pRSOPInformation,
        CRSOPObjectArray& rsopObjectArray,
        LPCONSOLE   pConsole)
: CCertMgrCookie (bIsMachine ? CERTMGR_SAFER_COMPUTER_ENTRIES : CERTMGR_SAFER_USER_ENTRIES, 
        pszMachineName, pszObjectName),
        m_pTrustedPublishersStore (0),
        m_pDisallowedStore (0)
{
    if ( pGPEInformation )
    {
        m_pTrustedPublishersStore = new CCertStoreSafer (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_TRUSTED_PUBLISHER_STORE_FRIENDLY_NAME,
			    SAFER_TRUSTED_PUBLISHER_STORE_NAME,
			    L"",
			    pGPEInformation,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    
        m_pDisallowedStore = new CCertStoreSafer (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_DISALLOWED_STORE_FRIENDLY_NAME,
			    SAFER_DISALLOWED_STORE_NAME,
			    L"",
			    pGPEInformation,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    }
    else if ( pRSOPInformation )
    {
        m_pTrustedPublishersStore = new CCertStoreRSOP (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_TRUSTED_PUBLISHER_STORE_FRIENDLY_NAME,
			    SAFER_TRUSTED_PUBLISHER_STORE_NAME,
			    L"",
			    rsopObjectArray,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    
        m_pDisallowedStore = new CCertStoreRSOP (
			    CERT_SYSTEM_STORE_RELOCATE_FLAG,
			    L"",
			    SAFER_DISALLOWED_STORE_FRIENDLY_NAME,
			    SAFER_DISALLOWED_STORE_NAME,
			    L"",
			    rsopObjectArray,
                bIsMachine ? NODEID_Machine : NODEID_User,
			    pConsole);
    }

 }

CSaferEntries::~CSaferEntries ()
{
    if ( m_pTrustedPublishersStore )
    {
        m_pTrustedPublishersStore->Release ();
        m_pTrustedPublishersStore = 0;
    }

    if ( m_pDisallowedStore )
    {
        m_pDisallowedStore->Release ();
        m_pDisallowedStore = 0;
    }
}

HRESULT CSaferEntries::GetTrustedPublishersStore(CCertStore **ppStore)
{
    if ( !ppStore )
        return E_POINTER;

    if ( m_pTrustedPublishersStore )
    {
        m_pTrustedPublishersStore->AddRef ();
        *ppStore = m_pTrustedPublishersStore;
    }
    else
        return E_FAIL;

    return S_OK;
}

HRESULT CSaferEntries::GetDisallowedStore(CCertStore **ppStore)
{
    if ( !ppStore )
        return E_POINTER;

    if ( m_pDisallowedStore )
    {
        m_pDisallowedStore->AddRef ();
        *ppStore = m_pDisallowedStore;
    }
    else
        return E_FAIL;


    return S_OK;
}

HRESULT SetRegistryScope (HKEY hKey, bool bIsComputer)
{
    HRESULT hr = S_OK;

 
    if ( g_hkeyLastSaferRegistryScope != hKey || g_bIsComputer != bIsComputer )
    {
        BOOL bRVal = SaferiChangeRegistryScope (hKey, REG_OPTION_NON_VOLATILE);
        ASSERT (bRVal);
        if ( bRVal )
        {
            g_hkeyLastSaferRegistryScope = hKey;
            g_bIsComputer = bIsComputer;
        }
        else
        {
            DWORD dwErr = GetLastError ();
            hr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"SaferiChangeRegistryScope (%s) failed: %d\n", 
                    hKey ? L"hKey" : L"0", dwErr);
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////

// Returns S_OK if the file has a valid signed hash
HRESULT GetSignedFileHash(
    IN LPCWSTR pwszFilename,
    OUT BYTE rgbFileHash[SAFER_MAX_HASH_SIZE],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    )
{
    HRESULT hr = S_OK;
    if ( !pwszFilename || !rgbFileHash || !pcbFileHash || !pHashAlgid )
        return E_POINTER;
    _TRACE (1, L"Entering GetSignedFileHash (%s)\n", pwszFilename);

    // Returns S_OK and the hash if the file was signed and contains a valid
    // hash
    *pcbFileHash = SAFER_MAX_HASH_SIZE;
    hr = WTHelperGetFileHash(
            pwszFilename,
            0,
            NULL,
            rgbFileHash,
            pcbFileHash,
            pHashAlgid);
    if ( FAILED (hr) )
    {
        _TRACE (0, L"WTHelperGetFileHash (%s) failed: 0x%x\n", pwszFilename, hr);
    }

    _TRACE (-1, L"Leaving GetSignedFileHash (%s): 0x%x\n", pwszFilename, hr);
    return hr;
}


HRESULT ComputeMD5Hash(IN HANDLE hFile, BYTE hashResult[SAFER_MAX_HASH_SIZE], DWORD& dwHashSize)
/*++

Routine Description:

    Computes the MD5 hash of a given file's contents and prints the
    resulting hash value to the screen.

Arguments:

    szFilename - filename to compute hash of.

Return Value:

    Returns 0 on success, or a non-zero exit code on failure.

--*/
{
    _TRACE (1, L"Entering ComputeMD5Hash ()\n");
    HRESULT     hr = S_OK;

    ASSERT (hashResult);
    if ( !hashResult )
        return E_POINTER;

    //
    // Open the specified file and map it into memory.
    //
    // security review 2/25/2002 BryanWal ok 
    // NOTICE - hFile is from GetOpenFileName ()
    HANDLE  hMapping = ::CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if ( hMapping )
    {
        DWORD dwDataLen = GetFileSize (hFile, NULL);

        if ( -1 != dwDataLen )
        {
            // security review 2/25/2002 BryanWal ok
            LPBYTE pbData = (LPBYTE) ::MapViewOfFile (hMapping, FILE_MAP_READ, 0, 0, dwDataLen);
            if ( pbData ) 
            {
                //
                // Generate the hash value of the specified file.
                //
                HCRYPTPROV  hProvider = 0;
                if ( CryptAcquireContext(&hProvider, NULL, NULL,
                      PROV_RSA_SIG, CRYPT_VERIFYCONTEXT) ||
                  CryptAcquireContext(&hProvider, NULL, NULL,
                      PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) )
                {
                    HCRYPTHASH  hHash = 0;
                    if ( CryptCreateHash(hProvider, CALG_MD5, 0, 0, &hHash) )
                    {
                        if ( CryptHashData (hHash, pbData, dwDataLen, 0) )
                        {
                            dwHashSize = SAFER_MAX_HASH_SIZE;
                            
                            if (!CryptGetHashParam(hHash, HP_HASHVAL, hashResult, &dwHashSize, 0))
                            {
                                dwHashSize = 0;
                                DWORD   dwErr = GetLastError ();
                                hr = HRESULT_FROM_WIN32 (dwErr);
                                _TRACE (0, L"CryptHashData () failed: 0x%x\n", hr);
                            }
                        }
                        else
                        {
                            DWORD   dwErr = GetLastError ();
                            hr = HRESULT_FROM_WIN32 (dwErr);
                            _TRACE (0, L"CryptHashData () failed: 0x%x\n", hr);
                        }
                        CryptDestroyHash(hHash);
                    }
                    else
                    {
                        DWORD   dwErr = GetLastError ();
                        hr = HRESULT_FROM_WIN32 (dwErr);
                        _TRACE (0, L"CryptCreateHash () failed: 0x%x\n", hr);
                    }
                    CryptReleaseContext(hProvider, 0);
                }
                else
                {
                    DWORD   dwErr = GetLastError ();
                    hr = HRESULT_FROM_WIN32 (dwErr);
                    _TRACE (0, L"CryptAcquireContext () failed: 0x%x\n", hr);
                }

                ::UnmapViewOfFile(pbData);
            }
            else
            {
                DWORD   dwErr = GetLastError ();
                _TRACE (0, L"MapViewOfFile () failed: 0x%x\n", dwErr);
                hr = HRESULT_FROM_WIN32 (dwErr);
            }
        }
        else
        {
            DWORD   dwErr = GetLastError ();
            _TRACE (0, L"GetFileSize () failed: 0x%x\n", dwErr);
            hr = HRESULT_FROM_WIN32 (dwErr);
        }

        VERIFY (CloseHandle(hMapping));
        hMapping = 0;
    }
    else
    {
        DWORD   dwErr = GetLastError ();
        _TRACE (0, L"CreateFileMapping () failed: 0x%x\n", dwErr);
        hr = HRESULT_FROM_WIN32 (dwErr);
    }

    _TRACE (-1, L"Leaving ComputeMD5Hash (): 0x%x\n", hr);
    return hr;
}

CString GetURLZoneFriendlyName (DWORD dwURLZoneID)
{
    CString szFriendlyName;

    switch (dwURLZoneID)
    {
    case URLZONE_LOCAL_MACHINE:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_LOCAL_MACHINE));
        break;

    case URLZONE_INTRANET:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_INTRANET));
        break;

    case URLZONE_TRUSTED:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_TRUSTED));
        break;

    case URLZONE_INTERNET:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_INTERNET));
        break;

    case URLZONE_UNTRUSTED:
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_UNTRUSTED));
        break;

    default:
        ASSERT (0);
        VERIFY (szFriendlyName.LoadString (IDS_URLZONE_UNKNOWN));
        break;
    }

    return szFriendlyName;
}

//
// Given a GUID in string format it returns a GUID struct
//
// e.g. "{00299570-246d-11d0-a768-00aa006e0529}" to a struct form
//

BOOL GuidFromString(GUID* pGuid, const CString& szGuidString)
{
    ASSERT (pGuid);
    if ( !pGuid )
        return FALSE;

    // security review 2/25/2002 BryanWal ok
    ::ZeroMemory(pGuid, sizeof(GUID));

    // security review 2/25/2002 BryanWal ok
    size_t nLen = wcslen (szGuidString);
    // the string length should be 38
    if (nLen != 38)
        return FALSE;

    return SUCCEEDED(::CLSIDFromString ((LPOLESTR)((PCWSTR)szGuidString), pGuid));
}


HRESULT SaferSetDefinedFileTypes (
            HWND hWnd, 
            HKEY hGroupPolicyKey, 
            PCWSTR pszFileTypes, 
            int nBufLen)
{
    HRESULT hr = S_OK;
    DWORD   dwDisposition = 0;

    HKEY    hKey = 0;
    LONG lResult = ::RegCreateKeyEx (hGroupPolicyKey, // handle of an open key
            SAFER_COMPUTER_CODEIDS_REGKEY,     // address of subkey name
            0,       // reserved
            L"",       // address of class string
            REG_OPTION_NON_VOLATILE,      // special options flag
            // security review 2/25/2002 BryanWal ok
            KEY_SET_VALUE,    // desired security access
            NULL,     // address of key security structure
			&hKey,      // address of buffer for opened handle
		    &dwDisposition);  // address of disposition value buffer
	ASSERT (ERROR_SUCCESS == lResult);
    if ( ERROR_SUCCESS == lResult )
    {
        lResult = ::RegSetValueEx (
                hKey,           // handle to key
                SAFER_EXETYPES_REGVALUE, // value name
                0,      // reserved
                REG_MULTI_SZ,        // value type
                (PBYTE) pszFileTypes,  // value data
                nBufLen);         // size of value data
        if ( ERROR_SUCCESS != lResult )
        {
            DisplaySystemError (hWnd, lResult);
            _TRACE (0, L"RegSetValueEx (SAFER_EXETYPES_REGVALUE, %s) failed: %d\n", 
                    pszFileTypes, lResult);
            hr = HRESULT_FROM_WIN32 (lResult);
        }

        RegCloseKey (hKey);
    }
    else
    {
        DisplaySystemError (hWnd, lResult);
        _TRACE (0, L"RegCreateKeyEx (SAFER_CODEID_KEY) failed: %d\n", lResult);
        hr = HRESULT_FROM_WIN32 (lResult);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\selacct.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SelAcct.cpp
//
//  Contents:   Implementation of property page to allow account selection for
//				cert management
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "SelAcct.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern HINSTANCE g_hInstance;
/////////////////////////////////////////////////////////////////////////////
// CSelectAccountPropPage property page

//IMPLEMENT_DYNCREATE(CSelectAccountPropPage, CAutoDeletePropPage)

CSelectAccountPropPage::CSelectAccountPropPage (const bool bIsWindowsNT) 
: CAutoDeletePropPage(CSelectAccountPropPage::IDD),
	m_pdwLocation (0),
	m_bIsWindowsNT (bIsWindowsNT)
{
	//{{AFX_DATA_INIT(CSelectAccountPropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


CSelectAccountPropPage::~CSelectAccountPropPage()
{
}

void CSelectAccountPropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectAccountPropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectAccountPropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CSelectAccountPropPage)
	ON_BN_CLICKED(IDC_PERSONAL_ACCT, OnPersonalAcct)
	ON_BN_CLICKED(IDC_SERVICE_ACCT, OnServiceAcct)
	ON_BN_CLICKED(IDC_MACHINE_ACCT, OnMachineAcct)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectAccountPropPage message handlers

BOOL CSelectAccountPropPage::OnInitDialog() 
{
	AfxSetResourceHandle (g_hInstance);
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
		*m_pdwLocation = CERT_SYSTEM_STORE_CURRENT_USER;
	CAutoDeletePropPage::OnInitDialog();
	
	GetDlgItem (IDC_PERSONAL_ACCT)->SendMessage (BM_SETCHECK, BST_CHECKED, 0);

	if ( !m_bIsWindowsNT )
	{
		GetDlgItem (IDC_SERVICE_ACCT)->EnableWindow (FALSE);
	}
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CSelectAccountPropPage::AssignLocationPtr(DWORD * pdwLocation)
{
	m_pdwLocation = pdwLocation;
}

/////////////////////////////////////////////////////////////////////////////
// MyPropertyPage message handlers

void CSelectAccountPropPage::OnPersonalAcct() 
{
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
	{
		*m_pdwLocation = CERT_SYSTEM_STORE_CURRENT_USER;
		GetParent ()->SendMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
	}
}

void CSelectAccountPropPage::OnServiceAcct()
{
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
	{
		*m_pdwLocation = CERT_SYSTEM_STORE_SERVICES;
		GetParent ()->SendMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	}
}

void CSelectAccountPropPage::OnMachineAcct()
{
	ASSERT (m_pdwLocation);
	if ( m_pdwLocation )
	{
		*m_pdwLocation = CERT_SYSTEM_STORE_LOCAL_MACHINE;
		GetParent ()->SendMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	}
}

BOOL CSelectAccountPropPage::OnSetActive() 
{
	BOOL	bResult = CAutoDeletePropPage::OnSetActive();
	ASSERT (bResult);

	if ( bResult )
	{
		if ( m_bIsWindowsNT )
		{
			if ( GetDlgItem (IDC_PERSONAL_ACCT)->SendMessage (BM_GETCHECK, BST_CHECKED, 0) 
					== BST_CHECKED )
			{
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
			}
			else
			{
				GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
			}
		}
		else
		{
			// If Windows 95 or Windows 98, we only allow local machine
			GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_FINISH);
		}
	}
	
	return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\saferutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000-2002.
//
//  File:       SaferUtil.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#ifndef __SAFERUTIL_H
#define __SAFERUTIL_H
#include <winsafer.h>
#include <winsaferp.h>
#include "cookie.h"
#include "storegpe.h"
#include "StoreRSOP.h"
#include "SaferStore.h"

CString SaferGetLevelFriendlyName (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer);
CString SaferGetLevelDescription (DWORD dwLevelID, HKEY hGroupPolicyKey, const bool bIsComputer);

void InitializeSecurityLevelComboBox (
        CComboBox& comboBox, 
        bool bLimit, 
        DWORD dwLevelID, 
        HKEY hGroupPolicyKey,
        DWORD* pdwSaferLevels,
        bool bIsComputer);
HRESULT SaferGetLevelID (SAFER_LEVEL_HANDLE hLevel, DWORD& dwLevelID);

class CSaferEntries : public CCertMgrCookie
{
public:
	CSaferEntries (
            bool bIsMachine, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName, 
            IGPEInformation* pGPEInformation,
            IRSOPInformation* pRSOPInformation,
            CRSOPObjectArray& m_rsopObjectArray,
            LPCONSOLE   pConsole);

    virtual ~CSaferEntries ();

  	HRESULT GetDisallowedStore (CCertStore** ppStore);
	HRESULT GetTrustedPublishersStore (CCertStore** ppStore);

protected:


private:
    CCertStore*    m_pTrustedPublishersStore;
    CCertStore*    m_pDisallowedStore;
};

class CSaferRootCookie : public CCertMgrCookie
{
public:
	CSaferRootCookie (
            CertificateManagerObjectType objecttype, 
            PCWSTR pszMachineName, 
            PCWSTR pszObjectName)
            : CCertMgrCookie (objecttype,
        pszMachineName, pszObjectName), 
    m_bCreateSaferNodes (true),
    m_bExpandedOnce (false)
    {
    }

    virtual ~CSaferRootCookie ()
    {
    };

    bool    m_bCreateSaferNodes;
    bool    m_bExpandedOnce;
};


HRESULT SetRegistryScope (HKEY hKey, bool bIsComputer);


// Returns S_OK if the file has a valid signed hash
HRESULT GetSignedFileHash(
    IN LPCWSTR pwszFilename,
    OUT BYTE rgbFileHash[SAFER_MAX_HASH_SIZE],
    OUT DWORD *pcbFileHash,
    OUT ALG_ID *pHashAlgid
    );
HRESULT ComputeMD5Hash(IN HANDLE hFile, BYTE hashresult[SAFER_MAX_HASH_SIZE], DWORD& dwHashSize);

CString GetURLZoneFriendlyName (DWORD dwURLZoneID);
BOOL GuidFromString(GUID* pGuid, const CString& szGuidString);


HRESULT SaferSetDefinedFileTypes (HWND hWnd, HKEY hGroupPolicyKey, PCWSTR pszFileTypes, int nBufLen);


#define SAFER_TRUSTED_PUBLISHER_STORE_FRIENDLY_NAME L"Safer Trusted Publisher Store"
#define SAFER_DISALLOWED_STORE_FRIENDLY_NAME        L"Safer Disallowed Store"
#define SAFER_LEVELOBJECTS_REGKEY \
            SAFER_HKLM_REGBASE SAFER_OBJECTS_REGSUBKEY

#define SAFER_COMPUTER_CODEIDS_REGKEY   SAFER_HKLM_REGBASE L"\\" SAFER_CODEIDS_REGSUBKEY
#define SAFER_USER_CODEIDS_REGKEY       SAFER_HKCU_REGBASE L"\\" SAFER_CODEIDS_REGSUBKEY

#define MD5_HASH_LEN    16
#define SHA1_HASH_LEN   20

#define NO_MORE_SAFER_LEVELS -1

#define ILLEGAL_FAT_CHARS   L"\"+,;<=>[]|"


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\selacct.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       selacct.h
//
//  Contents:   Property page to choose type of cert administration.
//
//----------------------------------------------------------------------------
#if !defined(AFX_SELACCT_H__E76F93EC_23F0_11D1_A28B_00C04FB94F17__INCLUDED_)
#define AFX_SELACCT_H__E76F93EC_23F0_11D1_A28B_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelAcct.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectAccountPropPage dialog

class CSelectAccountPropPage : public CAutoDeletePropPage
{
//	DECLARE_DYNCREATE(CSelectAccountPropPage)

// Construction
public:
	void AssignLocationPtr (DWORD* pdwLocation);
//	CSelectAccountPropPage();  // default, but don't use
	CSelectAccountPropPage(const bool m_bIsWindowsNT);
	virtual ~CSelectAccountPropPage();

// Dialog Data
	//{{AFX_DATA(CSelectAccountPropPage)
	enum { IDD = IDD_PROPPAGE_CHOOSE_ACCOUNT };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectAccountPropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSelectAccountPropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnPersonalAcct();
	afx_msg void OnServiceAcct();
	afx_msg void OnMachineAcct();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	const bool m_bIsWindowsNT;
	DWORD* m_pdwLocation;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELACCT_H__E76F93EC_23F0_11D1_A28B_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\snapmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SnapMgr.cpp
//
//  Contents:   implementation file for Snapin Manager property page
//
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include "chooser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\selservc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SelServc.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_SELSERVC_H__9A888DAC_62BF_11D1_85BA_00C04FB94F17__INCLUDED_)
#define AFX_SELSERVC_H__9A888DAC_62BF_11D1_85BA_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// SelServc.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSelectServiceAccountPropPage dialog

class CSelectServiceAccountPropPage : public CAutoDeletePropPage
{
//	DECLARE_DYNCREATE(CSelectServiceAccountPropPage)

// Construction
public:
	CSelectServiceAccountPropPage (
			CString* pszManagedService, 
			CString* pszManagedServiceDisplayName,
			const CString& pszManagedMachine);
	virtual ~CSelectServiceAccountPropPage();

// Dialog Data
	//{{AFX_DATA(CSelectServiceAccountPropPage)
	enum { IDD = IDD_PROPPAGE_CHOOSE_SERVICE };
	CListBox	m_acctNameList;
	CStatic		m_instructionsText;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSelectServiceAccountPropPage)
	protected:
	virtual BOOL OnSetActive();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void CopyCurrentString ();
	void FreeDataPointers ();
	HRESULT EnumerateServices ();
	// Generated message map functions
	//{{AFX_MSG(CSelectServiceAccountPropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeAcctName();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CString		m_savedManagedMachineName;
	const CString&	m_szManagedMachine;
	CString*	m_pszManagedService;
	CString*	m_pszManagedServiceDisplayName;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SELSERVC_H__9A888DAC_62BF_11D1_85BA_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\stdafx.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       StdAFX.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------\
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#pragma warning(push, 3)
#include <statreg.h>
#include <statreg.cpp>
#pragma warning(pop)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\selservc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       SelServc.cpp
//
//  Contents:   Implementation of Service Selection setup page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "SelServc.h"

USE_HANDLE_MACROS("CERTMGR(SelServc.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSelectServiceAccountPropPage property page

//IMPLEMENT_DYNCREATE(CSelectServiceAccountPropPage, CAutoDeletePropPage)

CSelectServiceAccountPropPage::CSelectServiceAccountPropPage(
		CString* pszManagedService, 
		CString* pszManagedServiceDisplayName,
		const CString& szManagedMachine) : 
	CAutoDeletePropPage(CSelectServiceAccountPropPage::IDD),
	m_pszManagedService (pszManagedService),
	m_pszManagedServiceDisplayName (pszManagedServiceDisplayName),
	m_szManagedMachine (szManagedMachine),
	m_savedManagedMachineName (_T("$uninitialized machine name$"))
{
	ASSERT (pszManagedService);
	//{{AFX_DATA_INIT(CSelectServiceAccountPropPage)
	//}}AFX_DATA_INIT
}

CSelectServiceAccountPropPage::~CSelectServiceAccountPropPage()
{
}

void CSelectServiceAccountPropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSelectServiceAccountPropPage)
	DDX_Control(pDX, IDC_ACCT_NAME, m_acctNameList);
	DDX_Control(pDX, IDC_INSTRUCTIONS, m_instructionsText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSelectServiceAccountPropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CSelectServiceAccountPropPage)
	ON_CBN_SELCHANGE(IDC_ACCT_NAME, OnSelchangeAcctName)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSelectServiceAccountPropPage message handlers


BOOL CSelectServiceAccountPropPage::OnSetActive() 
{
	BOOL	bResult = CAutoDeletePropPage::OnSetActive();
	ASSERT (bResult);


	if ( IsLocalComputername (m_szManagedMachine) )
	{
		CString	text;
		VERIFY (text.LoadString (IDS_SELECT_SERVICE_ON_LOCAL_MACHINE));
		m_instructionsText.SetWindowText (text);
	}
	else
	{
		CString text;
		size_t	len = m_instructionsText.GetWindowTextLength () + 1;
		m_instructionsText.GetWindowText (text.GetBufferSetLength ((int) len), (int) len);
		text.FormatMessage (text, m_szManagedMachine);
		m_instructionsText.SetWindowText (text);
	}

	if ( m_savedManagedMachineName != m_szManagedMachine )
	{
    	GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
                PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
		m_savedManagedMachineName = m_szManagedMachine;
		FreeDataPointers  ();
		EnumerateServices ();
	}
    else
    {
    	GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
                PSWIZB_BACK | PSWIZB_FINISH);
    }

	return bResult;
}

BOOL CSelectServiceAccountPropPage::OnInitDialog() 
{
	CAutoDeletePropPage::OnInitDialog();
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

HRESULT CSelectServiceAccountPropPage::EnumerateServices()
{
	HRESULT hResult = S_OK;
    DWORD					cbBytesNeeded = 0;
    DWORD					entriesRead = 0;
    DWORD					resumeHandle = 0;
	DWORD					dwErr = 0;
	LPCWSTR lpMachineName = (LPCWSTR) (m_szManagedMachine);

    SC_HANDLE	hScManager = ::OpenSCManager (lpMachineName,
                    SERVICES_ACTIVE_DATABASE,
                    SC_MANAGER_ENUMERATE_SERVICE);
    if ( hScManager ) 
	{
	    LPENUM_SERVICE_STATUS	enumBuffer = new ENUM_SERVICE_STATUS[32];
		DWORD					cbBufSize = sizeof (ENUM_SERVICE_STATUS) * 32;
		BOOL					bResult = FALSE;

		if ( enumBuffer )
		{
			int	nIndex = 0;
			//
			// Enumerate the ServiceStatus
			//
			dwErr = NO_ERROR;

			do 
			{
				bResult = ::EnumServicesStatus (
						hScManager,
						SERVICE_WIN32,
						SERVICE_STATE_ALL,
						enumBuffer,
						cbBufSize,
						&cbBytesNeeded,
						&entriesRead,
						&resumeHandle);
				if ( bResult || GetLastError() == ERROR_MORE_DATA )
				{
					for (UINT i = 0; i < entriesRead && SUCCEEDED (hResult); i++)
					{
						nIndex = m_acctNameList.AddString (
								enumBuffer[i].lpDisplayName);
						ASSERT (nIndex >= 0);
						switch ( nIndex )
						{
						case LB_ERR:
							hResult = E_FAIL;
							break;

						case LB_ERRSPACE:
							hResult = E_OUTOFMEMORY;
							break;

						default:
							nIndex = m_acctNameList.SetItemDataPtr (nIndex, 
									new CString (enumBuffer[i].lpServiceName));
							ASSERT (nIndex != LB_ERR);
							if ( nIndex == LB_ERR )
								hResult = E_FAIL;
							break;
						}
					}
				}
				else
				{
					dwErr = GetLastError();
					DisplaySystemError (m_hWnd, dwErr);
					hResult = HRESULT_FROM_WIN32 (dwErr);
					break;
				}
			} while (SUCCEEDED (hResult) && resumeHandle > 0);

			int nCnt = m_acctNameList.GetCount ();
			ASSERT (nCnt != LB_ERR);
			if ( nCnt > 0 )
			{	
				nIndex = m_acctNameList.SetCurSel (0);
				ASSERT (nIndex != LB_ERR);
				if ( nIndex != LB_ERR )
				{
					CopyCurrentString ();
					if ( m_pszManagedService && m_pszManagedService->IsEmpty () )
						GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
								PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
					else
						GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
								PSWIZB_BACK | PSWIZB_FINISH);
				}
			}
			
			delete [] enumBuffer;
		}
		else
		{
			hResult = E_OUTOFMEMORY;
		}

		bResult = ::CloseServiceHandle (hScManager);
		ASSERT (bResult);
		if ( !bResult )
		{
			dwErr = GetLastError ();
			DisplaySystemError (m_hWnd, dwErr);
			hResult = HRESULT_FROM_WIN32 (dwErr);
		}
	}
	else
	{
        dwErr = GetLastError ();
		DisplaySystemError (m_hWnd, dwErr);
		hResult = HRESULT_FROM_WIN32 (dwErr);
/*
		switch (dwErr)
		{
		case ERROR_ACCESS_DENIED: // The requested access was denied. 
			break;

		case ERROR_DATABASE_DOES_NOT_EXIST: // The specified database does not exist. 
			break;

		case ERROR_INVALID_PARAMETER:
			break;

		case RPC_S_SERVER_UNAVAILABLE:
			break;
		}
*/
    }

	return hResult;
}

void CSelectServiceAccountPropPage::OnSelchangeAcctName() 
{
	CopyCurrentString ();
	ASSERT (m_pszManagedService);
	if ( m_pszManagedService && m_pszManagedService->IsEmpty () )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
				PSWIZB_BACK | PSWIZB_DISABLEDFINISH);
	else
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, 
				PSWIZB_BACK | PSWIZB_FINISH);
}

void CSelectServiceAccountPropPage::FreeDataPointers()
{
	CString*	pStr = 0;
	int			nCnt = m_acctNameList.GetCount ();

	for (int i = nCnt-1; i >= 0; i--)
	{
		pStr = (CString*) m_acctNameList.GetItemDataPtr (i);
		ASSERT (pStr != (CString*) LB_ERR);
		ASSERT (pStr);
		if ( pStr && pStr != (CString*) LB_ERR )
			delete pStr;
		m_acctNameList.SetItemDataPtr (i, 0);
        m_acctNameList.DeleteString (i);
	}
}

void CSelectServiceAccountPropPage::OnDestroy() 
{
	CAutoDeletePropPage::OnDestroy();
	
	FreeDataPointers  ();
}

void CSelectServiceAccountPropPage::CopyCurrentString()
{
	ASSERT (m_pszManagedService);
	if ( m_pszManagedService )
	{
		int	nIndex = m_acctNameList.GetCurSel ();
		ASSERT (LB_ERR != nIndex);
		if ( LB_ERR != nIndex )
		{
			CString*	pStr = (CString*) m_acctNameList.GetItemDataPtr (nIndex);
			ASSERT (pStr && pStr != (CString*) LB_ERR);
			if ( pStr && pStr != (CString*) LB_ERR )
				*m_pszManagedService = *pStr;

			m_acctNameList.GetText (nIndex, 
					*m_pszManagedServiceDisplayName);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\snapmgr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       SnapMgr.h
//
//  Contents:   header file for Snapin Manager property page
//
//----------------------------------------------------------------------------

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#endif // ~__SNAPMGR_H__
/////////////////////////////////////////////////////////////////////////////
// CCertMgrChooseMachinePropPage dialog

class CCertMgrChooseMachinePropPage : public CChooseMachinePropPage
{
// Construction
public:
	CCertMgrChooseMachinePropPage();
	virtual ~CCertMgrChooseMachinePropPage();
	void AssignLocationPtr (DWORD* pdwLocation);

// Dialog Data
	//{{AFX_DATA(CCertMgrChooseMachinePropPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCertMgrChooseMachinePropPage)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCertMgrChooseMachinePropPage)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	virtual LRESULT OnWizardNext();
    virtual BOOL OnKillActive();

private:
	DWORD* m_pdwLocation;
};
/////////////////////////////////////////////////////////////////////////////
// CCertMgrChooseMachinePropPage property page

CCertMgrChooseMachinePropPage::CCertMgrChooseMachinePropPage() : 
	CChooseMachinePropPage(),
	m_pdwLocation (0)
{
	//{{AFX_DATA_INIT(CCertMgrChooseMachinePropPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CCertMgrChooseMachinePropPage::~CCertMgrChooseMachinePropPage()
{
}

void CCertMgrChooseMachinePropPage::AssignLocationPtr(DWORD * pdwLocation)
{
	m_pdwLocation = pdwLocation;
}

void CCertMgrChooseMachinePropPage::DoDataExchange(CDataExchange* pDX)
{
	CChooseMachinePropPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCertMgrChooseMachinePropPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCertMgrChooseMachinePropPage, CChooseMachinePropPage)
	//{{AFX_MSG_MAP(CCertMgrChooseMachinePropPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCertMgrChooseMachinePropPage message handlers
BOOL CCertMgrChooseMachinePropPage::OnSetActive() 
{
	if ( m_pdwLocation && CERT_SYSTEM_STORE_SERVICES == *m_pdwLocation )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_NEXT);
	else
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_BACK | PSWIZB_FINISH);
	
	// Do not call CChooseMachinePropPage here because it will disable the back button. 
	// Call the grandparent instead.
	return CPropertyPage::OnSetActive();
}

BOOL CCertMgrChooseMachinePropPage::OnKillActive()
{
	ASSERT_VALID(this);

    // override CPropertyPage::OnKillActive () so that UpdateData is not called
    return TRUE;
}

LRESULT CCertMgrChooseMachinePropPage::OnWizardNext()
{
	if ( !UpdateData (TRUE) )
        return -1;

	if ( m_pstrMachineNameOut )
    {
        // Store the machine name into its output buffer
        // NTRAID# 487794 Certificates/Service account: cannot add snapin 
        // targeted to local computer if illegal chars present in "Another 
        // computer" textbox
        if ( m_fIsRadioLocalMachine )
		    *m_pstrMachineNameOut = L"";
        else
            *m_pstrMachineNameOut = m_strMachineName;

        if (m_pfAllowOverrideMachineNameOut != NULL)
			*m_pfAllowOverrideMachineNameOut = m_fAllowOverrideMachineName;
    }

	return CChooseMachinePropPage::OnWizardNext ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once 
#endif // _MSC_VER >= 1000

#define STRICT

#pragma warning(push,3)

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#define NT_INCLUDED
#undef ASSERT
#undef ASSERTMSG

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage
#include <afxcmn.h>     // CSpinButtonCtrl
#include <afxext.h>
#include <afxmt.h>

//#define _WIN32_WINNT 0x0500
#define _ATL_APARTMENT_THREADED

#include <mmc.h>
#include "certmgr.h"

EXTERN_C const CLSID CLSID_CertificateManager;
EXTERN_C const CLSID CLSID_CertificateManagerPKPOLExt;
EXTERN_C const CLSID CLSID_SaferWindowsExtension;


#include <xstring>
#include <list>
#include <vector>
#include <algorithm>

using namespace std;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
/*
 * Define/include the stuff we need for WTL::CImageList.  We need prototypes
 * for IsolationAwareImageList_Read and IsolationAwareImageList_Write here
 * because commctrl.h only declares them if __IStream_INTERFACE_DEFINED__
 * is defined.  __IStream_INTERFACE_DEFINED__ is defined by objidl.h, which
 * we can't include before including afx.h because it ends up including
 * windows.h, which afx.h expects to include itself.  Ugh.
 */
HIMAGELIST WINAPI IsolationAwareImageList_Read(LPSTREAM pstm);
BOOL WINAPI IsolationAwareImageList_Write(HIMAGELIST himl,LPSTREAM pstm);
#define _WTL_NO_AUTOMATIC_NAMESPACE
#include <atlapp.h>
#include <atlwin.h>

#include <atlctrls.h>
#include <lmcons.h>

#include "stdcooki.h" // from ..\framewrk
#include "stdcmpnt.h" // from ..\framewrk
#include "stdcdata.h" // from ..\framewrk
#include "persist.h" // PersistStream   from ..\framewrk
#include "stdutils.h" // GetObjectType() utility routines from ..\corecopy
#include "stddtobj.h" // class DataObject   from ..\framewrk
#include "stdabout.h" // from ..\framewrk


#include "chooser.h" //                 from ..\chooser
#include "regkey.h" // AMC::CRegKey     from ..\corecopy
#include "safetemp.h"   // from ..\corecopy
#include "macros.h"
#include "guidhelp.h" // GuidToCString

#include <comstrm.h>

#include <strings.h>
#include <dsrole.h>
#include <lmapibuf.h>

#include <prsht.h>
#include <shlobj.h>
#include <dsclient.h>
#include <objsel.h>

#include <CertCA.h>
#include <wincrypt.h>

// For theming
#include <shfusion.h>

#include "dbg.h"

#pragma warning(pop)


#include "DisabledWarnings.h"
#include "helpids.h"
#include "CMUtils.h"
#include "debug.h"
#include "resource.h"
#include "HelpPropertyPage.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\storegpe.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       StoreGPE.cpp
//
//  Contents:   Implementation of CCertStoreGPE
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "cookie.h"
#include "storegpe.h"
#include "certifct.h"

USE_HANDLE_MACROS("CERTMGR(storegpe.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

GUID g_guidExtension = { 0xb1be8d72, 0x6eac, 0x11d2, {0xa4, 0xea, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x3a }};
GUID g_guidRegExt = REGISTRY_EXTENSION_GUID;
GUID g_guidSnapin = CLSID_CertificateManager;

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
HRESULT CCertStoreGPE::Commit ()
{
    _TRACE (1, L"Entering CCertStoreGPE::Commit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    HRESULT hr = S_OK;


    if ( GetStoreType () == EFS_STORE && !m_fIsNullEFSPolicy )
    {
        if ( SUCCEEDED (hr) )
            hr = WriteEFSBlobToRegistry ();
    }

    if ( SUCCEEDED (hr) && m_bDirty )
    {
        hr = CCertStore::Commit ();
        ASSERT (SUCCEEDED (hr));
        ASSERT (m_pGPEInformation);
        if ( SUCCEEDED (hr) && m_pGPEInformation )
        {
            hr = m_pGPEInformation->PolicyChanged (
                    m_fIsComputerType ? TRUE : FALSE,
                    m_bAddInCallToPolicyChanged, &g_guidExtension, &g_guidSnapin );
             hr = m_pGPEInformation->PolicyChanged (
                    m_fIsComputerType ? TRUE : FALSE,
                    m_bAddInCallToPolicyChanged, &g_guidRegExt, &g_guidSnapin );
            ASSERT (SUCCEEDED (hr));
        }
    }


    _TRACE (-1, L"Leaving CCertStoreGPE::Commit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}



CCertStoreGPE::CCertStoreGPE (
            DWORD dwFlags,
            LPCWSTR lpcszMachineName,
            LPCWSTR objectName,
            const CString & pcszLogStoreName,
            const CString & pcszPhysStoreName,
            IGPEInformation * pGPTInformation,
            const GUID& compDataGUID,
            IConsole* pConsole)
    : CCertStore (CERTMGR_LOG_STORE_GPE,
        CERT_STORE_PROV_SYSTEM, dwFlags, lpcszMachineName, objectName,
        pcszLogStoreName, pcszPhysStoreName,
        StoreNameToType (pcszLogStoreName),
        0,
        pConsole),
    m_pGPEInformation (pGPTInformation),
    m_fIsNullEFSPolicy (true),       // assume NULL policy until proven otherwise
    m_hGroupPolicyKey (0),
    m_bAddInCallToPolicyChanged (TRUE)
{
    _TRACE (1, L"Entering CCertStoreGPE::CCertStoreGPE - %s\n",
            (LPCWSTR) pcszLogStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    ASSERT (m_pGPEInformation);
    if ( m_pGPEInformation )
    {
        m_pGPEInformation->AddRef ();
        if ( ::IsEqualGUID (compDataGUID, NODEID_User) )
        {
            m_fIsComputerType = false;
            m_dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;
        }
        else if ( ::IsEqualGUID (compDataGUID, NODEID_Machine) )
        {
            m_fIsComputerType = true;
            m_dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;
        }
        else
            ASSERT (0);
    }
    _TRACE (-1, L"Leaving CCertStoreGPE::CCertStoreGPE - %s\n",
            (LPCWSTR) pcszLogStoreName);
}


CCertStoreGPE::~CCertStoreGPE ()
{
    _TRACE (1, L"Entering CCertStoreGPE::~CCertStoreGPE - %s\n",
            (LPCWSTR) m_pcszStoreName);;
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);

    if ( m_hGroupPolicyKey )
        RegCloseKey (m_hGroupPolicyKey);

    if ( m_pGPEInformation )
    {
        m_pGPEInformation->Release ();
        m_pGPEInformation = 0;
    }

    CERT_CONTEXT_PSID_STRUCT* pCert = 0;
    while (!m_EFSCertList.IsEmpty () )
    {
        pCert = m_EFSCertList.RemoveHead ();
        ASSERT (pCert);
        if ( pCert )
            delete pCert;
    }
    _TRACE (-1, L"Leaving CCertStoreGPE::~CCertStoreGPE - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HCERTSTORE CCertStoreGPE::GetStoreHandle (BOOL bSilent /*= FALSE*/, HRESULT* phr /* = 0*/)
{
    _TRACE (1, L"Entering CCertStoreGPE::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    CERT_SYSTEM_STORE_RELOCATE_PARA RelocatePara;
    void*                           pvPara = 0;

    if ( !m_hCertStore )
    {
        DWORD   dwErr = 0;

        if ( EFS_STORE == GetStoreType () && m_fIsNullEFSPolicy )
        {
            // Test to see if EFS key exists, if not, flag this as
            // having no EFS policy and return.
            HKEY    hEFSKey = 0;
            // security review 2/27/2002 BryanWal ok
            LONG lResult = ::RegOpenKeyEx (GetGroupPolicyKey (), CERT_EFSBLOB_REGPATH, 0,
                    KEY_READ, &hEFSKey); 
            if ( ERROR_SUCCESS == lResult )
            {
                m_fIsNullEFSPolicy = false;
                ::RegCloseKey (hEFSKey);
            }
            else
                return 0;
        }
        RelocatePara.hKeyBase = GetGroupPolicyKey ();
        RelocatePara.pwszSystemStore = (LPCWSTR) m_pcszStoreName;
        pvPara = (void*) &RelocatePara;
        m_hCertStore = ::CertOpenStore (m_storeProvider,
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
                m_dwFlags | CERT_STORE_SET_LOCALIZED_NAME_FLAG | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
                pvPara);
        if ( !m_hCertStore )
        {
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            m_hCertStore = ::CertOpenStore (m_storeProvider,
                    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, NULL,
                    m_dwFlags | CERT_STORE_READONLY_FLAG | CERT_STORE_SET_LOCALIZED_NAME_FLAG,
                    pvPara);
            if ( m_hCertStore )
                m_bReadOnly = true;
            else
            {
                dwErr = GetLastError ();
                if ( phr )
                    *phr = HRESULT_FROM_WIN32 (dwErr);
                _TRACE (0, L"CertOpenStore (%s) failed: 0x%x\n", 
                        (PCWSTR) m_pcszStoreName, dwErr);
            }
        }

        if ( !m_hCertStore && !m_bUnableToOpenMsgDisplayed && !bSilent && 
                (USERDS_STORE != GetStoreType ()) )
        {
            m_bUnableToOpenMsgDisplayed = true;
            CString caption;
            CString text;
            int         iRetVal = 0;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_UNABLE_TO_OPEN_STORE, GetStoreName (), 
                    GetSystemMessage (dwErr));
            if ( m_pConsole )
                m_pConsole->MessageBox (text, caption, MB_OK | MB_ICONINFORMATION, &iRetVal);
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);

    return m_hCertStore;
}

bool CCertStoreGPE::CanContain(CertificateManagerObjectType nodeType)
{
    _TRACE (1, L"Entering CCertStoreGPE::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    bool    bCanContain = false;

    switch (nodeType)
    {
    case CERTMGR_CERTIFICATE:
        if ( ROOT_STORE == GetStoreType () ||
                EFS_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    case CERTMGR_CTL:
        if ( TRUST_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bCanContain;
}


bool CCertStoreGPE::IsMachineStore()
{
    _TRACE (0, L"Entering and leaving CCertStoreGPE::IsMachineStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);

    if (m_dwFlags & CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY)
        return true;
    else
        return false;
}


HKEY CCertStoreGPE::GetGroupPolicyKey()
{
    _TRACE (1, L"Entering CCertStoreGPE::GetGroupPolicyKey - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    if ( !m_hGroupPolicyKey )
    {
        if ( m_fIsComputerType )
        {
            HRESULT hr = m_pGPEInformation->GetRegistryKey (GPO_SECTION_MACHINE,
                    &m_hGroupPolicyKey);
            ASSERT (SUCCEEDED (hr));
        }
        else
        {
            HRESULT hr = m_pGPEInformation->GetRegistryKey (GPO_SECTION_USER,
                    &m_hGroupPolicyKey);
            ASSERT (SUCCEEDED (hr));
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::GetGroupPolicyKey - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_hGroupPolicyKey;
}

IGPEInformation * CCertStoreGPE::GetGPEInformation() const
{
    _TRACE (0, L"Entering and leaving CCertStoreGPE::GetGPEInformation - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    return m_pGPEInformation;
}

HRESULT CCertStoreGPE::WriteEFSBlobToRegistry()
{
    _TRACE (1, L"Entering CCertStoreGPE::WriteEFSBlobToRegistry - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    HRESULT hr = S_OK;

    if ( !m_fIsNullEFSPolicy )
    {
        HKEY    hGroupPolicyKey = GetGroupPolicyKey ();
        if ( hGroupPolicyKey )
        {
            DWORD   dwDisposition = 0;
            HKEY    hKeyEFSBlob = 0;
            int     nCertCnt = GetCertCount ();

            // security review 2/27/2002 BryanWal ok - reduce privilege requested
            LONG lResult = ::RegCreateKeyEx (hGroupPolicyKey, // handle of an open key
                    CERT_EFSBLOB_REGPATH,     // address of subkey name
                    0,                  // reserved
                    L"",                // address of class string
                    REG_OPTION_NON_VOLATILE,      // special options flag
                    KEY_SET_VALUE,      // desired security access
                    NULL,               // address of key security structure
                    &hKeyEFSBlob,       // address of buffer for opened handle
                    &dwDisposition);    // address of disposition value buffer
            ASSERT (lResult == ERROR_SUCCESS);
            if ( lResult == ERROR_SUCCESS )
            {
                try {
                    PEFS_PUBLIC_KEY_INFO*   pEFSPKI = new PEFS_PUBLIC_KEY_INFO[nCertCnt];
                    DWORD*                  cbPKI = new DWORD[nCertCnt];
                    PRECOVERY_KEY_1_1*      pRecoveryKey = new PRECOVERY_KEY_1_1[nCertCnt];
                    DWORD*                  cbRecoveryKey = new DWORD[nCertCnt];
                    PRECOVERY_POLICY_1_1    pRecoveryPolicy = 0;
                    DWORD                   cbRecoveryPolicy = 0;
                    BYTE*                   pData = 0;
                    DWORD                   cbData = 0;
                    int                     nActualCertCnt = 0;
                    PCCERT_CONTEXT          pCertContext = 0;

                    if ( !pEFSPKI || ! cbPKI || ! pRecoveryKey || !cbRecoveryKey )
                    {
                        ::RegCloseKey (hKeyEFSBlob);
                        hr = E_OUTOFMEMORY;
                    }
                    else
                    {
                        // security review 2/27/2002 BryanWal ok
                        ::ZeroMemory (pEFSPKI, nCertCnt*sizeof (PEFS_PUBLIC_KEY_INFO));
                        ::ZeroMemory (cbPKI, nCertCnt*sizeof (DWORD));
                        ::ZeroMemory (pRecoveryKey, nCertCnt*sizeof (PRECOVERY_KEY_1_1));
                        ::ZeroMemory (cbRecoveryKey, nCertCnt*sizeof (DWORD));

                        while ( 1 )
                        {
                            // Subsequent calls to CertEnumCertificatesInStore () free pCertContext.  If
                            // we must break prematurely out of this loop, we must CertFreeCertificateContext ()
                            // explicitly on the last pCertContext
                            pCertContext = EnumCertificates (pCertContext);
                            if ( pCertContext )
                            {
                                hr = CreatePublicKeyInformationCertificate (
                                        GetPSIDFromCert (pCertContext),
                                        pCertContext->pbCertEncoded,
                                        pCertContext->cbCertEncoded,
                                        &pEFSPKI[nActualCertCnt],
                                        &cbPKI[nActualCertCnt]);
                                if ( SUCCEEDED (hr) )
                                {
                                    cbRecoveryKey[nActualCertCnt] = sizeof (ULONG) + cbPKI[nActualCertCnt];
                                    pRecoveryKey[nActualCertCnt] = (PRECOVERY_KEY_1_1) 
                                            ::LocalAlloc (LPTR, cbRecoveryKey[nActualCertCnt]);
                                    if ( pRecoveryKey[nActualCertCnt] )
                                    {
                                        pRecoveryKey[nActualCertCnt]->TotalLength = cbRecoveryKey[nActualCertCnt];
                                        // security review 2/27/2002 BryanWal ok
                                        memcpy (&(pRecoveryKey[nActualCertCnt]->PublicKeyInfo),
                                                pEFSPKI[nActualCertCnt],
                                                cbPKI[nActualCertCnt]);
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                        ::CertFreeCertificateContext (pCertContext);
                                        break;
                                    }
                                }
                                nActualCertCnt++;
                                if ( nActualCertCnt > nCertCnt )
                                {
                                    ASSERT (0);
                                    ::CertFreeCertificateContext (pCertContext);
                                    break;
                                }
                            }
                            else
                                break;
                        }
                        Close ();
                        ASSERT (nActualCertCnt == nCertCnt);
                        if ( SUCCEEDED (hr) )
                        {

                            cbRecoveryPolicy = sizeof (RECOVERY_POLICY_HEADER);
                            for (int nIndex = 0; nIndex < nActualCertCnt; nIndex++)
                                cbRecoveryPolicy += cbRecoveryKey[nIndex];
                            pRecoveryPolicy = (PRECOVERY_POLICY_1_1) ::LocalAlloc (LPTR, cbRecoveryPolicy);
                            if ( pRecoveryPolicy )
                            {
                                pRecoveryPolicy->RecoveryPolicyHeader.MajorRevision = EFS_RECOVERY_POLICY_MAJOR_REVISION_1;
                                pRecoveryPolicy->RecoveryPolicyHeader.MinorRevision = EFS_RECOVERY_POLICY_MINOR_REVISION_1;
                                pRecoveryPolicy->RecoveryPolicyHeader.RecoveryKeyCount = nActualCertCnt;

                                // Build array of variable size recovery keys.
                                BYTE* ptr = (BYTE*) pRecoveryPolicy->RecoveryKeyList;
                                for (int nIndex = 0; nIndex < nActualCertCnt; nIndex++)
                                {
                                    // security review 2/27/2002 BryanWal ok
                                    memcpy (ptr, pRecoveryKey[nIndex], cbRecoveryKey[nIndex]);
                                    ptr += cbRecoveryKey[nIndex];
                                }
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }

                            if ( pRecoveryPolicy )  // otherwise, the value is set to 0
                            {
                                pData = (BYTE*) pRecoveryPolicy;
                                cbData = cbRecoveryPolicy;
                            }
                            lResult =  ::RegSetValueEx (hKeyEFSBlob,       // handle of key to set value for
                                    CERT_EFSBLOB_VALUE_NAME, // address of value to set
                                    0,              // reserved
                                    REG_BINARY, // flag for value type
                                    pData,      // address of value data
                                    cbData);    // size of value data
                            if ( lResult == ERROR_SUCCESS )
                            {
                                m_bDirty = true;
                            }
                            else
                                DisplaySystemError (NULL, lResult);
                        }
                        ::RegCloseKey (hKeyEFSBlob);
                        hKeyEFSBlob = 0;

                        // Free all the allocated pointers in the arrays.
                        for (int nIndex = 0; nIndex < nActualCertCnt; nIndex++)
                        {
                            if ( pEFSPKI[nIndex] )
                                ::LocalFree (pEFSPKI[nIndex]);
                            if ( pRecoveryKey[nIndex] )
                                ::LocalFree (pRecoveryKey[nIndex]);
                        }

                        // Free the allocated arrays
                        if ( pEFSPKI )
                            delete [] pEFSPKI;
                        if ( cbPKI )
                            delete [] cbPKI;
                        if ( cbRecoveryKey )
                            delete [] cbRecoveryKey;
                        if ( pRecoveryKey )
                            delete [] pRecoveryKey;

                        if ( pRecoveryPolicy )
                            ::LocalFree (pRecoveryPolicy);
                    }
                }

                catch (CMemoryException*) 
                {
                    if ( hKeyEFSBlob )
                        ::RegCloseKey (hKeyEFSBlob);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (lResult);
                DisplaySystemError (NULL, lResult);
            }
            if ( SUCCEEDED (hr) )
                m_bDirty = true;
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::WriteEFSBlobToRegistry - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}


#define POINTER_TO_OFFSET( Pointer, pBase ) (((PUCHAR)(Pointer)) - ((PUCHAR)(pBase)))

HRESULT CCertStoreGPE::CreatePublicKeyInformationCertificate(
    IN PSID  pUserSid OPTIONAL,
    PBYTE pbCert,
    DWORD cbCert,
    OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation,
    DWORD*  pcbPublicKeyInfo)
{
    _TRACE (1, L"Entering CCertStoreGPE::CreatePublicKeyInformationCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    ASSERT (PublicKeyInformation && pcbPublicKeyInfo);
    ASSERT (pbCert);
    if ( !PublicKeyInformation || !pcbPublicKeyInfo || !pbCert)
        return E_POINTER;

    DWORD   userSidLength = 0;
    PBYTE   pBase = 0;

    if (pUserSid != NULL)
    {
        userSidLength = GetLengthSid (pUserSid);
    }

    DWORD publicKeyInformationLength = sizeof( EFS_PUBLIC_KEY_INFO )  + userSidLength + cbCert;

    //
    // Allocate and fill in the PublicKeyInformation structure
    //

    *PublicKeyInformation = (PEFS_PUBLIC_KEY_INFO) ::LocalAlloc (LPTR, publicKeyInformationLength);

    if ( !(*PublicKeyInformation) )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    (*PublicKeyInformation)->Length = publicKeyInformationLength;
    (*PublicKeyInformation)->KeySourceTag = (ULONG)EfsCertificate;

    //
    // Copy the string and SID data to the end of the structure.
    //

    pBase = (PBYTE) *PublicKeyInformation;
    pBase = (PBYTE) pBase + sizeof (EFS_PUBLIC_KEY_INFO);

    if (pUserSid != NULL)
    {
        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)POINTER_TO_OFFSET( pBase, *PublicKeyInformation );
        // security review 2/27/2002 BryanWal ok
        ::CopySid( userSidLength, (PSID)pBase, pUserSid );
    }
    else
    {
        (*PublicKeyInformation)->PossibleKeyOwner = (ULONG)NULL;
    }

    pBase = ((PBYTE)pBase + userSidLength);

    (*PublicKeyInformation)->CertificateInfo.CertificateLength = cbCert;
    (*PublicKeyInformation)->CertificateInfo.Certificate = (ULONG)POINTER_TO_OFFSET( pBase, *PublicKeyInformation );

    // security review 2/27/2002 BryanWal ok
    memcpy (pBase, pbCert, cbCert );
    *pcbPublicKeyInfo = publicKeyInformationLength;

    _TRACE (-1, L"Leaving CCertStoreGPE::CreatePublicKeyInformationCertificate - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return 0;
}

void CCertStoreGPE::AddCertToList(PCCERT_CONTEXT pCertContext, PSID userPSID)
{
    _TRACE (1, L"Entering CCertStoreGPE::AddCertToList - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    if ( pCertContext && userPSID )
    {
        CERT_CONTEXT_PSID_STRUCT* pCert = new CERT_CONTEXT_PSID_STRUCT (
                pCertContext, userPSID);
        if ( pCert )
        {
            m_EFSCertList.AddTail (pCert);
            m_bDirty = true;
        }
    }
    _TRACE (-1, L"Leaving CCertStoreGPE::AddCertToList - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

PSID CCertStoreGPE::GetPSIDFromCert (PCCERT_CONTEXT pCertContext)
{
    _TRACE (1, L"Entering CCertStoreGPE::GetPSIDFromCert - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    PSID            pSID = 0;
    CERT_CONTEXT_PSID_STRUCT*   pCert = 0;
    POSITION        curPos = 0;

    for (POSITION nextPos = m_EFSCertList.GetHeadPosition (); nextPos; )
    {
        curPos = nextPos;
        pCert = m_EFSCertList.GetNext (nextPos);
        if ( CertCompareCertificate (
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                pCert->m_pCertContext->pCertInfo,
                pCertContext->pCertInfo) )
        {
            pSID = pCert->m_psid;
            break;
        }
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::GetPSIDFromCert - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return pSID;
}


void CCertStoreGPE::FinalCommit()
{
    _TRACE (1, L"Entering CCertStoreGPE::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_GPE == m_objecttype);
    // Called only from destructor
    // Cannot commit here for GPT: GPT has already freed all pertinent data
    _TRACE (-1, L"Leaving CCertStoreGPE::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
}


bool CCertStoreGPE::IsNullEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreGPE::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    GetStoreHandle (); // to initialize
    Close ();
    _TRACE (-1, L"Leaving CCertStoreGPE::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_fIsNullEFSPolicy;
}

void CCertStoreGPE::AllowEmptyEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreGPE::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    m_fIsNullEFSPolicy = false;
    _TRACE (-1, L"Leaving CCertStoreGPE::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HRESULT CCertStoreGPE::AddCertificateContext(PCCERT_CONTEXT pContext, LPCONSOLE pConsole, bool bDeletePrivateKey)
{
    _TRACE (1, L"Entering CCertStoreGPE::AddCertificateContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    HRESULT hr = S_OK;
    AllowEmptyEFSPolicy ();
    hr = CCertStore::AddCertificateContext (pContext, pConsole, bDeletePrivateKey);

    _TRACE (-1, L"Leaving CCertStoreGPE::AddCertificateContext - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

HRESULT CCertStoreGPE::DeleteEFSPolicy(bool bCommitChanges)
{
    _TRACE (1, L"Entering CCertStoreGPE::DeleteEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (EFS_STORE == GetStoreType ());
    if ( EFS_STORE == GetStoreType () )
    {
        // If the store is open, close it first
        if ( m_hCertStore )
        {
            CERT_CONTEXT_PSID_STRUCT* pCert = 0;
            while (!m_EFSCertList.IsEmpty () )
            {
                pCert = m_EFSCertList.RemoveHead ();
                ASSERT (pCert);
                if ( pCert )
                    delete pCert;
            }

            VERIFY (::CertCloseStore (m_hCertStore, CERT_CLOSE_STORE_FORCE_FLAG)); //CERT_CLOSE_STORE_CHECK_FLAG);
            m_hCertStore = 0;
        }

        LRESULT lResult = ::RegDelnode (GetGroupPolicyKey (), CERT_EFSBLOB_REGPATH);
        if ( ERROR_SUCCESS == lResult )
        {
            m_fIsNullEFSPolicy = true;
            m_bDirty = true;

            if ( bCommitChanges )
            {
                m_bAddInCallToPolicyChanged = FALSE;  // delete policy
                Commit ();
                m_bAddInCallToPolicyChanged = TRUE;
            }
        }
        else
            DisplaySystemError (NULL, (DWORD)lResult);
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::DeleteEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return S_OK;
}


HRESULT CCertStoreGPE::PolicyChanged()
{
    _TRACE (1, L"Entering CCertStoreGPE::PolicyChanged - %s\n",
            (LPCWSTR) m_pcszStoreName);
    HRESULT hr = E_FAIL;

    if ( m_pGPEInformation )
    {
        hr = m_pGPEInformation->PolicyChanged (
                m_fIsComputerType ? TRUE : FALSE,
                m_bAddInCallToPolicyChanged, &g_guidExtension, &g_guidSnapin);
        hr = m_pGPEInformation->PolicyChanged (
                m_fIsComputerType ? TRUE : FALSE,
                m_bAddInCallToPolicyChanged, &g_guidRegExt, &g_guidSnapin);
    }

    _TRACE (-1, L"Leaving CCertStoreGPE::PolicyChanged - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return hr;
}

PCCERT_CONTEXT CCertStoreGPE::EnumCertificates (PCCERT_CONTEXT pPrevCertContext)
{
    PCCERT_CONTEXT pCertContext = CCertStore::EnumCertificates (pPrevCertContext);

    if ( pCertContext )
        m_fIsNullEFSPolicy = false;

    return pCertContext;
}

CERT_CONTEXT_PSID_STRUCT::CERT_CONTEXT_PSID_STRUCT (PCCERT_CONTEXT pCertContext, PSID psid) :
    m_pCertContext (0),
    m_psid (0)
{
    if ( pCertContext && psid )
    {
        m_pCertContext = CertDuplicateCertificateContext (pCertContext);
        DWORD   dwSidSize = ::GetLengthSid (psid);
        if (  dwSidSize > 0 )
        {
            m_psid = new BYTE[dwSidSize];
            if ( m_psid )
            {
                // security review 2/27/2002 BryanWal ok
                ::ZeroMemory (m_psid, dwSidSize);
                if ( !::CopySid (dwSidSize, m_psid, psid) )
                {
                    ASSERT (0);
                    delete [] m_psid;
                    m_psid = 0;
                }
            }
        }
    } 
}

CERT_CONTEXT_PSID_STRUCT::~CERT_CONTEXT_PSID_STRUCT ()
{
    if ( m_pCertContext )
        ::CertFreeCertificateContext (m_pCertContext);
    if ( m_psid )
        delete [] m_psid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\storegpe.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2001.
//
//  File:       StoreGPE.h
//
//  Contents:   CertStoreGPE class definition
//
//----------------------------------------------------------------------------

#ifndef __STOREGPE_H_INCLUDED__
#define __STOREGPE_H_INCLUDED__

#include "cookie.h"

class CERT_CONTEXT_PSID_STRUCT
{
public:
    CERT_CONTEXT_PSID_STRUCT (PCCERT_CONTEXT pCertContext, PSID psid);
    ~CERT_CONTEXT_PSID_STRUCT ();
    PCCERT_CONTEXT  m_pCertContext;
    PSID            m_psid;
};

class CCertStoreGPE : public CCertStore
{
public:
    virtual PCCERT_CONTEXT EnumCertificates (PCCERT_CONTEXT pPrevCertContext);
    HRESULT PolicyChanged ();
    HRESULT DeleteEFSPolicy (bool bCommitChanges);
    virtual HRESULT AddCertificateContext(PCCERT_CONTEXT pContext, LPCONSOLE pConsole, bool bDeletePrivateKey);
    void AllowEmptyEFSPolicy();
    virtual bool IsNullEFSPolicy();
    void AddCertToList (PCCERT_CONTEXT pCertContext, PSID userPSID);
    virtual HKEY GetGroupPolicyKey();
    IGPEInformation* GetGPEInformation() const;
    virtual bool IsMachineStore() ;
    virtual bool CanContain (CertificateManagerObjectType nodeType);
    virtual HCERTSTORE  GetStoreHandle (BOOL bSilent = FALSE, HRESULT* phr = 0);
    virtual HRESULT Commit ();
    CCertStoreGPE ( 
            DWORD dwFlags, 
            LPCWSTR lpcszMachineName, 
            LPCWSTR objectName, 
            const CString & pcszLogStoreName, 
            const CString & pcszPhysStoreName,
            IGPEInformation * pGPTInformation,
            const GUID& compDataGUID,
            IConsole* pConsole);

    virtual void SetAdding ()
    {
        m_bAddInCallToPolicyChanged = TRUE;
    }
    virtual void SetDeleting ()
    {
        m_bAddInCallToPolicyChanged = FALSE;
    }

    virtual ~CCertStoreGPE ();

private:
    bool                m_fIsNullEFSPolicy;
    IGPEInformation *   m_pGPEInformation;
    CTypedPtrList<CPtrList, CERT_CONTEXT_PSID_STRUCT*>  m_EFSCertList; 
    HKEY                m_hGroupPolicyKey;
    BOOL                m_bAddInCallToPolicyChanged; // corresponds to bAdd 
                                // argument in IGPEInformation::PolicyChanged ()

protected:
    virtual void FinalCommit();
    PSID GetPSIDFromCert (PCCERT_CONTEXT pCertContext);
    HRESULT WriteEFSBlobToRegistry();
    HRESULT CreatePublicKeyInformationCertificate(
        IN PSID  pUserSid OPTIONAL,
        PBYTE pbCert,
        DWORD cbCert,
        OUT PEFS_PUBLIC_KEY_INFO * PublicKeyInformation,
        DWORD*  pcbPublicKeyInfo);
};

class CEnrollmentNodeCookie : public CCertMgrCookie
{
public:
    CEnrollmentNodeCookie (
            CertificateManagerObjectType    objecttype, 
            LPCWSTR                         objectName,
            IGPEInformation*                pGPEInformation);
    virtual ~CEnrollmentNodeCookie ();

    IGPEInformation*    GetGPEInformation ();

private:
    IGPEInformation*    m_pGPEInformation;
};


#endif // ~__STOREGPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\storersop.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       StoreRSOP.cpp
//
//  Contents:   Implementation of CCertStoreRSOP
//
//----------------------------------------------------------------------------
#include "stdafx.h"
#include <gpedit.h>
#include "cookie.h"
#include "StoreRSOP.h"
#include "certifct.h"

USE_HANDLE_MACROS("CERTMGR(StoreRSOP.cpp)")

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern GUID g_guidExtension;
extern GUID g_guidRegExt;
extern GUID g_guidSnapin;


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
CCertStoreRSOP::CCertStoreRSOP (
            DWORD dwFlags,
            LPCWSTR lpcszMachineName,
            LPCWSTR objectName,
            const CString & pcszLogStoreName,
            const CString & pcszPhysStoreName,
            CRSOPObjectArray& rsopObjectArray,
            const GUID& compDataGUID,
            IConsole* pConsole)
    : CCertStore (CERTMGR_LOG_STORE_RSOP,
        CERT_STORE_PROV_SYSTEM, dwFlags, lpcszMachineName, objectName,
        pcszLogStoreName, pcszPhysStoreName,
        StoreNameToType (pcszLogStoreName),        
        0,
        pConsole),
    m_fIsNullEFSPolicy (true)       // assume NULL policy until proven otherwise
{
    _TRACE (1, L"Entering CCertStoreRSOP::CCertStoreRSOP - %s\n",
            (LPCWSTR) pcszLogStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    if ( ::IsEqualGUID (compDataGUID, NODEID_User) )
    {
        m_fIsComputerType = false;
        m_dwFlags |= CERT_SYSTEM_STORE_CURRENT_USER_GROUP_POLICY;
    }
    else if ( ::IsEqualGUID (compDataGUID, NODEID_Machine) )
    {
        m_fIsComputerType = true;
        m_dwFlags |= CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY;
    }
    else
        ASSERT (0);

    int     nIndex = 0;
    INT_PTR nUpperBound = rsopObjectArray.GetUpperBound ();
    bool    bFound = false;
	CString storePath = CERT_GROUP_POLICY_SYSTEM_STORE_REGPATH;
    storePath += L"\\";
    storePath += m_pcszStoreName;
    size_t nStoreLen = storePath.GetLength ();
    CString szWinningEFSPolicy;

    while ( nUpperBound >= nIndex )
    {
        CRSOPObject* pObject = rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            // Only add if
            // 1. Precedence is 1
            // 2. The object belongs to this store
            // 3. The valueName is not empty
            if ( 1 == pObject->GetPrecedence () )
            {
                // Consider only entries from this store
                // security review 2/25/2002 BryanWal ok
                if ( !wcsncmp (storePath, pObject->GetRegistryKey (), nStoreLen) )
                {
                    bFound = true;
                    if ( !pObject->GetValueName ().IsEmpty () )
                    {
                        // NTRAID# 477258 AddRSoP:  EFS:  Domain policy should 
                        // be disabled once OU policy has been established
                        if ( EFS_STORE == GetStoreType () )
                        {
                            // Find "EFSBlob".  Because the list is sorted, 
                            // this will be found before all the "Certificate" 
                            // keys that have the value of "Blob".  There should
                            // only be one "EFSBlob" that has a precedence of 1. 
                            // This winning EFSBlob will contain the winning
                            // GPO OID, which we will cache.  After this, we 
                            // will only keep certificates that have this same
                            // policy OID.
                            // Note that the EFSBlob is a special structure that
                            // also contains all the EFS certificates, but each
                            // EFSBlob have a unique precedence, while all the 
                            // "Blob"s have a precedence of 1, even if they 
                            // will not be applied.
                            if ( CERT_EFSBLOB_VALUE_NAME == pObject->GetValueName () )
                            {
                                ASSERT (-1 == m_rsopObjectArray.GetUpperBound ());
                                ASSERT (szWinningEFSPolicy.IsEmpty ());
                                szWinningEFSPolicy = pObject->GetPolicyOID ();
                            }
                            else if ( szWinningEFSPolicy == pObject->GetPolicyOID () )
                            {
                                CRSOPObject* pNewObject = new CRSOPObject (*pObject);
                                if ( pNewObject )
                                    m_rsopObjectArray.Add (pNewObject);
                            }
                        }
                        else
                        {
                            CRSOPObject* pNewObject = new CRSOPObject (*pObject);
                            if ( pNewObject )
                                m_rsopObjectArray.Add (pNewObject);
                        }
                    }
                }
                else if ( bFound )
                {
                    // Since the list is sorted, and we've already found the 
                    // desired RSOP objects and no longer are finding them, 
                    // there aren't any more.  We can optimize and break here.
                    break;
                }
            }
        }
        else
            break;

        nIndex++;
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::CCertStoreRSOP - %s\n",
            (LPCWSTR) pcszLogStoreName);
}


CCertStoreRSOP::~CCertStoreRSOP ()
{
    _TRACE (1, L"Entering CCertStoreRSOP::~CCertStoreRSOP - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    INT_PTR     nUpperBound = m_rsopObjectArray.GetUpperBound ();
    int         nIndex = 0;

    while (nUpperBound >= nIndex)
    {
        CRSOPObject*    pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            delete pObject;
        }
        else
            break;

        nIndex++;
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::~CCertStoreRSOP - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

HCERTSTORE CCertStoreRSOP::GetStoreHandle (BOOL bSilent /*= FALSE*/, HRESULT* phr /* = 0*/)
{
    _TRACE (1, L"Entering CCertStoreRSOP::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);

    if ( !m_hCertStore )
    {
        DWORD   dwErr = 0;

		//open a generic memory store
		m_hCertStore = ::CertOpenStore (CERT_STORE_PROV_MEMORY,
				 0, NULL,
				 CERT_STORE_SET_LOCALIZED_NAME_FLAG | CERT_STORE_MAXIMUM_ALLOWED_FLAG,
				 NULL);
		if ( m_hCertStore )
		{
            // Certificates, CTLs and other objects are either stored integrally in a
            // value called "Blob" or broken up into multiple parts. In this case, we'll 
            // first see "BlobCount", which tells us how many parts there are, then 
            // "BlobLength" which tells us the total byte length and finally
            // "Blob0", "Blob1", etc. to "Blob<BlobCount-1>"
            // Check for Certificates
            GetBlobs ();
        }
        else
        {
            dwErr = GetLastError ();
            if ( phr )
                *phr = HRESULT_FROM_WIN32 (dwErr);
            _TRACE (0, L"CertOpenStore (CERT_STORE_PROV_MEMORY) failed: 0x%x\n", dwErr);
        }

        if ( !m_hCertStore && !m_bUnableToOpenMsgDisplayed 
                && !bSilent && 
                (USERDS_STORE != GetStoreType ()) )
        {
            m_bUnableToOpenMsgDisplayed = true;
            CString caption;
            CString text;
            int         iRetVal = 0;

            VERIFY (caption.LoadString (IDS_CERTIFICATE_MANAGER));
            text.FormatMessage (IDS_UNABLE_TO_OPEN_STORE, GetStoreName (), 
                    GetSystemMessage (dwErr));
            if ( m_pConsole )
                m_pConsole->MessageBox (text, caption, MB_OK, &iRetVal);
        }
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::GetStoreHandle - %s\n",
            (LPCWSTR) m_pcszStoreName);

    return m_hCertStore;
}


HRESULT CCertStoreRSOP::GetBlobs ()
{ 
    HRESULT     hr = S_OK;
    INT_PTR     nUpperBound = m_rsopObjectArray.GetUpperBound ();
    int         nIndex = 0;

    while (nUpperBound >= nIndex)
    {
        CRSOPObject*    pObject = m_rsopObjectArray.GetAt (nIndex);
        if ( pObject )
        {
            if ( STR_BLOB == pObject->GetValueName () )
            {
                // If this is a single, serialized cert, get it and
                // add it to the store
                BYTE*   pByte = pObject->GetBlob ();
                ASSERT (pByte);
                if ( pByte )
                {
				    if ( !CertAddSerializedElementToStore (
						    m_hCertStore,
						    pByte,
						    (DWORD) pObject->GetBlobLength (),
						    CERT_STORE_ADD_ALWAYS,
						    0,
						    CERT_STORE_ALL_CONTEXT_FLAG,
						    NULL,
						    NULL) )
                    {
                        _TRACE (0, L"CertAddSerializedElementToStore () failed: 0x%x\n",
                                GetLastError ());
                    }
                }
            }
            else if ( STR_BLOBCOUNT == pObject->GetValueName () )
            {
                CString szBaseRegKey = pObject->GetRegistryKey ();
                DWORD   dwBlobCount = pObject->GetDWORDValue ();
                if ( dwBlobCount > 0 )
                {
                    nIndex++;
                    if (nUpperBound >= nIndex)
                    {
                        // Get the blob length
                        pObject = m_rsopObjectArray.GetAt (nIndex);
                        if ( pObject )
                        {
                            if ( STR_BLOBLENGTH == pObject->GetValueName () )
                            {
                                DWORD dwBlobLength = pObject->GetDWORDValue ();
                                if ( dwBlobLength )
                                {
                                    BYTE* pbyLob = new BYTE[dwBlobLength];
                                    if ( pbyLob )
                                    {
                                        size_t  nTotalBlobLength = 0;
                                        BYTE*   pbyLobPtr = pbyLob;
                                        for (DWORD dwBlob = 0; dwBlob < dwBlobCount; dwBlob++)
                                        {
                                            nIndex++;
                                            if ( nUpperBound >= nIndex )
                                            {
                                                // security review 2/25/2002 BryanWal
                                                // NOTICE.  Docs say that int64 requires 33 chars,
                                                // so DWORD would require half that many (17)
                                                // NOTICE: 4 == wcslen (STR_BLOB) ("Blob")
                                                ASSERT (4 == wcslen (STR_BLOB));
                                                const size_t BUF_LEN = 4 + 17 + 1; 
                                                WCHAR   szName[BUF_LEN];
                                                wsprintf (szName, L"%s%d", STR_BLOB, dwBlob);
                                                CString szRegKey = szBaseRegKey;
                                                szRegKey += L"\\";
                                                szRegKey += szName;

                                                pObject = m_rsopObjectArray.GetAt (nIndex);
                                                if ( pObject )
                                                {
                                                    if ( nTotalBlobLength + pObject->GetBlobLength () <=
                                                            dwBlobLength )
                                                    {
                                                        if ( szRegKey == pObject->GetRegistryKey () &&
                                                                STR_BLOB == pObject->GetValueName () )
                                                        {
                                                            BYTE* pByte = pObject->GetBlob ();
                                                            if ( pByte )
                                                            {
                                                                // security review 2/25/2002 BryanWal
                                                                // NOTICE: Add length addition check above to
                                                                // to prevent buffer overflow here if registry
                                                                // data is bad
                                                                memcpy (pbyLobPtr, pByte, pObject->GetBlobLength ());
                                                                pbyLobPtr += pObject->GetBlobLength ();
                                                                nTotalBlobLength += pObject->GetBlobLength ();
                                                            }
                                                            else
                                                            {
                                                                ASSERT (0);
                                                                hr = E_UNEXPECTED;
                                                                break;
                                                            }
                                                        }
                                                        else
                                                        {
                                                            ASSERT (0);
                                                            hr = E_UNEXPECTED;
                                                            break;
                                                        }
                                                    }
                                                    else
                                                    {
                                                        ASSERT (0);
                                                        hr = E_UNEXPECTED;
                                                        break;
                                                    }
                                                }
                                                else
                                                {
                                                    ASSERT (0);
                                                    hr = E_UNEXPECTED;
                                                    break;
                                                }
                                            }
                                            else
                                            {
                                                ASSERT (0);
                                                hr = E_UNEXPECTED;
                                                break;
                                            }
                                        }

                                        if ( SUCCEEDED (hr) && nTotalBlobLength == (size_t) dwBlobLength )
                                        {
 						                    if ( !CertAddSerializedElementToStore (
								                    m_hCertStore,
								                    pbyLob,
								                    dwBlobLength,
								                    CERT_STORE_ADD_ALWAYS,
								                    0,
								                    CERT_STORE_ALL_CONTEXT_FLAG,
								                    NULL,
								                    NULL) )
                                            {
                                                _TRACE (0, L"CertAddSerializedElementToStore () failed: 0x%x\n",
                                                        GetLastError ());
                                            }
                                        }

                                        delete [] pbyLob;
                                    }
                                    else
                                    {
                                        hr = E_OUTOFMEMORY;
                                        break;
                                    }
                                }
                                else
                                {
                                    ASSERT (0);
                                    hr = E_UNEXPECTED;
                                    break;
                                }
                            }
                            else
                            {
                                ASSERT (0);
                                hr = E_UNEXPECTED;
                                break;
                            }
                        }
                        else
                        {
                            ASSERT (0);
                            hr = E_UNEXPECTED;
                            break;
                        }
                    }
                    else
                    {
                        ASSERT (0);
                        hr = E_UNEXPECTED;
                        break;
                    }
                }
            }
        }
        else
            break;

        nIndex++;
    }

    return hr;
}

bool CCertStoreRSOP::CanContain(CertificateManagerObjectType nodeType)
{
    _TRACE (1, L"Entering CCertStoreRSOP::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    bool    bCanContain = false;

    switch (nodeType)
    {
    case CERTMGR_CERTIFICATE:
        if ( ROOT_STORE == GetStoreType () ||
                EFS_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    case CERTMGR_CTL:
        if ( TRUST_STORE == GetStoreType () )
        {
            bCanContain = true;
        }
        break;

    default:
        break;
    }

    _TRACE (-1, L"Leaving CCertStoreRSOP::CanContain - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return bCanContain;
}


bool CCertStoreRSOP::IsMachineStore()
{
    _TRACE (0, L"Entering and leaving CCertStoreRSOP::IsMachineStore - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);

    if (m_dwFlags & CERT_SYSTEM_STORE_LOCAL_MACHINE_GROUP_POLICY)
        return true;
    else
        return false;
}


void CCertStoreRSOP::FinalCommit()
{
    _TRACE (1, L"Entering CCertStoreRSOP::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
    ASSERT (CERTMGR_LOG_STORE_RSOP == m_objecttype);
    // Called only from destructor
    // Cannot commit here for GPT: GPT has already freed all pertinent data
    _TRACE (-1, L"Leaving CCertStoreRSOP::FinalCommit - %s\n",
            (LPCWSTR) m_pcszStoreName);
}


bool CCertStoreRSOP::IsNullEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreRSOP::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    GetStoreHandle (); // to initialize
    PCCERT_CONTEXT pCertContext = EnumCertificates (0); // sets m_fIsNullEFSPolicy
    if ( pCertContext )
        ::CertFreeCertificateContext (pCertContext);
    Close ();
    _TRACE (-1, L"Leaving CCertStoreRSOP::IsNullEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    return m_fIsNullEFSPolicy;
}

void CCertStoreRSOP::AllowEmptyEFSPolicy()
{
    _TRACE (1, L"Entering CCertStoreRSOP::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
    m_fIsNullEFSPolicy = false;
    _TRACE (-1, L"Leaving CCertStoreRSOP::AllowEmptyEFSPolicy - %s\n",
            (LPCWSTR) m_pcszStoreName);
}

PCCERT_CONTEXT CCertStoreRSOP::EnumCertificates (PCCERT_CONTEXT pPrevCertContext)
{
    PCCERT_CONTEXT pCertContext = CCertStore::EnumCertificates (pPrevCertContext);

    if ( pCertContext )
        m_fIsNullEFSPolicy = false;

    return pCertContext;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\uuids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       uuids.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Nodetypes for the Certificate Management snapin
// created by GUIDGEN 8/8/97 BryanWal

#ifndef _UUIDS_CERTIFICATE_MANAGEMENT_
#define _UUIDS_CERTIFICATE_MANAGEMENT_
#include "certmgrd.h"

#define lstruuidNodetypeSnapin				L"{53D6AB16-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeCertificate			L"{53D6AB17-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeLogStore			L"{53D6AB18-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypePhysStore			L"{53D6AB19-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeUsage				L"{53D6AB1A-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeCRLContainer		L"{E3EDFDFD-D0C3-11d1-955B-0000F803A951}"
#define lstruuidNodetypeCTLContainer		L"{E3EDFDFE-D0C3-11d1-955B-0000F803A951}"
#define lstruuidNodetypeCertContainer		L"{D5CC57D2-CD78-11d1-B690-0000F803A951}"
#define lstruuidNodetypeCRL					L"{E3EDFDFF-D0C3-11d1-955B-0000F803A951}"
#define lstruuidNodetypeCTL					L"{53D6AB1F-2488-11d1-A28C-00C04FB94F17}"
#define lstruuidNodetypeAutoCertRequest		L"{FC82B00C-8872-11d1-85EF-00C04FB94F17}"
#define lstruiidNodetypeCertPoliciesUser	L"{C4A92B40-91EE-11d1-85FD-00C04FB94F17}"
#define lstruiidNodetypeCertPoliciesComputer \
                                            L"{C4A92B41-91EE-11d1-85FD-00C04FB94F17}"
#define lstruiidNodetypeLogStoreGPE			L"{82F57E23-D0B7-11d1-9559-0000F803A951}"
#define lstruiidNodetypePKPAutoenrollmentSettings \
                                            L"{8DD146E1-4687-4b4c-90DC-23F920C06355}"
#define lstruiidNodetypeSaferComputerRoot   L"{70933DB1-D9CE-4d4a-9F35-D812ED6B6E5A}"
#define lstruiidNodetypeSaferComputerLevels L"{CF7C6FD8-BF56-4058-B6F7-DEEA2D4A1570}"
#define lstruiidNodetypeSaferComputerEntries \
                                            L"{EA3D57B1-473E-463d-BD0B-05BCBAE69FC2}"
#define lstruiidNodetypeSaferUserRoot       L"{521B8639-FDA3-493f-8C5A-946D7B037931}"
#define lstruiidNodetypeSaferUserLevels     L"{CF85A487-6C7C-4708-8EE9-2BF7D23CE61D}"
#define lstruiidNodetypeSaferUserEntries    L"{91DE2E53-63B6-4b69-8B74-990FB0AC1F47}"
#define lstruiidNodetypeSaferComputerLevel  L"{4ECC4509-0356-439b-883A-6B046D5E70E9}"
#define lstruiidNodetypeSaferUserLevel      L"{9BA58619-CF80-45c3-83A4-029C76EB96BD}"
#define lstruiidNodetypeSaferComputerEntry  L"{EE376E23-6D19-49ee-B12A-83442D52C7F1}"
#define lstruiidNodetypeSaferUserEntry      L"{954A504B-33FF-4836-ADD7-E385B0AAF6AD}"
#define lstruiidNodetypeSaferTrustedPublisher L"{DE72271F-2C86-4349-A8F9-0BF3F0A1DB42}"
#define lstruiidNodetypeSaferDefinedFileTypes L"{4A0B4F37-F04A-4e5d-832A-34A035A755B3}"
#define lstruiidNodetypeSaferEnforcement    L"{14E0F120-C802-4ee0-A425-2BA2671E6848}"


#define structuuidNodetypeSnapin    \
    { 0x53d6ab16, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCertificate \
    { 0x53d6ab17, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeLogStore \
	{ 0x53d6ab18, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypePhysStore \
	{ 0x53d6ab19, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeUsage \
	{ 0x53d6ab1a, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCRLContainer \
	{ 0xe3edfdfd, 0xd0c3, 0x11d1, { 0x95, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCTLContainer \
	{ 0xe3edfdfe, 0xd0c3, 0x11d1, { 0x95, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCertContainer \
	{ 0xd5cc57d2, 0xcd78, 0x11d1, { 0xb6, 0x90, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCRL \
	{ 0xe3edfdff, 0xd0c3, 0x11d1, { 0x95, 0x5b, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypeCTL \
	{ 0x53d6ab1f, 0x2488, 0x11d1, { 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeAutoCertRequest \
	{ 0xfc82b00c, 0x8872, 0x11d1, { 0x85, 0xef, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCertPoliciesUser \
	{ 0xc4a92b40, 0x91ee, 0x11d1, { 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeCertPoliciesComputer \
	{ 0xc4a92b41, 0x91ee, 0x11d1, { 0x85, 0xfd, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17 } }
#define structuuidNodetypeLogStoreGPE \
	{ 0x82f57e23, 0xd0b7, 0x11d1, { 0x95, 0x59, 0x0, 0x0, 0xf8, 0x3, 0xa9, 0x51 } }
#define structuuidNodetypePKPAutoenrollmentSettings \
    { 0x8dd146e1, 0x4687, 0x4b4c, { 0x90, 0xdc, 0x23, 0xf9, 0x20, 0xc0, 0x63, 0x55 } }
#define structuuidNodetypeSaferComputerRoot \
    { 0x70933db1, 0xd9ce, 0x4d4a, { 0x9f, 0x35, 0xd8, 0x12, 0xed, 0x6b, 0x6e, 0x5a } }
#define structuuidNodetypeSaferComputerLevels \
    { 0xcf7c6fd8, 0xbf56, 0x4058, { 0xb6, 0xf7, 0xde, 0xea, 0x2d, 0x4a, 0x15, 0x70 } }
#define structuuidNodetypeSaferComputerEntries \
    { 0xea3d57b1, 0x473e, 0x463d, { 0xbd, 0xb, 0x5, 0xbc, 0xba, 0xe6, 0x9f, 0xc2 } }
#define structuuidNodetypeSaferUserRoot \
    { 0x521b8639, 0xfda3, 0x493f, { 0x8c, 0x5a, 0x94, 0x6d, 0x7b, 0x3, 0x79, 0x31 } }
#define structuuidNodetypeSaferUserLevels \
    { 0xcf85a487, 0x6c7c, 0x4708, { 0x8e, 0xe9, 0x2b, 0xf7, 0xd2, 0x3c, 0xe6, 0x1d } }
#define structuuidNodetypeSaferUserEntries \
    { 0x91de2e53, 0x63b6, 0x4b69, { 0x8b, 0x74, 0x99, 0xf, 0xb0, 0xac, 0x1f, 0x47 } }
#define structuuidNodetypeSaferComputerLevel \
    { 0x4ecc4509, 0x356, 0x439b, { 0x88, 0x3a, 0x6b, 0x4, 0x6d, 0x5e, 0x70, 0xe9 } }
#define structuuidNodetypeSaferUserLevel \
    { 0x9ba58619, 0xcf80, 0x45c3, { 0x83, 0xa4, 0x2, 0x9c, 0x76, 0xeb, 0x96, 0xbd } }
#define structuuidNodetypeSaferComputerEntry \
    { 0xee376e23, 0x6d19, 0x49ee, { 0xb1, 0x2a, 0x83, 0x44, 0x2d, 0x52, 0xc7, 0xf1 } }
#define structuuidNodetypeSaferUserEntry \
    { 0x954a504b, 0x33ff, 0x4836, { 0xad, 0xd7, 0xe3, 0x85, 0xb0, 0xaa, 0xf6, 0xad } }
#define structuuidNodetypeSaferTrustedPublishers \
    { 0xde72271f, 0x2c86, 0x4349, { 0xa8, 0xf9, 0xb, 0xf3, 0xf0, 0xa1, 0xdb, 0x42 } }
#define structuuidNodetypeSaferDefinedFileTypes \
    { 0x4a0b4f37, 0xf04a, 0x4e5d, { 0x83, 0x2a, 0x34, 0xa0, 0x35, 0xa7, 0x55, 0xb3 } }
#define structuuidNodetypeSaferEnforcement \
    { 0x14e0f120, 0xc802, 0x4ee0, { 0xa4, 0x25, 0x2b, 0xa2, 0x67, 0x1e, 0x68, 0x48 } }


DEFINE_GUID (NODEID_CertMgr_CERTIFICATE, 0x53d6ab17, 0x2488, 0x11d1, 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_CertMgr_CRL, 0x53d6ab1e, 0x2488, 0x11d1, 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_CertMgr_CTL, 0x53d6ab1f, 0x2488, 0x11d1, 0xa2, 0x8c, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_CertMgr_AUTOCERT, 0xfc82b00c, 0x8872, 0x11d1, 0x85, 0xef, 0x0, 0xc0, 0x4f, 0xb9, 0x4f, 0x17);
DEFINE_GUID (NODEID_Safer_COMPUTER_ENTRY, 0xee376e23, 0x6d19, 0x49ee, 0xb1, 0x2a, 0x83, 0x44, 0x2d, 0x52, 0xc7, 0xf1);
DEFINE_GUID (NODEID_Safer_USER_ENTRY, 0x954a504b, 0x33ff, 0x4836, 0xad, 0xd7, 0xe3, 0x85, 0xb0, 0xaa, 0xf6, 0xad);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\users.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       users.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Users.h: interface for the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
#define AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
#pragma warning(push, 3)
#include <winefs.h>
#pragma warning(pop)

#define USERINFILE  1
#define USERADDED   2
#define USERREMOVED 4

typedef struct USERSONFILE {
    USERSONFILE *       m_pNext;
    DWORD               m_dwFlag; // If the item is added, removed or existed in the file
    PVOID               m_pCert; // Either the hash or the Blob
    PCCERT_CONTEXT      m_pCertContext; // Cert Context. To be released when the item is deleted.
    LPWSTR              m_szUserName;
    LPWSTR				m_szDnName;
    PSID                m_UserSid;
} USERSONFILE, *PUSERSONFILE;

//
// This class supports single thread only.
//

class CUsers  
{
public:
	CUsers();
	virtual ~CUsers();

public:
	void Clear(void);
	DWORD GetUserRemovedCnt();

	DWORD GetUserAddedCnt();

    DWORD   Add(
                LPWSTR UserName,
                LPWSTR DnName, 
                PVOID UserCert, 
                PSID UserSid = NULL, 
                DWORD Flag = USERINFILE,
                PCCERT_CONTEXT pContext = NULL
              );

    DWORD   Add( CUsers &NewUsers );

    PUSERSONFILE RemoveItemFromHead(void);

    DWORD   Remove(
                LPCWSTR UserName,
                LPCWSTR CertName
                );
 
    PUSERSONFILE   StartEnum();

    PUSERSONFILE   GetNextUser(
                PUSERSONFILE Token, 
                CString &UserName,
                CString &CertName
                );

	PVOID GetNextChangedUser(
                PVOID Token, 
                LPWSTR *UserName,
                LPWSTR *DnName,  
                PSID *UserSid, 
                PVOID *CertData, 
                DWORD *Flag
                );
    

private:
	DWORD m_UserAddedCnt;
	DWORD m_UserRemovedCnt;
    PUSERSONFILE    m_UsersRoot;

};

#endif // !defined(AFX_USERS_H__FFCA99DE_56E0_11D1_BB65_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\storersop.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       StoreRSOP.h
//
//  Contents:   CertStoreRSOP class definition
//
//----------------------------------------------------------------------------

#ifndef __STORERSOP_H_INCLUDED__
#define __STORERSOP_H_INCLUDED__

#pragma warning(push, 3)
#include <wbemcli.h>
#pragma warning(pop)
#include "cookie.h"
#include "RSOPObject.h"

class CCertStoreRSOP : public CCertStore
{
public:
    virtual PCCERT_CONTEXT EnumCertificates (PCCERT_CONTEXT pPrevCertContext);
    virtual HRESULT Commit () { return S_OK; }
    virtual bool IsReadOnly () { return true; }
	void AllowEmptyEFSPolicy();
	virtual bool IsNullEFSPolicy();
    virtual bool IsMachineStore();
	virtual bool CanContain (CertificateManagerObjectType nodeType);
	virtual HCERTSTORE	GetStoreHandle (BOOL bSilent = FALSE, HRESULT* phr = 0);
	CCertStoreRSOP ( 
			DWORD dwFlags, 
			LPCWSTR lpcszMachineName, 
			LPCWSTR objectName, 
			const CString & pcszLogStoreName, 
			const CString & pcszPhysStoreName,
			CRSOPObjectArray& rsopObjectArray,
			const GUID& compDataGUID,
			IConsole* pConsole);

	virtual ~CCertStoreRSOP ();

protected:
    HRESULT GetBlobs ();
	virtual void FinalCommit();

private:
	bool				m_fIsNullEFSPolicy;
    CRSOPObjectArray    m_rsopObjectArray;
};


#endif // ~__STORERSOP_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\users.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Users.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Users.cpp: implementation of the CUsers class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Users.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CUsers::CUsers()
{
    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;
}

//////////////////////////////////////////////////////////////////////
// Walk through the chain to free the memory
//////////////////////////////////////////////////////////////////////

CUsers::~CUsers()
{
    Clear();
}

PUSERSONFILE
CUsers::RemoveItemFromHead(void)
{
    PUSERSONFILE PItem = m_UsersRoot;
    if (m_UsersRoot){
        m_UsersRoot = m_UsersRoot->m_pNext;
        if ((PItem->m_dwFlag & USERADDED) && !(PItem->m_dwFlag & USERREMOVED)){
            m_UserAddedCnt--;
        }
        if ((PItem->m_dwFlag & USERINFILE) && (PItem->m_dwFlag & USERREMOVED)){
            m_UserRemovedCnt--;
        }
    }
    return PItem;
}

DWORD
CUsers::Add( CUsers &NewUsers )
{
    PUSERSONFILE NewItem = NewUsers.RemoveItemFromHead();

    while ( NewItem )
	{
        PUSERSONFILE    TmpItem = m_UsersRoot;
        
        while ( TmpItem )
		{

            if ((NewItem->m_szUserName && TmpItem->m_szUserName && !_tcsicmp(NewItem->m_szUserName, TmpItem->m_szUserName)) ||
                 ( !NewItem->m_szUserName && !TmpItem->m_szUserName))
			{
                if ( !TmpItem->m_szUserName)
				{
					bool   bUserMatched = false;

                    if (( !NewItem->m_szDnName && !TmpItem->m_szDnName) ||
                          (NewItem->m_szDnName && TmpItem->m_szDnName && !_tcsicmp(NewItem->m_szDnName, TmpItem->m_szDnName)))
					{
						bUserMatched = true;
                    }

                    if ( !bUserMatched )
					{
                        TmpItem = TmpItem->m_pNext;
                        continue;
                    }
                }

                //
                // User exist
                //

                if ( TmpItem->m_dwFlag & USERREMOVED )
				{
                    if ( TmpItem->m_dwFlag & USERADDED )
					{
                        ASSERT(!(TmpItem->m_dwFlag & USERINFILE));

                        //
                        //    User added and removed
                        //
                        m_UserAddedCnt++;

                    } 
					else if ( TmpItem->m_dwFlag & USERINFILE )
					{
                        //
                        //    User added and removed
                        //
                        m_UserRemovedCnt--;

                    }
                    TmpItem->m_dwFlag &= ~USERREMOVED;
                }

                //
                // The caller will count on CUsers to release the memory
                //

                if (NewItem->m_szUserName)
				{
                    delete [] NewItem->m_szUserName;
                }
                if (NewItem->m_szDnName)
				{
                    delete [] NewItem->m_szDnName;
                }
                if ( NewItem->m_pCertContext ) 
				{
                    CertFreeCertificateContext(NewItem->m_pCertContext);
                }
                delete [] NewItem->m_pCert;
                if (NewItem->m_UserSid)
				{
                    delete [] NewItem->m_UserSid;
                }
                delete NewItem;
                NewItem = NULL;                
                break;
            }
            TmpItem = TmpItem->m_pNext;
        }

        if (NewItem )
		{ 
            //
            // New item. Insert into the head.
            //

            NewItem->m_pNext = m_UsersRoot;
            m_UsersRoot = NewItem;
            m_UserAddedCnt++;
        }

        NewItem = NewUsers.RemoveItemFromHead();
    }

    return ERROR_SUCCESS;
}

DWORD
CUsers::Add(
    LPWSTR pszUserName,
    LPWSTR pszDnName, 
    PVOID UserCert, 
    PSID UserSid, /* = NULL */
    DWORD dwFlag, /* = USERINFILE */
    PCCERT_CONTEXT pCertContext /* = NULL */
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Create an item for a user
// Arguments:
//      m_szUserName -- User's name
//      m_szDnName -- User's distinguished name
//      UserCert -- User's certificate blob or hash
//      m_UserSid -- User's ID. Can be NULL
//      m_dwFlag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      NO_ERROR if succeed.
//      Will throw exception if memory allocation fails. ( From new.)
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE UserItem = 0;
    PUSERSONFILE TmpUserItem = m_UsersRoot;
    PEFS_CERTIFICATE_BLOB CertBlob;
    PEFS_HASH_BLOB  CertHashBlob;
    DWORD   CertSize;
    DWORD   SidSize;

    if ( !UserCert )
    {
        return ERROR_INVALID_PARAMETER;
    }

    ASSERT ( (( dwFlag & USERADDED ) || ( dwFlag & USERINFILE )) &&
                       ( (dwFlag & (USERADDED | USERINFILE)) != (USERADDED | USERINFILE)));


    //
    // If the user already in the memory, no new item is to be created except for unknown user
    //

    while ( TmpUserItem )
	{
        if ( (pszUserName && TmpUserItem->m_szUserName && !_tcsicmp(pszUserName, TmpUserItem->m_szUserName)) ||
              ((!pszUserName) && (TmpUserItem->m_szUserName == NULL)))
		{
            if (!pszUserName)
			{
				bool   bUserMatched = false;

                if (( !pszDnName &&  !TmpUserItem->m_szDnName) ||
                     (pszDnName && TmpUserItem->m_szDnName && !_tcsicmp(pszDnName, TmpUserItem->m_szDnName)))
				{
                    bUserMatched = true;
                }

                if ( !bUserMatched )
				{
                    TmpUserItem = TmpUserItem->m_pNext;
                    continue;
                }
            }

            //
            // User exist
            //

            if ( TmpUserItem->m_dwFlag & USERREMOVED )
			{
                if ( TmpUserItem->m_dwFlag & USERADDED )
				{
                    ASSERT(!(TmpUserItem->m_dwFlag & USERINFILE));

                    //
                    //    User added and removed
                    //
                    m_UserAddedCnt++;

                } 
				else if ( TmpUserItem->m_dwFlag & USERINFILE )
				{
                    //
                    //    User added and removed
                    //
                    m_UserRemovedCnt--;

                }
                TmpUserItem->m_dwFlag &= ~USERREMOVED;
            }

            //
            // The caller will count on CUsers to release the memory
            // for Username and the context if the call is succeeded. This is just for
            // performance reason.
            //

            if (pszUserName)
			{
                delete [] pszUserName;
            }
            if (pszDnName)
			{
                delete [] pszDnName;
            }
            if ( pCertContext ) 
			{
                ::CertFreeCertificateContext (pCertContext);
                pCertContext = NULL;
            }
            return (DWORD) CRYPT_E_EXISTS;
        }
        TmpUserItem = TmpUserItem->m_pNext;
    }
    
    try {
        UserItem = new USERSONFILE;
        if ( !UserItem )
		{
            AfxThrowMemoryException( );
        }

        UserItem->m_pNext = NULL;

        //
        // In case exception raised, we can call delete.
        // Delete NULL is OK, but random data is not OK.
        //

        UserItem->m_UserSid = NULL;
        UserItem->m_pCert = NULL;
        UserItem->m_pCertContext = NULL;

        if ( UserSid )
		{
            SidSize = GetLengthSid (UserSid );
            if (  SidSize > 0 )
			{
                UserItem->m_UserSid = new BYTE[SidSize];
                if ( !UserItem->m_UserSid )
				{
                    AfxThrowMemoryException( );
                }
                // security review 2/27/2002 BryanWal ok
                if ( !::CopySid(SidSize, UserItem->m_UserSid, UserSid))
				{
                    delete [] UserItem->m_UserSid;
                    delete UserItem;
                    return GetLastError();
                }
                
            } 
			else 
			{
                delete UserItem;
                return GetLastError();
            }
        } 
		else 
		{
            UserItem->m_UserSid = NULL;
        }
 
        if ( dwFlag & USERINFILE )
		{

            //
            // The info is from the file. Use the hash structure
            //

            CertHashBlob = ( PEFS_HASH_BLOB ) UserCert;
            CertSize = sizeof(EFS_HASH_BLOB) + CertHashBlob->cbData;
            UserItem->m_pCert = new BYTE[CertSize];
            if ( !UserItem->m_pCert )
			{
                AfxThrowMemoryException( );
            }
            ((PEFS_HASH_BLOB)UserItem->m_pCert)->cbData = CertHashBlob->cbData;
            ((PEFS_HASH_BLOB)UserItem->m_pCert)->pbData = (PBYTE)(UserItem->m_pCert) + sizeof(EFS_HASH_BLOB);

            // security review 2/27/2002 BryanWal ok
            memcpy(((PEFS_HASH_BLOB)UserItem->m_pCert)->pbData, 
                   CertHashBlob->pbData,
                   CertHashBlob->cbData);
        } 
		else 
		{
            //
            // The info is from the user picked cert. Use m_pCert Blob structure
            //

            CertBlob = ( PEFS_CERTIFICATE_BLOB ) UserCert;
            CertSize = sizeof(EFS_CERTIFICATE_BLOB) + CertBlob->cbData;
            UserItem->m_pCert = new BYTE[CertSize];
            if ( NULL == UserItem->m_pCert ){
                AfxThrowMemoryException( );
            }
            ((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->cbData = CertBlob->cbData;
            ((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->dwCertEncodingType = CertBlob->dwCertEncodingType;
            ((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->pbData = (PBYTE)(UserItem->m_pCert) + sizeof(EFS_CERTIFICATE_BLOB);
            // security review 2/27/2002 BryanWal ok
            memcpy(((PEFS_CERTIFICATE_BLOB)UserItem->m_pCert)->pbData, 
                   CertBlob->pbData,
                   CertBlob->cbData);
        }
 
        UserItem->m_szUserName = pszUserName;
        UserItem->m_szDnName = pszDnName;
        UserItem->m_pCertContext = pCertContext;
        UserItem->m_dwFlag = dwFlag;
        if ( dwFlag & USERADDED )
		{
            m_UserAddedCnt ++;
        }
    }
    catch (...) {
        delete [] UserItem->m_UserSid;
        delete [] UserItem->m_pCert;
        delete UserItem;
        AfxThrowMemoryException( );
        return ERROR_NOT_ENOUGH_MEMORY; 
    }

    //
    // Add to the head
    //

    if ( m_UsersRoot )
	{
        UserItem->m_pNext = m_UsersRoot;
    }
    m_UsersRoot = UserItem;

    return NO_ERROR;
}

DWORD
CUsers::Remove(
    LPCWSTR m_szUserName,
    LPCWSTR UserCertName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Remove a user from the list. Actually just mark for remove.
// Arguments:
//      m_szUserName -- User's name
//      UserCertName -- User's certificate name
//  Return Value:
//      NO_ERROR if succeed.
//      ERROR_NOT_FOUND if the user cannot be found.
// 
//////////////////////////////////////////////////////////////////////
{
    PUSERSONFILE	TmpUserItem = m_UsersRoot;
    bool			bUserMatched = false;

    while ( TmpUserItem ){
        if (((NULL==m_szUserName) && ( NULL == TmpUserItem->m_szUserName)) || 
            ( m_szUserName && TmpUserItem->m_szUserName && !_tcsicmp(m_szUserName, TmpUserItem->m_szUserName))){

            //
            // Make sure the CertName matches also if the user name is NULL
            //

            if (NULL==m_szUserName) 
			{ 
                 if (((NULL==UserCertName) && ( NULL == TmpUserItem->m_szDnName)) ||
                      (UserCertName && TmpUserItem->m_szDnName && !_tcsicmp(UserCertName, TmpUserItem->m_szDnName))){

                    bUserMatched = true;
                }
            } 
			else 
			{
                bUserMatched = true;
            }

            if (bUserMatched)
			{
                //
                // User exist, mark it for remove
                //

                if ( TmpUserItem->m_dwFlag & USERINFILE ){
                    m_UserRemovedCnt++;
                } else if ( TmpUserItem->m_dwFlag & USERADDED ) {
                    m_UserAddedCnt--;
                }
                TmpUserItem->m_dwFlag |= USERREMOVED;
                return NO_ERROR;
            }
        }
        TmpUserItem = TmpUserItem->m_pNext;
    }
    return ERROR_NOT_FOUND;
}

PUSERSONFILE CUsers::StartEnum()
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Prepare for GetNextUser
// Arguments:
//
//  Return Value:
//      A pointer used for GetNextUser
// 
//////////////////////////////////////////////////////////////////////
{
    return m_UsersRoot;
}

PUSERSONFILE CUsers::GetNextUser(
    PUSERSONFILE Token, 
    CString &szUserName,
    CString &CertName
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get next user in the list.(Not removed).
// Arguments:
//      m_szUserName -- m_pNext User's name
//      CertName -- Certificate name
//      Token -- A pointer returned by previous GetNextUser or StartEnum. 
// Return Value:
//      A pointer for GetNextUser()
// 
//////////////////////////////////////////////////////////////////////
{

    PUSERSONFILE   TmpItem = Token;
    PUSERSONFILE   RetPointer = NULL;

    while ( TmpItem )
	{
        if ( TmpItem->m_dwFlag & USERREMOVED )
		{
            TmpItem = TmpItem->m_pNext;
            continue;
        }

        try{    
            szUserName = TmpItem->m_szUserName;
            CertName = TmpItem->m_szDnName;
            RetPointer = TmpItem->m_pNext;
        }
        catch (...){

            //
            // Out of memory
            //

            TmpItem = NULL;
            RetPointer = NULL;
        }
        break;
    }

    if ( NULL == TmpItem )
	{
        szUserName.Empty();
        CertName.Empty();
    }
    return RetPointer;

}

DWORD CUsers::GetUserAddedCnt()
{
    return m_UserAddedCnt;
}

DWORD CUsers::GetUserRemovedCnt()
{
    return m_UserRemovedCnt;
}

PVOID CUsers::GetNextChangedUser(
    PVOID Token, 
    LPWSTR * m_szUserName,
    LPWSTR * m_szDnName, 
    PSID * m_UserSid, 
    PVOID * CertData, 
    DWORD * m_dwFlag
    )
//////////////////////////////////////////////////////////////////////
// Routine Description:
//      Get the info for changed users. This method is not well behaved in the
//  sense of OOP. It exposes internal pointers to the ouside world. The gain
//  is performance. At this moment, CUsers is a supporting class and used only
//  by USERLIST and CAddEFSWizSheet (single thread). We can make USERLIST a 
//  friend of CUsers if such concerns are raised in the future or reimplement this. 
//  The same issue applies to the enumerate methods.
//
// Arguments:
//      Token -- A pointer to the item returned in previous GetNextChangedUser or StartEnum.
//      m_szUserName -- User's name
//      m_szDnName -- User's Distinguished name
//      CertData -- User's certificate blob or hash
//      m_UserSid -- User's ID. Can be NULL
//      m_dwFlag -- Indicate if the item is existing in the file, to be added or removed
//  Return Value:
//      m_pNext item pointer.
// 
//////////////////////////////////////////////////////////////////////
{
    bool    bChangedUserFound = false;

    while ( Token )
	{
        *m_dwFlag = ((PUSERSONFILE) Token)->m_dwFlag;

        if ( ( *m_dwFlag & USERADDED ) && !( *m_dwFlag & USERREMOVED ))
		{
            //
            // The user is to to be added to the file
            //

            *m_dwFlag = USERADDED;
            bChangedUserFound = true;
        } 
		else if ( ( *m_dwFlag & USERREMOVED ) && ( *m_dwFlag & USERINFILE))
		{
            //
            // The user is to be removed from the file
            //

            *m_dwFlag = USERREMOVED;
            bChangedUserFound = true;
        }

        if ( bChangedUserFound )
		{
            *m_szUserName = ((PUSERSONFILE) Token)->m_szUserName;
            *m_szDnName = ((PUSERSONFILE) Token)->m_szDnName;
            *m_UserSid = ((PUSERSONFILE) Token)->m_UserSid;
            *CertData = ((PUSERSONFILE) Token)->m_pCert;
            return ((PUSERSONFILE) Token)->m_pNext;
        } 
		else 
		{
            Token = ((PUSERSONFILE) Token)->m_pNext;
        }

    }

    *m_szUserName = NULL;
    *m_szDnName = NULL;
    *m_UserSid = NULL;
    *CertData = NULL;
    *m_dwFlag = 0;
    return NULL;
}

void CUsers::Clear()
{
    PUSERSONFILE TmpUserItem = m_UsersRoot;
    while (TmpUserItem)
	{
        m_UsersRoot = TmpUserItem->m_pNext;
        delete [] TmpUserItem->m_szUserName;
        delete [] TmpUserItem->m_szDnName;
        delete [] TmpUserItem->m_pCert;
        if (TmpUserItem->m_UserSid)
		{
            delete [] TmpUserItem->m_UserSid;
        }
        if (TmpUserItem->m_pCertContext)
		{
            ::CertFreeCertificateContext(TmpUserItem->m_pCertContext);
        }
        delete TmpUserItem;
        TmpUserItem = m_UsersRoot;
    }

    m_UsersRoot = NULL;
	m_UserAddedCnt = 0;
	m_UserRemovedCnt = 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\welcome.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Welcome.cpp
//
//  Contents:   Implementation of Add EFS Agent Wizard Welcome Page
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Welcome.h"
#include "AddSheet.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizWelcome property page

CAddEFSWizWelcome::CAddEFSWizWelcome() : CWizard97PropertyPage(CAddEFSWizWelcome::IDD)
{
	//{{AFX_DATA_INIT(CAddEFSWizWelcome)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	InitWizard97 (TRUE);
}

CAddEFSWizWelcome::~CAddEFSWizWelcome()
{
}

void CAddEFSWizWelcome::DoDataExchange(CDataExchange* pDX)
{
	CWizard97PropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddEFSWizWelcome)
	DDX_Control(pDX, IDC_STATICB_BOLD, m_boldStatic);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddEFSWizWelcome, CWizard97PropertyPage)
	//{{AFX_MSG_MAP(CAddEFSWizWelcome)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizWelcome message handlers

BOOL CAddEFSWizWelcome::OnSetActive() 
{
	BOOL	bResult = CWizard97PropertyPage::OnSetActive();

	if ( bResult )
		GetParent ()->PostMessage (PSM_SETWIZBUTTONS, 0, PSWIZB_NEXT);
	
	return bResult;
}

BOOL CAddEFSWizWelcome::OnInitDialog() 
{
	CWizard97PropertyPage::OnInitDialog();
	
	m_boldStatic.SetFont (&GetBigBoldFont ());
	CString	title;
	VERIFY (title.LoadString (IDS_ADDTITLE));
	CWnd* pParent = GetParent ();
    if ( pParent )
        pParent->SendMessage (PSM_SETTITLE, 0, (LPARAM) (LPCWSTR) title);
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\welcome.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       welcome.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_WELCOME_H__8C048CD7_54B2_11D1_BB63_00A0C906345D__INCLUDED_)
#define AFX_WELCOME_H__8C048CD7_54B2_11D1_BB63_00A0C906345D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Welcome.h : header file
//
#include "Wiz97PPg.h"

/////////////////////////////////////////////////////////////////////////////
// CAddEFSWizWelcome dialog

class CAddEFSWizWelcome : public CWizard97PropertyPage
{

// Construction
public:
	CAddEFSWizWelcome();
	virtual ~CAddEFSWizWelcome();

// Dialog Data
	//{{AFX_DATA(CAddEFSWizWelcome)
	enum { IDD = IDD_ADD_EFS_AGENT_WELCOME };
	CStatic	m_boldStatic;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAddEFSWizWelcome)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAddEFSWizWelcome)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WELCOME_H__8C048CD7_54B2_11D1_BB63_00A0C906345D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\wiz97ppg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Wiz97PPg.cpp
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Wiz97PPg.cpp : implementation file
//

#include "stdafx.h"
#include "Wiz97PPg.h"

#ifdef _DEBUG
#ifndef ALPHA
#define new DEBUG_NEW
#endif
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage property page
IMPLEMENT_DYNCREATE(CWizard97PropertyPage, CPropertyPage)

CWizard97PropertyPage::CWizard97PropertyPage ()
	: CPropertyPage (),
	m_pWiz (0)
{
	ASSERT (0); // default constructor - should never be called
}

CWizard97PropertyPage::CWizard97PropertyPage(UINT nIDTemplate) : 
	CPropertyPage(nIDTemplate),
	m_pWiz (0)
{
	//{{AFX_DATA_INIT(CWizard97PropertyPage)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWizard97PropertyPage::~CWizard97PropertyPage()
{
}

void CWizard97PropertyPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWizard97PropertyPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWizard97PropertyPage, CPropertyPage)
	//{{AFX_MSG_MAP(CWizard97PropertyPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage message handlers

void CWizard97PropertyPage::InitWizard97(bool bHideHeader)
{
    // security review 2/27/2002 BryanWal ok
	::ZeroMemory (&m_psp97, sizeof (m_psp97));
	m_psp.dwFlags &= ~PSP_HASHELP;
    ASSERT (sizeof (m_psp97) >= m_psp.dwSize);
    if ( sizeof (m_psp97) < m_psp.dwSize )
        return;

    // security review 2/27/2002 BryanWal ok
	memcpy (&m_psp97, &m_psp, m_psp.dwSize);
	m_psp97.dwSize = sizeof (PROPSHEETPAGE);

	if ( bHideHeader )
	{
		// for first and last page of the wizard
		m_psp97.dwFlags |= PSP_HIDEHEADER;
	}
	else
	{
		// for intermediate pages
		m_psp97.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
		m_psp97.pszHeaderTitle = (LPCWSTR) m_szHeaderTitle;
		m_psp97.pszHeaderSubTitle = (LPCWSTR) m_szHeaderSubTitle;
	}
}

bool CWizard97PropertyPage::SetupFonts()
{
	bool	bReturn = false;
    //
	// Create the fonts we need based on the dialog font
    //
	NONCLIENTMETRICS ncm = {0};
	ncm.cbSize = sizeof (ncm);
	SystemParametersInfo (SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

	LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
	LOGFONT BoldLogFont     = ncm.lfMessageFont;

    //
	// Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
	BoldLogFont.lfWeight      = FW_BOLD;

    CString	largeFontSizeString;
    INT		largeFontSize;
    CString smallFontSizeString;
    INT		smallFontSize;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    static PCWSTR pwszAlternateFont = L"Verdana";
    static size_t cchFont = wcslen (pwszAlternateFont);
    if ( !::LoadString (AfxGetInstanceHandle (), IDS_LARGEFONTNAME,
			BigBoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
		ASSERT (0);
        // security review 2/27/2002 BryanWal ok
        if ( cchFont < LF_FACESIZE )
            wcscpy (BigBoldLogFont.lfFaceName, pwszAlternateFont);
    }

    if ( largeFontSizeString.LoadString (IDS_LARGEFONTSIZE) ) 
    {
        largeFontSize = wcstoul ((LPCWSTR) largeFontSizeString, NULL, 10);
    } 
    else 
    {
		ASSERT (0);
        largeFontSize = 12;
    }

    if ( !::LoadString (AfxGetInstanceHandle (), IDS_SMALLFONTNAME,
			BoldLogFont.lfFaceName, LF_FACESIZE) ) 
    {
		ASSERT (0);
        if ( cchFont < LF_FACESIZE )
            wcscpy (BoldLogFont.lfFaceName, pwszAlternateFont);
    }

    if ( smallFontSizeString.LoadString (IDS_SMALLFONTSIZE) ) 
    {
        smallFontSize = wcstoul ((LPCWSTR) smallFontSizeString, NULL, 10);
    } 
    else 
    {
		ASSERT (0);
        smallFontSize = 8;
    }

	CDC* pdc = GetDC ();

    if ( pdc )
    {
        BigBoldLogFont.lfHeight = 0 - (pdc->GetDeviceCaps (LOGPIXELSY) * largeFontSize / 72);
        BoldLogFont.lfHeight = 0 - (pdc->GetDeviceCaps (LOGPIXELSY) * smallFontSize / 72);

        BOOL	bBigBold = m_bigBoldFont.CreateFontIndirect (&BigBoldLogFont);
		BOOL	bBold = m_boldFont.CreateFontIndirect (&BoldLogFont);

        ReleaseDC (pdc);

        if ( bBigBold && bBold )
			bReturn = true;
		else
        {
            if ( bBold )
            {
                VERIFY (m_boldFont.DeleteObject());
            }

            if ( bBigBold )
            {
                VERIFY (m_bigBoldFont.DeleteObject());
            }
        }
    }

    return bReturn;
}

CFont& CWizard97PropertyPage::GetBoldFont()
{
	return m_boldFont;
}

CFont& CWizard97PropertyPage::GetBigBoldFont()
{
	return m_bigBoldFont;
}


BOOL CWizard97PropertyPage::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	LONG dwExStyle = GetWindowLong (GetParent ()->m_hWnd, GWL_EXSTYLE);
	if ( dwExStyle & WS_EX_CONTEXTHELP )
	{
		dwExStyle &= ~WS_EX_CONTEXTHELP;
		SetWindowLong (GetParent ()->m_hWnd, GWL_EXSTYLE, dwExStyle);
	}

	SetupFonts ();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\wiz97ppg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       wiz97ppg.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
#if !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Wiz97PPg.h : header file
//
#include "Wiz97Sht.h"

/////////////////////////////////////////////////////////////////////////////
// CWizard97PropertyPage dialog

class CWizard97PropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CWizard97PropertyPage)
// Construction
public:
	PROPSHEETPAGE			m_psp97;
	CString					m_szHeaderTitle;
	CString					m_szHeaderSubTitle;
	CWizard97PropertySheet* m_pWiz;

	void InitWizard97(bool bHideHeader);
	CWizard97PropertyPage ();
	CWizard97PropertyPage(UINT nIDTemplate);
	virtual ~CWizard97PropertyPage();

// Dialog Data
	//{{AFX_DATA(CWizard97PropertyPage)
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWizard97PropertyPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWizard97PropertyPage)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	bool SetupFonts ();
	CFont& GetBigBoldFont();
	CFont& GetBoldFont();

	CFont m_boldFont;
	CFont m_bigBoldFont;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIZ97PPG_H__386C7213_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\wiz97sht.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2001.
//
//  File:       Wiz97Sht.h
//
//  Contents:   
//
//----------------------------------------------------------------------------
// Wiz97Sht.h: interface for the CWizard97PropertySheet class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
#define AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define NUM_PAGES 10

class CWizard97PropertyPage; // Forward definition

class CWizard97PropertySheet
{
public:
	void AddPage( CWizard97PropertyPage *pPage );
	CWizard97PropertySheet(UINT nIDCaption, UINT nIDWaterMark, UINT nIDBanner);
	virtual ~CWizard97PropertySheet();

	INT_PTR DoWizard(HWND hParent);

//private:
	CString m_title;

	PROPSHEETHEADER			m_psh;
    HPROPSHEETPAGE			m_pPageArr[NUM_PAGES];
	CWizard97PropertyPage*	m_pPagePtr[NUM_PAGES];
	int						m_nPageCount;
};

#endif // !defined(AFX_WIZ97SHT_H__386C7214_A248_11D1_8618_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\certmgr\wiz97sht.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2002.
//
//  File:       Wiz97Sht.cpp
//
//  Contents:   Base class for cert find dialog
//
//----------------------------------------------------------------------------\
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Wiz97Sht.h"
#include "Wiz97PPg.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWizard97PropertySheet::CWizard97PropertySheet(UINT nIDCaption, UINT nIDWaterMark, UINT nIDBanner)
{
    // security review 2/27/2002 BryanWal ok
	::ZeroMemory (&m_pPagePtr, sizeof (m_pPagePtr));
	::ZeroMemory (&m_pPageArr, sizeof (m_pPageArr));

	// NOTICE: do this because of header mismatch
    // security review 2/27/2002 BryanWal ok
    ::ZeroMemory (&m_psh, sizeof(m_psh));
	m_psh.dwFlags = PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
	m_psh.pszbmWatermark = MAKEINTRESOURCE (nIDWaterMark);
	m_psh.pszbmHeader = MAKEINTRESOURCE (nIDBanner);
	m_psh.hplWatermark = NULL;
	

    m_psh.dwSize              = sizeof (m_psh);
    m_psh.hInstance           = AfxGetApp()->m_hInstance;
    m_psh.hwndParent          = NULL;

	VERIFY (m_title.LoadString (nIDCaption));
    m_psh.pszCaption          = (LPCWSTR) m_title;
    m_psh.phpage              = NULL;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = 0;

    m_nPageCount = 0;
}

CWizard97PropertySheet::~CWizard97PropertySheet()
{
}


INT_PTR CWizard97PropertySheet::DoWizard(HWND hParent)
{
    m_psh.hwndParent = hParent;
//   if ( m_nPageCount > 0 && m_pPagePtr[m_nPageCount - 1] )
//		m_pPagePtr[m_nPageCount - 1]->m_bLast = TRUE;

    m_psh.phpage              = m_pPageArr;
    m_psh.nStartPage          = 0;
    m_psh.nPages              = m_nPageCount;

	return PropertySheet (&m_psh);
}

void CWizard97PropertySheet::AddPage(CWizard97PropertyPage * pPage)
{
	ASSERT (pPage);
	if ( pPage )
	{
		ASSERT (m_nPageCount < NUM_PAGES);
		m_pPagePtr[m_nPageCount] = pPage;
		m_pPageArr[m_nPageCount] = ::MyCreatePropertySheetPage (
                (AFX_OLDPROPSHEETPAGE*) &(pPage->m_psp97));
		ASSERT (m_pPageArr[m_nPageCount]);
		m_nPageCount++;
		pPage->m_pWiz = this;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\chooser\chooser.cpp ===
/////////////////////////////////////////////////////////////////////
//	Chooser.cpp
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//
//	Dialog to choose a machine name.
//
//	PURPOSE
//	(Important -- Please Read)
//	This code was written for you to save you time.
//	What you have to do is to copy all the files from the
//	snapin\chooser\ directory into your project (you may add
//	\nt\private\admin\snapin\chooser\ to your include directory if
//	you prefer not copying the code).
//	If you decide to copy the code to your project, please send mail
//	to Dan Morin (T-DanM) and cc to Jon Newman (JonN) so we can
//	mail you when we have updates available.  The next update will
//	be the "Browse" button to select a machine name.
//
//
//  DYNALOADED LIBRARIES
//		$(SDK_LIB_PATH)\shell32.lib         // CommandLineToArgvW()
//		$(SDK_LIB_PATH)\netapi32.lib        // I_NetName*()
//
//	EXTRA INFO
//	If you don't know how this works, take a look at the inheritance tree
//	in chooser.h.  Then, take a look at the existing code that inherit and/or
//	uses CChooseMachinePropPage.
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//	23-May-1997		t-danm		Checkin into public tree. Comments updates.
//	25-May-1997		t-danm		Added MMCPropPageCallback().
//	31-Oct-1997		mattt			Added dynaload, fixed user <CANCEL> logic
//
/////////////////////////////////////////////////////////////////////

#include "chooser.h"
#include <lmcons.h>	  // NET_API_STATUS
#include <lmerr.h>	  // NERR_Success
#include <icanon.h>   // I_NetNameValidate(), I_NetNameCanonicalize(). Found in \nt\private\net\inc.
#include <objsel.h>
#include "stdutils.h" // IsLocalComputername
#include <lmserver.h> // NetServerGetInfo JonN 2002/04/08 585301
#include <lmapibuf.h> // NetApiBufferFree JonN 2002/04/08 585301

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
#define THIS_FILE __FILE__
#endif

#ifndef INOUT
	// The following defines are found in \nt\private\admin\snapin\filemgmt\stdafx.h

	#define INOUT
	#define	Endorse(f)		// Dummy macro
	#define LENGTH(x)		(sizeof(x)/sizeof(x[0]))
	#define Assert(f)		ASSERT(f)
#endif

/////////////////////////////////////////////////////////////////////
//	CanonicalizeComputername()
//
//	Function to validate the computer name and optionally
//	add the \\ at beginning of machine name.
//


typedef
NET_API_STATUS
NET_API_FUNCTION
INETNAMEVALIDATE(
    LPTSTR  ServerName,
    LPTSTR  Name,
    DWORD   NameType,
    DWORD   Flags);

typedef
NET_API_STATUS
NET_API_FUNCTION
INETNAMECANONICALIZE(
    LPTSTR  ServerName,
    LPTSTR  Name,
    LPTSTR  Outbuf,
    DWORD   OutbufLen,
    DWORD   NameType,
    DWORD   Flags);


NET_API_STATUS
CanonicalizeComputername(
	INOUT CString& rstrMachineName,
	IN BOOL fAddWackWack = TRUE)	// TRUE => Add the \\ at beginning of name
{
	NET_API_STATUS err;
	LPTSTR pszTemp;

	rstrMachineName.TrimLeft();
	rstrMachineName.TrimRight();
	if ( rstrMachineName.IsEmpty() )
		return NERR_Success;

	if ( 2 <= rstrMachineName.GetLength() &&
		 _T('\\') == rstrMachineName[0] &&
		 _T('\\') == rstrMachineName[1] )
	{
		// Remove the \\ at the beginning of name
		CString strShorter = rstrMachineName.Right(
			rstrMachineName.GetLength() - 2 );
		rstrMachineName = strShorter;
	}

	// DYNALOAD NETAPI32.dll
	HINSTANCE hNetApiDll = NULL;
	INETNAMEVALIDATE        *pfnValidate;
	INETNAMECANONICALIZE    *pfnCanonicalize;
   if (NULL == (hNetApiDll = LoadLibrary(L"netapi32.dll")))
      return GetLastError();

   if (NULL == (pfnValidate = (INETNAMEVALIDATE*)GetProcAddress(hNetApiDll, "I_NetNameValidate")) )
   {
      err = GetLastError();
      goto Ret;
   }
    if (NULL == (pfnCanonicalize = (INETNAMECANONICALIZE*)GetProcAddress(hNetApiDll, "I_NetNameCanonicalize")) )
    {
        err = GetLastError();
        goto Ret;
    }


	err = pfnValidate(
		  NULL,
        const_cast<LPTSTR>((LPCTSTR)rstrMachineName),
        NAMETYPE_COMPUTER,
        0L );
	if (NERR_Success != err)
		goto Ret;

	if ( MAX_PATH <= rstrMachineName.GetLength() )
	{
		err = ERROR_INVALID_NAME;
		goto Ret;
	}
   pszTemp = (LPTSTR)alloca( MAX_PATH*sizeof(TCHAR) );
   ASSERT( NULL != pszTemp );
   // 2002/03/28-JonN CliffV confirms that this API takes a bytecount
   err = pfnCanonicalize(
		NULL,
      IN const_cast<LPTSTR>((LPCTSTR)rstrMachineName),
		OUT pszTemp,
		MAX_PATH*sizeof(TCHAR),
      NAMETYPE_COMPUTER,
      0L );
	if (NERR_Success != err)
		goto Ret;
	if (fAddWackWack && pszTemp[0] != '\0')
	{
		// Add the \\ at beginning of name
		rstrMachineName = _T("\\\\");
		rstrMachineName += pszTemp;
	}
	else
	{
		rstrMachineName = pszTemp;
	}

   err = NERR_Success;
Ret:
   if (hNetApiDll)
      FreeLibrary(hNetApiDll);

	return err;
} // CanonicalizeComputername()


/////////////////////////////////////////////////
//	Machine name override
const TCHAR szOverrideCommandLineEquals[] = _T("/Computer=");	// Not subject to localization
const TCHAR szOverrideCommandLineColon[] = _T("/Computer:");	// Not subject to localization
const TCHAR szLocalMachine[] = _T("LocalMachine");		// Not subject to localization
const int cchOverrideCommandLine = LENGTH(szOverrideCommandLineEquals) - 1;
// Assumption: both command line strings are the same length

static CString g_strOverrideMachineName;
static LPCTSTR g_pszOverrideMachineName;	// NULL => No override provided, "" => LocalMachine

///////////////////////////////////////////////////////////////////////////////
//	PchGetMachineNameOverride()
//
//	Parse the command line arguments and return a pointer to the
//	machine name override if present.
//
//	INTERFACE NOTES
//	If the machine name is other than local machine, the machine name
//	will have the \\ at the beginning of its name.
//	
//	RETURN
//	- Return NULL if no override (ie, no command line override)
//	- Return pointer to empty string if override is "local machine"
//	- Otherwise return pointer to machine name override with \\ at beginning.
//
typedef
LPWSTR * COMMANDLINETOARGVW(
                LPCWSTR lpCmdLine,  // pointer to a command-line string
                int *pNumArgs);     // pointer to a variable that receives the argument count



LPCTSTR PchGetMachineNameOverride ()
{
	static BOOL fAlreadyInitialized = FALSE;
	if (fAlreadyInitialized)
	{
		// We already have parsed the command line
		return g_pszOverrideMachineName;
	}
	fAlreadyInitialized = TRUE;
	ASSERT(g_pszOverrideMachineName == NULL);

	LPCWSTR * lpServiceArgVectors = 0;		// Array of pointers to string
	int cArgs = 0;						// Count of arguments


    // DYNALOAD Shell32
    {
        HINSTANCE hShellDll = LoadLibrary (L"shell32.dll");
        if ( !hShellDll )
            return NULL;

        COMMANDLINETOARGVW *pfnCmdToArgs = (COMMANDLINETOARGVW*) GetProcAddress (hShellDll, "CommandLineToArgvW");
        if ( !pfnCmdToArgs )
        {
            VERIFY (FreeLibrary (hShellDll));
            return NULL;
        }

        lpServiceArgVectors = (LPCWSTR *) pfnCmdToArgs (GetCommandLineW (), OUT &cArgs);

        VERIFY (FreeLibrary (hShellDll));
        pfnCmdToArgs = NULL;
    }

	if (lpServiceArgVectors == NULL)
		return NULL;
	// ISSUE-2002/03/28-JonN I wouldn't mind being a little more cautious here
	//   by checking the overall length of lpServiceArgVectors and the string-ness
	//   of its components.
	for (int i = 1; i < cArgs; i++)
	{
		Assert(lpServiceArgVectors[i] != NULL);
		CString str = lpServiceArgVectors[i];	// Copy the string
		str = str.Left(cchOverrideCommandLine);
		if (0 != str.CompareNoCase(szOverrideCommandLineEquals) &&
				0 != str.CompareNoCase(szOverrideCommandLineColon) )
		{
			continue;
		}
		str = lpServiceArgVectors[i] + cchOverrideCommandLine;
		if (0 == str.CompareNoCase(szLocalMachine))
			str.Empty();
		if (NERR_Success != CanonicalizeComputername(INOUT str))
			continue;
		g_strOverrideMachineName = str;	// Copy the argument into the global string
		g_pszOverrideMachineName = g_strOverrideMachineName;
	}
	LocalFree(lpServiceArgVectors);
	return g_pszOverrideMachineName;
} // PchGetMachineNameOverride()


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CAutoDeletePropPage, CPropertyPage)
	//{{AFX_MSG_MAP(CAutoDeletePropPage)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : CPropertyPage(uIDD)
{
	m_prgzHelpIDs = NULL;
	m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
	m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;
	m_psp.pfnCallback = S_PropSheetPageProc;
	m_psp.lParam = reinterpret_cast<LPARAM>(this);

	// The following line is to enable MFC property pages to run under MMC.
	MMCPropPageCallback(INOUT &m_psp);
}

CAutoDeletePropPage::~CAutoDeletePropPage()
{
}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
{
	m_strCaption = pszCaption;		// Copy the caption
	m_psp.pszTitle = m_strCaption;	// Set the title
	m_psp.dwFlags |= PSP_USETITLE;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
{
	VERIFY(m_strCaption.LoadString(uStringID));
	SetCaption(m_strCaption);
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
	Endorse(szHelpFile == NULL);	// TRUE => No help file supplied (meaning no help)
	Endorse(rgzHelpIDs == NULL);	// TRUE => No help at all
	m_strHelpFile = szHelpFile;
	m_prgzHelpIDs = rgzHelpIDs;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
	Assert(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
	::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
{
	HWND hwndParent = ::GetParent(m_hWnd);
	Assert(IsWindow(hwndParent));
	::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);
	return CPropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
	if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
		return TRUE;
	const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
	if (pHelpInfo != NULL && pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
		// Display context help for a control
		::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
			HELP_WM_HELP, (DWORD_PTR)m_prgzHelpIDs);
	}
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
	if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
		return TRUE;
	Assert(IsWindow((HWND)wParam));
	::WinHelp((HWND)wParam, m_strHelpFile, HELP_CONTEXTMENU, (DWORD_PTR)m_prgzHelpIDs);
	return TRUE;
}


/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//
UINT CALLBACK CAutoDeletePropPage::S_PropSheetPageProc(
	HWND hwnd,	
	UINT uMsg,	
	LPPROPSHEETPAGE ppsp)
{
	Assert(ppsp != NULL);
	CChooseMachinePropPage * pThis;
	pThis = reinterpret_cast<CChooseMachinePropPage*>(ppsp->lParam);
	Assert(pThis != NULL);

	switch (uMsg)
	{
	case PSPCB_RELEASE:
		if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
			{
			// Remember callback on stack since "this" will be deleted
			LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
			delete pThis;
			return (pfnOrig)(hwnd, uMsg, ppsp);
		}
		break;
	case PSPCB_CREATE:
		// do not increase refcount, PSPCB_CREATE may or may not be called
		// depending on whether the page was created.  PSPCB_RELEASE can be
		// depended upon to be called exactly once per page however.
		break;

	} // switch
	return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
} // CAutoDeletePropPage::S_PropSheetPageProc()





/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CChooseMachinePropPage, CAutoDeletePropPage)
	//{{AFX_MSG_MAP(CChooseMachinePropPage)
	ON_BN_CLICKED(IDC_CHOOSER_RADIO_LOCAL_MACHINE, OnRadioLocalMachine)
	ON_BN_CLICKED(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, OnRadioSpecificMachine)
	ON_BN_CLICKED(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, OnChooserButtonBrowseMachinenames)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#ifdef _DEBUG
static void AssertValidDialogTemplate(HWND hwnd)
{
	ASSERT(::IsWindow(hwnd));
	// Mandatory controls for a valid dialog template
	static const UINT rgzidDialogControl[] =
	{
		IDC_CHOOSER_RADIO_LOCAL_MACHINE,
		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,
		IDC_CHOOSER_EDIT_MACHINE_NAME,
		0
	};

	for (int i = 0; rgzidDialogControl[i] != 0; i++)
	{
		ASSERT(NULL != GetDlgItem(hwnd, rgzidDialogControl[i]) &&
			"Control ID not found in dialog template.");
	}
} // AssertValidDialogTemplate()
#else
	#define AssertValidDialogTemplate(hwnd)
#endif	// ~_DEBUG

/////////////////////////////////////////////////////////////////////
//	Constructor
CChooseMachinePropPage::CChooseMachinePropPage(UINT uIDD) : CAutoDeletePropPage(uIDD)
{
	// ISSUE-2002/03/28-JonN initialize m_hwndCheckboxOverride
	m_fIsRadioLocalMachine = TRUE;
	m_fAllowOverrideMachineName = FALSE;
	
	m_pfAllowOverrideMachineNameOut = NULL;
	m_pstrMachineNameOut = NULL;
	m_pstrMachineNameEffectiveOut = NULL;
}

/////////////////////////////////////////////////////////////////////
CChooseMachinePropPage::~CChooseMachinePropPage()
{
}

/////////////////////////////////////////////////////////////////////
//	Load the initial state of CChooseMachinePropPage
void CChooseMachinePropPage::InitMachineName(LPCTSTR pszMachineName)
{
	Endorse(pszMachineName == NULL);
	m_strMachineName = pszMachineName;
	m_fIsRadioLocalMachine = m_strMachineName.IsEmpty();
}

/////////////////////////////////////////////////////////////////////
//	SetOutputBuffers()
//
//	- Set the pointer to the CString object to store the machine name.
//	- Set the pointer to the boolean flag for command line override.
//	- Set the pointer pointer to store the overriden machine name.
//
void CChooseMachinePropPage::SetOutputBuffers(
	OUT CString * pstrMachineNamePersist,	// Machine name the user typed.  Empty string == local machine.
	OUT BOOL * pfAllowOverrideMachineName,
	OUT CString * pstrMachineNameEffective)
{
	Assert(pstrMachineNamePersist != NULL && "Invalid output buffer");
	Endorse(pfAllowOverrideMachineName == NULL); // TRUE => Do not want to support override from command line
	Endorse(pstrMachineNameEffective == NULL);		// TRUE => Don't care of override
	
	m_pstrMachineNameOut = pstrMachineNamePersist;
	m_pfAllowOverrideMachineNameOut = pfAllowOverrideMachineName;
	m_pstrMachineNameEffectiveOut = pstrMachineNameEffective;
}

/////////////////////////////////////////////////////////////////////
void CChooseMachinePropPage::DoDataExchange(CDataExchange* pDX)
{
	CAutoDeletePropPage::DoDataExchange(pDX);

	//{{AFX_DATA_MAP(CChooseMachinePropPage)
	//}}AFX_DATA_MAP

	DDX_Text(pDX, IDC_CHOOSER_EDIT_MACHINE_NAME, m_strMachineName);
	DDV_MaxChars(pDX, m_strMachineName, MAX_PATH);
	if (NULL != m_hwndCheckboxOverride)
	{
		DDX_Check(pDX, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME, m_fAllowOverrideMachineName);
	}
    // JonN 10/25/01 485853
	if (pDX->m_bSaveAndValidate && !m_fIsRadioLocalMachine)
	{
		// User clicked on OK
		if (NERR_Success != CanonicalizeComputername(INOUT m_strMachineName) )
		{
			// AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxMessageBox()
			// AfxMessageBox(IDS_CHOOSER_INVALID_COMPUTERNAME);

			CString	text;
			CString	caption;
			text.LoadString (IDS_CHOOSER_INVALID_COMPUTERNAME);
			caption.LoadString (IDS_SELECT_COMPUTER);
			::MessageBox (m_hWnd, text, caption, MB_ICONEXCLAMATION | MB_OK);
			//::SetFocus(::GetDlgItem(m_hWnd,IDC_CHOOSER_EDIT_MACHINE_NAME));

			pDX->Fail();
			Assert(FALSE && "Unreachable code");
		}
	} // if

} // DoDataExchange()


/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnInitDialog()
{
	// ISSUE-2002/03/28-JonN chooser2 calls Edit_LimitText(MAX_PATH+2)
	AssertValidDialogTemplate(m_hWnd);
	CAutoDeletePropPage::OnInitDialog();
	InitRadioButtons();
	m_hwndCheckboxOverride = ::GetDlgItem(m_hWnd, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME);
	if (m_pfAllowOverrideMachineNameOut == NULL && m_hwndCheckboxOverride != NULL)
	{
		// We are not interested with the command line override
		::EnableWindow(m_hwndCheckboxOverride, FALSE);	// Disable the window
		::ShowWindow(m_hwndCheckboxOverride, SW_HIDE);	// Hide the window
	}
	
	return TRUE;
}

/////////////////////////////////////////////////////////////////////
BOOL CChooseMachinePropPage::OnWizardFinish()
{
	if (!UpdateData())    // Do the data exchange to collect data
		return FALSE;       // don't destroy on error

	if (m_fIsRadioLocalMachine)
		m_strMachineName.Empty();

	if (m_pstrMachineNameOut != NULL)
	{
		// Store the machine name into its output buffer
		*m_pstrMachineNameOut = m_strMachineName;
		if (m_pfAllowOverrideMachineNameOut != NULL)
			*m_pfAllowOverrideMachineNameOut = m_fAllowOverrideMachineName;
		if (m_pstrMachineNameEffectiveOut != NULL)
		{
			if (m_fAllowOverrideMachineName && PchGetMachineNameOverride())
				*m_pstrMachineNameEffectiveOut = PchGetMachineNameOverride();
			else
				*m_pstrMachineNameEffectiveOut = m_strMachineName;

			// JonN 1/27/99: If the persisted name is the local computername,
			// leave the persisted name alone but make the effective name (Local).
			if ( IsLocalComputername( *m_pstrMachineNameEffectiveOut ) )
				m_pstrMachineNameEffectiveOut->Empty();

		} // if
	}
	else
		Assert(FALSE && "FYI: You have not specified any output buffer to store the machine name.");

	return CAutoDeletePropPage::OnWizardFinish();
}

void CChooseMachinePropPage::InitRadioButtons()
{
	SendDlgItemMessage(IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, m_fIsRadioLocalMachine);
	SendDlgItemMessage(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !m_fIsRadioLocalMachine);
	SendDlgItemMessage(IDC_CHOOSER_EDIT_MACHINE_NAME, MAX_PATH-1);
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, !m_fIsRadioLocalMachine);
	EnableDlgItem (IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, !m_fIsRadioLocalMachine);
}

void CChooseMachinePropPage::OnRadioLocalMachine()
{
	m_fIsRadioLocalMachine = TRUE;
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, FALSE);
	EnableDlgItem (IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, FALSE);
}

void CChooseMachinePropPage::OnRadioSpecificMachine()
{
	m_fIsRadioLocalMachine = FALSE;
	EnableDlgItem(IDC_CHOOSER_EDIT_MACHINE_NAME, TRUE);
	EnableDlgItem (IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES, TRUE);
}



void CChooseMachinePropPage::OnChooserButtonBrowseMachinenames()
{
	CString	 computerName;
	HRESULT hr = ComputerNameFromObjectPicker (m_hWnd, computerName);
	if ( S_OK == hr )  // S_FALSE means user pressed "Cancel"
	{
		SetDlgItemText (IDC_CHOOSER_EDIT_MACHINE_NAME, computerName);
	}
	else if ( FAILED (hr) )
	{
		CString	text;
		CString	caption;

		text.LoadString (IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR);
		caption.LoadString (IDS_SELECT_COMPUTER);

		MessageBox (text, caption, MB_ICONEXCLAMATION | MB_OK);
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Generic Computer Picker
///////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT InitObjectPickerForComputers(IDsObjectPicker *pDsObjectPicker)
{
	if ( !pDsObjectPicker )
		return E_POINTER;

	//
	// Prepare to initialize the object picker.
	// Set up the array of scope initializer structures.
	//

	static const int SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

	ZeroMemory(aScopeInit, sizeof(aScopeInit)); // JonN 3/28/02

	//
	// 127399: JonN 10/30/00 JOINED_DOMAIN should be starting scope
	//

	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
	                     | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
	                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
	                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_WORKGROUP
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	//
	// Put the scope init array into the object picker init array
	//

	DSOP_INIT_INFO  initInfo;
	ZeroMemory(&initInfo, sizeof(initInfo));

	initInfo.cbSize = sizeof(initInfo);
	initInfo.pwzTargetComputer = NULL;  // NULL == local machine
	initInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	initInfo.aDsScopeInfos = aScopeInit;
	initInfo.cAttributesToFetch = 1;
	static PCWSTR pwszDnsHostName = L"dNSHostName";
	initInfo.apwzAttributeNames = &pwszDnsHostName;

	//
	// Note object picker makes its own copy of initInfo.  Also note
	// that Initialize may be called multiple times, last call wins.
	//

	return pDsObjectPicker->Initialize(&initInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   ProcessSelectedObjects
//
//  Synopsis:   Retrieve the list of selected items from the data object
//              created by the object picker and print out each one.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT ProcessSelectedObjects(IDataObject *pdo, CString& computerName)
{
	if ( !pdo )
		return E_POINTER;

	HRESULT hr = S_OK;
	static UINT g_cfDsObjectPicker =
		RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		(CLIPFORMAT)g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	bool fGotStgMedium = false;

	do
	{
		hr = pdo->GetData(&formatetc, &stgmedium);
		if ( SUCCEEDED (hr) )
		{
			fGotStgMedium = true;

			PDS_SELECTION_LIST pDsSelList =
				(PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

			if (!pDsSelList)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());
				break;
			}

			ASSERT (1 == pDsSelList->cItems);
			if ( 1 == pDsSelList->cItems )
			{
				PDS_SELECTION psel = &(pDsSelList->aDsSelection[0]);
				// ISSUE-2002/03/28-JonN check for NULL == psel
				VARIANT* pvarDnsName = &(psel->pvarFetchedAttributes[0]);
				if (   NULL == pvarDnsName
				    || VT_BSTR != pvarDnsName->vt
				    || NULL == pvarDnsName->bstrVal
				    || L'\0' == (pvarDnsName->bstrVal)[0] )
				{
					computerName = psel->pwzName;
				} else {
					computerName = pvarDnsName->bstrVal;

					//
					// JonN 2002/04/08 585301
					// Computer management snapin only attempts to use the DnsHostName
					// to connect to a remote computer, even when the dns name
					// is not valid
					//
					// Bank of America encounters a problem because they
					// set RegisterDnsARecord to 1, turning off client DNS
					// records.  The dnsHostName is therefore not a valid
					// binding name.  The fix is to test the dnsHostName.
					//
					LPBYTE pbDummy = NULL;
					NET_API_STATUS err = NetServerGetInfo(
						(LPTSTR)(LPCTSTR)computerName, 101, &pbDummy );
					if (pbDummy)
					{
						NetApiBufferFree( pbDummy );
						pbDummy = NULL;
					}
					if (NERR_Success != err)
					{
						err = NetServerGetInfo( psel->pwzName, 101, &pbDummy );
						if (pbDummy)
						{
							NetApiBufferFree( pbDummy );
							pbDummy = NULL;
						}
						if (NERR_Success == err)
							computerName = psel->pwzName;
					}
					// end new code: JonN 2002/04/08 585301

				}
			}
			else
				hr = E_UNEXPECTED;
			

			GlobalUnlock(stgmedium.hGlobal);
		}
	} while (0);

	if (fGotStgMedium)
	{
		ReleaseStgMedium(&stgmedium);
	}

	return hr;
}



///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//////////////////////////////////////////////////////////////////////////////
HRESULT	ComputerNameFromObjectPicker (HWND hwndParent, CString& computerName)
{
	//
	// Create an instance of the object picker.  The implementation in
	// objsel.dll is apartment model.
	//
	CComPtr<IDsObjectPicker> spDsObjectPicker;
	HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
	                              NULL,
	                              CLSCTX_INPROC_SERVER,
	                              IID_IDsObjectPicker,
	                              (void **) &spDsObjectPicker);
	if ( SUCCEEDED (hr) )
	{
		ASSERT(!!spDsObjectPicker);
		//
		// Initialize the object picker to choose computers
		//

		hr = InitObjectPickerForComputers(spDsObjectPicker);
		if ( SUCCEEDED (hr) )
		{
			//
			// Now pick a computer
			//
			CComPtr<IDataObject> spDataObject;

			hr = spDsObjectPicker->InvokeDialog(hwndParent, &spDataObject);
			if ( S_OK == hr )
			{
				ASSERT(!!spDataObject);
				hr = ProcessSelectedObjects(spDataObject, computerName);
			}
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\chooser\chooser.h ===
/////////////////////////////////////////////////////////////////////
//	Chooser.h
//
//	HISTORY
//	13-May-1997		t-danm		Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __CHOOSER_H_INCLUDED__
#define __CHOOSER_H_INCLUDED__

LPCTSTR PchGetMachineNameOverride();


#include "choosert.h"	// Temporary IDs
#include "chooserd.h"	// Default IDs


///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//////////////////////////////////////////////////////////////////////////////
HRESULT	ComputerNameFromObjectPicker (HWND hwndParent, CString& computerName);


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//	INHERITANCE TREE (so far)
//	CAutoDeletePropPage - Base object
//		CChooseMachinePropPage - Dialog to select a machine name
//			CFileMgmtGeneral - Dialog to select "File Services" (snapin\filemgmt\snapmgr.h)
//			CMyComputerGeneral - Dialog for the "My Computer" (snapin\mycomput\snapmgr.h)
//		CChoosePrototyperPropPage - Dialog to select prototyper demo (NYI)
//	
//	HISTORY
//	15-May-1997		t-danm		Creation. Split of CChooseMachinePropPage
//					to allow property pages to have more flexible dialog
//					templates.
//
class CAutoDeletePropPage : public CPropertyPage
{
public:
// Construction
	CAutoDeletePropPage(UINT uIDD);
	virtual ~CAutoDeletePropPage();

protected:
// Dialog Data
	//{{AFX_DATA(CAutoDeletePropPage)
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAutoDeletePropPage)
	virtual BOOL OnSetActive();
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CAutoDeletePropPage)
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// This mechanism deletes the CAutoDeletePropPage object
	// when the wizard is finished
	struct
		{
		INT cWizPages;	// Number of pages in wizard
		LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
		} m_autodeleteStuff;

	static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);


protected:
	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
	
public:
	/////////////////////////////////////////////////////////////////////	
	void SetCaption(UINT uStringID);
	void SetCaption(LPCTSTR pszCaption);
	void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);
}; // CAutoDeletePropPage


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CChooseMachinePropPage
//
//	This object is a stand-alone property page used to
//	select a computer name.
//
//	The object CChooseMachinePropPage can have its dialog
//	template replaced to allow a new wizard without any new code.
//	The object can also be inherited, allowing easy extentionability.
//
//	RESTRICTIONS:
//	If the user wishes to provide its own dialog template, here
//	are the dialog IDs that must present:
//		IDC_CHOOSER_RADIO_LOCAL_MACHINE - Select local machine.
//		IDC_CHOOSER_RADIO_SPECIFIC_MACHINE - Select a specific machine.
//		IDC_CHOOSER_EDIT_MACHINE_NAME - Edit field to enter the machine name.
//	There are also optional IDs:
//		IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES - Browse to select a machine name.
//		IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME - Checkbox to allow the machine name to be overriden by command line.
//
class CChooseMachinePropPage : public CAutoDeletePropPage
{
public:
	enum { IID_DEFAULT = IDD_CHOOSER_CHOOSE_MACHINE };

public:
// Construction
	CChooseMachinePropPage(UINT uIDD = IID_DEFAULT);
	virtual ~CChooseMachinePropPage();

protected:
	void InitRadioButtons();

// Dialog Data
	//{{AFX_DATA(CChooseMachinePropPage)
	enum { IDD = IDD_CHOOSER_CHOOSE_MACHINE };
	BOOL m_fIsRadioLocalMachine;		// TRUE => Local Machine is selected
	BOOL m_fAllowOverrideMachineName;	// TRUE => Machine name can be overriden from command line
	CString	m_strMachineName;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChooseMachinePropPage)
	public:
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChooseMachinePropPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioLocalMachine();
	afx_msg void OnRadioSpecificMachine();
	afx_msg void OnChooserButtonBrowseMachinenames();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
	HWND m_hwndCheckboxOverride;

protected:
	BOOL * m_pfAllowOverrideMachineNameOut;	// OUT: Pointer to BOOL receiving flag wherever to override machine name
	CString * m_pstrMachineNameOut;	// OUT: Pointer to the CString object to store the machine name
	CString * m_pstrMachineNameEffectiveOut;	// OUT: Pointer to the CString object to store the effective machine name

public:
	void InitMachineName(LPCTSTR pszMachineName);
	void SetOutputBuffers(
		OUT CString * pstrMachineNamePersist,
		OUT OPTIONAL BOOL * pfAllowOverrideMachineName,
		OUT OPTIONAL CString * pstrMachineNameEffective);

}; // CChooseMachinePropPage


#endif // ~__CHOOSER_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\chooser\chooser2.cpp ===
//
// JonN 12/6/99 created
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000
//

#include <windows.h>
#include <windowsx.h>
#include <lmcons.h>
#include <atlbase.h>
#include <objsel.h>
#include "chooser2.h"
#include <lmserver.h> // NetServerGetInfo JonN 2002/04/08 585301
#include <lmapibuf.h> // NetApiBufferFree JonN 2002/04/08 585301

//+--------------------------------------------------------------------------
//
//  Function:   CHOOSER2_InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Created
//              12-08-1999   JonN       Copied from CHOOSER
//
//---------------------------------------------------------------------------

// ISSUE-2002/03/28-JonN Combine this with identical method in chooser.cpp
HRESULT CHOOSER2_InitObjectPickerForComputers(
    IDsObjectPicker *pDsObjectPicker)
{
	if ( !pDsObjectPicker )
		return E_POINTER;

	//
	// Prepare to initialize the object picker.
	// Set up the array of scope initializer structures.
	//

	static const int SCOPE_INIT_COUNT = 2;
	DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

	ZeroMemory(aScopeInit, sizeof(aScopeInit)); // JonN 3/28/02

	//
	// 127399: JonN 10/30/00 JOINED_DOMAIN should be starting scope
	//

	aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
	                     | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
	aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
	aScopeInit[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
	aScopeInit[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
	                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
	                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
	                     | DSOP_SCOPE_TYPE_WORKGROUP
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
	                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
	aScopeInit[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
	aScopeInit[1].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

	//
	// Put the scope init array into the object picker init array
	//

	DSOP_INIT_INFO  initInfo;
	ZeroMemory(&initInfo, sizeof(initInfo));

	initInfo.cbSize = sizeof(initInfo);
	initInfo.pwzTargetComputer = NULL;  // NULL == local machine
	initInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
	initInfo.aDsScopeInfos = aScopeInit;
	initInfo.cAttributesToFetch = 1;
	static PCWSTR pwszDnsHostName = L"dNSHostName";
	initInfo.apwzAttributeNames = &pwszDnsHostName;

	//
	// Note object picker makes its own copy of initInfo.  Also note
	// that Initialize may be called multiple times, last call wins.
	//

	return pDsObjectPicker->Initialize(&initInfo);
}

//+--------------------------------------------------------------------------
//
//  Function:   CHOOSER2_ProcessSelectedObjects
//
//  Synopsis:   Retrieve the name of the selected item from the data object
//              created by the object picker
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Created
//              12-08-1999   JonN       Copied from CHOOSER
//
//---------------------------------------------------------------------------

// ISSUE-2002/03/28-JonN Combine this with identical method in chooser.cpp
HRESULT CHOOSER2_ProcessSelectedObjects(
    IDataObject* pdo,
    BSTR* pbstrComputerName)
{
	if ( !pdo )
		return E_POINTER;

	HRESULT hr = S_OK;
	static UINT g_cfDsObjectPicker =
		RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

	STGMEDIUM stgmedium =
	{
		TYMED_HGLOBAL,
		NULL,
		NULL
	};

	FORMATETC formatetc =
	{
		(CLIPFORMAT)g_cfDsObjectPicker,
		NULL,
		DVASPECT_CONTENT,
		-1,
		TYMED_HGLOBAL
	};

	bool fGotStgMedium = false;

	do
	{
		hr = pdo->GetData(&formatetc, &stgmedium);
		if ( SUCCEEDED (hr) )
		{
			fGotStgMedium = true;

			PDS_SELECTION_LIST pDsSelList =
				(PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

			if (!pDsSelList)
			{
				hr = HRESULT_FROM_WIN32 (GetLastError());
				break;
			}

			if ( 1 == pDsSelList->cItems )
			{
				PDS_SELECTION psel = &(pDsSelList->aDsSelection[0]);
				// ISSUE-2002/03/28-JonN check for NULL == psel
				VARIANT* pvarDnsName = &(psel->pvarFetchedAttributes[0]);
				if (   NULL == pvarDnsName
				    || VT_BSTR != pvarDnsName->vt
				    || NULL == pvarDnsName->bstrVal
				    || L'\0' == (pvarDnsName->bstrVal)[0] )
				{
					*pbstrComputerName = SysAllocString(
					    psel->pwzName);
				} else {
					*pbstrComputerName = SysAllocString(
					    pvarDnsName->bstrVal);

					//
					// JonN 2002/04/08 585301
					// Computer management snapin only attempts to use the DnsHostName
					// to connect to a remote computer, even when the dns name
					// is not valid
					//
					// Bank of America encounters a problem because they
					// set RegisterDnsARecord to 1, turning off client DNS
					// records.  The dnsHostName is therefore not a valid
					// binding name.  The fix is to test the dnsHostName.
					//
					LPBYTE pbDummy = NULL;
					NET_API_STATUS err = NetServerGetInfo(
						pvarDnsName->bstrVal, 101, &pbDummy );
					if (pbDummy)
					{
						NetApiBufferFree( pbDummy );
						pbDummy = NULL;
					}
					if (NERR_Success != err)
					{
						err = NetServerGetInfo( psel->pwzName, 101, &pbDummy );
						if (pbDummy)
						{
							NetApiBufferFree( pbDummy );
							pbDummy = NULL;
						}
						if (NERR_Success == err)
						{
							if (NULL != *pbstrComputerName)
							{
								::SysFreeString( *pbstrComputerName );
							}
							*pbstrComputerName = SysAllocString(
							    psel->pwzName);
						}
					}
					// end new code: JonN 2002/04/08 585301

				}
			}
			else
				hr = E_UNEXPECTED;
			

			GlobalUnlock(stgmedium.hGlobal);
		}
	} while (0);

	if (fGotStgMedium)
	{
		ReleaseStgMedium(&stgmedium);
	}

	return hr;
}


///////////////////////////////////////////////////////////////////////////////
// Generic method for launching a single-select computer picker
//
//	Paremeters:
//		hwndParent (IN)	- window handle of parent window
//		computerName (OUT) - computer name returned
//
//	Returns S_OK if everything succeeded, S_FALSE if user pressed "Cancel"
//		
//  History:    12-08-1999   JonN       Copied from CHOOSER
//
//////////////////////////////////////////////////////////////////////////////
HRESULT	CHOOSER2_ComputerNameFromObjectPicker (
    HWND hwndParent,
    BSTR* pbstrTargetComputer)
{
	//
	// Create an instance of the object picker.  The implementation in
	// objsel.dll is apartment model.
	//
	CComPtr<IDsObjectPicker> spDsObjectPicker;
	HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
	                              NULL,
	                              CLSCTX_INPROC_SERVER,
	                              IID_IDsObjectPicker,
	                              (void **) &spDsObjectPicker);
	if ( SUCCEEDED (hr) )
	{
		//
		// Initialize the object picker to choose computers
		//

		hr = CHOOSER2_InitObjectPickerForComputers(spDsObjectPicker);
		if ( SUCCEEDED (hr) )
		{
			//
			// Now pick a computer
			//
			CComPtr<IDataObject> spDataObject;

			hr = spDsObjectPicker->InvokeDialog(
                hwndParent,
                &spDataObject);
			if ( S_OK == hr )
			{
				hr = CHOOSER2_ProcessSelectedObjects(
                    spDataObject,
                    pbstrTargetComputer);
			}
		}
	}

	return hr;
}


const ULONG g_aHelpIDs_CHOOSER2[]=
{
	IDC_CHOOSER2_RADIO_LOCAL_MACHINE,	IDC_CHOOSER2_RADIO_LOCAL_MACHINE,
	IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE,	IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE,
	IDC_CHOOSER2_EDIT_MACHINE_NAME,	IDC_CHOOSER2_EDIT_MACHINE_NAME,
	IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES,	IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES,
	IDD_CHOOSER2,	(ULONG)-1,
	0, 0
};


INT_PTR CALLBACK CHOOSER2_TargetComputerDialogFunc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            Edit_LimitText(
                GetDlgItem(hwndDlg,IDC_CHOOSER2_EDIT_MACHINE_NAME),
                MAX_PATH+2);

            // lParam is pbstrTargetComputer
            BSTR* pbstrTargetComputer = (BSTR*)lParam;
            (void) SetWindowLongPtr(
                hwndDlg,
                DWLP_USER,
                (LONG_PTR)pbstrTargetComputer );
            (void) SendMessage(
                GetDlgItem(hwndDlg,IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE),
                BM_SETCHECK,
                BST_CHECKED,
                0 );
            (void) SetFocus(
                GetDlgItem(hwndDlg,IDC_CHOOSER2_EDIT_MACHINE_NAME));
        }
        break;
    case WM_COMMAND:
            switch (LOWORD(wParam))
            {
            case IDOK:
                if (BST_CHECKED == IsDlgButtonChecked(
                        hwndDlg,
                        IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE ))
                {
                    WCHAR achTarget[MAX_PATH+3]; // allow for whackwhack
                    ZeroMemory( achTarget, sizeof(achTarget) );
                    GetDlgItemText(
                        hwndDlg,
                        IDC_CHOOSER2_EDIT_MACHINE_NAME,
                        achTarget,
                        MAX_PATH+2);
                    BSTR* pbstrTargetComputer =
                        (BSTR*)GetWindowLongPtr( hwndDlg, DWLP_USER );
                    LPCWSTR pcszTargetComputer = achTarget;
                    while (L'\\' == *pcszTargetComputer)
                        pcszTargetComputer++;
                    if (L'\0' != *pcszTargetComputer)
                        *pbstrTargetComputer = SysAllocString(pcszTargetComputer);
                }
                EndDialog( hwndDlg, 1 );
                break;
            case IDCANCEL:
                EndDialog( hwndDlg, 0 );
                break;
            case IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES:
                {
                    CComBSTR sbstrTargetComputer;
                    HRESULT hr = CHOOSER2_ComputerNameFromObjectPicker(
                        hwndDlg,
                        &sbstrTargetComputer );
                    if ( SUCCEEDED(hr) )
                    {
                        LPCWSTR pcszTargetComputer =
                            (!sbstrTargetComputer)
                                ? NULL
                                : (LPCWSTR)sbstrTargetComputer;
                        SetDlgItemText(
                            hwndDlg,
                            IDC_CHOOSER2_EDIT_MACHINE_NAME,
                            pcszTargetComputer );
                    }
                }
                break;
            case IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE:
            case IDC_CHOOSER2_RADIO_LOCAL_MACHINE:
                // 671670-2002/07/25-JonN use IsDlgButtonChecked
                (void) EnableWindow(
                    GetDlgItem(hwndDlg,IDC_CHOOSER2_EDIT_MACHINE_NAME),
                    (IsDlgButtonChecked(hwndDlg, IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE))
                        ? TRUE
                        : FALSE );
                (void) EnableWindow(
                    GetDlgItem(hwndDlg,
                               IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES),
                    (IsDlgButtonChecked(hwndDlg, IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE))
                        ? TRUE
                        : FALSE );
                break;
            default:
                break;
            }
        break;
    case WM_HELP:
        if (NULL != lParam)
        {
            const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;
            // ISSUE-2002/03/28-JonN check pHelpInfo for NULL
            if (pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
                const HWND hwnd = (HWND)pHelpInfo->hItemHandle;
                (void) WinHelp(
                    hwnd,
                    _T("chooser.hlp"),
                    HELP_WM_HELP,
                    (ULONG_PTR)g_aHelpIDs_CHOOSER2);
            }
        }
        break;
    default:
        break;
    }
    return FALSE;
}
 

bool CHOOSER2_PickTargetComputer(
    IN  HINSTANCE hinstance,
    IN  HWND hwndParent,
    OUT BSTR* pbstrTargetComputer )
{
    if (NULL == pbstrTargetComputer)
        return false;
    INT_PTR nReturn = ::DialogBoxParam(
        hinstance,
        MAKEINTRESOURCE(IDD_CHOOSER2),
        hwndParent,
        CHOOSER2_TargetComputerDialogFunc,
        (LPARAM)pbstrTargetComputer );
    return (0 < nReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\chooser\chooser2.h ===
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-2000

//+--------------------------------------------------------------------------
//
//  Function:   CHOOSER2_PickTargetComputer
//
//  Synopsis:   Bring up a standard dialog which allows users to
//              select a target computer.
//
//  Arguments:  pbstrTargetComputer - pointer to return value
//
//  Returns:    true -> OK, false -> Cancel
//
//  History:    12-06-1999   JonN       Created
//
//---------------------------------------------------------------------------


#define IDD_CHOOSER2                             5000
#define IDC_CHOOSER2_RADIO_LOCAL_MACHINE         5001
#define IDC_CHOOSER2_RADIO_SPECIFIC_MACHINE      5002
#define IDC_CHOOSER2_EDIT_MACHINE_NAME           5003
#define IDC_CHOOSER2_BUTTON_BROWSE_MACHINENAMES  5004

bool CHOOSER2_PickTargetComputer(
    IN  HINSTANCE hinstance,
    IN  HWND hwndParent,
    OUT BSTR* pbstrTargetComputer );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\chooser\chooserd.h ===
// chooserd.h - Contains default resource IDs for chooser.rc
//
// HISTORY
// 26-May-1997	t-danm		Creation.
//

//
// The _CHOOSER_BASE_RESOURCE_ID is there to allow relocatable resource IDs
//
#ifndef _CHOOSER_BASE_RESOURCE_ID
	#define _CHOOSER_BASE_RESOURCE_ID	970	// Arbitrary chosen
#endif

// Dialog ID
#ifndef IDD_CHOOSER_CHOOSE_MACHINE
	#define IDD_CHOOSER_CHOOSE_MACHINE 		_CHOOSER_BASE_RESOURCE_ID
#endif

// Dialog Controls
#ifndef IDC_CHOOSER_STATIC
	#define IDC_CHOOSER_STATIC						(_CHOOSER_BASE_RESOURCE_ID+0)
	#define IDC_CHOOSER_GROUP_TARGET_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+1)
	#define IDC_CHOOSER_RADIO_LOCAL_MACHINE			(_CHOOSER_BASE_RESOURCE_ID+2)
	#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+3)
	#define IDC_CHOOSER_EDIT_MACHINE_NAME			(_CHOOSER_BASE_RESOURCE_ID+4)
	#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES	(_CHOOSER_BASE_RESOURCE_ID+5)
	#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME (_CHOOSER_BASE_RESOURCE_ID+6)
#endif

// Strings
#ifndef IDS_CHOOSER_INVALID_COMPUTERNAME
	#define IDS_CHOOSER_INVALID_COMPUTERNAME		(_CHOOSER_BASE_RESOURCE_ID+0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\chooser\choosert.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chooser.rc
//
#define IDS_SELECT_COMPUTER             971
#define IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR 972

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\assert.cpp ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------


#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>
#include <shlwapi.h> // wvnsprintf

#if DBG==1

#define new DEBUG_NEW

#include "admindbg.h"
#include "malloc.h" // alloca
#include "stddbg.h" // VERIFY
#include "macros.h" // ARRAYLEN
#include "strsafe.h" // StringCchPrintf

//
//  Globals
//

ULONG AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//
//  Forward declaration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
int   w4dprintf(LPTSTR format, ...);
int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

int w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

int w4smprintf(LPTSTR  format, va_list arglist)
{
    TCHAR szMessageBuf[500];        // this is the message buffer
    int ret;

    ret = wvnsprintf(szMessageBuf, 500, format, arglist);
    OutputDebugString(szMessageBuf);
    return ret;
}


//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void smprintf(ULONG ulCompMask, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        (ulCompMask | (DEB_ERROR | DEB_WARN)))
    {
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if (((DEB_ERROR | DEB_WARN) & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
            }
            w4smprintf(ppszfmt, pargs);
        }
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

#define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
#define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADMINDEBUGKEY, 0,
                                            KEY_ALL_ACCESS, &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                                                    KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                   REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                                (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            *pulInfoLevel = (DEB_ERROR | DEB_WARN);

            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                        (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}


// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath)) {
        if ((pPath[0] == '\\' || pPath[0] == ':')
                            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return (LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static CHAR szModuleName[128];
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    // 591438-2002/04/05 JonN removed wsprintf
	//   "%hs" is short-string
    VERIFY( SUCCEEDED( StringCchPrintf(szAssertCaption,
                                       ARRAYLEN(szAssertCaption),
                                       _T("%hs: Assertion Failed"),
                                       pProcess) ) );


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    // 591438-2002/04/05 JonN removed wsprintf
    VERIFY( SUCCEEDED( StringCchPrintf(
                        szDetails,
                        ARRAYLEN(szDetails),
                        _T(" Assertion:\t %s\n\n")       \
                        _T(" File:   \t\t %hs\n")        \
                        _T(" Line:   \t\t %d\n\n")       \
                        _T(" Module:   \t %hs\n")        \
                        _T(" Thread ID:\t %d.%d\n"),
                        szMsg, szFile, iLine, pszModuleName, pid, tid) ) );


    int id = MessageBox(NULL,
                    szDetails,
                    szAssertCaption,
                    MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                                | MB_TASKMODAL
                                | MB_ICONEXCLAMATION
                                | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
            szMessage, pszFileName, iLine, tid);
    }

    if (AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (AdminAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________

CDbg::CDbg(LPTSTR  str)
    :
    m_InfoLevelString(str),
    m_InfoLevel(DEB_ERROR | DEB_WARN)
{
    CheckInit(m_InfoLevelString, &m_InfoLevel);
}

void CDbg::Trace(LPSTR pszfmt, ...)
{
#ifdef UNICODE
    size_t convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, (int) convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::Trace(LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    // NTRAID#NTBUG9-590026-2002/03/29 JonN I am not confident in this
    //   translation code, since the MBCS string will often have more
    //   characters than the UNICODE string.  However, this code is
    //   restricted to non-UNICODE snapins so it isn't too relevant.
    size_t convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, (int) convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    size_t convert = strlen(pszfmt) + 1;
    LPTSTR ptcfmt = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, (int) convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugOut(ULONG fDebugMask, LPWSTR pwszfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwszfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwszfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwszfmt;
#endif

    if (m_InfoLevel & fDebugMask)
    {
        va_list va;
        va_start (va, pwszfmt);
        smprintf(DEB_TRACE, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                                                      err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_InfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    ptcMsg = (LPWSTR)alloca(convert * sizeof(WCHAR));
    ptcMsg[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}


#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);

    void Trace(LPWSTR pszfmt, ...);
    void Trace(LPSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPWSTR pszfmt, ...);
    void DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, LPWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

private:
    unsigned long   m_InfoLevel; // must be the first data member
    LPTSTR          m_InfoLevelString;

};  // class CDbg


#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined
#define DEB_USER8           0x00800000      // User defined
#define DEB_USER9           0x01000000      // User defined
#define DEB_USER10          0x02000000      // User defined
#define DEB_USER11          0x04000000      // User defined
#define DEB_USER12          0x08000000      // User defined
#define DEB_USER13          0x10000000      // User defined
#define DEB_USER14          0x20000000      // User defined
#define DEB_USER15          0x40000000      // User defined

#define DEB_NOCOMPNAME      0x80000000      // suppress component name

#define DEB_FORCE           0x7fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\comptr.h ===
#ifndef COMPTR_H
#define COMPTR_H
#if _MSC_VER >= 1100
#pragma warning(disable:4800)
#include <comdef.h>
#define CIP_RETYPEDEF(I) typedef I##Ptr I##CIP;
#define CIP_TYPEDEF(I) _COM_SMARTPTR_TYPEDEF(I, IID_##I); CIP_RETYPEDEF(I);
#define DEFINE_CIP(x)\
	CIP_TYPEDEF(x)

#define DECLARE_CIP(x) DEFINE_CIP(x) x##CIP

CIP_RETYPEDEF(IUnknown);
CIP_RETYPEDEF(IDataObject);
CIP_RETYPEDEF(IStorage);
CIP_RETYPEDEF(IStream);
CIP_RETYPEDEF(IPersistStorage);
CIP_RETYPEDEF(IPersistStream);
CIP_RETYPEDEF(IPersistStreamInit);
CIP_RETYPEDEF(IDispatch);

#else // _MSC_VER < 1100

#define USE_OLD_COMPILER (_MSC_VER<1100)
#define USE_INTERMEDIATE_COMPILER (USE_OLD_COMPILER && (_MSC_VER>1020))

// This avoids "warning C4290: C++ Exception Specification ignored"
// JonN 12/16/96
#pragma warning(4:4290)

#ifndef BOOL_H
#include <bool.h>
#endif
#ifndef __wtypes_h__
#include <wtypes.h>
#endif

template<typename _Interface, const IID* _IID/*=&__uuidof(_Interface)*/>
	class CIID
	// Provide Interface to IID association
	{
	public: typedef _Interface Interface;

	public: static _Interface* GetInterfacePtr() throw()
			{
			return NULL;
			}

	public: static _Interface& GetInterface() throw()
			{
			return *GetInterfacePtr();
			}

	public: static const IID& GetIID() throw()
			{
			return *_IID;
			}
	}; // class CIID

template<typename _CIID> class CIP
	{
	#if USE_OLD_COMPILER
	private: class _IUnknown: public IUnknown {};
		// Unique type used to provide for operations between different pointer
		// types.
	#endif // USE_OLD_COMPILER

	// Declare interface type so that the type may be available outside
	// the scope of this template.
	public: typedef _CIID ThisCIID;
	public: typedef _CIID::Interface Interface;

	public: static const IID& GetIID() throw()
		// When the compiler supports references in template params,
		// _CLSID will be changed to a reference.  To avoid conversion
		// difficulties this function should be used to obtain the
		// CLSID.
		{
		return ThisCIID::GetIID();
		}

	//REVIEW: add support for assignment of nonpointer interfaces
	// i.e. IUnknown, instead of simple IUnknown*

	public: CIP()  throw()
		// Construct empty in preperation for assignment.
		: _pInterface(NULL)
		{
		}

	public: CIP(int null) throw()
		// This constructor is provided to allow NULL assignment.  It will assert
		// if any value other than null is assigned to the object.
		: _pInterface(NULL)
		{
		ASSERT(!null);
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	template<typename _InterfacePtr> CIP(_InterfacePtr p) throw()
		// Queries for this interface.
	#else
	public: CIP(_IUnknown& p) throw()
		: _pInterface(NULL)
		{
		if (&p)
			{
			const HRESULT hr = _QueryInterface(&p);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			}
		else _pInterface = NULL;
		}

	public: CIP(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		: _pInterface(NULL)
		{
		if (p)
			{
			const HRESULT hr = _QueryInterface(p);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			}
		else _pInterface = NULL;
		}

	public: CIP(const CIP& cp)  throw()
		// Copy the pointer and AddRef().
		: _pInterface(cp._pInterface)
		{
		_AddRef();
		}

	public: CIP(Interface* pInterface)  throw()
		// Saves the interface
		: _pInterface(pInterface)
		{
		_AddRef();
		}

	public: CIP(Interface* pInterface, bool bAddRef) throw()
		// Copies the pointer.  If bAddRef is TRUE, the interface will
		// be AddRef()ed.
		: _pInterface(pInterface)
		{
		if (bAddRef)
			{
			ASSERT(!pInterface);
			if (pInterface)
				_AddRef();
			}
		}

	public: CIP(const CLSID& clsid, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		// Calls CoCreateClass with the provided CLSID.
		: _pInterface(NULL)
		{
		const HRESULT hr = CreateInstance(clsid, dwClsContext);
		ASSERT(SUCCEEDED(hr));
		}

	public: CIP(LPOLESTR str, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		// Calls CoCreateClass with the provided CLSID retrieved from
		// the string.
		: _pInterface(NULL)
		{
		const HRESULT hr = CreateInstance(str, dwClsContext);
		ASSERT(SUCCEEDED(hr));
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> CIP& operator=(_InterfacePtr& p) throw()
		// Queries for interface.
	#else
	public: CIP& operator=(_IUnknown& p) throw()
		{
		return operator=(static_cast<IUnknown*>(&p));
		}

	public: CIP& operator=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		const HRESULT hr = _QueryInterface(p);
		ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
		return *this;
		}

	public: CIP& operator=(Interface* pInterface) throw()
		// Saves the interface.
		{
		if (_pInterface != pInterface)
			{
			Interface* pOldInterface = _pInterface;
			_pInterface = pInterface;
			_AddRef();
			if (pOldInterface)
				pOldInterface->Release();
			}
		return *this;
		}

	public: CIP& operator=(const CIP& cp) throw()
		// Copies and AddRef()'s the interface.
		{
		return operator=(cp._pInterface);
		}

	public: CIP& operator=(int null) throw()
		// This operator is provided to permit the assignment of NULL to the class.
		// It will assert if any value other than NULL is assigned to it.
		{
		ASSERT(!null);
		return operator=(reinterpret_cast<Interface*>(NULL));
		}

	public: ~CIP() throw()
		// If we still have an interface then Release() it.  The interface
		// may be NULL if Detach() has previosly been called, or if it was
		// never set.
		{
		_Release();
		}

	public: void Attach(Interface* pInterface) throw()
		// Saves/sets the interface without AddRef()ing.  This call
		// will release any previously aquired interface.
		{
		_Release();
		_pInterface = pInterface;
		}

	public: void Attach(Interface* pInterface, bool bAddRef) throw()
		// Saves/sets the interface only AddRef()ing if bAddRef is TRUE.
		// This call will release any previously aquired interface.
		{
		_Release();
		_pInterface = pInterface;
		if (bAddRef)
			{
			ASSERT(pInterface);
			if (pInterface)
				pInterface->AddRef();
			}
		}

	public: Interface* Detach() throw()
		// Simply NULL the interface pointer so that it isn't Released()'ed.
		{
		Interface* const old=_pInterface;
		_pInterface = NULL;
		return old;
		}

	public: operator Interface*() const throw()
		// Return the interface.  This value may be NULL
		{
		return _pInterface;
		}

	public: Interface& operator*() const throw()
		// Allows an instance of this class to act as though it were the
		// actual interface.  Also provides minimal assertion verification.
		{
		ASSERT(_pInterface);
		return *_pInterface;
		}

	public: Interface** operator&() throw()
		// Returns the address of the interface pointer contained in this
		// class.  This is useful when using the COM/OLE interfaces to create
		// this interface.
		{
		_Release();
		_pInterface = NULL;
		return &_pInterface;
		}

	public: Interface* operator->() const throw()
		// Allows this class to be used as the interface itself.
		// Also provides simple assertion verification.
		{
		ASSERT(_pInterface);
		return _pInterface;
		}

	public: operator bool() const throw()
		// This operator is provided so that simple boolean expressions will
		// work.  For example: "if (p) ...".
		// Returns TRUE if the pointer is not NULL.
		{
		return _pInterface;
		}

	public: bool operator!() throw()
		// Returns TRUE if the interface is NULL.
		// This operator will be removed when support for type bool
		// is added to the compiler.
		{
		return !_pInterface;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator==(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator==(_IUnknown& p) throw()
		{
		return operator==(static_cast<IUnknown*>(&p));
		}

	public: bool operator==(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return !_CompareUnknown(p);
		}

	public: bool operator==(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface == p) ? true : !_CompareUnknown(p);
		}

	public: bool operator==(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator==(p._pInterface);
		}

	public: bool operator==(int null) throw()
		// For comparison to NULL
		{
		ASSERT(!null);
		return !_pInterface;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator!=(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator!=(_IUnknown& p) throw()
		{
		return operator!=(static_cast<IUnknown*>(&p));
		}

	public: bool operator!=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p);
		}

	public: bool operator!=(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface!=p)?true:_CompareUnknown(p);
		}

	public: bool operator!=(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator!=(p._pInterface);
		}

	public: bool operator!=(int null) throw()
		// For comparison to NULL
		{
		ASSERT(!null);
		return _pInterface;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator<(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator<(_IUnknown& p) throw()
		{
		return operator<(static_cast<IUnknown*>(&p));
		}

	public: bool operator<(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p)<0;
		}

	public: bool operator<(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface<p) ? true : _CompareUnknown(p) < 0;
		}

	public: bool operator<(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator<(p._pInterface);
		}

	public: bool operator<(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface<NULL;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator>(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator>(_IUnknown& p) throw()
		{
		return operator>(static_cast<IUnknown*>(&p));
		}

	public: bool operator>(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p) > 0;
		}

	public: bool operator>(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface>p) ? true : _CompareUnknown(p) > 0;
		}

	public: bool operator>(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator>(p._pInterface);
		}

	public: bool operator>(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface > NULL;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator<=(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator<=(_IUnknown& p) throw()
		{
		return operator<=(static_cast<IUnknown*>(&p));
		}

	public: bool operator<=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p)<=0;
		}

	public: bool operator<=(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface<=p) ? true : _CompareUnknown(p) <= 0;
		}

	public: bool operator<=(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator<=(p._pInterface);
		}

	public: bool operator<=(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface <= NULL;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfacePtr> bool operator>=(_InterfacePtr p) throw()
		// Compare to pointers
	#else
	public: bool operator>=(_IUnknown& p) throw()
		{
		return operator>=(static_cast<IUnknown*>(&p));
		}

	public: bool operator>=(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _CompareUnknown(p) >= 0;
		}

	public: bool operator>=(Interface* p) throw()
		// Compare with other interface
		{
		return (_pInterface>=p) ? true : _CompareUnknown(p) >= 0;
		}

	public: bool operator>=(CIP& p) throw()
		// Compares 2 CIPs
		{
		return operator>=(p._pInterface);
		}

	public: bool operator>=(int null) throw()
		// For comparison with NULL
		{
		ASSERT(!null);
		return _pInterface >= NULL;
		}

	#if USE_OLD_COMPILER
	public: operator _IUnknown&() const throw()
		// Provided for casts between different pointer types.
		{
		return *reinterpret_cast<_IUnknown*>(static_cast<IUnknown*>(_pInterface));
		}
	#endif // USE_OLD_COMPILER

	public: void Release() throw()
		// Provides assertion verified, Release()ing of this interface.
		{
		ASSERT(_pInterface);
		if (_pInterface)
			{
			_pInterface->Release();
			_pInterface = NULL;
			}
		}

	public: void AddRef() throw()
		// Provides assertion verified AddRef()ing of this interface.
		{
		ASSERT(_pInterface);
		if (_pInterface)
			_pInterface->AddRef();
		}

	public: Interface* GetInterfacePtr() const throw()
		// Another way to get the interface pointer without casting.
		{
		return _pInterface;
		}

	public: HRESULT CreateInstance(
		const CLSID& clsid, DWORD dwClsContext=CLSCTX_ALL) throw()
		// Loads an interface for the provided CLSID.
		// Returns an HRESULT.  Any previous interface is released.
		{
		_Release();
		const HRESULT hr = CoCreateInstance(clsid, NULL, dwClsContext,
			GetIID(), reinterpret_cast<void**>(&_pInterface));
		ASSERT(SUCCEEDED(hr));
		return hr;
		}

	public: HRESULT CreateInstance(
		LPOLESTR clsidString, DWORD dwClsContext=CLSCTX_ALL) throw()
		// Creates the class specified by clsidString.  clsidString may
		// contain a class id, or a prog id string.
		{
		// ISSUE-2002/03/29-JonN Should handle NULL case
		ASSERT(clsidString);
		CLSID clsid;
		HRESULT hr;
		if (clsidString[0] == '{')
			hr = CLSIDFromString(clsidString, &clsid);
		else
			hr = CLSIDFromProgID(clsidString, &clsid);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		return CreateInstance(clsid, dwClsContext);
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType*& p) throw()
		// Perfoms the QI for the specified IID and returns it in p.
		// As with all QIs, the interface will be AddRef'd.
	#else
	public: HRESULT QueryInterface(const IID& iid, IUnknown*& p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return _pInterface ?
			_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p)) :
			E_NOINTERFACE;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfaceType> HRESULT QueryInterface(const IID& iid, _InterfaceType** p) throw()
		// Perfoms the QI for the specified IID and returns it in p.
		// As with all QIs, the interface will be AddRef'd.
	#else
	public: HRESULT QueryInterface(const IID& iid, IUnknown** p) throw()
	#endif // !USE_OLD_COMPILER
		{
		return QueryInterface(iid, *p);
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	public: template<typename _InterfaceType> _InterfaceType* QueryInterface(const IID& iid) throw()
		// Perfoms the QI for the specified IID and returns it.
		// As with all QIs, the interface will be AddRef'd.
	#else
	public: IUnknown* QueryInterface(const IID& iid) throw()
	#endif // !USE_OLD_COMPILER
		{
		#if USE_OLD_COMPILER
		typedef IUnknown _InterfaceType;
		#endif // USE_OLD_COMPILER
		_InterfaceType* pInterface;
		QueryInterface(iid, pInterface);
		return pInterface;
		}

	private: Interface* _pInterface;
		// The Interface.

	private: void _Release() throw()
		// Releases only if the interface is not null.
		// The interface is not set to NULL.
		{
		if (_pInterface)
			_pInterface->Release();
		}

	private: void _AddRef() throw()
		// AddRefs only if the interface is not NULL
		{
		if (_pInterface)
			_pInterface->AddRef();
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	private: template<typename _InterfacePtr> HRESULT _QueryInterface(_InterfacePtr p) throw()
		// Performs a QI on pUnknown for the interface type returned
		// for this class.  The interface is stored.  If pUnknown is
		// NULL, or the QI fails, E_NOINTERFACE is returned and
		// _pInterface is set to NULL.
	#else
	private: HRESULT _QueryInterface(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		if (!p) // Can't QI NULL
			{
			operator=(static_cast<Interface*>(NULL));
			return E_NOINTERFACE;
			}

		// Query for this interface
		Interface* pInterface;
		const HRESULT hr = p->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		if (FAILED(hr))
			{
			// If failed intialize interface to NULL and return HRESULT.
			Attach(NULL);
			return hr;
			}

		// Save the interface without AddRef()ing.
		Attach(pInterface);
		return hr;
		}

	#if !USE_OLD_COMPILER //REVIEW: remove after v5
	private: template<typename _InterfacePtr> int _CompareUnknown(_InterfacePtr& p) throw()
		// Compares the provided pointer with this by obtaining IUnknown interfaces
		// for each pointer and then returning the difference.
	#else
	private: int _CompareUnknown(IUnknown* p) throw()
	#endif // !USE_OLD_COMPILER
		{
		IUnknown* pu1;
		if (_pInterface)
			{
			const HRESULT hr = QueryInterface(IID_IUnknown, pu1);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu1)
				pu1->Release();
			}
		else pu1=NULL;

		IUnknown* pu2;
		if (p)
			{
			const HRESULT hr = p->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&pu2));
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu2)
				pu2->Release();
			}
		else pu2 = NULL;
		return pu1 - pu2;
		}
	}; // class CIP

// Reverse comparison operators for CIP
template<typename _Interface> bool operator==(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p == NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator==(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p == i;
	}

template<typename _Interface> bool operator!=(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p != NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator!=(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p != i;
	}

template<typename _Interface> bool operator<(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p < NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator<(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p < i;
	}

template<typename _Interface> bool operator>(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p > NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator>(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p > i;
	}

template<typename _Interface> bool operator<=(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p <= NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator<=(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p <= i;
	}

template<typename _Interface> bool operator>=(int null, CIP<_Interface>& p)
	{
	ASSERT(!null);
	return p >= NULL;
	}

template<typename _Interface, typename _InterfacePtr> bool operator>=(_Interface* i, CIP<_InterfacePtr>& p)
	{
	return p >= i;
	}

#define DEFINE_CIP(x)\
	typedef CIID<x, &IID_##x> x##IID;\
	typedef CIP<x##IID> x##CIP;

#define DECLARE_CIP(x) DEFINE_CIP(x) x##CIP

DEFINE_CIP(IUnknown);

#if USE_OLD_COMPILER
#if USE_INTERMEDIATE_COMPILER
template<>
#endif
class CIP<IUnknownIID>
{
private:
	#if USE_OLD_COMPILER
	// Unique type used to provide for operations between different pointer
	// types.
	class _IUnknown: public IUnknown {};
	#endif // USE_OLD_COMPILER

public:
	// Declare interface type so that the type may be available outside
	// the scope of this template.
	typedef IUnknownIID ThisCIID;
	typedef IUnknown Interface;

	// When the compiler supports references in template params,
	// _CLSID will be changed to a reference.  To avoid conversion
	// difficulties this function should be used to obtain the
	// CLSID.
	static const IID& GetIID() throw()
	{
		return ThisCIID::GetIID();
	}

	// Construct empty in preperation for assignment.
	CIP()  throw()
		: _pInterface(NULL)
	{
	}

	// This constructor is provided to allow NULL assignment.  It will assert
	// if any value other than null is assigned to the object.
	CIP(int null) throw()
		: _pInterface(NULL)
	{
		ASSERT(!null);
	}

	CIP(_IUnknown& p) throw()
		: _pInterface(NULL)
	{
		if (&p)
		{
			const HRESULT hr=_QueryInterface(&p);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
		}
		else _pInterface=NULL;
	}

	// Copy the pointer and AddRef().
	CIP(const CIP& cp)  throw()
		: _pInterface(cp._pInterface)
	{
		_AddRef();
	}

	// Saves the interface
	CIP(Interface* pInterface)  throw()
		: _pInterface(pInterface)
	{
		_AddRef();
	}

	// Copies the pointer.  If bAddRef is TRUE, the interface will
	// be AddRef()ed.
	CIP(Interface* pInterface, bool bAddRef) throw()
		: _pInterface(pInterface)
	{
		if (bAddRef)
		{
			ASSERT(!pInterface);
			_AddRef();
		}
	}

	// Calls CoCreateClass with the provided CLSID.
	CIP(const CLSID& clsid, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		: _pInterface(NULL)
	{
		const HRESULT hr = CreateInstance(clsid, dwClsContext);
		ASSERT(SUCCEEDED(hr));
	}

	// Calls CoCreateClass with the provided CLSID retrieved from
	// the string.
	CIP(LPOLESTR str, DWORD dwClsContext = CLSCTX_ALL) explicit throw()
		: _pInterface(NULL)
	{
		const HRESULT hr = CreateInstance(str, dwClsContext);
		ASSERT(SUCCEEDED(hr));
	}

	CIP& operator=(_IUnknown& p) throw()
	{
		return operator=(static_cast<IUnknown*>(&p));
	}

	// Saves the interface.
	CIP& operator=(Interface* pInterface) throw()
	{
		if (_pInterface != pInterface)
		{
			Interface* pOldInterface = _pInterface;
			_pInterface = pInterface;
			_AddRef();
			if (pOldInterface)
				pOldInterface->Release();
		}
		return *this;
	}

	// Copies and AddRef()'s the interface.
	CIP& operator=(const CIP& cp) throw()
	{
		return operator=(cp._pInterface);
	}

	// This operator is provided to permit the assignment of NULL to the class.
	// It will assert if any value other than NULL is assigned to it.
	CIP& operator=(int null) throw()
	{
		ASSERT(!null);
		return operator=(reinterpret_cast<Interface*>(NULL));
	}

	// If we still have an interface then Release() it.  The interface
	// may be NULL if Detach() has previosly been called, or if it was
	// never set.
	~CIP() throw()
	{
		_Release();
	}

	// Saves/sets the interface without AddRef()ing.  This call
	// will release any previously aquired interface.
	void Attach(Interface* pInterface) throw()
	{
		_Release();
		_pInterface = pInterface;
	}

	// Saves/sets the interface only AddRef()ing if bAddRef is TRUE.
	// This call will release any previously aquired interface.
	void Attach(Interface* pInterface, bool bAddRef) throw()
	{
		_Release();
		_pInterface = pInterface;
		if (bAddRef)
		{
			ASSERT(pInterface);
			if (pInterface)
				pInterface->AddRef();
		}
	}

	// Simply NULL the interface pointer so that it isn't Released()'ed.
	IUnknown* Detach() throw()
	{
		ASSERT(_pInterface);
        IUnknown* const old = _pInterface;
		_pInterface = NULL;
        return old;
	}

	// Return the interface.  This value may be NULL
	operator Interface*() const throw()
	{
		return _pInterface;
	}

	// Queries for the unknown and return it
	// Provides minimal level assertion before use.
	operator Interface&() const throw()
	{
		ASSERT(_pInterface);
		return *_pInterface;
	}

	// Allows an instance of this class to act as though it were the
	// actual interface.  Also provides minimal assertion verification.
	Interface& operator*() const throw()
	{
		ASSERT(_pInterface);
		return *_pInterface;
	}

	// Returns the address of the interface pointer contained in this
	// class.  This is useful when using the COM/OLE interfaces to create
	// this interface.
	Interface** operator&() throw()
	{
		_Release();
		_pInterface = NULL;
		return &_pInterface;
	}

	// Allows this class to be used as the interface itself.
	// Also provides simple assertion verification.
	Interface* operator->() const throw()
	{
		ASSERT(_pInterface);
		return _pInterface;
	}

	// This operator is provided so that simple boolean expressions will
	// work.  For example: "if (p) ...".
	// Returns TRUE if the pointer is not NULL.
	operator bool() const throw()
	{
		return _pInterface;
	}

	// Returns TRUE if the interface is NULL.
	// This operator will be removed when support for type bool
	// is added to the compiler.
	bool operator!() throw()
	{
		return !_pInterface;
	}

	bool operator==(_IUnknown& p) throw()
	{
		return operator==(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator==(Interface* p) throw()
	{
		return (_pInterface==p)?true:!_CompareUnknown(p);
	}

	// Compares 2 CIPs
	bool operator==(CIP& p) throw()
	{
		return operator==(p._pInterface);
	}

	// For comparison to NULL
	bool operator==(int null) throw()
	{
		ASSERT(!null);
		return !_pInterface;
	}

	bool operator!=(_IUnknown& p) throw()
	{
		return operator!=(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator!=(Interface* p) throw()
	{
		return (_pInterface!=p)?true:_CompareUnknown(p);
	}

	// Compares 2 CIPs
	bool operator!=(CIP& p) throw()
	{
		return operator!=(p._pInterface);
	}

	// For comparison to NULL
	bool operator!=(int null) throw()
	{
		ASSERT(!null);
		return _pInterface;
	}

	bool operator<(_IUnknown& p) throw()
	{
		return operator<(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator<(Interface* p) throw()
	{
		return (_pInterface<p)?true:_CompareUnknown(p)<0;
	}

	// Compares 2 CIPs
	bool operator<(CIP& p) throw()
	{
		return operator<(p._pInterface);
	}

	// For comparison with NULL
	bool operator<(int null) throw()
	{
		ASSERT(!null);
		return _pInterface<NULL;
	}

	bool operator>(_IUnknown& p) throw()
	{
		return operator>(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator>(Interface* p) throw()
	{
		return (_pInterface>p)?true:_CompareUnknown(p)>0;
	}

	// Compares 2 CIPs
	bool operator>(CIP& p) throw()
	{
		return operator>(p._pInterface);
	}

	// For comparison with NULL
	bool operator>(int null) throw()
	{
		ASSERT(!null);
		return _pInterface>NULL;
	}

	bool operator<=(_IUnknown& p) throw()
	{
		return operator<=(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator<=(Interface* p) throw()
	{
		return (_pInterface<=p)?true:_CompareUnknown(p)<=0;
	}

	// Compares 2 CIPs
	bool operator<=(CIP& p) throw()
	{
		return operator<=(p._pInterface);
	}

	// For comparison with NULL
	bool operator<=(int null) throw()
	{
		ASSERT(!null);
		return _pInterface<=NULL;
	}

	bool operator>=(_IUnknown& p) throw()
	{
		return operator>=(static_cast<IUnknown*>(&p));
	}

	// Compare with other interface
	bool operator>=(Interface* p) throw()
	{
		return (_pInterface>=p)?true:_CompareUnknown(p)>=0;
	}

	// Compares 2 CIPs
	bool operator>=(CIP& p) throw()
	{
		return operator>=(p._pInterface);
	}

	// For comparison with NULL
	bool operator>=(int null) throw()
	{
		ASSERT(!null);
		return _pInterface>=NULL;
	}

	// Provided for casts between different pointer types.
	operator _IUnknown&() const throw()
	{
		return *reinterpret_cast<_IUnknown*>(static_cast<IUnknown*>(_pInterface));
	}

	// Provides assertion verified, Release()ing of this interface.
	void Release() throw()
	{
		ASSERT(_pInterface);
		if (_pInterface)
			{
			_pInterface->Release();
			_pInterface = NULL;
			}
	}

	// Provides assertion verified AddRef()ing of this interface.
	void AddRef() throw()
	{
		ASSERT(_pInterface);
		if (_pInterface)
			_pInterface->AddRef();
	}

	// Another way to get the interface pointer without casting.
	Interface* GetInterfacePtr() const throw()
	{
		return _pInterface;
	}

	// Loads an interface for the provided CLSID.
	// Returns an HRESULT.  Any previous interface is released.
	HRESULT CreateInstance(
		const CLSID& clsid, DWORD dwClsContext=CLSCTX_ALL) throw()
	{
		_Release();
		const HRESULT hr = CoCreateInstance(clsid, NULL, dwClsContext,
			GetIID(), reinterpret_cast<void**>(&_pInterface));
		ASSERT(SUCCEEDED(hr));
		return hr;
	}

	// Creates the class specified by clsidString.  clsidString may
	// contain a class id, or a prog id string.
	HRESULT CreateInstance(
		LPOLESTR clsidString, DWORD dwClsContext=CLSCTX_ALL) throw()
	{
		// ISSUE-2002/03/29-JonN Should handle NULL case
		ASSERT(clsidString);
		CLSID clsid;
		HRESULT hr;
		if (clsidString[0] == '{')
			hr = CLSIDFromString(clsidString, &clsid);
		else
			hr = CLSIDFromProgID(clsidString, &clsid);
		ASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
			return hr;
		return CreateInstance(clsid, dwClsContext);
	}

	HRESULT QueryInterface(const IID& iid, IUnknown*& p) throw()
	{
		return _pInterface ?
			_pInterface->QueryInterface(iid, reinterpret_cast<void**>(&p)) :
			E_NOINTERFACE;
	}

	HRESULT QueryInterface(const IID& iid, IUnknown** p) throw()
	{
		return QueryInterface(iid, *p);
	}

	// Perfoms the QI for the specified IID and returns it.
	// As with all QIs, the interface will be AddRef'd.
	IUnknown* QueryInterface(const IID& iid) throw()
	{
		typedef IUnknown _InterfaceType;
		_InterfaceType* pInterface;
		QueryInterface(iid, pInterface);
		return pInterface;
	}

private:
	// The Interface.
	Interface* _pInterface;

	// Releases only if the interface is not null.
	// The interface is not set to NULL.
	void _Release() throw()
	{
		if (_pInterface)
			_pInterface->Release();
	}

	// AddRefs only if the interface is not NULL
	void _AddRef() throw()
	{
		if (_pInterface)
			_pInterface->AddRef();
	}

	// Performs a QI on pUnknown for the interface type returned
	// for this class.  The interface is stored.  If pUnknown is
	// NULL, or the QI fails, E_NOINTERFACE is returned and
	// _pInterface is set to NULL.
	HRESULT _QueryInterface(IUnknown* p) throw()
	{
		if (!p) // Can't QI NULL
		{
			operator=(static_cast<Interface*>(NULL));
			return E_NOINTERFACE;
		}

		// Query for this interface
		Interface* pInterface;
		const HRESULT hr = p->QueryInterface(GetIID(),
			reinterpret_cast<void**>(&pInterface));
		if (FAILED(hr))
		{
			// If failed intialize interface to NULL and return HRESULT.
			Attach(NULL);
			return hr;
		}

		// Save the interface without AddRef()ing.
		Attach(pInterface);
		return hr;
	}

	// Compares the provided pointer with this by obtaining IUnknown interfaces
	// for each pointer and then returning the difference.
	int _CompareUnknown(IUnknown* p) throw()
	{
		IUnknown* pu1;
		if (_pInterface)
		{
			const HRESULT hr=QueryInterface(IID_IUnknown, pu1);
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu1)
				pu1->Release();
		}
		else pu1=NULL;

		IUnknown* pu2;
		if (p)
		{
			const HRESULT hr=p->QueryInterface(IID_IUnknown, reinterpret_cast<void**>(&pu2));
			ASSERT(SUCCEEDED(hr) || hr == E_NOINTERFACE);
			if (pu2)
				pu2->Release();
		}
		else pu2=NULL;
		return pu1-pu2;
	}
}; // class CIP
#endif // USE_OLD_COMPILER

#endif // _MSC_VER < 1100
#endif // COMPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\comptrs.h ===
#ifndef COMPTRS_H
#define COMPTRS_H

#ifndef COMPTR_H
#include <comptr.h>
#endif

#if _MSC_VER < 1100

// Includes for Common IIDs
//REVIEW: these should probably be ifdefed so that all of these includes needn't be included.
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPISPI_H
#include <MAPISPI.H>
#endif
#ifndef _INC_VFW
#include <VFW.H>
#endif
//REVIEW: #ifndef __activscp_h__
//REVIEW: #include <ACTIVSCP.H>
//REVIEW: #endif
#ifndef __urlmon_h__
#include <URLMON.H>
#endif
#ifndef __datapath_h__
#include <DATAPATH.h>
#endif
#ifndef __RECONCIL_H__
#include <RECONCIL.H>
#endif
#ifndef _DAOGETRW_H_
#include <DAOGETRW.H>
#endif
#include <DBDAOID.H>
//REVIEW: #ifndef __comcat_h__
//REVIEW: #include <COMCAT.H>
//REVIEW: #endif
#include <SHLGUID.H>
#ifndef _SHLOBJ_H_
#include <SHLOBJ.H>
#endif
#ifndef __docobj_h__
#include <DOCOBJ.H>
#endif
#include <DBDAOID.H>
#ifndef __DDRAW_INCLUDED__
#include <DDRAW.H>
#endif
#ifndef __DPLAY_INCLUDED__
#include <DPLAY.H>
#endif
#ifndef __DSOUND_INCLUDED__
#include <DSOUND.H>
#endif
//REVIEW: #ifndef __hlink_h__
//REVIEW: #include <HLINK.H>
//REVIEW: #endif
//REVIEW: #ifndef _SHDocVw_H_
//REVIEW: #include <EXDISP.H>
//REVIEW: #endif
#ifndef MAPIFORM_H
#include <MAPIFORM.H>
#endif
#ifndef MAPIX_H
#include <MAPIX.H>
#endif
//REVIEW: #ifndef __objsafe_h__
//REVIEW: #include <OBJSAFE.H>
//REVIEW: #endif
#include <OLECTLID.H>
#ifndef _RICHEDIT_
#include <RICHEDIT.H>
#endif
#ifndef _RICHOLE_
#include <RICHOLE.H>
#endif
//REVIEW: #ifndef __INTSHCUT_H__
//REVIEW: #include <INTSHCUT.H>
//REVIEW: #endif
//REVIEW: #ifndef _WPObj_H_
//REVIEW: #include <WPOBJ.H>
//REVIEW: #endif
//REVIEW: #ifndef _wpapi_h_
//REVIEW: #include <WPAPI.H>
//REVIEW: #endif
//REVIEW: #ifndef _wpspi_h_
//REVIEW: #include <WPSPI.H>
//REVIEW: #endif
#ifndef EXCHEXT_H
#include <EXCHEXT.h>
#endif

// Standard cip's
DEFINE_CIP(IABContainer);
DEFINE_CIP(IABLogon);
DEFINE_CIP(IABProvider);
DEFINE_CIP(IAVIEditStream);
DEFINE_CIP(IAVIFile);
DEFINE_CIP(IAVIStream);
DEFINE_CIP(IAVIStreaming);
//REVIEW: DEFINE_CIP(IActiveScript);
//REVIEW: DEFINE_CIP(IActiveScriptError);
//REVIEW: DEFINE_CIP(IActiveScriptParse);
//REVIEW: DEFINE_CIP(IActiveScriptSite);
//REVIEW: DEFINE_CIP(IActiveScriptSiteWindow);
DEFINE_CIP(IAddrBook);
DEFINE_CIP(IAdviseSink);
DEFINE_CIP(IAdviseSink2);
DEFINE_CIP(IAdviseSinkEx);
//REVIEW: DEFINE_CIP(IAsyncMoniker);
//REVIEW: DEFINE_CIP(IAttachment);
DEFINE_CIP(IAuthenticate);
DEFINE_CIP(IBindCtx);
DEFINE_CIP(IBindHost);
DEFINE_CIP(IBindProtocol);
DEFINE_CIP(IBindStatusCallback);
DEFINE_CIP(IBinding);
DEFINE_CIP(IBriefcaseInitiator);
DEFINE_CIP(ICDAORecordset);
//REVIEW: DEFINE_CIP(ICatInformation);
//REVIEW: DEFINE_CIP(ICatRegister);
DEFINE_CIP(IChannelHook);
DEFINE_CIP(IClassActivator);
DEFINE_CIP(IClassFactory);
DEFINE_CIP(IClassFactory2);
DEFINE_CIP(IClientSecurity);
DEFINE_CIP(ICodeInstall);
DEFINE_CIP(ICommDlgBrowser);
DEFINE_CIP(IConnectionPoint);
DEFINE_CIP(IConnectionPointContainer);
DEFINE_CIP(IContextMenu);
DEFINE_CIP(IContextMenu2);
DEFINE_CIP(IContinue);
DEFINE_CIP(IContinueCallback);
DEFINE_CIP(ICreateErrorInfo);
DEFINE_CIP(ICreateTypeInfo);
DEFINE_CIP(ICreateTypeInfo2);
DEFINE_CIP(ICreateTypeLib);
DEFINE_CIP(ICreateTypeLib2);
//REVIEW: DEFINE_CIP(IDAOContainer);
//REVIEW: DEFINE_CIP(IDAOContainerW);
//REVIEW: DEFINE_CIP(IDAOContainers);
//REVIEW: DEFINE_CIP(IDAOContainersW);
//REVIEW: DEFINE_CIP(IDAODBEngine);
//REVIEW: DEFINE_CIP(IDAODBEngineW);
//REVIEW: DEFINE_CIP(IDAODatabase);
//REVIEW: DEFINE_CIP(IDAODatabaseW);
//REVIEW: DEFINE_CIP(IDAODatabases);
//REVIEW: DEFINE_CIP(IDAODatabasesW);
//REVIEW: DEFINE_CIP(IDAODocument);
//REVIEW: DEFINE_CIP(IDAODocumentW);
//REVIEW: DEFINE_CIP(IDAODocuments);
//REVIEW: DEFINE_CIP(IDAODocumentsW);
//REVIEW: DEFINE_CIP(IDAOError);
//REVIEW: DEFINE_CIP(IDAOErrorW);
//REVIEW: DEFINE_CIP(IDAOErrors);
//REVIEW: DEFINE_CIP(IDAOErrorsW);
//REVIEW: DEFINE_CIP(IDAOField);
//REVIEW: DEFINE_CIP(IDAOFieldW);
//REVIEW: DEFINE_CIP(IDAOFields);
//REVIEW: DEFINE_CIP(IDAOFieldsW);
//REVIEW: DEFINE_CIP(IDAOGroup);
//REVIEW: DEFINE_CIP(IDAOGroupW);
//REVIEW: DEFINE_CIP(IDAOGroups);
//REVIEW: DEFINE_CIP(IDAOGroupsW);
//REVIEW: DEFINE_CIP(IDAOIndex);
//REVIEW: DEFINE_CIP(IDAOIndexFields);
//REVIEW: DEFINE_CIP(IDAOIndexFieldsW);
//REVIEW: DEFINE_CIP(IDAOIndexW);
//REVIEW: DEFINE_CIP(IDAOIndexes);
//REVIEW: DEFINE_CIP(IDAOIndexesW);
//REVIEW: DEFINE_CIP(IDAOParameter);
//REVIEW: DEFINE_CIP(IDAOParameterW);
//REVIEW: DEFINE_CIP(IDAOParameters);
//REVIEW: DEFINE_CIP(IDAOParametersW);
//REVIEW: DEFINE_CIP(IDAOProperties);
//REVIEW: DEFINE_CIP(IDAOPropertiesW);
//REVIEW: DEFINE_CIP(IDAOProperty);
//REVIEW: DEFINE_CIP(IDAOPropertyW);
//REVIEW: DEFINE_CIP(IDAOQueryDef);
//REVIEW: DEFINE_CIP(IDAOQueryDefW);
//REVIEW: DEFINE_CIP(IDAOQueryDefs);
//REVIEW: DEFINE_CIP(IDAOQueryDefsW);
//REVIEW: DEFINE_CIP(IDAORecordset);
//REVIEW: DEFINE_CIP(IDAORecordsetW);
//REVIEW: DEFINE_CIP(IDAORecordsets);
//REVIEW: DEFINE_CIP(IDAORecordsetsW);
//REVIEW: DEFINE_CIP(IDAORelation);
//REVIEW: DEFINE_CIP(IDAORelationW);
//REVIEW: DEFINE_CIP(IDAORelations);
//REVIEW: DEFINE_CIP(IDAORelationsW);
//REVIEW: DEFINE_CIP(IDAOStdCollection);
//REVIEW: DEFINE_CIP(IDAOStdObject);
//REVIEW: DEFINE_CIP(IDAOTableDef);
//REVIEW: DEFINE_CIP(IDAOTableDefW);
//REVIEW: DEFINE_CIP(IDAOTableDefs);
//REVIEW: DEFINE_CIP(IDAOTableDefsW);
//REVIEW: DEFINE_CIP(IDAOUser);
//REVIEW: DEFINE_CIP(IDAOUserW);
//REVIEW: DEFINE_CIP(IDAOUsers);
//REVIEW: DEFINE_CIP(IDAOUsersW);
//REVIEW: DEFINE_CIP(IDAOWorkspace);
//REVIEW: DEFINE_CIP(IDAOWorkspaceW);
//REVIEW: DEFINE_CIP(IDAOWorkspaces);
//REVIEW: DEFINE_CIP(IDAOWorkspacesW);
DEFINE_CIP(IDataAdviseHolder);
DEFINE_CIP(IDataObject);
DEFINE_CIP(IDataPathBrowser);
//REVIEW: DEFINE_CIP(IDebug);
//REVIEW: DEFINE_CIP(IDebugStream);
//REVIEW: DEFINE_CIP(IDfReserved1);
//REVIEW: DEFINE_CIP(IDfReserved2);
//REVIEW: DEFINE_CIP(IDfReserved3);
DEFINE_CIP(IDirectDraw);
DEFINE_CIP(IDirectDraw2);
DEFINE_CIP(IDirectDrawClipper);
DEFINE_CIP(IDirectDrawPalette);
DEFINE_CIP(IDirectDrawSurface);
DEFINE_CIP(IDirectDrawSurface2);
DEFINE_CIP(IDirectPlay);
DEFINE_CIP(IDirectSound);
DEFINE_CIP(IDirectSoundBuffer);
DEFINE_CIP(IDispatch);
DEFINE_CIP(IDistList);
DEFINE_CIP(IDropSource);
DEFINE_CIP(IDropTarget);
//REVIEW: DEFINE_CIP(IEnumCATEGORYINFO);
//REVIEW: DEFINE_CIP(IEnumCATID);
//REVIEW: DEFINE_CIP(IEnumCLSID);
//REVIEW: DEFINE_CIP(IEnumCallback);
DEFINE_CIP(IEnumConnectionPoints);
DEFINE_CIP(IEnumConnections);
DEFINE_CIP(IEnumFORMATETC);
//REVIEW: DEFINE_CIP(IEnumGUID);
//REVIEW: DEFINE_CIP(IEnumGeneric);
//REVIEW: DEFINE_CIP(IEnumHLITEM);
//REVIEW: DEFINE_CIP(IEnumHolder);
DEFINE_CIP(IEnumIDList);
//REVIEW: DEFINE_CIP(IEnumMAPIFormProp);
DEFINE_CIP(IEnumMoniker);
DEFINE_CIP(IEnumMsoView);
DEFINE_CIP(IEnumOLEVERB);
DEFINE_CIP(IEnumOleDocumentViews);
DEFINE_CIP(IEnumOleUndoUnits);
DEFINE_CIP(IEnumSTATDATA);
DEFINE_CIP(IEnumSTATPROPSETSTG);
DEFINE_CIP(IEnumSTATPROPSTG);
DEFINE_CIP(IEnumSTATSTG);
DEFINE_CIP(IEnumString);
DEFINE_CIP(IEnumUnknown);
DEFINE_CIP(IEnumVARIANT);
DEFINE_CIP(IErrorInfo);
DEFINE_CIP(IErrorLog);
DEFINE_CIP(IExchExt);
DEFINE_CIP(IExchExtAdvancedCriteria);
DEFINE_CIP(IExchExtAttachedFileEvents);
DEFINE_CIP(IExchExtCallback);
DEFINE_CIP(IExchExtCommands);
DEFINE_CIP(IExchExtMessageEvents);
DEFINE_CIP(IExchExtModeless);
DEFINE_CIP(IExchExtModelessCallback);
DEFINE_CIP(IExchExtPropertySheets);
DEFINE_CIP(IExchExtSessionEvents);
DEFINE_CIP(IExchExtUserEvents);
DEFINE_CIP(IExternalConnection);
DEFINE_CIP(IExtractIcon);
DEFINE_CIP(IExtractIconA);
DEFINE_CIP(IExtractIconW);
DEFINE_CIP(IFileViewer);
DEFINE_CIP(IFileViewerA);
DEFINE_CIP(IFileViewerSite);
DEFINE_CIP(IFileViewerW);
DEFINE_CIP(IFillLockBytes);
DEFINE_CIP(IFont);
DEFINE_CIP(IFontDisp);
DEFINE_CIP(IGetFrame);
//REVIEW: DEFINE_CIP(IHTMLDocument);
//REVIEW: DEFINE_CIP(IHlink);
//REVIEW: DEFINE_CIP(IHlinkBrowseContext);
//REVIEW: DEFINE_CIP(IHlinkFrame);
//REVIEW: DEFINE_CIP(IHlinkSite);
//REVIEW: DEFINE_CIP(IHlinkSource);
//REVIEW: DEFINE_CIP(IHlinkTarget);
DEFINE_CIP(IHttpNegotiate);
DEFINE_CIP(IHttpSecurity);
//REVIEW: DEFINE_CIP(IInternalMoniker);
//REVIEW: DEFINE_CIP(IInternetExplorer);
DEFINE_CIP(ILayoutStorage);
DEFINE_CIP(ILockBytes);
DEFINE_CIP(IMAPIAdviseSink);
DEFINE_CIP(IMAPIContainer);
DEFINE_CIP(IMAPIControl);
DEFINE_CIP(IMAPIFolder);
DEFINE_CIP(IMAPIForm);
DEFINE_CIP(IMAPIFormAdviseSink);
DEFINE_CIP(IMAPIFormContainer);
DEFINE_CIP(IMAPIFormFactory);
DEFINE_CIP(IMAPIFormInfo);
DEFINE_CIP(IMAPIFormMgr);
//REVIEW: DEFINE_CIP(IMAPIFormProp);
DEFINE_CIP(IMAPIMessageSite);
DEFINE_CIP(IMAPIProgress);
DEFINE_CIP(IMAPIProp);
//REVIEW: DEFINE_CIP(IMAPIPropData);
DEFINE_CIP(IMAPISession);
//REVIEW: DEFINE_CIP(IMAPISpoolerInit);
//REVIEW: DEFINE_CIP(IMAPISpoolerService);
//REVIEW: DEFINE_CIP(IMAPISpoolerSession);
DEFINE_CIP(IMAPIStatus);
//REVIEW: DEFINE_CIP(IMAPISup);
DEFINE_CIP(IMAPITable);
//REVIEW: DEFINE_CIP(IMAPITableData);
DEFINE_CIP(IMAPIViewAdviseSink);
DEFINE_CIP(IMAPIViewContext);
DEFINE_CIP(IMSLogon);
DEFINE_CIP(IMSProvider);
DEFINE_CIP(IMailUser);
DEFINE_CIP(IMalloc);
DEFINE_CIP(IMallocSpy);
DEFINE_CIP(IMarshal);
DEFINE_CIP(IMessage);
DEFINE_CIP(IMessageFilter);
DEFINE_CIP(IMoniker);
DEFINE_CIP(IMsgServiceAdmin);
DEFINE_CIP(IMsgStore);
DEFINE_CIP(IMsoCommandTarget);
DEFINE_CIP(IMsoDocument);
DEFINE_CIP(IMsoDocumentSite);
DEFINE_CIP(IMsoView);
//REVIEW: DEFINE_CIP(IMultiQC);
DEFINE_CIP(INewShortcutHook);
DEFINE_CIP(INewShortcutHookA);
DEFINE_CIP(INewShortcutHookW);
DEFINE_CIP(INotifyReplica);
//REVIEW: DEFINE_CIP(IObjectSafety);
DEFINE_CIP(IObjectWithSite);
DEFINE_CIP(IOleAdviseHolder);
DEFINE_CIP(IOleCache);
DEFINE_CIP(IOleCache2);
DEFINE_CIP(IOleCacheControl);
DEFINE_CIP(IOleClientSite);
DEFINE_CIP(IOleCommandTarget);
DEFINE_CIP(IOleContainer);
DEFINE_CIP(IOleControl);
DEFINE_CIP(IOleControlSite);
DEFINE_CIP(IOleDocument);
DEFINE_CIP(IOleDocumentSite);
DEFINE_CIP(IOleDocumentView);
DEFINE_CIP(IOleInPlaceActiveObject);
DEFINE_CIP(IOleInPlaceFrame);
DEFINE_CIP(IOleInPlaceObject);
DEFINE_CIP(IOleInPlaceObjectWindowless);
DEFINE_CIP(IOleInPlaceSite);
DEFINE_CIP(IOleInPlaceSiteEx);
DEFINE_CIP(IOleInPlaceSiteWindowless);
DEFINE_CIP(IOleInPlaceUIWindow);
DEFINE_CIP(IOleItemContainer);
DEFINE_CIP(IOleLink);
//REVIEW: DEFINE_CIP(IOleManager);
DEFINE_CIP(IOleObject);
DEFINE_CIP(IOleParentUndoUnit);
//REVIEW: DEFINE_CIP(IOlePresObj);
DEFINE_CIP(IOleUndoManager);
DEFINE_CIP(IOleUndoUnit);
DEFINE_CIP(IOleWindow);
//REVIEW: DEFINE_CIP(IPSFactory);
DEFINE_CIP(IPSFactoryBuffer);
DEFINE_CIP(IParseDisplayName);
DEFINE_CIP(IPerPropertyBrowsing);
DEFINE_CIP(IPersist);
DEFINE_CIP(IPersistFile);
DEFINE_CIP(IPersistFolder);
DEFINE_CIP(IPersistMemory);
DEFINE_CIP(IPersistMessage);
DEFINE_CIP(IPersistMoniker);
DEFINE_CIP(IPersistPropertyBag);
DEFINE_CIP(IPersistStorage);
DEFINE_CIP(IPersistStream);
DEFINE_CIP(IPersistStreamInit);
DEFINE_CIP(IPicture);
DEFINE_CIP(IPictureDisp);
DEFINE_CIP(IPointerInactive);
DEFINE_CIP(IPrint);
DEFINE_CIP(IProfAdmin);
DEFINE_CIP(IProfSect);
DEFINE_CIP(IProgressNotify);
//REVIEW: DEFINE_CIP(IPropSheetPage);
DEFINE_CIP(IPropertyBag);
//REVIEW: DEFINE_CIP(IPropertyFrame);
DEFINE_CIP(IPropertyNotifySink);
DEFINE_CIP(IPropertyPage);
DEFINE_CIP(IPropertyPage2);
DEFINE_CIP(IPropertyPageSite);
DEFINE_CIP(IPropertySetStorage);
DEFINE_CIP(IPropertyStorage);
DEFINE_CIP(IProvideClassInfo);
DEFINE_CIP(IProvideClassInfo2);
DEFINE_CIP(IProvideClassInfo3);
DEFINE_CIP(IProviderAdmin);
//REVIEW: DEFINE_CIP(IProxy);
//REVIEW: DEFINE_CIP(IProxyManager);
DEFINE_CIP(IQuickActivate);
DEFINE_CIP(IROTData);
DEFINE_CIP(IReconcilableObject);
DEFINE_CIP(IReconcileInitiator);
DEFINE_CIP(IRichEditOle);
DEFINE_CIP(IRichEditOleCallback);
DEFINE_CIP(IRootStorage);
//REVIEW: DEFINE_CIP(IRpcChannel);
DEFINE_CIP(IRpcChannelBuffer);
//REVIEW: DEFINE_CIP(IRpcProxy);
DEFINE_CIP(IRpcProxyBuffer);
//REVIEW: DEFINE_CIP(IRpcStub);
DEFINE_CIP(IRpcStubBuffer);
DEFINE_CIP(IRunnableObject);
DEFINE_CIP(IRunningObjectTable);
//REVIEW: DEFINE_CIP(ISHItemOC);
DEFINE_CIP(ISequentialStream);
DEFINE_CIP(IServerSecurity);
DEFINE_CIP(IServiceProvider);
DEFINE_CIP(IShellBrowser);
//REVIEW: DEFINE_CIP(IShellCopyHook);
//REVIEW: DEFINE_CIP(IShellCopyHookA);
//REVIEW: DEFINE_CIP(IShellCopyHookW);
DEFINE_CIP(IShellExecuteHook);
DEFINE_CIP(IShellExecuteHookA);
DEFINE_CIP(IShellExecuteHookW);
DEFINE_CIP(IShellExtInit);
DEFINE_CIP(IShellFolder);
DEFINE_CIP(IShellIcon);
DEFINE_CIP(IShellLink);
DEFINE_CIP(IShellLinkA);
DEFINE_CIP(IShellLinkW);
DEFINE_CIP(IShellPropSheetExt);
DEFINE_CIP(IShellView);
DEFINE_CIP(IShellView2);
DEFINE_CIP(ISimpleFrameSite);
DEFINE_CIP(ISpecifyPropertyPages);
//REVIEW: DEFINE_CIP(ISpoolerHook);
DEFINE_CIP(IStdMarshalInfo);
DEFINE_CIP(IStorage);
DEFINE_CIP(IStream);
//REVIEW: DEFINE_CIP(IStreamDocfile);
//REVIEW: DEFINE_CIP(IStreamTnef);
//REVIEW: DEFINE_CIP(IStub);
//REVIEW: DEFINE_CIP(IStubManager);
DEFINE_CIP(ISupportErrorInfo);
//REVIEW: DEFINE_CIP(ITNEF);
DEFINE_CIP(ITypeChangeEvents);
DEFINE_CIP(ITypeComp);
DEFINE_CIP(ITypeInfo);
DEFINE_CIP(ITypeInfo2);
DEFINE_CIP(ITypeLib);
DEFINE_CIP(ITypeLib2);
//REVIEW: DEFINE_CIP(IUniformResourceLocator);
DEFINE_CIP(IViewObject);
DEFINE_CIP(IViewObject2);
DEFINE_CIP(IViewObjectEx);
//REVIEW: DEFINE_CIP(IWPObj);
//REVIEW: DEFINE_CIP(IWPProvider);
//REVIEW: DEFINE_CIP(IWPSite);
//REVIEW: DEFINE_CIP(IWebBrowser);
DEFINE_CIP(IWinInetHttpInfo);
DEFINE_CIP(IWinInetInfo);
DEFINE_CIP(IWindowForBindingUI);
DEFINE_CIP(IXPLogon);
DEFINE_CIP(IXPProvider);

#endif // _MSC_VER < 1100
#endif // COMPTRS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\comstrm.h ===
#ifndef COMSTRM_H
#define COMSTRM_H

//
// JonN 12/01/99
// 384722: compmgmt: GetDataHere is not returning an error
//         if buffer is too small
// The callers routinely assume that if stream_ptr is initialized
// using a STGMEDIUM with TYMED_GLOBAL, that STGMEDIUM.hGlobal will
// be kept up to date with each Write().  This is not strictly true
// of a normal IStream, but we will build in this behavior in order
// to avoid changing too much client code.  However, since GetDataHere
// (MSDN) specifies that the HGLOBAL should not be changed, we return
// STG_E_MEDIUMFULL if it changes; but we do still replace the HGLOBAL,
// since the old one is implicitly freed and the new one needs to be freed.
//

#ifndef COMPTRS_H
#include <comptrs.h>
#endif

namespace microsoft	{
namespace com {

class stream_ptr
	{
	// Construction
	public: stream_ptr() throw()
		// Sets the stream to NULL
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		}

	public: explicit stream_ptr(const stream_ptr& pStream) throw()
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(pStream.m_pStream);
		}

	public: explicit stream_ptr(IStream* pStream) throw()
		// Saves the stream
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(pStream);
		}

	//REVIEW: add template constructors

	public: explicit stream_ptr(HGLOBAL global) throw()
		// Creates a stream on top of the global
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(global);
		}

	public: explicit stream_ptr(LPCOLESTR filename) throw()
		// Creates a stream on top of the specified file
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(filename);
		}

	public: explicit stream_ptr(STGMEDIUM& stgMedium) throw()
		// Saves the provided stream.
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		Initialize(stgMedium);
		}

	public: explicit stream_ptr(STGMEDIUM* pStgMedium) throw()
		// Saves the provided stream.
		: m_pStream()
		, m_pWritebackHGlobal( NULL )
		, m_hgOriginalHGlobal( NULL )
		{
		if (pStgMedium)
			Initialize(*pStgMedium);
		}
	
	//REVIEW: Add Create and Open functions
	//REVIEW: Add all of the assignment operators, cast operators, attach, detach, ->, *, etc.
	
	public: operator IStream*() const throw()
		{
		//REVIEW: trace on null would be helpful
		return m_pStream;
		}

	public: IStream* operator->() const throw()
		{
		//REVIEW: trace on null would be helpful
		return m_pStream;
		}

	public: IStream& operator*() const throw()
		{
		//REVIEW: trace on null would be helpful
		return *m_pStream;
		}

	// Write interfaces
	public: HRESULT Write(
		const void* pBuffer, unsigned long writeCount, unsigned long& written) throw()
		// Write the data contained in the buffer
		{
		if (m_pStream == NULL)
			return E_FAIL; //REVIEW: correct failure code?
		HRESULT hr = m_pStream->Write(pBuffer, writeCount, &written);
		if (SUCCEEDED(hr) && NULL != m_pWritebackHGlobal)
		{
			HGLOBAL hgNew = NULL;
			hr = GetHGlobalFromStream(m_pStream, &hgNew);
			if (SUCCEEDED(hr))
			{
				if (NULL == m_hgOriginalHGlobal)
					*m_pWritebackHGlobal = hgNew;
				else if (m_hgOriginalHGlobal != hgNew)
				{
					//
					// When this occurs, the old HGLOBAL has already been freed
					//
					*m_pWritebackHGlobal = hgNew;
					hr = STG_E_MEDIUMFULL;
				}
			}
		}
		return hr;
		}

	public: HRESULT Write(const void* pBuffer, unsigned long writeCount) throw()
		{
		unsigned long written = 0;
		HRESULT hr = Write(pBuffer, writeCount, written);
		// 2002/02/15-JonN Security push: do not ignore written!=writeCount
		if (SUCCEEDED(hr) && written != writeCount)
			hr = STG_E_MEDIUMFULL;
		return hr;
		}

	public: HRESULT Write(const wchar_t* string) throw()
		{
		// 2002/02/15-JonN pointer check
		if (IsBadStringPtrW(string,(UINT_PTR)-1))
			{
			ASSERT(FALSE);
			return E_POINTER;
			}
		unsigned long len=(unsigned long)(wcslen(string)+1);
		return Write(string, len*sizeof(wchar_t), len);
		}

	public: HRESULT Write(const char* string) throw()
		{
		// 2002/02/15-JonN pointer check
		if (IsBadStringPtrA(string,(UINT_PTR)-1))
			{
			ASSERT(FALSE);
			return E_POINTER;
			}
		unsigned long len=(unsigned long)(strlen(string)+1);
		return Write(string, len, len);
		}
	
	//REVIEW: Read interfaces
	//REVIEW: Seek
	//REVIEW: Stat - broken out
	
	// Initialization.  May be used by derived classes to setup the stream for
	// different types of storage mediums.  These functions are all re-entrant,
	// and may be called at any time.  They perform all of the appropriate
	// clean up and releasing of any resources in previous use.
	protected: void Initialize(HGLOBAL hg) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		HRESULT const hr = CreateStreamOnHGlobal(hg, FALSE, &m_pStream);
		ASSERT(SUCCEEDED(hr));
		}

	protected: void Initialize(IStream* pStream) throw()
		{
		//REVIEW: make re-entrant and bullet proof
		m_pStream = pStream;
		}

	protected: void Initialize(LPCOLESTR filename) throw()
		{
        UNREFERENCED_PARAMETER (filename);
		//REVIEW: make re-entrant and bullet proof
		#if 0 //REVIEW:  need to create FileStream before this can be enabled
		if (!filename || !*filename)
			return false;

		cip<FileStream> fs = new CComObject<FileStream>;
		if (!fs)
			return false;

		HRESULT hr = fs->Open(filename);
		if (FAILED(hr))
			return false;

		m_pStream = fs;
		return true;
		#endif // 0
		}

	protected: void Initialize(STGMEDIUM& storage) throw()
		// Initializes the read/write functions based on the type of storage
		// medium.  If there is a problem, the reader/writer is not set.
		{
		//REVIEW: make re-entrant and bullet proof
		switch (storage.tymed)
			{
			case TYMED_HGLOBAL:
				Initialize(storage.hGlobal);
				m_hgOriginalHGlobal = storage.hGlobal;
				m_pWritebackHGlobal = &(storage.hGlobal);
				return;

			case TYMED_FILE:
				Initialize(storage.lpszFileName);
				return;

			case TYMED_ISTREAM:
				Initialize(storage.pstm);
				return;
			}
		}

	// Implementation
	private: IStreamCIP m_pStream;
		// This stream is created and used when the TYMED type is HGLOBAL.

		 //
		 // JonN 12/01/99 384722: see comments at top of file
		 //
		 HGLOBAL m_hgOriginalHGlobal;
		 HGLOBAL* m_pWritebackHGlobal;

	}; // class streamptr

} // namespace com
} // namespace microsoft

#ifndef MICROSOFT_NAMESPACE_ON
using namespace microsoft;
#ifndef COM_NAMESPACE_ON
using namespace com;
#endif // COM_NAMESPACE_ON
#endif // MICROSOFT_NAMESPACE_ON

#endif // COMSTRM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\coremfc.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       mfccore.cpp
//
//  Contents:   put functions that use mfc in here.
//
//  Classes:
//
//  Functions:
//
//  History:   
//
//____________________________________________________________________________

#include <afx.h>
#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include <mmc.h>
#include "guidhelp.h"

#include "macros.h"
USE_HANDLE_MACROS("GUIDHELP(guidhelp.cpp)")

#include <basetyps.h>
#include "cstr.h"
#include "regkey.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static CLIPFORMAT g_CFNodeType = 0;
static CLIPFORMAT g_CFSnapInCLSID = 0;  
static CLIPFORMAT g_CFDisplayName = 0;

HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CString*     pstr,           // OUT: Pointer to CStr to store data
                       DWORD        cchMaxLength)
{
	if (pstr == NULL)
		return E_POINTER;

	CStr cstr(*pstr);

	HRESULT hr = ExtractString(piDataObject, cfClipFormat, &cstr, cchMaxLength);
	
	*pstr = cstr;

	return hr;
} 


HRESULT GuidToCString( CString* pstr, const GUID& guid )
{
	if (pstr == NULL)
		return E_POINTER;

	CStr cstr(*pstr);

	HRESULT hr = GuidToCStr(&cstr, guid);
	
	*pstr = cstr;

	return S_OK;
}


HRESULT LoadRootDisplayName(IComponentData* pIComponentData, 
                            CString& strDisplayName)
{
	CStr cstr = strDisplayName;

	HRESULT hr = LoadRootDisplayName(pIComponentData, cstr);
	
	strDisplayName = cstr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\cstr.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include <stdio.h>
#include <objbase.h>

#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"


/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries
TCHAR strChNil = '\0';

// for creating empty key strings
const CStr strEmptyString;

void CStr::Init()
{
	m_nDataLength = m_nAllocLength = 0;
	m_pchData = (LPTSTR)&strChNil;
}

// declared static
void CStr::SafeDelete(LPTSTR lpch)
{
	// ISSUE-2002/03/29-JonN also check for NULL?  Or is "delete[] NULL" OK?
	if (lpch != (LPTSTR)&strChNil)
		delete[] lpch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CStr::CStr()
{
	Init();
}

CStr::CStr(const CStr& stringSrc)
{
	// if constructing a String from another String, we make a copy of the
	// original string data to enforce value semantics (i.e. each string
	// gets a copy of its own

	stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CStr::AllocBuffer(size_t nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
	if (nLen == 0)
	{
		Init();
	}
	else
	{
		m_pchData = new TCHAR[nLen+1];       //REVIEW may throw an exception
		m_pchData[nLen] = '\0';
		m_nDataLength = nLen;
		m_nAllocLength = nLen;
	}
}

void CStr::Empty()
{
	SafeDelete(m_pchData);
	Init();
	ASSERT(m_nDataLength == 0);
	ASSERT(m_nAllocLength == 0);
}

CStr::~CStr()
 //  free any attached data
{
	SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

static inline size_t SafeStrlen(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	return (lpsz == NULL) ? 0 : lstrlen(lpsz);
}

void CStr::AllocCopy(CStr& dest, size_t nCopyLen, size_t nCopyIndex,
	 size_t nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	size_t nNewLen = nCopyLen + nExtraLen;

	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		dest.AllocBuffer(nNewLen);
		// ISSUE-2002/03/29-JonN should check against m_nDataLength
		memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CStr::CStr(LPCTSTR lpsz)
{
	size_t nLen;
	if ((nLen = SafeStrlen(lpsz)) == 0)
		Init();
	else
	{
		AllocBuffer(nLen);
		memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion constructors

#ifdef UNICODE
CStr::CStr(LPCSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen == 0)
		Init();
	else
	{
		AllocBuffer(nSrcLen);
		mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	}
}
#else //UNICODE
CStr::CStr(LPCWSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen == 0)
		Init();
	else
	{
		AllocBuffer(nSrcLen*2);
		mmc_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
}
#endif //!UNICODE


//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CStr&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CStr::AssignCopy(size_t nSrcLen, LPCTSTR lpszSrcData)
{
	// check if it will fit
	if (nSrcLen > m_nAllocLength)
	{
		// it won't fit, allocate another one
		Empty();
		AllocBuffer(nSrcLen);
	}
	if (nSrcLen != 0)
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
	m_nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
}

const CStr& CStr::operator=(const CStr& stringSrc)
{
	AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
	return *this;
}

const CStr& CStr::operator=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Special conversion assignment

#ifdef UNICODE
const CStr& CStr::operator=(LPCSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	// check if it will fit
	if (nSrcLen > m_nAllocLength)
	{
		// it won't fit, allocate another one
		Empty();
		AllocBuffer(nSrcLen);
	}
	if (nSrcLen != 0)
		mmc_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
	// ISSUE-2002/03/29-JonN "m_nDataLength = nSrcLen" seems wrong
	m_nDataLength = nSrcLen;
	m_pchData[nSrcLen] = '\0';
	return *this;
}
#else //!UNICODE
const CStr& CStr::operator=(LPCWSTR lpsz)
{
	size_t nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	nSrcLen *= 2;
	// check if it will fit
	if (nSrcLen > m_nAllocLength)
	{
		// it won't fit, allocate another one
		Empty();
		AllocBuffer(nSrcLen);
	}
	if (nSrcLen != 0)
	{
		mmc_wcstombsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!UNICODE

//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          String + String
// and for ? = TCHAR, LPCTSTR
//          String + ?
//          ? + String

void CStr::ConcatCopy(size_t nSrc1Len, LPCTSTR lpszSrc1Data,
	size_t nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new String object

	size_t nNewLen = nSrc1Len + nSrc2Len;
	AllocBuffer(nNewLen);
	memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
	memcpy(&m_pchData[nSrc1Len], lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
}

CStr STRAPI operator+(const CStr& string1, const CStr& string2)
{
	CStr s;
	s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
		string2.m_nDataLength, string2.m_pchData);
	return s;
}

CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	CStr s;
	s.ConcatCopy(string.m_nDataLength, string.m_pchData, SafeStrlen(lpsz), lpsz);
	return s;
}

CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	CStr s;
	s.ConcatCopy(SafeStrlen(lpsz), lpsz, string.m_nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CStr::ConcatInPlace(size_t nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (m_nDataLength + nSrcLen > m_nAllocLength)
	{
		// we have to grow the buffer, use the Concat in place routine
		LPTSTR lpszOldData = m_pchData;
		ConcatCopy(m_nDataLength, lpszOldData, nSrcLen, lpszSrcData);
		ASSERT(lpszOldData != NULL);
		SafeDelete(lpszOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(&m_pchData[m_nDataLength], lpszSrcData, nSrcLen*sizeof(TCHAR));
		m_nDataLength += nSrcLen;
	}
	ASSERT(m_nDataLength <= m_nAllocLength);
	m_pchData[m_nDataLength] = '\0';
}

const CStr& CStr::operator+=(LPCTSTR lpsz)
{
	ASSERT(lpsz == NULL || IsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

const CStr& CStr::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

const CStr& CStr::operator+=(const CStr& string)
{
	ConcatInPlace(string.m_nDataLength, string.m_pchData);
	return *this;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

LPTSTR CStr::GetBuffer(size_t nMinBufLength)
{
	if (nMinBufLength > m_nAllocLength)
	{
		// we have to grow the buffer
		LPTSTR lpszOldData = m_pchData;
		size_t nOldLen = m_nDataLength;        // AllocBuffer will tromp it

		AllocBuffer(nMinBufLength);
		memcpy(m_pchData, lpszOldData, nOldLen*sizeof(TCHAR));
		m_nDataLength = nOldLen;
		m_pchData[m_nDataLength] = '\0';

		SafeDelete(lpszOldData);
	}

	// return a pointer to the character storage for this string
	ASSERT(m_pchData != NULL);
	return m_pchData;
}

void CStr::ReleaseBuffer(size_t nNewLength)
{
	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	// ISSUE-2002/03/29-JonN handle this case
	ASSERT(nNewLength <= m_nAllocLength);
	m_nDataLength = nNewLength;
	m_pchData[m_nDataLength] = '\0';
}

LPTSTR CStr::GetBufferSetLength(int nNewLength)
{
	// ISSUE-2002/03/29-JonN handle this case
	ASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	m_nDataLength = nNewLength;
	m_pchData[m_nDataLength] = '\0';
	return m_pchData;
}

void CStr::FreeExtra()
{
	ASSERT(m_nDataLength <= m_nAllocLength);
	if (m_nDataLength != m_nAllocLength)
	{
		LPTSTR lpszOldData = m_pchData;
		AllocBuffer(m_nDataLength);
		memcpy(m_pchData, lpszOldData, m_nDataLength*sizeof(TCHAR));
		ASSERT(m_pchData[m_nDataLength] == '\0');
		SafeDelete(lpszOldData);
	}
	ASSERT(m_pchData != NULL);
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CStr::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

int CStr::FindOneOf(LPCTSTR lpszCharSet) const
{
	ASSERT(IsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
// String conversion helpers (these use the current system locale)

size_t mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	size_t result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, (int) count, NULL, NULL);
	ASSERT(mbstr == NULL || result <= count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

size_t mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	size_t result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, (int) count);
	ASSERT(wcstr == NULL || result <= count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}


/////////////////////////////////////////////////////////////////////////////
// Windows extensions to strings

BOOL CStr::LoadString(HINSTANCE hInst, UINT nID)
{
	ASSERT(nID != 0);       // 0 is an illegal string ID

	// Note: resource strings limited to 511 characters
	TCHAR szBuffer[512];
	UINT nSize = StrLoadString(hInst, nID, szBuffer);
	AssignCopy(nSize, szBuffer);
	return nSize > 0;
}


// ISSUE-2002/04/01-JonN should take cch parameter
int STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf)
{
	// ISSUE-2002/04/01-JonN should test lpszBuf==NULL in retail
	ASSERT(IsValidAddressz(lpszBuf, 512));  // must be big enough for 512 bytes
#ifdef DBG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(hInst, MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //DBG
	int nLen = ::LoadString(hInst, nID, lpszBuf, 511);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}


BOOL STRAPI IsValidString(LPCSTR lpsz, UINT_PTR nLength)
{
	if (lpsz == NULL)
		return FALSE;
	return ::IsBadStringPtrA(lpsz, nLength) == 0;
}

BOOL STRAPI IsValidString(LPCWSTR lpsz, UINT_PTR nLength)
{
	if (lpsz == NULL)
		return FALSE;

	return ::IsBadStringPtrW(lpsz, nLength) == 0;
}


#ifdef OLE_AUTOMATION
#ifdef  UNICODE
BSTR CStr::AllocSysString()
{
	BSTR bstr = ::SysAllocStringLen(m_pchData, m_nDataLength);
	if (bstr == NULL)
		;//REVIEW AfxThrowMemoryException();

	return bstr;
}

BSTR CStr::SetSysString(BSTR* pbstr)
{
	ASSERT(IsValidAddressz(pbstr, sizeof(BSTR)));

	if (!::SysReAllocStringLen(pbstr, m_pchData, m_nDataLength))
		; //REVIEW AfxThrowMemoryException();

	ASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif
#endif // #ifdef OLE_AUTOMATION


///////////////////////////////////////////////////////////////////////////////
// Orginally from StrEx.cpp 


CStr::CStr(TCHAR ch, int nLength)
{
#ifndef UNICODE
	// ISSUE-2002/04/01-JonN This is wrong, we just shouldn't support this
	ASSERT(!IsDBCSLeadByte(ch));    // can't create a lead byte string
#endif
	if (nLength < 1)
	{
		// return empty string if invalid repeat count
		Init();
	}
	else
	{
		AllocBuffer(nLength);
#ifdef UNICODE
		for (int i = 0; i < nLength; i++)
			m_pchData[i] = ch;
#else
		memset(m_pchData, ch, nLength);
#endif
	}
}

CStr::CStr(LPCTSTR lpch, int nLength)
{
	if (nLength == 0)
		Init();
	else
	{
		ASSERT(IsValidAddressz(lpch, nLength, FALSE));
		AllocBuffer(nLength);
		memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CStr& CStr::operator=(TCHAR ch)
{
#ifndef UNICODE
	ASSERT(!IsDBCSLeadByte(ch));    // can't set single lead byte
#endif
	AssignCopy(1, &ch);
	return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CStr STRAPI operator+(const CStr& string1, TCHAR ch)
{
	CStr s;
	s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

CStr STRAPI operator+(TCHAR ch, const CStr& string)
{
	CStr s;
	s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
	return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CStr CStr::Mid(size_t nFirst) const
{
	return Mid(nFirst, m_nDataLength - nFirst);
}

CStr CStr::Mid(size_t nFirst, size_t nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst + nCount > m_nDataLength)
		nCount = m_nDataLength - nFirst;
	if (nFirst > m_nDataLength)
		nCount = 0;

	CStr dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

CStr CStr::Right(size_t nCount) const
{
	if (nCount > m_nDataLength)
		nCount = m_nDataLength;

	CStr dest;
	AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
	return dest;
}

CStr CStr::Left(size_t nCount) const
{
	if (nCount > m_nDataLength)
		nCount = m_nDataLength;

	CStr dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
CStr CStr::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ASSERT(IsValidString(lpszCharSet, FALSE));
	return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
CStr CStr::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ASSERT(IsValidString(lpszCharSet, FALSE));
	return Left(_tcscspn(m_pchData, lpszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CStr::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
int CStr::Find(LPCTSTR lpszSub) const
{
	ASSERT(IsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

/////////////////////////////////////////////////////////////////////////////
// String formatting

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

void CStr::TrimRight()
{
	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		m_nDataLength = (int)(lpszLast - m_pchData);
	}
}

void CStr::TrimLeft()
{
	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	size_t nDataLength = m_nDataLength - (int)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	m_nDataLength = nDataLength;
}

#if 0

///////////////////////////////////////////////////////////////////////////////
// String support for template collections

template<>
void STRAPI ConstructElements(CStr* pElements, int nCount)
{
	ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

	for (; nCount--; ++pElements)
		memcpy(pElements, &strEmptyString, sizeof(*pElements));
}

template<>
void STRAPI DestructElements(CStr* pElements, int nCount)
{
	ASSERT(IsValidAddressz(pElements, nCount * sizeof(CStr)));

	for (; nCount--; ++pElements)
		pElements->Empty();
}

template<>
UINT STRAPI HashKey(LPCTSTR key)
{
	UINT nHash = 0;
	while (*key)
		nHash = (nHash<<5) + nHash + *key++;
	return nHash;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\cstr.h ===
#ifndef __STR_H__
#define __STR_H__

#include <tchar.h>

#define STRAPI __stdcall
struct _STR_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

BOOL STRAPI IsValidString(LPCSTR lpsz, UINT_PTR nLength);
BOOL STRAPI IsValidString(LPCWSTR lpsz, UINT_PTR nLength);

BOOL STRAPI IsValidAddressz(const void* lp, UINT nBytes, BOOL bReadWrite=TRUE);

int  STRAPI StrLoadString(HINSTANCE hInst, UINT nID, LPTSTR lpszBuf); 

class CStr
{
public:

// Constructors
	CStr();
	CStr(const CStr& stringSrc);
	CStr(TCHAR ch, int nRepeat = 1);
	CStr(LPCSTR lpsz);
	CStr(LPCWSTR lpsz);
	CStr(LPCTSTR lpch, int nLength);
	CStr(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	size_t GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(size_t nIndex) const;      // 0 based
	TCHAR operator[](size_t nIndex) const; // same as GetAt
	void SetAt(size_t nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CStr& operator=(const CStr& stringSrc);
	const CStr& operator=(TCHAR ch);
#ifdef UNICODE
	const CStr& operator=(char ch);
#endif
	const CStr& operator=(LPCSTR lpsz);
	const CStr& operator=(LPCWSTR lpsz);
	const CStr& operator=(const unsigned char* psz);

	// string concatenation
	const CStr& operator+=(const CStr& string);
	const CStr& operator+=(TCHAR ch);
#ifdef UNICODE
	const CStr& operator+=(char ch);
#endif
	const CStr& operator+=(LPCTSTR lpsz);

	friend CStr STRAPI operator+(const CStr& string1,
			const CStr& string2);
	friend CStr STRAPI operator+(const CStr& string, TCHAR ch);
	friend CStr STRAPI operator+(TCHAR ch, const CStr& string);
#ifdef UNICODE
	friend CStr STRAPI operator+(const CStr& string, char ch);
	friend CStr STRAPI operator+(char ch, const CStr& string);
#endif
	friend CStr STRAPI operator+(const CStr& string, LPCTSTR lpsz);
	friend CStr STRAPI operator+(LPCTSTR lpsz, const CStr& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CStr Mid(size_t nFirst, size_t nCount) const;
	CStr Mid(size_t nFirst) const;
	CStr Left(size_t nCount) const;
	CStr Right(size_t nCount) const;

	CStr SpanIncluding(LPCTSTR lpszCharSet) const;
	CStr SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// Windows support
	BOOL LoadString(HINSTANCE hInst, UINT nID);          // load from string resource
										// 255 chars max
#ifndef UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif
	BSTR AllocSysString();
	BSTR SetSysString(BSTR* pbstr);

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(size_t nMinBufLength);
	void ReleaseBuffer(size_t nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

// Implementation
public:
	~CStr();
	size_t GetAllocLength() const;

protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	LPTSTR m_pchData;           // actual string (zero terminated)
	size_t m_nDataLength;          // does not include terminating 0
	size_t m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CStr& dest, size_t nCopyLen, size_t nCopyIndex, size_t nExtraLen) const;
	void AllocBuffer(size_t nLen);
	void AssignCopy(size_t nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(size_t nSrc1Len, LPCTSTR lpszSrc1Data, size_t nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(size_t nSrcLen, LPCTSTR lpszSrcData);
	static void SafeDelete(LPTSTR lpch);
	static size_t SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
BOOL STRAPI operator==(const CStr& s1, const CStr& s2);
BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, const CStr& s2);
BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2);
BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2);

// conversion helpers
size_t mmc_wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
size_t mmc_mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
extern const CStr strEmptyString;
extern TCHAR strChNil;

// Compiler doesn't inline for DBG
/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

inline size_t CStr::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? NULL : _tcslen(lpsz); }
// ISSUE-2002/03/29-JonN Can you really get away with these direct
//   manipulations of *this?
inline CStr::CStr(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CStr& CStr::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }

#ifdef _UNICODE
inline const CStr& CStr::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CStr& CStr::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CStr STRAPI operator+(const CStr& string, char ch)
	{ return string + (TCHAR)ch; }
inline CStr STRAPI operator+(char ch, const CStr& string)
	{ return (TCHAR)ch + string; }
#endif

inline size_t CStr::GetLength() const
	{ return m_nDataLength; }
inline size_t CStr::GetAllocLength() const
	{ return m_nAllocLength; }
inline BOOL CStr::IsEmpty() const
	{ return m_nDataLength == 0; }
inline CStr::operator LPCTSTR() const
	{ return (LPCTSTR)m_pchData; }

// String support (windows specific)
// ISSUE-2002/03/29-JonN Should test for NULL
inline int CStr::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CStr::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CStr::Collate is often slower than Compare but is MBCS/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CStr::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive
inline void CStr::MakeUpper()
	{ ::CharUpper(m_pchData); }
inline void CStr::MakeLower()
	{ ::CharLower(m_pchData); }

inline void CStr::MakeReverse()
	{ _tcsrev(m_pchData); }
inline TCHAR CStr::GetAt(size_t nIndex) const
	{
		// ISSUE-2002/03/29-JonN should handle this case
		ASSERT(nIndex < m_nDataLength);

		return m_pchData[nIndex];
	}
inline TCHAR CStr::operator[](size_t nIndex) const
	{
		// same as GetAt

		ASSERT(nIndex < m_nDataLength);

		return m_pchData[nIndex];
	}
inline void CStr::SetAt(size_t nIndex, TCHAR ch)
	{
		ASSERT(nIndex < m_nDataLength);
		ASSERT(ch != 0);

		m_pchData[nIndex] = ch;
	}
inline BOOL STRAPI operator==(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline BOOL STRAPI operator==(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) == 0; }
inline BOOL STRAPI operator!=(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline BOOL STRAPI operator!=(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) != 0; }
inline BOOL STRAPI operator<(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline BOOL STRAPI operator<(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline BOOL STRAPI operator>(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) < 0; }
inline BOOL STRAPI operator<=(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline BOOL STRAPI operator<=(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, const CStr& s2)
	{ return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(const CStr& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline BOOL STRAPI operator>=(LPCTSTR s1, const CStr& s2)
	{ return s2.Compare(s1) <= 0; }

#ifndef UNICODE
inline void CStr::AnsiToOem()
	{ ::AnsiToOem(m_pchData, m_pchData); }
inline void CStr::OemToAnsi()
	{ ::OemToAnsi(m_pchData, m_pchData); }

#endif // UNICODE

// General Exception for memory
class MemoryException
{
public:
	MemoryException(){}
	void DisplayMessage()
	{
	::MessageBox(NULL, _T("Memory Exception"), _T("System Out of Memory"), MB_OK|MB_ICONSTOP);
	}
};

// General Exception for memory
class ResourceException
{
public:
	ResourceException()
	{
	::MessageBox(NULL, _T("Resource Exception"), _T("Unable to Load Resource"), MB_OK|MB_ICONSTOP);
	}
};

#endif // __STR_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(AMCCore)
    #define DBG_COMP    AMCCoreInfoLevel

#endif //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\guidhelp.h ===
// GUID support functions
#ifndef _GUIDHELP_H
#define _GUIDHELP_H

class CStr;
class CString;

struct IContextMenuCallback;
struct IComponent;

HRESULT ExtractData(   IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       PVOID        pbData,
                       DWORD        cbData );

HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CStr*     pstr,
                       DWORD        cchMaxLength );
HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CString*     pstr,
                       DWORD        cchMaxLength );

HRESULT GuidToCStr( CStr* pstr, const GUID& guid );
HRESULT GuidToCString(CString* pstr, const GUID& guid );

HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );

HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CStr& strDisplayName);
HRESULT LoadRootDisplayName(IComponentData* pIComponentData, CString& strDisplayName);

HRESULT LoadAndAddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    UINT nResourceID, // contains text and status text seperated by '\n'
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst,
    PCTSTR pszLanguageIndependentName);
HRESULT AddSpecialSeparator(
    IContextMenuCallback* pIContextMenuCallback,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );
HRESULT AddSpecialInsertionPoint(
    IContextMenuCallback* pIContextMenuCallback,
    long lCommandID,
    long lInsertionPointID = CCM_INSERTIONPOINTID_ROOT_MENU );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\macros.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       macros.h
//
//  Contents:   Useful macros
//
//  Macros:     ARRAYLEN
//
//              BREAK_ON_FAIL(hresult)
//              BREAK_ON_FAIL(hresult)
//
//              DECLARE_IUNKNOWN_METHODS
//              DECLARE_STANDARD_IUNKNOWN
//              IMPLEMENT_STANDARD_IUNKNOWN
//
//              SAFE_RELEASE
//
//              DECLARE_SAFE_INTERFACE_PTR_MEMBERS
//
//  History:    6/3/1996   RaviR   Created
//              7/23/1996  JonN    Added exception handling macros
//
//____________________________________________________________________________

#ifndef _MACROS_H_
#define _MACROS_H_


//____________________________________________________________________________
//
//  Macro:      ARRAYLEN
//
//  Purpose:    To determine the length of an array.
//____________________________________________________________________________
//

#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))


//____________________________________________________________________________
//
//  Macros:     BREAK_ON_FAIL(hresult), BREAK_ON_ERROR(lastError)
//
//  Purpose:    To break out of a loop on error.
//____________________________________________________________________________
//

#define BREAK_ON_FAIL(hr)   if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr)  if (lr != ERROR_SUCCESS) { break; } else 1;


//____________________________________________________________________________
//
//  Macros:     DwordAlign(n)
//____________________________________________________________________________
//

#define DwordAlign(n)  (((n) + 3) & ~3)


//____________________________________________________________________________
//
//  Macros:     SAFE_RELEASE
//____________________________________________________________________________
//

#ifndef SAFE_RELEASE
#define SAFE_RELEASE(punk) \
                if (punk != NULL) \
                { \
                    punk##->Release(); \
                    punk = NULL; \
                } \
                else \
                { \
                    TRACE(_T("Release called on NULL interface ptr")); \
                }
#endif // SAFE_RELEASE



//____________________________________________________________________________
//
//  Macro:      DECLARE_IUNKNOWN_METHODS
//
//  Purpose:    This declares the set of IUnknown methods and is for
//              general-purpose use inside classes that inherit from IUnknown
//____________________________________________________________________________
//

#define DECLARE_IUNKNOWN_METHODS                                    \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);    \
    STDMETHOD_(ULONG,AddRef) (void);                                \
    STDMETHOD_(ULONG,Release) (void)

//____________________________________________________________________________
//
//  Macro:      DECLARE_STANDARD_IUNKNOWN
//
//  Purpose:    This is for use in declaring non-aggregatable objects. It
//              declares the IUnknown methods and reference counter, m_ulRefs.
//              m_ulRefs should be initialized to 1 in the constructor of
//              the object
//____________________________________________________________________________
//

#define DECLARE_STANDARD_IUNKNOWN           \
    DECLARE_IUNKNOWN_METHODS;               \
    ULONG m_ulRefs


//____________________________________________________________________________
//
//  Macro:      IMPLEMENT_STANDARD_IUNKNOWN
//
//  Purpose:    Partial implementaion of standard IUnknown.
//
//  Note:       This does NOT implement QueryInterface, which must be
//              implemented by each object
//____________________________________________________________________________
//

#define IMPLEMENT_STANDARD_IUNKNOWN(cls)                        \
    STDMETHODIMP_(ULONG) cls##::AddRef()                        \
        { return InterlockedIncrement((LONG*)&m_ulRefs); }      \
    STDMETHODIMP_(ULONG) cls##::Release()                       \
        { ULONG ulRet = InterlockedDecrement((LONG*)&m_ulRefs); \
          if (0 == ulRet) { delete this; }                      \
          return ulRet; }






// ISSUE-2002/04/01-JonN This is not used, remove it

//____________________________________________________________________________
//
//  Macro:      DECLARE_SAFE_INTERFACE_PTR_MEMBERS(cls, Interface, m_iptr)
//
//  Purpose:    Make the interface ptr 'm_iptr' of interface type 'Interface'
//              a safe pointer for the given class 'cls', by adding methods and
//              overloading operators to manipulate the pointer m_iptr.
//
//  History:    6/3/1996   RaviR   Created
//
//  Notes:      Adds safe interface pointer member functions to the given
//              class for the given OLE interface. 'm_iptr' is the member
//              variable name of the interface ptr in the given class.
//
//              The Copy function creates a valid additional copy of
//              the captured pointer (following the AddRef/Release protocol)
//              so can be used to hand out copies from a safe pointer declared
//              as a member of some other class.
//
//              The 'Transfer' function transfers the interface pointer, and
//              invalidates its member value (by setting it to NULL).
//
//              To release the existing interface ptr and set it to a new
//              instance use the 'Set' member fuction. This method takes a
//              parameter which specifies whether the new pointer should be
//              AddRef'd, defaulting to TRUE.
//
//              The following methods manipulate the interface pointer with
//              out following the AddRef/Release protocol: Transfer, Attach
//              and Detach.
//____________________________________________________________________________
//

#define DECLARE_SAFE_INTERFACE_PTR_MEMBERS(cls, Interface, m_iptr)  \
                                                                    \
public:                                                             \
    cls##(Interface * iptr=NULL, BOOL fInc=TRUE) : m_iptr(iptr)     \
    {                                                               \
        if (fInc && (m_iptr != NULL))                               \
        {                                                           \
            m_iptr->AddRef();                                       \
        }                                                           \
    }                                                               \
                                                                    \
    ~##cls##()                                                      \
    {                                                               \
        if (m_iptr != NULL)                                         \
        {                                                           \
            m_iptr->Release();                                      \
            m_iptr = NULL;                                          \
        }                                                           \
    }                                                               \
                                                                    \
    inline BOOL IsNull(void)                                        \
    {                                                               \
        return (m_iptr == NULL);                                    \
    }                                                               \
                                                                    \
    void Transfer(Interface **piptr)                                \
    {                                                               \
        *piptr = m_iptr;                                            \
        m_iptr = NULL;                                              \
    }                                                               \
                                                                    \
    void Copy(Interface **piptr)                                    \
    {                                                               \
        *piptr = m_iptr;                                            \
        if (m_iptr != NULL)                                         \
            m_iptr->AddRef();                                       \
    }                                                               \
                                                                    \
    void Set(Interface* iptr, BOOL fInc = TRUE)                     \
    {                                                               \
        if (m_iptr)                                                 \
        {                                                           \
            m_iptr->Release();                                      \
        }                                                           \
        m_iptr = iptr;                                              \
        if (fInc && m_iptr)                                         \
        {                                                           \
            m_iptr->AddRef();                                       \
        }                                                           \
    }                                                               \
                                                                    \
    void SafeRelease(void)                                          \
    {                                                               \
        if (m_iptr)                                                 \
        {                                                           \
            m_iptr->Release();                                      \
            m_iptr = NULL;                                          \
        }                                                           \
    }                                                               \
                                                                    \
    void SimpleRelease(void)                                        \
    {                                                               \
        ASSERT(m_iptr != NULL);                                     \
        m_iptr->Release();                                          \
        m_iptr = NULL;                                              \
    }                                                               \
                                                                    \
    void Attach(Interface* iptr)                                    \
    {                                                               \
        ASSERT(m_iptr == NULL);                                     \
        m_iptr = iptr;                                              \
    }                                                               \
                                                                    \
    void Detach(void)                                               \
    {                                                               \
        m_iptr = NULL;                                              \
    }                                                               \
                                                                    \
    Interface * operator-> () { return m_iptr; }                    \
    Interface& operator * () { return *m_iptr; }                    \
    operator Interface *() { return m_iptr; }                       \
                                                                    \
    Interface ** operator &()                                       \
    {                                                               \
        ASSERT(m_iptr == NULL);                                     \
        return &m_iptr;                                             \
    }                                                               \
                                                                    \
    Interface *Self(void) { return m_iptr; }                        \
                                                                    \
private:                                                            \
    void operator= (const cls &) {;}                                \
    cls(const cls &){;}




//____________________________________________________________________________
//
//  Macro:      EXCEPTION HANDLING MACROS
//
//  Purpose:    Provide standard macros for exception-handling in
//              OLE servers.
//
//  History:    7/23/1996   JonN    Created
//
//  Notes:      Declare USE_HANDLE_MACROS("Component name") in each source
//              file before these are used.
//
//              These macros can only be used in function calls which return
//              type HRESULT.
//
//              Bracket routines which can generate exceptions
//              with STANDARD_TRY and STANDARD_CATCH.
//
//              Where these routines are COM methods requiring MFC
//              support, use MFC_TRY and MFC_CATCH instead.
//____________________________________________________________________________
//


#define USE_HANDLE_MACROS(component)                                        \
    static TCHAR* You_forgot_to_declare_USE_HANDLE_MACROS = _T(component);

#define STANDARD_TRY                                                        \
    try {

#define MFC_TRY                                                             \
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));                           \
    STANDARD_TRY


// ISSUE-2002/04/01-JonN remove ENDMETHOD_READBLOCK

//
// CODEWORK don't quite have ENDMETHOD_READBLOCK working yet
//
#ifdef DEBUG
#define ENDMETHOD_STRING                                                    \
    "%s: The unexpected error can be identified as \"%s\" context %n\n"
#define ENDMETHOD_READBLOCK                                                 \
    {                                                                       \
        TCHAR szError[MAX_PATH];                                            \
        UINT nHelpContext = 0;                                              \
        if ( e->GetErrorMessage( szError, MAX_PATH, &nHelpContext ) )       \
        {                                                                   \
            TRACE( ENDMETHOD_STRING,                                        \
                You_forgot_to_declare_USE_HANDLE_MACROS,                    \
                szError,                                                    \
                nHelpContext );                                             \
        }                                                                   \
    }
#else
#define ENDMETHOD_READBLOCK
#endif

#define ERRSTRING_MEMORY       "%s: An out-of-memory error occurred\n"
#define ERRSTRING_FILE         "%s: File error 0x%lx occurred on file \"%s\"\n"
#define ERRSTRING_OLE          "%s: OLE error 0x%lx occurred\n"
#define ERRSTRING_UNEXPECTED   "%s: An unexpected error occurred\n"
#define BADPARM_STRING         "%s: Bad string parameter\n"
#define BADPARM_POINTER        "%s: Bad pointer parameter\n"

#define TRACEERR(s) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS )
#define TRACEERR1(s,a) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a )
#define TRACEERR2(s,a,b) TRACE( s, You_forgot_to_declare_USE_HANDLE_MACROS,a,b )

// Note that it is important to use "e->Delete();" and not "delete e;"
#define STANDARD_CATCH                                                      \
    }                                                                       \
    catch (CMemoryException* e)                                             \
    {                                                                       \
        TRACEERR( ERRSTRING_MEMORY );                                       \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_OUTOFMEMORY;                                               \
    }                                                                       \
    catch (COleException* e)                                                \
    {                                                                       \
		HRESULT hr = (HRESULT)e->Process(e);								\
        TRACEERR1( ERRSTRING_OLE, hr );										\
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
		ASSERT( FAILED(hr) );												\
        return hr;															\
    }                                                                       \
    catch (CFileException* e)                                               \
    {                                                                       \
		HRESULT hr = (HRESULT)e->m_lOsError;								\
        TRACEERR2( ERRSTRING_FILE, hr, e->m_strFileName );					\
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
		ASSERT( FAILED(hr) );												\
        return hr;															\
    }                                                                       \
    catch (CException* e)                                                   \
    {                                                                       \
        TRACEERR( ERRSTRING_UNEXPECTED );                                   \
        ASSERT( FALSE );                                                    \
        e->Delete();                                                        \
        return E_UNEXPECTED;                                                \
    }

#define MFC_CATCH                                                           \
    STANDARD_CATCH

#define TEST_STRING_PARAM(x)                                                \
    if ( (x) != NULL && !AfxIsValidString(x) ) {                            \
        TRACEERR( BADPARM_STRING ); return E_POINTER; }
#define TEST_NONNULL_STRING_PARAM(x)                                        \
    if ( !AfxIsValidString(x) ) {                                           \
        TRACEERR( BADPARM_STRING ); return E_POINTER; }
#define TEST_NONNULL_PTR_PARAM(x)                                           \
    if ( (x) == NULL || IsBadWritePtr((x),sizeof(x)) ) {                    \
        TRACEERR( BADPARM_POINTER ); return E_POINTER; }

#endif // _MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\regkey.cpp ===
#include <afxdisp.h>        // AfxThrowOleException

#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"

#include "regkey.h"
#include "util.h"
#include "macros.h"

USE_HANDLE_MACROS("GUIDHELP(regkey.cpp)")

using namespace AMC;

DECLARE_INFOLEVEL(AMCCore);
DECLARE_HEAPCHECKING;

// ISSUE-2002/04/01-JonN handle NULL pointer parameters -- omnibus issue


//____________________________________________________________________________
//
//  Member:     CRegKey::CreateKeyEx
//
//  Synopsis:   Same meaning as for RegCreateKeyEx API.
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//              [pdwDisposition] -- OUT
//              [dwOption] -- IN
//              [pSecurityAttributes] -- OUT
//
//  Returns:    void
//
//  History:    5/24/1996   RaviR   Created
//____________________________________________________________________________
//

void
CRegKey::CreateKeyEx(
    HKEY                    hKeyAncestor,
    LPCTSTR                 lpszKeyName,
    REGSAM                  security,
    DWORD                 * pdwDisposition,
    DWORD                   dwOption,
    LPSECURITY_ATTRIBUTES   pSecurityAttributes)
{
    ASSERT(lpszKeyName != NULL);
    ASSERT(m_hKey == 0);         // already called CreateEx on this object

    // NTRAID#NTBUG9-654900-2002/07/08-artm  initialize dwDisposition
    DWORD dwDisposition = 0;

    m_lastError = ::RegCreateKeyEx(hKeyAncestor, lpszKeyName, 0, _T(""),
                                   dwOption, security, pSecurityAttributes,
                                   &m_hKey, &dwDisposition);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld creating key \"%s\" under ancestor 0x%x\n",
            m_lastError, lpszKeyName, hKeyAncestor );
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    if (pdwDisposition != NULL)
    {
        *pdwDisposition = dwDisposition;
    }
}

//____________________________________________________________________________
//
//  Member:     CRegKey::OpenKeyEx
//
//  Synopsis:   Same meaning as RegOpenKeyEx
//
//  Arguments:  [hKeyAncestor] -- IN
//              [lpszKeyName] -- IN
//              [security] -- IN
//
//  Returns:    BOOL (FALSE if key not found, TRUE otherwise.)
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
CRegKey::OpenKeyEx(
    HKEY        hKeyAncestor,
    LPCTSTR     lpszKeyName,
    REGSAM      security)
{
    ASSERT(m_hKey == 0);

    m_lastError = ::RegOpenKeyEx(hKeyAncestor, lpszKeyName,
                                 0, security, &m_hKey);

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_FILE_NOT_FOUND)
    {
        TRACE("CRegKey error %ld opening key \"%s\" under ancestor 0x%x\n",
            m_lastError, lpszKeyName, hKeyAncestor );
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}



//____________________________________________________________________________
//
//  Member:     CRegKey::GetKeySecurity
//
//  Synopsis:   Same meaning as for RegGetKeySecurity API.
//
//  Arguments:  [SecInf] -- IN descriptor contents
//              [pSecDesc] -- OUT address of descriptor for key
//              [lpcbSecDesc] -- IN/OUT address of size of buffer for descriptor
//
//  Returns:    HRESULT.
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

BOOL
CRegKey::GetKeySecurity(
    SECURITY_INFORMATION  SecInf,
    PSECURITY_DESCRIPTOR  pSecDesc,
    LPDWORD               lpcbSecDesc)
{
    ASSERT(pSecDesc != NULL);
    ASSERT(lpcbSecDesc != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegGetKeySecurity(m_hKey, SecInf, pSecDesc, lpcbSecDesc);

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_INSUFFICIENT_BUFFER)
    {
        TRACE("CRegKey error %ld reading security of key 0x%x\n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}

//____________________________________________________________________________
//
//  Member:     CRegKey::CloseKey
//
//  Synopsis:   Same meaning as for RegCloseKey API.
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::CloseKey()
{
    ASSERT(m_hKey != 0);

    m_lastError = ::RegCloseKey(m_hKey);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld closing key 0x%x\n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
    else
    {
        // reset the object
        m_hKey = 0;
        m_lastError = ERROR_SUCCESS;
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::DeleteKey
//
//  Synopsis:   Delete all the keys and subkeys
//
//  Arguments:  [lpszKeyName] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

void
CRegKey::DeleteKey(
    LPCTSTR lpszKeyName)
{
    ASSERT(m_hKey != NULL);
    ASSERT(lpszKeyName != NULL);

    m_lastError = NTRegDeleteKey(m_hKey , lpszKeyName);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld recursively deleting key \"%s\" under key 0x%x\n",
            m_lastError, lpszKeyName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}

//____________________________________________________________________________
//
//  Member:     CRegKey::SetValueEx
//
//  Synopsis:   Same meaning as for RegSetValueEx API.
//
//  Arguments:  [lpszValueName] -- IN
//              [dwType] -- IN
//              [pData] -- OUT
//              [nLen] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::SetValueEx(
    LPCTSTR     lpszValueName,
    DWORD       dwType,
    const void *pData,
    DWORD       nLen)
{
    ASSERT(lpszValueName != NULL);
    ASSERT(pData != NULL);
    ASSERT(m_hKey != NULL);

#if DBG==1
    switch (dwType)
    {
    case REG_BINARY:
    case REG_DWORD:
    case REG_DWORD_BIG_ENDIAN:
    case REG_EXPAND_SZ:
    case REG_LINK:
    case REG_MULTI_SZ:
    case REG_NONE:
    case REG_RESOURCE_LIST:
    case REG_SZ:
        break;

    default:
        ASSERT(FALSE);  // unknown type
    }
#endif

    m_lastError = ::RegSetValueEx(m_hKey, lpszValueName, 0, dwType,
                                        (CONST BYTE *)pData, nLen);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld setting value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     IsValuePresent
//
//  Arguments:  [lpszValueName] -- IN
//
//  Returns:    BOOL.
//
//  History:    3/21/1997   RaviR   Created
//____________________________________________________________________________
//

BOOL CRegKey::IsValuePresent(LPCTSTR lpszValueName)
{
    DWORD cbData; // ISSUE-2002/04/01-JonN pass NULL for this parameter
    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, NULL, 
                                    NULL, &cbData);

    return (m_lastError == ERROR_SUCCESS);
}

//____________________________________________________________________________
//
//  Member:     CRegKey::QueryValueEx
//
//  Synopsis:   Same meaning as for RegQueryValueEx API.
//
//  Arguments:  [lpszValueName] -- IN
//              [pType] -- IN
//              [pData] -- IN
//              [pLen] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryValueEx(
    LPCTSTR lpszValueName,
    LPDWORD pType,
    PVOID   pData,
    LPDWORD pLen)
{
    ASSERT(pLen != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, pType,
                                                  (LPBYTE)pData, pLen);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %d querying data value \"%ws\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}

//____________________________________________________________________________
//
//  Member:     CRegKey::QueryDword
//
//  Synopsis:   Query's for DWORD type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [pdwData] -- IN
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryDword(
    LPCTSTR lpszValueName,
    LPDWORD pdwData)
{
    ASSERT(m_hKey);

    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(DWORD);

    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, &dwType,
                                                  (LPBYTE)pdwData, &dwSize);

    if (m_lastError != ERROR_FILE_NOT_FOUND && dwType != REG_DWORD)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
    }

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld querying dword value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::QueryGUID
//
//  Synopsis:   Query's for GUID type data, stored as REG_SZ.
//
//  Arguments:  [lpszValueName] -- IN
//              [pguid] -- OUT
//
//  Returns:    void
//
//  History:    8/27/1996   JonN    Created
//
//____________________________________________________________________________

void
CRegKey::QueryGUID(
    LPCTSTR lpszValueName,
    GUID* pguid)
{
    ASSERT(m_hKey);
    ASSERT( NULL != pguid );

    CStr str;
    QueryString( lpszValueName, str );

     // CODEWORK m_lastError should not be HRESULT
    m_lastError = GUIDFromCStr( str, pguid );

    if (FAILED(m_lastError))
    {
        TRACE("CRegKey error %ld querying guid value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        ////AfxThrowOleException( m_lastError );
    }
}


void
CRegKey::SetGUID(
    LPCTSTR lpszValueName,
    const GUID& guid)
{
    ASSERT(m_hKey);

    CStr str;

     // CODEWORK m_lastError should not be HRESULT
    m_lastError = GUIDToCStr( str, guid );

    if (FAILED(m_lastError))
    {
        TRACE("CRegKey error %ld setting guid value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        // ISSUE-2002/04/01-JonN should return here?
        ////AfxThrowOleException( m_lastError );
    }

    SetString( lpszValueName, str );
}


//____________________________________________________________________________
//
//  Member:     CRegKey::QueryString
//
//  Synopsis:   Query's for string type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [pBuffer] -- OUT
//              [pdwBufferByteLen] -- IN/OUT
//              [pdwType] -- OUT
//
//  Returns:    BOOL, returns FALSE if the buffer provided is insufficient.
//
//  History:    5/24/1996   RaviR   Created
//
//____________________________________________________________________________


BOOL
CRegKey::QueryString(
    LPCTSTR     lpszValueName,
    LPTSTR      pBuffer,
    DWORD     * pdwBufferByteLen,
    DWORD     * pdwType)
{
    ASSERT(pBuffer != NULL);
    ASSERT(pdwBufferByteLen != NULL);
    ASSERT(m_hKey != NULL);

    DWORD dwType = REG_NONE; // JonN 11/21/00 PREFIX 179991

    m_lastError = ::RegQueryValueEx(m_hKey, lpszValueName, 0, &dwType,
                                    (LPBYTE)pBuffer, pdwBufferByteLen);
    if (pdwType != NULL)
    {
        *pdwType = dwType;
    }

    if (m_lastError != ERROR_FILE_NOT_FOUND &&
        dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
    }

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_MORE_DATA)
    {
        TRACE("CRegKey error %ld querying bufferstring value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}

//____________________________________________________________________________
//
//  Member:     CRegKey::QueryString
//
//  Synopsis:   Query's for string type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [ppStrValue] -- OUT
//              [pdwType] -- OUT
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryString(
    LPCTSTR     lpszValueName,
    LPTSTR    * ppStrValue,
    DWORD     * pdwType)
{
    DWORD dwType = REG_SZ;
    DWORD dwLen = 0;

    // Determine how big the data is
    this->QueryValueEx(lpszValueName, &dwType, NULL, &dwLen);

    if (pdwType != NULL)
    {
        *pdwType = dwType;
    }

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
        TRACE("CRegKey error %ld querying allocstring value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    DWORD charLen = dwLen/sizeof(TCHAR);
    LPTSTR pBuffer = new TCHAR[charLen + 1];
    // ISSUE-2002/04/01-JonN clear buffer

    if (dwLen != 0)
    {
#if DBG==1
        try
        {
            this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);
        }
        catch ( HRESULT result )
        {
            CHECK_HRESULT( result );
        }

#else   // ! DBG==1

        this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);

#endif  // ! DBG==1
    }

    pBuffer[charLen] = TEXT('\0');

    *ppStrValue = pBuffer;
}


//____________________________________________________________________________
//
//  Member:     CRegKey::QueryString
//
//  Synopsis:   Query's for string type data.
//
//  Arguments:  [lpszValueName] -- IN
//              [str] -- OUT
//              [pdwType] -- OUT
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________

void
CRegKey::QueryString(
    LPCTSTR     lpszValueName,
    CStr&    str,
    DWORD     * pdwType)
{
    DWORD dwType = REG_SZ;
    DWORD dwLen=0;

    // Determine how big the data is
    this->QueryValueEx(lpszValueName, &dwType, NULL, &dwLen);

    if (pdwType != NULL)
    {
        *pdwType = dwType;
    }

    if (dwType != REG_SZ && dwType != REG_EXPAND_SZ)
    {
        m_lastError = ERROR_INVALID_DATATYPE;
        TRACE("CRegKey error %ld querying CString value \"%s\" of key 0x%x\n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    DWORD charLen = dwLen/sizeof(TCHAR);
    LPTSTR pBuffer = str.GetBuffer(charLen + 1);
    // ISSUE-2002/04/01-JonN clear buffer

    if (dwLen != 0)
    {
#if DBG==1
        try
        {
            this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);
        }
        catch ( HRESULT result )
        {
            CHECK_HRESULT( result );
        }
#else   // ! DBG==1

        this->QueryValueEx(lpszValueName, &dwType, pBuffer, &dwLen);

#endif  // ! DBG==1
    }

    pBuffer[charLen] = TEXT('\0');

    str.ReleaseBuffer();
}



//____________________________________________________________________________
//
//  Member:     CRegKey::EnumKeyEx
//
//  Synopsis:   Same meaning as for RegEnumKeyEx API.
//
//  Arguments:  [iSubkey] -- IN
//              [lpszName] -- OUT place to store the name
//              [dwLen] -- IN
//              [lpszLastModified] -- IN
//
//  Returns:    BOOL. Returns FALSE if no more items found.
//
//  History:    5/22/1996   RaviR   Created
//
//____________________________________________________________________________

BOOL
CRegKey::EnumKeyEx(
    DWORD       iSubkey,
    LPTSTR      lpszName,
    LPDWORD     lpcchName,
    PFILETIME   lpszLastModified)
{
    ASSERT(lpszName != NULL);
    ASSERT(lpcchName != NULL);
    ASSERT(*lpcchName != 0);
    ASSERT(m_hKey != NULL);     // key probably not opened

    m_lastError = ::RegEnumKeyEx(m_hKey, iSubkey, lpszName, lpcchName,
                                 NULL, NULL, NULL, lpszLastModified);

    if (m_lastError == ERROR_SUCCESS)
    {
        return TRUE;
    }
    else if (m_lastError != ERROR_NO_MORE_ITEMS)
    {
        TRACE("CRegKey error %ld enumerating child %i of key 0x%x\n",
            m_lastError, iSubkey, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return FALSE;
}

//____________________________________________________________________________
//
//  Member:     CRegKey::EnumValue
//
//  Synopsis:   Same meaning as for RegEnumValue API.
//
//  Arguments:  [iValue] -- IN
//              [lpszValue] -- OUT
//              [lpcchValue] -- OUT
//              [lpdwType] -- OUT
//              [lpbData] -- OUT
//              [lpcbData] -- OUT
//
//  Returns:    HRESULT. Returns ERROR_NO_MORE_ITEMS if no more items found,
//              or ERROR_MORE_DATA if the buffer is too small.
//
//  History:    6/6/1996   RaviR   Created
//              2/20/02    JonN    Security Push -- now returns HRESULT
//
//____________________________________________________________________________

HRESULT
CRegKey::EnumValue(
    DWORD   iValue,
    LPTSTR  lpszValue,
    LPDWORD lpcchValue,
    LPDWORD lpdwType,
    LPBYTE  lpbData,
    LPDWORD lpcbData)
{
    // JonN 2/20/02 Security Push
    if (NULL == m_hKey)
    {
        ASSERT(FALSE);
        return E_FAIL;
    }
    if (   IsBadWritePtr( lpcchValue, sizeof(DWORD) )
        || IsBadWritePtr( lpszValue, (*lpcchValue) * sizeof(TCHAR) ) )
    {  // lpdwType, lpbData, lpcbData may be NULL
        ASSERT(FALSE);
        return E_POINTER;
    }

    m_lastError = ::RegEnumValue(m_hKey, iValue, lpszValue, lpcchValue,
                                 NULL, lpdwType, lpbData, lpcbData);
    // JonN 2/20/02 Security Push: handle ERROR_MORE_DATA properly
    if ( m_lastError != ERROR_SUCCESS
      && m_lastError != ERROR_MORE_DATA
      && m_lastError != ERROR_NO_MORE_ITEMS )
    {
        TRACE("CRegKey error %ld enumerating value %i of key 0x%x\n",
            m_lastError, iValue, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }

    return m_lastError;
}


//____________________________________________________________________________
//
//  Member:     CRegKey::SaveKey
//
//  Synopsis:   Same meaning as for RegSaveKey API.
//
//  Arguments:  [lpszFile] -- IN filename to save to.
//              [lpsa] -- IN security structure
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

void
CRegKey::SaveKey(
    LPCTSTR                lpszFile,
    LPSECURITY_ATTRIBUTES  lpsa)
{
    ASSERT(lpszFile != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegSaveKey(m_hKey, lpszFile, lpsa);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld saving key 0x%x to file \"%s\"\n",
            m_lastError, m_hKey, lpszFile);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::RestoreKey
//
//  Synopsis:   Same meaning as for RegRestoreKey API.
//
//  Arguments:  [lpszFile] -- IN filename containing saved tree
//              [fdw] -- IN optional flags
//
//  Returns:    void
//
//  History:    6/6/1996   RaviR   Created
//
//____________________________________________________________________________
//

void
CRegKey::RestoreKey(
    LPCTSTR     lpszFile,
    DWORD       fdw)
{
    ASSERT(lpszFile != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegRestoreKey(m_hKey, lpszFile, fdw);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld restoring key 0x%x from file \"%s\"\n",
            m_lastError, m_hKey, lpszFile);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


//____________________________________________________________________________
//
//  Member:     CRegKey::NTRegDeleteKey, static
//
//  Synopsis:   Recursively deletes all the sub keys & finally the
//              given start key itself.
//
//  Arguments:  [hStartKey] -- IN
//              [pKeyName] -- IN
//
//  Returns:    LONG.
//
//  History:    5/22/1996   RaviR   Created
//
//____________________________________________________________________________

LONG
CRegKey::NTRegDeleteKey(
    HKEY        hStartKey,
    LPCTSTR     pKeyName)
{
    ASSERT(pKeyName != NULL);
    ASSERT(*pKeyName != TEXT('\0'));

    DWORD        dwSubKeyLength;
    TCHAR        szSubKey[MAX_PATH+2];
    HKEY         hKey;
    LONG         lr = ERROR_SUCCESS;

    lr = ::RegOpenKeyEx(hStartKey, pKeyName, 0, KEY_ALL_ACCESS, &hKey);

    if (lr != ERROR_SUCCESS)
    {
        return lr;
    }

    while (lr == ERROR_SUCCESS)
    {
        dwSubKeyLength = MAX_PATH;

        lr = ::RegEnumKeyEx(hKey, 0, szSubKey, &dwSubKeyLength,
                            NULL, NULL, NULL, NULL);

        if (lr == ERROR_NO_MORE_ITEMS)
        {
            lr = ::RegCloseKey(hKey);

            if (lr == ERROR_SUCCESS)
            {
                lr = ::RegDeleteKey(hStartKey, pKeyName);
                break;
            }
        }
        else if (lr == ERROR_SUCCESS)
        {
            lr = NTRegDeleteKey(hKey, szSubKey);
        }
        else
        {
            // Dont reset lr here!
            ::RegCloseKey(hKey);
        }
    }

    return lr;
}



////////////////////////////////////////////////////////////////////////////
//
//      CRegKey formerly inline methods
//


CRegKey::CRegKey(HKEY hKey)
    :
    m_hKey(hKey),
    m_lastError(ERROR_SUCCESS)
{
    ;
}


CRegKey::~CRegKey()
{
    if (m_hKey != NULL)
    {
        this->CloseKey();
    }
}


HKEY CRegKey::AttachKey(HKEY hKey)
{
    HKEY hKeyOld = m_hKey;

    m_hKey = hKey;
    m_lastError = ERROR_SUCCESS;

    return hKeyOld;
}


void CRegKey::DeleteValue(LPCTSTR lpszValueName)
{
    ASSERT(m_hKey); // Key probably not opened or failed to open

    m_lastError = ::RegDeleteValue(m_hKey, lpszValueName);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld deleting value \"%s\" from key 0x%x \n",
            m_lastError, lpszValueName, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


void CRegKey::FlushKey(void)
{
    ASSERT(m_hKey);

    m_lastError = ::RegFlushKey(m_hKey);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld flushing key 0x%x \n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


void CRegKey::SetString(LPCTSTR lpszValueName, LPCTSTR lpszString)
{
    ASSERT(lpszString);

// NATHAN CHECK
#ifndef UNICODE
//#error This will not work without UNICODE
#endif
    this->SetValueEx(lpszValueName, REG_SZ, lpszString, lstrlen(lpszString)*sizeof(TCHAR));
}


void CRegKey::SetString(LPCTSTR lpszValueName, CStr& str)
{
    this->SetValueEx(lpszValueName, REG_SZ, (LPCTSTR)str, (DWORD) str.GetLength());
}


void CRegKey::SetDword(LPCTSTR lpszValueName, DWORD dwData)
{
    this->SetValueEx(lpszValueName, REG_DWORD, &dwData, sizeof(DWORD));
}


void CRegKey::ConnectRegistry(LPTSTR pszComputerName, HKEY hKey)
{
    ASSERT(pszComputerName != NULL);
    ASSERT(hKey == HKEY_LOCAL_MACHINE || hKey == HKEY_USERS);
    ASSERT(m_hKey == NULL);

    m_lastError = ::RegConnectRegistry(pszComputerName, hKey, &m_hKey);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld connecting to key 0x%x on remote machine \"%s\"\n",
            m_lastError, m_hKey, pszComputerName);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}


void CRegKey::SetKeySecurity(SECURITY_INFORMATION SecInf,
                             PSECURITY_DESCRIPTOR pSecDesc)
{
    ASSERT(pSecDesc != NULL);
    ASSERT(m_hKey != NULL);

    m_lastError = ::RegSetKeySecurity(m_hKey, SecInf, pSecDesc);

    if (m_lastError != ERROR_SUCCESS)
    {
        TRACE("CRegKey error %ld setting security on key 0x%x \n",
            m_lastError, m_hKey);
        AfxThrowOleException(PACKAGE_NOT_FOUND);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\guidhelp.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       guidhelp.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    9/18/1996   JonN    Created
//
//____________________________________________________________________________


#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"


#ifndef DECLSPEC_UUID
#if _MSC_VER >= 1100
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif
#include <mmc.h>
#include "guidhelp.h"

#include "atlbase.h" // USES_CONVERSION

#include "macros.h"
USE_HANDLE_MACROS("GUIDHELP(guidhelp.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


static CLIPFORMAT g_CFNodeType = 0;
static CLIPFORMAT g_CFSnapInCLSID = 0;  
static CLIPFORMAT g_CFDisplayName = 0;


HRESULT ExtractData( IDataObject* piDataObject,
                     CLIPFORMAT cfClipFormat,
                     PVOID        pbData,
                     DWORD        cbData )
{
    TEST_NONNULL_PTR_PARAM( piDataObject );
    TEST_NONNULL_PTR_PARAM( pbData );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            // JonN Jan 7 1999: don't assert here, some errors are perfectly reasonable
            break;
        }
        
        PVOID pbNewData = reinterpret_cast<PVOID>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
        //VERIFY( stgmedium.hGlobal);
        VERIFY( NULL == ::GlobalFree(stgmedium.hGlobal) );
    }
    return hr;
} // ExtractData()


HRESULT ExtractString( IDataObject* piDataObject,
                       CLIPFORMAT cfClipFormat,
                       CStr*     pstr,           // OUT: Pointer to CStr to store data
                       DWORD        cchMaxLength)
{
    TEST_NONNULL_PTR_PARAM( piDataObject );
    TEST_NONNULL_PTR_PARAM( pstr );
    ASSERT( cchMaxLength > 0 );

    HRESULT hr = S_OK;
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, sizeof(WCHAR)*cchMaxLength);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            ASSERT(FALSE);
            ////AfxThrowMemoryException();
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            // This failure happens when 'searching' for
            // clipboard format supported by the IDataObject.
            // t-danmo (24-Oct-96)
            // Skipping ASSERT( FALSE );
            break;
        }
        
        LPWSTR pszNewData = reinterpret_cast<LPWSTR>(stgmedium.hGlobal);
        if (NULL == pszNewData)
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
            break;
        }
        pszNewData[cchMaxLength-1] = L'\0'; // just to be safe
        USES_CONVERSION;
        *pstr = OLE2T(pszNewData);
    } while (FALSE); // false loop

    if (NULL != stgmedium.hGlobal)
    {
        VERIFY(NULL == ::GlobalFree(stgmedium.hGlobal));
    }
    return hr;
} // ExtractString()


HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
	if( !g_CFSnapInCLSID )
	{
		USES_CONVERSION;
		g_CFSnapInCLSID = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID));
		// ISSUE-2002/04/01-JonN ASSERT(NULL != g_CFSnapInCLSID)
	}

    return ExtractData( piDataObject, g_CFSnapInCLSID, (PVOID)pclsidSnapin, sizeof(CLSID) );
}

HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
	if( !g_CFNodeType )
	{
		USES_CONVERSION;
		g_CFNodeType = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_NODETYPE));
		// ISSUE-2002/04/01-JonN ASSERT(NULL != g_CFSnapInCLSID)
	}

    return ExtractData( piDataObject, g_CFNodeType, (PVOID)pguidObjectType, sizeof(GUID) );
}

HRESULT GuidToCStr( CStr* pstr, const GUID& guid )
{
    WCHAR awch[MAX_PATH];
    // ISSUE-2002/04/01-JonN call ZeroMemory
    HRESULT hr = StringFromGUID2(guid, awch, MAX_PATH); // JonN 11/21/00 PREFIX 226769
    ASSERT(SUCCEEDED(hr));
    USES_CONVERSION;
    LPTSTR lptstr = OLE2T(awch);
    *pstr = lptstr;
    return hr;
}

HRESULT CStrToGuid( const CStr& str, GUID* pguid )
{
    USES_CONVERSION;
    LPOLESTR lpolestr = T2OLE(((LPTSTR)(LPCTSTR)str));
    HRESULT hr = CLSIDFromString(lpolestr, pguid);
    ASSERT(SUCCEEDED(hr));
    return hr;
}

#if 0
HRESULT bstrToGuid( const bstr& str, GUID* pguid )
{
    HRESULT hr = CLSIDFromString(const_cast<LPOLESTR>((LPCWSTR)str), pguid);
    ASSERT(SUCCEEDED(hr));
    return hr;
}
#endif

HRESULT LoadRootDisplayName(IComponentData* pIComponentData, 
                            CStr& strDisplayName)
{
    // ISSUE-2002/04/01-JonN test pIComponentData
    IDataObject* pIDataObject = NULL;
    HRESULT hr = pIComponentData->QueryDataObject(NULL, CCT_SNAPIN_MANAGER, &pIDataObject);
    CHECK_HRESULT(hr);
    if ( FAILED(hr) )
        return hr;

    if( !g_CFDisplayName )
	{
		USES_CONVERSION;
		g_CFDisplayName = (CLIPFORMAT)RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME));
		// ISSUE-2002/04/01-JonN ASSERT(NULL != g_CFSnapInCLSID)
	}

    hr = ExtractString( pIDataObject,
                        g_CFDisplayName,
                        &strDisplayName,
                        MAX_PATH); // CODEWORK maximum length
    CHECK_HRESULT(hr);

    if (pIDataObject) pIDataObject->Release(); // JonN 3/28/02

    return hr;
}


HRESULT LoadAndAddMenuItem(
    IContextMenuCallback* pIContextMenuCallback,
    UINT nResourceID, // contains text and status text seperated by '\n'
    long lCommandID,
    long lInsertionPointID,
    long fFlags,
    HINSTANCE hInst,
    PCTSTR pszLanguageIndependentName)
{
    // ISSUE-2002/04/01-JonN handle these cases
    ASSERT( pIContextMenuCallback != NULL );
    ASSERT( pszLanguageIndependentName != NULL );

    CComPtr<IContextMenuCallback2> spiCallback2;
    HRESULT hr = pIContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void **)&spiCallback2);
    if (FAILED(hr))
        return hr;

    // load the resource
    CStr strText;
    strText.LoadString(hInst,  nResourceID );
    ASSERT( !strText.IsEmpty() );

    // split the resource into the menu text and status text
    CStr strStatusText;
    int iSeparator = strText.Find(_T('\n'));
    if (0 > iSeparator)
    {
        ASSERT( FALSE );
        strStatusText = strText;
    }
    else
    {
        strStatusText = strText.Right( strText.GetLength()-(iSeparator+1) );
        strText = strText.Left( iSeparator );
    }

    // add the menu item
    USES_CONVERSION;
    CONTEXTMENUITEM2 contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strText));
    contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusText));
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = fFlags;
    contextmenuitem.fSpecialFlags = ((fFlags & MF_POPUP) ? CCM_SPECIAL_SUBMENU : 0L);
    contextmenuitem.strLanguageIndependentName = T2OLE(const_cast<LPTSTR>(pszLanguageIndependentName));
    hr = spiCallback2->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);

    return hr;
}

HRESULT AddSpecialSeparator(
    IContextMenuCallback* pIContextMenuCallback,
    long lInsertionPointID )
{
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = 0;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = MF_SEPARATOR;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_SEPARATOR;
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);

    return hr;
}

HRESULT AddSpecialInsertionPoint(
    IContextMenuCallback* pIContextMenuCallback,
    long lCommandID,
    long lInsertionPointID )
{
    // ISSUE-2002/04/01-JonN handle NULL
    CONTEXTMENUITEM contextmenuitem;
    ::ZeroMemory( &contextmenuitem, sizeof(contextmenuitem) );
    contextmenuitem.strName = NULL;
    contextmenuitem.strStatusBarText = NULL;
    contextmenuitem.lCommandID = lCommandID;
    contextmenuitem.lInsertionPointID = lInsertionPointID;
    contextmenuitem.fFlags = 0;
    contextmenuitem.fSpecialFlags = CCM_SPECIAL_INSERTION_POINT;
    HRESULT hr = pIContextMenuCallback->AddItem( &contextmenuitem );
    ASSERT(hr == S_OK);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\regkey.h ===
#ifndef __REGKEY__H__
#define __REGKEY__H__
#include "cstr.h"

#define PACKAGE_NOT_FOUND HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

namespace AMC
{

//____________________________________________________________________________
//
//  Class:      CRegKey
//
//  Purpose:    A wrapper around the RegXXX APIs. Most of the RegXXX APIs
//              have been wrapped in this class.
//
//              The RegXXX APIs NOT wrapped in this class are:
//                      RegLoadKey()
//                      RegNotifyChangeKeyValue()
//                      RegReplaceKey()
//                      RegUnLoadKey()
//
//  History:    5/22/1996   RaviR   Created
//
//  Notes:      This class uses C++ exception handling mechanism to throw
//              most of the errors returned by the RegXXX APIs.  It can throw
//              CMemoryException
//              COleException
//
//  Method          RegXXX API          Comment
//  -----------     ----------------    -------------------------
//
//  CreateKeyEx     RegCreateKeyEx      By default creates a non
//                                      volatile key, with all access
//
//  OpenKeyEx       RegOpenKeyEx        By default opens key with all access.
//                                      Returns FALSE if specified key not
//                                      present.
//
//  ConnectRegistry RegConnectRegistry  By default connects to the given
//                                      computer's HKEY_LOCAL_MACHINE.
//
//  CloseKey        RegCloseKey         -
//
//  DeleteKey           -               Delete all the keys and subkeys,
//                                      using RegDeleteKey.
//
//  SetValueEx      RegSetValueEx       Sets any type of data.
//  SetString           -               Sets string type data.
//  SetDword            -               Sets DWORD type data.
//
//  QueryValueEx    RegQueryValueEx     Query's for any type of data.
//  QueryString         -               Query's for string type data.
//  QueryDword          -               Query's for DWORD type data.
//
//  EnumKeyEx       RegEnumKeyEx        Returns FALSE if no more items present.
//
//  EnumValue       RegEnumValue        Returns ERROR_NO_MORE_ITEMS if no more
//                                      values present, or ERROR_MORE_DATA if
//                                      provided buffer is insufficient.
//
//  GetKeySecurity  RegGetKeySecurity   Returns FALSE on insufficent buffer.
//
//  SetKeySecurity  RegSetKeySecurity   -
//
//  SaveKey         RegSaveKey          -
//
//  RestoreKey      RegRestoreKey       -
//
//____________________________________________________________________________
//

class CRegKey
{
public:
// Constructor & Destructor
    CRegKey(HKEY hKey = NULL);
    ~CRegKey(void);

    BOOL IsNull() { return (m_hKey == NULL); }

// Attributes
    operator    HKEY() { ASSERT(m_hKey); return m_hKey; }
    LONG        GetLastError() { return m_lastError; }

// Operations
    // Attach/Detach
    HKEY AttachKey(HKEY hKey);
    HKEY DetachKey(void) { return AttachKey(NULL); }

    // Open & Create Operations
    void CreateKeyEx(
            HKEY                    hKeyAncestor,
            LPCTSTR                 lpszKeyName,
            REGSAM                  security = KEY_ALL_ACCESS,
            DWORD                 * pdwDisposition = NULL,
            DWORD                   dwOption = REG_OPTION_NON_VOLATILE,
            LPSECURITY_ATTRIBUTES   pSecurityAttributes = NULL);

    BOOL OpenKeyEx(
            HKEY        hKey,
            LPCTSTR     lpszKeyName = NULL,
            REGSAM      security = KEY_ALL_ACCESS);

    // Connect to another machine
    void ConnectRegistry(LPTSTR pszComputerName,
                         HKEY hKey = HKEY_LOCAL_MACHINE);

    // Close & Delete Operations
    void CloseKey(void);

    void DeleteKey(LPCTSTR lpszKeyName);
    void DeleteValue(LPCTSTR lpszValueName);

    // Flush operation
    void FlushKey();

    // Main Access Operations
    void SetValueEx(LPCTSTR lpszValueName, DWORD dwType,
                    const void * pData, DWORD nLen);
    void QueryValueEx(LPCTSTR lpszValueName, LPDWORD pType,
                      PVOID pData, LPDWORD pLen);
    BOOL IsValuePresent(LPCTSTR lpszValueName);

    // Additional string access Operations
    void SetString(LPCTSTR lpszValueName, LPCTSTR lpszString);
    void SetString(LPCTSTR lpszValueName, CStr& str);

    BOOL QueryString(LPCTSTR lpszValueName, LPTSTR pBuffer,
                     DWORD *pdwBufferByteLen, DWORD *pdwType = NULL);
    void QueryString(LPCTSTR lpszValueName, LPTSTR * ppStrValue,
                                        DWORD * pdwType = NULL);
    void QueryString(LPCTSTR lpszValueName, CStr& str,
                                        DWORD * pdwType = NULL);

    // Additional DWORD access Operations
    void SetDword(LPCTSTR lpszValueName, DWORD dwData);
    void QueryDword(LPCTSTR lpszValueName, LPDWORD pdwData);

    // Additional GUID access Operations
    void SetGUID(LPCTSTR lpszValueName, const GUID& guid);
    void QueryGUID(LPCTSTR lpszValueName, GUID* pguid);

    // Iteration Operations
    BOOL EnumKeyEx(DWORD iSubkey, LPTSTR lpszName, LPDWORD lpcchName,
                                        PFILETIME lpszLastModified = NULL);

    HRESULT EnumValue(DWORD iValue, LPTSTR lpszValue, LPDWORD lpcchValue,
                      LPDWORD lpdwType = NULL, LPBYTE lpbData = NULL,
                      LPDWORD lpcbData = NULL);

    // Key Security access
    BOOL GetKeySecurity(SECURITY_INFORMATION SecInf,
                        PSECURITY_DESCRIPTOR pSecDesc, LPDWORD lpcbSecDesc);
    void SetKeySecurity(SECURITY_INFORMATION SecInf,
                        PSECURITY_DESCRIPTOR pSecDesc);

    // Save/Restore to/from a file
    void SaveKey(LPCTSTR lpszFile, LPSECURITY_ATTRIBUTES lpsa = NULL);
    void RestoreKey(LPCTSTR lpszFile, DWORD fdw = 0);


protected:

    // Data
    HKEY    m_hKey;
    LONG    m_lastError;    // error code from last function call

    // implementation helpers
    static LONG  NTRegDeleteKey(HKEY hStartKey, LPCTSTR pKeyName);

}; // class CRegKey

} // AMC namespace

#endif // __REGKEY__H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#define DEB_RESOURCE    DEB_USER10      // Constructor/Destructor
#define DEB_METHOD      DEB_USER11
#define DEB_FUNCTION    DEB_USER12

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1


    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_DESTRUCTOR(cls) \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this);

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this);

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n"));

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __DummyDbg(ULONG, LPCWSTR, ...) { }
    inline void __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __DummyTrace(LPCWSTR, ...) { }
    inline void __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   (e)

    #define ASSERT(e)
    #define VERIFY(e)   (e)

#endif // DBG==1


#if DBG==1 && defined(_NODEMGR_DLL_)

    // Debug instance counter
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    // 591438-2002/04/05 JonN removed wsprintf
    char buf[100];
    VERIFY( SUCCEEDED( StringCchPrintfA(
        buf, ARRAYLEN(buf),
        "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "MMC: Memory Leak!!!", MB_OK);
}

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#endif





#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }


#ifdef DBX
#define DbxAssert(x)    ASSERT(x)
#else
#define DbxAssert(x)
#endif

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\safetemp.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SafeTemp.h
//
//  Contents:   A template for safe pointers.
//
//  Classes:    XSafeInterfacePtr<ISome>
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


//____________________________________________________________________________
//
//  Template:   XSafeInterfacePtr
//
//  Purpose:    Safe pointer to any interface that supports AddRef/Release
//
//  Notes:      This works for classes that define AddRef/Release, or for
//              OLE interfaces. It is not necessary that the class
//              be a derivative of IUnknown, so long as it supports
//              AddRef and Release methods which have the same semantics as
//              those in IUnknown.
//
//              The constructor takes a parameter which specifies whether
//              the captured pointer should be AddRef'd, defaulting to TRUE.
//
//              The Copy function creates a valid additional copy of
//              the captured pointer (following the AddRef/Release protocol)
//              so can be used to hand out copies from a safe pointer declared
//              as a member of some other class.
//
//              The 'Transfer' function transfers the interface pointer, and
//              invalidates its member value (by setting it to NULL).
//
//              To release the existing interface ptr and set it to a new
//              instance use the 'Set' member fuction. This method takes a
//              parameter which specifies whether the new pointer should be
//              AddRef'd, defaulting to TRUE.
//
//              The following methods manipulate the interface pointer with
//              out following the AddRef/Release protocol: Transfer, Attach
//              and Detach.
//
//  History:    6/3/1996   RaviR   Created
//____________________________________________________________________________
//


template<class ISome>
class XSafeInterfacePtr
{
public:

    inline XSafeInterfacePtr(ISome * pinter=NULL, BOOL fInc=TRUE)
        : _p ( pinter )
    {
        if (fInc && (_p != NULL))
        {
            _p->AddRef();
        }
    }

    inline ~XSafeInterfacePtr()
    {
        if (_p != NULL)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline BOOL IsNull(void)
    {
        return (_p == NULL);
    }

    inline void Copy(ISome **pxtmp)
    {
        *pxtmp = _p;
        if (_p != NULL)
            _p->AddRef();
    }

    inline void Transfer(ISome **pxtmp)
    {
        *pxtmp = _p;
        _p = NULL;
    }

    inline void Set(ISome* p, BOOL fInc = TRUE)
    {
        if (_p)
        {
            _p->Release();
        }
        _p = p;
        if (fInc && _p)
        {
            _p->AddRef();
        }
    }

    inline void SafeRelease(void)
    {
        if (_p)
        {
            _p->Release();
            _p = NULL;
        }
    }

    inline void SimpleRelease(void)
    {
        ASSERT(_p != NULL);
        _p->Release();
        _p = NULL;
    }

    inline void Attach(ISome* p)
    {
        ASSERT(_p == NULL);
        _p = p;
    }

    inline void Detach(void)
    {
        _p = NULL;
    }

    inline ISome * operator-> () { return _p; }

    inline ISome& operator * () { return *_p; }

    inline operator ISome *() { return _p; }

    inline ISome ** operator &()
    {
        ASSERT( _p == NULL );
        return &_p;
    }

    inline ISome *Self(void) { return _p; }

private:

    ISome * _p;

    inline  void operator= (const XSafeInterfacePtr &) {;}

    inline  XSafeInterfacePtr(const XSafeInterfacePtr &){;}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\strings.cpp ===
#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

EXTERN_C const TCHAR g_szCLSID[] = TEXT("CLSID");
EXTERN_C const TCHAR g_szContextMenu[] = TEXT("ContextMenu");
EXTERN_C const TCHAR g_szDynamicExtensions[] = TEXT("DynamicExtensions");
EXTERN_C const TCHAR g_szImage[] = TEXT("Image");
EXTERN_C const TCHAR g_szImageOpen[] = TEXT("ImageOpen");
EXTERN_C const TCHAR g_szImageClosed[] = TEXT("ImageClosed");
EXTERN_C const TCHAR g_szName[] = TEXT("Name");
EXTERN_C const TCHAR g_szNameString[] = TEXT("NameString");
EXTERN_C const TCHAR g_szObject[] = TEXT("Object");
EXTERN_C const TCHAR g_szObjects[] = TEXT("Objects");
EXTERN_C const TCHAR g_szObjectType[] = TEXT("ObjectType");
EXTERN_C const TCHAR g_szObjectTypes[] = TEXT("ObjectTypes");
EXTERN_C const TCHAR g_szObjectTypeGUID[] = TEXT("ObjectTypeGUID");
EXTERN_C const TCHAR g_szObjectContext[] = TEXT("ObjectContext");
EXTERN_C const TCHAR g_szPackage[] = TEXT("Package");
EXTERN_C const TCHAR g_szResultPane[] = TEXT("ResultPane");
EXTERN_C const TCHAR g_szStatus[] = TEXT("Status");
EXTERN_C const TCHAR g_szStatusString[] = TEXT("StatusString");
EXTERN_C const TCHAR g_szTree[] = TEXT("Tree");
EXTERN_C const TCHAR g_szNameSpace[] = TEXT("NameSpace");
EXTERN_C const TCHAR g_szNodeType[] = TEXT("NodeType");
EXTERN_C const TCHAR g_szNodeTypes[] = TEXT("NodeTypes");
EXTERN_C const TCHAR g_szPropertySheet[] = TEXT("PropertySheet");
EXTERN_C const TCHAR g_szStandAlone[] = TEXT("StandAlone");
EXTERN_C const TCHAR g_szToolbar[] = TEXT("Toolbar");
EXTERN_C const TCHAR g_szExtensions[] = TEXT("Extensions");

EXTERN_C const TCHAR CURRENT_VER_KEY[] = _TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
EXTERN_C const TCHAR NODE_TYPES_KEY[] = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
EXTERN_C const TCHAR SNAPINS_KEY[] = TEXT("Software\\Microsoft\\MMC\\SnapIns");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\sources.inc ===
#
# This sources file is included in every sources file for this
#  project

INCLUDES=$(BASE_INCLUDES);  \
         $(SHELL_INC_PATH); \
         $(DS_INC_PATH);    \
         $(NET_INC_PATH);   \
         $(WINDOWS_INC_PATH)

C_DEFINES=  $(C_DEFINES) -DUNICODE -D_UNICODE

USE_NATIVE_EH=1
USE_MSVCRT=1
USE_ATL=1
USE_STL=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\strings.h ===
EXTERN_C const TCHAR g_szCLSID[];
EXTERN_C const TCHAR g_szContextMenu[];
EXTERN_C const TCHAR g_szDynamicExtensions[];
EXTERN_C const TCHAR g_szImage[];
EXTERN_C const TCHAR g_szImageOpen[];
EXTERN_C const TCHAR g_szImageClosed[];
EXTERN_C const TCHAR g_szName[];
EXTERN_C const TCHAR g_szNameString[];
EXTERN_C const TCHAR g_szObject[];
EXTERN_C const TCHAR g_szObjects[];
EXTERN_C const TCHAR g_szObjectType[];
EXTERN_C const TCHAR g_szObjectTypes[];
EXTERN_C const TCHAR g_szObjectTypeGUID[];
EXTERN_C const TCHAR g_szObjectContext[];
EXTERN_C const TCHAR g_szPackage[];
EXTERN_C const TCHAR g_szResultPane[];
EXTERN_C const TCHAR g_szStatus[];
EXTERN_C const TCHAR g_szStatusString[];
EXTERN_C const TCHAR g_szTree[];
EXTERN_C const TCHAR g_szNameSpace[];
EXTERN_C const TCHAR g_szNodeType[];
EXTERN_C const TCHAR g_szNodeTypes[];
EXTERN_C const TCHAR g_szPropertySheet[];
EXTERN_C const TCHAR g_szStandAlone[];
EXTERN_C const TCHAR g_szToolbar[];
EXTERN_C const TCHAR g_szExtensions[];


EXTERN_C const TCHAR NODE_TYPES_KEY[];
EXTERN_C const TCHAR SNAPINS_KEY[];
EXTERN_C const TCHAR CURRENT_VER_KEY[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\util.h ===
#include "cstr.h"

HRESULT GUIDToCStr(CStr& str, const GUID& guid);
HRESULT GUIDFromCStr(const CStr& str, GUID* pguid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\dfsdebug.h ===
#ifndef _DFSDEBUG_H_
#define _DFSDEBUG_H_

#ifdef DEBUG

#include <stdio.h>
#include <stdarg.h>

#define DECLARE_INFOLEVEL(comp) \
        extern unsigned long comp##InfoLevel = DEF_INFOLEVEL;

#define DECLARE_DEBUG(comp) \
    extern unsigned long comp##InfoLevel; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, TCHAR *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            TCHAR acsString[1000];\
            va_list va; \
            va_start(va, pszfmt);\
            _vsntprintf(acsString, 999, pszfmt, va); \
            acsString[999] = _T('\0'); \
            va_end(va);\
            OutputDebugString(acsString);\
        } \
    }\
    _inline void \
    comp##InlineDebugOut( TCHAR *pszfmt, ...) \
    { \
        if ( TRUE ) \
        { \
            TCHAR acsString[1000];\
            va_list va; \
            va_start(va, pszfmt);\
            _vsntprintf(acsString, 999, pszfmt, va); \
            acsString[999] = _T('\0'); \
            va_end(va);\
            OutputDebugString(acsString);\
        } \
    }

#else  // DEBUG

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)

#endif // DEBUG

DECLARE_DEBUG(dfs);

#ifdef DEBUG
    #define dfsDebugOut( x ) dfsInlineDebugOut x
#else  // DEBUG
    #define dfsDebugOut( x ) ((void)0)
#endif // DEBUG

int
mylstrncmp(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
);

int
mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
);

#define PROPSTRNOCHNG(str1, str2)   (str1 && str2 && !lstrcmp(str1, str2) || \
                                    !str1 && str2 && !*str2 || \
                                     str1 && !*str1 && !str2 || \
                                    !str1 && !str2)

#define RETURN_OUTOFMEMORY_IF_NULL(ptr)         if (NULL == (ptr)) return E_OUTOFMEMORY
#define BREAK_OUTOFMEMORY_IF_NULL(ptr, phr)     if (NULL == (ptr)) { *phr = E_OUTOFMEMORY; break; }
#define RETURN_INVALIDARG_IF_TRUE(bVal)         if (bVal) return E_INVALIDARG
#define RETURN_INVALIDARG_IF_NULL(ptr)          if (NULL == (ptr)) return E_INVALIDARG
#define RETURN_IF_FAILED(hr)                    if (FAILED(hr)) return (hr)
#define BREAK_IF_FAILED(hr)                     if (FAILED(hr)) break
#define RETURN_IF_NOT_S_OK(hr)                  if (S_OK != hr) return (hr)
#define BREAK_IF_NOT_S_OK(hr)                   if (S_OK != hr) break

#define GET_BSTR(i_ccombstr, o_pbstr)       \
    RETURN_INVALIDARG_IF_NULL(o_pbstr);    \
	*o_pbstr = i_ccombstr.Copy();           \
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstr);   \
    return S_OK

#endif // _DFSDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\corecopy\util.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       util.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    7/8/1996   RaviR   Created
//
//____________________________________________________________________________

#include <objbase.h>
#include <basetyps.h>
#include "dbg.h"
#include "cstr.h"
#include <Atlbase.h>
#include <winnls.h>

//+---------------------------------------------------------------------------
//
//  Function:   GUIDToString
//              GUIDFromString
//
//  Synopsis:   Converts between GUID& and CStr
//
//  Returns:    FALSE for invalid string, or CMemoryException
//
//+---------------------------------------------------------------------------

HRESULT GUIDToCStr(CStr& str, const GUID& guid)
{
	LPOLESTR lpolestr = NULL;
	HRESULT hr = StringFromIID( guid, &lpolestr );
    if (FAILED(hr))
	{
		TRACE("GUIDToString error %ld\n", hr);
		return hr;
	}
	else
	{
		str = lpolestr;
		CoTaskMemFree(lpolestr);
	}
	return hr;
}

HRESULT GUIDFromCStr(const CStr& str, GUID* pguid)
{
	USES_CONVERSION;

	HRESULT hr = IIDFromString( T2OLE( const_cast<LPTSTR>((LPCTSTR)str) ), pguid );
    if (FAILED(hr))
	{
		TRACE("GUIDFromString error %ld\n", hr);
	}
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\ldaputils.h ===
/*++
Module Name:

LDAPUtils.h

Abstract:
  This is the header file for the LDAP utility functions.

*/


#ifndef _LDAPUTILS_H
#define _LDAPUTILS_H

#include <stdafx.h>
#include <winldap.h>    // For LDAP APIs.
#include <ntdsapi.h>
#include <schedule.h>

              // Defines Values;

#define MAX_RDN_KEY_SIZE            64   // ds\src\inc\ntdsa.h
#define CN_SYSTEM                       _T("System")
#define CN_FRS                          _T("File Replication Service")
#define CN_DFSVOLUMES                   _T("DFS Volumes")
#define CN_NTFRSSUBSCRIPTIONS           _T("NTFRS Subscriptions")
#define CN_DFSCONFIGURATION             _T("Dfs-Configuration")
#define CN_COMPUTERS                    _T("Computers")
#define CN_DFSVOLUMES_PREFIX            _T(",CN=DFS Volumes,CN=File Replication Service,CN=System")
#define CN_DFSVOLUMES_PREFIX_COMMA      _T(",CN=DFS Volumes,CN=File Replication Service,CN=System,")

#define OBJCLASS_ATTRIBUTENAME          _T("objectClass")

typedef enum  LDAP_ENTRY_ACTION
{
  ADD_VALUE    = 0,
  MODIFY_VALUE,
  DELETE_VALUE
};

typedef struct _LDAPNAME
{
  CComBSTR    bstrLDAPName;
  _LDAPNAME    *Next;

  _LDAPNAME():Next(NULL)
  {
  }

}  LDAPNAME,    *PLDAPNAME;

              // This holds a linked list of LDAP attributes and value.
              // Used in ldap_add, ldap_modify etc.
typedef struct _LDAP_ATTR_VALUE
{
  CComBSTR      bstrAttribute;    // Attribute name.
  void*        vpValue;      // Pointer to value buffer, void pointer to handle char as
                      // well as binary values.
  BOOLEAN        bBerValue;      // Is this a BerValue?
  ULONG        ulLength;      // Size of a BerValue;
  _LDAP_ATTR_VALUE*  Next;        // The bBerValue fields of the structures other than 
                      // the head of the list are ignored.

  _LDAP_ATTR_VALUE():
    vpValue(NULL),
    bBerValue(false),
    ulLength(0),
    Next(NULL)
  {
  }

}  LDAP_ATTR_VALUE, *PLDAP_ATTR_VALUE;

typedef struct _LDAPLLIST
{
  PLDAP_ATTR_VALUE  pAttrValues;
  _LDAPLLIST        *Next;

  _LDAPLLIST():Next(NULL)
  {
  }

}  LDAPLLIST,    *PLDAPLLIST;

typedef struct _LLISTELEM
{
  PTSTR**            pppszAttrValues;
  _LLISTELEM        *Next;

  _LLISTELEM(PTSTR** pppszValues):
        pppszAttrValues(pppszValues),
        Next(NULL)
  {
  }

  ~_LLISTELEM()
  {
      PTSTR** pppszValues = pppszAttrValues;
      while (*pppszValues)
          ldap_value_free(*pppszValues++);

      free(pppszAttrValues);
  }
} LListElem;

HRESULT FreeLDAPNamesList
(
  IN PLDAPNAME    i_pLDAPNames        // pointer to list to be freed.
);  

HRESULT FreeAttrValList
(
  IN PLDAP_ATTR_VALUE    i_pAttrVals        // pointer to list to be freed.
);  
      // Connect To DS (LDAP)
HRESULT ConnectToDS
(
  IN  PCTSTR    i_lpszDomainName,  // DNS or non DNS format.
  OUT PLDAP    *o_ppldap,
  OUT BSTR*     o_pbstrDC = NULL
);

      // Close connection to DS
HRESULT CloseConnectionToDS
(
  IN PLDAP    i_pldap      
);

      // Gets Values for an attribute from an LDAP Object.
HRESULT GetValues 
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_lpszBase,
    IN PCTSTR               i_lpszSearchFilter,
    IN ULONG                i_ulScope,
    IN ULONG                i_ulAttrCount,
    IN LDAP_ATTR_VALUE      i_pAttributes[],
    OUT PLDAP_ATTR_VALUE    o_ppValues[]
);

void FreeLListElem(LListElem* pElem);

HRESULT GetValuesEx 
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_pszBase,
    IN ULONG                i_ulScope,
    IN PCTSTR               i_pszSearchFilter,
    IN PCTSTR               i_pszAttributes[],
    OUT LListElem**         o_ppElem
);

      //  Gets the DNs of all children of a DS object.
HRESULT GetChildrenDN
(
    IN PLDAP        i_pldap,
    IN LPCTSTR      i_lpszBase,
    IN ULONG        i_ulScope,
    IN LPTSTR       i_lpszChildObjectClass,
    OUT PLDAPNAME*  o_ppDistNames
);


      // Internal function to prepare LDAPMod
HRESULT PrepareLDAPMods
(
  IN LDAP_ATTR_VALUE    i_pAttrValue[],
  IN LDAP_ENTRY_ACTION  i_AddModDel,
  IN ULONG        i_ulCountOfVals,
  OUT LDAPMod*      o_ppModVals[]
);


      // Adds a new record or values.
HRESULT AddValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  OUT LDAP_ATTR_VALUE  i_pAttrValue[],
  IN BSTR               i_bstrDC = NULL
);

      // Modifies an existing record or values.
HRESULT ModifyValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  OUT LDAP_ATTR_VALUE  i_pAttrValue[]
);

      // Deletes values from an existing record or values.
HRESULT DeleteValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE  i_pAttrValue[]
);

      // Deletes an object from DS.
HRESULT DeleteDSObject
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN bool         i_bDeleteRecursively = true
);

      // Free ModVals.
HRESULT FreeModVals
(
    IN OUT LDAPMod ***io_pppMod
);

      // Gets a string corresponding to the ldap error code.
LPTSTR ErrorString
(
  DWORD          i_ldapErrCode
);

// Checks if an object with given DN exists.
HRESULT IsValidObject
(
  IN PLDAP        i_pldap,
  IN BSTR          i_bstrObjectDN
);

// Gets the DN of an object given old style name.
HRESULT  CrackName(
  IN  HANDLE          i_hDS,
  IN  LPTSTR          i_lpszOldTypeName,
  IN  DS_NAME_FORMAT  i_formatIn,
  IN  DS_NAME_FORMAT  i_formatdesired,
  OUT BSTR*           o_pbstrResult
);

// return S_FALSE if it's not NT5 domain
HRESULT  GetDomainInfo(
  IN  LPCTSTR         i_bstrDomain,
  OUT BSTR*           o_pbstrDC = NULL,            // return DC's Dns name
  OUT BSTR*           o_pbstrDomainDnsName = NULL, // return Domain's Dns name
  OUT BSTR*           o_pbstrDomainDN = NULL,      // return DC=nttest,DC=microsoft,DC=com
  OUT BSTR*           o_pbstrLDAPDomainPath = NULL,// return LDAP://<DC>/<DomainDN>
  OUT BSTR*           o_pbstrDomainGuid = NULL     // return Domain's guid
);

void
DebugOutLDAPError(
    IN PLDAP  i_pldap,
    IN ULONG  i_ulError,
    IN PCTSTR i_pszLDAPFunctionName
);

HRESULT ExtendDN
(
  IN  LPTSTR            i_lpszCN,
  IN  LPTSTR            i_lpszDN,
  OUT BSTR              *o_pbstrNewDN
);

HRESULT ExtendDNIfLongJunctionName
(
  IN  LPTSTR            i_lpszJunctionName,
  IN  LPCTSTR           i_lpszBaseDN,
  OUT BSTR              *o_pbstrNewDN
);

HRESULT GetJunctionPathPartitions
(
  OUT PVOID             *o_ppBuffer,
  OUT DWORD             *o_pdwEntries,
  IN  LPCTSTR           i_pszJunctionPath
);

HRESULT CreateExtraNodesIfLongJunctionName
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszJunctionName,
  IN LPCTSTR            i_lpszBaseDN,
  IN LPCTSTR            i_lpszObjClass
);

HRESULT DeleteExtraNodesIfLongJunctionName
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszJunctionName,
  IN LPCTSTR            i_lpszDN
);

HRESULT CreateObjectSimple
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszDN,
  IN LPCTSTR            i_lpszObjClass
);

HRESULT CreateObjectsRecursively
(
  IN PLDAP              i_pldap,
  IN BSTR               i_bstrDN,
  IN UINT               i_nLenPrefix,
  IN LPCTSTR            i_lpszObjClass
);

HRESULT DeleteAncestorNodesIfEmpty
(
  IN PLDAP              i_pldap,
  IN LPCTSTR            i_lpszDN,
  IN DWORD              i_dwCount
);

// Replace all occurences of '\' with '|' in the given string.
HRESULT ReplaceChar
(
  IN OUT  BSTR          io_bstrString, 
  IN      TCHAR         i_cOldChar,
  IN      TCHAR         i_cNewChar
);

HRESULT GetDfsLinkNameFromDN(
    IN  BSTR    i_bstrReplicaSetDN, 
    OUT BSTR*   o_pbstrDfsLinkName
    );

HRESULT GetSubscriberDN(
    IN  BSTR    i_bstrReplicaSetDN,
    IN  BSTR    i_bstrDomainGuid,
    IN  BSTR    i_bstrComputerDN,
    OUT BSTR*   o_pbstrSubscriberDN
    );

HRESULT CreateNtfrsMemberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrComputerDN,
    IN BSTR     i_bstrDCofComputerObj
    );

HRESULT CreateNtfrsSubscriberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrRootPath,
    IN BSTR     i_bstrStagingPath,
    IN BSTR     i_bstrDC
    );

HRESULT CreateNtdsConnectionObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrConnectionDN,
    IN BSTR     i_bstrFromMemberDN,
    IN BOOL     i_bEnable,
    IN DWORD    i_dwOptions
    );

HRESULT CreateNtfrsSettingsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    );

HRESULT DeleteNtfrsReplicaSetObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    );

HRESULT CreateNtfrsSubscriptionsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    );

HRESULT DeleteNtfrsSubscriberObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    );

HRESULT DeleteDSObjectsIfEmpty(
    IN PLDAP    i_pldap,
    IN LPCTSTR  i_lpszDN,
    IN int      i_nPrefixLength
);

HRESULT SetConnectionSchedule(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrConnectionDN,
    IN SCHEDULE*    i_pSchedule);

HRESULT SetConnectionOptions(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrConnectionDN,
    IN DWORD        i_dwOptions);

HRESULT UuidToStructuredString(
    UUID*  i_pUuid,
    BSTR*  o_pbstr
);

HRESULT ScheduleToVariant(
    IN  SCHEDULE*   i_pSchedule,
    OUT VARIANT*    o_pVar
    );

HRESULT VariantToSchedule(
    IN  VARIANT*    i_pVar,
    OUT PSCHEDULE*  o_ppSchedule
    );

HRESULT CompareSchedules(
    IN  SCHEDULE*  i_pSchedule1,
    IN  SCHEDULE*  i_pSchedule2
    );

HRESULT CopySchedule(
    IN  SCHEDULE*  i_pSrcSchedule,
    OUT PSCHEDULE* o_ppDstSchedule
    );

HRESULT GetDefaultSchedule(
    OUT PSCHEDULE* o_ppSchedule
    );

HRESULT GetSchemaVersion(IN PLDAP    i_pldap);

HRESULT GetSchemaVersionEx(
    IN BSTR i_bstrName,
    IN BOOL i_bServer = TRUE // TRUE if i_bstrName is a server, FALSE if i_bstrName is a domain
    );

HRESULT LdapConnectToDC(IN LPCTSTR i_pszDC, OUT PLDAP* o_ppldap);

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT BSTR*        o_pbstrErrorMsg
);

HRESULT
FormatMessageString(
  OUT BSTR *o_pbstrMsg,
  IN  DWORD dwErr,
  IN  UINT  iStringId,
  ...);

HRESULT DsBindToDS(BSTR i_bstrDomain, BSTR *o_pbstrDC, HANDLE *o_phDS);

#ifdef DEBUG
void PrintTimeDelta(LPCTSTR pszMsg, SYSTEMTIME* pt0, SYSTEMTIME* pt1);
#endif // DEBUG

#endif //#ifndef _LDAPUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\dfsenums.h ===
#ifndef _DFS_ENUMS_H
#define _DFS_ENUMS_H

#define WM_PARENT_NODE_CLOSING  (WM_USER + 1)

//Dfs Root Type Enums
enum DFS_TYPE           {
                        DFS_TYPE_UNASSIGNED = 0, 
                        DFS_TYPE_FTDFS,
                        DFS_TYPE_STANDALONE
                        };

//Dfs JunctionPoint State Enums
enum DFS_JUNCTION_STATE {
                        DFS_JUNCTION_STATE_UNASSIGNED = 0,
                        DFS_JUNCTION_STATE_ALL_REP_OK,
                        DFS_JUNCTION_STATE_NOT_ALL_REP_OK,
                        DFS_JUNCTION_STATE_UNREACHABLE
                        };

//Dfs Target State Enums
enum DFS_REFERRAL_STATE {
                        DFS_REFERRAL_STATE_ONLINE = 0,
                        DFS_REFERRAL_STATE_OFFLINE
                        };

enum DFS_TARGET_STATE   {
                        DFS_TARGET_STATE_UNASSIGNED = 0,
                        DFS_TARGET_STATE_OK,
                        DFS_TARGET_STATE_UNREACHABLE
                        };

enum FILTERDFSLINKS_TYPE {
        FILTERDFSLINKS_TYPE_NO_FILTER = 0,
        FILTERDFSLINKS_TYPE_BEGINWITH,
        FILTERDFSLINKS_TYPE_CONTAIN
};

#define FILTERDFSLINKS_MAXLIMIT_DEFAULT        100

#define KEYTWORDS_UPPER_RANGER          256
#define DNSNAMELIMIT                    2048   // as defined in AD schema UpperRange for dnsHostName

#define ATTR_SCHEMANAMINGCONTEXT        _T("schemaNamingContext")
#define DN_PREFIX_SCHEMA_REPLICASET     _T("CN=NTFRS-Replica-Set,")

#define FRS_STAGE_PATH                  _T("Frs-Staging")

enum FRSSHARE_TYPE
{
    FRSSHARE_TYPE_OK = 0,
    FRSSHARE_TYPE_NONTFRS,
    FRSSHARE_TYPE_NOTDISKTREE,
    FRSSHARE_TYPE_NOTNTFS,
    FRSSHARE_TYPE_CONFLICTSTAGING,
    FRSSHARE_TYPE_NODOMAIN,
    FRSSHARE_TYPE_NOTSMBDISK,
    FRSSHARE_TYPE_OVERLAPPING,
    FRSSHARE_TYPE_UNKNOWN
};

//
// replica set types
//
#define FRS_RSTYPE_ENTERPRISE_SYSVOL    _T("1")
#define FRS_RSTYPE_DOMAIN_SYSVOL        _T("2")
#define FRS_RSTYPE_DFS                  _T("3")
#define FRS_RSTYPE_OTHER                _T("4")

//
// replica set topology preference
//
#define FRS_RSTOPOLOGYPREF_RING         _T("1")
#define FRS_RSTOPOLOGYPREF_HUBSPOKE     _T("2")
#define FRS_RSTOPOLOGYPREF_FULLMESH     _T("3")
#define FRS_RSTOPOLOGYPREF_CUSTOM       _T("4")

//
// enabledConnection values
//
#define CONNECTION_ENABLED_TRUE         _T("TRUE")
#define CONNECTION_ENABLED_FALSE        _T("FALSE")

//
// FRS attribute names
//
#define ATTR_OBJCLASS                           _T("objectClass")
#define ATTR_DNSHOSTNAME                        _T("dNSHostName")
#define ATTR_OBJECTGUID                         _T("objectGUID")
#define ATTR_DISTINGUISHEDNAME                  _T("distinguishedName")
#define ATTR_SYSTEMMAYCONTAIN                   _T("systemMayContain")

#define ATTR_FRS_REPSET_TYPE                    _T("fRSReplicaSetType")
#define ATTR_FRS_REPSET_TOPOLOGYPREF            _T("msFRS-Topology-Pref")
#define ATTR_FRS_REPSET_HUBSERVER               _T("msFRS-Hub-Member")
#define ATTR_FRS_REPSET_PRIMARYMEMBER           _T("fRSPrimaryMember")
#define ATTR_FRS_REPSET_FILEFILTER              _T("fRSFileFilter")
#define ATTR_FRS_REPSET_DIRFILTER               _T("fRSDirectoryFilter")

#define ATTR_FRS_MEMBER_COMPUTERREF             _T("frsComputerReference")

#define ATTR_NTDS_CONNECTION_FROMSERVER         _T("fromServer")
#define ATTR_NTDS_CONNECTION_ENABLEDCONNECTION  _T("enabledConnection")
#define ATTR_NTDS_CONNECTION_OPTIONS            _T("options")
#define ATTR_NTDS_CONNECTION_SCHEDULE           _T("schedule")

#define ATTR_FRS_SUBSCRIBER_MEMBERREF           _T("fRSMemberReference")
#define ATTR_FRS_SUBSCRIBER_ROOTPATH            _T("fRSRootPath")
#define ATTR_FRS_SUBSCRIBER_STAGINGPATH         _T("fRSStagingPath")

#define ATTR_SHRPUB_UNCNAME                     _T("uNCName")
#define ATTR_SHRPUB_DESCRIPTION                 _T("description")
#define ATTR_SHRPUB_KEYWORDS                    _T("keywords")
#define ATTR_SHRPUB_MANAGEDBY                   _T("managedBy")

//
// values for objectClass
//
#define OBJCLASS_NTFRSSETTINGS          _T("nTFRSSettings")
#define OBJCLASS_NTFRSREPLICASET        _T("nTFRSReplicaSet")
#define OBJCLASS_NTFRSMEMBER            _T("nTFRSMember")
#define OBJCLASS_NTDSCONNECTION         _T("nTDSConnection")
#define OBJCLASS_NTFRSSUBSCRIPTIONS     _T("nTFRSSubscriptions")
#define OBJCLASS_NTFRSSUBSCRIBER        _T("nTFRSSubscriber")
#define OBJCLASS_VOLUME                 _T("volume")

//
// search filter on objectClass
//
#define OBJCLASS_SF_ALL                     _T("(objectClass=*)")
#define OBJCLASS_SF_CLASSSCHEMA             _T("(objectCategory=classSchema)")
#define OBJCLASS_SF_COMPUTER                _T("(objectCategory=computer)")
#define OBJCLASS_SF_NTFRSSETTINGS           _T("(objectCategory=nTFRSSettings)")
#define OBJCLASS_SF_NTFRSREPLICASET         _T("(objectCategory=nTFRSReplicaSet)")
#define OBJCLASS_SF_NTFRSMEMBER             _T("(objectCategory=nTFRSMember)")
#define OBJCLASS_SF_NTDSCONNECTION          _T("(objectCategory=nTDSConnection)")
#define OBJCLASS_SF_NTFRSSUBSCRIPTIONS      _T("(objectCategory=nTFRSSubscriptions)")
#define OBJCLASS_SF_NTFRSSUBSCRIBER         _T("(objectCategory=nTFRSSubscriber)")
#define OBJCLASS_SF_FTDFS                   _T("(objectCategory=fTDfs)")
#define OBJCLASS_SF_VOLUME                  _T("(objectCategory=volume)")

#define DEFAULT_FILEFILTER                  _T("*.bak,*.tmp,~*")
#define DEFAULT_CONNECTION_OPTIONS          _T("0")

#define NUM_OF_FRSMEMBER_ATTRS          9
#define NUM_OF_FRSCONNECTION_ATTRS      5

enum CONNECTION_OPTYPE {
        CONNECTION_OPTYPE_OTHERS = 0,
        CONNECTION_OPTYPE_ADD,
        CONNECTION_OPTYPE_DEL
};

typedef enum _Connection_Priority
{
    PRIORITY_HIGH = 2,
    PRIORITY_MEDIUM = 4,
    PRIORITY_LOW = 7
} Connection_Priority;

#endif //_DFS_ENUMS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\ldaputils.cpp ===
/*++
Module Name:

LDAPUtils.h

Abstract:
  This is the header file for the LDAP utility functions.

*/
//--------------------------------------------------------------------

#include <stdafx.h>
#include "LDAPUtils.h"
#include <dsgetdc.h>
#include <stdio.h>
#include <ntdsapi.h>
#include <lm.h>
#include <ntldap.h>
#include <winber.h>
#include "dfsenums.h"
#include "netutils.h"

//----------------------------------------------------------------------------------
HRESULT FreeLDAPNamesList
(
  IN PLDAPNAME    i_pLDAPNames        // pointer to list to be freed.
)
{
/*++

Routine Description:

  Helper funciton used to free the NETNAME linked list retrurned by 
    LDAP helper functions.

Arguments:

  i_pLDAPNames - Pointer to the first node in the list to be freed.


Return value:

    S_OK, on Success.
  E_POINTER, Illegal pointer was passed.

--*/

  PLDAPNAME   pNodeToFree = NULL;
  try
  {
    while (NULL != i_pLDAPNames)      
    {                    
      pNodeToFree  = i_pLDAPNames;
      i_pLDAPNames = i_pLDAPNames->Next;
      delete pNodeToFree;
    }
  }  //  try
  catch (...)
  {
    return E_POINTER;
  }
  return S_OK;
}  //  HRESULT FreeDomainList



HRESULT FreeAttrValList
(
  IN PLDAP_ATTR_VALUE    i_pAttrVals        
)
{
/*++

Routine Description:

  Helper funciton used to free the LDAP_ATTR_VALUE linked list retrurned by 
    LDAP helper functions.

Arguments:

  i_pLDAPNames - Pointer to the first node in the list to be freed.


Return value:

    S_OK, on Success.
  E_POINTER, Illegal pointer was passed.

--*/

  PLDAP_ATTR_VALUE   pNodeToFree = NULL;
  try
  {
    while (NULL != i_pAttrVals)      
    {                    
      pNodeToFree  = i_pAttrVals;
      i_pAttrVals = i_pAttrVals->Next;
      if (NULL != pNodeToFree->vpValue)
      {
        free(pNodeToFree->vpValue);
      }
      delete pNodeToFree;
    }
  }  //  try
  catch (...)
  {
    return E_POINTER;
  }
  return S_OK;
}


//----------------------------------------------------------------------------------
HRESULT ConnectToDS
(
  IN  PCTSTR    i_lpszDomainName,  // DNS or non DNS format.
  OUT PLDAP    *o_ppldap,
  OUT BSTR*     o_pbstrDC // = NULL
)
{
/*++

Routine Description:

  Opens an LDAP connection to a valid DC (DC re-fetched if down).

Arguments:

  i_lpszDomainName - Name of the domain, DNS or Non Dns format.
  
  o_ppldap     - Pointer to LDAP handle in returned here.
             NULL on failure.

Return value:

    S_OK, on Success.
  E_INVALIDARG, Illegal pointer was passed.
  E_FAIL, if connection could not be established.
  Any Other error code returned by ldap or Net apis.

--*/

    RETURN_INVALIDARG_IF_NULL(o_ppldap);

    *o_ppldap = NULL;

    //
    // open a ldap connection to a valid DC
    //
    HRESULT     hr = S_OK;
    DWORD       dwErr = 0; 
    CComBSTR    bstrDCName;
    PLDAP       pldap = NULL;
    BOOL        bRetry = FALSE;
    do {
#ifdef DEBUG
        SYSTEMTIME time0 = {0};
        GetSystemTime(&time0);
#endif // DEBUG

        //
        // pick a DC
        //
        PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
        if (bRetry)
            dwErr = DsGetDcName(NULL, i_lpszDomainName, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, &pDCInfo);
        else
            dwErr = DsGetDcName(NULL, i_lpszDomainName, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
        SYSTEMTIME time1 = {0};
        GetSystemTime(&time1);
        PrintTimeDelta(_T("ConnectToDS-DsGetDcName"), &time0, &time1);
#endif // DEBUG

        if (ERROR_SUCCESS != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

        if ( !mylstrncmpi(pDCInfo->DomainControllerName, _T("\\\\"), 2) )
            bstrDCName = pDCInfo->DomainControllerName + 2;
        else
            bstrDCName = pDCInfo->DomainControllerName;
    
        NetApiBufferFree(pDCInfo);

        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDCName, &hr);

        //
        // make ldap connection to this DC
        //
        pldap = ldap_init(bstrDCName, LDAP_PORT);
        if (!pldap)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Making ldap_open/ldap_connect with a server name without first setting 
        // LDAP_OPT_AREC_EXCLUSIVE (for ldap interfaces) or 
        // ADS_SERVER_BIND (for ADSI interfaces) will result in bogus DNS queries 
        // consuming bandwidth and potentially bringing up remote links that are 
        // costly or demand dial.
        //
        // ignore the return of ldap_set_option
        ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

        ULONG ulRet = ldap_connect(pldap, NULL); // NULL for the default timeout

#ifdef DEBUG
        SYSTEMTIME time2 = {0};
        GetSystemTime(&time2);
        PrintTimeDelta(_T("ConnectToDS-ldap_connect"), &time1, &time2);
#endif // DEBUG

        if (LDAP_SERVER_DOWN == ulRet && !bRetry)
        {
            ldap_unbind(pldap);
            bRetry = TRUE; // retry once to pick another DC
        } else
        {
             if (LDAP_SUCCESS != ulRet)
             {
                ldap_unbind(pldap);
                hr = HRESULT_FROM_WIN32(LdapMapErrorToWin32(ulRet));
             }

             break;
        }
    } while (1);

    RETURN_IF_FAILED(hr);

    //
    // bind to this ldap connection
    //
    dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (LDAP_SUCCESS != dwErr) 
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        DebugOutLDAPError(pldap, dwErr, _T("ldap_bind_s"));
        ldap_unbind(pldap);
        hr = HRESULT_FROM_WIN32(dwErr);
    } else
    {
        *o_ppldap = pldap;

        if (o_pbstrDC)
        {
            *o_pbstrDC = bstrDCName.Copy();
            if (!*o_pbstrDC)
            {
                ldap_unbind(pldap);
                *o_ppldap = NULL;
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}



HRESULT CloseConnectionToDS
(
  IN PLDAP    i_pldap      
)
{
/*++

Routine Description:

  Closes an open LDAP connection.

Arguments:

  i_pldap - Open LDAP connection handle.

Return value:

    S_OK, on Success.
  E_FAIL, if connection could not be established.
  Any Other error code returned by ldap or Net apis.

--*/

  if (NULL == i_pldap)
  {
    return(E_INVALIDARG);
  }

  DWORD dwErr = ldap_unbind(i_pldap);
  if (LDAP_SUCCESS != dwErr) 
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    return(HRESULT_FROM_WIN32(dwErr));
  }
  else
  {
    return(S_OK);
  }
}


      // Gets Values for an attribute from an LDAP Object.
HRESULT GetValues 
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_lpszBase,
    IN PCTSTR               i_lpszSearchFilter,
    IN ULONG                i_ulScope,
    IN ULONG                i_ulAttrCount,
    IN LDAP_ATTR_VALUE      i_pAttributes[],
    OUT PLDAP_ATTR_VALUE    o_ppValues[]
)
{

/*++
Routine Description:

    Gets Values for an attribute from an LDAP Object given Object class.
  Object Class can be "*" etc.

Arguments:

    i_pldap        - An open, bound ldap port.
    i_lpszBase      - The base path of a DS object, can be "".
  i_lpszSearchFilter  - LDAP Search Filter.
  i_ulScope      - The search scope.
  i_ulAttrCount    - Count of attributes passed in i_lpszAttributes.
    i_pAttributes    - Attributes for which to get values. The bBerValue has to be set.
  o_ppValues      - Array of pointers, size = i_ulAttrCount, each pointer to a list
              of values corresponding to the respective attribute in i_pAttributes.
              The bstrAttribute is not set for values. For BerVal types the
              bBerValue and ulLength are set.

Return Value:

    S_OK, on Success.
  E_INVALIDARG, Illegal pointer was passed.
  E_OUTOFMEMORY on memory allocation failure.
  E_FAIL, if connection could not be established.
  Any Other error code returned by ldap or Net apis.
    
  
--*/
  DWORD           dwErr;      
  BerElement      *BerElm = NULL;       
  PLDAPMessage    pMsg = NULL;       
  PLDAPMessage    pEntry = NULL;     
  HRESULT         hr = S_OK;

  if (!i_pldap ||
      !i_lpszBase || 
      !i_lpszSearchFilter ||
      (i_ulAttrCount < 1) ||
      !i_pAttributes ||
      !o_ppValues)
  {
    return(E_INVALIDARG);
  }

                // Prepare the list of attributes to be sent to ldap_search.
  LPTSTR *lpszAttributes = new LPTSTR[i_ulAttrCount + 1];
  if (!lpszAttributes)
    return E_OUTOFMEMORY;

  lpszAttributes[i_ulAttrCount] = NULL;
  for (ULONG i = 0; i < i_ulAttrCount; i++)
    lpszAttributes[i] = i_pAttributes[i].bstrAttribute;

                // Execute the search.
  dwErr = ldap_search_s  (i_pldap, 
            (PTSTR)i_lpszBase, 
            i_ulScope,
            (PTSTR)i_lpszSearchFilter, 
            lpszAttributes, 
            0, 
            &pMsg
            );
  delete [] lpszAttributes;

  if (LDAP_SUCCESS != dwErr) 
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
    hr = HRESULT_FROM_WIN32(dwErr);
  } else
  {
    LPTSTR lpszCurrentAttr = ldap_first_attribute(i_pldap, pMsg, &BerElm);
    if (!lpszCurrentAttr)
    {
      dfsDebugOut((_T("GetValues of %s returned NULL attributes.\n"), i_lpszBase));
      hr = HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED);
    } else
    {
                // For each attribute, build a list of values 
                // by scanning each entry for the given attribute.
      for (i = 0; i < i_ulAttrCount && SUCCEEDED(hr); i++)
      {
        PLDAP_ATTR_VALUE  *ppCurrent = &(o_ppValues[i]);

                    // Scan each attribute of the entry for an exact match
        for(lpszCurrentAttr = ldap_first_attribute(i_pldap, pMsg, &BerElm);
          lpszCurrentAttr != NULL && SUCCEEDED(hr);
          lpszCurrentAttr = ldap_next_attribute(i_pldap, pMsg, BerElm))
        {
                  // Is there a match?
          if (0 == lstrcmpi(i_pAttributes[i].bstrAttribute, lpszCurrentAttr)) 
          {
                  // Add the value to the linked list for this attribute.
            LPTSTR      *lpszCurrentValue = NULL, *templpszValue = NULL;
            LDAP_BERVAL    **ppBerVal = NULL, **tempBerVal = NULL;

            if (i_pAttributes[i].bBerValue)
            {
              tempBerVal = ppBerVal =  ldap_get_values_len(i_pldap, pMsg, lpszCurrentAttr);
              while(*ppBerVal && SUCCEEDED(hr))
              {
                *ppCurrent = new LDAP_ATTR_VALUE;
                if (!*ppCurrent)
                {
                   hr = E_OUTOFMEMORY;
                } else
                {
                  (*ppCurrent)->ulLength = (*ppBerVal)->bv_len;
                  (*ppCurrent)->bBerValue = true;
                  (*ppCurrent)->vpValue = malloc((*ppBerVal)->bv_len);
              
                  if (!(*ppCurrent)->vpValue)
                  {
                    delete *ppCurrent;
                    hr = E_OUTOFMEMORY;
                  } else
                  {
                    memcpy(
                        (*ppCurrent)->vpValue,
                        (void *)(*ppBerVal)->bv_val,
                        (*ppBerVal)->bv_len
                        );

                    (*ppCurrent)->Next = NULL;

                    ppBerVal++;
                    ppCurrent = &((*ppCurrent)->Next);
                  }
                }
              } // while
              if (NULL != tempBerVal)
                ldap_value_free_len(tempBerVal);
            }
            else
            {
              templpszValue = lpszCurrentValue = ldap_get_values(i_pldap, pMsg, lpszCurrentAttr);
              while(*lpszCurrentValue && SUCCEEDED(hr))
              {
                *ppCurrent = new LDAP_ATTR_VALUE;
                if (NULL == *ppCurrent)
                {
                  hr = E_OUTOFMEMORY;
                } else
                {
                  (*ppCurrent)->bBerValue = false;
                  (*ppCurrent)->vpValue = (void *)_tcsdup(*lpszCurrentValue);
                  (*ppCurrent)->Next = NULL;

                  if (NULL == (*ppCurrent)->vpValue)
                  {
                    delete *ppCurrent;
                    hr = E_OUTOFMEMORY;
                  } else
                  {
                    lpszCurrentValue++;
                    ppCurrent = &((*ppCurrent)->Next);
                  }
                }
              } // while
              if (NULL != templpszValue)
                ldap_value_free(templpszValue);
            }              
          }
        }
      }
    }
  }

  // free pMsg because ldap_search_s always allocates pMsg
  if (pMsg)
    ldap_msgfree(pMsg);

  if (FAILED(hr))
  {
    for (i = 0; i < i_ulAttrCount; i++)
      FreeAttrValList(o_ppValues[i]);
  }

  return hr;
}

void FreeLListElem(LListElem* pElem)
{
    LListElem* pCurElem = NULL;
    LListElem* pNextElem = pElem;

    while (pCurElem = pNextElem)
    {
        pNextElem = pCurElem->Next;
        delete pCurElem;
    }
}

HRESULT GetValuesEx
(
    IN PLDAP                i_pldap,
    IN PCTSTR               i_pszBase,
    IN ULONG                i_ulScope,
    IN PCTSTR               i_pszSearchFilter,
    IN PCTSTR               i_pszAttributes[],
    OUT LListElem**         o_ppElem
)
{
    if (!i_pldap ||
        !i_pszBase || 
        !i_pszSearchFilter ||
        !i_pszAttributes ||
        !o_ppElem)
    {
        return(E_INVALIDARG);
    }

    *o_ppElem = NULL;

    //
    // count number of attributes
    //
    ULONG   ulNumOfAttributes = 0;
    PTSTR*  ppszAttr = (PTSTR *)i_pszAttributes;
    while (*ppszAttr++)
        ulNumOfAttributes++;
    if (!ulNumOfAttributes)
        return E_INVALIDARG;

    HRESULT         hr = S_OK;
    PLDAPMessage    pMsg = NULL;       
    DWORD           dwErr = ldap_search_s(i_pldap, 
                                (PTSTR)i_pszBase, 
                                i_ulScope,
                                (PTSTR)i_pszSearchFilter, 
                                (PTSTR *)i_pszAttributes, 
                                0, 
                                &pMsg
                                );

    if (LDAP_SUCCESS != dwErr) 
    {
        dwErr = LdapMapErrorToWin32(dwErr);
        DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
        hr = HRESULT_FROM_WIN32(dwErr);
    } else
    {
        PLDAPMessage    pMsgEntry = NULL;     
        BerElement*     pBerElm = NULL;       
        PTSTR           pszCurrentAttr = NULL;   
        LListElem*      pHeadElem = NULL;
        LListElem*      pCurElem = NULL;

        // Scan each entry to find the value set for the DN attribute.
        for(pMsgEntry = ldap_first_entry(i_pldap, pMsg); pMsgEntry; pMsgEntry = ldap_next_entry(i_pldap, pMsgEntry)) 
        {
            PTSTR** pppszValueArray = (PTSTR **)calloc(ulNumOfAttributes + 1, sizeof(PTSTR **));
            BREAK_OUTOFMEMORY_IF_NULL(pppszValueArray, &hr);

            // Read each attribute of the entry into the array
            for(pszCurrentAttr = ldap_first_attribute(i_pldap, pMsgEntry, &pBerElm); pszCurrentAttr; pszCurrentAttr = ldap_next_attribute(i_pldap, pMsgEntry, pBerElm))
            {
                PTSTR* ppszValues = ldap_get_values(i_pldap, pMsgEntry, pszCurrentAttr);

                for (ULONG i = 0; i < ulNumOfAttributes; i++)
                {
                    if (!lstrcmpi(i_pszAttributes[i], pszCurrentAttr))
                    {
                        pppszValueArray[i] = ppszValues;
                        break;
                    }
                }
            } // end of attribute enumeration

            LListElem* pNewElem = new LListElem(pppszValueArray);
            if (!pNewElem)
            {
                free(pppszValueArray);
                hr = E_OUTOFMEMORY;
                break;
            }

            if (!pCurElem)
            {
                pHeadElem = pCurElem = pNewElem;
            } else
            {
                pCurElem->Next = pNewElem;
                pCurElem = pNewElem;
            }
        } // end of entry enumeration

        if (FAILED(hr))
            FreeLListElem(pHeadElem);
        else
            *o_ppElem = pHeadElem;
    }

    // free pMsg because ldap_search_s always allocates pMsg
    if (pMsg)
        ldap_msgfree(pMsg);

    return hr;
}

HRESULT GetChildrenDN
(
    IN PLDAP        i_pldap,
    IN LPCTSTR      i_lpszBase,
    IN ULONG        i_ulScope,
    IN LPTSTR       i_lpszChildObjectClassSF,
    OUT PLDAPNAME*  o_ppDistNames
)
/*++
Routine Description:
    
  Return the Distinguished Name of all children of a given objectClass
  as a linked list of LDAPNAME structures.
  
Arguments:
    
  pldap          - An open and bound ldap handle.

    i_lpszBase        - The base path of a DS object, can be "".

  o_ppDistNames      - The linked of child DNs is returned here.

    i_lpszChildObjectClassSF  - The objectClass of the children to list.
                E.g fTDfs, User.

Return Value:
  
  S_OK on success.
  E_FAIL on failure.
  E_OUTOFMEORY if memory allocation fails.
  E_INVALIDARG if null pointer arguments were passed.

--*/
{

  DWORD           dwErr;      
  LPTSTR          lpszCurrentAttr = NULL;   
  LPTSTR      *plpszValues  = NULL;
  BerElement      *BerElm = NULL;       
  PLDAPMessage    pMsg = NULL; 
  PLDAPMessage    pEntry = NULL;     
  PLDAPNAME    *ppCurrent;
  HRESULT      hr = S_OK;

  if (!i_pldap || !i_lpszBase || !o_ppDistNames ||
    !i_lpszChildObjectClassSF || !*i_lpszChildObjectClassSF)
  {
    return(E_INVALIDARG);
  }

  *o_ppDistNames = NULL;
  ppCurrent = o_ppDistNames;

  LPTSTR lpszAttributes[2] = {0,0};
  lpszAttributes[0] = _T("distinguishedName");

                // Execute the search.
  dwErr = ldap_search_s  (i_pldap, 
            (LPTSTR)i_lpszBase, 
            i_ulScope,
            i_lpszChildObjectClassSF, 
            lpszAttributes, 
            0, 
            &pMsg
            );
  if (LDAP_SUCCESS != dwErr)
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
    hr = HRESULT_FROM_WIN32(dwErr);
  } else
  {
                // Scan each entry to find the value set for the DN attribute.
    for(pEntry = ldap_first_entry(i_pldap, pMsg);
      pEntry != NULL;
      pEntry = ldap_next_entry(i_pldap, pEntry)) 
    {
      CComBSTR bstrCN;

                  // Scan each attribute of the entry for DN
      for(lpszCurrentAttr = ldap_first_attribute(i_pldap, pEntry, &BerElm);
          lpszCurrentAttr != NULL;
          lpszCurrentAttr = ldap_next_attribute(i_pldap, pEntry, BerElm))
      {

        plpszValues = ldap_get_values(  i_pldap, 
                        pEntry, 
                        lpszCurrentAttr
                       );
                // Is there a match for CN?
        if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("distinguishedName"), -1, lpszCurrentAttr, -1)) 
        {
          bstrCN = plpszValues[0];
        }    
      }

                // LDAP object does not have valid fields.
      if (!bstrCN)
        continue;

      // Add to list.

      *ppCurrent = new LDAPNAME;
      if (NULL == *ppCurrent)
      {
        hr = E_OUTOFMEMORY;
        break;
      }

      (*ppCurrent)->Next = NULL;
      (*ppCurrent)->bstrLDAPName = bstrCN.m_str;

      if (!(*ppCurrent)->bstrLDAPName)
      {
        delete *ppCurrent;
        *ppCurrent = NULL;
        hr = E_OUTOFMEMORY;
        break;
      }

      ppCurrent = &((*ppCurrent)->Next);
    }

    if (NULL == *o_ppDistNames)
    {
      hr = E_FAIL;
    }
    
    if (S_OK != hr)
    {
      FreeLDAPNamesList(*ppCurrent);
      *ppCurrent = NULL;
      hr = E_OUTOFMEMORY;
    }
  }

  // free pMsg because ldap_search_s always allocates pMsg
  if (pMsg)
    ldap_msgfree(pMsg);

  return(hr);
}

HRESULT GetConnectionDNs
(
    IN PLDAP        i_pldap,
    IN LPCTSTR      i_lpszBase,
    IN LPTSTR       i_lpszChildObjectClassSF,
    OUT PLDAPNAME*  o_ppDistNames
)
{

  DWORD           dwErr;      
  LPTSTR          lpszCurrentAttr = NULL;   
  LPTSTR      *plpszValues  = NULL;
  BerElement      *BerElm = NULL;       
  PLDAPMessage    pMsg = NULL; 
  PLDAPMessage    pEntry = NULL;     
  PLDAPNAME    *ppCurrent;
  HRESULT      hr = S_OK;

  if (!i_pldap || !i_lpszBase || !o_ppDistNames ||
    !i_lpszChildObjectClassSF || !*i_lpszChildObjectClassSF)
  {
    return(E_INVALIDARG);
  }

  *o_ppDistNames = NULL;
  ppCurrent = o_ppDistNames;

  LPTSTR lpszAttributes[2] = {0,0};
  lpszAttributes[0] = _T("distinguishedName");

                // Execute the search.
  dwErr = ldap_search_s  (i_pldap, 
            (LPTSTR)i_lpszBase, 
            LDAP_SCOPE_ONELEVEL,
            i_lpszChildObjectClassSF, 
            lpszAttributes, 
            0, 
            &pMsg
            );
  if (LDAP_SUCCESS != dwErr)
  {
    dwErr = LdapMapErrorToWin32(dwErr);
    DebugOutLDAPError(i_pldap, dwErr, _T("ldap_search_s"));
    hr = HRESULT_FROM_WIN32(dwErr);
  } else
  {
                // Scan each entry to find the value set for the DN attribute.
    for(pEntry = ldap_first_entry(i_pldap, pMsg);
      pEntry != NULL;
      pEntry = ldap_next_entry(i_pldap, pEntry)) 
    {
      CComBSTR bstrCN;

                  // Scan each attribute of the entry for DN
      for(lpszCurrentAttr = ldap_first_attribute(i_pldap, pEntry, &BerElm);
          lpszCurrentAttr != NULL;
          lpszCurrentAttr = ldap_next_attribute(i_pldap, pEntry, BerElm))
      {

        plpszValues = ldap_get_values(  i_pldap, 
                        pEntry, 
                        lpszCurrentAttr
                       );
                // Is there a match for CN?
        if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("distinguishedName"), -1, lpszCurrentAttr, -1)) 
        {
          bstrCN = plpszValues[0];
        }    
      }

                // LDAP object does not have valid fields.
      if (!bstrCN)
        continue;

      // Add to list.

      *ppCurrent = new LDAPNAME;
      if (NULL == *ppCurrent)
      {
        hr = E_OUTOFMEMORY;
        break;
      }

      (*ppCurrent)->Next = NULL;
      (*ppCurrent)->bstrLDAPName = bstrCN.m_str;

      if (!(*ppCurrent)->bstrLDAPName)
      {
        delete *ppCurrent;
        *ppCurrent = NULL;
        hr = E_OUTOFMEMORY;
        break;
      }

      ppCurrent = &((*ppCurrent)->Next);
    }

    if (NULL == *o_ppDistNames)
    {
      hr = E_FAIL;
    }
    
    if (S_OK != hr)
    {
      FreeLDAPNamesList(*ppCurrent);
      *ppCurrent = NULL;
      hr = E_OUTOFMEMORY;
    }
  }

  // free pMsg because ldap_search_s always allocates pMsg
  if (pMsg)
    ldap_msgfree(pMsg);

  return(hr);
}

HRESULT PrepareLDAPMods
(
  IN LDAP_ATTR_VALUE    i_pAttrValue[],
  IN LDAP_ENTRY_ACTION  i_AddModDel,
  IN ULONG        i_ulCountOfVals,
  OUT LDAPMod*      o_ppModVals[]
)
{
/*++

Routine Description:

  Fills up a LPDAMod pointer array given a array of attribute value pairs.
  The mod_op field of all LPDAMod structures returned depends on the value of i_AddModDel.

Arguments:

  i_pAttrValue  -  An array of LDAP_ATTR_VALUE structures containing 
  the attribute and name value pairs.

  i_AddModDel    -  One of LDAP_ENTRY_ACTION enum value.

    i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

    o_ppModVals    -  Pointer to a pre-allocated (and NULL terminated) array of pointers to 
             LPDAPMod structures. The LPDAMod structures and allocated and returned here.
             Size of this should be i_ulCountOfVals.

Return value:
    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.

--*/

  if (NULL == i_pAttrValue || NULL == o_ppModVals)
  {
    return(E_INVALIDARG);
  }

  for (ULONG i = 0, k = 0; k < i_ulCountOfVals; i++, k++)
  {

    //
    // have to skip objectClass attribute in case of modify/delete,
    // otherwise, ldap_modify_xxx will return LDAP_UNWILLING_TO_PERFORM 
    //
    if (ADD_VALUE != i_AddModDel &&
        CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, i_pAttrValue[k].bstrAttribute, -1, ATTR_OBJCLASS, -1))
    {
        k++;
    }

    o_ppModVals[i] = new LDAPMod;
    o_ppModVals[i]->mod_type = _tcsdup(i_pAttrValue[k].bstrAttribute);
    
    switch (i_AddModDel)
    {
    case ADD_VALUE:
      o_ppModVals[i]->mod_op = LDAP_MOD_ADD;
      break;
    case MODIFY_VALUE:
      o_ppModVals[i]->mod_op = LDAP_MOD_REPLACE;
      break;
    case DELETE_VALUE:
      o_ppModVals[i]->mod_op = LDAP_MOD_DELETE;
      break;
    }

            // Count the number of values for this attribute.
    PLDAP_ATTR_VALUE  pAttrVal = &(i_pAttrValue[k]);
    ULONG        ulCountOfVals = 0;
    while (pAttrVal)
    {
      ulCountOfVals++;
      pAttrVal = pAttrVal->Next;
    }

    pAttrVal = &(i_pAttrValue[k]);
    ULONG  j = 0;

    if (i_pAttrValue[k].bBerValue)
    {
      PLDAP_BERVAL* ppBerValues = NULL;
      ppBerValues = new PLDAP_BERVAL[ulCountOfVals + 1];
      ppBerValues[ulCountOfVals] = NULL;

      while (pAttrVal)
      {
        ppBerValues[j] = new LDAP_BERVAL;

        if (!pAttrVal->vpValue)
        {
            ppBerValues[j]->bv_len = 0;
            ppBerValues[j]->bv_val = NULL;
        } else
        {
            ppBerValues[j]->bv_len = pAttrVal->ulLength;
            ppBerValues[j]->bv_val = new char[pAttrVal->ulLength];
            memcpy(
                (void *)ppBerValues[j]->bv_val, 
                pAttrVal->vpValue,
                pAttrVal->ulLength
                );
        }
      
        pAttrVal = pAttrVal->Next;
        j++;
      }
      o_ppModVals[i]->mod_bvalues = ppBerValues;
      o_ppModVals[i]->mod_op |= LDAP_MOD_BVALUES;
    }
    else
    {
      LPTSTR*  plpszValues = NULL;
      plpszValues = new LPTSTR[ulCountOfVals + 1];
      plpszValues[ulCountOfVals] = NULL;

      while (pAttrVal)
      {
        if (pAttrVal->vpValue)
            plpszValues[j] = _tcsdup((LPTSTR)(pAttrVal->vpValue));
        else
            plpszValues[j] = NULL;

        pAttrVal = pAttrVal->Next;
        j++;
      }

      o_ppModVals[i]->mod_values = plpszValues;

    }
  }

  return(S_OK);
}

HRESULT AddValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR        i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE    i_pAttrValue[],
  IN BSTR               i_bstrDC // = NULL
)
{
/*++

Routine Description:
  
  This method add an attribute value (and a new LDAP object if it does not exist)
  in the DS. The parent of the given DN must exist. This can be used to add a new object
  and also to add new values for attributes of an existing object in which case
  the DN must exist.

Arguments:
  
  i_pldap  - Open LDAP connection context.

  i_DN  - Distinguished name of the (new) object.

  i_pAttrValue - Array of pointers to LDAP_ATTR_VALUE containing attribue and value.

  i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

Return value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.
--*/

  if (NULL == i_pldap || NULL == i_DN || NULL == i_pAttrValue)
  {
    return(E_INVALIDARG);
  }
  
  LDAPMod**    ppModVals = NULL;
  HRESULT      hr = S_FALSE;

  ppModVals = new LDAPMod*[i_ulCountOfVals + 1];
  if (NULL == ppModVals)
  {
    return(E_OUTOFMEMORY);
  }

  for (ULONG i = 0; i <= i_ulCountOfVals; i++)
  {
    ppModVals[i] = NULL;
  }

  do
  {
    hr = PrepareLDAPMods(
                i_pAttrValue,
                ADD_VALUE,
                i_ulCountOfVals,
                ppModVals
              );

    if (FAILED(hr))
    {
      break;
    }

    DWORD dwStatus = LDAP_SUCCESS;

    if (!i_bstrDC)
    {
      dwStatus = ldap_add_s(
                    i_pldap,
                    (LPTSTR)i_DN,
                    ppModVals
                   );
    } else
    {
      //
      // prepare the server hint
      //
      LDAPControl   simpleControl;
      PLDAPControl  controlArray[2];
      INT           rc;
      BERVAL*       pBerVal = NULL;
      BerElement*   pBer;

      pBer = ber_alloc_t(LBER_USE_DER);
      if (!pBer)
      {
        hr = E_OUTOFMEMORY;
        break;
      }
      rc = ber_printf(pBer,"{io}", 0, i_bstrDC, wcslen(i_bstrDC) * sizeof(WCHAR));
      if ( rc == -1 ) {
        hr = E_FAIL;
        break;
      }
      rc = ber_flatten(pBer, &pBerVal);
      if (rc == -1)
      {
        hr = E_FAIL;
        break;
      }
      ber_free(pBer,1);

      controlArray[0] = &simpleControl;
      controlArray[1] = NULL;

      simpleControl.ldctl_oid = LDAP_SERVER_VERIFY_NAME_OID_W;
      simpleControl.ldctl_iscritical = TRUE;
      simpleControl.ldctl_value = *pBerVal;

      dwStatus = ldap_add_ext_s(
              i_pldap, 
              (LPTSTR)i_DN, 
              ppModVals, 
              (PLDAPControl *)&controlArray, //ServerControls,
              NULL         //ClientControls,
              );

      ber_bvfree(pBerVal);

    }

    if (LDAP_SUCCESS == dwStatus)
    { 
      hr = S_OK;
    } else if (LDAP_ALREADY_EXISTS == dwStatus)
    {
        hr = ModifyValues(i_pldap, i_DN, i_ulCountOfVals, i_pAttrValue);
    }
    else
    {
      dwStatus = LdapMapErrorToWin32(dwStatus);
      DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_add_ext_s"));
      hr = HRESULT_FROM_WIN32(dwStatus);
    }

  } while (false);

  FreeModVals(&ppModVals);
  delete[] ppModVals;

  return(hr);
}


      // Modifies an existing record or values.
HRESULT ModifyValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR        i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE    i_pAttrValue[]
)
{
/*++

Routine Description:
  
  This method modifies attribute values of a DS object given its DN. 
  The DN object must exist.

Arguments:
  
  i_pldap  - Open LDAP connection context.

  i_DN  - Distinguished name of the object.

  i_pAttrValue - Array of pointers to LDAP_ATTR_VALUE containing attribue and value.

  i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

Return value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.
--*/
  if (NULL == i_pldap || NULL == i_DN || NULL == i_pAttrValue)
  {
    return(E_INVALIDARG);
  }

  LDAPMod**    ppModVals = NULL;
  HRESULT      hr = S_FALSE;
  
  ppModVals = new LDAPMod*[i_ulCountOfVals + 1];
  if (NULL == ppModVals)
  {
    return(E_OUTOFMEMORY);
  }

  for (ULONG i = 0; i <= i_ulCountOfVals; i++)
  {
    ppModVals[i] = NULL;
  }

  do
  {
    hr = PrepareLDAPMods(
                    i_pAttrValue,
                    MODIFY_VALUE,
                    i_ulCountOfVals,
                    ppModVals
                  );
    if (FAILED(hr))
    {
      break;
    }

    //
    // With this server side control, ldap_modify will return success
    // if modifying an existing attribute with same value, or deleting
    // an attribute with no value
    //
    BERVAL        berVal = {0};
    LDAPControl   permissiveControl;
    PLDAPControl  controlArray[2];

    controlArray[0] = &permissiveControl;
    controlArray[1] = NULL;

    permissiveControl.ldctl_oid = LDAP_SERVER_PERMISSIVE_MODIFY_OID_W;
    permissiveControl.ldctl_iscritical = FALSE;
    permissiveControl.ldctl_value = berVal;

    DWORD dwStatus = ldap_modify_ext_s(
                    i_pldap,
                    (LPTSTR)i_DN,
                    ppModVals,
                    (PLDAPControl *)&controlArray,  //ServerControls,
                    NULL                            //ClientControls,
                   );

    if (LDAP_SUCCESS == dwStatus || LDAP_ATTRIBUTE_OR_VALUE_EXISTS == dwStatus)
    { 
      hr = S_OK;
      break;
    }
    else
    {
      dwStatus = LdapMapErrorToWin32(dwStatus);
      DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_modify_ext_s"));
      hr = HRESULT_FROM_WIN32(dwStatus);
      break;
    }
  }
  while (false);

  FreeModVals(&ppModVals);
  delete[] ppModVals;

  return(hr);
}

      // Deletes values from an existing record or values.
HRESULT DeleteValues
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN ULONG        i_ulCountOfVals,
  IN LDAP_ATTR_VALUE    i_pAttrValue[]
)
{
/*++

Routine Description:
  
  This method deletes attribute values of a DS object given its DN. 
  The DN object must exist.

Arguments:
  
  i_pldap  - Open LDAP connection context.

  i_DN  - Distinguished name of the object.

  i_pAttrValue - Array of pointers to LDAP_ATTR_VALUE containing attribue and value.

  i_ulCountOfVals -  The size of i_pAttrValue array (the number of values).

Return value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.
  E_OUTOEMEMORY, if memory allocation fails.
  Any other network (ldap) error.
--*/

  if (NULL == i_pldap || NULL == i_DN || NULL == i_pAttrValue)
  {
    return(E_INVALIDARG);
  }

  LDAPMod**    ppModVals = NULL;
  HRESULT      hr = S_FALSE;
  
  ppModVals = new LDAPMod*[i_ulCountOfVals + 1];
  if (NULL == ppModVals)
  {
    return(E_OUTOFMEMORY);
  }

  for (ULONG i = 0; i <= i_ulCountOfVals; i++)
  {
    ppModVals[i] = NULL;
  }

  do
  {
    hr = PrepareLDAPMods(
                    i_pAttrValue,
                    DELETE_VALUE,
                    i_ulCountOfVals,
                    ppModVals
                  );
    if (FAILED(hr))
    {
      break;
    }

    //
    // With this server side control, ldap_modify will return success
    // if modifying an existing attribute with same value, or deleting
    // an attribute with no value
    //
    BERVAL        berVal = {0};
    LDAPControl   permissiveControl;
    PLDAPControl  controlArray[2];

    controlArray[0] = &permissiveControl;
    controlArray[1] = NULL;

    permissiveControl.ldctl_oid = LDAP_SERVER_PERMISSIVE_MODIFY_OID_W;
    permissiveControl.ldctl_iscritical = FALSE;
    permissiveControl.ldctl_value = berVal;

    DWORD dwStatus = ldap_modify_ext_s(
                    i_pldap,
                    (LPTSTR)i_DN,
                    ppModVals,
                    (PLDAPControl *)&controlArray,  //ServerControls,
                    NULL                            //ClientControls,
                   );

    if (LDAP_SUCCESS == dwStatus || LDAP_NO_SUCH_ATTRIBUTE == dwStatus)
    { 
      hr = S_OK;
      break;
    }
    else
    {
      dwStatus = LdapMapErrorToWin32(dwStatus);
      DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_modify_ext_s"));
      hr = HRESULT_FROM_WIN32(dwStatus);
      break;
    }
  }
  while (false);

  FreeModVals(&ppModVals);
  delete[] ppModVals;

  return(hr);
}

      // Deletes an object, recursive or non-recursive.
HRESULT DeleteDSObject
(
  IN PLDAP        i_pldap,
  IN LPCTSTR      i_DN,
  IN bool         i_bDeleteRecursively //= true
)
{
  if (i_bDeleteRecursively)
  {
    PLDAPNAME   pDNs = NULL;
    PLDAPNAME   pTemp = NULL;

    HRESULT hr = GetChildrenDN(
                  i_pldap,
                  i_DN,
                  LDAP_SCOPE_ONELEVEL,
                  OBJCLASS_SF_ALL,
                  &pDNs
                  );

    if (S_OK == hr)
    {  
      pTemp = pDNs;
      while (pTemp)
      {
        DeleteDSObject(i_pldap, pTemp->bstrLDAPName);
        pTemp = pTemp->Next;      
      }

      FreeLDAPNamesList(pDNs);
    }
  }

  DWORD dwStatus = ldap_delete_s(
                  i_pldap,
                  (LPTSTR)i_DN
                  );

  if ( LDAP_NO_SUCH_OBJECT == dwStatus ||
      (!i_bDeleteRecursively && LDAP_NOT_ALLOWED_ON_NONLEAF == dwStatus) )
    return S_FALSE;

  if ( LDAP_SUCCESS != dwStatus)
  {
    dwStatus = LdapMapErrorToWin32(dwStatus);
    DebugOutLDAPError(i_pldap, dwStatus, _T("ldap_delete_s"));
  }

  return HRESULT_FROM_WIN32(dwStatus);
}



HRESULT FreeModVals
(
    IN OUT LDAPMod ***pppMod
)
/*++
Routine Description:
    
  Free the LPDAMod structures. Frees all LDAPMod values and pointers.

Arguments:
    
  pppMod  - Address of a null-terminated array of LPDAMod.

Return Value:

    S_OK, On success
  E_INVALIDARG, if an invalid (NULL) pointer was passed.

--*/
{
  if (NULL == pppMod)
  {
    return(E_INVALIDARG);
  }

  DWORD   i, j;
  LDAPMod **ppMod;


  if (NULL == *pppMod) 
  {
          // Nothing to do.
    return(S_OK);
  }

    
  ppMod = *pppMod;

            // For each attribute entry, free all its values.
  for (i = 0; ppMod[i] != NULL; i++) 
  {
    for (j = 0; (ppMod[i])->mod_values[j] != NULL; j++) 
    {
      if (ppMod[i]->mod_op & LDAP_MOD_BVALUES) 
      {
          delete (ppMod[i]->mod_bvalues[j]->bv_val);
      }
            
      delete ((ppMod[i])->mod_values[j]);
    }
    delete ((ppMod[i])->mod_values);   // Free the array of pointers to values
    delete ((ppMod[i])->mod_type);     // Free the string identifying the attribute
    delete (ppMod[i]);                 // Free the attribute
  }
    
  return(S_OK);
}


LPTSTR ErrorString
(
  DWORD          i_ldapErrCode
)
{
/*++
Routine Description:
    
  Gets a string corresponding to the ldap error code.

Arguments:
    
  i_ldapErrCode  - The ldap error code to map to an error string.

Return Value:

  The pointer to the error string.

--*/
  return(ldap_err2string(i_ldapErrCode));
}


HRESULT IsValidObject
(
  IN PLDAP    i_pldap,
  IN BSTR      i_bstrObjectDN
)
{
/*++

Routine Description:

  Checks if an object with given DN exists.

Arguments:

  i_bstrObjectDN    -  The DN of the object.

Return value:

  S_OK, Object exist
  S_FALSE, no such object
  Others, error occurred
--*/


  if (NULL == i_bstrObjectDN)
  {
    return(E_INVALIDARG);
  }

  PLDAP_ATTR_VALUE  pValues[2] = {0,0}, pCurrent = NULL;

  LDAP_ATTR_VALUE  pAttributes[1];

  pAttributes[0].bstrAttribute = _T("Name");
  pAttributes[0].bBerValue = false;
  
  HRESULT hr = GetValues(  
            i_pldap, 
            i_bstrObjectDN,
            OBJCLASS_SF_ALL,
            LDAP_SCOPE_BASE,
            1,          
            pAttributes,    
            pValues        
            );

  if (SUCCEEDED(hr))
    FreeAttrValList(pValues[0]);
  else
      hr = S_FALSE;

  return(hr);

}

HRESULT  CrackName(
  IN  HANDLE            i_hDS,
  IN  LPTSTR            i_lpszOldTypeName,
  IN  DS_NAME_FORMAT    i_formatIn,
  IN  DS_NAME_FORMAT    i_formatdesired,
  OUT BSTR*             o_pbstrResult
)
{
  if (!i_hDS || !i_lpszOldTypeName || !*i_lpszOldTypeName || !o_pbstrResult)
    return E_INVALIDARG;

  *o_pbstrResult = NULL;

  HRESULT         hr = S_OK;
  DS_NAME_RESULT* pDsNameResult = NULL;
  
  DWORD dwErr = DsCrackNames(
            i_hDS,
            DS_NAME_NO_FLAGS,
            i_formatIn,
            i_formatdesired,
            1,
            &i_lpszOldTypeName,
            &pDsNameResult
          );
  if (ERROR_SUCCESS != dwErr)
    hr = HRESULT_FROM_WIN32(dwErr);
  else
  {
    if (DS_NAME_NO_ERROR != pDsNameResult->rItems->status)
      hr = HRESULT_FROM_WIN32(pDsNameResult->rItems->status);
    else
    {
      *o_pbstrResult = SysAllocString(pDsNameResult->rItems->pName);
      if (!*o_pbstrResult)
        hr = E_OUTOFMEMORY;
    }

    DsFreeNameResult(pDsNameResult);
  }

  return hr;
}

void RemoveBracesOnGuid(IN OUT BSTR bstrGuid)
{
    if (!bstrGuid || !*bstrGuid)
        return;

    TCHAR *p = bstrGuid + lstrlen(bstrGuid) - 1;
    if (_T('}') == *p)
        *p = _T('\0');

    p = bstrGuid;
    if (_T('{') == *p)
    {
        while (*++p)
            *(p-1) = *p;

        *(p-1) = _T('\0');
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDomainInfo
//
//  Synopsis:   return DC Dns name, DomainDN, and/or LDAP://<DC>/<DomainDN> 
//
//--------------------------------------------------------------------------
HRESULT  GetDomainInfo(
  IN  LPCTSTR         i_bstrDomain,
  OUT BSTR*           o_pbstrDC,            // return DC's Dns name
  OUT BSTR*           o_pbstrDomainDnsName, // return Domain's Dns name
  OUT BSTR*           o_pbstrDomainDN,      // return DC=nttest,DC=microsoft,DC=com
  OUT BSTR*           o_pbstrLDAPDomainPath,// return LDAP://<DC>/<DomainDN>
  OUT BSTR*           o_pbstrDomainGuid     // return Domain's guid in string without {}
)
{
  if (o_pbstrDC)                *o_pbstrDC = NULL;
  if (o_pbstrDomainDnsName)     *o_pbstrDomainDnsName = NULL;
  if (o_pbstrDomainDN)          *o_pbstrDomainDN = NULL;
  if (o_pbstrLDAPDomainPath)    *o_pbstrLDAPDomainPath = NULL;
  if (o_pbstrDomainGuid)        *o_pbstrDomainGuid = NULL;

  HRESULT   hr = S_OK;
  BOOL      bRetry = FALSE;
  BOOL      b50Domain = FALSE;
  CComBSTR  bstrDCName;
  CComBSTR  bstrDomainDnsName;
  CComBSTR  bstrDomainDN;
  CComBSTR  bstrLDAPDomainPath;
  CComBSTR  bstrDomainGuid;

  HANDLE hDS = NULL;
  DWORD dwErr = ERROR_SUCCESS;
  do {
#ifdef DEBUG
    SYSTEMTIME time0 = {0};
    GetSystemTime(&time0);
#endif // DEBUG

    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    if (bRetry)
        dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
            DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, &pDCInfo);
    else
        dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
            DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
    SYSTEMTIME time1 = {0};
    GetSystemTime(&time1);
    PrintTimeDelta(_T("GetDomainInfo-DsGetDcName"), &time0, &time1);
#endif // DEBUG

    if (ERROR_SUCCESS != dwErr)
      return HRESULT_FROM_WIN32(dwErr);

    b50Domain = pDCInfo->Flags & DS_DS_FLAG;

    if ( !mylstrncmpi(pDCInfo->DomainControllerName, _T("\\\\"), 2) )
      bstrDCName = pDCInfo->DomainControllerName + 2;
    else
      bstrDCName = pDCInfo->DomainControllerName;

    // remove the ending dot
    int len = _tcslen(pDCInfo->DomainName);
    if ( _T('.') == *(pDCInfo->DomainName + len - 1) )
        *(pDCInfo->DomainName + len - 1) = _T('\0');
    bstrDomainDnsName = pDCInfo->DomainName;

    NetApiBufferFree(pDCInfo);

    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDCName, &hr);
    BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainDnsName, &hr);

    hr = b50Domain ? S_OK : S_FALSE;

    if (!b50Domain || 
        !o_pbstrDC &&
        !o_pbstrDomainDnsName &&
        !o_pbstrDomainDN &&
        !o_pbstrLDAPDomainPath &&
        !o_pbstrDomainGuid)
      return hr;

    if (!o_pbstrDomainDN && !o_pbstrLDAPDomainPath && !o_pbstrDomainGuid)
      break;

    dwErr = DsBind(bstrDCName,  bstrDomainDnsName, &hDS);
    hr = HRESULT_FROM_WIN32(dwErr);

#ifdef DEBUG
    SYSTEMTIME time2 = {0};
    GetSystemTime(&time2);
    PrintTimeDelta(_T("GetDomainInfo-DsBind"), &time1, &time2);
#endif // DEBUG

    if ((RPC_S_SERVER_UNAVAILABLE == dwErr || RPC_S_CALL_FAILED == dwErr) && !bRetry)
        bRetry = TRUE; // only retry once
    else
        break;

  } while (1);

  if (FAILED(hr))
      return hr;

  if (hDS)
  {
    do {
        CComBSTR bstrDomainTrailing = bstrDomainDnsName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainTrailing, &hr);
        bstrDomainTrailing += _T("/");   // add the trailing slash
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainTrailing, &hr);

        hr = CrackName(
                  hDS,
                  bstrDomainTrailing,
                  DS_CANONICAL_NAME,
                  DS_FQDN_1779_NAME,
                  &bstrDomainDN
                );
        BREAK_IF_FAILED(hr);

        if (o_pbstrLDAPDomainPath)
        {
            bstrLDAPDomainPath = _T("LDAP://");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
            bstrLDAPDomainPath += bstrDCName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
            bstrLDAPDomainPath += _T("/");
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
            bstrLDAPDomainPath += bstrDomainDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLDAPDomainPath, &hr);
        }

        if (o_pbstrDomainGuid)
        {
            hr = CrackName(
                      hDS,
                      bstrDomainTrailing,
                      DS_CANONICAL_NAME,
                      DS_UNIQUE_ID_NAME,
                      &bstrDomainGuid
                    );
            BREAK_IF_FAILED(hr);
            RemoveBracesOnGuid(bstrDomainGuid);
        }
    } while (0);

    DsUnBind(&hDS);

  } while (0);

  if (SUCCEEDED(hr))
  {
    if (o_pbstrDC)
      *o_pbstrDC = bstrDCName.Detach();

    if (o_pbstrDomainDnsName)
      *o_pbstrDomainDnsName = bstrDomainDnsName.Detach();

    if (o_pbstrDomainDN)
      *o_pbstrDomainDN = bstrDomainDN.Detach();

    if (o_pbstrLDAPDomainPath)
      *o_pbstrLDAPDomainPath = bstrLDAPDomainPath.Detach();

    if (o_pbstrDomainGuid)
      *o_pbstrDomainGuid = bstrDomainGuid.Detach();
  }

  return hr;
}

void
DebugOutLDAPError(
    IN PLDAP  i_pldap,
    IN ULONG  i_ulError,
    IN PCTSTR i_pszLDAPFunctionName
)
{
#ifdef DEBUG
  if (i_pldap && LDAP_SUCCESS != i_ulError)
  {
    TCHAR *pszExtendedError = NULL;
    DWORD dwErrorEx = ldap_get_optionW(
                        i_pldap,
                        LDAP_OPT_SERVER_ERROR,
                        (void *) &pszExtendedError);
    if (LDAP_SUCCESS == dwErrorEx)
    {
      dfsDebugOut((_T("%s returns error: %x, extended error: %s\n"), 
        i_pszLDAPFunctionName, i_ulError, pszExtendedError)); 
      ldap_memfree(pszExtendedError); 
    } else
    {
      dfsDebugOut((_T("%s returns error: %x\n"), 
        i_pszLDAPFunctionName, i_ulError)); 
    }
  }
#endif // DEBUG
}

int
MyCompareStringN(
    IN LPCTSTR  lpString1,
    IN LPCTSTR  lpString2,
    IN UINT     cchCount,
    IN DWORD    dwCmpFlags
)
{
  UINT  nLen1 = (lpString1 ? lstrlen(lpString1) : 0);
  UINT  nLen2 = (lpString2 ? lstrlen(lpString2) : 0);
  int   nRet = CompareString(
                LOCALE_USER_DEFAULT,
                dwCmpFlags,
                lpString1,
                min(cchCount, nLen1),
                lpString2,
                min(cchCount, nLen2)
              );

  return (nRet - CSTR_EQUAL);
}

int
mylstrncmp(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
)
{
  return MyCompareStringN(lpString1, lpString2, cchCount, 0);
}

int
mylstrncmpi(
    IN LPCTSTR lpString1,
    IN LPCTSTR lpString2,
    IN UINT    cchCount
)
{
  return MyCompareStringN(lpString1, lpString2, cchCount, NORM_IGNORECASE);
}

HRESULT ExtendDN
(
    IN  LPTSTR    i_lpszCN,
    IN  LPTSTR    i_lpszDN,
    OUT BSTR      *o_pbstrNewDN
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrNewDN);
    RETURN_INVALIDARG_IF_TRUE(!i_lpszCN || !*i_lpszCN);

    CComBSTR bstrNewDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
    bstrNewDN += i_lpszCN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
    if (i_lpszDN && *i_lpszDN)
    {
        bstrNewDN += _T(",");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
        bstrNewDN += i_lpszDN;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrNewDN);
    }

    *o_pbstrNewDN = bstrNewDN.Detach();

    return S_OK;
}

HRESULT ExtendDNIfLongJunctionName(
    IN  LPTSTR    i_lpszJunctionName,
    IN  LPCTSTR   i_lpszBaseDN,
    OUT BSTR      *o_pbstrNewDN
)
{
  RETURN_INVALIDARG_IF_NULL(o_pbstrNewDN);
  RETURN_INVALIDARG_IF_TRUE(!i_lpszJunctionName || !*i_lpszJunctionName);

  HRESULT hr = S_OK;

  if (_tcslen(i_lpszJunctionName) > MAX_RDN_KEY_SIZE)
  {
    // junction name is too long to be fit into one CN= name,
    // we need to break it down into several CN= names
    LPTSTR  *paStrings = NULL;
    DWORD   dwEntries = 0;
    hr = GetJunctionPathPartitions((PVOID *)&paStrings, &dwEntries, i_lpszJunctionName);
    if (SUCCEEDED(hr))
    {
      CComBSTR    bstrIn = i_lpszBaseDN;
      CComBSTR    bstrOut;

      for (DWORD i=0; i<dwEntries; i++)
      {
        hr = ExtendDN(paStrings[i], bstrIn, &bstrOut);
        if (FAILED(hr)) break;

        bstrIn = bstrOut;
        bstrOut.Empty();
      }

      free(paStrings);

      if (SUCCEEDED(hr))
        *o_pbstrNewDN = bstrIn.Detach();
    }
  
  } else {
    // junction name can fit into one CN= name
    ReplaceChar(i_lpszJunctionName, _T('\\'), _T('|'));
    hr = ExtendDN(i_lpszJunctionName, (PTSTR)i_lpszBaseDN, o_pbstrNewDN);
  }

  return hr;
}

HRESULT ReplaceChar
(
  IN OUT BSTR    io_bstrString, 
  TCHAR      i_cOldChar,
  TCHAR      i_cNewChar
)
/*++
Routine Description:
  Replace all occurences of a char ("\") with another char ("_") in 
  the given string.
Arguments:
  io_bstrString  - The string which needs to be converted.
  i_cOldChar    - The original character.
  i_cNewChar    - The character to replace the old one with.
--*/
{
  RETURN_INVALIDARG_IF_NULL(io_bstrString);

                    // Replace i_cOldChar by i_cNewChar
                    // allowed in DN.
  LPTSTR lpszTempPtr = _tcschr(io_bstrString, i_cOldChar);

  while (lpszTempPtr)
  {
    *lpszTempPtr = i_cNewChar;
    lpszTempPtr = _tcschr(lpszTempPtr +1,i_cOldChar);
  }

  return S_OK;
}

HRESULT GetJunctionPathPartitions(
    OUT PVOID       *o_ppBuffer,
    OUT DWORD       *o_pdwEntries,
    IN  LPCTSTR      i_pszJunctionPath
)
{
  _ASSERT(o_ppBuffer && o_pdwEntries && i_pszJunctionPath && *i_pszJunctionPath);

  if (!o_ppBuffer || !o_pdwEntries || !i_pszJunctionPath || !(*i_pszJunctionPath))
    return(E_INVALIDARG);

  HRESULT hr = S_OK;
  int     nLength = _tcslen(i_pszJunctionPath);
  DWORD   dwCount = nLength / MAX_RDN_KEY_SIZE + ((nLength % MAX_RDN_KEY_SIZE) ? 1 : 0);
  PBYTE   pBuffer = NULL;

  pBuffer = (PBYTE)calloc(dwCount, sizeof(LPTSTR *) + (MAX_RDN_KEY_SIZE + 1) * sizeof(TCHAR));
  if (!pBuffer)
  {
    hr = E_OUTOFMEMORY;
  } else
  {
    DWORD   i = 0;
    LPTSTR *ppsz = NULL;
    LPTSTR  pString = NULL;

    for (i=0; i<dwCount; i++)
    {
      ppsz = (LPTSTR *)(pBuffer + i * sizeof(LPTSTR *));
      pString = (LPTSTR)(pBuffer + dwCount * sizeof(LPTSTR *) + i * (MAX_RDN_KEY_SIZE + 1) * sizeof(TCHAR));

      _tcsncpy(pString, i_pszJunctionPath, MAX_RDN_KEY_SIZE);
      ReplaceChar(pString, _T('\\'), _T('|'));

      *ppsz = pString;

      i_pszJunctionPath += MAX_RDN_KEY_SIZE;
    }

    *o_ppBuffer = pBuffer;
    *o_pdwEntries = dwCount;

  }

  return hr;
}

HRESULT CreateExtraNodesIfLongJunctionName(
    IN PLDAP   i_pldap,
    IN LPCTSTR i_lpszJunctionName,
    IN LPCTSTR i_lpszBaseDN,
    IN LPCTSTR i_lpszObjClass
)
{
  _ASSERT(i_pldap && 
          i_lpszJunctionName && *i_lpszJunctionName &&
          i_lpszBaseDN && *i_lpszBaseDN &&
          i_lpszObjClass && *i_lpszObjClass);

  HRESULT hr = S_OK;

  if (_tcslen(i_lpszJunctionName) > MAX_RDN_KEY_SIZE)
  {
    // junction name is too long to be fit into one CN= name,
    // we need to break it down into several CN= names
    LPTSTR  *paStrings = NULL;
    DWORD   dwEntries = 0;

    hr = GetJunctionPathPartitions((PVOID *)&paStrings, &dwEntries, i_lpszJunctionName);
    if (SUCCEEDED(hr))
    {
      DWORD       i = 0;
      CComBSTR    bstrIn = i_lpszBaseDN;
      CComBSTR    bstrOut;

      for (i=0; i<(dwEntries-1); i++)
      {
        hr = ExtendDN(paStrings[i], bstrIn, &bstrOut);
        if (SUCCEEDED(hr))
          hr = CreateObjectSimple(i_pldap, bstrOut, i_lpszObjClass);
        if (FAILED(hr)) break;

        bstrIn = bstrOut;
        bstrOut.Empty();
      }

      free(paStrings);
    }

  }  // > MAX_RDN_KEY_SIZE

  return hr;
}

HRESULT CreateObjectSimple(
    IN PLDAP    i_pldap,
    IN LPCTSTR  i_lpszDN,
    IN LPCTSTR  i_lpszObjClass
)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_lpszDN);
    RETURN_INVALIDARG_IF_NULL(i_lpszObjClass);

    LDAP_ATTR_VALUE  pAttrVals[1];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)i_lpszObjClass;
    pAttrVals[0].bBerValue = false;

    return AddValues(
                    i_pldap,
                    i_lpszDN,
                    1,
                    pAttrVals
                    );
}

HRESULT DeleteExtraNodesIfLongJunctionName(
    IN PLDAP   i_pldap,
    IN LPCTSTR i_lpszJunctionName,
    IN LPCTSTR i_lpszDN
)
{
  _ASSERT(i_pldap &&
          i_lpszJunctionName && *i_lpszJunctionName &&
          i_lpszDN && *i_lpszDN);

  DWORD   nLength = _tcslen(i_lpszJunctionName);
  if (nLength > MAX_RDN_KEY_SIZE)
  {
    DWORD   dwEntries = nLength / MAX_RDN_KEY_SIZE + ((nLength % MAX_RDN_KEY_SIZE) ? 1 : 0); 

    (void) DeleteAncestorNodesIfEmpty(i_pldap, i_lpszDN+3, dwEntries-1);
  }

  return S_OK;
}

HRESULT
CreateObjectsRecursively(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrDN,
    IN UINT         i_nLenPrefix,
    IN LPCTSTR      i_lpszObjClass)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDN);
    RETURN_INVALIDARG_IF_NULL(i_lpszObjClass);

    if (0 == i_nLenPrefix)
        return S_OK;

    HRESULT hr = IsValidObject(i_pldap, i_bstrDN);
    if (S_OK == hr)
        return S_OK;

    CComBSTR  bstrPrefix = CComBSTR(i_nLenPrefix, i_bstrDN);
    PTSTR     pszNextPrefix = _tcsstr(bstrPrefix + 3, _T("CN="));
    UINT      nLengthNext = (pszNextPrefix ? _tcslen(pszNextPrefix) : 0);
    UINT      nLengthThis = (pszNextPrefix ? (pszNextPrefix - bstrPrefix) : _tcslen(bstrPrefix));

    hr = CreateObjectsRecursively(
                                    i_pldap,
                                    i_bstrDN + nLengthThis,
                                    nLengthNext,
                                    i_lpszObjClass);

    if (SUCCEEDED(hr))
        hr = CreateObjectSimple(
                            i_pldap, 
                            i_bstrDN, 
                            i_lpszObjClass);

    return hr;
}

HRESULT DeleteAncestorNodesIfEmpty(
    IN PLDAP   i_pldap,
    IN LPCTSTR i_lpszDN,
    IN DWORD   i_dwCount
)
{
  _ASSERT(i_pldap &&
          i_lpszDN && *i_lpszDN &&
          i_dwCount > 0);

  DWORD   i = 0;
  LPTSTR  p = NULL;

  for (i=0; i<i_dwCount; i++)
  {
    p = _tcsstr(i_lpszDN, _T("CN="));
    if (p)
    {
      (void) DeleteDSObject(i_pldap, p, false);

      i_lpszDN = p+3;
    }
  }

  return S_OK;
}

HRESULT GetDfsLinkNameFromDN(
    IN  BSTR    i_bstrReplicaSetDN, 
    OUT BSTR*   o_pbstrDfsLinkName)
{
    if (!i_bstrReplicaSetDN || !*i_bstrReplicaSetDN || !o_pbstrDfsLinkName)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    PTSTR   pszReplicaSetDN = NULL;

    do {
        //
        // make a copy of the string
        //
        pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
        BREAK_OUTOFMEMORY_IF_NULL(pszReplicaSetDN, &hr);

        //
        // change the string to all upper cases
        //
        _tcsupr(pszReplicaSetDN);

        //
        // get rid of suffix: Dfs Volumes\File Replication Service\system\.....
        //
        TCHAR* p = _tcsstr(pszReplicaSetDN, _T(",CN=DFS VOLUMES"));
        if (!p)
        {
            hr = E_INVALIDARG;
            break;
        }
        *p = _T('\0'); 

        //
        // reverse the string
        //
        _tcsrev(pszReplicaSetDN);

        //
        // get rid of the CN= clause about the DfsRoot container
        //
        PTSTR pszCN = _tcsstr(pszReplicaSetDN, _T("=NC,"));
        if (!pszCN)
        {
            hr = E_INVALIDARG;
            break;
        }
        pszCN += 4; // after this tep, pszCN points at the delta

        //
        // Now, the left over CN= clauses are all related to Dfs Link name
        //
        p = _tcsstr(pszCN, _T("=NC"));
        if (!p)
        {
            hr = E_INVALIDARG;  // there must be at least one CN= clause
            break;
        }

        CComBSTR bstrLinkName;
        do {
            *p = _T('\0');
            _tcsrev(pszCN);
            bstrLinkName += pszCN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrLinkName, &hr);

            pszCN = p + 3; // points to the next CN= clause
            if (*pszCN && *pszCN == _T(','))
                pszCN++;

            if (!*pszCN)
                break;      // no more CN= clauses

            p = _tcsstr(pszCN, _T("=NC"));
        } while (p);

        if (SUCCEEDED(hr))
        {
            ReplaceChar(bstrLinkName, _T('|'), _T('\\'));
            *o_pbstrDfsLinkName = bstrLinkName.Detach();
        }
    } while (0);

    if (pszReplicaSetDN)
        free(pszReplicaSetDN);

    return hr;
}

HRESULT GetSubscriberDN(
    IN  BSTR    i_bstrReplicaSetDN,
    IN  BSTR    i_bstrDomainGuid,
    IN  BSTR    i_bstrComputerDN,
    OUT BSTR*   o_pbstrSubscriberDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrDomainGuid);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(o_pbstrSubscriberDN);

    HRESULT hr = S_OK;

    CComBSTR bstrSubscriberDN;

    PTSTR pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
    RETURN_OUTOFMEMORY_IF_NULL(pszReplicaSetDN);

    _tcsupr(pszReplicaSetDN); // change to all upper case

    do {
        TCHAR* p = _tcsstr(pszReplicaSetDN, _T(",CN=DFS VOLUMES"));
        if (!p)
        {
            hr = E_INVALIDARG;
            break;
        }

        bstrSubscriberDN = CComBSTR((int)(p - pszReplicaSetDN) + 4, i_bstrReplicaSetDN);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
        bstrSubscriberDN += i_bstrDomainGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
        bstrSubscriberDN += _T(",CN=DFS Volumes,CN=NTFRS Subscriptions,");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
        bstrSubscriberDN += i_bstrComputerDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrSubscriberDN, &hr);
    } while (0);

    free(pszReplicaSetDN);

    if (SUCCEEDED(hr))
        *o_pbstrSubscriberDN = bstrSubscriberDN.Detach();

    return hr;
}


HRESULT CreateNtfrsMemberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrComputerDN,
    IN BSTR     i_bstrDCofComputerObj
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);

    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[2];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)OBJCLASS_NTFRSMEMBER;
    pAttrVals[0].bBerValue = false;

    pAttrVals[1].bstrAttribute = ATTR_FRS_MEMBER_COMPUTERREF;
    pAttrVals[1].vpValue = (void *)i_bstrComputerDN;
    pAttrVals[1].bBerValue = false;

    hr = AddValues(
            i_pldap,
            i_bstrMemberDN,
            2,
            pAttrVals,
            i_bstrDCofComputerObj
            );
    
    return hr;
}

HRESULT CreateNtfrsSubscriberObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrMemberDN,
    IN BSTR     i_bstrRootPath,
    IN BSTR     i_bstrStagingPath,
    IN BSTR     i_bstrDC            // validate MemberDN against this DC
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrRootPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrStagingPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrDC);

    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[4];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)OBJCLASS_NTFRSSUBSCRIBER;
    pAttrVals[0].bBerValue = false;

    pAttrVals[1].bstrAttribute = ATTR_FRS_SUBSCRIBER_MEMBERREF;
    pAttrVals[1].vpValue = (void *)i_bstrMemberDN;
    pAttrVals[1].bBerValue = false;

    pAttrVals[2].bstrAttribute = ATTR_FRS_SUBSCRIBER_ROOTPATH;
    pAttrVals[2].vpValue = (void *)i_bstrRootPath;
    pAttrVals[2].bBerValue = false;

    pAttrVals[3].bstrAttribute = ATTR_FRS_SUBSCRIBER_STAGINGPATH;
    pAttrVals[3].vpValue = (void *)i_bstrStagingPath;
    pAttrVals[3].bBerValue = false;

    hr = AddValues(
            i_pldap,
            i_bstrSubscriberDN,
            4,
            pAttrVals,
            i_bstrDC
            );
    
    return hr;
}

HRESULT CreateNtdsConnectionObject(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrConnectionDN,
    IN BSTR     i_bstrFromMemberDN,
    IN BOOL     i_bEnable,
    IN DWORD    i_dwOptions
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);

    HRESULT hr = S_OK;

    LDAP_ATTR_VALUE  pAttrVals[4];

    pAttrVals[0].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
    pAttrVals[0].vpValue = (void *)OBJCLASS_NTDSCONNECTION;
    pAttrVals[0].bBerValue = false;

    pAttrVals[1].bstrAttribute = ATTR_NTDS_CONNECTION_FROMSERVER;
    pAttrVals[1].vpValue = (void *)i_bstrFromMemberDN;
    pAttrVals[1].bBerValue = false;

    pAttrVals[2].bstrAttribute = ATTR_NTDS_CONNECTION_ENABLEDCONNECTION;
    pAttrVals[2].vpValue = (void *)(i_bEnable ? CONNECTION_ENABLED_TRUE : CONNECTION_ENABLED_FALSE);
    pAttrVals[2].bBerValue = false;

    TCHAR szOptions[16] = {0};
    _ultot(i_dwOptions, szOptions, 10);

    pAttrVals[3].bstrAttribute = ATTR_NTDS_CONNECTION_OPTIONS;
    pAttrVals[3].vpValue = (void *)szOptions;
    pAttrVals[3].bBerValue = false;

    hr = AddValues(
            i_pldap,
            i_bstrConnectionDN,
            4,
            pAttrVals
            );

    return hr;
}

#define CN_SEARCH_UPR_DFSVOL_FRS_SYS    _T(",CN=DFS VOLUMES,CN=FILE REPLICATION SERVICE,CN=SYSTEM")
#define CN_SEARCH_UPR_SYS               _T(",CN=SYSTEM")
#define CN_SEARCH_UPR_FRS_SYS           _T(",CN=FILE REPLICATION SERVICE,CN=SYSTEM")

HRESULT CreateNtfrsSettingsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);

    HRESULT hr = S_OK;

    //
    // The first CN= clause is a nTFRSReplicaSet object.
    // The clauses from the 2nd to the CN=System clause should be created
    // as nTFRSSettings objects
    //
    PTSTR pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
    RETURN_OUTOFMEMORY_IF_NULL(pszReplicaSetDN);

    _tcsupr(pszReplicaSetDN);

    TCHAR *pszNtfrsSettingsDN = NULL;
    int lenPrefix = 0;
    do {
        // have pStart point at the 2nd CN=
        TCHAR *pStart = _tcsstr(pszReplicaSetDN, _T(",CN="));
        if (!pStart)
        {
            hr = E_INVALIDARG;
            break;
        }
        pStart++;

        // have pEnd points at the CN=SYSTEM
        TCHAR *pEnd = _tcsstr(pszReplicaSetDN, CN_SEARCH_UPR_DFSVOL_FRS_SYS);
        if (!pEnd)
        {
            hr = E_INVALIDARG;
            break;
        }
        pEnd += lstrlen(CN_SEARCH_UPR_DFSVOL_FRS_SYS) - lstrlen(CN_SEARCH_UPR_SYS) + 1;

        //
        // calculate
        //
        pszNtfrsSettingsDN = i_bstrReplicaSetDN + ((BYTE*)pStart - (BYTE*)pszReplicaSetDN) / sizeof(TCHAR);
        lenPrefix = (int)((BYTE*)pEnd - (BYTE*)pStart) / sizeof(TCHAR);
    } while (0);

    free(pszReplicaSetDN);

    RETURN_IF_FAILED(hr);

    hr = CreateObjectsRecursively(
                                i_pldap,
                                pszNtfrsSettingsDN,
                                lenPrefix,
                                OBJCLASS_NTFRSSETTINGS
                                );
    return hr;
}
        
HRESULT CreateNtfrsSubscriptionsObjects(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);

    //
    // The first CN= clause is a nTFRSSubscriber object.
    // The clauses from the 2nd to the CN=<computer> clause should be created
    // as nTFRSSubscriptions objects
    //

    // have pStart point at the 2nd CN=
    TCHAR *pStart = _tcsstr(i_bstrSubscriberDN, _T(",CN="));
    RETURN_INVALIDARG_IF_NULL(pStart);
    pStart++;

    //
    // calculate
    //
    TCHAR *pszNtfrsSubscriptionsDN = pStart;
    int lenPrefix = lstrlen(pszNtfrsSubscriptionsDN) - lstrlen(i_bstrComputerDN);

    HRESULT hr = CreateObjectsRecursively(
                                i_pldap,
                                pszNtfrsSubscriptionsDN,
                                lenPrefix,
                                OBJCLASS_NTFRSSUBSCRIPTIONS
                                );
    return hr;
}

HRESULT DeleteNtfrsReplicaSetObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrReplicaSetDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);

    HRESULT hr = S_OK;

    //
    // The first CN= clause is a nTFRSReplicaSet object.
    // The clauses from the 2nd to the CN=File Replication Service clause should 
    // be deleted if empty
    //
    PTSTR pszReplicaSetDN = _tcsdup(i_bstrReplicaSetDN);
    RETURN_OUTOFMEMORY_IF_NULL(pszReplicaSetDN);

    _tcsupr(pszReplicaSetDN);

    int lenPrefix = 0;
    TCHAR *pStart = NULL;
    do {
        // have pStart point at the 2nd CN=
        pStart = _tcsstr(pszReplicaSetDN, _T(",CN="));
        if (!pStart)
        {
            hr = E_INVALIDARG;
            break;
        }
        pStart++;

        // have pEnd points at the CN=FILE REPLICATION SERVICE
        TCHAR *pEnd = _tcsstr(pszReplicaSetDN, CN_SEARCH_UPR_DFSVOL_FRS_SYS);
        if (!pEnd)
        {
            hr = E_INVALIDARG;
            break;
        }
        pEnd += lstrlen(CN_SEARCH_UPR_DFSVOL_FRS_SYS) - lstrlen(CN_SEARCH_UPR_FRS_SYS) + 1;

        //
        // calculate
        //
        lenPrefix = (int)((BYTE*)pEnd - (BYTE*)pStart) / sizeof(TCHAR);
    } while (0);

    if (SUCCEEDED(hr))
    {
        // forcibly blow away the replicaset object
        hr = DeleteDSObject(i_pldap, i_bstrReplicaSetDN, true);
        if (SUCCEEDED(hr))
        {
            // delete replicasettings objects if empty
            hr = DeleteDSObjectsIfEmpty(
                                        i_pldap,
                                        pStart,
                                        lenPrefix
                                        );
        }
    }

    free(pszReplicaSetDN);

    return hr;
}

HRESULT DeleteNtfrsSubscriberObjectAndContainers(
    IN PLDAP    i_pldap,
    IN BSTR     i_bstrSubscriberDN,
    IN BSTR     i_bstrComputerDN
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);

    //
    // The first CN= clause is a nTFRSSubscriber object.
    // The clauses from the 1st to the CN=<computer> clause should 
    // be deleted if empty
    //

    //
    // calculate
    //
    int lenPrefix = lstrlen(i_bstrSubscriberDN) - lstrlen(i_bstrComputerDN);

    HRESULT hr = DeleteDSObjectsIfEmpty(
                                i_pldap,
                                i_bstrSubscriberDN,
                                lenPrefix
                                );
    return hr;
}

HRESULT DeleteDSObjectsIfEmpty(
    IN PLDAP    i_pldap,
    IN LPCTSTR  i_lpszDN,
    IN int      i_nPrefixLength
)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_lpszDN);
    RETURN_INVALIDARG_IF_NULL(i_nPrefixLength);

    HRESULT hr = S_OK;
    TCHAR   *p = (PTSTR)i_lpszDN;

    while (p < i_lpszDN + i_nPrefixLength)
    {
        hr = DeleteDSObject(i_pldap, p, false);
        BREAK_IF_FAILED(hr);

        p = _tcsstr(p, _T(",CN="));
        if (!p)
            break;
        p++;
    }

  return hr;
}

HRESULT SetConnectionSchedule(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrConnectionDN,
    IN SCHEDULE*    i_pSchedule)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_pSchedule);

    //
    // set attribute schedule of this nTDSConnection object
    //
    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_SCHEDULE;
    pAttrVals[0].vpValue = (void *)i_pSchedule;
    pAttrVals[0].ulLength = i_pSchedule->Size;
    pAttrVals[0].bBerValue = true;

    return ::ModifyValues(i_pldap, i_bstrConnectionDN, 1, pAttrVals);
}

HRESULT SetConnectionOptions(
    IN PLDAP        i_pldap,
    IN BSTR         i_bstrConnectionDN,
    IN DWORD        i_dwOptions)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);

    //
    // set attribute options of this nTDSConnection object
    //
    TCHAR szOptions[16] = {0};
    _ultot(i_dwOptions, szOptions, 10);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_OPTIONS;
    pAttrVals[0].vpValue = (void *)szOptions;
    pAttrVals[0].bBerValue = false;

    return ::ModifyValues(i_pldap, i_bstrConnectionDN, 1, pAttrVals);
}

HRESULT UuidToStructuredString(
    UUID*  i_pUuid,
    BSTR*  o_pbstr
)
{
    if (!i_pUuid || !o_pbstr)
        return E_INVALIDARG;

    TCHAR szString[40];

    _stprintf( szString,
           _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
           i_pUuid->Data1,
           i_pUuid->Data2,
           i_pUuid->Data3,
           i_pUuid->Data4[0],
           i_pUuid->Data4[1],
           i_pUuid->Data4[2],
           i_pUuid->Data4[3],
           i_pUuid->Data4[4],
           i_pUuid->Data4[5],
           i_pUuid->Data4[6],
           i_pUuid->Data4[7] );

    *o_pbstr = SysAllocString(szString);
    if (!*o_pbstr)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT ScheduleToVariant(
    IN  SCHEDULE*   i_pSchedule,
    OUT VARIANT*    o_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_pSchedule);
    RETURN_INVALIDARG_IF_NULL(o_pVar);

    VariantInit(o_pVar);
    o_pVar->vt = VT_ARRAY | VT_VARIANT;
    o_pVar->parray = NULL;

    int nItems = i_pSchedule->Size;

    SAFEARRAYBOUND  bounds = {nItems, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    for (int i = 0; i < nItems; i++)
    {
        varArray[i].vt = VT_UI1;
        varArray[i].cVal = *((BYTE *)i_pSchedule + i);
    }

    SafeArrayUnaccessData(psa);

    o_pVar->parray = psa;

    return S_OK;
}

HRESULT VariantToSchedule(
    IN  VARIANT*    i_pVar,
    OUT PSCHEDULE*  o_ppSchedule    // freed by caller
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pVar);
    RETURN_INVALIDARG_IF_NULL(o_ppSchedule);

    HRESULT hr = S_OK;

    if (V_VT(i_pVar) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa = V_ARRAY(i_pVar);
    long        lLowerBound = 0;
    long        lUpperBound = 0;
    long        lCount = 0;

    SafeArrayGetLBound(psa, 1, &lLowerBound );
    SafeArrayGetUBound(psa, 1, &lUpperBound );
    lCount = lUpperBound - lLowerBound + 1;

    BYTE *pSchedule = (BYTE *)calloc(lCount, 1);
    RETURN_OUTOFMEMORY_IF_NULL(pSchedule);

    VARIANT HUGEP *pArray;
    SafeArrayAccessData(psa, (void HUGEP **) &pArray);

    for (int i = 0; i < lCount; i++)
    {
        if (VT_UI1 != pArray[i].vt)
        {
            hr = E_INVALIDARG;
            break;
        }

        pSchedule[i] = pArray[i].cVal;
    }

    SafeArrayUnaccessData(psa);

    if (FAILED(hr))
        free(pSchedule);
    else
        *o_ppSchedule = (SCHEDULE *)pSchedule;

    return hr;
}

HRESULT CompareSchedules(
    IN  SCHEDULE*  i_pSchedule1,
    IN  SCHEDULE*  i_pSchedule2
    )
{
    if (!i_pSchedule1 && !i_pSchedule2)
        return S_OK;
    else if (!i_pSchedule1 || !i_pSchedule2)
        return S_FALSE;
    else if (i_pSchedule1->Size != i_pSchedule2->Size)
        return S_FALSE;

    HRESULT hr = S_OK;
    for (ULONG i = 0; i < i_pSchedule1->Size; i++)
    {
        if (*((BYTE *)i_pSchedule1 + i) != *((BYTE *)i_pSchedule2 + i))
        {
            hr = S_FALSE;
            break;
        }
    }

    return hr;
}

HRESULT CopySchedule(
    IN  SCHEDULE*  i_pSrcSchedule,
    OUT PSCHEDULE* o_ppDstSchedule
    )
{
    RETURN_INVALIDARG_IF_NULL(i_pSrcSchedule);
    RETURN_INVALIDARG_IF_NULL(o_ppDstSchedule);

    *o_ppDstSchedule = (SCHEDULE *)calloc(i_pSrcSchedule->Size, 1);
    RETURN_OUTOFMEMORY_IF_NULL(*o_ppDstSchedule);

    memcpy(*o_ppDstSchedule, i_pSrcSchedule, i_pSrcSchedule->Size);

    return S_OK;
}

HRESULT GetDefaultSchedule(
    OUT PSCHEDULE* o_ppSchedule
    )
{
    RETURN_INVALIDARG_IF_NULL(o_ppSchedule);

    SCHEDULE* pSchedule = (SCHEDULE *)calloc(20 + SCHEDULE_DATA_ENTRIES, 1);
    RETURN_OUTOFMEMORY_IF_NULL(pSchedule);

    pSchedule->Size = 20 + SCHEDULE_DATA_ENTRIES;
    pSchedule->Bandwidth = 0; // not used
    pSchedule->NumberOfSchedules = 1;
    pSchedule->Schedules->Type = SCHEDULE_INTERVAL;
    pSchedule->Schedules->Offset = 20;
    memset((BYTE *)pSchedule + 20, 1, SCHEDULE_DATA_ENTRIES);

    *o_ppSchedule = pSchedule;

    return S_OK;
}

//
// S_OK: Whistler version
// S_FALSE: Windows2000 version
// others: error occurred
//
HRESULT GetSchemaVersion(IN PLDAP    i_pldap)
{
    RETURN_INVALIDARG_IF_NULL(i_pldap);

    LDAP_ATTR_VALUE  pAttributes[1];
    pAttributes[0].bstrAttribute = ATTR_SCHEMANAMINGCONTEXT;
    pAttributes[0].bBerValue = false;

    PLDAP_ATTR_VALUE pDNName[1] = {0};
    HRESULT hr = GetValues(  i_pldap, 
            _T(""),             // LDAP Root.
            OBJCLASS_SF_ALL,    // All Objects
            LDAP_SCOPE_BASE,
            1,                  // Only 1 attribute
            pAttributes,        // schemaNamingContext Attribute.
            pDNName             // List of all values at Root for schemaNamingContext.
            );

    if (FAILED(hr))
        return(hr);

    if (!(pDNName[0]))
        return S_FALSE;

    if (!(pDNName[0]->vpValue) || !*((LPTSTR)pDNName[0]->vpValue))
    {
        FreeAttrValList(pDNName[0]);
        return S_FALSE;
    }

    CComBSTR bstrSchemaNamingContext = (LPTSTR)pDNName[0]->vpValue;

    FreeAttrValList(pDNName[0]);

    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSchemaNamingContext);

    CComBSTR bstrReplicaSetSchemaDN = DN_PREFIX_SCHEMA_REPLICASET;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrReplicaSetSchemaDN);
    bstrReplicaSetSchemaDN += bstrSchemaNamingContext;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrReplicaSetSchemaDN);

    BOOL        bFound = FALSE;
    PCTSTR      ppszAttributes[] = {ATTR_SYSTEMMAYCONTAIN, 0};
    LListElem*  pElem = NULL;
    hr = GetValuesEx(
                    i_pldap,
                    bstrReplicaSetSchemaDN,
                    LDAP_SCOPE_BASE,
                    OBJCLASS_SF_CLASSSCHEMA,
                    ppszAttributes,
                    &pElem);

    if (SUCCEEDED(hr) && pElem && pElem->pppszAttrValues)
    {
        PTSTR* ppszValues = *(pElem->pppszAttrValues);
        if (ppszValues)
        {
            while (*ppszValues)
            {
                if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, ATTR_FRS_REPSET_TOPOLOGYPREF, -1, *ppszValues, -1))
                {
                    bFound = TRUE;
                    break;
                }
                ppszValues++;
            }
        }

        FreeLListElem(pElem);
    }

    RETURN_IF_FAILED(hr);

    return (bFound ? S_OK : S_FALSE);
}

//
// S_OK: Whistler version
// S_FALSE: Windows2000 version
// others: error occurred
//
HRESULT GetSchemaVersionEx(
    IN BSTR i_bstrName,
    IN BOOL i_bServer // =TRUE if i_bstrName is a server, FALSE if i_bstrName is a domain
    )
{
    HRESULT hr = S_OK;

    PTSTR pszDomain = NULL;

    do {
        CComBSTR bstrDomain;
        if (i_bServer)
        {
            hr = GetServerInfo(i_bstrName, &bstrDomain);
            if (S_OK != hr)
                break;
            pszDomain = bstrDomain;
        } else
        {
            pszDomain = i_bstrName;
        }

        PLDAP pldap = NULL;
        hr = ConnectToDS(pszDomain, &pldap, NULL);
        if (SUCCEEDED(hr))
        {
            hr = GetSchemaVersion(pldap);
            CloseConnectionToDS(pldap);
        }
    } while (0);

    return hr;
}

//
// This function doesn't refetch DC in case of LDAP_SERVER_DOWN
//
HRESULT LdapConnectToDC(IN LPCTSTR i_pszDC, OUT PLDAP* o_ppldap)
{
    if (!i_pszDC || !*i_pszDC || !o_ppldap)
        return E_INVALIDARG;

    *o_ppldap = NULL;

    PLDAP pldap = ldap_init((LPTSTR)i_pszDC, LDAP_PORT);
    if (!pldap)
        return HRESULT_FROM_WIN32(GetLastError());

    //
    // Making ldap_open/ldap_connect with a server name without first setting 
    // LDAP_OPT_AREC_EXCLUSIVE (for ldap interfaces) or 
    // ADS_SERVER_BIND (for ADSI interfaces) will result in bogus DNS queries 
    // consuming bandwidth and potentially bringing up remote links that are 
    // costly or demand dial.
    //
    // ignore the return of ldap_set_option
    ldap_set_option(pldap, LDAP_OPT_AREC_EXCLUSIVE, LDAP_OPT_ON);

    ULONG ulRet = ldap_connect(pldap, NULL); // NULL for the default timeout
    if (LDAP_SUCCESS != ulRet)
    {
        ldap_unbind(pldap);
        return HRESULT_FROM_WIN32(LdapMapErrorToWin32(ulRet));
    }

    *o_ppldap = pldap;

    return S_OK;

}

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT BSTR*        o_pbstrErrorMsg
)
{
  if (0 == i_dwError || !o_pbstrErrorMsg)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;
  LPTSTR       lpBuffer = NULL;

  DWORD dwRet = ::FormatMessage(
              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
              (LPTSTR)&lpBuffer, 0, NULL);
  if (0 == dwRet)
  {
    // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
        0x80070000 == (i_dwError & 0xffff0000) ||
        0 == (i_dwError & 0xffff0000) )
    { // Try locating the message from NetMsg.dll.
      hr = S_OK;
      DWORD dwNetError = i_dwError & 0x0000ffff;
      
      HINSTANCE  hLib = LoadLibrary(_T("netmsg.dll"));
      if (!hLib)
        hr = HRESULT_FROM_WIN32(GetLastError());
      else
      {
        dwRet = ::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
            hLib, dwNetError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
            (LPTSTR)&lpBuffer, 0, NULL);

        if (0 == dwRet)
          hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hLib);
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    *o_pbstrErrorMsg = SysAllocString(lpBuffer);
    LocalFree(lpBuffer);
  }
  else
  {
    // we failed to retrieve the error message from system/netmsg.dll,
    // report the error code directly to user
    hr = S_OK;
    TCHAR szString[32];
    _stprintf(szString, _T("0x%x"), i_dwError); 
    *o_pbstrErrorMsg = SysAllocString(szString);
  }

  if (!*o_pbstrErrorMsg)
    hr = E_OUTOFMEMORY;

  return hr;
}

HRESULT
FormatMessageString(
  OUT BSTR *o_pbstrMsg,
  IN  DWORD dwErr,
  IN  UINT  iStringId, // OPTIONAL: String resource Id
  ...)        // Optional arguments
{
  _ASSERT(dwErr != 0 || iStringId != 0);    // One of the parameter must be non-zero

  HRESULT hr = S_OK;
  CComBSTR bstrErrorMsg, bstrMsg;

  if (dwErr)
    hr = GetErrorMessage(dwErr, &bstrErrorMsg);

  if (SUCCEEDED(hr))
  {
    if (iStringId == 0)
    {
      bstrMsg = bstrErrorMsg;
      RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrMsg);
    }
    else
    {
      TCHAR szString[1024];
      ::LoadString(_Module.GetModuleInstance(), iStringId, 
                   szString, sizeof(szString)/sizeof(TCHAR));

      va_list arglist;
      va_start(arglist, iStringId);

      LPTSTR lpBuffer = NULL;
      DWORD dwRet = ::FormatMessage(
                        FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                        szString,
                        0,                // dwMessageId
                        0,                // dwLanguageId, ignored
                        (LPTSTR)&lpBuffer,
                        0,            // nSize
                        &arglist);
      va_end(arglist);

      if (dwRet == 0)
      {
        hr = HRESULT_FROM_WIN32(GetLastError());
      }
      else
      {
        bstrMsg = lpBuffer;
        LocalFree(lpBuffer);

        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrMsg);

        if (dwErr)
        {
          bstrMsg += bstrErrorMsg;
          RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrMsg);
        }
      }
    }
  }

  if (SUCCEEDED(hr))
    *o_pbstrMsg = bstrMsg.Detach();

  return hr;
}

//
// This function will DsBind to a valid DC (DC is re-fetched if down)
//
HRESULT DsBindToDS(BSTR i_bstrDomain, BSTR *o_pbstrDC, HANDLE *o_phDS)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrDC);
    RETURN_INVALIDARG_IF_NULL(o_phDS);

    HRESULT     hr = S_OK;
    BOOL        bRetry = FALSE;
    HANDLE      hDS = NULL;
    DWORD       dwErr = ERROR_SUCCESS;
    CComBSTR    bstrDCName;
    CComBSTR    bstrDomainDnsName;

    do {
#ifdef DEBUG
        SYSTEMTIME time0 = {0};
        GetSystemTime(&time0);
#endif // DEBUG

        PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
        if (bRetry)
            dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME | DS_FORCE_REDISCOVERY, &pDCInfo);
        else
            dwErr = DsGetDcName(NULL, i_bstrDomain, NULL, NULL,
                DS_DIRECTORY_SERVICE_PREFERRED | DS_RETURN_DNS_NAME, &pDCInfo);

#ifdef DEBUG
        SYSTEMTIME time1 = {0};
        GetSystemTime(&time1);
        PrintTimeDelta(_T("DsBindToDS-DsGetDcName"), &time0, &time1);
#endif // DEBUG

        if (ERROR_SUCCESS != dwErr)
            return HRESULT_FROM_WIN32(dwErr);

        if ( !mylstrncmpi(pDCInfo->DomainControllerName, _T("\\\\"), 2) )
            bstrDCName = pDCInfo->DomainControllerName + 2;
        else
            bstrDCName = pDCInfo->DomainControllerName;
    
        // remove the ending dot
        int len = _tcslen(pDCInfo->DomainName);
        if ( _T('.') == *(pDCInfo->DomainName + len - 1) )
            *(pDCInfo->DomainName + len - 1) = _T('\0');
        bstrDomainDnsName = pDCInfo->DomainName;

        NetApiBufferFree(pDCInfo);

        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDCName, &hr);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrDomainDnsName, &hr);

        dwErr = DsBind(bstrDCName, bstrDomainDnsName, &hDS);
        hr = HRESULT_FROM_WIN32(dwErr);

#ifdef DEBUG
        SYSTEMTIME time2 = {0};
        GetSystemTime(&time2);
        PrintTimeDelta(_T("DsBindToDS-DsBind"), &time1, &time2);
#endif // DEBUG

        if ((RPC_S_SERVER_UNAVAILABLE == dwErr || RPC_S_CALL_FAILED == dwErr) && !bRetry)
        {
            bRetry = TRUE; // only retry once
        } else
        {
            if (SUCCEEDED(hr))
            {
                *o_phDS = hDS;

                *o_pbstrDC = bstrDCName.Copy();
                if (!*o_pbstrDC)
                {
                    hr = E_OUTOFMEMORY;
                    DsUnBind(&hDS);
                    *o_phDS = NULL;
                }
            }

            break;
        }
    } while (1);

    return hr;
}

#ifdef DEBUG
void PrintTimeDelta(LPCTSTR pszMsg, SYSTEMTIME* pt0, SYSTEMTIME* pt1)
{
    if (!pt0 || !pt1)
        return;

    dfsDebugOut((_T("%s took %d milliseconds.\n"), (pszMsg ? pszMsg : _T("")), 
        ((pt1->wMinute - pt0->wMinute) * 60 +
         (pt1->wSecond - pt0->wSecond)) * 1000 +
         (pt1->wMilliseconds - pt0->wMilliseconds)
         ));
}
#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\netutils.cpp ===
/**
Module Name:

NetUtils.cpp

Abstract:
  This is the implementation file for the utility functions for Network APIs.

*/

#include "NetUtils.h"
#include <winsock2.h>
#include <stack>
#include <ntdsapi.h>
#include <ldaputils.h>
#include <lmdfs.h>
#include <dsrole.h>
#include <dns.h>  //DNS_MAX_NAME_BUFFER_LENGTH
//----------------------------------------------------------------------------------

HRESULT FlatAdd
(
  DOMAIN_DESC*      i_pDomDesc,      // Pointer to the Domain Description Structure returned by IBrowserDomainTree::GetDomains()
  OUT NETNAMELIST*  o_pDomainList    // Pointer to the list of NETNAME is returned here.
)
/*++

Routine Description:

  This function flattens the domain tree returned by GetDomains() method
  of IBrowserDomainTree into a NETNAME list.
  This code produces a preorder traversal method.

Arguments:

  i_pDomDesc    -  Pointer to the Domain Description Structure returned by IBrowserDomainTree::GetDomains()  
  o_pDomainList  -  Pointer to the list of NETNAME is returned here.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pDomDesc);
    RETURN_INVALIDARG_IF_NULL(o_pDomainList);

    HRESULT             hr = S_OK;
    stack<DOMAIN_DESC*> Stack;  

    Stack.push(i_pDomDesc);
    while (!Stack.empty())
    {
        DOMAIN_DESC* pDomDesc = Stack.top();
        Stack.pop();

        NETNAME* pCurrent = new NETNAME;
        BREAK_OUTOFMEMORY_IF_NULL(pCurrent, &hr);

        pCurrent->bstrNetName = pDomDesc->pszName;
        if (!(pCurrent->bstrNetName))
        {
            delete pCurrent;
            hr = E_OUTOFMEMORY;
            break;
        }

                          // Add to the output list.
        o_pDomainList->push_back(pCurrent);

        if (pDomDesc->pdNextSibling)
            Stack.push(pDomDesc->pdNextSibling);

        if (pDomDesc->pdChildList)
            Stack.push(pDomDesc->pdChildList);
    }

    if (FAILED(hr))
        FreeNetNameList(o_pDomainList);

    return hr;
}

HRESULT Get50Domains
(
  OUT NETNAMELIST*  o_pDomains        // List of NETNAME structures.
)
/*++

Routine Description:

  Returns a list of all NT 5.0 domains in a list of NETNAME structures

Arguments:

  o_pDomains   -  Pointer to list of NETNAME structures is returned.

--*/

//  This method uses the DsDomainTreeBrowser COM Object to get the list
//  of domain names from the DS. The Domain tree returned is then flatened out
//  by using preorder traversal algorithm.
{
    RETURN_INVALIDARG_IF_NULL(o_pDomains);

    FreeNetNameList(o_pDomains);
  
    CComPtr<IDsBrowseDomainTree>  pDsDomTree;
    HRESULT       hr = CoCreateInstance(
                                      CLSID_DsDomainTreeBrowser, 
                                      NULL, 
                                      CLSCTX_INPROC_SERVER,
                                      IID_IDsBrowseDomainTree,
                                      (void **)&pDsDomTree
                                     );    
    RETURN_IF_FAILED(hr);
  
    PDOMAIN_TREE  pDomTree = NULL;
    hr = pDsDomTree->GetDomains(&pDomTree, DBDTF_RETURNEXTERNAL | DBDTF_RETURNINBOUND);
    RETURN_IF_FAILED(hr);

             // Flaten the tree in to a list.
    hr = FlatAdd(&(pDomTree->aDomains[0]), o_pDomains);

    pDsDomTree->FreeDomains(&pDomTree);
  
    return hr;
}

//----------------------------------------------------------------------------------
HRESULT Is50Domain
(
  IN BSTR      i_bstrDomain,
  OUT BSTR*    o_pbstrDnsDomainName    
)
{
  return GetDomainInfo(i_bstrDomain, NULL, o_pbstrDnsDomainName);
}

//----------------------------------------------------------------------------------
HRESULT GetServerInfo
(
  IN  BSTR    i_bstrServer,
  OUT BSTR    *o_pbstrDomain, // = NULL     
  OUT BSTR    *o_pbstrNetbiosName, // = NULL
  OUT BOOL    *o_pbValidDSObject, // = NULL
  OUT BSTR    *o_pbstrDnsName, // = NULL
  OUT BSTR    *o_pbstrGuid, // = NULL
  OUT BSTR    *o_pbstrFQDN, // = NULL
  OUT SUBSCRIBERLIST *o_pFRSRootList, // NULL
  OUT long    *o_lMajorNo, // = NULL
  OUT long    *o_lMinorNo // = NULL
)
{
//  This function uses NetWkstaGetInfo to get the server informaiton.

  if (!o_pbstrDomain && 
      !o_pbstrNetbiosName &&
      !o_pbValidDSObject &&
      !o_pbstrDnsName &&
      !o_pbstrGuid &&
      !o_pbstrFQDN &&
      !o_pFRSRootList &&
      !o_lMajorNo && 
      !o_lMinorNo
     )
    return(E_INVALIDARG);

  if (o_pbstrDomain)      *o_pbstrDomain = NULL;
  if (o_pbstrNetbiosName) *o_pbstrNetbiosName = NULL;
  if (o_pbValidDSObject)  *o_pbValidDSObject = FALSE;
  if (o_pbstrDnsName)     *o_pbstrDnsName = NULL;
  if (o_pbstrGuid)        *o_pbstrGuid = NULL;
  if (o_pbstrFQDN)        *o_pbstrFQDN = NULL;
  if (o_pFRSRootList)     FreeSubscriberList(o_pFRSRootList);
  if (o_lMajorNo)         *o_lMajorNo = 0;
  if (o_lMinorNo)         *o_lMinorNo = 0;

  HRESULT           hr = S_OK;
  PWKSTA_INFO_100   wki100 = NULL;
  NET_API_STATUS    NetStatus = NetWkstaGetInfo(i_bstrServer, 100, (LPBYTE *) &wki100 );
  if (ERROR_SUCCESS != NetStatus) 
    hr = HRESULT_FROM_WIN32(NetStatus);
  else
  {
    if (o_lMajorNo)
      *o_lMajorNo = wki100->wki100_ver_major;

    if (o_lMinorNo)
      *o_lMinorNo = wki100->wki100_ver_minor;

    if (SUCCEEDED(hr) && o_pbstrNetbiosName && wki100->wki100_computername)
    {
      *o_pbstrNetbiosName = SysAllocString(wki100->wki100_computername);
      if (!*o_pbstrNetbiosName) 
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr) &&
        (o_pbstrDomain || o_pbValidDSObject || o_pbstrDnsName || o_pbstrGuid || o_pbstrFQDN || o_pFRSRootList) &&
        wki100->wki100_langroup && 
        wki100->wki100_computername)
    {
      PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuffer = NULL;
      DWORD dwErr = DsRoleGetPrimaryDomainInformation(
                        i_bstrServer,
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE *)&pBuffer);
      if (ERROR_SUCCESS != dwErr)
        hr = HRESULT_FROM_WIN32(dwErr);
      else
      {
        CComBSTR bstrDomain;

        //
        // Verify if this is really a server name.
        // NetWkstaGetInfo and DsRoleGetPrimaryDomainInformation work with domain name,
        // they return info of a DC.
        //
        if (i_bstrServer && *i_bstrServer && 
            (pBuffer->DomainNameFlat && !lstrcmpi(i_bstrServer, pBuffer->DomainNameFlat) || 
             pBuffer->DomainNameDns && !lstrcmpi(i_bstrServer, pBuffer->DomainNameDns)))
        {
            // we're seeing a domain name, not what we expect, return S_FALSE.
            hr = S_FALSE; // server not in a domain or cannot find an appropriate computer obj.
        } else
        {
            bstrDomain = (pBuffer->DomainNameDns ? pBuffer->DomainNameDns : pBuffer->DomainNameFlat);
            if (!bstrDomain)
            {
                hr = E_OUTOFMEMORY;
            } else if (pBuffer->MachineRole == DsRole_RoleStandaloneWorkstation ||
                       pBuffer->MachineRole == DsRole_RoleStandaloneServer ||
                       !*bstrDomain)
            {
                hr = S_FALSE; // server not in a domain or cannot find an appropriate computer obj.
            } else
            {
                //
                // In case the DNS name is in absolute form, remove the ending dot
                //
                int nlen = _tcslen(bstrDomain);
                if ( *(bstrDomain + nlen - 1) == _T('.') )
                  *(bstrDomain + nlen - 1) = _T('\0');
            }
        }

        DsRoleFreeMemory(pBuffer);

        if (S_OK == hr && o_pbstrDomain)
        {
            *o_pbstrDomain = SysAllocString(bstrDomain);
            if (!*o_pbstrDomain) 
                hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr &&
            (o_pbValidDSObject || o_pbstrDnsName || o_pbstrGuid || o_pbstrFQDN || o_pFRSRootList) )
        {
            CComBSTR bstrDC;
            HANDLE   hDS = NULL;
            hr = DsBindToDS(bstrDomain, &bstrDC, &hDS);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrOldName = wki100->wki100_langroup;
                bstrOldName += _T("\\");
                bstrOldName += wki100->wki100_computername;
                bstrOldName += _T("$");

                if (o_pbstrGuid)
                    hr = CrackName(hDS, bstrOldName, DS_NT4_ACCOUNT_NAME, DS_UNIQUE_ID_NAME, o_pbstrGuid);

                if (SUCCEEDED(hr) && (o_pbValidDSObject || o_pbstrDnsName || o_pbstrFQDN || o_pFRSRootList))
                {
                    CComBSTR bstrComputerDN;
                    hr = CrackName(hDS, bstrOldName, DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME, &bstrComputerDN);
                    if (SUCCEEDED(hr) && o_pbstrFQDN)
                    {
                        *o_pbstrFQDN = bstrComputerDN.Copy();
                        if (!*o_pbstrFQDN)
                            hr = E_OUTOFMEMORY;
                    }
                    if (SUCCEEDED(hr) && (o_pbValidDSObject || o_pbstrDnsName || o_pFRSRootList))
                    {
                        PLDAP pldap = NULL;
                        hr = LdapConnectToDC(bstrDC, &pldap);
                        if (SUCCEEDED(hr))
                        {
                            dwErr = ldap_bind_s(pldap, NULL, NULL, LDAP_AUTH_NEGOTIATE);
                            if (LDAP_SUCCESS != dwErr)
                            {
                                DebugOutLDAPError(pldap, dwErr, _T("ldap_bind_s"));
                                hr = HRESULT_FROM_WIN32(dwErr);
                            } else
                            {
                                if (o_pbValidDSObject)
                                {
                                    hr = IsValidObject(pldap, bstrComputerDN);
                                    *o_pbValidDSObject = (S_OK == hr);
                                }

                                if (SUCCEEDED(hr) && o_pbstrDnsName)
                                {
                                    PLDAP_ATTR_VALUE  pValues[2] = {0,0};
                                    LDAP_ATTR_VALUE  pAttributes[1];
                                    pAttributes[0].bstrAttribute = _T("dNSHostName");

                                    hr = GetValues(  
                                            pldap, 
                                            bstrComputerDN,
                                            OBJCLASS_SF_COMPUTER,
                                            LDAP_SCOPE_BASE,
                                            1,          
                                            pAttributes,    
                                            pValues        
                                            );

                                    if (SUCCEEDED(hr))
                                    {
                                        *o_pbstrDnsName = SysAllocString((LPTSTR)(pValues[0]->vpValue));
                                        if (!*o_pbstrDnsName)
                                            hr = E_OUTOFMEMORY;

                                        FreeAttrValList(pValues[0]);

                                    } else
                                    {
                                        hr = S_OK; // ignore failure, since dNSHostName might not be set
                                    }

                                }

                                if (SUCCEEDED(hr) && o_pFRSRootList)
                                {
                                    PCTSTR ppszAttributes[] = {ATTR_FRS_SUBSCRIBER_MEMBERREF, ATTR_FRS_SUBSCRIBER_ROOTPATH, 0};

                                    LListElem* pElem = NULL;
                                    hr = GetValuesEx(pldap,
                                                    bstrComputerDN,
                                                    LDAP_SCOPE_SUBTREE,
                                                    OBJCLASS_SF_NTFRSSUBSCRIBER,
                                                    ppszAttributes,
                                                    &pElem);
                                    if (SUCCEEDED(hr) && pElem)
                                    {
                                        LListElem* pCurElem = pElem;
                                        while (pCurElem)
                                        {
                                            PTSTR** pppszValues = pCurElem->pppszAttrValues;

                                            if (!pppszValues ||
                                                !pppszValues[0] || !*(pppszValues[0]) ||
                                                !pppszValues[1] || !*(pppszValues[1]))
                                            {
                                                pCurElem = pCurElem->Next;
                                                continue; // corrupted subscriber object, ignore it
                                            }

                                            SUBSCRIBER* pCurrent = new SUBSCRIBER;
                                            BREAK_OUTOFMEMORY_IF_NULL(pCurrent, &hr);

                                            pCurrent->bstrMemberDN = *(pppszValues[0]);  // frsMemberReference
                                            pCurrent->bstrRootPath = *(pppszValues[1]);  // frsRootPath
                                            if (!(pCurrent->bstrMemberDN) || !(pCurrent->bstrRootPath))
                                            {
                                                delete pCurrent;
                                                hr = E_OUTOFMEMORY;
                                                break;
                                            }

                                            o_pFRSRootList->push_back(pCurrent);

                                            pCurElem = pCurElem->Next;
                                        }

                                        FreeLListElem(pElem);

                                        if (FAILED(hr))
                                            FreeSubscriberList(o_pFRSRootList);
                                    }
                                }
                            }

                            ldap_unbind(pldap);
                        }
                    }
                }
                DsUnBind(&hDS);
            }
        }
      } // DsRoleGetPrimaryDomainInformation
    }

    NetApiBufferFree((LPBYTE)wki100);
  }  //NetWkstaGetInfo 

  return hr;
}


//----------------------------------------------------------------------------------

HRESULT  IsServerRunningDfs
(
  IN BSTR      i_bstrServer
)
/*++

Routine Description:

  Contacts the machine and determines if service Dfs is running.

Arguments:

  i_bstrServer -   The server name.

--*/
{
    SC_HANDLE       SCMHandle = NULL;
    SC_HANDLE       DFSHandle = NULL;
    SERVICE_STATUS  SStatus;
    HRESULT         hr = S_FALSE;

    if ((SCMHandle = OpenSCManager(i_bstrServer, NULL, GENERIC_READ)) &&
        (DFSHandle = OpenService(SCMHandle, _T("Dfs"), SERVICE_QUERY_STATUS)) &&
        QueryServiceStatus(DFSHandle, &SStatus) &&
        (SERVICE_RUNNING == SStatus.dwCurrentState) )
    {
        hr = S_OK;
    }  

    if (DFSHandle)
        CloseServiceHandle(DFSHandle);
    if (SCMHandle)
        CloseServiceHandle(SCMHandle);

    return hr;
}

//
// TRUE: support NTFS 5 reparse point
// FALSE: doesn't support
//
BOOL CheckReparsePoint(IN BSTR i_bstrServer, IN BSTR i_bstrShare)
{
    if (!i_bstrServer || !*i_bstrServer || !i_bstrShare || !*i_bstrShare)
        return FALSE;

    //
    // bug#720184
    // To work around GetVolumeInfo(\\server\share) adding the share to the SMB cache just before root
    // is created, we can replace it with NetShareGetInfo(server, share) and GetVolumeInfo(\\server\c$).
    // DFS will be able to hand out referral if \\server\share is not in the SMB cache.
    //
    // For cases that $ share may not exist or we might have mounted volumes, I'm returning TRUE to let
    // DFS API catch the error later. That is, if we failed to get share info or folder path is not in
    // C: format, we'll ignore and continue and let DFS API to handle it later. 
    //
    SHARE_INFO_2   *pShareInfo = NULL;
    NET_API_STATUS nstatRetVal = NetShareGetInfo(i_bstrServer, i_bstrShare, 2, (LPBYTE *)&pShareInfo);

    if (nstatRetVal != NERR_Success)
        return TRUE;

    if (!pShareInfo->shi2_path || lstrlen(pShareInfo->shi2_path) < 2 || *(pShareInfo->shi2_path + 1) != _T(':'))
    {
        NetApiBufferFree(pShareInfo);
        return TRUE;
    }

    TCHAR  szDriveShare[] = _T("\\C$\\");
    szDriveShare[1] = *(pShareInfo->shi2_path);

    NetApiBufferFree(pShareInfo);

    TCHAR  szFileSystemName[MAX_PATH + 1] = {0};
    DWORD  dwMaxCompLength = 0, dwFileSystemFlags = 0;

    CComBSTR bstrRootPath = _T("\\\\");
    bstrRootPath += i_bstrServer;
    bstrRootPath += szDriveShare;

    BOOL bRet = GetVolumeInformation(bstrRootPath, NULL, 0, NULL, &dwMaxCompLength,
                         &dwFileSystemFlags, szFileSystemName, MAX_PATH);

    // If we failed to get volume info, we'll ignore and continue and let DFS API to handle it later
    return (!bRet || bRet && CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, _T("NTFS"), -1, szFileSystemName, -1) && 
            (dwFileSystemFlags & FILE_SUPPORTS_REPARSE_POINTS));
}

//----------------------------------------------------------------------------------
//
// S_OK: o_pbFound is valid
// S_FALSE: share is not eligible to host dfs root
// hr: other errors
//
HRESULT  CheckShare 
(
  IN  BSTR          i_bstrServer,
  IN  BSTR          i_bstrShare,
  OUT BOOL*         o_pbFound
)
{
    if (!i_bstrServer || !*i_bstrServer || !i_bstrShare || !*i_bstrShare || !o_pbFound)
        return E_INVALIDARG;

    *o_pbFound = FALSE;

    if (CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, i_bstrShare, -1, _T("SYSVOL"), -1) ||
        CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, i_bstrShare, -1, _T("NETLOGON"), -1) ||
        _istspace(i_bstrShare[0]) ||                        // exclude share with leading space
        _istspace(i_bstrShare[lstrlen(i_bstrShare) - 1])    // exclude share with trailing space
        )
        return S_FALSE;

    LPSHARE_INFO_1  lpBuffer = NULL;
    DWORD           dwNumEntries = 0;
    DWORD           dwTotalEntries = 0;
    DWORD           dwResumehandle = NULL;
    NET_API_STATUS  nstatRetVal = NetShareEnum(
                                                i_bstrServer,
                                                1L,          
                                                (LPBYTE*) &lpBuffer,
                                                0xFFFFFFFF,
                                                &dwNumEntries,
                                                &dwTotalEntries,
                                                &dwResumehandle 
                                              );
    if (NERR_Success != nstatRetVal)
    {
        if (ERROR_NO_MORE_ITEMS == nstatRetVal)
            return S_OK;
        else
            return HRESULT_FROM_WIN32(nstatRetVal);
    }

    HRESULT hr = S_OK;
    for (DWORD i = 0; i < dwNumEntries; i++)
    {
        if (!lstrcmpi(lpBuffer[i].shi1_netname, i_bstrShare))
        {
            if (lpBuffer[i].shi1_type != STYPE_DISKTREE)
                hr = S_FALSE;
            else
                *o_pbFound = TRUE;
            break;
        }
    }

    NetApiBufferFree ((LPVOID) lpBuffer);

    return hr;
}

HRESULT
BuildSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR  *ppSelfRelativeSD // return a security descriptor in self-relative form
)
{
    if (*ppSelfRelativeSD)
    {
        LocalFree((HLOCAL)*ppSelfRelativeSD);
        *ppSelfRelativeSD = NULL;
    }

    HRESULT                 hr = S_OK;
    PSID                    pSid = NULL;
    PSECURITY_DESCRIPTOR    pAbsoluteSD = NULL;
    PACL                    pACL = NULL;
  
    do { // false loop

        // get PSID of account "everyone"
        SID_IDENTIFIER_AUTHORITY  SidIdentifierWORLDAuthority = SECURITY_WORLD_SID_AUTHORITY;
        DWORD dwRID[8];
        ZeroMemory(dwRID, sizeof(dwRID));
        dwRID[0] = SECURITY_WORLD_RID;

        if ( !AllocateAndInitializeSid(&SidIdentifierWORLDAuthority, 1, 
                                        dwRID[0], dwRID[1], dwRID[2], dwRID[3], 
                                        dwRID[4], dwRID[5], dwRID[6], dwRID[7], &pSid) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // Initialize a new ACL
        DWORD cbACL = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid(pSid) - sizeof(DWORD);

        if ( !(pACL = (PACL)LocalAlloc(LPTR, cbACL)) ||
            !InitializeAcl(pACL, cbACL, ACL_REVISION))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // Add Ace
        if ( !::AddAccessAllowedAce(pACL, ACL_REVISION, (FILE_GENERIC_READ | FILE_EXECUTE), pSid) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // Note: this is a new object, set Dacl only.
        // Initialize a new security descriptor in absolute form and add the new ACL to it
        if ( !(pAbsoluteSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH)) ||
            !InitializeSecurityDescriptor(pAbsoluteSD, SECURITY_DESCRIPTOR_REVISION) ||
            !SetSecurityDescriptorDacl(pAbsoluteSD, TRUE, pACL, FALSE) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        // transform into a self-relative form
        DWORD dwSDSize = 0;
        MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwSDSize);
        if ( !(*ppSelfRelativeSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, dwSDSize)) ||
            !MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwSDSize) )
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
    } while (0);

    if (FAILED(hr))
    {
        if (*ppSelfRelativeSD)
        {
            LocalFree((HLOCAL)*ppSelfRelativeSD);
            *ppSelfRelativeSD = NULL;
        }
    }

    if (pACL)
        LocalFree((HLOCAL)pACL);
    if (pAbsoluteSD)
        LocalFree((HLOCAL)pAbsoluteSD);

    if (pSid)
        FreeSid(pSid);

    return hr;
}

HRESULT  CreateShare
(
  IN BSTR      i_bstrServerName,
  IN BSTR      i_bstrShareName, 
  IN BSTR      i_bstrComment,
  IN BSTR      i_bstrPath
)
/*++

Routine Description:

  This function creates an share of the specified name on the specified computer.

Arguments:

  i_bstrServerName  -  The machine on which the new share is to be created.
  i_bstrShareName    -  The name of the new share to be created.
  i_bstrComment    -  Comment to be given for the share.
  i_bstrPath      -  The physical path of the share.
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
    RETURN_INVALIDARG_IF_NULL(i_bstrShareName);
    RETURN_INVALIDARG_IF_NULL(i_bstrComment);
    RETURN_INVALIDARG_IF_NULL(i_bstrPath);

    PSECURITY_DESCRIPTOR pSD = NULL;
    HRESULT hr = BuildSecurityDescriptor(&pSD);
    if (FAILED(hr))
        return hr;

    SHARE_INFO_502 sInfo;

    ZeroMemory(&sInfo, sizeof(sInfo));
    sInfo.shi502_netname = i_bstrShareName;
    sInfo.shi502_type = STYPE_DISKTREE;
    sInfo.shi502_remark = i_bstrComment;
    sInfo.shi502_max_uses = (DWORD)-1;
    sInfo.shi502_path = i_bstrPath;
    sInfo.shi502_security_descriptor = pSD;

    DWORD dwError = 0;
    NET_API_STATUS nRet = NetShareAdd(i_bstrServerName, 502, (LPBYTE)&sInfo, &dwError);

    LocalFree((HLOCAL)pSD);

    return HRESULT_FROM_WIN32(nRet);
}

//----------------------------------------------------------------------------------
// Checks if \\<server>\<share>\x\y\z is on a valid disktree share
// and return the path local to the server
HRESULT GetFolderInfo
(
  IN  BSTR      i_bstrServerName,   // <server>
  IN  BSTR      i_bstrFolder,       // <share>\x\y\z
  OUT BSTR      *o_bstrPath         // return <share path>\x\y\z 
)
{
  if (!i_bstrServerName || !*i_bstrServerName || !i_bstrFolder || !*i_bstrFolder)
  {
    return(E_INVALIDARG);
  }

  //
  // first, test if folder \\<server>\<share>\x\y\z can be reached
  //
  CComBSTR bstrUNC;
  if (0 != mylstrncmp(i_bstrServerName, _T("\\\\"), 2))
  {
      bstrUNC = _T("\\\\");
      RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);
  }

  bstrUNC += i_bstrServerName;
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);
  bstrUNC += _T("\\");
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);
  bstrUNC += i_bstrFolder;
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrUNC);

  if (-1 == GetFileAttributes(bstrUNC))
      return HRESULT_FROM_WIN32(GetLastError());

  CComBSTR bstrShareName;
  CComBSTR bstrRestOfPath;
  TCHAR *p = _tcschr(i_bstrFolder, _T('\\'));
  if (p && *(p+1))
  {
    bstrRestOfPath = p+1;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrRestOfPath);

    bstrShareName = CComBSTR(p - i_bstrFolder, i_bstrFolder);
  } else
  {
    bstrShareName = i_bstrFolder;
  }
    
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrShareName);

  HRESULT        hr = S_OK;
  SHARE_INFO_2   *pShareInfo = NULL;
  NET_API_STATUS nstatRetVal = NetShareGetInfo (i_bstrServerName, bstrShareName, 2, (LPBYTE *)&pShareInfo);

  if (nstatRetVal != NERR_Success)
  {
    hr = HRESULT_FROM_WIN32(nstatRetVal);
  }
  else
  {
    if (STYPE_DISKTREE != pShareInfo->shi2_type &&
        STYPE_SPECIAL != pShareInfo->shi2_type) // we allow ADMIN$, C$ to be configured in Dfs/Frs
      hr = STG_E_NOTFILEBASEDSTORAGE;

    while (NULL != o_bstrPath)
    {
      CComBSTR bstrPath = pShareInfo->shi2_path;
      BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPath, &hr);

      if (!!bstrRestOfPath)
      {
        if ( _T('\\') != *(bstrPath + _tcslen(bstrPath) - 1) )
        {
          bstrPath += _T("\\");
          BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPath, &hr);
        }
        bstrPath += bstrRestOfPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrPath, &hr);
      }
      *o_bstrPath = bstrPath.Detach();
      break;
    }

    NetApiBufferFree(pShareInfo);
  }

  return(hr);
}

void FreeNetNameList(NETNAMELIST *pList)
{
  if (pList && !pList->empty()) {
    for (NETNAMELIST::iterator i = pList->begin(); i != pList->end(); i++)
        delete (*i);
    pList->clear();
  }
}

void FreeRootInfoList(ROOTINFOLIST *pList)
{
  if (pList && !pList->empty()) {
    for (ROOTINFOLIST::iterator i = pList->begin(); i != pList->end(); i++)
        delete (*i);
    pList->clear();
  }
}

void FreeSubscriberList(SUBSCRIBERLIST *pList)
{
  if (pList && !pList->empty()) {
    for (SUBSCRIBERLIST::iterator i = pList->begin(); i != pList->end(); i++)
        delete (*i);
    pList->clear();
  }
}

HRESULT GetLocalComputerName(OUT BSTR* o_pbstrComputerName)
{
  _ASSERT(o_pbstrComputerName);

  DWORD   dwErr = 0;
  TCHAR   szBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
  DWORD   dwSize = DNS_MAX_NAME_BUFFER_LENGTH;

  if ( !GetComputerNameEx(ComputerNameDnsFullyQualified, szBuffer, &dwSize) )
  {
    dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
    if ( !GetComputerNameEx(ComputerNameNetBIOS, szBuffer, &dwSize) )
      dwErr = GetLastError();
  }

  if (0 == dwErr)
  {
    *o_pbstrComputerName = SysAllocString(szBuffer);
    if (!*o_pbstrComputerName)
      dwErr = ERROR_OUTOFMEMORY;
  }

  return HRESULT_FROM_WIN32(dwErr);
}

HRESULT
GetDomainDfsRoots(
    OUT NETNAMELIST*  o_pDfsRootList,
    IN  LPCTSTR       i_lpszDomainName
)
{
  HRESULT hr = S_OK;

  FreeNetNameList(o_pDfsRootList);

  do {
    DFS_INFO_200 *pBuffer = NULL;
    DWORD   dwEntriesRead = 0;
    DWORD   dwResumeHandle = 0;
    DWORD   dwErr = NetDfsEnum(
                        const_cast<LPTSTR>(i_lpszDomainName),
                        200,            // Level,
                        (DWORD)-1,             // PrefMaxLen,
                        (LPBYTE *)&pBuffer,
                        &dwEntriesRead,
                        &dwResumeHandle
                    );

    dfsDebugOut((_T("NetDfsEnum domain=%s, level 200 for GetDomainDfsRoots, nRet=%d\n"),
        i_lpszDomainName, dwErr));

    if (NERR_Success != dwErr)
    {
        hr = (ERROR_NO_MORE_ITEMS == dwErr || ERROR_NOT_FOUND == dwErr) ? S_FALSE : HRESULT_FROM_WIN32(dwErr);
        break;
    } else if (0 == dwEntriesRead)
    {
        if (pBuffer)
            NetApiBufferFree(pBuffer);

        hr = S_FALSE;
        break;
    }

    NETNAME *pCurrent = NULL;
    for (DWORD i = 0; i < dwEntriesRead; i++)
    {
      pCurrent = new NETNAME;
      if (!pCurrent)
      {
        hr = E_OUTOFMEMORY;
        break;
      }

      pCurrent->bstrNetName = pBuffer[i].FtDfsName;
      if (!pCurrent->bstrNetName)
      {
        delete pCurrent;
        hr = E_OUTOFMEMORY;
        break;
      }

      o_pDfsRootList->push_back(pCurrent);
    }

    NetApiBufferFree(pBuffer);

  } while (0);

  if (FAILED(hr))
    FreeNetNameList(o_pDfsRootList);

  return hr;
}

HRESULT
GetMultiDfsRoots(
    OUT ROOTINFOLIST* o_pDfsRootList,
    IN  LPCTSTR       i_lpszScope
)
{
    if (!i_lpszScope || !*i_lpszScope)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    FreeRootInfoList(o_pDfsRootList);

    do {
        DFS_INFO_300 *pBuffer = NULL;
        DWORD   dwEntriesRead = 0;
        DWORD   dwResumeHandle = 0;
        DWORD   dwErr = NetDfsEnum(
                                const_cast<LPTSTR>(i_lpszScope),
                                300,            // Level,
                                (DWORD)-1,             // PrefMaxLen,
                                (LPBYTE *)&pBuffer,
                                &dwEntriesRead,
                                &dwResumeHandle
                                );

        dfsDebugOut((_T("NetDfsEnum scope=%s, level 300 for GetMultiDfsRoots, nRet=%d\n"),
            i_lpszScope, dwErr));

        if (NERR_Success != dwErr)
        {
            hr = (ERROR_NO_MORE_ITEMS == dwErr || ERROR_NOT_FOUND == dwErr) ? S_FALSE : HRESULT_FROM_WIN32(dwErr);
            break;
        } else if (0 == dwEntriesRead)
        {
            if (pBuffer)
                NetApiBufferFree(pBuffer);

            hr = S_FALSE;
            break;
        }

        ROOTINFO *pCurrent = NULL;
        for (DWORD i = 0; i < dwEntriesRead; i++)
        {
            pCurrent = new ROOTINFO;
            if (pCurrent)
            {
                if ((pBuffer[i].Flags & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_AD_BLOB)
                    pCurrent->enumRootType = DFS_TYPE_FTDFS;
                else
                    pCurrent->enumRootType = DFS_TYPE_STANDALONE;

                pCurrent->bstrRootName = _T("\\");
                pCurrent->bstrRootName += pBuffer[i].DfsName;
            }

            if (!pCurrent)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (!pCurrent->bstrRootName)
            {
                delete pCurrent;
                hr = E_OUTOFMEMORY;
                break;
            }

            o_pDfsRootList->push_back(pCurrent);
        }

        NetApiBufferFree(pBuffer);

    } while (0);

    if (FAILED(hr))
        FreeRootInfoList(o_pDfsRootList);

    return hr;
}

/*
bool 
IsDfsPath
(
     LPTSTR                i_lpszNetPath
)
{
    if ( S_OK != CheckUNCPath(i_lpszNetPath) )
        return false;

    CComBSTR bstrPath = i_lpszNetPath;
    if (!bstrPath)
        return false; // out of memory

    TCHAR   *s = _tcschr(bstrPath + 2, _T('\\'));   // points to the 3rd backslash
    TCHAR   *p = bstrPath + bstrPath.Length();      // points to the ending char '\0'
    bool    bIsDfsPath = false;

    do
    {
        *p = _T('\0');

        PDFS_INFO_1 pDfsInfo1 = NULL;
        DWORD       dwStatus = NetDfsGetClientInfo (
                                    bstrPath,            // dir path as entrypath
                                    NULL,                    // No server name required
                                    NULL,                    // No share required
                                    1,                        // level 1
                                    (LPBYTE *)&pDfsInfo1    // out buffer.
                                 );

        if (NERR_Success == dwStatus)
        {
            bIsDfsPath = true;
            NetApiBufferFree(pDfsInfo1);
            break;
        }

        p--;

        while (_T('\\') != *p && p > s)
        {
            p--;
        }
    } while (p > s);

    return bIsDfsPath;
}
*/

HRESULT CheckUNCPath(
  IN LPCTSTR i_lpszPath
  )
/*++

Routine Description:

  Checks if path is of UNC format.
--*/  
{
  //"someserver\someshare\somedir\.."    - Invalid
  //"\\Server                - Invalid
  //"\\someserver\someshare\..      - Valid
  //"\\someserver\someshare\Somedir\..  - Valid
  
  RETURN_INVALIDARG_IF_NULL(i_lpszPath);
    
  DWORD             dwRetFlags = 0;
  NET_API_STATUS    nStatus = I_NetPathType(NULL, (LPTSTR)i_lpszPath, &dwRetFlags, 0);
  if (NERR_Success != nStatus)
    return HRESULT_FROM_WIN32(nStatus);

  return (ITYPE_UNC == dwRetFlags) ? S_OK : S_FALSE;
}

HRESULT GetUNCPathComponent(
    IN  LPCTSTR i_lpszPath,
    OUT BSTR*   o_pbstrComponent,
    IN  UINT    i_nStartBackslashes,  // index starting from 1
    IN  UINT    i_nEndBackslashes     // index starting from 1
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrComponent);
    RETURN_INVALIDARG_IF_TRUE(i_nStartBackslashes < 2);
    RETURN_INVALIDARG_IF_TRUE(0 != i_nEndBackslashes && i_nEndBackslashes <= i_nStartBackslashes);

    *o_pbstrComponent = NULL;
/* bug#587178
    HRESULT hr = CheckUNCPath(i_lpszPath);
    RETURN_INVALIDARG_IF_TRUE(S_OK != hr);
*/
    HRESULT hr = S_OK;
    UINT nDeltaBackslashes = i_nEndBackslashes ? (i_nEndBackslashes - i_nStartBackslashes) : 0;
    
    TCHAR *p = (LPTSTR)i_lpszPath + 2;    // skip the first 2 backslashes
    i_nStartBackslashes -= 2;

    // locate the starting backslash
    while (*p && i_nStartBackslashes)
    {
        if (_T('\\') == *p)
            i_nStartBackslashes--;

        p++;
    }
    if (!*p)
        return hr;

    // locate the ending backslash
    TCHAR *s = p;
    if (!nDeltaBackslashes)
    {
        s += _tcslen(p);
    } else
    {
        while (*s && nDeltaBackslashes)
        {
            if (_T('\\') == *s)
                nDeltaBackslashes--;

            s++;
        }
        if (*s)
            s--;
    }

    // p points at the first char after the starting backslash, and
    // s points at the ending backslash or the ending char '\0'

    *o_pbstrComponent = SysAllocStringLen(p, s - p);    
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrComponent);

    return S_OK;
}

// return TRUE if string matches the filter string, case-insensitive match
BOOL FilterMatch(LPCTSTR lpszString, FILTERDFSLINKS_TYPE lLinkFilterType, LPCTSTR lpszFilter)
{
    BOOL bResult = TRUE;

    switch (lLinkFilterType)
    {
    case FILTERDFSLINKS_TYPE_BEGINWITH:
        if (!lpszString || !lpszFilter)
            return FALSE;
        bResult = !mylstrncmpi(lpszString, lpszFilter, lstrlen(lpszFilter));
        break;
    case FILTERDFSLINKS_TYPE_CONTAIN:
        {
            if (!lpszString || !lpszFilter)
                return FALSE;
            TCHAR* pszStringLower = _tcsdup(lpszString);
            TCHAR* pszFilterLower = _tcsdup(lpszFilter);
            if (!pszStringLower || !pszFilterLower)
                bResult = FALSE;
            else
                bResult = (NULL != _tcsstr(_tcslwr(pszStringLower), _tcslwr(pszFilterLower)));

            if (pszStringLower)
                free(pszStringLower);
            if (pszFilterLower)
                free(pszFilterLower);
        }
        break;
    default:
        break;
    }
    
    return bResult;
}

HRESULT IsHostingDfsRoot(IN BSTR i_bstrServer, OUT BSTR* o_pbstrRootEntryPath)
{
    if (o_pbstrRootEntryPath)
        *o_pbstrRootEntryPath = NULL;

    DWORD        dwEntriesRead = 0;
    DWORD        dwResumeHandle = 0;
    DFS_INFO_1*  pDfsInfoLevel1 = NULL;

    NET_API_STATUS dwRet = NetDfsEnum(
                                    i_bstrServer,
                                    1,
                                    sizeof(DFS_INFO_1), // get 1 entry
                                    (LPBYTE *)&pDfsInfoLevel1,
                                    &dwEntriesRead,
                                    &dwResumeHandle
                                    );

    dfsDebugOut((_T("NetDfsEnum server=%s, level 1 for IsHostingDfsRoot, nRet=%d\n"),
        i_bstrServer,dwRet));

    if (NERR_Success != dwRet)
    {
        return (ERROR_NO_MORE_ITEMS == dwRet || ERROR_NOT_FOUND == dwRet) ? S_FALSE : HRESULT_FROM_WIN32(dwRet);
    } else if (0 == dwEntriesRead)
    {
        if (pDfsInfoLevel1)
            NetApiBufferFree(pDfsInfoLevel1);
        return S_FALSE;
    }

    HRESULT hr = S_OK;
    if (o_pbstrRootEntryPath)
    {
        *o_pbstrRootEntryPath = SysAllocString(pDfsInfoLevel1->EntryPath);
        if (!*o_pbstrRootEntryPath)
            hr = E_OUTOFMEMORY;
    }

    NetApiBufferFree(pDfsInfoLevel1);

    return hr;
}

/*
void GetTimeDelta(LPCTSTR str, SYSTEMTIME* ptime0, SYSTEMTIME* ptime1)
{
    dfsDebugOut((_T("%s, delta = %d millisec \n"), str,
        ((ptime1->wMinute - ptime0->wMinute) * 60 +
         (ptime1->wSecond - ptime0->wSecond)) * 1000 +
        (ptime1->wMilliseconds - ptime0->wMilliseconds)
        ));
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <oleauto.h>
#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\netutils.h ===
/*++
Module Name:

NetUtils.h

Abstract:
  This is the header file for the utility functions for Network APIs.

*/


#ifndef _NETUTILS_H
#define _NETUTILS_H

#include "stdafx.h"
#include <wtypes.h>      // For define types like DWORD, HANDLE etc.
#include <oleauto.h>    // For SysAllocString().
#include <lmerr.h>      // For Lan Manager API error codes and return value types.
#include <lmcons.h>      // For Lan Manager API constants.
#include <lmserver.h>    // For Server specific Lan Manager APIs.  
#include <lmaccess.h>    // For NetGetDCInfo.
#include <lmapibuf.h>    // For NetApiBufferFree.
#include <shlobj.h>
#include <dsclient.h>
#include <lmwksta.h>
#include <lmshare.h>
#include <icanon.h>      // I_Net
#include "dfsenums.h"

#include <list>
using namespace std;

class NETNAME                // Structure to store and send a list of names
{
public:
  CComBSTR    bstrNetName;      // To store Name of Domain, Server, Share etc.
};

typedef list<NETNAME*>      NETNAMELIST;

class ROOTINFO
{
public:
    CComBSTR      bstrRootName;
    enum DFS_TYPE enumRootType;
};

typedef list<ROOTINFO*>      ROOTINFOLIST;

class SUBSCRIBER 
{
public:
  CComBSTR    bstrMemberDN; 
  CComBSTR    bstrRootPath;
};

typedef list<SUBSCRIBER*>      SUBSCRIBERLIST;

/*----------------------------------------------------------------------
          H E L P E R   F U N C T I O N S 
------------------------------------------------------------------------*/

            //  Recursive function to flatten the domain tree returned by GetDomains() method
            //  of IBrowserDomainTree into a NETNAME list.
            //  This is done by using a depth first algorithm.
            //  Used in Get50Domains().

HRESULT FlatAdd
(
  IN DOMAIN_DESC*    i_pDomDesc,        // Pointer to the Domain Description Structure returned by IBrowserDomainTree::GetDomains()
  OUT NETNAMELIST*  o_pDomainList      // Pointer to the list of NETNAME is returned here.
);

/*----------------------------------------------------------------------
      D O M A I N    R E L A T E D   F U N C T I O N S 
------------------------------------------------------------------------*/

            // Returns the list of all 5.0 domains  present in the DS Domain Tree only.
            // The domain names will be in DNS forms
HRESULT Get50Domains
(
  OUT NETNAMELIST*  o_pDomains        // List of NETNAME structures.
);

            // Contacts the domain and determines if it is 5.0 Domain.
            // The domain name can be in DNS form.
            // returns the netbios name if second parameter is not null.
HRESULT Is50Domain
(
  IN BSTR      i_bstrDomain,
  OUT BSTR*    o_bstrDnsDomainName = NULL    
);

/*----------------------------------------------------------------------
      S E R V E R   R E L A T E D   F U N C T I O N S 
------------------------------------------------------------------------*/

            // Gets the domain, and OS version of a machine.
            // If the last parameter in not null the the current
            // machine name is returned in it.
HRESULT GetServerInfo
(
  IN  BSTR    i_bstrServer,      // NULL means use current server.
  OUT BSTR    *o_pbstrDomain = NULL,      
  OUT BSTR    *o_pbstrNetbiosName = NULL,
  OUT BOOL    *o_pbValidDSObject = NULL,
  OUT BSTR    *o_pbstrDnsName = NULL,
  OUT BSTR    *o_pbstrGuid = NULL,
  OUT BSTR    *o_pbstrFQDN = NULL,
  OUT SUBSCRIBERLIST *o_pFRSRootList = NULL,
  OUT long    *o_lMajorNo = NULL,
  OUT long    *o_lMinorNo = NULL
);

HRESULT  IsServerRunningDfs
(
  IN BSTR      i_bstrServer
);

BOOL CheckReparsePoint(IN BSTR i_bstrServer, IN BSTR i_bstrShare);

HRESULT  CheckShare 
(
  IN  BSTR      i_bstrServer,
  IN  BSTR      i_bstrShare,
  OUT BOOL*     o_pbFound
);

HRESULT  CreateShare
(
  IN BSTR      i_bstrServerName,
  IN BSTR      i_bstrShareName, 
  IN BSTR      i_bstrComment,
  IN BSTR      i_bstrPath
);

// Checks if \\<server>\<share>\x\y\z is on a valid disktree share
// and return the path local to the server
HRESULT GetFolderInfo
(
  IN  BSTR      i_bstrServerName,   // <server>
  IN  BSTR      i_bstrFolder,       // <share>\x\y\z
  OUT BSTR      *o_bstrPath = NULL // return <share path>\x\y\z 
);

void FreeNetNameList(NETNAMELIST *pList);
void FreeRootInfoList(ROOTINFOLIST *pList);
void FreeSubscriberList(SUBSCRIBERLIST *pList);

HRESULT GetLocalComputerName(OUT BSTR* o_pbstrComputerName);

HRESULT
GetDomainDfsRoots(
    OUT NETNAMELIST*  o_pDfsRootList,
    IN  LPCTSTR       i_lpszDomainName
);

HRESULT
GetMultiDfsRoots(
    OUT ROOTINFOLIST* o_pDfsRootList,
    IN  LPCTSTR       i_lpszScope
);

/*
bool 
IsDfsPath
(
 	LPTSTR				i_lpszNetPath
);
*/

HRESULT CheckUNCPath(
  IN LPCTSTR i_lpszPath
);

HRESULT GetUNCPathComponent(
    IN  LPCTSTR i_lpszPath,
    OUT BSTR*   o_pbstrComponent,
    IN  UINT    i_nStartBackslashes,  // index starting from 1
    IN  UINT    i_nEndBackslashes     // index starting from 1
);

BOOL FilterMatch(LPCTSTR lpszString, FILTERDFSLINKS_TYPE lLinkFilterType, LPCTSTR lpszFilter);

HRESULT IsHostingDfsRoot(IN BSTR i_bstrServer, OUT BSTR* o_pbstrRootEntryPath = NULL);

/*
void GetTimeDelta(LPCTSTR str, SYSTEMTIME* ptime0, SYSTEMTIME* ptime1);
*/
#endif  //#ifndef _NETUTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\common\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_)
#define AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include "dfsDebug.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfscore.cpp ===
// DfsCore.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//        To build a separate proxy/stub DLL, 
//        run nmake -f DfsCoreps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DfsCore.h"

#include "DfsCore_i.c"
#include "DfsRoot.h"
#include "DfsRep.h"
#include "DfsJP.h"
#include "RepSet.h"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DfsRoot, CDfsRoot)
    OBJECT_ENTRY(CLSID_DfsReplica, CDfsReplica)
    OBJECT_ENTRY(CLSID_DfsJunctionPoint, CDfsJunctionPoint)
    OBJECT_ENTRY(CLSID_ReplicaSet, CReplicaSet)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfsrep.h ===
/*++
Module Name:
    DfsRep.h

Abstract:
    This file contains the declaration of the CDfsReplica COM Class. This class
    provides methods to get information of a Dfs replica.
--*/


#ifndef __DFSREP_H_
#define __DFSREP_H_

#include "resource.h"       // main symbols
#include "dfsenums.h"

class ATL_NO_VTABLE CDfsReplica : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsReplica, &CLSID_DfsReplica>,
    public IDispatchImpl<IDfsReplica, &IID_IDfsReplica, &LIBID_DFSCORELib>
{

public:                                                                
    CDfsReplica();
    ~CDfsReplica();

DECLARE_REGISTRY_RESOURCEID(IDR_DFSREP)

BEGIN_COM_MAP(CDfsReplica)
    COM_INTERFACE_ENTRY(IDfsReplica)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


// IDfsReplica
                                                        // Gets the entry path of junction point 
    STDMETHOD(get_EntryPath)                            // for which the replica is providing storage.
    (
        /*[out, retval]*/ BSTR *pVal
    );

                                                        // Initialize DfsReplica object. Should 
    STDMETHOD(Initialize)                                // be called after CoCreateInstance
    (
        /*[in]*/ BSTR i_szEntryPath,                    // Entry path of junction point.
        /*[in]*/ BSTR i_szStorageServerName,            // server hosting share.
        /*[in]*/ BSTR i_szStorageShareName,                // share name for replica.
        /*[in]*/ long i_lDfsStorageState
    );
    
                                                        // Get the storage share name.
    STDMETHOD(get_StorageShareName)
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
                                                        // Get the storage share name.
    STDMETHOD(get_StorageServerName)
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
                                                        // Get the dfs replica state.
    STDMETHOD( get_State )
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD( put_State )                                // Set the state of the Dfs Replica.
    (
        /*[in]*/ long        newVal
    );

    STDMETHOD( FindTarget )                             // verify this target's existence
    (
    );

// Member variables.
protected:

    void        _FreeMemberVariables();
    CComBSTR    m_bstrStorageShareName;
    CComBSTR    m_bstrStorageServerName;
    CComBSTR    m_bstrEntryPath;
    long        m_lDfsReferralState;
};

#endif //__DFSREP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfsjp.cpp ===
/*++
Module Name:

    DfsJP.cpp

Abstract:

  This COM Class provides method to get information of Dfs 
  Junction Points and to enumerate replica of a junction point.
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "DfsJP.h"
#include "DfsRep.h"
#include "JPEnum.h"
#include "RepEnum.h"
#include "netutils.h"
#include "ldaputils.h"
#include <dsgetdc.h>

/////////////////////////////////////////////////////////////////////////////////////////////////
// CDfsJuntionPoint

/////////////////////////////////////////////////////////////////////////////////////////////////


CDfsJunctionPoint :: CDfsJunctionPoint ()
{
  dfsDebugOut((_T("CDfsJunctionPoint::CDfsJunctionPoint this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////


CDfsJunctionPoint :: ~CDfsJunctionPoint ()
{  
  _FreeMemberVariables();
  dfsDebugOut((_T("CDfsJunctionPoint::~CDfsJunctionPoint this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_State
(
  long*        pVal
)
{
    return E_NOTIMPL;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_EntryPath
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  *pVal = m_bstrEntryPath.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_JunctionName
(
  BOOL           i_bDfsNameIncluded,
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  if (i_bDfsNameIncluded)
    *pVal = m_bstrJunctionNameEx.Copy ();
  else
    *pVal = m_bstrJunctionName.Copy ();

  if (!*pVal)
    return E_OUTOFMEMORY;
  
  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_Comment
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  DFS_INFO_100*  pInfoBuffer = NULL;
  NET_API_STATUS nRet = NetDfsGetInfo(
                            m_bstrEntryPath,
                            NULL,
                            NULL,
                            100,
                            (LPBYTE*)&pInfoBuffer
                        );

  dfsDebugOut((_T("NetDfsGetInfo entry=%s, level 100 for comment, nRet=%d\n"),
      m_bstrEntryPath, nRet));

  if (NERR_Success == nRet)
  {
      *pVal = SysAllocString(pInfoBuffer->Comment);

      NetApiBufferFree(pInfoBuffer);

      if (!*pVal)
        return E_OUTOFMEMORY;
  }

  return HRESULT_FROM_WIN32(nRet);
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: put_Comment
(
  BSTR          newVal
)
{
  DFS_INFO_100   InfoBuffer = {(newVal ? newVal : _T(""))};
  NET_API_STATUS nRet = NetDfsSetInfo  (
                            m_bstrEntryPath,
                            NULL,
                            NULL,
                            100,
                            (LPBYTE) &InfoBuffer
                        );

  dfsDebugOut((_T("NetDfsSetInfo entry=%s, level 100 for comment, nRet=%d\n"),
      m_bstrEntryPath, nRet));

  return HRESULT_FROM_WIN32(nRet);
}


/////////////////////////////////////////////////////////////////////////////
// get_Timeout


STDMETHODIMP CDfsJunctionPoint :: get_Timeout
(
  long*          pVal
)
{
  if (!pVal || !m_bstrEntryPath)
    return E_INVALIDARG;

  DFS_INFO_4*  pInfoBuffer = NULL;
  NET_API_STATUS nRet = NetDfsGetInfo(
                            m_bstrEntryPath,
                            NULL,
                            NULL,
                            4,
                            (LPBYTE*)&pInfoBuffer
                        );

  dfsDebugOut((_T("NetDfsGetInfo entry=%s, level 4 for Timeout, nRet=%d\n"),
      m_bstrEntryPath, nRet));

  if (NERR_Success == nRet)
  {
      *pVal = pInfoBuffer->Timeout;

      NetApiBufferFree(pInfoBuffer);
  }

  return HRESULT_FROM_WIN32(nRet);
}


/////////////////////////////////////////////////////////////////////////////
// put_Timeout


STDMETHODIMP CDfsJunctionPoint :: put_Timeout
(
  long          newVal
)
{
    if (!m_bstrEntryPath)
        return E_INVALIDARG;

    DFS_INFO_102    DfsInfoLevel102 = {newVal};
    NET_API_STATUS    nRet = NetDfsSetInfo  (
                              m_bstrEntryPath,
                              NULL,
                              NULL,
                              102,
                              (LPBYTE) &DfsInfoLevel102
                            );

  dfsDebugOut((_T("NetDfsSetInfo entry=%s, level 102 for Timeout, nRet=%d\n"),
      m_bstrEntryPath, nRet));

  return HRESULT_FROM_WIN32(nRet);
}

/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_ReplicaSetDN
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  if (!m_bstrReplicaSetDN)
  {
    hr = _GetReplicaSetDN(m_bstrEntryPath);
    RETURN_IF_FAILED(hr);
  }

  *pVal = m_bstrReplicaSetDN.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_ReplicaSetExist
(
  BOOL*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;

  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  *pVal = m_bReplicaSetExist;

  return S_OK;
}

STDMETHODIMP CDfsJunctionPoint :: get_ReplicaSetExistEx
(
  BSTR*          o_pbstrDC,
  BOOL*          pVal
)
{
  if (!pVal || !o_pbstrDC)
    return E_INVALIDARG;

  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  HRESULT hr = S_OK;
  if (!m_bstrReplicaSetDN)
  {
    hr = _GetReplicaSetDN(m_bstrEntryPath);
    RETURN_IF_FAILED(hr);
  }

  DFS_TYPE dwDfsType = DFS_TYPE_UNASSIGNED;
  CComBSTR bstrDomainName;
  CComBSTR bstrDomainDN;
  hr = _GetDfsType(&dwDfsType, &bstrDomainName, &bstrDomainDN);
  RETURN_IF_FAILED(hr);

  m_bReplicaSetExist = FALSE;
  if (dwDfsType == DFS_TYPE_FTDFS)
  {
    CComBSTR bstrDN = m_bstrReplicaSetDN;
    if ((BSTR)bstrDN) bstrDN += _T(",");
    if ((BSTR)bstrDN) bstrDN += bstrDomainDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDN);

    PLDAP pldap = NULL;
    CComBSTR bstrDC;
    hr = ConnectToDS(bstrDomainName, &pldap, &bstrDC);
    if (SUCCEEDED(hr))
    {
        m_bReplicaSetExist = (S_OK == IsValidObject(pldap, bstrDN));

        CloseConnectionToDS(pldap);

        *o_pbstrDC = bstrDC.Copy();
        if (!*o_pbstrDC)
            hr = E_OUTOFMEMORY;

    }
  }

  *pVal = m_bReplicaSetExist;

  return hr;
}

HRESULT CDfsJunctionPoint :: _GetDfsType(
    OUT DFS_TYPE* o_pdwDfsType,
    OUT BSTR*     o_pbstrDomainName,
    OUT BSTR*     o_pbstrDomainDN
)
{
    if (!o_pdwDfsType)
        return E_INVALIDARG;

    if (!m_spiDfsRoot)
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    m_spiDfsRoot->get_DfsType((long *)o_pdwDfsType);
    if (*o_pdwDfsType == DFS_TYPE_FTDFS)
    {
        if (o_pbstrDomainName)
            hr = m_spiDfsRoot->get_DomainName(o_pbstrDomainName);

        if (SUCCEEDED(hr) && o_pbstrDomainDN)
            hr = m_spiDfsRoot->get_DomainDN(o_pbstrDomainDN);
    }

    return hr;
}

STDMETHODIMP CDfsJunctionPoint :: put_ReplicaSetExist
(
  BOOL          newVal
)
{
  if (!m_bstrEntryPath)
    return E_INVALIDARG;

  m_bReplicaSetExist = newVal;

  return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT CDfsJunctionPoint::_Init(
    PDFS_INFO_3 pDfsInfo, 
    BOOL        bReplicaSetExist,
    BSTR        bstrReplicaSetDN
)
{
    _FreeMemberVariables();

    if (bReplicaSetExist && (!bstrReplicaSetDN || !*bstrReplicaSetDN))
        return E_INVALIDARG;

    HRESULT hr = S_OK;

    do {
        m_bstrEntryPath = pDfsInfo->EntryPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath, &hr);

        hr = GetUNCPathComponent(m_bstrEntryPath, &m_bstrJunctionName, 4, 0);
        BREAK_IF_FAILED(hr);

        hr = GetUNCPathComponent(m_bstrEntryPath, &m_bstrJunctionNameEx, 3, 0);
        BREAK_IF_FAILED(hr);

        PDFS_STORAGE_INFO pStorage = pDfsInfo->Storage;

        for (DWORD i = 0; i < pDfsInfo->NumberOfStorages && pStorage; i++, pStorage++)
        {
            hr = _AddToReplicaList(pStorage->ServerName, pStorage->ShareName, pStorage->State);
            BREAK_IF_FAILED(hr);
        }
        
        m_bReplicaSetExist = bReplicaSetExist;

        if (m_bReplicaSetExist)
        {
            m_bstrReplicaSetDN = bstrReplicaSetDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        }
    } while (0);

    if (FAILED(hr))
        _FreeMemberVariables();

    return hr;
}

STDMETHODIMP CDfsJunctionPoint :: Initialize
(
  IUnknown *i_piDfsRoot,
  BSTR i_szEntryPath,
  BOOL i_bReplicaSetExist,
  BSTR i_bstrReplicaSetDN
)
{
/*++

Routine Description:
  
  This initializes the junction point. Before this method is called the 
  data stored by DfsJunctionPoint is NULL. If initialization fails the
  properties will be NULL.

Arguments:

  i_szEntryPath - The the Entry Path to the Junction Point.
--*/

    RETURN_INVALIDARG_IF_NULL(i_piDfsRoot);
    RETURN_INVALIDARG_IF_NULL(i_szEntryPath);

    if ((IDfsRoot *)m_spiDfsRoot)
        m_spiDfsRoot.Release();
    i_piDfsRoot->QueryInterface(IID_IDfsRoot, (void **)&m_spiDfsRoot);

    PDFS_INFO_3     pDfsInfo = NULL;
    NET_API_STATUS  nRet = NetDfsGetInfo(
                              i_szEntryPath,
                              NULL,
                              NULL,
                              3,
                              (LPBYTE*) &pDfsInfo
                            );

    dfsDebugOut((_T("NetDfsGetInfo entry=%s, level 3 for Link Initialization, nRet=%d\n"),
        i_szEntryPath, nRet));

  if (NERR_Success != nRet)
    {
        if (NERR_DfsNoSuchVolume == nRet)
            return S_FALSE; // no such link
        else
            return HRESULT_FROM_WIN32(nRet);
    }

    HRESULT hr = _Init(pDfsInfo, i_bReplicaSetExist, i_bstrReplicaSetDN);

    NetApiBufferFree(pDfsInfo);

    return hr;
}

// Note: not all fields of pDfsInfo is filled in, e.g., comment/timeout are not filled in
HRESULT VariantToDfsInfoLevel3(VARIANT *pVar, OUT PDFS_INFO_3 *ppDfsInfo)
{
    *ppDfsInfo = NULL;

    if (V_VT(pVar) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa_2 = V_ARRAY(pVar);
    long        lLowerBound = 0;
    long        lUpperBound = 0;
    long        lCount = 0;

    if (!psa_2)
        return E_INVALIDARG;

    SafeArrayGetLBound(psa_2, 1, &lLowerBound );
    SafeArrayGetUBound(psa_2, 1, &lUpperBound );
    lCount = lUpperBound - lLowerBound + 1;
    if (lCount != ARRAY_COUNT_FOR_DFS_INFO_3)
        return E_INVALIDARG;

    HRESULT hr = S_OK;
    VARIANT HUGEP *pArray_2;
    SafeArrayAccessData(psa_2, (void HUGEP **) &pArray_2);
    do {
        if (V_VT(&(pArray_2[0])) != VT_BSTR   ||
            V_VT(&(pArray_2[1])) != (VT_ARRAY | VT_VARIANT))
        {
            hr = E_INVALIDARG;
            break;
        }

        SAFEARRAY *psa_1 = V_ARRAY(&(pArray_2[1]));
        if (!psa_1)
        {
            lCount = 0;  // empty root/link container
        } else
        {
            SafeArrayGetLBound(psa_1, 1, &lLowerBound );
            SafeArrayGetUBound(psa_1, 1, &lUpperBound );
            lCount = lUpperBound - lLowerBound + 1;
        }
        
        *ppDfsInfo = (PDFS_INFO_3)calloc(
                    sizeof(DFS_INFO_3) + lCount * sizeof(DFS_STORAGE_INFO),
                    1);
        BREAK_OUTOFMEMORY_IF_NULL(*ppDfsInfo, &hr);

        LPDFS_STORAGE_INFO pStorage = (LPDFS_STORAGE_INFO)((BYTE*)*ppDfsInfo + sizeof(DFS_INFO_3));

        (*ppDfsInfo)->EntryPath           = pArray_2[0].bstrVal;
        (*ppDfsInfo)->NumberOfStorages    = lCount;
        (*ppDfsInfo)->Storage             = pStorage;

        VARIANT HUGEP *pArray_1;
        SafeArrayAccessData(psa_1, (void HUGEP **)&pArray_1);
        for (long i = 0; i < lCount; i++, pStorage++)
        {
            if (V_VT(&(pArray_1[i])) != (VT_ARRAY | VT_VARIANT))
            {
                hr = E_INVALIDARG;
                break;
            }

            SAFEARRAY *psa_0 = V_ARRAY(&(pArray_1[i]));
            SafeArrayGetLBound(psa_0, 1, &lLowerBound );
            SafeArrayGetUBound(psa_0, 1, &lUpperBound );
            if (ARRAY_COUNT_FOR_DFS_STORAGE_INFO != (lUpperBound - lLowerBound + 1))
            {
                hr = E_INVALIDARG;
                break;
            }
            VARIANT HUGEP *pArray_0;
            SafeArrayAccessData(psa_0, (void HUGEP **)&pArray_0);
            if (V_VT(&(pArray_0[0])) != VT_BSTR ||
                V_VT(&(pArray_0[1])) != VT_BSTR ||
                V_VT(&(pArray_0[2])) != VT_I4)
            {
                hr = E_INVALIDARG;
            } else
            {
                pStorage->ServerName    = pArray_0[0].bstrVal;
                pStorage->ShareName     = pArray_0[1].bstrVal;
                pStorage->State         = pArray_0[2].lVal;
            }
            SafeArrayUnaccessData(psa_0);
        }
        SafeArrayUnaccessData(psa_1);

    } while (0);

    SafeArrayUnaccessData(psa_2);

    if (FAILED(hr) && *ppDfsInfo)
        free((void *)*ppDfsInfo);

    return hr;
}

STDMETHODIMP CDfsJunctionPoint :: InitializeEx
(
  IUnknown  *piDfsRoot,
  VARIANT   *pVar,
  BOOL      bReplicaSetExist,
  BSTR      bstrReplicaSetDN
)
{
    RETURN_INVALIDARG_IF_NULL(piDfsRoot);
    RETURN_INVALIDARG_IF_NULL(pVar);

    if ((IDfsRoot *)m_spiDfsRoot)
        m_spiDfsRoot.Release();
    piDfsRoot->QueryInterface(IID_IDfsRoot, (void **)&m_spiDfsRoot);

    PDFS_INFO_3 pDfsInfo = NULL;
    HRESULT hr = VariantToDfsInfoLevel3(pVar, &pDfsInfo);
    if (SUCCEEDED(hr))
    {
        hr = _Init(pDfsInfo, bReplicaSetExist, bstrReplicaSetDN);

        free((void *)pDfsInfo);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get_CountOfDfsReplicas
(
  long*          pVal
)
{
  if (!pVal)
    return(E_INVALIDARG);

  *pVal = m_Replicas.size();
    
  return S_OK;
}



/////////////////////////////////////////////////////////////////////////////////////////////////


void CDfsJunctionPoint :: _FreeMemberVariables
(
)
{
  m_bstrEntryPath.Empty();
  m_bstrJunctionName.Empty();
  m_bstrJunctionNameEx.Empty();
  m_bstrReplicaSetDN.Empty();

  m_bReplicaSetExist = FALSE;

  FreeReplicas(&m_Replicas);
}



/////////////////////////////////////////////////////////////////////////////////////////////////


HRESULT CDfsJunctionPoint :: _GetReplicaSetDN
(  
  BSTR          i_szEntryPath
)
{
    // as an example, given an entry path \\dom\public\dir1\dir2

    // set m_bstrReplicaSetDN to be: 
    // "CN=public|dir1|dir2,CN=public,CN=DFS Volumes,
    // CN=File Replication Service,CN=System"

    CComBSTR    bstrDfsName;  // e.g., "public"
    HRESULT     hr = GetUNCPathComponent(i_szEntryPath, &bstrDfsName, 3, 4);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrDfsRootDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);
    bstrDfsRootDN += bstrDfsName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);
    bstrDfsRootDN += CN_DFSVOLUMES_PREFIX;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDfsRootDN);

    hr = ExtendDNIfLongJunctionName(m_bstrJunctionNameEx, bstrDfsRootDN, &m_bstrReplicaSetDN);

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP CDfsJunctionPoint :: get__NewEnum
(
  LPUNKNOWN*        pVal
)
{
/*++

Routine Description:

  This property gets a new replica enumerator pointer.

Arguments:

  pVal - Pointer in which the pointer to IEnumVARIANT pointer will be returned.

--*/

      if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

                // Create a new ReplicaEnum object which implements IEnumVARIANT 
                // and return the pointer to IEnumVARIANT.
    CComObject<CReplicaEnum> *pReplicaEnum = new CComObject<CReplicaEnum>();
    if (!pReplicaEnum)
        return E_OUTOFMEMORY;
    
                // Initialize the enumerator with the list of replicas and the entrypath.
    HRESULT hr = pReplicaEnum->Initialize(&m_Replicas, m_bstrEntryPath);

                // Get the enumerator pointer.
    if (SUCCEEDED(hr))
        hr = pReplicaEnum->QueryInterface(IID_IEnumVARIANT, (void **)pVal);

    if (FAILED(hr))
    {
      delete pReplicaEnum;
      return hr;
    }

  return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////////////////////
// AddReplica

HRESULT CDfsJunctionPoint::_AddToReplicaList(BSTR bstrServerName, BSTR bstrShareName, long lDfsStorageState)
{
    REPLICAINFO*   pDfsReplica = new REPLICAINFO;
    RETURN_OUTOFMEMORY_IF_NULL(pDfsReplica);

    HRESULT hr = pDfsReplica->Init(bstrServerName, bstrShareName, lDfsStorageState);
    if (FAILED(hr))
    {
        delete pDfsReplica;
        return hr;
    }

    m_Replicas.push_back(pDfsReplica);

    return S_OK;
}

void CDfsJunctionPoint::_DeleteFromReplicaList(BSTR bstrServerName, BSTR bstrShareName)
{
  for (REPLICAINFOLIST::iterator i = m_Replicas.begin(); i != m_Replicas.end(); i++)
  {
      if (0 == lstrcmpi(bstrServerName, (*i)->m_bstrServerName) &&
          0 == lstrcmpi(bstrShareName, (*i)->m_bstrShareName))
      {
          delete (*i);
          m_Replicas.erase(i);
          break;
      }
  }
}

HRESULT CDfsJunctionPoint::_GetDfsStorageState
(
    BSTR          i_szServerName,
    BSTR          i_szShareName,
    long*         o_pVal
)
{
    if (!i_szServerName || !i_szShareName || !o_pVal)
        return E_INVALIDARG;
  
    *o_pVal = DFS_STORAGE_STATE_OFFLINE;

    PDFS_INFO_3    pDfsInfo = NULL;
    NET_API_STATUS nstatRetVal = NetDfsGetInfo  (
                                  m_bstrEntryPath,
                                  i_szServerName,
                                  i_szShareName,
                                  3,
                                  (LPBYTE*)&pDfsInfo
                                );

    dfsDebugOut((_T("NetDfsGetInfo entry=%s, server=%s, share=%s, level 3 for State, nRet=%d\n"),
        m_bstrEntryPath, i_szServerName, i_szShareName, nstatRetVal));

    if (nstatRetVal != NERR_Success)
    {
        if (nstatRetVal == NERR_DfsNoSuchVolume)
            return S_FALSE;
        else
            return HRESULT_FROM_WIN32 (nstatRetVal);
    }

    BOOL bFound = FALSE;
    LPDFS_STORAGE_INFO  pStorageInfo = pDfsInfo->Storage;
    for (UINT i=0; i < pDfsInfo->NumberOfStorages; i++, pStorageInfo++)
    {
        if ( !lstrcmpi(pStorageInfo->ServerName, i_szServerName) &&
            !lstrcmpi(pStorageInfo->ShareName, i_szShareName) )
        {
            bFound = TRUE;
            *o_pVal = pStorageInfo->State;
            break;
        }
    }

    NetApiBufferFree(pDfsInfo);

    return (bFound ? S_OK : S_FALSE);
}

STDMETHODIMP CDfsJunctionPoint :: AddReplica
(
  BSTR          i_szServerName,
  BSTR          i_szShareName,
  VARIANT*      o_pvarReplicaObject
)
{
/*++

Routine Description:

  This method adds a Replica to an existing Junction Point.

Arguments:

  i_szServerName - The name of the server which hosts the share that the junction point should point to.
  i_szShareName - The name of the share that the junction point should point to.
  o_pvarReplicaObject - The Newly Created Replica's Object is returned here.
--*/

    if (!i_szServerName || !i_szShareName || !o_pvarReplicaObject)
        return E_INVALIDARG;

    HRESULT        hr = S_OK;
    long           lDfsStorageState = DFS_STORAGE_STATE_OFFLINE;
    NET_API_STATUS nstatRetVal = NetDfsAdd  (
                                    m_bstrEntryPath,
                                    i_szServerName,
                                    i_szShareName,
                                    NULL,
                                    DFS_RESTORE_VOLUME
                                  );

    dfsDebugOut((_T("NetDfsAdd entry=%s, server=%s, share=%s, DFS_RESTORE_VOLUME, nRet=%d\n"),
        m_bstrEntryPath, i_szServerName, i_szShareName, nstatRetVal));

    if (NERR_Success != nstatRetVal)
    {
        return HRESULT_FROM_WIN32 (nstatRetVal);
    } else
    {
        hr = _GetDfsStorageState(i_szServerName, i_szShareName, &lDfsStorageState);
        if (S_OK != hr)
        {
            // something is wrong, we failed to find the target we just added
            return E_FAIL;
        }
    }

                            // Gets the IReplica interface pointer.
    IDfsReplica* pIReplicaPtr = NULL;
    hr = CoCreateInstance(CLSID_DfsReplica, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDfsReplica, (void **)&pIReplicaPtr);
    RETURN_IF_FAILED(hr);

                            // Initialize the replica object.
    hr = pIReplicaPtr->Initialize(
                                m_bstrEntryPath, 
                                i_szServerName,
                                i_szShareName,
                                lDfsStorageState
                              );

    if (SUCCEEDED(hr))
        hr = _AddToReplicaList(i_szServerName, i_szShareName, lDfsStorageState);

    if (SUCCEEDED(hr))
    {
        o_pvarReplicaObject->vt = VT_DISPATCH;
        o_pvarReplicaObject->pdispVal = (IDispatch*)pIReplicaPtr;
    } else
    {
        pIReplicaPtr->Release();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// RemoveReplica


STDMETHODIMP CDfsJunctionPoint :: RemoveReplica
(
  BSTR          i_szServerName,
  BSTR          i_szShareName
)
{
/*++

Routine Description:

  This method removes a replica for the Junction point.

Arguments:

  i_szServerName  - The name of the server hosting the share that the replica is representing.
  i_szShareName  - The name of the share that the replica is representing
--*/
    if (!i_szServerName || !i_szShareName)
        return E_INVALIDARG;

    NET_API_STATUS nstatRetVal = NetDfsRemove(
                                        m_bstrEntryPath,
                                        i_szServerName,
                                        i_szShareName
                                    );

    dfsDebugOut((_T("NetDfsRemove entrypath=%s, server=%s, share=%s, nRet=%d\n"),
        m_bstrEntryPath, i_szServerName, i_szShareName, nstatRetVal));

    if (ERROR_NOT_FOUND == nstatRetVal)
        nstatRetVal = NERR_Success;

    if (NERR_Success == nstatRetVal)
        _DeleteFromReplicaList(i_szServerName, i_szShareName);

    return HRESULT_FROM_WIN32 (nstatRetVal);
}

STDMETHODIMP CDfsJunctionPoint::RemoveAllReplicas()
{
/*++

Routine Description:

  This method deletes the Junction point.

--*/

    if (m_Replicas.empty())
        return S_OK;

    //
    // DFS DCR: allow link deletion happen at once
    //
    NET_API_STATUS nstatRetVal = NetDfsRemove(
                                        m_bstrEntryPath,
                                        NULL,
                                        NULL
                                    );
    dfsDebugOut((_T("NetDfsRemove at once entrypath=%s, nRet=%d\n"), m_bstrEntryPath, nstatRetVal));

    if (ERROR_NOT_FOUND == nstatRetVal)
        nstatRetVal = NERR_Success;

    if (NERR_Success == nstatRetVal)
          FreeReplicas(&m_Replicas);

    return HRESULT_FROM_WIN32 (nstatRetVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// DeleteRootReplica

STDMETHODIMP CDfsJunctionPoint::DeleteRootReplica
(
    BSTR i_bstrDomainName,
    BSTR i_bstrDfsName,
    BSTR i_bstrServerName,
    BSTR i_bstrShareName,
    BOOL i_bForce
)
{
    RETURN_INVALIDARG_IF_TRUE(!i_bstrServerName || !*i_bstrServerName);
    RETURN_INVALIDARG_IF_TRUE(!i_bstrShareName || !*i_bstrShareName);

    NET_API_STATUS  nStatus = NERR_Success;

    if (!i_bstrDfsName || !*i_bstrDfsName)  // standalone Dfs
    {
        nStatus = NetDfsRemoveStdRoot(
                        i_bstrServerName,
                        i_bstrShareName,
                        0          // No Flags.
                    );
        dfsDebugOut((_T("NetDfsRemoveStdRoot server=%s, share=%s, nRet=%d\n"),
            i_bstrServerName, i_bstrShareName, nStatus));
    } else
    {
        if (!i_bForce)
        {
            nStatus = NetDfsRemoveFtRoot(
                        i_bstrServerName,
                        i_bstrShareName,
                        i_bstrDfsName,
                        0          // No Flags.
                    );
            dfsDebugOut((_T("NetDfsRemoveFtRoot server=%s, share=%s, DfsName=%s, nRet=%d\n"),
                i_bstrServerName, i_bstrShareName, i_bstrDfsName, nStatus));
        } else
        {
            nStatus = NetDfsRemoveFtRootForced(
                        i_bstrDomainName,
                        i_bstrServerName,
                        i_bstrShareName,
                        i_bstrDfsName,
                        0          // No Flags.
                    );
            dfsDebugOut((_T("NetDfsRemoveFtRootForced domain=%s, server=%s, share=%s, DfsName=%s, nRet=%d\n"),
                i_bstrDomainName, i_bstrServerName, i_bstrShareName, i_bstrDfsName, nStatus));
        }
    }

    if (NERR_Success == nStatus)
        _DeleteFromReplicaList(i_bstrServerName, i_bstrShareName);

    return HRESULT_FROM_WIN32(nStatus);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// GetOneRootReplica

// always return the first entry in the m_Replicas list.
STDMETHODIMP CDfsJunctionPoint::GetOneRootReplica
(
    OUT BSTR* o_pbstrServerName,
    OUT BSTR* o_pbstrShareName
)
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrServerName);
    RETURN_INVALIDARG_IF_NULL(o_pbstrShareName);

    *o_pbstrServerName = NULL;
    *o_pbstrShareName = NULL;

    if (m_Replicas.empty())
        return E_INVALIDARG;

    REPLICAINFOLIST::iterator i = m_Replicas.begin();
    *o_pbstrServerName = SysAllocString((*i)->m_bstrServerName);
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrServerName);

    *o_pbstrShareName = SysAllocString((*i)->m_bstrShareName);
    if (!*o_pbstrShareName)
    {
        SysFreeString(*o_pbstrServerName);
        *o_pbstrServerName = NULL;
        return E_OUTOFMEMORY;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfsrep.cpp ===
/*++
Module Name:
    DfsRep.cpp

Abstract:
  This COM Class provides method to get information of Dfs replica.
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "DfsRep.h"

/////////////////////////////////////////////////////////////////////////////
// CDfsReplica

CDfsReplica::CDfsReplica()
{
    dfsDebugOut((_T("CDfsReplica::CDfsReplica this=%p\n"), this));
}

CDfsReplica::~CDfsReplica()
{
    dfsDebugOut((_T("CDfsReplica::~CDfsReplica this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////
// get_State

STDMETHODIMP CDfsReplica :: get_State
(
  long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;
  
    *pVal = m_lDfsReferralState;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// put_State


STDMETHODIMP CDfsReplica :: put_State
(
  long          newVal
)
{
    DFS_INFO_101          DfsInfoLevel101 = {0};

    if (DFS_REFERRAL_STATE_OFFLINE == newVal)
        DfsInfoLevel101.State = DFS_STORAGE_STATE_OFFLINE;
    else if (DFS_REFERRAL_STATE_ONLINE == newVal)
        DfsInfoLevel101.State = DFS_STORAGE_STATE_ONLINE;
    else
        return E_INVALIDARG;

    NET_API_STATUS nstatRetVal = NetDfsSetInfo  (
                                      m_bstrEntryPath,
                                      m_bstrStorageServerName,
                                      m_bstrStorageShareName,
                                      101,
                                      (LPBYTE) &DfsInfoLevel101
                                    );

    dfsDebugOut((_T("NetDfsSetInfo entry=%s, server=%s, share=%s, level 101 for State, nRet=%d\n"),
        m_bstrEntryPath, m_bstrStorageServerName, m_bstrStorageShareName, nstatRetVal));


    if (NERR_Success == nstatRetVal)
        m_lDfsReferralState = newVal;

    return HRESULT_FROM_WIN32 (nstatRetVal);
}


/////////////////////////////////////////////////////////////////////////////
// get_StorageServerName


STDMETHODIMP CDfsReplica :: get_StorageServerName
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;
  
  *pVal = m_bstrStorageServerName.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// get_StorageShareName


STDMETHODIMP CDfsReplica :: get_StorageShareName
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;
  
  *pVal = m_bstrStorageShareName.Copy ();
  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Initialize


STDMETHODIMP CDfsReplica :: Initialize
(
  BSTR          i_szEntryPath,
  BSTR          i_szStorageServerName, 
  BSTR          i_szStorageShareName,
  long          i_lDfsStorageState
)
{
/*++

Routine Description:

  Initializes the  DfsReplica object. Should be called after CoCreateInstance.
  If initialisation fails all properties will be NULL.

Arguments:

  i_szEntryPath - The entry path to the Replica.
  i_szStorageServerName - The name of the server which hosts the share the replica exists on.
  i_szStorageShareName - The name of the share.
--*/

    if (!i_szEntryPath || !i_szStorageServerName || !i_szStorageShareName)
        return E_INVALIDARG;

    _FreeMemberVariables ();

    HRESULT hr = S_OK;

    do {
        m_bstrEntryPath = i_szEntryPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath, &hr);
        m_bstrStorageServerName = i_szStorageServerName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStorageServerName, &hr);
        m_bstrStorageShareName = i_szStorageShareName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStorageShareName, &hr);

        if (DFS_STORAGE_STATE_ONLINE == i_lDfsStorageState)
        {
            m_lDfsReferralState = DFS_REFERRAL_STATE_ONLINE;
        } else if (DFS_STORAGE_STATE_OFFLINE == i_lDfsStorageState)
        {
            m_lDfsReferralState = DFS_REFERRAL_STATE_OFFLINE;
        } else
        {
            hr = E_INVALIDARG;
            break;
        }

    } while (0);

    if (FAILED(hr))
        _FreeMemberVariables ();

  return hr;
}


/////////////////////////////////////////////////////////////////////////////
// get_EntryPath


STDMETHODIMP CDfsReplica :: get_EntryPath
(
  BSTR*          pVal
)
{
  if (!pVal)
    return E_INVALIDARG;
  
  *pVal = m_bstrEntryPath.Copy ();

  if (!*pVal)
    return E_OUTOFMEMORY;

  return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// FindTarget


STDMETHODIMP CDfsReplica::FindTarget
(
)
{
    PDFS_INFO_3    pDfsInfo = NULL;
    NET_API_STATUS nstatRetVal = NetDfsGetInfo  (
                                  m_bstrEntryPath,
                                  m_bstrStorageServerName,
                                  m_bstrStorageShareName,
                                  3,
                                  (LPBYTE*)&pDfsInfo
                                );

    dfsDebugOut((_T("NetDfsGetInfo entry=%s, server=%s, share=%s, level 3 for FindTarget, nRet=%d\n"),
        m_bstrEntryPath, m_bstrStorageServerName, m_bstrStorageShareName, nstatRetVal));

    if (nstatRetVal != NERR_Success)
    {
        if (nstatRetVal == NERR_DfsNoSuchVolume)
            return S_FALSE;
        else
            return HRESULT_FROM_WIN32(nstatRetVal);
    }

    BOOL                bFound = FALSE;
    LPDFS_STORAGE_INFO  pStorageInfo = pDfsInfo->Storage;

    for (UINT i=0; i < pDfsInfo->NumberOfStorages; i++, pStorageInfo++)
    {
        if ( !lstrcmpi(pStorageInfo->ServerName, m_bstrStorageServerName) &&
            !lstrcmpi(pStorageInfo->ShareName, m_bstrStorageShareName) )
        {
            bFound = TRUE;
            break;
        }
    }

    NetApiBufferFree(pDfsInfo);

    return (bFound ? S_OK : S_FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// _FreeMemberVariables


void CDfsReplica :: _FreeMemberVariables ()
{
  m_bstrEntryPath.Empty();
  m_bstrStorageServerName.Empty();
  m_bstrStorageShareName.Empty();
  m_lDfsReferralState = DFS_REFERRAL_STATE_OFFLINE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfsroot.cpp ===
/*++
Module Name:
    DfsRoot.cpp
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "DfsRoot.h"
#include "JPEnum.h"
#include <dsgetdc.h>
#include <dsrole.h>   // DsRoleGetPrimaryDomainInformation
#include "netutils.h"
#include "ldaputils.h"

/////////////////////////////////////////////////////////////////////////////////////////////////
// CDfsRoot constructor

CDfsRoot::CDfsRoot() : 
            m_pDfsJP(NULL), 
            m_dwDfsType(DFS_TYPE_UNASSIGNED),
            m_lCountOfDfsJunctionPointsFiltered(0),
            m_lLinkFilterType(FILTERDFSLINKS_TYPE_NO_FILTER)
{
    dfsDebugOut((_T("CDfsRoot::CDfsRoot this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// CDfsRoot destructor 


CDfsRoot::~CDfsRoot()
{
    _FreeMemberVariables();
    dfsDebugOut((_T("CDfsRoot::~CDfsRoot this=%p\n"), this));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DomainName


STDMETHODIMP CDfsRoot :: get_DomainName
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_bstrDomainName.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DomainGuid


STDMETHODIMP CDfsRoot :: get_DomainGuid
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_bstrDomainGuid.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DomainDN


STDMETHODIMP CDfsRoot :: get_DomainDN
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_bstrDomainDN.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DfsType


STDMETHODIMP CDfsRoot :: get_DfsType
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_dwDfsType;

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_State


STDMETHODIMP CDfsRoot :: get_State
(
    long*          pVal
)
{
    return m_pDfsJP->get_State(pVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_DfsName


STDMETHODIMP CDfsRoot :: get_DfsName
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG ;

    *pVal = m_bstrDfsName.Copy ();
    if (!*pVal)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_ReplicaSetDN


STDMETHODIMP CDfsRoot :: get_ReplicaSetDN
(
    BSTR*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_ReplicaSetDN(pVal);
}

STDMETHODIMP CDfsRoot :: get_ReplicaSetExist
(
  BOOL*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_ReplicaSetExist(pVal);
}

STDMETHODIMP CDfsRoot :: get_ReplicaSetExistEx
(
  BSTR*          o_pbstrDC,
  BOOL*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_ReplicaSetExistEx(o_pbstrDC, pVal);
}

STDMETHODIMP CDfsRoot :: put_ReplicaSetExist
(
  BOOL          newVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->put_ReplicaSetExist(newVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_CountOfDfsJunctionPoints


STDMETHODIMP CDfsRoot :: get_CountOfDfsJunctionPoints
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_JunctionPoints.size();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_CountOfDfsJunctionPointsFiltered


STDMETHODIMP CDfsRoot :: get_CountOfDfsJunctionPointsFiltered
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_lCountOfDfsJunctionPointsFiltered;

    return S_OK;
}

HRESULT DfsInfo3ToVariant(PDFS_INFO_3 pDfsInfo, OUT VARIANT *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pDfsInfo);
    RETURN_INVALIDARG_IF_NULL(pVal);

    HRESULT hr = S_OK;

    int cStorages = pDfsInfo->NumberOfStorages;

    // create an array of array of variants to hold all storage data
    SAFEARRAY*      psa_1 = NULL;

    if (cStorages > 0 )
    {
        SAFEARRAYBOUND  bounds_1 = {cStorages, 0};
        psa_1 = SafeArrayCreate(VT_VARIANT, 1, &bounds_1);
        RETURN_OUTOFMEMORY_IF_NULL(psa_1);

        VARIANT*        varArray_1 = NULL;
        SafeArrayAccessData(psa_1, (void**)&varArray_1);
        for (int i = 0; i < cStorages; i++)
        {
            // create an array of variants to hold each Storage data (3 elements)
            SAFEARRAYBOUND  bounds_0 = {ARRAY_COUNT_FOR_DFS_STORAGE_INFO, 0};
            SAFEARRAY*      psa_0 = SafeArrayCreate(VT_VARIANT, 1, &bounds_0);
            BREAK_OUTOFMEMORY_IF_NULL(psa_0, &hr);

            VARIANT*        varArray_0 = NULL;
            SafeArrayAccessData(psa_0, (void**)&varArray_0);
            do
            {
                varArray_0[0].vt        = VT_BSTR;
                varArray_0[0].bstrVal   = SysAllocString(pDfsInfo->Storage[i].ServerName);
                BREAK_OUTOFMEMORY_IF_NULL(varArray_0[0].bstrVal, &hr);

                varArray_0[1].vt        = VT_BSTR;
                varArray_0[1].bstrVal   = SysAllocString(pDfsInfo->Storage[i].ShareName);
                BREAK_OUTOFMEMORY_IF_NULL(varArray_0[1].bstrVal, &hr);

                varArray_0[2].vt        = VT_I4;
                varArray_0[2].lVal   = pDfsInfo->Storage[i].State;
            } while (0);
            SafeArrayUnaccessData(psa_0);

            if (FAILED(hr))
            {
                SafeArrayDestroy(psa_0);
                break;
            }

            // add this array to be an element
            varArray_1[i].vt        = VT_ARRAY | VT_VARIANT;
            varArray_1[i].parray    = psa_0;
        }
        SafeArrayUnaccessData(psa_1);
    }

    if (SUCCEEDED(hr))
    {
        // now create an array of variants to hold DfsInfoLevel
        SAFEARRAYBOUND  bounds_2 = {ARRAY_COUNT_FOR_DFS_INFO_3, 0};
        SAFEARRAY*      psa_2 = SafeArrayCreate(VT_VARIANT, 1, &bounds_2);
        if (!psa_2)
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            VARIANT*        varArray_2 = NULL;
            SafeArrayAccessData(psa_2, (void**)&varArray_2);
            do
            {
                varArray_2[0].vt        = VT_BSTR;
                varArray_2[0].bstrVal   = SysAllocString(pDfsInfo->EntryPath);
                BREAK_OUTOFMEMORY_IF_NULL(varArray_2[0].bstrVal, &hr);

                varArray_2[1].vt        = VT_ARRAY | VT_VARIANT;
                varArray_2[1].parray    = psa_1;

            } while (0);
            SafeArrayUnaccessData(psa_2);

            if (FAILED(hr))
                SafeArrayDestroy(psa_2);
        }

        if (SUCCEEDED(hr))
        {
            VariantInit(pVal);
            pVal->vt = VT_ARRAY | VT_VARIANT;
            pVal->parray = psa_2;
        }
    }

    if (FAILED(hr))
        SafeArrayDestroy(psa_1);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  Initialize

HRESULT CDfsRoot::_Init(
    PDFS_INFO_3 pDfsInfo,
    StringMap*  pMap)
{
    RETURN_INVALIDARG_IF_NULL(pDfsInfo);
    RETURN_INVALIDARG_IF_NULL(pMap);

    HRESULT hr = S_OK;

    do {
        hr = GetUNCPathComponent(pDfsInfo->EntryPath, &m_bstrDfsName, 3, 4);
        BREAK_IF_FAILED(hr);

        // decide whether it's a domain-based or standalone
        CComBSTR bstrScope;
        hr = GetUNCPathComponent(pDfsInfo->EntryPath, &bstrScope, 2, 3);
        BREAK_IF_FAILED(hr);

        if ((pDfsInfo->State & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_STANDALONE)
        {
            m_dwDfsType = DFS_TYPE_STANDALONE;
        } else if ((pDfsInfo->State & DFS_VOLUME_FLAVORS) == DFS_VOLUME_FLAVOR_AD_BLOB)
        {
            m_dwDfsType = DFS_TYPE_FTDFS;
        } else
        {
            // flavor flag is not set, we're dealing with old version of metadata blob

            // see if bstrScope is a domain name
#ifdef DEBUG
            SYSTEMTIME time0 = {0};
            GetSystemTime(&time0);
#endif // DEBUG
            PDOMAIN_CONTROLLER_INFO   pDCInfo = NULL;
            DWORD nRet = DsGetDcName(
                      NULL,
                      bstrScope,
                      NULL,
                      NULL,
                      DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                      &pDCInfo
                    );
#ifdef DEBUG
            SYSTEMTIME time1 = {0};
            GetSystemTime(&time1);
            PrintTimeDelta(_T("CDfsRoot::_Init-DsGetDcName"), &time0, &time1);
#endif // DEBUG
            if (ERROR_SUCCESS == nRet)
            { 
                NetApiBufferFree(pDCInfo);

                m_dwDfsType = DFS_TYPE_FTDFS;
            } else
            { // check to see if it's a valid server name
                PWKSTA_INFO_100     wki100 = NULL;
                nRet = NetWkstaGetInfo(bstrScope, 100, (LPBYTE *)&wki100 );
                if (ERROR_SUCCESS == nRet)
                {
                    m_dwDfsType = DFS_TYPE_STANDALONE;
                    NetApiBufferFree((LPVOID)wki100);
                } else
                {
                    hr = HRESULT_FROM_WIN32(nRet);
                }
    
            }
        }

        if (SUCCEEDED(hr) && m_dwDfsType == DFS_TYPE_FTDFS)
        {
            hr = GetDomainInfo( bstrScope,
                                NULL, // DC
                                &m_bstrDomainName,
                                &m_bstrDomainDN,
                                NULL, // LDAPDomainPath
                                &m_bstrDomainGuid);
        }

        BREAK_IF_FAILED(hr);

        if (m_dwDfsType == DFS_TYPE_FTDFS)
        {
            (void) _GetAllReplicaSets(pMap);
        }

        CComVariant varData;
        hr = DfsInfo3ToVariant(pDfsInfo, &varData);
        BREAK_IF_FAILED(hr);

        hr = CoCreateInstance(CLSID_DfsJunctionPoint, NULL, CLSCTX_INPROC_SERVER,
            IID_IDfsJunctionPoint, (void **)&m_pDfsJP);
        BREAK_IF_FAILED(hr);

        if (m_dwDfsType == DFS_TYPE_FTDFS)
        {
            CComBSTR bstrDfsLinkName;
            hr = GetUNCPathComponent(pDfsInfo->EntryPath, &bstrDfsLinkName, 3, 0);
            BREAK_IF_FAILED(hr);

            StringMap::iterator it = pMap->find(bstrDfsLinkName);
            if (it != pMap->end())
                hr = m_pDfsJP->InitializeEx((IUnknown *)this, &varData, TRUE, (*it).second);
            else
                hr = m_pDfsJP->InitializeEx((IUnknown *)this, &varData, FALSE, NULL);
        } else
        {
            hr = m_pDfsJP->InitializeEx((IUnknown *)this, &varData, FALSE, NULL);
        }

    } while (0);

    return hr;
}

int __cdecl CompareJPs(const void *arg1, const void *arg2 )
{
   return lstrcmpi( (*(PDFS_INFO_3 *)arg1)->EntryPath, (*(PDFS_INFO_3 *)arg2)->EntryPath );
}


STDMETHODIMP CDfsRoot :: Initialize
(
    BSTR          i_szDfsName
)
{
/*++

Routine Description:
  
  This method intializes the newly created object and previously initialised 
  DfsRoot object.

Arguments:

  i_szDfsName - The Dfs name which can be any of the following type:
  1.  \\domain.dns.name\FtDfs,
  2.  \\domain\FtDfs,
  3.  \\server\share,
  4.  \\server,
  5.  server.

Notes:
  Initialize performs the following:
  1.  Gets the name of the domain for the server hosting / participating in the Dfs Root.
  2.  Gets all child junction points and root level replicas for this Dfs.
  3.  Gets the type (standalone or fault tolerant) of the DFS.
  4.  Gets the display name of the DFS, \\domain.dns.name\FtDfs or \\server\share and Dfs Name which
    is FtDfs or server..

Return:
  S_FALSE if i_szDfsName doesn't host any dfs root
--*/

    RETURN_INVALIDARG_IF_NULL(i_szDfsName);

    _FreeMemberVariables();

    LPBYTE      pBuffer = NULL;
    DWORD        dwEntriesRead = 0;
    DWORD        dwResumeHandle = 0;

    NET_API_STATUS  nRet = NetDfsEnum(
                                i_szDfsName,
                                3,  // level 3
                                0xffffffff,
                                &pBuffer,
                                &dwEntriesRead,
                                &dwResumeHandle);

    dfsDebugOut((_T("NetDfsEnum DfsName=%s, level 3 for Root Initialization, nRet=%d\n"),
        i_szDfsName, nRet));

    if (NERR_Success != nRet)
    {
        return (ERROR_NO_MORE_ITEMS == nRet || ERROR_NOT_FOUND == nRet) ? S_FALSE : HRESULT_FROM_WIN32(nRet);
    } else if (0 == dwEntriesRead)
    {
        if (pBuffer)
            NetApiBufferFree(pBuffer);

        return S_FALSE;
    }

    HRESULT hr = S_OK;
    do {
        DWORD            i = 0;
        PDFS_INFO_3        pDfsInfo = (PDFS_INFO_3)pBuffer;

        //
        // root may not be the 1st entry, find the root entry, switch it to the top
        //
        for (i = 0; i < dwEntriesRead; i++)
        {
            if (pDfsInfo[i].State & DFS_VOLUME_FLAVORS)
                break; // the i-th entry is the root entry
        }

        if (i != 0 && i != dwEntriesRead)
        {
            DFS_INFO_3 tmpInfo = {0};
            memcpy(&tmpInfo, pDfsInfo, sizeof(DFS_INFO_3));
            memcpy(pDfsInfo, pDfsInfo + i, sizeof(DFS_INFO_3));
            memcpy(pDfsInfo + i, &tmpInfo, sizeof(DFS_INFO_3));
        }

        // i=0 is the Root info
        StringMap mapReplicaSets;
        hr = _Init(pDfsInfo, &mapReplicaSets);
        BREAK_IF_FAILED(hr);

        if (dwEntriesRead > 1)
        {
            pDfsInfo++;

            PDFS_INFO_3 *pArray = (PDFS_INFO_3 *)calloc(dwEntriesRead - 1, sizeof(PDFS_INFO_3));
            BREAK_OUTOFMEMORY_IF_NULL(pArray, &hr);

            PDFS_INFO_3 *pArrayElem = NULL;
            for (i = 1, pArrayElem = pArray; i < dwEntriesRead; i++, pDfsInfo++, pArrayElem++)
                *pArrayElem = pDfsInfo;

            qsort((void *)pArray, dwEntriesRead - 1, sizeof(PDFS_INFO_3), CompareJPs);

            StringMap::iterator it;
            for (i = 1, pArrayElem = pArray; i < dwEntriesRead; i++, pArrayElem++)
            {
                if (m_dwDfsType == DFS_TYPE_FTDFS)
                {
                    CComBSTR bstrDfsLinkName;
                    hr = GetUNCPathComponent((*pArrayElem)->EntryPath, &bstrDfsLinkName, 3, 0);
                    BREAK_IF_FAILED(hr);

                    it = mapReplicaSets.find(bstrDfsLinkName);
                    if (it != mapReplicaSets.end())
                        hr = _AddToJPList(*pArrayElem, TRUE, (*it).second);
                    else
                        hr = _AddToJPList(*pArrayElem, FALSE, NULL);
                } else
                {
                    hr = _AddToJPList(*pArrayElem, FALSE, NULL);
                }

                BREAK_IF_FAILED(hr);
            }

            free((void *)pArray);
        }
    } while (0);

    NetApiBufferFree(pBuffer);

    if (FAILED(hr))
        _FreeMemberVariables();

    return hr;
}

void _FreeStringMap(IN StringMap* pMap)
{
    if (pMap && !pMap->empty()) {
        for (StringMap::iterator i = pMap->begin(); i != pMap->end(); i++)
        {
            if ((*i).first)
                free( (void *)((*i).first) );
            if ((*i).second)
                free( (void *)((*i).second) );
        }
        pMap->clear();
    }
}

HRESULT CDfsRoot :: _GetAllReplicaSets(
    OUT StringMap*  pMap
    )
{
    _FreeStringMap(pMap);

    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDomainName);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDomainDN);

    HRESULT hr = S_OK;

    PLDAP pldap = NULL;
    do {
        hr = ConnectToDS(m_bstrDomainName, &pldap);
        BREAK_IF_FAILED(hr);

        CComBSTR bstrContainerDN = _T("CN=");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrContainerDN, &hr);
        bstrContainerDN += m_bstrDfsName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrContainerDN, &hr);
        bstrContainerDN += CN_DFSVOLUMES_PREFIX_COMMA;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrContainerDN, &hr);
        bstrContainerDN += m_bstrDomainDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrContainerDN, &hr);

        //
        // get all the replica sets under the container
        //
        PCTSTR      ppszAttributes[] = {ATTR_DISTINGUISHEDNAME, 0};
        LListElem*  pElem = NULL;
        hr = GetValuesEx(
                        pldap,
                        bstrContainerDN,
                        LDAP_SCOPE_SUBTREE,
                        _T("(&(objectCategory=nTFRSReplicaSet)(frsReplicaSetType=3))"),
                        ppszAttributes,
                        &pElem);
        BREAK_IF_FAILED(hr);

        LListElem* pCurElem = pElem;
        while (pCurElem)
        {
            PTSTR** pppszValues = pCurElem->pppszAttrValues;
            if (!pppszValues ||
                !pppszValues[0] || !*(pppszValues[0]))
            {
                hr = E_FAIL;
                break;
            }

            PTSTR  pszDN = *(pppszValues[0]);

            PTSTR  p = _tcsstr(pszDN, _T(",DC="));
            if (!p)
            {
                hr = E_INVALIDARG;
                break;
            }
            *p = _T('\0');
            PTSTR  pszReplicaSetDN = _tcsdup(pszDN);
            *p = _T(',');
            BREAK_OUTOFMEMORY_IF_NULL(pszReplicaSetDN, &hr);

            CComBSTR bstrDfsLinkName;
            hr = GetDfsLinkNameFromDN(pszReplicaSetDN, &bstrDfsLinkName);

            PTSTR  pszDfsLinkName = NULL;
            if (SUCCEEDED(hr))
            {
                pszDfsLinkName = _tcsdup(bstrDfsLinkName);
                if (!pszDfsLinkName)
                    hr = E_OUTOFMEMORY;
            }

            if (FAILED(hr))
            {
                free(pszReplicaSetDN);
                break;
            }

            pMap->insert(StringMap::value_type(pszDfsLinkName, pszReplicaSetDN));

            pCurElem = pCurElem->Next;
        }

        FreeLListElem(pElem);

        BREAK_IF_FAILED(hr);

    } while (0);

    if (pldap)
        CloseConnectionToDS(pldap);

    if (FAILED(hr))
        _FreeStringMap(pMap);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  CreateJunctionPoint


STDMETHODIMP CDfsRoot :: CreateJunctionPoint
(
    BSTR            i_szJPName,
    BSTR            i_szServerName,
    BSTR            i_szShareName,
    BSTR            i_szComment,
    long            i_lTimeout,
    VARIANT*        o_pIDfsJunctionPoint
)
{
    if (!i_szJPName || !i_szServerName || !i_szShareName || !o_pIDfsJunctionPoint)
        return E_INVALIDARG;

    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    CComBSTR bstrEntryPath;      // Start with the root entry path.
    HRESULT hr = m_pDfsJP->get_EntryPath(&bstrEntryPath);
    RETURN_IF_FAILED(hr);

    bstrEntryPath += _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);
    bstrEntryPath += i_szJPName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);

    NET_API_STATUS nstatRetVal = NetDfsAdd(
                                    bstrEntryPath,
                                    i_szServerName,
                                    i_szShareName,
                                    i_szComment,
                                    DFS_ADD_VOLUME | DFS_RESTORE_VOLUME
                                  );

    dfsDebugOut((_T("NetDfsAdd entry=%s, server=%s, share=%s, comment=%s, DFS_ADD_VOLUME | DFS_RESTORE_VOLUME, nRet=%d\n"),
        bstrEntryPath, i_szServerName, i_szShareName, i_szComment, nstatRetVal));

    if (nstatRetVal != NERR_Success)
        return HRESULT_FROM_WIN32 (nstatRetVal);

                              // Get the interface pointer
    IDfsJunctionPoint*    pIJunctionPointPtr = NULL;
    hr = CoCreateInstance(CLSID_DfsJunctionPoint, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDfsJunctionPoint, (void **)&pIJunctionPointPtr);
    RETURN_IF_FAILED(hr);

    hr = pIJunctionPointPtr->Initialize((IUnknown *)this, bstrEntryPath, FALSE, NULL);

    if (SUCCEEDED(hr))
    {
        hr = pIJunctionPointPtr->put_Timeout(i_lTimeout);
        if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr)
        {
            // we're most probably managing NT4 here, which doesn't support Timeout
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
        hr = _AddToJPListEx(pIJunctionPointPtr, TRUE);

    if (SUCCEEDED(hr))
    {
        o_pIDfsJunctionPoint->vt = VT_DISPATCH;
        o_pIDfsJunctionPoint->pdispVal = pIJunctionPointPtr;
    } else
    {
        pIJunctionPointPtr->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteJunctionPoint


STDMETHODIMP CDfsRoot::DeleteJunctionPoint
(
    BSTR          i_szJPName
)
{
    if (!i_szJPName)
        return E_INVALIDARG;

    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    CComBSTR bstrEntryPath;      // Start with the root entry path.
    HRESULT hr = m_pDfsJP->get_EntryPath(&bstrEntryPath);
    RETURN_IF_FAILED(hr);

    bstrEntryPath += _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);
    bstrEntryPath += i_szJPName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrEntryPath);

                              // Get the interface pointer
    JUNCTIONNAMELIST::iterator  i;
    for (i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        if (!lstrcmpi((*i)->m_bstrJPName, i_szJPName))
            break;
    }

    if (i != m_JunctionPoints.end())
    {
        hr = ((*i)->m_piDfsJunctionPoint)->RemoveAllReplicas();

        if (SUCCEEDED(hr))
        {
            delete (*i);
            m_JunctionPoints.erase(i);
        }
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteDfsHost

STDMETHODIMP CDfsRoot::DeleteDfsHost
(
    BSTR i_bstrServerName,
    BSTR i_bstrShareName,
    BOOL i_bForce
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    switch (m_dwDfsType)
    {
    case DFS_TYPE_STANDALONE:
        return m_pDfsJP->DeleteRootReplica(NULL, NULL, i_bstrServerName, i_bstrShareName, i_bForce);
    case DFS_TYPE_FTDFS:
        return m_pDfsJP->DeleteRootReplica(m_bstrDomainName, m_bstrDfsName, i_bstrServerName, i_bstrShareName, i_bForce);
    default:
        return E_INVALIDARG;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  GetOneDfsHost

STDMETHODIMP CDfsRoot::GetOneDfsHost
(
    OUT BSTR* o_pbstrServerName,
    OUT BSTR* o_pbstrShareName
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->GetOneRootReplica(o_pbstrServerName, o_pbstrShareName);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  _FreeMemberVariables


void CDfsRoot :: _FreeMemberVariables
(
)
{
    m_bstrDfsName.Empty();
    m_bstrDomainName.Empty();
    m_bstrDomainGuid.Empty();
    m_bstrDomainDN.Empty();

    m_lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER;
    m_bstrEnumFilter.Empty();

    FreeJunctionNames(&m_JunctionPoints);

    if (m_pDfsJP)
    {
        m_pDfsJP->Release();
        m_pDfsJP = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get__NewEnum


STDMETHODIMP CDfsRoot :: get__NewEnum
(
    LPUNKNOWN*        pVal
)
{
/*++

Routine Description:
  
  Returns a new enumerator interface (IEnumVARIANT) to enumerate Junction points.
  This depends upon the EnumFilter value.

Arguments:

  pVal - Pointer to a Variant in which the enumerator will be returned.

--*/

    if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

                //Create a Junction point enumerator and initialize it with
                //the internal list.    
    CComObject<CJunctionPointEnum> *pJunctionPointEnum = new CComObject<CJunctionPointEnum>();
    if (!pJunctionPointEnum)
        return E_OUTOFMEMORY;

    HRESULT hr = pJunctionPointEnum->Initialize(&m_JunctionPoints, m_lLinkFilterType, m_bstrEnumFilter, (ULONG*)&m_lCountOfDfsJunctionPointsFiltered);
    if (SUCCEEDED(hr))
        hr = pJunctionPointEnum->QueryInterface(IID_IEnumVARIANT, (void **)pVal);

    if (FAILED(hr))
        delete pJunctionPointEnum;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_RootReplicaEnum


STDMETHODIMP CDfsRoot :: get_RootReplicaEnum
(
    LPUNKNOWN*        pVal
)
{
/*++

Routine Description:
  
  Call the inner junction point to return a new enumerator interface (IEnumVARIANT) 
  to enumerate root replicas.

Arguments:

  pVal - Pointer to a Variant in which the enumerator will be returned.

--*/

    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get__NewEnum(pVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  GetRootJP


STDMETHODIMP CDfsRoot :: GetRootJP
(
    VARIANT*        o_pIDfsJunctionPoint
)
{
    RETURN_INVALIDARG_IF_NULL(o_pIDfsJunctionPoint);
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    m_pDfsJP->AddRef();

    o_pIDfsJunctionPoint->vt = VT_DISPATCH;
    o_pIDfsJunctionPoint->pdispVal = m_pDfsJP;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_RootEntryPath


STDMETHODIMP CDfsRoot :: get_RootEntryPath
(
    BSTR*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_EntryPath(pVal);
}


/////////////////////////////////////////////////////////////////////////////////////////////////
//  Comment

STDMETHODIMP CDfsRoot :: get_Comment(BSTR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_Comment(pVal);
}

STDMETHODIMP CDfsRoot :: put_Comment(BSTR newVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->put_Comment(newVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  Timeout

STDMETHODIMP CDfsRoot::get_Timeout(long *pVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_Timeout(pVal);
}

STDMETHODIMP CDfsRoot::put_Timeout(long newVal)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->put_Timeout(newVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteAllJunctionPoints

HRESULT CDfsRoot :: DeleteAllJunctionPoints()
{
/*++

Routine Description:
  
  Deletes all Junction junction points.

--*/

    HRESULT hr = S_OK;

    for (JUNCTIONNAMELIST::iterator i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        hr = DeleteJunctionPoint((*i)->m_bstrJPName);
        BREAK_IF_FAILED(hr);
    }

    return hr;
}

//
//  gets/puts the type of Enumerator Filter.
//
STDMETHODIMP CDfsRoot::get_EnumFilterType
(
    long*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = m_lLinkFilterType;

    return S_OK;
}

STDMETHODIMP CDfsRoot::put_EnumFilterType
(
    long          newVal
)
{
    m_lLinkFilterType = (FILTERDFSLINKS_TYPE)newVal;

    return S_OK;
}

//
// gets/puts the Enumerator Filter
//
STDMETHODIMP CDfsRoot::get_EnumFilter
(
    BSTR*          pVal
)
{
    if (!pVal)
        return E_INVALIDARG;

    *pVal = NULL;

    if ((BSTR)m_bstrEnumFilter)
    {
        *pVal = m_bstrEnumFilter.Copy ();
        if (!*pVal)
            return E_OUTOFMEMORY;
    }

    return S_OK;
}

STDMETHODIMP CDfsRoot::put_EnumFilter
(
    BSTR          newVal
)
{
    // we require newVal points to a non-empty string
    if (!newVal || !*newVal)
        return E_INVALIDARG;

    m_bstrEnumFilter = newVal;
    if (!m_bstrEnumFilter)
        return E_OUTOFMEMORY;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  get_CountOfDfsRootReplicas

STDMETHODIMP CDfsRoot :: get_CountOfDfsRootReplicas
(
    long*          pVal
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);
    return m_pDfsJP->get_CountOfDfsReplicas(pVal);
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  IsJPExisted

STDMETHODIMP CDfsRoot :: IsJPExisted
(
    BSTR    i_bstrJPName
)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrJPName);

    for (JUNCTIONNAMELIST::iterator i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        if (!lstrcmpi((*i)->m_bstrJPName, i_bstrJPName))
            return S_OK;
    }

    return S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  RefreshRootReplicas: used to pick up new Dfs hosts

STDMETHODIMP CDfsRoot :: RefreshRootReplicas
(
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    CComBSTR bstrEntryPath;
    HRESULT hr = m_pDfsJP->get_EntryPath(&bstrEntryPath);
    RETURN_IF_FAILED(hr);

    BOOL bReplicaSetExist = FALSE;
    hr = m_pDfsJP->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrReplicaSetDN;
    hr = m_pDfsJP->get_ReplicaSetDN(&bstrReplicaSetDN);
    RETURN_IF_FAILED(hr);

    hr = m_pDfsJP->Initialize((IUnknown *)this, bstrEntryPath, bReplicaSetExist, bstrReplicaSetDN);

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  DeleteAllReplicaSets: delete all replica sets related to this Dfs root

STDMETHODIMP CDfsRoot :: DeleteAllReplicaSets
(
)
{
    RETURN_INVALIDARG_IF_NULL(m_pDfsJP);

    if (m_dwDfsType != DFS_TYPE_FTDFS)
        return S_OK;

    //
    // delete replica sets associated with this Dfs root
    //
    HRESULT hr = S_OK;
    BOOL bReplicaSetExist = FALSE;
    JUNCTIONNAMELIST::iterator  i;
    for (i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
    {
        bReplicaSetExist = FALSE;
        (void)(*i)->m_piDfsJunctionPoint->get_ReplicaSetExist(&bReplicaSetExist);

        if (bReplicaSetExist)
        {
            CComBSTR bstrReplicaSetDN;
            hr = (*i)->m_piDfsJunctionPoint->get_ReplicaSetDN(&bstrReplicaSetDN);
            BREAK_IF_FAILED(hr);

            CComPtr<IReplicaSet> piReplicaSet;
            hr = CoCreateInstance(CLSID_ReplicaSet, NULL, CLSCTX_INPROC_SERVER, IID_IReplicaSet, (void**)&piReplicaSet);
            BREAK_IF_FAILED(hr);

            hr = piReplicaSet->Initialize(m_bstrDomainName, bstrReplicaSetDN);
            if (SUCCEEDED(hr))
                piReplicaSet->Delete();
        }
    }
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  FreeJunctionNames


void FreeJunctionNames (JUNCTIONNAMELIST* pJPList)
{
    if (NULL == pJPList)
        return;

    if (!pJPList->empty())
    {
        for (JUNCTIONNAMELIST::iterator i = pJPList->begin(); i != pJPList->end(); i++)
        {
            delete (*i);
        }

        pJPList->clear();
    }
    _ASSERT(pJPList->empty());
}


/////////////////////////////////////////////////////////////////////////////////////////////////


void FreeReplicas(REPLICAINFOLIST* pRepList)
{
    if (NULL == pRepList)
        return;

    if (!pRepList->empty())
    {
        for (REPLICAINFOLIST::iterator i = pRepList->begin(); i != pRepList->end(); i++)
        {
            delete (*i);
        }

        pRepList->clear();
    }
    _ASSERT(pRepList->empty());
}

HRESULT CDfsRoot::_AddToJPList(
    PDFS_INFO_3 pDfsInfo,
    BOOL        bReplicaSetExist,
    BSTR        bstrReplicaSetDN)
{
    HRESULT hr = S_OK;

    CComPtr<IDfsJunctionPoint> piDfsJunctionPoint;
    hr = CoCreateInstance(CLSID_DfsJunctionPoint, NULL, CLSCTX_INPROC_SERVER,
        IID_IDfsJunctionPoint, (void **)&piDfsJunctionPoint);
    RETURN_IF_FAILED(hr);

    CComVariant varData;
    hr = DfsInfo3ToVariant(pDfsInfo, &varData);
    RETURN_IF_FAILED(hr);

    hr = piDfsJunctionPoint->InitializeEx((IUnknown *)this, &varData, bReplicaSetExist, bstrReplicaSetDN);
    RETURN_IF_FAILED(hr);

    return _AddToJPListEx(piDfsJunctionPoint);
}

HRESULT CDfsRoot::_AddToJPListEx(
    IDfsJunctionPoint * piDfsJunctionPoint,
    BOOL                bSort)
{
    JUNCTIONNAME*   pDfsJP = new JUNCTIONNAME;
    RETURN_OUTOFMEMORY_IF_NULL(pDfsJP);

    HRESULT hr = pDfsJP->Init(piDfsJunctionPoint);
    if (FAILED(hr))
    {
        delete pDfsJP;
        return hr;
    }

    if (bSort)
    {
        JUNCTIONNAMELIST::iterator i;
        for (i = m_JunctionPoints.begin(); i != m_JunctionPoints.end(); i++)
        {
            if (lstrcmpi(pDfsJP->m_bstrJPName, (*i)->m_bstrJPName) < 0)
                break;
        }
        m_JunctionPoints.insert(i, pDfsJP);
    } else
    {
        m_JunctionPoints.push_back(pDfsJP);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfsroot.h ===
/*++
Module Name:
    DfsRoot.h

Abstract:

    This module contains the declaration of the CDfsRoot COM Class. This class
    provides methods to get information of a junction point and to enumerate 
    junction points.It implements IDfsRoot and provides
    an enumerator through get__NewEnum().
--*/


#ifndef __DFSROOT_H_
#define __DFSROOT_H_

#include "resource.h"       // main symbols
#include "dfsenums.h"
#include "dfsjp.h"
#include "netutils.h"

#include <list>
#include <map>
using namespace std;

                        // Helper Structures
                        // To store list of junction point info
class JUNCTIONNAME
{
public:
    CComPtr<IDfsJunctionPoint>  m_piDfsJunctionPoint;
    CComBSTR                    m_bstrEntryPath;
    CComBSTR                    m_bstrJPName;

    HRESULT Init(IDfsJunctionPoint *i_piDfsJunctionPoint)
    {
        ReSet();

        RETURN_INVALIDARG_IF_TRUE(!i_piDfsJunctionPoint);

        m_piDfsJunctionPoint = i_piDfsJunctionPoint;

        HRESULT hr = S_OK;
        do {
            hr = m_piDfsJunctionPoint->get_EntryPath(&m_bstrEntryPath);
            BREAK_IF_FAILED(hr);
            hr = GetUNCPathComponent(m_bstrEntryPath, &m_bstrJPName, 4, 0);
            BREAK_IF_FAILED(hr);
        } while (0);

        if (FAILED(hr))
            ReSet();

        return S_OK;
    }

    void ReSet()
    {
        m_piDfsJunctionPoint = NULL;
        m_bstrEntryPath.Empty();
        m_bstrJPName.Empty();
    }

    JUNCTIONNAME* Copy()
    {
        JUNCTIONNAME* pNew = new JUNCTIONNAME;
        
        if (pNew)
        {
            HRESULT hr = pNew->Init(m_piDfsJunctionPoint);

            if (FAILED(hr))
            {
                delete pNew;
                pNew = NULL;
            }
        }

        return pNew;
    }
};

typedef list<JUNCTIONNAME*>        JUNCTIONNAMELIST;

void FreeJunctionNames (JUNCTIONNAMELIST* pJPList);    // To free the list of junction point names.
void FreeReplicas (REPLICAINFOLIST* pRepList);        // To free the list of junction point names.

struct strmapcmpfn
{
   bool operator()(PTSTR p1, PTSTR p2) const
   {
       return lstrcmpi(p1, p2) < 0;
   }
};

typedef map<PTSTR, PTSTR, strmapcmpfn> StringMap;

class ATL_NO_VTABLE CDfsRoot : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsRoot, &CLSID_DfsRoot>,
    public IDispatchImpl<IDfsRoot, &IID_IDfsRoot, &LIBID_DFSCORELib>
{
public:
    CDfsRoot();

    ~CDfsRoot ();
    
DECLARE_REGISTRY_RESOURCEID(IDR_DFSROOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDfsRoot)
    COM_INTERFACE_ENTRY(IDfsRoot)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDfsRoot
                                                            // This is a string values which determines
                                                            // what get__NewEnum() will enumerate.
    STDMETHOD(get_EnumFilterType)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(put_EnumFilterType)
    (
        /*[in]*/ long newVal
    );
                                                            // Intializes the newly created object 
    STDMETHOD(get_EnumFilter)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(put_EnumFilter)
    (
        /*[in]*/ BSTR newVal
    );
                                                            // Intializes the newly created object 
    STDMETHOD(Initialize)                                    // and previously initialised DfsRoot object. 
    (
        BSTR i_szDfsName                                    // Dfs Name (i.e \\domain\ftdfs, \\server\share)
                                                            // or Server name hosting Dfs.
    );

    STDMETHOD(get_CountOfDfsJunctionPoints)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_CountOfDfsJunctionPointsFiltered)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_CountOfDfsRootReplicas)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_DfsName)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_State)
    (
        /*[out, retval]*/ long *pVal
    );
    
    STDMETHOD(get_DfsType)
    (
        /*[out, retval]*/ long *pVal
    );

    STDMETHOD(get_DomainName)
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
    STDMETHOD(get_DomainGuid)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_DomainDN)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_ReplicaSetDN)
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_ReplicaSetExist)
    (
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(get_ReplicaSetExistEx)
    (
        /*[out]*/ BSTR* o_pbstrDC,
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(put_ReplicaSetExist)
    (
        /*[in]*/ BOOL newVal
    );

    STDMETHOD(get__NewEnum)
    (
        /*[out, retval]*/ LPUNKNOWN *pVal
    );

    STDMETHOD(get_RootReplicaEnum)
    (
        /*[out, retval]*/ LPUNKNOWN *pVal
    );

    STDMETHOD(get_RootEntryPath)                // Returns the root entry path
    (
        /*[out, retval]*/ BSTR *pVal
    );
                                                // Get the DfsRoot Comment
    STDMETHOD(get_Comment)
    (
        /*[out, retval]*/ BSTR*    o_pbstrComment
    );

    STDMETHOD(put_Comment)
    (
        /*[in]*/ BSTR    i_bstrComment
    );

    
    STDMETHOD(get_Timeout)
    (
        /*[out, retval]*/ long *pVal
    );
    
    STDMETHOD(put_Timeout)
    (
        /*[in]*/ long newVal
    );

    STDMETHOD( DeleteJunctionPoint )
    (
        /*[in]*/ BSTR i_szEntryPath
    );

    STDMETHOD( CreateJunctionPoint )
    (
        /*[in]*/    BSTR i_szJPName,
        /*[in]*/    BSTR i_szServerName,
        /*[in]*/    BSTR i_szShareName,
        /*[in]*/    BSTR i_szComment,
        /*[in]*/    long i_lTimeout,
        /*[out]*/   VARIANT *o_pIDfsJunctionPoint
    );

    STDMETHOD( DeleteDfsHost )
    (
        /*[in]*/ BSTR i_bstrServerName,
        /*[in]*/ BSTR i_bstrShareName,
        /*[in]*/ BOOL i_bForce
    );

    STDMETHOD( GetOneDfsHost )
    (
        /*[out]*/ BSTR* o_pbstrServerName,
        /*[out]*/ BSTR* o_pbstrShareName
    );

    STDMETHOD( IsJPExisted )
    (
        /*[in]*/  BSTR i_bstrJPName
    );

    STDMETHOD( RefreshRootReplicas )
    (
    );

    STDMETHOD( GetRootJP )
    (
        /*[out]*/   VARIANT *o_pIDfsJunctionPoint
    );

    STDMETHOD( DeleteAllReplicaSets )
    (
    );

//Protected Member Functions
protected:
    void _FreeMemberVariables ();           //Member function to free internal string variables.
    
    HRESULT _GetDfsName                  // set m_bstrDfsName
    (
        BSTR i_szRootEntryPath
    );

    HRESULT _Init(
        PDFS_INFO_3 pDfsInfo,
        StringMap*  pMap
        );

    HRESULT _AddToJPList(
        PDFS_INFO_3 pDfsInfo,
        BOOL        bReplicaSetExist,
        BSTR        bstrReplicaSetDN
        );

    HRESULT _AddToJPListEx(
        IDfsJunctionPoint * piDfsJunctionPoint,
        BOOL                bSort = FALSE
        );

    HRESULT _GetAllReplicaSets(
        OUT StringMap*  pMap
    );

    HRESULT RemoveAllReplicas               // Removes all the Replicas for a Junction Point
    (
            IDfsJunctionPoint*        i_JPObject
    );


    HRESULT DeleteAllJunctionPoints();      // Deletes all the Junction Points.


//Protected Member Variables
protected:
    IDfsJunctionPoint*  m_pDfsJP;               // pointer to the inner object

    // To Store Properties

    CComBSTR            m_bstrDfsName;
    CComBSTR            m_bstrDomainName;
    CComBSTR            m_bstrDomainGuid;
    CComBSTR            m_bstrDomainDN;
    FILTERDFSLINKS_TYPE m_lLinkFilterType;
    CComBSTR            m_bstrEnumFilter;
    DFS_TYPE            m_dwDfsType;
    JUNCTIONNAMELIST    m_JunctionPoints;
    long                m_lCountOfDfsJunctionPointsFiltered;
};


#endif //__DFSROOT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\jpenum.cpp ===
/*++
Module Name:

    JPEnum.cpp

Abstract:

   This file contains the Implementation of the Class CJunctionPointEnum.
   This class implements IEnumVARIANT for DfsJunctionPoint enumeration.
--*/


#include "stdafx.h"
#include "DfsCore.h"
#include "DfsJP.h"
#include "JPEnum.h"


/////////////////////////////////////////////////////////////////////////////
// ~CJunctionPointEnum


CJunctionPointEnum :: ~CJunctionPointEnum ()
{
    _FreeMemberVariables();
}


/////////////////////////////////////////////////////////////////////////////
// Initialize


STDMETHODIMP CJunctionPointEnum :: Initialize
(
  JUNCTIONNAMELIST* i_pjiList,      // Pointer to the list of junction points.
  FILTERDFSLINKS_TYPE i_lLinkFilterType,
  BSTR              i_bstrEnumFilter, // Filtering string expresseion
  ULONG*            o_pulCount       // count of links that matches the filter 
)
{
/*++

Routine Description:

  Initializes the JunctionPointEnum object.
  It copies the JunctionPoint list passed to it by the junction point
  object.

Arguments:

  i_pjiList    -  Pointer to the list of junction points.
  i_lLinkFilterType  - The type of link filtering.
  i_bstrEnumFilter  - The string expression to do prefix filtering.
  o_pulCount - to hold the count of links that matches the specified filter.

--*/

    if (!i_pjiList)
        return E_INVALIDARG;

    if (i_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER &&
        (!i_bstrEnumFilter || !*i_bstrEnumFilter))
        return E_INVALIDARG;

    if (o_pulCount)
        *o_pulCount = 0;

    HRESULT                     hr = S_OK;
    JUNCTIONNAMELIST::iterator  i;
    JUNCTIONNAMELIST::iterator  j;

    for (i = i_pjiList->begin(); i != i_pjiList->end(); i++)
    {                   // Copy filtered junctions to its own internal list
        if (i_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
        {
            if ( !FilterMatch((*i)->m_bstrJPName, i_lLinkFilterType, i_bstrEnumFilter) )
                continue;
        }

        JUNCTIONNAME*  pTemp = (*i)->Copy();
        BREAK_OUTOFMEMORY_IF_NULL(pTemp, &hr);

        m_JunctionPoints.push_back(pTemp);
    }

    if (SUCCEEDED(hr))
    {
        m_iCurrentInEnumOfJunctionPoints = m_JunctionPoints.begin();
        if (o_pulCount)
            *o_pulCount = m_JunctionPoints.size();
    } else
        _FreeMemberVariables();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IEnumVariant Methods


/////////////////////////////////////////////////////////////////////////////
// Next


STDMETHODIMP CJunctionPointEnum::Next
(
  ULONG     i_ulNumOfJunctionPoints,        //To fetch.
  VARIANT*  o_pIJunctionPointArray,         //Array to fetch into.
  ULONG*    o_ulNumOfJunctionPointsFetched  //The number of values fetched, (Arg can be NULL)
)
{
/*++

Routine Description:

  Gets the next object in the list.

Arguments:

  i_ulNumOfJunctionPoints      - the number of objects to return
  o_pIJunctionPointArray      - an array of variants in which to return the objects
  o_ulNumOfJunctionPointsFetched  - the number of objects that are actually returned

Return value:

  S_OK, On success
  S_FALSE if the end of the list has been reached
--*/

    if (!o_pIJunctionPointArray || !i_ulNumOfJunctionPoints)
        return E_INVALIDARG;

    HRESULT       hr = S_OK;
    ULONG         nCount = 0;

    for (nCount = 0; 
        nCount < i_ulNumOfJunctionPoints && m_iCurrentInEnumOfJunctionPoints != m_JunctionPoints.end();
        m_iCurrentInEnumOfJunctionPoints++)
    {
        IDfsJunctionPoint *pIJunctionPointPtr = (*m_iCurrentInEnumOfJunctionPoints)->m_piDfsJunctionPoint;
        pIJunctionPointPtr->AddRef();

        o_pIJunctionPointArray[nCount].vt = VT_DISPATCH;
        o_pIJunctionPointArray[nCount].pdispVal = pIJunctionPointPtr;

        nCount++;
    }

    if (o_ulNumOfJunctionPointsFetched)
        *o_ulNumOfJunctionPointsFetched = nCount;

    if (SUCCEEDED(hr) && !nCount)
        return S_FALSE;
    else
        return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Skip


STDMETHODIMP CJunctionPointEnum :: Skip
(
    unsigned long i_ulJunctionPointsToSkip    //Items to skip
)
{
/*++

Routine Description:

  Skips the next 'n' objects in the list.

Arguments:

  i_ulJunctionPointsToSkip - the number of objects to skip over

Return value:

    S_OK, On success
  S_FALSE, if the end of the list is reached

--*/

    for (unsigned int j = 0; j < i_ulJunctionPointsToSkip && 
        m_iCurrentInEnumOfJunctionPoints != m_JunctionPoints.end(); j++)
    {
        m_iCurrentInEnumOfJunctionPoints++;
    }

    return (m_iCurrentInEnumOfJunctionPoints != m_JunctionPoints.end()) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Reset


STDMETHODIMP CJunctionPointEnum :: Reset()
{
/*++

Routine Description:

  Resets the current enumeration pointer to the start of the list

--*/

    m_iCurrentInEnumOfJunctionPoints = m_JunctionPoints.begin();
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Clone


STDMETHODIMP CJunctionPointEnum :: Clone
(
    IEnumVARIANT FAR* FAR* ppenum
)
{
/*++

Routine Description:

  Creates a clone of the enumerator object

Arguments:

  ppenum  -  address of the pointer to the IEnumVARIANT interface 
        of the newly created enumerator object

Notes:

  This has not been implemented.
--*/

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\dfsjp.h ===
/*++
Module Name:
    DfsJP.h

Abstract:
    This module contains the declaration of the DfsJunctionPoint COM Class. This class
    provides methods to get information of a junction point and to enumerate 
    Replicas of the junction point. It implements IDfsJunctionPoint and provides
    an enumerator through get__NewEnum().
--*/


#ifndef _DFSJP_H
#define _DFSJP_H


#include "resource.h"                                                // main symbols
#include "dfsenums.h"

#include <list>
using namespace std;

#define ARRAY_COUNT_FOR_DFS_INFO_3          2
#define ARRAY_COUNT_FOR_DFS_STORAGE_INFO    3

class REPLICAINFO
{
public:
    CComBSTR m_bstrServerName;
    CComBSTR m_bstrShareName;
    long     m_lDfsStorageState;

    HRESULT Init(BSTR bstrServerName, BSTR bstrShareName, long lDfsStorageState)
    {
        ReSet();

        RETURN_INVALIDARG_IF_TRUE(!bstrServerName);
        RETURN_INVALIDARG_IF_TRUE(!bstrShareName);

        HRESULT hr = S_OK;
        do {
            m_bstrServerName = bstrServerName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServerName, &hr);
            m_bstrShareName = bstrShareName;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrShareName, &hr);
            m_lDfsStorageState = lDfsStorageState;
        } while (0);

        if (FAILED(hr))
            ReSet();

        return hr;
    }

    void ReSet()
    {
        if (m_bstrServerName)    m_bstrServerName.Empty();
        if (m_bstrShareName)     m_bstrShareName.Empty();
        m_lDfsStorageState = DFS_STORAGE_STATE_OFFLINE;
    }

    REPLICAINFO* Copy()
    {
        REPLICAINFO* pNew = new REPLICAINFO;
        
        if (pNew)
        {
            HRESULT hr = S_OK;
            do {
                pNew->m_bstrServerName = m_bstrServerName;
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrServerName, &hr);

                pNew->m_bstrShareName = m_bstrShareName;
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrShareName, &hr);

                pNew->m_lDfsStorageState = m_lDfsStorageState;
            } while (0);

            if (FAILED(hr))
            {
                delete pNew;
                pNew = NULL;
            }
        }

        return pNew;
    }
};

typedef list<REPLICAINFO*>        REPLICAINFOLIST;

class ATL_NO_VTABLE CDfsJunctionPoint : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsJunctionPoint, &CLSID_DfsJunctionPoint>,
    public IDispatchImpl<IDfsJunctionPoint, &IID_IDfsJunctionPoint, &LIBID_DFSCORELib>
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DFSJP)

BEGIN_COM_MAP(CDfsJunctionPoint)
    COM_INTERFACE_ENTRY(IDfsJunctionPoint)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDfsJunctionPoint
public:
    //Contructor.
    CDfsJunctionPoint();

    //Destructor.
    ~CDfsJunctionPoint();

                                                            // Returns a DfsReplica Enumerator.
    STDMETHOD(get__NewEnum)
    (
        /*[out, retval]*/ 
        LPUNKNOWN *pVal                                        // The IEnumVARIANT Pointer is returned in this.
    );

                                                            // Returns the number of replicas for 
    STDMETHOD(get_CountOfDfsReplicas)                        // this Junction Point
    (
        /*[out, retval]*/ long *pVal                        // The number of replicas.
    );

                                                            // Intialises a DfsJunctionPoint COM 
    STDMETHOD(Initialize)                                    // Object. Should be called after CoCreateInstance.
    (
        /*[in]*/ IUnknown *i_piDfsRoot,
        /*[in]*/ BSTR i_szEntryPath,                        // The junction point Dfs Path. Eg. "//DOM/Dfs/JP".
        /*[in]*/ BOOL i_bReplicaSetExist,
        /*[in]*/ BSTR i_bstrReplicaSetDN
    );
    
                                                             // Gets the comment associated with 
    STDMETHOD(get_Comment)                                    // the Junctionpoint.
    (
        /*[out, retval]*/ BSTR *pVal                        // The Comment.
    );
    
                                                            // Sets the comment. Sets in memory as 
    STDMETHOD(put_Comment)                                    // well in the network PKT.
    (
        /*[in]*/ BSTR newVal
    );
    
                                                            // Gets the Junction Name. Justs gets 
                                                            // the last part of the entry path.
    STDMETHOD(get_JunctionName)                                // E.g "usa\Products" for "\\DOM\Dfs\usa\Products".
    (
        /*[in]*/ BOOL i_bDfsNameIncluded,
        /*[out, retval]*/ BSTR *pVal                        // The junction name.
    );

                                                            // Gets the entry path of the junction 
    STDMETHOD(get_EntryPath)                                // point. Eg. "\\Dom\Dfs\usa\Products".
    (
        /*[out, retval]*/ BSTR *pVal
    );
    
                                                            // Get Dfs JuncitonPoint State.
    STDMETHOD(get_State)
    (
        /*[out, retval]*/ long *pVal                        // The state of the junction point.
    );

    STDMETHOD(get_ReplicaSetDN)                             // get the prefix DN of the corresponding replica set.
    (
        /*[out, retval]*/ BSTR *pVal
    );

    STDMETHOD(get_ReplicaSetExist)
    (
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(get_ReplicaSetExistEx)
    (
        /*[out]*/ BSTR* o_pbstrDC,
        /*[out, retval]*/ BOOL *pVal
    );

    STDMETHOD(put_ReplicaSetExist)
    (
        /*[in]*/ BOOL newVal
    );

    STDMETHOD( AddReplica )                                    // Adds a new replica to the junction point.
    (
        /* [in]*/ BSTR i_szServerName,
        /* [in]*/ BSTR i_szShareName,
        /* [out, retval]*/ VARIANT* o_pvarReplicaObject
    );

    STDMETHOD( RemoveReplica )                                // Removes a Replica from the Junction Point.
    (
        /* [in]*/ BSTR i_szServerName,
        /* [in]*/ BSTR i_szShareName
    );

    STDMETHOD( RemoveAllReplicas )                                // Delete the Junction Point.
    (
    );

    STDMETHOD( get_Timeout )
    (
        /*[out, retval]*/    long*        pVal
    );
                                                            // Sets the time out for the junction point.
    STDMETHOD( put_Timeout )
    (
        /*[in]*/    long        newVal
    );

    STDMETHOD( DeleteRootReplica )
    (
        /*[in]*/ BSTR i_bstrDomainName,
        /*[in]*/ BSTR i_bstrDfsName,
        /*[in]*/ BSTR i_bstrServerName,
        /*[in]*/ BSTR i_bstrShareName,
        /*[in]*/ BOOL i_bForce
    );

    STDMETHOD( GetOneRootReplica )
    (
        /*[out]*/ BSTR* o_pbstrServerName,
        /*[out]*/ BSTR* o_pbstrShareName
    );

    STDMETHOD(InitializeEx)
    (
        /*[in]*/ IUnknown   *piDfsRoot,
        /*[in]*/ VARIANT    *pVar,
        /*[in]*/ BOOL       bReplicaSetExist,
        /*[in]*/ BSTR       bstrReplicaSetDN
    );
    
protected:
    //Member Variables
    CComPtr<IDfsRoot> m_spiDfsRoot;
    CComBSTR        m_bstrEntryPath;
    CComBSTR        m_bstrJunctionName;   // given \\ntbuilds\release\dir1\dir2, it's dir1\dir2
    CComBSTR        m_bstrJunctionNameEx; // given \\ntbuilds\release\dir1\dir2, it's release\dir1\dir2
    CComBSTR        m_bstrReplicaSetDN;
    BOOL            m_bReplicaSetExist;
    REPLICAINFOLIST m_Replicas;                            // List of Replicas.

protected:
    //Helper Functions
    void _FreeMemberVariables();

    HRESULT _GetReplicaSetDN
    (
        BSTR i_szEntryPath
    );
    
    HRESULT _GetDfsType(
        OUT DFS_TYPE* o_pdwDfsType,
        OUT BSTR*     o_pbstrDomainName,
        OUT BSTR*     o_pbstrDomainDN
    );

    HRESULT _Init(
        PDFS_INFO_3 pDfsInfo,
        BOOL        bReplicaSetExist,
        BSTR        bstrReplicaSetDN
        );

    HRESULT _AddToReplicaList
    (
        BSTR bstrServerName,
        BSTR bstrShareName,
        long lDfsStorageState
    );

    void _DeleteFromReplicaList(BSTR bstrServerName, BSTR bstrShareName);

    HRESULT _GetDfsStorageState
    (
        BSTR        i_szServerName,
        BSTR        i_szShareName,
        long*       o_pVal
    );
};

#endif //_DFSJP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\jpenum.h ===
/*++

Module Name:

    JPENum.h

Abstract:

     This file contains the Declaration of the CJunctionPointEnum Class.
     This class implements IEnumVARIANT for DfsJunctionPoint enumeration.

--*/


#ifndef __JPENUM_H_
#define __JPENUM_H_

#include "resource.h"       // main symbols
#include "DfsRoot.h"

class ATL_NO_VTABLE CJunctionPointEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CJunctionPointEnum, &CLSID_JunctionPointEnum>,
    public IEnumVARIANT
{
public:
    CJunctionPointEnum()
    {
    }

    ~CJunctionPointEnum();

// DECLARE_REGISTRY_RESOURCEID(IDR_JPENUM)

BEGIN_COM_MAP(CJunctionPointEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

public:
                                                                // Call this to initialise.
    STDMETHOD( Initialize )
    (
        JUNCTIONNAMELIST*   i_pjiList,
        FILTERDFSLINKS_TYPE i_lLinkFilterType,
        BSTR                i_bstrEnumFilter, // Filtering string expresseion
        ULONG*              o_pulCount = NULL // count of links that matches the filter 
    );

// IEnumVariant
public:
                                                                //Get next Junction point
    STDMETHOD(Next)
    (
        ULONG i_ulNumOfJunctionPoints, 
        VARIANT * o_pIJunctionPointArray, 
        ULONG * o_ulNumOfJunctionPointsFetched
    );

                                                                //Skip  junction points
    STDMETHOD(Skip)
    (
        unsigned long i_ulJunctionPointsToSkip
    );

                                                                //Reset enumeration.
    STDMETHOD(Reset)();

                                                                //Clone a Enumerator.
    STDMETHOD(Clone)
    (
        IEnumVARIANT FAR* FAR* ppenum
    );

protected:
    void _FreeMemberVariables() {
        FreeJunctionNames(&m_JunctionPoints);
    }
    JUNCTIONNAMELIST::iterator  m_iCurrentInEnumOfJunctionPoints;   // Current pointer.
    JUNCTIONNAMELIST            m_JunctionPoints;                   // Stores the list of junction point entry path.
};

#endif //__JPENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DfsCore.rc
//
#define IDS_PROJNAME                    100
#define IDR_DFSROOT                     101
#define IDR_DFSJP                       102
#define IDR_DFSREP                      103
#define IDR_REPLICASET                  104
#define IDS_UNKNOWN_SITE                201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\repset.h ===
/*++
Module Name:
    RepSet.h

Abstract:

--*/


#ifndef __REPSET_H_
#define __REPSET_H_

#include "resource.h"       // main symbols
#include "dfsenums.h"
#include "netutils.h"
#include "ldaputils.h"

#include <list>
using namespace std;

class CFrsMember;

class CDfsAlternate
{
public:
    CComBSTR                    m_bstrServer;
    CComBSTR                    m_bstrShare;
    CFrsMember*                 m_pFrsMember;
};

class CFrsMember
{
public:
    CComBSTR                    m_bstrServer;
    CComBSTR                    m_bstrSite;
    CComBSTR                    m_bstrDomain;
    CComBSTR                    m_bstrServerGuid;

    CComBSTR                    m_bstrRootPath;
    CComBSTR                    m_bstrStagingPath;

    CComBSTR                    m_bstrMemberDN;
    CComBSTR                    m_bstrComputerDN;
    CComBSTR                    m_bstrSubscriberDN;

public:
    //
    // InitEx does query DS to retrieve related info
    //
    HRESULT InitEx(
        PLDAP   i_pldap,                // points to the i_bstrMemberDN's DS
        BSTR    i_bstrDC,               // domain controller pointed by i_pldap
        BSTR    i_bstrMemberDN,         // FQDN of nTFRSMember object
        BSTR    i_bstrComputerDN = NULL // FQDN of computer object
    );

    //
    // Init does NOT query DS
    //
    HRESULT Init(
        IN BSTR i_bstrDnsHostName,
        IN BSTR i_bstrComputerDomain,
        IN BSTR i_bstrComputerGuid,
        IN BSTR i_bstrRootPath,
        IN BSTR i_bstrStagingPath,
        IN BSTR i_bstrMemberDN,
        IN BSTR i_bstrComputerDN,
        IN BSTR i_bstrSubscriberDN
        );

    CFrsMember* Copy();

private:
    void _ReSet();

    HRESULT _GetMemberInfo(
        PLDAP   i_pldap,                // points to the i_bstrMemberDN's DS
        BSTR    i_bstrDC,               // domain controller pointed by i_pldap
        BSTR    i_bstrMemberDN,         // FQDN of nTFRSMember object
        BSTR    i_bstrComputerDN = NULL // FQDN of computer object
    );

    HRESULT _GetSubscriberInfo
    (
        PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
        BSTR    i_bstrComputerDN,   // FQDN of the computer object
        BSTR    i_bstrMemberDN      // FQDN of the corresponding nTFRSMember object
    );

    HRESULT _GetComputerInfo
    (
        PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
        BSTR    i_bstrComputerDN    // FQDN of the computer object
    );

};

class CFrsConnection
{
public:
    CComBSTR                    m_bstrConnectionDN;
    CComBSTR                    m_bstrFromMemberDN;
    CComBSTR                    m_bstrToMemberDN;
    BOOL                        m_bEnable;
    DWORD                       m_dwOptions;

    //
    // Init Does NOT query DS
    //
    HRESULT Init(
        BSTR i_bstrConnectionDN,
        BSTR i_bstrFromMemberDN,
        BOOL i_bEnable,
        DWORD i_dwOptions
        );

    CFrsConnection* Copy();

protected:
    void _ReSet();

};

typedef list<CDfsAlternate *>    CDfsAlternateList;
typedef list<CFrsMember *>       CFrsMemberList;
typedef list<CFrsConnection *>   CFrsConnectionList;

void FreeDfsAlternates(CDfsAlternateList* pList);
void FreeFrsMembers(CFrsMemberList* pList);
void FreeFrsConnections(CFrsConnectionList* pList);

class ATL_NO_VTABLE CReplicaSet : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CReplicaSet, &CLSID_ReplicaSet>,
    public IDispatchImpl<IReplicaSet, &IID_IReplicaSet, &LIBID_DFSCORELib>
{
public:
    CReplicaSet();

    ~CReplicaSet();
    
DECLARE_REGISTRY_RESOURCEID(IDR_REPLICASET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CReplicaSet)
    COM_INTERFACE_ENTRY(IReplicaSet)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IReplicaSet
    STDMETHOD(get_Type)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_Type)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_TopologyPref)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_TopologyPref)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_HubMemberDN)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_HubMemberDN)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_PrimaryMemberDN)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_PrimaryMemberDN)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_FileFilter)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_FileFilter)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_DirFilter)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(put_DirFilter)( 
        /* [in] */ BSTR newVal);

    STDMETHOD(get_DfsEntryPath)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(get_Domain)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(get_ReplicaSetDN)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(get_NumOfMembers)( 
        /* [retval][out] */ long __RPC_FAR *pVal);

    STDMETHOD(get_NumOfConnections)( 
        /* [retval][out] */ long __RPC_FAR *pVal);

    STDMETHOD(get_TargetedDC)( 
        /* [retval][out] */ BSTR __RPC_FAR *pVal);

    STDMETHOD(Create)(
		/* [in] */ BSTR i_bstrDomain,
        /* [in] */ BSTR i_bstrReplicaSetDN,
        /* [in] */ BSTR i_bstrType,
		/* [in] */ BSTR i_bstrTopologyPref,
        /* [in] */ BSTR i_bstrHubMemberDN,
		/* [in] */ BSTR i_bstrPrimaryMemberDN,
        /* [in] */ BSTR i_bstrFileFilter,
		/* [in] */ BSTR i_bstrDirFilter
    );

    STDMETHOD(Initialize)( 
        /* [in] */ BSTR i_bstrDomain,
        /* [in] */ BSTR i_bstrReplicaSetDN);

    STDMETHOD(GetMemberList)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMemberDNs);

    STDMETHOD(GetMemberListEx)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pVal);

    STDMETHOD(GetMemberInfo)( 
        /* [in] */ BSTR i_bstrMemberDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember);

    STDMETHOD(IsFRSMember)( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath);

    STDMETHOD(IsHubMember)( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath);

    STDMETHOD(AddMember)( 
        /* [in] */ BSTR i_bstrServer,
        /* [in] */ BSTR i_bstrRootPath,
        /* [in] */ BSTR i_bstrStagingPath,
        /* [in] */ BOOL i_bAddConnectionNow,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrMemberDN);

    STDMETHOD(RemoveMember)( 
        /* [in] */ BSTR i_bstrMemberDN);

    STDMETHOD(RemoveMemberEx)( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath);

    STDMETHOD(RemoveAllMembers)();

    STDMETHOD(GetConnectionList)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnectionDNs);

    STDMETHOD(GetConnectionListEx)( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pVal);

    STDMETHOD(GetConnectionInfo)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnection);

    STDMETHOD(AddConnection)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable,
        /* [in] */ BOOL i_bSyncImmediately,
        /* [in] */ long i_nPriority,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrConnectionDN);

    STDMETHOD(RemoveConnection)( 
        /* [in] */ BSTR i_bstrConnectionDN);

    STDMETHOD(RemoveConnectionEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN);

    STDMETHOD(RemoveAllConnections)();

    STDMETHOD(EnableConnection)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ BOOL i_bEnable);

    STDMETHOD(EnableConnectionEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable);

    STDMETHOD(GetConnectionSchedule)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT* o_pVar);

    STDMETHOD(GetConnectionScheduleEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [retval][out] */ VARIANT* o_pVar);

    STDMETHOD(SetConnectionSchedule)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ VARIANT* i_pVar);

    STDMETHOD(SetConnectionScheduleEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ VARIANT* i_pVar);

    STDMETHOD(SetScheduleOnAllConnections)( 
        /* [in] */ VARIANT* i_pVar);

    STDMETHOD(SetConnectionOptions)( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ BOOL i_bSyncImmediately,
        /* [in] */ long i_nPriority);

    STDMETHOD(SetConnectionOptionsEx)( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bSyncImmediately,
        /* [in] */ long i_nPriority);

    STDMETHOD(CreateConnections)();

    STDMETHOD(Delete)();

    STDMETHOD(GetBadMemberInfo)( 
        /* [in] */ BSTR i_bstrServerName,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember);

protected:
    void _FreeMemberVariables();
    HRESULT _PopulateMemberList();
    HRESULT _PopulateConnectionList();
    HRESULT _DeleteMember(CFrsMember* pFrsMember);
    HRESULT _DeleteConnection(CFrsConnection* pFrsConnection);
    HRESULT _GetMemberInfo(CFrsMember* i_pFrsMember, VARIANT* o_pvarMember);
    HRESULT _GetConnectionInfo(CFrsConnection* i_pFrsConnection, VARIANT* o_pvarConnection);
    HRESULT _SetCustomTopologyPref();
    HRESULT _AdjustConnectionsAdd(BSTR i_bstrNewMemberDN, BSTR i_bstrSite);
    HRESULT _RemoveConnectionsFromAndTo(CFrsMember* pFrsMember);
    HRESULT _GetConnectionSchedule(BSTR i_bstrConnectionDN, VARIANT* o_pVar);

protected:
    CComBSTR            m_bstrType;
    CComBSTR            m_bstrTopologyPref;
    CComBSTR            m_bstrHubMemberDN;
    CComBSTR            m_bstrPrimaryMemberDN;
    CComBSTR            m_bstrFileFilter;
    CComBSTR            m_bstrDirFilter;
    CComBSTR            m_bstrDfsEntryPath;
    CComBSTR            m_bstrReplicaSetDN;

    CDfsAlternateList   m_dfsAlternateList;
    CFrsMemberList      m_frsMemberList;
    CFrsConnectionList  m_frsConnectionList;

    PLDAP               m_pldap;
    CComBSTR            m_bstrDomain;
    CComBSTR            m_bstrDomainGuid;
    CComBSTR            m_bstrDC;

    BOOL                m_bNewSchema;
};

#endif //__REPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\repenum.h ===
/*++

Module Name:

    RepEnum.h

Abstract:

     This file contains the declaration of the CReplicaEnum Class.
     This class implements the IEnumVARIANT which enumerates DfsReplicas.
--*/


#ifndef __REPENUM_H_
#define __REPENUM_H_

#include "resource.h"       // main symbols
#include "DfsRoot.h"

class ATL_NO_VTABLE CReplicaEnum : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CReplicaEnum, &CLSID_ReplicaEnum>,
    IEnumVARIANT
{
public:
    CReplicaEnum()
    {
    }
virtual    ~CReplicaEnum();
// DECLARE_REGISTRY_RESOURCEID(IDR_REPLICAENUM)

BEGIN_COM_MAP(CReplicaEnum)
    COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()


//IEnumVARIANT Methods
public:
                                                        // Get next replica.
    STDMETHOD(Next)
    (
        ULONG i_ulNumOfReplicas, 
        VARIANT *o_pIReplicaArray, 
        ULONG *o_ulNumOfReplicasFetched
    );

                                                        // Skip the next element in the enumeratio.
    STDMETHOD(Skip)
    (
        ULONG i_ulReplicasToSkip
    );

                                                        // Reset enumeration and start afresh.
    STDMETHOD(Reset)();
    
                                                        // Create a new enumerator.
    STDMETHOD(Clone)
    (
        IEnumVARIANT **o_ppEnum                            // Pointer to IEnum.
    );

                                                        // Intialise the Enumerator.
    STDMETHOD(Initialize)
    (
        REPLICAINFOLIST* i_priList, 
        BSTR i_bstrEntryPath
    );


protected:    
    void _FreeMemberVariables() {
        m_bstrEntryPath.Empty();
        FreeReplicas(&m_Replicas);
    }

    //Member variable for enumeraiton.
    REPLICAINFOLIST::iterator   m_iCurrentInEnumOfReplicas;    
    REPLICAINFOLIST             m_Replicas;
    CComBSTR                    m_bstrEntryPath;
};

#endif //__REPENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_)
#define AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <lmcons.h>
#include <lmdfs.h>
#include <lmapibuf.h>    // For NetApiBufferFree.
#include <lmserver.h>
#include <lmerr.h>
#include <lmwksta.h>

#include "dfsDebug.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A741D3E8_31BE_11D1_9A4A_0080ADAA5C4B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\repenum.cpp ===
/*++

Module Name:

    RepEnum.cpp

Abstract:

   This file contains the Implementation of the Class CReplicaEnum.
   This class implements the IEnumVARIANT which enumerates DfsReplicas.

--*/


#include "stdafx.h"
#include "DfsCore.h"
#include "DfsRep.h"
#include "RepEnum.h"


/////////////////////////////////////////////////////////////////////////////
// ~CReplicaEnum


CReplicaEnum :: ~CReplicaEnum()
{
    _FreeMemberVariables();
}


/////////////////////////////////////////////////////////////////////////////
// Initialize


STDMETHODIMP CReplicaEnum :: Initialize
(
    REPLICAINFOLIST*    i_priList,
    BSTR                i_bstrEntryPath
)
{
/*++

Routine Description:

  Initializes the ReplicaEnum object.
  It copies the replica list passed to it by the junction point
  object. Sorting is done during the copying.

--*/

    if (!i_priList || !i_bstrEntryPath)
        return E_INVALIDARG;

    _FreeMemberVariables();

    HRESULT hr = S_OK;

    do {
        m_bstrEntryPath = i_bstrEntryPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath, &hr);

        REPLICAINFOLIST::iterator i;
        REPLICAINFOLIST::iterator j;

        for (i = i_priList->begin(); i != i_priList->end(); i++)
        {
                    // Find insertion position.
            for (j = m_Replicas.begin(); j != m_Replicas.end(); j++)
            {
                if (lstrcmpi((*i)->m_bstrServerName, (*j)->m_bstrServerName) < 0 ||
                    lstrcmpi((*i)->m_bstrShareName, (*j)->m_bstrShareName) <= 0)
                    break;
            }

            REPLICAINFO* pTemp = (*i)->Copy();
            BREAK_OUTOFMEMORY_IF_NULL(pTemp, &hr);

            m_Replicas.insert(j, pTemp);
        }
    } while (0);

    if (SUCCEEDED(hr))
        m_iCurrentInEnumOfReplicas = m_Replicas.begin();
    else
        _FreeMemberVariables();

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IEnumVariant Methods


/////////////////////////////////////////////////////////////////////////////
// Next


STDMETHODIMP CReplicaEnum :: Next
(
    ULONG       i_ulNumOfReplicas,          // Number of replicas to fetch
    VARIANT *   o_pIReplicaArray,           // VARIANT array to return fetched replicas.
    ULONG *     o_ulNumOfReplicasFetched    // Return the number of replicas fetched.
)
{
/*++

Routine Description:

  Gets the next object in the list.

Arguments:

  i_ulNumOfReplicas      - the number of replicas to return
  o_pIReplicaArray      - an array of variants in which to return the replicas
  o_ulNumOfReplicasFetched  - the number of replicas that are actually returned

--*/

    if (!i_ulNumOfReplicas || !o_pIReplicaArray)
        return E_INVALIDARG;

    HRESULT       hr = S_OK;
    ULONG         nCount = 0;      //Count of Elements Fetched.
    IDfsReplica   *pIReplicaPtr = NULL;

                      // Create replica object using the internal replica list.
    for (nCount = 0; 
        nCount < i_ulNumOfReplicas && m_iCurrentInEnumOfReplicas != m_Replicas.end();
        m_iCurrentInEnumOfReplicas++)
    {
                      // Create a replica object.
        hr = CoCreateInstance(CLSID_DfsReplica, NULL, CLSCTX_INPROC_SERVER,
                            IID_IDfsReplica, (void **)&pIReplicaPtr);
        BREAK_IF_FAILED(hr);

                                  //Initialize the replica object.
        hr = pIReplicaPtr->Initialize(m_bstrEntryPath, 
                       (*m_iCurrentInEnumOfReplicas)->m_bstrServerName,
                       (*m_iCurrentInEnumOfReplicas)->m_bstrShareName,
                       (*m_iCurrentInEnumOfReplicas)->m_lDfsStorageState);

        if (FAILED(hr))
        {
            pIReplicaPtr->Release();
            break;
        }

        V_VT (&o_pIReplicaArray[nCount]) = VT_DISPATCH;
        o_pIReplicaArray[nCount].pdispVal = pIReplicaPtr; 

        nCount++;
    }

                //VB does not send o_ulNumOfReplicasFetched;
    if (o_ulNumOfReplicasFetched)
        *o_ulNumOfReplicasFetched = nCount;

    if (SUCCEEDED(hr) && !nCount)
        return S_FALSE;
    else
        return hr;
}


/////////////////////////////////////////////////////////////////////////////
// Skip


STDMETHODIMP CReplicaEnum :: Skip
(
    ULONG i_ulReplicasToSkip        //Number of items to skip.
)
{
/*++

Routine Description:

  Skips the next 'n' objects in the list.

Arguments:

  i_ulReplicasToSkip - the number of objects to skip over

Return value:

  S_OK, On success
  S_FALSE, if the end of the list is reached

--*/

    for (unsigned int j = 0; j < i_ulReplicasToSkip && m_iCurrentInEnumOfReplicas != m_Replicas.end(); j++)
    {
        m_iCurrentInEnumOfReplicas++;
    }

    return (m_iCurrentInEnumOfReplicas != m_Replicas.end()) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Reset


STDMETHODIMP CReplicaEnum :: Reset()
{
/*++

Routine Description:

  Resets the current enumeration pointer to the start of the list

--*/

    m_iCurrentInEnumOfReplicas = m_Replicas.begin();
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// Clone


STDMETHODIMP CReplicaEnum :: Clone
(
    IEnumVARIANT **o_ppEnum        //Return IEnumVARIANT pointer.
)
{
/*++

Routine Description:

  Creates a clone of the enumerator object

Arguments:

  o_ppEnum  -  address of the pointer to the IEnumVARIANT interface 
          of the newly created enumerator object

Notes:

  This has not been implemented.

--*/

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfscore\repset.cpp ===
/*++
Module Name:
    RepSet.cpp
--*/

#include "stdafx.h"
#include "DfsCore.h"
#include "RepSet.h"
#include "netutils.h"
#include "ldaputils.h"
#include <dsgetdc.h>    // DsGetSiteName

// sort member list based on m_bstrSite
struct FrsMemberCompare : greater<CFrsMember*>
{
      bool operator()(const CFrsMember *pMem1, const CFrsMember *pMem2) const
      { return (lstrcmpi(pMem1->m_bstrSite, pMem2->m_bstrSite) > 0); }
};

//
// retrieve Site
//
HRESULT GetSiteName(IN BSTR i_bstrServer, OUT BSTR* o_pbstrSite)
{
    HRESULT hr = S_OK;
    LPTSTR  lpszSiteName = NULL;
    DWORD   dwErr = DsGetSiteName(i_bstrServer, &lpszSiteName);

    if (NO_ERROR == dwErr)
    {
        *o_pbstrSite = SysAllocString(lpszSiteName);
        NetApiBufferFree((LPBYTE)lpszSiteName);
        if (!*o_pbstrSite)
            hr = E_OUTOFMEMORY;
    } else if (ERROR_NO_SITENAME == dwErr)
    {
        *o_pbstrSite = SysAllocString(_T(""));
        if (!*o_pbstrSite)
            hr = E_OUTOFMEMORY;
    } else
    {
        CComBSTR  bstrText;
	FormatMessageString(&bstrText, 0, IDS_UNKNOWN_SITE, dwErr);
        *o_pbstrSite = bstrText.Copy();
        if (!*o_pbstrSite)
            hr = E_OUTOFMEMORY;

//        hr = HRESULT_FROM_WIN32(dwErr);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// constructor

CReplicaSet::CReplicaSet() :
    m_pldap(NULL),
    m_bNewSchema(FALSE)
{
    dfsDebugOut((_T("CReplicaSet::CReplicaSet this=%p\n"), this));
}


/////////////////////////////////////////////////////////////////////////////////////////////////
// destructor 


CReplicaSet::~CReplicaSet()
{
    _FreeMemberVariables();

    dfsDebugOut((_T("CReplicaSet::~CReplicaSet this=%p\n"), this));
}

/////////////////////////////////////////////////////////////////////////////////////////////////
// various properties

STDMETHODIMP CReplicaSet::get_Type(BSTR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrType)
    {
        m_bstrType = FRS_RSTYPE_OTHER;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrType);
    }

    *pVal = m_bstrType.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_Type(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrType && !lstrcmpi(newVal, m_bstrType))
        return S_OK; // no change

    CComBSTR bstrType = ((newVal && *newVal)? newVal : FRS_RSTYPE_DFS);
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrType);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_TYPE;
    pAttrVals[0].vpValue = (void *)(BSTR)bstrType;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);

    if (SUCCEEDED(hr))
        m_bstrType = bstrType;

    return hr;
}

STDMETHODIMP CReplicaSet::get_TopologyPref(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrTopologyPref)
    {
        m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_CUSTOM;
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref);
    }

    *pVal = m_bstrTopologyPref.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    dfsDebugOut((_T("get_TopologyPref = %s\n"), m_bstrTopologyPref));

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_TopologyPref(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrTopologyPref && !lstrcmpi(newVal, m_bstrTopologyPref))
        return S_OK; // no change

    CComBSTR bstrTopologyPref = ((newVal && *newVal)? newVal : FRS_RSTOPOLOGYPREF_CUSTOM);
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrTopologyPref);

    HRESULT hr = S_OK;

    if (m_bNewSchema)
    {
        LDAP_ATTR_VALUE  pAttrVals[1];
        pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_TOPOLOGYPREF;
        pAttrVals[0].vpValue = (void *)(BSTR)bstrTopologyPref;
        pAttrVals[0].bBerValue = false;

        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);

        if (SUCCEEDED(hr))
            m_bstrTopologyPref = bstrTopologyPref;
    } else
    {
        m_bstrTopologyPref = bstrTopologyPref;
    }

    dfsDebugOut((_T("put_TopologyPref = %s\n"), m_bstrTopologyPref));

    return hr;
}

STDMETHODIMP CReplicaSet::get_HubMemberDN(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrHubMemberDN)
    {
        m_bstrHubMemberDN = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrHubMemberDN);
    }

    *pVal = m_bstrHubMemberDN.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    dfsDebugOut((_T("get_HubMemberDN = %s\n"), m_bstrHubMemberDN));

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_HubMemberDN(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrHubMemberDN && !lstrcmpi(newVal, m_bstrHubMemberDN))
        return S_OK; // no change

    CComBSTR bstrHubMemberDN = ((newVal && *newVal) ? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrHubMemberDN);

    HRESULT hr = S_OK;

    if (m_bNewSchema)
    {
        LDAP_ATTR_VALUE  pAttrVals[1];
        pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_HUBSERVER;
        pAttrVals[0].bBerValue = false;

        if (newVal && *newVal)
        {
            pAttrVals[0].vpValue = (void *)(BSTR)bstrHubMemberDN;
            hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
        } else
        {
            pAttrVals[0].vpValue = NULL;
            hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
        }
        if (SUCCEEDED(hr))
            m_bstrHubMemberDN = bstrHubMemberDN;
    } else
    {
        m_bstrHubMemberDN = bstrHubMemberDN;
    }

    dfsDebugOut((_T("put_HubMemberDN = %s\n"), m_bstrHubMemberDN));

    return hr;
}

STDMETHODIMP CReplicaSet::get_PrimaryMemberDN(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrPrimaryMemberDN)
    {
        m_bstrPrimaryMemberDN = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrPrimaryMemberDN);
    }

    *pVal = m_bstrPrimaryMemberDN.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_PrimaryMemberDN(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrPrimaryMemberDN && !lstrcmpi(newVal, m_bstrPrimaryMemberDN))
        return S_OK; // no change

    CComBSTR bstrPrimaryMemberDN = ((newVal && *newVal)? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrPrimaryMemberDN);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_PRIMARYMEMBER;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = S_OK;
    if (newVal && *newVal)
    {
        pAttrVals[0].vpValue = (void *)(BSTR)bstrPrimaryMemberDN;
        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    } else
    {
        pAttrVals[0].vpValue = NULL;
        hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    }
    if (SUCCEEDED(hr))
        m_bstrPrimaryMemberDN = bstrPrimaryMemberDN;

    return hr;
}

STDMETHODIMP CReplicaSet::get_FileFilter(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrFileFilter)
    {
        m_bstrFileFilter = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFileFilter);
    }

    *pVal = m_bstrFileFilter.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_FileFilter(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrFileFilter && !lstrcmpi(newVal, m_bstrFileFilter))
        return S_OK; // no change

    CComBSTR bstrFileFilter = ((newVal && *newVal) ? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFileFilter);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_FILEFILTER;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = S_OK;
    if (newVal && *newVal)
    {
        pAttrVals[0].vpValue = (void *)(BSTR)bstrFileFilter;
        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    } else
    {
        pAttrVals[0].vpValue = NULL;
        hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    }
    if (SUCCEEDED(hr))
        m_bstrFileFilter = bstrFileFilter;

    return hr;
}

STDMETHODIMP CReplicaSet::get_DirFilter(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrDirFilter)
    {
        m_bstrDirFilter = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDirFilter);
    }

    *pVal = m_bstrDirFilter.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::put_DirFilter(BSTR newVal)
{
    if (newVal && (BSTR)m_bstrDirFilter && !lstrcmpi(newVal, m_bstrDirFilter))
        return S_OK; // no change

    CComBSTR bstrDirFilter = ((newVal && *newVal)? newVal : _T(""));
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrDirFilter);

    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_FRS_REPSET_DIRFILTER;
    pAttrVals[0].bBerValue = false;

    HRESULT hr = S_OK;
    if (newVal && *newVal)
    {
        pAttrVals[0].vpValue = (void *)(BSTR)bstrDirFilter;
        hr = ::ModifyValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    } else
    {
        pAttrVals[0].vpValue = NULL;
        hr = ::DeleteValues(m_pldap, m_bstrReplicaSetDN, 1, pAttrVals);
    }
    if (SUCCEEDED(hr))
        m_bstrDirFilter = bstrDirFilter;

    return hr;
}

STDMETHODIMP CReplicaSet::get_DfsEntryPath(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    if (!m_bstrDfsEntryPath)
    {
        m_bstrDfsEntryPath = _T("");
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDfsEntryPath);
    }

    *pVal = m_bstrDfsEntryPath.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_Domain(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDomain);

    *pVal = m_bstrDomain.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_ReplicaSetDN(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrReplicaSetDN);

    *pVal = m_bstrReplicaSetDN.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_NumOfMembers(long* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    *pVal = m_frsMemberList.size();

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_NumOfConnections(long* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    *pVal = m_frsConnectionList.size();

    return S_OK;
}

STDMETHODIMP CReplicaSet::get_TargetedDC(BSTR* pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);
    RETURN_INVALIDARG_IF_NULL((BSTR)m_bstrDC);

    *pVal = m_bstrDC.Copy ();
    RETURN_OUTOFMEMORY_IF_NULL(*pVal);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  various methods
STDMETHODIMP CReplicaSet::Create(
    BSTR i_bstrDomain,
    BSTR i_bstrReplicaSetDN,
    BSTR i_bstrType,
    BSTR i_bstrTopologyPref,
    BSTR i_bstrHubMemberDN,
    BSTR i_bstrPrimaryMemberDN,
    BSTR i_bstrFileFilter,
    BSTR i_bstrDirFilter
)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrType);

    _FreeMemberVariables();

    HRESULT hr = S_OK;

    do {
        m_bstrDomain = i_bstrDomain;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

        CComBSTR bstrDomainDN;
        hr = GetDomainInfo(
                        i_bstrDomain,
                        NULL,               // return DC's Dns name
                        NULL,               // return Domain's Dns name
                        &bstrDomainDN,      // return DC=nttest,DC=micr
                        NULL,               // return LDAP://<DC>/<Doma
                        &m_bstrDomainGuid   // return Domain's guid
                        );
        BREAK_IF_FAILED(hr);

        hr = ConnectToDS(m_bstrDomain, &m_pldap, &m_bstrDC);
        BREAK_IF_FAILED(hr);

        //
        // get schema version
        //
        hr = GetSchemaVersionEx(m_bstrDomain, FALSE);
        BREAK_IF_FAILED(hr);

        m_bNewSchema = (S_OK == hr);
        dfsDebugOut((_T("NewSchema=%d\n"), m_bNewSchema));

        m_bstrReplicaSetDN = i_bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        m_bstrReplicaSetDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        m_bstrReplicaSetDN += bstrDomainDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);

        m_bstrType = i_bstrType;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrType, &hr);

        //
        // create container objects if not exist
        //
        hr = CreateNtfrsSettingsObjects(m_pldap, m_bstrReplicaSetDN);
        BREAK_IF_FAILED(hr);

        //
        // create this nTFRSReplicaSet object
        //
        LDAP_ATTR_VALUE  pAttrVals[7];

        int i = 0;
        pAttrVals[i].bstrAttribute = OBJCLASS_ATTRIBUTENAME;
        pAttrVals[i].vpValue = (void *)OBJCLASS_NTFRSREPLICASET;
        pAttrVals[i].bBerValue = false;

        i++;
        pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_TYPE;
        pAttrVals[i].vpValue = (void *)i_bstrType;
        pAttrVals[i].bBerValue = false;

        if (i_bstrTopologyPref && *i_bstrTopologyPref)
        {
            m_bstrTopologyPref = i_bstrTopologyPref;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);

            if (m_bNewSchema)
            {
                i++;
                pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_TOPOLOGYPREF;
                pAttrVals[i].vpValue = (void *)i_bstrTopologyPref;
                pAttrVals[i].bBerValue = false;
            }

            if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref))
            {
                if (i_bstrHubMemberDN && *i_bstrHubMemberDN)
                {
                    m_bstrHubMemberDN = i_bstrHubMemberDN;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrHubMemberDN, &hr);

                    if (m_bNewSchema)
                    {
                        i++;
                        pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_HUBSERVER;
                        pAttrVals[i].vpValue = (void *)i_bstrHubMemberDN;
                        pAttrVals[i].bBerValue = false;
                    }
                }
            }
        }

        if (i_bstrPrimaryMemberDN && *i_bstrPrimaryMemberDN)
        {
            m_bstrPrimaryMemberDN = i_bstrPrimaryMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrPrimaryMemberDN, &hr);

            i++;
            pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_PRIMARYMEMBER;
            pAttrVals[i].vpValue = (void *)i_bstrPrimaryMemberDN;
            pAttrVals[i].bBerValue = false;
        }

        if (i_bstrFileFilter && *i_bstrFileFilter)
        {
            m_bstrFileFilter = i_bstrFileFilter;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFileFilter, &hr);

            i++;
            pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_FILEFILTER;
            pAttrVals[i].vpValue = (void *)i_bstrFileFilter;
            pAttrVals[i].bBerValue = false;
        }

        if (i_bstrDirFilter && *i_bstrDirFilter)
        {
            m_bstrDirFilter = i_bstrDirFilter;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDirFilter, &hr);

            i++;
            pAttrVals[i].bstrAttribute = ATTR_FRS_REPSET_DIRFILTER;
            pAttrVals[i].vpValue = (void *)i_bstrDirFilter;
            pAttrVals[i].bBerValue = false;
        }

        hr = AddValues(
                m_pldap,
                m_bstrReplicaSetDN,
                ++i,
                pAttrVals
                );
        BREAK_IF_FAILED(hr);

    } while (0);

    if (FAILED(hr))
    {
        _FreeMemberVariables();

        //
        // try to clean empty container objects
        //
        (void)DeleteNtfrsReplicaSetObjectAndContainers(m_pldap, m_bstrReplicaSetDN);
    }

    return hr;
}

STDMETHODIMP CReplicaSet::Initialize(BSTR i_bstrDomain, BSTR i_bstrReplicaSetDN)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrReplicaSetDN);

    _FreeMemberVariables();

    HRESULT hr = S_OK;

    do {
        m_bstrDomain = i_bstrDomain;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

        CComBSTR bstrDomainDN;
        hr = GetDomainInfo(
                        i_bstrDomain,
                        NULL,               // return DC's Dns name
                        NULL,               // return Domain's Dns name
                        &bstrDomainDN,      // return DC=nttest,DC=micr
                        NULL,               // return LDAP://<DC>/<Doma
                        &m_bstrDomainGuid   // return Domain's guid
                        );
        BREAK_IF_FAILED(hr);

        m_bstrReplicaSetDN = i_bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);

        hr = ConnectToDS(m_bstrDomain, &m_pldap, &m_bstrDC);
        BREAK_IF_FAILED(hr);

        //
        // get schema version
        //
        hr = GetSchemaVersionEx(m_bstrDomain, FALSE);
        BREAK_IF_FAILED(hr);

        m_bNewSchema = (S_OK == hr);
        dfsDebugOut((_T("NewSchema=%d\n"), m_bNewSchema));

        m_bstrReplicaSetDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);
        m_bstrReplicaSetDN += bstrDomainDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrReplicaSetDN, &hr);

        PLDAP_ATTR_VALUE  pValues[7] = {0,0,0,0,0,0,0};
        LDAP_ATTR_VALUE  pAttributes[6];

        int i = 0;
        pAttributes[i].bstrAttribute = ATTR_FRS_REPSET_TYPE;
        if (m_bNewSchema)
        {
            pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_TOPOLOGYPREF;
            pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_HUBSERVER;
        }
        pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_PRIMARYMEMBER;
        pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_FILEFILTER;
        pAttributes[++i].bstrAttribute = ATTR_FRS_REPSET_DIRFILTER;

        hr = GetValues( m_pldap,
                        m_bstrReplicaSetDN,
                        OBJCLASS_SF_NTFRSREPLICASET,
                        LDAP_SCOPE_BASE,
                        ++i,
                        pAttributes,
                        pValues);
        BREAK_IF_FAILED(hr);

        do {
            i = 0;
            if (pValues[i])
            {
                m_bstrType = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrType, &hr);
            }

            if (!m_bNewSchema)
            {
                m_bstrHubMemberDN.Empty();
                m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_CUSTOM;
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);
            } else
            {
                i++;
                if (pValues[i])
                {
                    m_bstrTopologyPref = (PTSTR)(pValues[i]->vpValue);
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);
                }

                i++;
                if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref))
                {
                    if (pValues[i])
                    {
                        m_bstrHubMemberDN = (PTSTR)(pValues[i]->vpValue);
                        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrHubMemberDN, &hr);
                    } else
                    {
                        // something was wrong, reset Cutom topology
                        m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_CUSTOM;
                        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrTopologyPref, &hr);
                    }
                }
            }

            i++;
            if (pValues[i])
            {
                m_bstrPrimaryMemberDN = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrPrimaryMemberDN, &hr);
            }

            i++;
            if (pValues[i])
            {
                m_bstrFileFilter = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFileFilter, &hr);
            }

            i++;
            if (pValues[i])
            {
                m_bstrDirFilter = (PTSTR)(pValues[i]->vpValue);
                BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDirFilter, &hr);
            }
        } while (0);

        for (i = 0; i < 7; i++)
        {
            if (pValues[i])
                FreeAttrValList(pValues[i]);
        }

        hr = _PopulateMemberList();
        BREAK_IF_FAILED(hr);

        hr = _PopulateConnectionList();
        BREAK_IF_FAILED(hr);

        dfsDebugOut((_T("members=%d, connections=%d\n"), m_frsMemberList.size(), m_frsConnectionList.size()));
    } while (0);

    if (FAILED(hr))
        _FreeMemberVariables();

    return hr;
}

HRESULT CReplicaSet::_PopulateMemberList()
{
    PCTSTR ppszAttributes[] = {
                                ATTR_DISTINGUISHEDNAME,
                                ATTR_FRS_MEMBER_COMPUTERREF,
                                0
                                };

    LListElem* pElem = NULL;
    HRESULT hr = GetValuesEx(
                            m_pldap,
                            m_bstrReplicaSetDN,
                            LDAP_SCOPE_ONELEVEL,
                            OBJCLASS_SF_NTFRSMEMBER,
                            ppszAttributes,
                            &pElem);
    RETURN_IF_FAILED(hr);

    LListElem* pCurElem = pElem;
    while (pCurElem)
    {
        PTSTR** pppszValues = pCurElem->pppszAttrValues;

        if (!pppszValues ||
            !pppszValues[0] || !*(pppszValues[0]) ||
            !pppszValues[1] || !*(pppszValues[1]))
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted member object
        }

        CFrsMember *pMember = new CFrsMember;
        hr = pMember->InitEx(m_pldap, 
                            m_bstrDC,
                            *(pppszValues[0]),  // distinguishedName
                            *(pppszValues[1])   // computerRef
                            );
       if (FAILED(hr))
       {
           delete pMember;
           break;
       } else if (S_FALSE == hr)
           delete pMember;
        else
            m_frsMemberList.push_back(pMember);

        pCurElem = pCurElem->Next;
    }

    FreeLListElem(pElem);

    if (FAILED(hr))
        FreeFrsMembers(&m_frsMemberList);

    return hr;
}

STDMETHODIMP CReplicaSet::GetMemberList( 
        /* [retval][out] */ VARIANT __RPC_FAR *pvarMemberDNs)
{
    RETURN_INVALIDARG_IF_NULL(pvarMemberDNs);

    VariantInit(pvarMemberDNs);
    pvarMemberDNs->vt = VT_ARRAY | VT_VARIANT;
    pvarMemberDNs->parray = NULL;

    HRESULT hr = S_OK;
    int     cMembers = m_frsMemberList.size();
    if (!cMembers)
        return hr;  // parray is NULL when the member list is empty

    SAFEARRAYBOUND  bounds = {cMembers, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); (it != m_frsMemberList.end()) && (i < cMembers); it++, i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = ((*it)->m_bstrMemberDN).Copy();
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        pvarMemberDNs->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

STDMETHODIMP CReplicaSet::GetMemberListEx( 
        /* [retval][out] */ VARIANT __RPC_FAR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    VariantInit(pVal);
    pVal->vt = VT_ARRAY | VT_VARIANT;
    pVal->parray = NULL;

    HRESULT hr = S_OK;
    int     cMembers = m_frsMemberList.size();
    if (!cMembers)
        return hr;  // parray is NULL when the member list is empty

    SAFEARRAYBOUND  bounds = {cMembers, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); (it != m_frsMemberList.end()) && (i < cMembers); it++, i++)
    {
        VariantInit(&(varArray[i]));
        hr = _GetMemberInfo((*it), &(varArray[i]));
        BREAK_IF_FAILED(hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        pVal->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

HRESULT CReplicaSet::_GetMemberInfo( 
    IN  CFrsMember*     i_pFrsMember,
    OUT VARIANT*        o_pvarMember)
{
    RETURN_INVALIDARG_IF_NULL(i_pFrsMember);
    RETURN_INVALIDARG_IF_NULL(o_pvarMember);

    HRESULT         hr = S_OK;
    SAFEARRAYBOUND  bounds = {NUM_OF_FRSMEMBER_ATTRS, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    BSTR bstr[NUM_OF_FRSMEMBER_ATTRS] = {
                                    i_pFrsMember->m_bstrComputerDN,
                                    i_pFrsMember->m_bstrDomain,
                                    i_pFrsMember->m_bstrMemberDN,
                                    i_pFrsMember->m_bstrRootPath,
                                    i_pFrsMember->m_bstrServer,
                                    i_pFrsMember->m_bstrServerGuid,
                                    i_pFrsMember->m_bstrSite,
                                    i_pFrsMember->m_bstrStagingPath,
                                    i_pFrsMember->m_bstrSubscriberDN
                                        };

    for (int i = 0; i < NUM_OF_FRSMEMBER_ATTRS; i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = SysAllocString(bstr[i]);
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
    {
        o_pvarMember->vt = VT_ARRAY | VT_VARIANT;
        o_pvarMember->parray = psa;
    } else
        SafeArrayDestroy(psa);

    return hr;
}

STDMETHODIMP CReplicaSet::GetMemberInfo( 
        /* [in] */ BSTR i_bstrMemberDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);

    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!lstrcmpi(i_bstrMemberDN, (*it)->m_bstrMemberDN))
            break;
    }

    if (it == m_frsMemberList.end())
        return S_FALSE; // no such member

    return _GetMemberInfo((*it), o_pvarMember);
}

STDMETHODIMP CReplicaSet::GetBadMemberInfo( 
        /* [in] */ BSTR i_bstrServerName,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarMember)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
    int n = lstrlen(i_bstrServerName);
    int nLen = 0;
    int nMinLen = 0;

    CFrsMember* pMember = NULL;
    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!mylstrncmpi(i_bstrServerName, (*it)->m_bstrServer, n))
        {
            nLen = lstrlen((*it)->m_bstrServer);
            if (!pMember || nLen < nMinLen)
            {
                nMinLen = nLen;
                pMember = *it;
            }
        }
    }

    if (!pMember)
        return S_FALSE; // no such member

    return _GetMemberInfo(pMember, o_pvarMember);
}

STDMETHODIMP CReplicaSet::IsFRSMember( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath
)
{
    if (!i_bstrDnsHostName || !*i_bstrDnsHostName ||
        !i_bstrRootPath || !*i_bstrRootPath)
        return S_FALSE;

    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!lstrcmpi(i_bstrDnsHostName, (*it)->m_bstrServer) &&
            !lstrcmpi(i_bstrRootPath, (*it)->m_bstrRootPath))
            break;
    }

    if (it == m_frsMemberList.end())
        return S_FALSE; // no such member

    return S_OK;
}

STDMETHODIMP CReplicaSet::IsHubMember( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath
)
{
    if (!i_bstrDnsHostName || !*i_bstrDnsHostName ||
        !i_bstrRootPath || !*i_bstrRootPath)
        return S_FALSE;

    if (0 != lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref))
        return S_FALSE; // not a hubspoke topology

    CFrsMemberList::iterator it;
    for (it = m_frsMemberList.begin(); it != m_frsMemberList.end(); it++)
    {
        if (!lstrcmpi(i_bstrDnsHostName, (*it)->m_bstrServer) &&
            !lstrcmpi(i_bstrRootPath, (*it)->m_bstrRootPath))
            break;
    }

    if (it == m_frsMemberList.end())
        return S_FALSE; // no such member

    if (!lstrcmpi(m_bstrHubMemberDN, (*it)->m_bstrMemberDN))
        return S_OK;

    return S_FALSE; 
}

STDMETHODIMP CReplicaSet::AddMember( 
        /* [in] */ BSTR i_bstrServer,
        /* [in] */ BSTR i_bstrRootPath,
        /* [in] */ BSTR i_bstrStagingPath,
        /* [in] */ BOOL i_bAddConnectionNow,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrMemberDN)
{
    CComBSTR    bstrComputerDomain;
    CComBSTR    bstrDnsHostName;
    CComBSTR    bstrComputerGuid;
    CComBSTR    bstrComputerDN;
    HRESULT     hr = GetServerInfo(i_bstrServer,
                        &bstrComputerDomain,
                        NULL, //o_pbstrNetbiosName
                        NULL, //o_pbValidDSObject
                        &bstrDnsHostName,
                        &bstrComputerGuid,
                        &bstrComputerDN
                        );
    if (S_OK != hr)
        return hr;   // don't add this member if it doesn't have an appropriate computer obj in a domain

    //
    // is i_bstrServer already a frs member
    //
    BOOL bIsFrsMember = FALSE;
    for (CFrsMemberList::iterator i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
    {
        if (!lstrcmpi(bstrComputerGuid, (*i)->m_bstrServerGuid))
        {
            bIsFrsMember = TRUE;
            break;
        }
    }

    if (bIsFrsMember)
    {
        if (0 != lstrcmpi(i_bstrRootPath, (*i)->m_bstrRootPath))
            return S_FALSE;    // cannot have two folders on the same computer join for the same replica set
 
        // member exists, return info of it
        if (o_pbstrMemberDN)
        {
            *o_pbstrMemberDN = (*i)->m_bstrMemberDN.Copy();
            RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrMemberDN);
        }
        return hr;
    }

    //
    // find out if the computer object sits in the same domain as the member object
    //
    CComBSTR bstrDCofComputerObj;
    BOOL bSameDomain = FALSE;
    PLDAP pldapComputer = NULL;
    if (!lstrcmpi(bstrComputerDomain, m_bstrDomain))
    {
        bSameDomain = TRUE;
        pldapComputer = m_pldap;
    } else
    {
        hr = ConnectToDS(bstrComputerDomain, &pldapComputer, &bstrDCofComputerObj);
        RETURN_IF_FAILED(hr);
    }

    CComBSTR bstrMemberDN;
    CComBSTR bstrSubscriberDN;
    do {
        //
        // create a nTFRSMember object in the DS
        //
        bstrMemberDN = _T("CN=");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += bstrComputerGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += m_bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);

        hr = CreateNtfrsMemberObject(m_pldap, bstrMemberDN, bstrComputerDN, bstrDCofComputerObj);
        BREAK_IF_FAILED(hr);

        //
        // create a nTFRSSubscriber object in the DS
        //
        hr = GetSubscriberDN(m_bstrReplicaSetDN, m_bstrDomainGuid, bstrComputerDN, &bstrSubscriberDN);
        BREAK_IF_FAILED(hr);

        hr = CreateNtfrsSubscriptionsObjects(pldapComputer, bstrSubscriberDN, bstrComputerDN);
        BREAK_IF_FAILED(hr);

        hr = CreateNtfrsSubscriberObject(
                    pldapComputer,
                    bstrSubscriberDN,
                    bstrMemberDN,
                    i_bstrRootPath,
                    i_bstrStagingPath,
                    m_bstrDC
                    );
    } while (0);

    if (!bSameDomain)
        CloseConnectionToDS(pldapComputer);

    RETURN_IF_FAILED(hr);

    //
    // add to m_frsMemberList
    //
    CFrsMember *pMember = new CFrsMember;
    hr = pMember->Init(
                    bstrDnsHostName,
                    bstrComputerDomain,
                    bstrComputerGuid,
                    i_bstrRootPath,
                    i_bstrStagingPath,
                    bstrMemberDN,
                    bstrComputerDN,
                    bstrSubscriberDN
                    );
   if (FAILED(hr))
   {
       delete pMember;
       return hr;
   }

    m_frsMemberList.push_back(pMember);

    //
    // if TopologyPref is not custom, add connections
    //
    if (i_bAddConnectionNow)
    {
        hr = _AdjustConnectionsAdd(bstrMemberDN, pMember->m_bstrSite);
        RETURN_IF_FAILED(hr);
    }

    //
    // if o_pbstrMemberDN specified, return o_pbstrMemberDN
    //
    if (o_pbstrMemberDN)
        *o_pbstrMemberDN = bstrMemberDN.Detach();

    return hr;
}

HRESULT CReplicaSet::_DeleteMember(CFrsMember* pFrsMember)
{
    HRESULT hr = S_OK;
    //
    // delete nTFRSSubscriber object
    //
    BOOL bSameDomain = FALSE;
    PLDAP pldapComputer = NULL;
    if (!lstrcmpi(pFrsMember->m_bstrDomain, m_bstrDomain))
    {
        bSameDomain = TRUE;
        pldapComputer = m_pldap;
    } else
    {
        hr = ConnectToDS(pFrsMember->m_bstrDomain, &pldapComputer, NULL);
        RETURN_IF_FAILED(hr);
    }

    hr = DeleteNtfrsSubscriberObjectAndContainers(
                                        pldapComputer, 
                                        pFrsMember->m_bstrSubscriberDN,
                                        pFrsMember->m_bstrComputerDN);

    if (!bSameDomain)
        CloseConnectionToDS(pldapComputer);

    RETURN_IF_FAILED(hr);

    //
    // adjust connections based on current topologyPref
    //
    if (m_frsMemberList.size() <= 2)
    {
        hr = _SetCustomTopologyPref();
    } else if (!lstrcmpi(FRS_RSTOPOLOGYPREF_RING, m_bstrTopologyPref))
    {
        BSTR bstrMemberDN[2];
        int i = 0;
        CFrsConnectionList::iterator it;
        for (it = m_frsConnectionList.begin(); (it != m_frsConnectionList.end()) && (i < 2); it++)
        {
            if (!lstrcmpi(pFrsMember->m_bstrMemberDN, (*it)->m_bstrFromMemberDN))
                bstrMemberDN[i++] = (*it)->m_bstrToMemberDN;
        }
        if (i != 2) 
            hr = _SetCustomTopologyPref(); // corrupted, reset to custom
        else
        {
            hr = AddConnection(bstrMemberDN[0], bstrMemberDN[1], TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            RETURN_IF_FAILED(hr);
            hr = AddConnection(bstrMemberDN[1], bstrMemberDN[0], TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        }
    }
    RETURN_IF_FAILED(hr);

    //
    // delete connections with other members
    //
    hr = _RemoveConnectionsFromAndTo(pFrsMember);
    RETURN_IF_FAILED(hr);

    //
    // delete nTFRSMember object
    //
    hr = DeleteDSObject(m_pldap, pFrsMember->m_bstrMemberDN, TRUE);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveMember( 
        /* [in] */ BSTR i_bstrMemberDN)
{
    HRESULT hr = S_OK;
    CFrsMemberList::iterator i;
    for (i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
    {
        if (!lstrcmpi(i_bstrMemberDN, (*i)->m_bstrMemberDN))
            break;
    }
    if (i == m_frsMemberList.end())
        return hr;  // no such member at all, return

    //
    // if it's the hub, change topologyPref to be custom
    //
    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref) &&
        !lstrcmpi(i_bstrMemberDN, m_bstrHubMemberDN))
    {
        hr = _SetCustomTopologyPref();
        RETURN_IF_FAILED(hr);
    }

    //
    // delete nTFRSSubscriber object
    // adjust connections
    // delete connections with other members
    // delete nTFRSMember object
    //
    hr = _DeleteMember((*i));

    //
    // remove it from m_frsMemberList
    //
    delete (*i);
    m_frsMemberList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveMemberEx( 
        /* [in] */ BSTR i_bstrDnsHostName,
        /* [in] */ BSTR i_bstrRootPath)
{
    HRESULT hr = S_OK;
    CFrsMemberList::iterator i;
    for (i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
    {
        if (!lstrcmpi(i_bstrDnsHostName, (*i)->m_bstrServer) &&
            !lstrcmpi(i_bstrRootPath, (*i)->m_bstrRootPath))
            break;
    }
    if (i == m_frsMemberList.end())
        return hr;  // no such member at all, return

    //
    // if it's the hub, change topologyPref to be custom
    //
    if (!lstrcmpi(FRS_RSTOPOLOGYPREF_HUBSPOKE, m_bstrTopologyPref) &&
        !lstrcmpi((*i)->m_bstrMemberDN, m_bstrHubMemberDN))
    {
        hr = _SetCustomTopologyPref();
        RETURN_IF_FAILED(hr);
    }

    //
    // delete nTFRSSubscriber object
    // adjust connections
    // delete connections with other members
    // delete nTFRSMember object
    //
    hr = _DeleteMember((*i));

    //
    // remove it from m_frsMemberList
    //
    delete (*i);
    m_frsMemberList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveAllMembers()
{
    HRESULT hr = S_OK;
    CFrsMemberList::iterator i = m_frsMemberList.begin();
    while (i != m_frsMemberList.end())
    {
        //
        // delete nTFRSSubscriber object
        // adjust connections
        // delete connections with other members
        // delete nTFRSMember object
        //
        hr = _DeleteMember((*i));
        BREAK_IF_FAILED(hr);

        //
        // remove it from m_frsMemberList
        //
        delete (*i);
        m_frsMemberList.erase(i);

        i = m_frsMemberList.begin();
    }

    return hr;
}

HRESULT CReplicaSet::_PopulateConnectionList()
{
    PCTSTR ppszAttributes[] = {
                                ATTR_DISTINGUISHEDNAME,
                                ATTR_NTDS_CONNECTION_FROMSERVER,
                                ATTR_NTDS_CONNECTION_ENABLEDCONNECTION,
                                ATTR_NTDS_CONNECTION_OPTIONS,
                                0
                                };

    LListElem* pElem = NULL;
    HRESULT hr = GetValuesEx(
                            m_pldap,
                            m_bstrReplicaSetDN,
                            LDAP_SCOPE_SUBTREE,
                            OBJCLASS_SF_NTDSCONNECTION,
                            ppszAttributes,
                            &pElem);
    RETURN_IF_FAILED(hr);

    LListElem* pCurElem = pElem;
    while (pCurElem)
    {
        PTSTR** pppszValues = pCurElem->pppszAttrValues;
        if (!pppszValues ||
            !pppszValues[0] || !*(pppszValues[0]) ||
            !pppszValues[1] || !*(pppszValues[1]) ||
            !pppszValues[2] || !*(pppszValues[2]))
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted connection object
        }

        PTSTR pszParentDN = _tcsstr(*(pppszValues[0]), _T(",CN="));
        if (!pszParentDN)
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted connection object
        }
        pszParentDN++; // point to the 2nd CN=XXX

        BOOL bFromServerFound = FALSE;
        BOOL bToServerFound = FALSE;
        CFrsMemberList::iterator i;
        for (i = m_frsMemberList.begin(); i != m_frsMemberList.end(); i++)
        {
            if (!bToServerFound && !lstrcmpi(pszParentDN, (*i)->m_bstrMemberDN))
            {
                bToServerFound = TRUE;
            }

            if (!bFromServerFound && !lstrcmpi(*(pppszValues[1]), (*i)->m_bstrMemberDN))
            {
                bFromServerFound = TRUE;
            }
        }
        if (!bFromServerFound || !bToServerFound)
        {
            pCurElem = pCurElem->Next;
            continue; // unknown fromServer or toServer, skip this connection
        }

        DWORD dwOptions = _tcstoul(*(pppszValues[3]), NULL, 10);

        BOOL bEnable = (CSTR_EQUAL == CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, *(pppszValues[2]), -1, CONNECTION_ENABLED_TRUE, -1));
        CFrsConnection* pFrsConnection = new CFrsConnection;
        BREAK_OUTOFMEMORY_IF_NULL(pFrsConnection, &hr);
        hr = pFrsConnection->Init(
                                *(pppszValues[0]),  // FQDN
                                *(pppszValues[1]),  // fromServer
                                bEnable,         // enableConnection
                                dwOptions // options
                                );
        if (FAILED(hr))
        {
            delete pFrsConnection;
            break;
        }

        m_frsConnectionList.push_back(pFrsConnection);

        pCurElem = pCurElem->Next;
    }

    FreeLListElem(pElem);

    if (FAILED(hr))
        FreeFrsConnections(&m_frsConnectionList);

    return hr;
}

STDMETHODIMP CReplicaSet::GetConnectionList( 
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnectionDNs)
{
    RETURN_INVALIDARG_IF_NULL(o_pvarConnectionDNs);

    VariantInit(o_pvarConnectionDNs);
    o_pvarConnectionDNs->vt = VT_ARRAY | VT_VARIANT;
    o_pvarConnectionDNs->parray = NULL;

    HRESULT hr = S_OK;
    int     cConnections = m_frsConnectionList.size();
    if (!cConnections)
        return hr;  // parray is NULL when the connection list is empty

    SAFEARRAYBOUND  bounds = {cConnections, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsConnectionList::iterator it;
    for (it = m_frsConnectionList.begin(); (it != m_frsConnectionList.end()) && (i < cConnections); it++, i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = ((*it)->m_bstrConnectionDN).Copy();
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        o_pvarConnectionDNs->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

STDMETHODIMP CReplicaSet::GetConnectionListEx( 
        /* [retval][out] */ VARIANT __RPC_FAR *pVal)
{
    RETURN_INVALIDARG_IF_NULL(pVal);

    VariantInit(pVal);
    pVal->vt = VT_ARRAY | VT_VARIANT;
    pVal->parray = NULL;

    HRESULT hr = S_OK;
    int     cConnections = m_frsConnectionList.size();
    if (!cConnections)
        return hr;  // parray is NULL when the connection list is empty

    SAFEARRAYBOUND  bounds = {cConnections, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    int i = 0;
    CFrsConnectionList::iterator it;
    for (it = m_frsConnectionList.begin(); (it != m_frsConnectionList.end()) && (i < cConnections); it++, i++)
    {
        VariantInit(&(varArray[i]));
        hr = _GetConnectionInfo((*it), &(varArray[i]));
        BREAK_IF_FAILED(hr);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
        pVal->parray = psa;
    else
        SafeArrayDestroy(psa);

    return hr;
}

HRESULT CReplicaSet::_GetConnectionInfo( 
    IN  CFrsConnection* i_pFrsConnection,
    OUT VARIANT*        o_pvarConnection)
{
    RETURN_INVALIDARG_IF_NULL(i_pFrsConnection);
    RETURN_INVALIDARG_IF_NULL(o_pvarConnection);

    HRESULT         hr = S_OK;
    SAFEARRAYBOUND  bounds = {NUM_OF_FRSCONNECTION_ATTRS, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    RETURN_OUTOFMEMORY_IF_NULL(psa);

    VARIANT*        varArray;
    SafeArrayAccessData(psa, (void**)&varArray);

    BSTR bstr[NUM_OF_FRSCONNECTION_ATTRS - 2] = {
                                    i_pFrsConnection->m_bstrConnectionDN,
                                    i_pFrsConnection->m_bstrFromMemberDN,
                                    i_pFrsConnection->m_bstrToMemberDN
                                        };

    for (int i = 0; i < NUM_OF_FRSCONNECTION_ATTRS - 2; i++)
    {
        varArray[i].vt = VT_BSTR;
        varArray[i].bstrVal = SysAllocString(bstr[i]);
        BREAK_OUTOFMEMORY_IF_NULL(varArray[i].bstrVal, &hr);
    }
    if (SUCCEEDED(hr))
    {
        varArray[i].vt = VT_I4;
        varArray[i].lVal = (long)(i_pFrsConnection->m_bEnable);

        varArray[++i].vt = VT_I4;
        varArray[i].lVal = (long)(i_pFrsConnection->m_dwOptions);
    }

    SafeArrayUnaccessData(psa);

    if (SUCCEEDED(hr))
    {
        o_pvarConnection->vt = VT_ARRAY | VT_VARIANT;
        o_pvarConnection->parray = psa;
    } else
        SafeArrayDestroy(psa);

    return S_OK;
}

STDMETHODIMP CReplicaSet::GetConnectionInfo( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT __RPC_FAR *o_pvarConnection)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);

    CFrsConnectionList::iterator it;
    for (it = m_frsConnectionList.begin(); it != m_frsConnectionList.end(); it++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*it)->m_bstrConnectionDN))
            break;
    }

    if (it == m_frsConnectionList.end())
        return S_FALSE;

    return _GetConnectionInfo((*it), o_pvarConnection);
}

STDMETHODIMP CReplicaSet::AddConnection( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable,
        /* [in] */ BOOL i_bSyncImmediately,
        /* [in] */ long i_nPriority,
        /* [retval][out] */ BSTR __RPC_FAR *o_pbstrConnectionDN)
{
    if (!lstrcmpi(i_bstrFromMemberDN, i_bstrToMemberDN))
        return S_OK;

    HRESULT hr = S_OK;

    //
    // is it an existing connection?
    //
    BOOL bIsFrsConnection = FALSE;
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
        {
            bIsFrsConnection = TRUE;
            break;
        }
    }
    if (bIsFrsConnection)
    {
        // connection exists, return info of it
        if (o_pbstrConnectionDN)
        {
            *o_pbstrConnectionDN = (*i)->m_bstrConnectionDN.Copy();
            RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrConnectionDN);
        }
        return hr;
    }

    //
    // locate the fromMember and the toMember in the m_frsMemberList
    //
    CFrsMemberList::iterator from;
    for (from = m_frsMemberList.begin(); from != m_frsMemberList.end(); from++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*from)->m_bstrMemberDN))
            break;
    }
    if (from == m_frsMemberList.end())
    {
        // fromServer is not a frsMember yet
        return E_INVALIDARG;
    }

    CFrsMemberList::iterator to;
    for (to = m_frsMemberList.begin(); to != m_frsMemberList.end(); to++)
    {
        if (!lstrcmpi(i_bstrToMemberDN, (*to)->m_bstrMemberDN))
            break;
    }
    if (to == m_frsMemberList.end())
    {
        // toServer is not a frsMember yet
        return E_INVALIDARG;
    }

    //
    // create the nTDSConnection object
    //
    CComBSTR bstrConnectionDN = _T("CN=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);
    bstrConnectionDN += (*from)->m_bstrServerGuid;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);
    bstrConnectionDN += _T(",");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);
    bstrConnectionDN += (*to)->m_bstrMemberDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrConnectionDN);

    DWORD dwOptions = (i_bSyncImmediately ? 0x80000000 : 0x0);
    switch (i_nPriority)
    {
    case 1:
    case 2:
        dwOptions |= (PRIORITY_HIGH << 28);
        break;
    case 3:
    case 4:
        dwOptions |= (PRIORITY_MEDIUM << 28);
        break;
    default:
        dwOptions |= (PRIORITY_LOW << 28);
        break;
    }

    hr = CreateNtdsConnectionObject(
            m_pldap,
            bstrConnectionDN,
            i_bstrFromMemberDN,
            i_bEnable,
            dwOptions
            );
    RETURN_IF_FAILED(hr);

    //
    // add to m_frsConnectionList
    //
    CFrsConnection* pFrsConnection = new CFrsConnection;
    RETURN_OUTOFMEMORY_IF_NULL(pFrsConnection);
    hr = pFrsConnection->Init(
                            bstrConnectionDN,  // FQDN
                            i_bstrFromMemberDN,  // fromServer
                            i_bEnable,         // enableConnection
                            dwOptions);
    if (FAILED(hr))
    {
        delete pFrsConnection;
        return hr;
    }

    m_frsConnectionList.push_back(pFrsConnection);

    //
    // if o_pbstrConnectionDN specified, return o_pbstrConnectionDN
    //
    if (o_pbstrConnectionDN)
        *o_pbstrConnectionDN = bstrConnectionDN.Detach();

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveConnection( 
        /* [in] */ BSTR i_bstrConnectionDN)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return hr; // no such connection, return

    //
    // delete the nTDSConnection object
    //
    hr = DeleteDSObject(m_pldap, (*i)->m_bstrConnectionDN, TRUE);
    RETURN_IF_FAILED(hr);

    //
    // remove it from m_frsConnectionList
    //
    delete (*i);
    m_frsConnectionList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveConnectionEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return hr; // no such connection, return

    //
    // delete the nTDSConnection object
    //
    hr = DeleteDSObject(m_pldap, (*i)->m_bstrConnectionDN, TRUE);
    RETURN_IF_FAILED(hr);

    //
    // remove it from m_frsConnectionList
    //
    delete (*i);
    m_frsConnectionList.erase(i);

    return hr;
}

STDMETHODIMP CReplicaSet::RemoveAllConnections()
{
    HRESULT hr = S_OK;

    CFrsConnectionList::iterator i = m_frsConnectionList.begin();
    while (i != m_frsConnectionList.end())
    {
        //
        // delete the nTDSConnection object
        //
        hr = DeleteDSObject(m_pldap, (*i)->m_bstrConnectionDN, TRUE);
        BREAK_IF_FAILED(hr);

        //
        // remove it from m_frsConnectionList
        //
        delete (*i);
        m_frsConnectionList.erase(i);

        i = m_frsConnectionList.begin();
    }

    return hr;
}

HRESULT CReplicaSet::_RemoveConnectionsFromAndTo(CFrsMember* pFrsMember)
{
    RETURN_INVALIDARG_IF_NULL(pFrsMember);

    HRESULT hr = S_OK;

    CFrsConnectionList::iterator i = m_frsConnectionList.begin();
    while (i != m_frsConnectionList.end())
    {
        CFrsConnectionList::iterator itConn = i++;
        if (!lstrcmpi(pFrsMember->m_bstrMemberDN, (*itConn)->m_bstrFromMemberDN) ||
            !lstrcmpi(pFrsMember->m_bstrMemberDN, (*itConn)->m_bstrToMemberDN))
        {
            //
            // delete the nTDSConnection object
            //
            hr = DeleteDSObject(m_pldap, (*itConn)->m_bstrConnectionDN, TRUE);
            RETURN_IF_FAILED(hr);

            //
            // remove it from m_frsConnectionList
            //
            delete (*itConn);
            m_frsConnectionList.erase(itConn);
        }
    }

    return hr;
}

STDMETHODIMP CReplicaSet::EnableConnection( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ BOOL i_bEnable)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    //
    // update attribute enabledConnection of this nTDSConnection object
    //
    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_ENABLEDCONNECTION;
    pAttrVals[0].vpValue = (void *)(i_bEnable ? CONNECTION_ENABLED_TRUE : CONNECTION_ENABLED_FALSE);
    pAttrVals[0].bBerValue = false;

    hr = ::ModifyValues(m_pldap, (*i)->m_bstrConnectionDN, 1, pAttrVals);

    //
    // update i in the m_frsConnectionList
    //
    if (SUCCEEDED(hr))
        (*i)->m_bEnable = i_bEnable;

    return hr;
}

STDMETHODIMP CReplicaSet::EnableConnectionEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bEnable)
{
    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    //
    // update attribute enabledConnection of this nTDSConnection object
    //
    LDAP_ATTR_VALUE  pAttrVals[1];
    pAttrVals[0].bstrAttribute = ATTR_NTDS_CONNECTION_ENABLEDCONNECTION;
    pAttrVals[0].vpValue = (void *)(i_bEnable ? CONNECTION_ENABLED_TRUE : CONNECTION_ENABLED_FALSE);
    pAttrVals[0].bBerValue = false;

    hr = ::ModifyValues(m_pldap, (*i)->m_bstrConnectionDN, 1, pAttrVals);

    //
    // update i in the m_frsConnectionList
    //
    if (SUCCEEDED(hr))
        (*i)->m_bEnable = i_bEnable;

    return hr;
}

HRESULT CReplicaSet::_GetConnectionSchedule( 
        /* [in] */ BSTR                 i_bstrConnectionDN,
        /* [retval][out] */ VARIANT*    o_pVar)
{
    //
    // get attribute schedule of this nTDSConnection object
    //
    PLDAP_ATTR_VALUE    pValues[2] = {0,0};
    LDAP_ATTR_VALUE     pAttributes[1];
    pAttributes[0].bstrAttribute = ATTR_NTDS_CONNECTION_SCHEDULE;
    pAttributes[0].bBerValue = true;

    HRESULT hr = GetValues( m_pldap,
                    i_bstrConnectionDN,
                    OBJCLASS_SF_NTDSCONNECTION,
                    LDAP_SCOPE_BASE,
                    1,
                    pAttributes,
                    pValues);

    if (SUCCEEDED(hr) && pValues[0])
    {
        hr = ScheduleToVariant((SCHEDULE *)(pValues[0]->vpValue), o_pVar);

        FreeAttrValList(pValues[0]);
    
    } else if (!(pValues[0]) || HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED) == hr)
    {
        SCHEDULE *pSchedule = NULL;
        hr = GetDefaultSchedule(&pSchedule);
        if (SUCCEEDED(hr))
        {
            hr = ScheduleToVariant(pSchedule, o_pVar);
            free(pSchedule);
        }
    }

    return hr;
}

STDMETHODIMP CReplicaSet::GetConnectionSchedule( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [retval][out] */ VARIANT* o_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(o_pVar);

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    return _GetConnectionSchedule(i_bstrConnectionDN, o_pVar);
}

STDMETHODIMP CReplicaSet::GetConnectionScheduleEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [retval][out] */ VARIANT* o_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrToMemberDN);
    RETURN_INVALIDARG_IF_NULL(o_pVar);

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    return _GetConnectionSchedule((*i)->m_bstrConnectionDN, o_pVar);
}

STDMETHODIMP CReplicaSet::SetConnectionSchedule( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ VARIANT* i_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_pVar);

    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    SCHEDULE *pSchedule = NULL;
    hr = VariantToSchedule(i_pVar, &pSchedule);
    RETURN_IF_FAILED(hr);

    hr = ::SetConnectionSchedule(m_pldap, (*i)->m_bstrConnectionDN, pSchedule);

    free(pSchedule);

    return hr;
}

STDMETHODIMP CReplicaSet::SetConnectionScheduleEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ VARIANT* i_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrToMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_pVar);

    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    SCHEDULE *pSchedule = NULL;
    hr = VariantToSchedule(i_pVar, &pSchedule);
    RETURN_IF_FAILED(hr);

    hr = ::SetConnectionSchedule(m_pldap, (*i)->m_bstrConnectionDN, pSchedule);

    free(pSchedule);

    return hr;
}

STDMETHODIMP CReplicaSet::SetScheduleOnAllConnections( 
        /* [in] */ VARIANT* i_pVar)
{
    RETURN_INVALIDARG_IF_NULL(i_pVar);

    HRESULT hr = S_OK;

    SCHEDULE *pSchedule = NULL;
    hr = VariantToSchedule(i_pVar, &pSchedule);
    RETURN_IF_FAILED(hr);

    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        hr = ::SetConnectionSchedule(m_pldap, (*i)->m_bstrConnectionDN, pSchedule);
        BREAK_IF_FAILED(hr);
    }

    free(pSchedule);

    return hr;
}

STDMETHODIMP CReplicaSet::SetConnectionOptions( 
        /* [in] */ BSTR i_bstrConnectionDN,
        /* [in] */ BOOL i_bSyncImmediately,
        /* [in] */ long i_nPriority)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);

    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrConnectionDN, (*i)->m_bstrConnectionDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    DWORD dwOptions = (i_bSyncImmediately ? 0x80000000 : 0x0);
    switch (i_nPriority)
    {
    case 1:
    case 2:
        dwOptions |= (PRIORITY_HIGH << 28);
        break;
    case 3:
    case 4:
        dwOptions |= (PRIORITY_MEDIUM << 28);
        break;
    default:
        dwOptions |= (PRIORITY_LOW << 28);
        break;
    }

    hr = ::SetConnectionOptions(m_pldap, (*i)->m_bstrConnectionDN, dwOptions);

    if (SUCCEEDED(hr))
    {
        //
        // update m_dwOptions in the m_frsConnectionList
        //
        if (SUCCEEDED(hr))
            (*i)->m_dwOptions = dwOptions;
    }

    return hr;
}

STDMETHODIMP CReplicaSet::SetConnectionOptionsEx( 
        /* [in] */ BSTR i_bstrFromMemberDN,
        /* [in] */ BSTR i_bstrToMemberDN,
        /* [in] */ BOOL i_bSyncImmediately,
        /* [in] */ long i_nPriority)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrToMemberDN);

    HRESULT hr = S_OK;

    //
    // locate connection in the m_frsConnectionList
    //
    CFrsConnectionList::iterator i;
    for (i = m_frsConnectionList.begin(); i != m_frsConnectionList.end(); i++)
    {
        if (!lstrcmpi(i_bstrFromMemberDN, (*i)->m_bstrFromMemberDN) &&
            !lstrcmpi(i_bstrToMemberDN, (*i)->m_bstrToMemberDN))
            break;
    }
    if (i == m_frsConnectionList.end())
        return E_INVALIDARG; // no such conneciton, return error

    DWORD dwOptions = (i_bSyncImmediately ? 0x80000000 : 0x0);
    switch (i_nPriority)
    {
    case 1:
    case 2:
        dwOptions |= (PRIORITY_HIGH << 28);
        break;
    case 3:
    case 4:
        dwOptions |= (PRIORITY_MEDIUM << 28);
        break;
    default:
        dwOptions |= (PRIORITY_LOW << 28);
        break;
    }

    hr = ::SetConnectionOptions(m_pldap, (*i)->m_bstrConnectionDN, dwOptions);

    if (SUCCEEDED(hr))
    {
        //
        // update m_dwOptions in the m_frsConnectionList
        //
        if (SUCCEEDED(hr))
            (*i)->m_dwOptions = dwOptions;
    }

    return hr;
}

STDMETHODIMP CReplicaSet::CreateConnections()
{
    HRESULT hr = S_OK;

    //
    // create connections from scratch
    //
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM))
        return hr;

    CFrsMemberList::iterator n1;
    CFrsMemberList::iterator n2;
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_RING))
    {
        //
        // sort member list on Site, such that members on the same site will be neighbors
        //
        m_frsMemberList.sort(FrsMemberCompare());

        CFrsMemberList::iterator head;

        head = n1 = m_frsMemberList.begin();
        while (n1 != m_frsMemberList.end())
        {
            n2 = n1++;
            if (n1 == m_frsMemberList.end())
            {
                if (m_frsMemberList.size() == 2)
                    break;

                n1 = head;
            }

            hr = AddConnection((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            BREAK_IF_FAILED(hr);
            hr = AddConnection((*n2)->m_bstrMemberDN, (*n1)->m_bstrMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            BREAK_IF_FAILED(hr);

            if (n1 == head)
                break;
        }
    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
        {
            if (!lstrcmpi((*n1)->m_bstrMemberDN, m_bstrHubMemberDN))
                continue;

            hr = AddConnection((*n1)->m_bstrMemberDN, m_bstrHubMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            BREAK_IF_FAILED(hr);
            hr = AddConnection(m_bstrHubMemberDN, (*n1)->m_bstrMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            BREAK_IF_FAILED(hr);
        }
    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_FULLMESH))
    {
        for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
        {
            for (n2 = m_frsMemberList.begin(); n2 != m_frsMemberList.end(); n2++)
            {
                if (!lstrcmpi((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN))
                    continue;

                hr = AddConnection((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
                BREAK_IF_FAILED(hr);
            }
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}

STDMETHODIMP CReplicaSet::Delete()
{
    dfsDebugOut((_T("Delete ReplicaSet: %s\n"), m_bstrReplicaSetDN));

    HRESULT hr = S_OK;

    //
    // delete all connections
    //
    hr = RemoveAllConnections();
    RETURN_IF_FAILED(hr);

    //
    // delete all members
    //
    // Note: the nTFRSReplicaSet object will be deleted if empty
    //
    hr = RemoveAllMembers();
    RETURN_IF_FAILED(hr);

    //
    // delete nTFRSReplicaSettings container objects if empty
    //
    (void) DeleteNtfrsReplicaSetObjectAndContainers(m_pldap, m_bstrReplicaSetDN);

    //
    // Reset this instance
    //
    _FreeMemberVariables();

    return hr;
}

HRESULT CReplicaSet::_SetCustomTopologyPref()
{
    HRESULT hr = put_TopologyPref(FRS_RSTOPOLOGYPREF_CUSTOM);

    if (SUCCEEDED(hr))
        hr = put_HubMemberDN(_T(""));

    return hr;
}

HRESULT CReplicaSet::_AdjustConnectionsAdd(BSTR i_bstrNewMemberDN, BSTR i_bstrSite)
{
    RETURN_INVALIDARG_IF_NULL(i_bstrNewMemberDN);

    HRESULT hr = S_OK;

    //
    // adjust connections after pFrsMember is added
    //
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM) || m_frsMemberList.empty())
        return hr;

    if (m_frsMemberList.size() == 2)
    {
        CFrsMemberList::iterator head = m_frsMemberList.begin();
        hr = AddConnection((*head)->m_bstrMemberDN, i_bstrNewMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        if (SUCCEEDED(hr))
            hr = AddConnection(i_bstrNewMemberDN, (*head)->m_bstrMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        return hr;
    }

    CFrsMemberList::iterator n1;
    CFrsMemberList::iterator n2;
    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_RING))
    {
        CComBSTR bstrMemberDN1;
        CComBSTR bstrMemberDN2;

        CFrsConnectionList::iterator conn;

        if (i_bstrSite && *i_bstrSite)
        {
            for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
            {
                if (!lstrcmpi((*n1)->m_bstrSite, i_bstrSite) &&         // has the same site as the new member
                    lstrcmpi((*n1)->m_bstrMemberDN, i_bstrNewMemberDN)) // different from the new member
                {
                    //
                    // see if there is an existing connection from/to this member n1
                    //
                    for (conn = m_frsConnectionList.begin(); conn != m_frsConnectionList.end(); conn++)
                    {
                        if (!lstrcmpi((*n1)->m_bstrMemberDN, (*conn)->m_bstrFromMemberDN))
                        {
                            bstrMemberDN1 = (*n1)->m_bstrMemberDN;
                            bstrMemberDN2 = (*conn)->m_bstrToMemberDN;
                            break;
                        } else if (!lstrcmpi((*n1)->m_bstrMemberDN, (*conn)->m_bstrToMemberDN))
                        {
                            bstrMemberDN1 = (*n1)->m_bstrMemberDN;
                            bstrMemberDN2 = (*conn)->m_bstrFromMemberDN;
                            break;
                        }
                    }

                    if ((BSTR)bstrMemberDN1 && (BSTR)bstrMemberDN2)
                        break;  // we've located the insertion point
                }
            }
        }

        if (!bstrMemberDN1 || !bstrMemberDN2)
        {
            //
            // locate an existing connection, if any
            //
            if (m_frsConnectionList.empty())
            {
                n1 = m_frsMemberList.begin();
                n2 = n1++;

                bstrMemberDN1 = (*n1)->m_bstrMemberDN;
                bstrMemberDN2 = (*n2)->m_bstrMemberDN;
            } else
            {
                conn = m_frsConnectionList.begin();
                bstrMemberDN1 = (*conn)->m_bstrFromMemberDN;
                bstrMemberDN2 = (*conn)->m_bstrToMemberDN;
            }
        }

        hr = AddConnection(bstrMemberDN1, i_bstrNewMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(i_bstrNewMemberDN, bstrMemberDN1, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(bstrMemberDN2, i_bstrNewMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(i_bstrNewMemberDN, bstrMemberDN2, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        RETURN_IF_FAILED(hr);

        if (m_frsMemberList.size() > 3)
        {
            hr = RemoveConnectionEx(bstrMemberDN2, bstrMemberDN1);
            RETURN_IF_FAILED(hr);
            hr = RemoveConnectionEx(bstrMemberDN1, bstrMemberDN2);
            RETURN_IF_FAILED(hr);
        }

    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        hr = AddConnection(i_bstrNewMemberDN, m_bstrHubMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        RETURN_IF_FAILED(hr);
        hr = AddConnection(m_bstrHubMemberDN, i_bstrNewMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
        RETURN_IF_FAILED(hr);

    } else if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_FULLMESH))
    {
        for (n1 = m_frsMemberList.begin(); n1 != m_frsMemberList.end(); n1++)
        {
            hr = AddConnection((*n1)->m_bstrMemberDN, i_bstrNewMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            BREAK_IF_FAILED(hr);
            hr = AddConnection(i_bstrNewMemberDN, (*n1)->m_bstrMemberDN, TRUE, FALSE, (long)PRIORITY_LOW, NULL);
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  _FreeMemberVariables

void FreeDfsAlternates(CDfsAlternateList* pList)
{
    if (pList && !pList->empty())
    {
        for (CDfsAlternateList::iterator i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}

void FreeFrsMembers(CFrsMemberList* pList)
{
    if (pList && !pList->empty())
    {
        for (CFrsMemberList::iterator i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}

void FreeFrsConnections(CFrsConnectionList* pList)
{
    if (pList && !pList->empty())
    {
        for (CFrsConnectionList::iterator i = pList->begin(); i != pList->end(); i++)
            delete (*i);

        pList->clear();
    }
}

void CReplicaSet::_FreeMemberVariables()
{
    m_bstrType.Empty();
    m_bstrTopologyPref.Empty();

    m_bstrHubMemberDN.Empty();
    m_bstrPrimaryMemberDN.Empty();
    m_bstrFileFilter.Empty();
    m_bstrDirFilter.Empty();
    m_bstrDfsEntryPath.Empty();
    m_bstrReplicaSetDN.Empty();

    FreeDfsAlternates(&m_dfsAlternateList);
    FreeFrsMembers(&m_frsMemberList);
    FreeFrsConnections(&m_frsConnectionList);

    m_bstrDomain.Empty();
    m_bstrDomainGuid.Empty();
    m_bstrDC.Empty();
    m_bNewSchema = FALSE;

    if (m_pldap)
    {
        CloseConnectionToDS(m_pldap);
        m_pldap = NULL;
    }
}

///////////////////////////////////////////////////////////////////
//
// CFrsMember
//

HRESULT CFrsMember::InitEx(
    PLDAP   i_pldap,                // points to the i_bstrMemberDN's DS
    BSTR    i_bstrDC,               // domain controller pointed by i_pldap
    BSTR    i_bstrMemberDN,         // FQDN of nTFRSMember object
    BSTR    i_bstrComputerDN        // =NULL, FQDN of computer object
)
{
    _ReSet();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDC);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);

    HRESULT hr = S_OK;

    do {
        m_bstrMemberDN = i_bstrMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrMemberDN, &hr);

        if (i_bstrComputerDN && *i_bstrComputerDN)
        {
            m_bstrComputerDN = i_bstrComputerDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrComputerDN, &hr);
        }

        hr = _GetMemberInfo(i_pldap, i_bstrDC, m_bstrMemberDN, m_bstrComputerDN);
    } while (0);

    if (S_OK != hr)
        _ReSet();

    return hr; 
}

HRESULT CFrsMember::Init(
    IN BSTR i_bstrDnsHostName,
    IN BSTR i_bstrComputerDomain,
    IN BSTR i_bstrComputerGuid,
    IN BSTR i_bstrRootPath,
    IN BSTR i_bstrStagingPath,
    IN BSTR i_bstrMemberDN,
    IN BSTR i_bstrComputerDN,
    IN BSTR i_bstrSubscriberDN
    )
{
    _ReSet();

    RETURN_INVALIDARG_IF_NULL(i_bstrDnsHostName);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDomain);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerGuid);
    RETURN_INVALIDARG_IF_NULL(i_bstrRootPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrStagingPath);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrSubscriberDN);

    HRESULT hr = S_OK;
    do {
        hr = GetSiteName(i_bstrDnsHostName, &m_bstrSite);
        BREAK_IF_FAILED(hr);

        m_bstrServer = i_bstrDnsHostName;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServer, &hr);

        m_bstrDomain = i_bstrComputerDomain;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

        m_bstrServerGuid = i_bstrComputerGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServerGuid, &hr);

        m_bstrRootPath = i_bstrRootPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrRootPath, &hr);

        m_bstrStagingPath = i_bstrStagingPath;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStagingPath, &hr);

        m_bstrMemberDN = i_bstrMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrMemberDN, &hr);

        m_bstrComputerDN = i_bstrComputerDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrComputerDN, &hr);

        m_bstrSubscriberDN = i_bstrSubscriberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSubscriberDN, &hr);
    } while (0);

    if (FAILED(hr))
        _ReSet();

    return hr;
}

CFrsMember* CFrsMember::Copy()
{
    CFrsMember* pNew = new CFrsMember;
    
    if (pNew)
    {
        HRESULT hr = S_OK;

        do {
            pNew->m_bstrServer = m_bstrServer;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrServer, &hr);
            pNew->m_bstrSite = m_bstrSite;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrSite, &hr);
            pNew->m_bstrDomain = m_bstrDomain;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrDomain, &hr);
            pNew->m_bstrServerGuid = m_bstrServerGuid;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrServerGuid, &hr);

            pNew->m_bstrRootPath = m_bstrRootPath;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrRootPath, &hr);
            pNew->m_bstrStagingPath = m_bstrStagingPath;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrStagingPath, &hr);

            pNew->m_bstrMemberDN = m_bstrMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrMemberDN, &hr);
            pNew->m_bstrComputerDN = m_bstrComputerDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrComputerDN, &hr);
            pNew->m_bstrSubscriberDN = m_bstrSubscriberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrSubscriberDN, &hr);
        } while (0);

        if (FAILED(hr))
        {
            delete pNew;
            pNew = NULL;
        }
    }

    return pNew;
}

void CFrsMember::_ReSet()
{
    m_bstrServer.Empty();
    m_bstrSite.Empty();
    m_bstrDomain.Empty();
    m_bstrServerGuid.Empty();

    m_bstrRootPath.Empty();
    m_bstrStagingPath.Empty();

    m_bstrMemberDN.Empty();
    m_bstrComputerDN.Empty();
    m_bstrSubscriberDN.Empty();
}

//
// Given: MemberDN
// Read: ComputerDN, Domain, Site, ServerName 
//
// Return:
//      S_FALSE if no such object found
//
HRESULT CFrsMember::_GetMemberInfo
(
    PLDAP   i_pldap,            // points to the i_bstrMemberDN's DS
    BSTR    i_bstrDC,           // domain controller pointed by i_pldap
    BSTR    i_bstrMemberDN,     // FQDN of nTFRSMember object
    BSTR    i_bstrComputerDN    // = NULL FQDN of computer object
)
{
    m_bstrDomain.Empty();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrDC);
    RETURN_INVALIDARG_IF_NULL(*i_bstrDC);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrMemberDN);

    HRESULT hr = S_OK;

    do {
        if (!i_bstrComputerDN || !*i_bstrComputerDN)
        {
            m_bstrComputerDN.Empty();

            //
            // Read:
            //      m_bstrComputerDN
            //
            PLDAP_ATTR_VALUE  pValues[2] = {0,0};
            LDAP_ATTR_VALUE  pAttributes[1];
            pAttributes[0].bstrAttribute = ATTR_FRS_MEMBER_COMPUTERREF;

            hr = GetValues( i_pldap,
                            m_bstrMemberDN,
                            OBJCLASS_SF_NTFRSMEMBER,
                            LDAP_SCOPE_BASE,
                            1,
                            pAttributes,
                            pValues);
            BREAK_IF_FAILED(hr);

            hr = E_FAIL;
            if (pValues[0])
            {
                m_bstrComputerDN = (PTSTR)(pValues[0]->vpValue);
                hr = (!m_bstrComputerDN) ? E_OUTOFMEMORY : S_OK;

                FreeAttrValList(pValues[0]);
            }

            BREAK_IF_FAILED(hr);
        }

        //
        // retrieve the domain for both ComputerDN and i_bstrMemberDN
        // If they are the same, reuse the handle to the LDAP port; 
        // otherwise, open a new handle.
        //
        // Read:
        //      m_bstrDomainDN
        //
        BOOL    bSameDomain = FALSE;
        HANDLE  hDS = NULL;
        DWORD   dwErr = DsBind(i_bstrDC, NULL, &hDS);
        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

        const PTSTR         pszFQDNs[2] = {(BSTR)m_bstrComputerDN, i_bstrMemberDN};
        DS_NAME_RESULT*     pDsNameResult = NULL;
        dwErr = DsCrackNames(
                            hDS,
                            DS_NAME_NO_FLAGS,
                            DS_FQDN_1779_NAME,
                            DS_CANONICAL_NAME,
                            2,
                            pszFQDNs,
                            &pDsNameResult
                            );
        if (NO_ERROR == dwErr)
        {
            do {
                PDS_NAME_RESULT_ITEM pItem = pDsNameResult->rItems;

                if (DS_NAME_NO_ERROR != pItem->status)
                {
                    dwErr = pItem->status;
                } else
                {
                    // retrieve info of m_bstrComputerDN
                    m_bstrDomain = pItem->pDomain;
                    BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDomain, &hr);

                    // retrieve info of i_bstrMemberDN
                    pItem++;
                    if (DS_NAME_NO_ERROR != pItem->status)
                    {
                        dwErr = pItem->status;
                    } else
                    {
                        bSameDomain = !mylstrncmpi(m_bstrDomain, pItem->pDomain, lstrlen(m_bstrDomain));
                    }
                }
            } while (0);

            DsFreeNameResult(pDsNameResult);
        }

        DsUnBind(&hDS);

        if (NO_ERROR != dwErr)
        {
            hr = HRESULT_FROM_WIN32(dwErr);
            break;
        }

        //
        // Create a new ldap handle if not in the same domain
        //
        PLDAP pldapComputer = NULL;
        if (bSameDomain)
            pldapComputer = i_pldap;
        else
        {
            hr = ConnectToDS(m_bstrDomain, &pldapComputer);
            BREAK_IF_FAILED(hr);
        }

        //
        // Read:
        //      m_bstrSubscriberDN, m_bstrRootPath, m_bstrStagingPath
        //
        hr = _GetSubscriberInfo(pldapComputer, m_bstrComputerDN, i_bstrMemberDN);

        //
        // Read:
        //      m_bstrServer, m_bstrServerGuid, m_bstrSite
        //
        if (S_OK == hr)
            hr = _GetComputerInfo(pldapComputer, m_bstrComputerDN);

        //
        // Close the newly created ldap handle
        //
        if (!bSameDomain)
            CloseConnectionToDS(pldapComputer);
    } while (0);

    if (S_OK != hr)
    {
        if (!i_bstrComputerDN || !*i_bstrComputerDN)
            m_bstrComputerDN.Empty();

        m_bstrDomain.Empty();
    }

    return hr;
}

//
// Given: ComputerDN, MemberDN
// Read:
//      m_bstrSubscriberDN, m_bstrRootPath, m_bstrStagingPath
//
// Return:
//      S_FALSE if no such object found
//
HRESULT CFrsMember::_GetSubscriberInfo
(
    PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
    BSTR    i_bstrComputerDN,   // FQDN of the computer object
    BSTR    i_bstrMemberDN      // FQDN of the corresponding nTFRSMember object
)
{
    m_bstrSubscriberDN.Empty();
    m_bstrRootPath.Empty();
    m_bstrStagingPath.Empty();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrMemberDN);

    //
    // locate the nTFRSSubscriber object whose attribute "frsMemberReference"
    // matches i_bstrMemberDN
    //
    CComBSTR bstrSearchFilter = _T("(&(objectCategory=nTFRSSubscriber)(frsMemberReference=");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSearchFilter);
    bstrSearchFilter += i_bstrMemberDN;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSearchFilter);
    bstrSearchFilter += _T("))");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrSearchFilter);

    PCTSTR ppszAttributes[] = {
                                ATTR_DISTINGUISHEDNAME,
                                ATTR_FRS_SUBSCRIBER_ROOTPATH,
                                ATTR_FRS_SUBSCRIBER_STAGINGPATH,
                                0
                                };

    LListElem* pElem = NULL;
    HRESULT hr = GetValuesEx(
                            i_pldap,
                            i_bstrComputerDN,
                            LDAP_SCOPE_SUBTREE,
                            bstrSearchFilter,
                            ppszAttributes,
                            &pElem);
    RETURN_IF_FAILED(hr);
    if (!pElem) // no matching nTFRSSubscriber object
        return S_FALSE;

    LListElem* pCurElem = pElem;
    while (pCurElem)
    {
        PTSTR** pppszValues = pCurElem->pppszAttrValues;
        if (!pppszValues ||
            !pppszValues[0] || !*(pppszValues[0]) ||
            !pppszValues[1] || !*(pppszValues[1]) ||
            !pppszValues[2] || !*(pppszValues[2]))
        {
            pCurElem = pCurElem->Next;
            continue; // corrupted subscriber object
        }

        m_bstrSubscriberDN = *(pppszValues[0]);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSubscriberDN, &hr);
        m_bstrRootPath = *(pppszValues[1]);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrRootPath, &hr);
        m_bstrStagingPath = *(pppszValues[2]);
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrStagingPath, &hr);

        pCurElem = pCurElem->Next;
    }

    FreeLListElem(pElem);

    if (FAILED(hr))
    {
        m_bstrSubscriberDN.Empty();
        m_bstrRootPath.Empty();
        m_bstrStagingPath.Empty();
    }

    return hr;
}

//
// Given: ComputerDN
// Read:  m_bstrServer, m_bstrServerGuid, m_bstrSite
//
HRESULT CFrsMember::_GetComputerInfo
(
    PLDAP   i_pldap,            // points to the i_bstrComputerDN's DS
    BSTR    i_bstrComputerDN    // FQDN of the computer object
)
{
    m_bstrServer.Empty();
    m_bstrServerGuid.Empty();
    m_bstrSite.Empty();

    RETURN_INVALIDARG_IF_NULL(i_pldap);
    RETURN_INVALIDARG_IF_NULL(i_bstrComputerDN);
    RETURN_INVALIDARG_IF_NULL(*i_bstrComputerDN);

    HRESULT hr = S_OK;

    do {
        //
        // read dNSHostName and objectGUID on the ComputerDN
        //
        PLDAP_ATTR_VALUE    pValues[3] = {0,0,0};
        LDAP_ATTR_VALUE     pAttributes[2];
        pAttributes[0].bstrAttribute = ATTR_DNSHOSTNAME;
        pAttributes[1].bstrAttribute = ATTR_OBJECTGUID;
        pAttributes[1].bBerValue = true;

        hr = GetValues( i_pldap,
                        i_bstrComputerDN,
                        OBJCLASS_SF_COMPUTER,
                        LDAP_SCOPE_BASE,
                        2,
                        pAttributes,
                        pValues);
        BREAK_IF_FAILED(hr);

        hr = E_FAIL;
        if (pValues[0])
        {
            m_bstrServer = (PTSTR)(pValues[0]->vpValue);
            hr = (!m_bstrServer) ? E_OUTOFMEMORY : S_OK;

            FreeAttrValList(pValues[0]);
        }

        if (pValues[1])
        {
            if (SUCCEEDED(hr))
            {
                if (pValues[1]->bBerValue)
                {
                    hr = UuidToStructuredString((UUID*)(pValues[1]->vpValue), &m_bstrServerGuid);
                } else
                {
                    m_bstrServerGuid = (PTSTR)(pValues[1]->vpValue);
                    hr = (!m_bstrServerGuid) ? E_OUTOFMEMORY : S_OK;
                }
            }

            FreeAttrValList(pValues[1]);
        }

        BREAK_IF_FAILED(hr);

        //
        // retrieve Site
        //
        hr = GetSiteName(m_bstrServer, &m_bstrSite);
        BREAK_IF_FAILED(hr);

    } while (0);

    if (FAILED(hr))
    {
        m_bstrServer.Empty();
        m_bstrServerGuid.Empty();
        m_bstrSite.Empty();
    }

    return hr;
}

//////////////////////////////////////////////////////////
//
// CFrsConnection
//

HRESULT CFrsConnection::Init(
    BSTR i_bstrConnectionDN,
    BSTR i_bstrFromMemberDN,
    BOOL i_bEnable,
    DWORD i_dwOptions)
{
    _ReSet();

    RETURN_INVALIDARG_IF_NULL(i_bstrConnectionDN);
    RETURN_INVALIDARG_IF_NULL(i_bstrFromMemberDN);

    HRESULT hr = S_OK;
    do {
        m_bstrConnectionDN = i_bstrConnectionDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrConnectionDN, &hr);

        m_bstrFromMemberDN = i_bstrFromMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromMemberDN, &hr);

        TCHAR* p = _tcschr(m_bstrConnectionDN, _T(','));
        if (!p)
        {
            hr = E_INVALIDARG;
            break;
        }
        m_bstrToMemberDN = p + 1;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToMemberDN, &hr);

        m_bEnable = i_bEnable;

        m_dwOptions = i_dwOptions;
    } while (0);

    if (FAILED(hr))
        _ReSet();

    return hr;
}

CFrsConnection* CFrsConnection::Copy()
{
    CFrsConnection* pNew = new CFrsConnection;
    
    if (pNew)
    {
        HRESULT hr = S_OK;

        do {
            pNew->m_bstrConnectionDN = m_bstrConnectionDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrConnectionDN, &hr);
            pNew->m_bstrFromMemberDN = m_bstrFromMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrFromMemberDN, &hr);
            pNew->m_bstrToMemberDN = m_bstrToMemberDN;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)pNew->m_bstrToMemberDN, &hr);

            pNew->m_bEnable = m_bEnable;

            pNew->m_dwOptions = m_dwOptions;
        } while (0);

        if (FAILED(hr))
        {
            delete pNew;
            pNew = NULL;
        }
    }

    return pNew;
}

void CFrsConnection::_ReSet()
{
    m_bstrConnectionDN.Empty();
    m_bstrFromMemberDN.Empty();
    m_bstrToMemberDN.Empty();

    m_bEnable = TRUE;

    m_dwOptions = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\addrep.h ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the declaration of the CAddRep.
  This class displays the Add Replica Dialog,which is used to add new Replica.

*/

#ifndef __ADDREP_H_
#define __ADDREP_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"

/////////////////////////////////////////////////////////////////////////////
// CAddRep
class CAddRep : 
  public CDialogImpl<CAddRep>
{
public:
  CAddRep();
  ~CAddRep();

  enum { IDD = IDD_ADDREP };
  typedef enum REPLICATION_TYPE 
  {
    REPLICATION_UNASSIGNED = 0,
    NO_REPLICATION,
    NORMAL_REPLICATION,
    STAGED_REPLICATION,
    IMMEDIATE_REPLICATION
  };

BEGIN_MSG_MAP(CAddRep)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
  COMMAND_ID_HANDLER(IDC_BUTTONNETBROWSE, OnNetBrowse)
END_MSG_MAP()

//  Command Handlers
  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnNetBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

//  Methods to access data in the dialog.
  HRESULT put_EntryPath(BSTR i_bstrParent);
  HRESULT get_NetPath(BSTR *o_bstrNetPath);
  HRESULT get_Server(BSTR *o_bstrServer);
  HRESULT get_Share(BSTR *o_bstrShare);
  REPLICATION_TYPE get_ReplicationType(VOID);

// Method to specify Dfs type.
  void  put_DfsType(DFS_TYPE  i_DfsType)
  {
    m_DfsType = i_DfsType;
  }

protected:
  CComBSTR  m_BrowseNetLabel;
  CComBSTR  m_bstrEntryPath;
  CComBSTR  m_bstrNetPath;
  CComBSTR  m_bstrServer;
  CComBSTR  m_bstrShare;

  REPLICATION_TYPE m_RepType;
  DFS_TYPE  m_DfsType;
};

#endif //__ADDREP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\addrep.cpp ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the Implementation of CAddRep.
  This class displays the Add Replica Dialog,which is used to add new Replica.

*/

#include "stdafx.h"
#include "AddRep.h"
#include "utils.h"
#include <shlobj.h>
#include <dsclient.h>
#include "dfshelp.h"

/////////////////////////////////////////////////////////////////////////////
// CAddRep

CAddRep::CAddRep() : m_RepType(REPLICATION_UNASSIGNED),
                    m_DfsType(DFS_TYPE_UNASSIGNED)
{
}

CAddRep::~CAddRep()
{
}


HRESULT CAddRep::put_EntryPath
(
  BSTR i_bstrEntryPath
)
{
/*++

Routine Description:

  Sets the path of the Junction point of this replica
  This is used to display in the edit text.

Arguments:

  i_bstrEntryPath  -  The junction point entry path.

*/

  RETURN_INVALIDARG_IF_NULL(i_bstrEntryPath);

  m_bstrEntryPath = i_bstrEntryPath;
  RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrEntryPath);

  return S_OK;
}


HRESULT CAddRep::get_Server
(
  BSTR *o_pbstrServer
)
{
/*++

Routine Description:

  Returns the server component of the share path.

Arguments:

  o_pbstrServer  -  The server name is returned here.

*/
    GET_BSTR(m_bstrServer, o_pbstrServer);
}



HRESULT CAddRep::get_Share
(
  BSTR *o_pbstrShare
)
{
/*++

Routine Description:

  Returns the share component of the share path.

Arguments:

  o_pbstrShare  -  The share name is returned here.

*/
    GET_BSTR(m_bstrShare, o_pbstrShare);
}

HRESULT CAddRep::get_NetPath
(
  BSTR *o_pbstrNetPath
)
{
/*++

Routine Description:

  Returns the complete share path typed in by the user in the edit box.

Arguments:

  o_pbstrNetPath  -  The share path is returned here.

*/
    GET_BSTR(m_bstrNetPath, o_pbstrNetPath);
}

LRESULT CAddRep::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
  SetDlgItemText(IDC_EDIT_ADDREP_DFSLINK_PATH, m_bstrEntryPath);

  ::SendMessage(GetDlgItem(IDC_EDITNETPATH), EM_LIMITTEXT, MAX_PATH, 0);

          // Disable replication button for Std Dfs.
  if (DFS_TYPE_FTDFS != m_DfsType)
  {
    ::EnableWindow(GetDlgItem(IDC_ADDREP_REPLICATE), FALSE);
  } else
  {
          // Check "replication" as default
    CheckDlgButton(IDC_ADDREP_REPLICATE, BST_CHECKED);
  }

  return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CAddRep::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDREP);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CAddRep::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDREP);

  return TRUE;
}

LRESULT CAddRep::OnNetBrowse
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  CComBSTR  bstrPath;
  HRESULT   hr = BrowseNetworkPath(hWndCtl, &bstrPath);

  if (S_OK == hr)
  {
    SetDlgItemText(IDC_EDITNETPATH, bstrPath);
    ::SetFocus(GetDlgItem(IDC_ADDREP_REPLICATE));
  }

  if (S_FALSE == hr)
    ::SetFocus(GetDlgItem(IDC_EDITNETPATH));

  return (SUCCEEDED(hr));
}

LRESULT CAddRep::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  BOOL      bValidInput = FALSE;
  int       idString = 0;
  HRESULT   hr = S_OK;

  do {
    CWaitCursor wait;

    DWORD     dwTextLength = 0;

    m_bstrNetPath.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITNETPATH), &m_bstrNetPath, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_FIELD;
      break;
    }

    m_bstrServer.Empty();
    m_bstrShare.Empty();
    if (!ValidateNetPath(m_bstrNetPath, &m_bstrServer, &m_bstrShare))
      break;

    m_RepType = NO_REPLICATION;
    if (IsDlgButtonChecked(IDC_ADDREP_REPLICATE))
      m_RepType = NORMAL_REPLICATION;

    bValidInput = TRUE;

  } while (0);

  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDITNETPATH));
    return FALSE;
  } else if (bValidInput)
  {
    EndDialog(S_OK);
    return TRUE;
  }
  else
  {
    if (idString)
      DisplayMessageBoxWithOK(idString);
    ::SetFocus(GetDlgItem(IDC_EDITNETPATH));
    return FALSE;
  }
}

LRESULT CAddRep::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

CAddRep::REPLICATION_TYPE CAddRep::get_ReplicationType(
  VOID
  )
/*++

Routine Description:

  This method gets the type of replication requested.
  This value is based on the radio button selected when OK is pressed.

*/
{
  return m_RepType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\addtodfs.h ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the declaration of the CAddToDfs.
  This class displays the Add To Dfs Dialog,which is used to add new Junctions Points.

*/

#ifndef __ADDTODFS_H_
#define __ADDTODFS_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAddToDfs
class CAddToDfs : 
  public CDialogImpl<CAddToDfs>
{
public:
  CAddToDfs();
  ~CAddToDfs();

  enum { IDD = IDD_ADDTODFS };

BEGIN_MSG_MAP(CAddToDfs)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
  COMMAND_ID_HANDLER(IDC_BUTTONNETBROWSE, OnNetBrowse)
  COMMAND_HANDLER(IDC_EDITCHLDNODE, EN_CHANGE, OnChangeDfsLink)
END_MSG_MAP()

//  Message Handlers.
  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnNetBrowse(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnChangeDfsLink(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
public:
  // Clients Call this methods.
  // Sets the entry path of the parent. This should be called before calling DoModal.
  HRESULT put_ParentPath(BSTR i_bstrParent);

  // Methods to retrieve data from the dialog on EndDialog().
  HRESULT get_Comment(BSTR *o_bstrComment);
  HRESULT get_EntryPath(BSTR *o_bstrEntryPath);
  HRESULT get_JPName(BSTR *o_bstrJPName);
  HRESULT get_NetPath(BSTR *o_bstrNetPath);
  HRESULT get_Server(BSTR *o_bstrServer);
  HRESULT get_Share(BSTR *o_bstrShare);
  HRESULT get_Time(long *o_plTime);

protected:
  CComBSTR  m_BrowseDfsLabel;
  CComBSTR  m_BrowseNetLabel;
  CComBSTR  m_bstrParentPath;
  CComBSTR  m_bstrEntryPath;
  CComBSTR  m_bstrJPName;
  CComBSTR  m_bstrNetPath;
  CComBSTR  m_bstrServer;
  CComBSTR  m_bstrShare;
  CComBSTR  m_bstrComment;
  long      m_lTime;
};

#endif //__ADDTODFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\bufmgr.h ===
#ifndef __BUFMGR_H__
#define __BUFMGR_H__

#include "netutils.h" //NETNAMELIST
#include <map>
using namespace std;

#define WM_USER_GETDATA_THREAD_DONE      WM_USER + 200

enum BUFFER_ENTRY_TYPE {
    BUFFER_ENTRY_TYPE_VALID = 0,
    BUFFER_ENTRY_TYPE_ERROR,
    BUFFER_ENTRY_TYPE_INPROGRESS
};

class CEntryData
{
public:
  CComBSTR                      m_bstrNodeName;
  NODETYPE                      m_nNodeType;
  HTREEITEM                     m_hItem;
  NETNAMELIST*                  m_pList;
  HRESULT                       m_hr;

  CEntryData(LPCTSTR pszNodeName, NODETYPE nNodeType, HTREEITEM hItem);
  ~CEntryData();

  inline LPCTSTR GetNodeName() { return m_bstrNodeName; }
  inline NODETYPE GetNodeType() { return m_nNodeType; }
  inline HTREEITEM GetTreeItem() { return m_hItem; }
  inline NETNAMELIST* GetList() { return m_pList; }
  inline HRESULT GetEntryHRESULT() { return m_hr; };

  void SetEntry(PVOID pList, HRESULT hr);
  enum BUFFER_ENTRY_TYPE GetEntryType();
  void ReSet();
};

struct mapcmpfn
{
    bool operator()(PTSTR p1, PTSTR p2) const
    {
        return lstrcmpi(p1, p2) < 0;
    }
};

typedef map<PTSTR, CEntryData *, mapcmpfn> Cache;

class CBufferManager
{
private:
  LONG  m_cRef; // instance reference count
  HWND  m_hDlg; // the owner dialog which owns this instance 
  LONG  m_lContinue; // synchronization flag between owner dialog and all the related running threads
  CRITICAL_SECTION  m_CriticalSection; // synchronize access to the buffer
  Cache   m_map; // NodeName ==> CEntryData*. The Buffer.

  void FreeBuffer();

  // constructor
  CBufferManager(HWND hDlg);
  // destructor
  ~CBufferManager();

public:
  static HRESULT CreateInstance(
    IN HWND hDlg, 
    OUT CBufferManager **ppBufferManager
  );

  LONG AddRef();
  LONG Release();
  void SignalExit();
  BOOL ShouldExit();

  HRESULT LoadInfo(
      IN PCTSTR       pszNodeName,
      IN NODETYPE     nNodeType,
      IN HTREEITEM    hItem,
      OUT CEntryData **ppInfo
  );
  HRESULT AddInfo(
      IN PCTSTR   pszNodeName, 
      IN PVOID    pList,
      IN HRESULT  hr,
      OUT PVOID*  ppv
  );
  void ThreadReport(
      IN PVOID    ptr,
      IN HRESULT  hr
  );
  HRESULT StartThread(
      IN PCTSTR pszNodeName,
      IN NODETYPE nNodeType
  );
};

#endif // __BUFMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\addtodfs.cpp ===
/*++
Module Name:

    AddToDfs.cpp

Abstract:

    This module contains the implementation for CAddToDfs.
  This class displays the Add To Dfs Dialog, which is used to add new Junctions Points.

*/

#include "stdafx.h"
#include "AddToDfs.h"
#include <shlobj.h>
#include <dsclient.h>
#include "utils.h"
#include "dfshelp.h"
#include "netutils.h"

/////////////////////////////////////////////////////////////////////////////
// CAddToDfs

CAddToDfs::CAddToDfs():m_lTime(1800)
{
}

CAddToDfs::~CAddToDfs()
{
}


HRESULT CAddToDfs::put_ParentPath
(
  BSTR i_bstrParentPath
)
{
/*++

Routine Description:

  Sets the path of the parent Junction point.
  This is used to display in the edit text and append to the entry path.

*/

  if (!i_bstrParentPath)
    return(E_INVALIDARG);

  m_bstrParentPath = i_bstrParentPath;

  if (!m_bstrParentPath)
    return(E_OUTOFMEMORY);

  return(S_OK);
}


HRESULT CAddToDfs::get_Comment
(
  BSTR *o_bstrComment
)
{
  if (!o_bstrComment)
    return(E_INVALIDARG);

  *o_bstrComment = SysAllocString(m_bstrComment);

  if (!*o_bstrComment)
    return(E_OUTOFMEMORY);

  return(S_OK);
}


HRESULT CAddToDfs::get_EntryPath
(
  BSTR *o_bstrEntryPath
)
{
/*++

Routine Description:

  Returns the complete entry path of the new Junction point to be created.

*/
  if (!o_bstrEntryPath)
    return(E_INVALIDARG);

  *o_bstrEntryPath = SysAllocString(m_bstrEntryPath);

  if (!*o_bstrEntryPath)
    return(E_OUTOFMEMORY);

  return(S_OK);
}

HRESULT CAddToDfs::get_JPName
(
  BSTR *o_bstrJPName
)
{
  if (!o_bstrJPName)
    return(E_INVALIDARG);

  *o_bstrJPName = SysAllocString(m_bstrJPName);

  if (!*o_bstrJPName)
    return(E_OUTOFMEMORY);

  return(S_OK);
}

HRESULT CAddToDfs::get_NetPath
(
  BSTR *o_bstrNetPath
)
{
/*++

Routine Description:

  Returns the complete share path typed in by the user in the edit box.

*/
  if (!o_bstrNetPath)
    return(E_INVALIDARG);

  *o_bstrNetPath = SysAllocString(m_bstrNetPath);

  if (!*o_bstrNetPath)
    return(E_OUTOFMEMORY);

  return(S_OK);
}


HRESULT CAddToDfs::get_Server
(
  BSTR *o_bstrServer
)
{
/*++

Routine Description:

  Returns the server component of the share path.

*/

  if (!o_bstrServer)
    return(E_INVALIDARG);

  *o_bstrServer = SysAllocString(m_bstrServer);

  if (!*o_bstrServer)
    return(E_OUTOFMEMORY);

  return(S_OK);
}



HRESULT CAddToDfs::get_Share
(
  BSTR *o_bstrShare
)
{
/*++

Routine Description:

  Returns the share component of the share path.

*/
  if (!o_bstrShare)
    return(E_INVALIDARG);

  *o_bstrShare = SysAllocString(m_bstrShare);

  if (!*o_bstrShare)
    return(E_OUTOFMEMORY);

  return(S_OK);
}





HRESULT CAddToDfs::get_Time
(
  long *o_plTime
)
{
  if (!o_plTime)
    return(E_INVALIDARG);

  *o_plTime = m_lTime;

  return(S_OK);
}

extern WNDPROC g_fnOldEditCtrlProc;

LRESULT CAddToDfs::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Performs the dialog initialization.

Arguments:

  As sent by Dialog Handler.

Return value:

*/

  m_bstrEntryPath.Empty();

  // Format the Parent enrty path and also display it in the static text.
  m_bstrParentPath += _T("\\");
  SetDlgItemText(IDC_EDIT_ADDLINK_DFSLINK_PATH, m_bstrParentPath);

  // Set the default time out value after getting it from the string resource.
  ::SendMessage(GetDlgItem(IDC_EDITTIME), EM_LIMITTEXT, 10, 0);
  TCHAR szTime[16];
  _stprintf(szTime, _T("%u"), m_lTime);
  SetDlgItemText(IDC_EDITTIME, szTime);
  g_fnOldEditCtrlProc = reinterpret_cast<WNDPROC>(
                 ::SetWindowLongPtr(
                                    GetDlgItem(IDC_EDITTIME),
                                    GWLP_WNDPROC, 
                                    reinterpret_cast<LONG_PTR>(NoPasteEditCtrlProc)));

  ::SendMessage(GetDlgItem(IDC_EDITNETPATH), EM_LIMITTEXT, MAX_PATH, 0);
  ::SendMessage(GetDlgItem(IDC_EDITCOMMENT), EM_LIMITTEXT, MAXCOMMENTSZ, 0);

  // Set the previous contents.
  SetDlgItemText(IDC_EDITNETPATH, m_bstrNetPath);
  SetDlgItemText(IDC_EDITCOMMENT, m_bstrComment);

  return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CAddToDfs::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDTODFS);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CAddToDfs::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_ADDTODFS);

  return TRUE;
}

LRESULT CAddToDfs::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  BOOL    bValidInput = FALSE;
  int     idControl = 0;
  int     idString = 0;
  HRESULT hr = S_OK;

  do {
    CWaitCursor wait;

    DWORD dwTextLength = 0;

    // Validate IDC_EDITCOMMENT
    m_bstrComment.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITCOMMENT), &m_bstrComment, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
      m_bstrComment = _T("");

    // Validate IDC_EDITCHLDNODE
    idControl = IDC_EDITCHLDNODE;
    m_bstrJPName.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITCHLDNODE), &m_bstrJPName, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_FIELD;
      break;
    }
    m_bstrEntryPath = m_bstrParentPath;
    m_bstrEntryPath += m_bstrJPName;
    hr = CheckUNCPath(m_bstrEntryPath);
    if (S_OK != hr)
    {
      hr = S_FALSE;
      idString = IDS_INVALID_LINKNAME;
      break;
    }

    // Validate IDC_EDITNETPATH
    idControl = IDC_EDITNETPATH;
    m_bstrNetPath.Empty();
    hr = GetInputText(GetDlgItem(IDC_EDITNETPATH), &m_bstrNetPath, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_FIELD;
      break;
    }

    m_bstrServer.Empty();
    m_bstrShare.Empty();
    if (!ValidateNetPath(m_bstrNetPath, &m_bstrServer, &m_bstrShare))
      break;

    // Validate IDC_EDITTIME
    idControl = IDC_EDITTIME;
    CComBSTR bstrTemp;
    hr = GetInputText(GetDlgItem(IDC_EDITTIME), &bstrTemp, &dwTextLength);
    if (FAILED(hr))
      break;
    ULONG ulTimeout = 0;
    if (0 == dwTextLength || !ValidateTimeout(bstrTemp, &ulTimeout))
    {
      idString = IDS_MSG_TIMEOUT_INVALIDRANGE;
      break;
    }
    m_lTime = ulTimeout;

    bValidInput = TRUE;

  } while (0);

  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(idControl));
    return FALSE;
  } else if (bValidInput)
  {
    EndDialog(S_OK);
    return TRUE;
  } else
  {
    if (idString)
      DisplayMessageBoxWithOK(idString);
    ::SetFocus(GetDlgItem(idControl));
    return FALSE;
  }
}

LRESULT CAddToDfs::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  EndDialog(S_FALSE);
  return(true);
}

LRESULT CAddToDfs::OnNetBrowse
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  CComBSTR  bstrPath;
  HRESULT   hr = BrowseNetworkPath(hWndCtl, &bstrPath);

  if (S_OK == hr)
  {
    SetDlgItemText(IDC_EDITNETPATH, bstrPath);
    ::SetFocus(GetDlgItem(IDC_EDITCOMMENT));
  }

  if (S_FALSE == hr)
      ::SetFocus(GetDlgItem(IDC_EDITNETPATH));

  return (SUCCEEDED(hr));
}

LRESULT
CAddToDfs::OnChangeDfsLink(
    WORD wNotifyCode,
    WORD wID, 
    HWND hWndCtl,
    BOOL& bHandled)
{
  CComBSTR  bstrDfsLinkName;
  DWORD     dwTextLength = 0;
  (void)GetInputText(GetDlgItem(IDC_EDITCHLDNODE), &bstrDfsLinkName, &dwTextLength);

  if ((BSTR)bstrDfsLinkName)
  {
    CComBSTR bstrFullPath = m_bstrParentPath;
    bstrFullPath += bstrDfsLinkName;
    SetDlgItemText(IDC_EDIT_ADDLINK_DFSLINK_PATH, bstrFullPath);

    ::SendMessage(GetDlgItem(IDC_EDIT_ADDLINK_DFSLINK_PATH), EM_SETSEL, 0, (LPARAM)-1);
    ::SendMessage(GetDlgItem(IDC_EDIT_ADDLINK_DFSLINK_PATH), EM_SETSEL, (WPARAM)-1, 0);
    ::SendMessage(GetDlgItem(IDC_EDIT_ADDLINK_DFSLINK_PATH), EM_SCROLLCARET, 0, 0);
  }

  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\connect.h ===
/*++
Module Name:

    Connect.h

Abstract:

    This module contains the declaration for CConnectToDialog. 
  This class is used to display the Connect To Dfs Root dialog box

--*/



#ifndef __CONNECT_H_
#define __CONNECT_H_


#include "resource.h"    // Main resource symbols
#include "NetUtils.h"
#include "DfsGUI.h"
#include "DfsCore.h"
#include "bufmgr.h"

typedef enum _ICONTYPE
{
        ICONTYPE_BUSY = 0,
        ICONTYPE_ERROR,
        ICONTYPE_NORMAL
} ICONTYPE;

/////////////////////////////////////////////////////////////////////////////
// CConnectToDialog
class CConnectToDialog : 
  public CDialogImpl<CConnectToDialog>
{
private:
  // This method is started the starting point of the second thread
  //friend DWORD WINAPI HelperThreadEntryPoint(IN LPVOID i_pvThisPointer);


private:
  // IDC_TREEDFSRoots is the resource id of the TV. Internally we useS IDC_TV only
  enum { IDC_TV = IDC_TREEDFSRoots };

  // The Edit box in the ConnectTo dialog
  enum {IDC_DLG_EDIT = IDC_EditDfsRoot};


public:
  CConnectToDialog();
  ~CConnectToDialog();

  // IDD_DLGCONNECTTO is the dialog id. This is used by CDialogImpl.
  enum { IDD = IDD_DLGCONNECTTO };


BEGIN_MSG_MAP(CDlgConnectTo)
  MESSAGE_HANDLER(WM_USER_GETDATA_THREAD_DONE, OnGetDataThreadDone)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()


  // Not implemented
private:
  CConnectToDialog(const CConnectToDialog& Obj);
  const CConnectToDialog& operator=(const CConnectToDialog& rhs);


public:

  // Message handlers
  LRESULT OnGetDataThreadDone(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  void ExpandNodeErrorReport(
      IN HTREEITEM  hItem,
      IN PCTSTR     pszNodeName, 
      IN HRESULT    hr
  );
  void ExpandNode(
    IN PCTSTR       pszNodeName,
    IN NODETYPE     nNodeType,
    IN HTREEITEM    hParentItem
  );

  HRESULT InsertData(
      IN CEntryData   *pEntry,
      IN HTREEITEM      hParentItem
  );


  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  // Used to get the notification about changing of TV's selection.
  LRESULT OnNotify(UINT uMsg, WPARAM wParam, LPARAM lParam,  BOOL& bHandled);
  
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

public:
  // Return the item selected by the user
  STDMETHOD(get_DfsRoot)(OUT BSTR *pVal);

  // Helper Methods
private:
  // Notify helpers


  // Handle the 
  LRESULT DoNotifyDoubleClick(
    );


  // Handle the TVN_ITEMEXPANDING notify for the Tree View
  LRESULT DoNotifyItemExpanding(
    IN LPNM_TREEVIEW        i_pNMTreeView
    );


  // Handle the TVN_SELCHANGED notify for the Tree View
  LRESULT DoNotifySelectionChanged(
    IN LPNM_TREEVIEW        i_pNMTreeView
    );



  // Initilization routines
  // Create the imagelist and initialize it.
  HRESULT InitTVImageList();


  // Add the items to the Tree View. This includes the domain names and the 
  // StandAlone subtree label
  HRESULT FillupTheTreeView(
    );

  // Set the cChilren label to zero for this tree item
  void SetChildrenToZero(
    IN HTREEITEM      i_hItem
    );

  HRESULT  AddSingleItemtoTV(  
    IN const BSTR         i_bstrItemLabel, 
    IN const int          i_iImageIndex, 
    IN const int          i_iImageSelectedIndex,
    IN const bool         i_bChildren,
    IN const NODETYPE     i_NodeType,
    IN HTREEITEM          i_hItemParent = NULL
    );
  void ChangeIcon(
      IN HTREEITEM hItem, 
      IN ICONTYPE  IconType
  );
  HRESULT GetNodeInfo(
      IN  HTREEITEM               hItem, 
      OUT BSTR*                   o_bstrName, 
      OUT NODETYPE*               pNodeType
  );


  // Overiding the method of CDialogImpl.
  BOOL  EndDialog(IN int i_RetCode);


  // Data members
private:
  CBufferManager      *m_pBufferManager;
  CComBSTR    m_bstrDfsRoot;          // Store the selected Dfs Root here
  
  HIMAGELIST    m_hImageList;          // The TV imagelist handle

  NETNAMELIST    m_50DomainList;        // Pointer to the first 50 domain information

  CComBSTR    m_bstrDomainDfsRootsLabel;
  CComBSTR    m_bstrAllDfsRootsLabel;
};

#endif //__CONNECTTODIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\bufmgr.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "bufmgr.h"
#include <process.h>

#define DOMAIN_DFSROOTS_SUFFIX  _T("D")
#define ALL_DFSROOTS_SUFFIX     _T("A")

unsigned __stdcall GetDataThreadFunc( void* lParam );

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::CBufferManager
//
//  Synopsis:   constructor
//
//----------------------------------------------------------------------------
CBufferManager::CBufferManager(HWND hDlg) : 
  m_cRef(0), m_hDlg(hDlg)
{
  dfsDebugOut((_T("CBufferManager::CBufferManager, this=%p\n"), this));

  m_lContinue = 1;  
  InitializeCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::~CBufferManager
//
//  Synopsis:   destructor
//
//----------------------------------------------------------------------------
CBufferManager::~CBufferManager()
{
  dfsDebugOut((_T("CBufferManager::~CBufferManager, this=%p\n"), this));

  _ASSERT(0 >= m_cRef);
  FreeBuffer();
  DeleteCriticalSection(&m_CriticalSection);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::CreateInstance
//
//  Synopsis:   Create an instance of CBufferManager.
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::CreateInstance(
    IN HWND               hDlg, 
    OUT CBufferManager **ppBufferManager
)
{
  dfsDebugOut((_T("CBufferManager::CreateInstance, hDlg=%x\n"), hDlg));

  _ASSERT(ppBufferManager);

  *ppBufferManager = new CBufferManager(hDlg);
  if ( !(*ppBufferManager) )
    return E_OUTOFMEMORY;

  (*ppBufferManager)->AddRef();

  return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::AddRef
//
//  Synopsis:   Increment reference count of this instance
//
//----------------------------------------------------------------------------
LONG
CBufferManager::AddRef()
{
  dfsDebugOut((_T("CBufferManager::AddRef, this=%p, preValue=%d\n"), this, m_cRef));

  return InterlockedIncrement(&m_cRef);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::Release
//
//  Synopsis:   Decrement reference count of this instance.
//              When the reference count reaches 0, delete this instance.
//
//----------------------------------------------------------------------------
LONG
CBufferManager::Release()
{
  dfsDebugOut((_T("CBufferManager::Release, this=%p, preValue=%d\n"), this, m_cRef));

  if (InterlockedDecrement(&m_cRef) <= 0)
  {
    delete this;
    return 0;
  }

  return m_cRef;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::SignalExit
//
//  Synopsis:   Called by the owner dialog to signal the related threads to exit.
//
//----------------------------------------------------------------------------
void
CBufferManager::SignalExit()
{ 
  dfsDebugOut((_T("CBufferManager::SignalExit\n")));

  InterlockedExchange(&m_lContinue, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::ShouldExit
//
//  Synopsis:   Threads are calling this function periodically to see
//              if the owner dialog signals them to exit.
//
//----------------------------------------------------------------------------
BOOL
CBufferManager::ShouldExit()
{
  dfsDebugOut((_T("CBufferManager::ShouldExit %d\n"), !m_lContinue));

  return (!m_lContinue);
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::LoadInfo
//
//  Synopsis:   The Owner dialog call it to get a pointer to the info of the specified domain.
//      The buffer consists of entries. 
//      Each entry is in the form of (LPTSTR szNodeName, CEntryData* pEntry).
//
//      LoadInfo() will first look up in the buffer.
//      If a valid entry is found, pass back pEntry to caller.
//      If an error entry is found, reset it (clear the error) and retry.
//      If an inprogress entry is found, do nothing. The caller will handle a THREAD_DONE later.
//      If no entry in the buffer, create a new entry, kick off a thread.
//
//      When the owner dialog get THREAD_DONE message, the related entry
//      in the buffer should either be a valid entry or an error entry.
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::LoadInfo(
    IN PCTSTR       pszNodeName,
    IN NODETYPE     nNodeType,
    IN HTREEITEM    hItem,
    OUT CEntryData **ppInfo
)
{
  _ASSERT(pszNodeName);
  _ASSERT(*pszNodeName);
  _ASSERT(hItem);
  _ASSERT(ppInfo);
  _ASSERT(*ppInfo == NULL);  // prevent memory leak

  dfsDebugOut((_T("CBufferManager::LoadInfo for %s\n"), pszNodeName));

  BOOL          bStartNewThread = FALSE;
  HRESULT       hr = S_OK;
  PVOID         ptr = NULL;
  CEntryData*  pEntry = NULL;
  Cache::iterator i;
  CComBSTR      bstrUniqueNodeName = pszNodeName;
  if (FTDFS == nNodeType)
    bstrUniqueNodeName += DOMAIN_DFSROOTS_SUFFIX;
  else
    bstrUniqueNodeName += ALL_DFSROOTS_SUFFIX;

  EnterCriticalSection(&m_CriticalSection);     // Lock buffer

  i = m_map.find(bstrUniqueNodeName);
  if (i != m_map.end()) {
    pEntry = (*i).second;
    //
    // Found an entry in the buffer.
    //
    if (pEntry)
    {
      switch (pEntry->GetEntryType())
      {
      case BUFFER_ENTRY_TYPE_VALID:
        // return the valid entry pointer
        *ppInfo = pEntry;
        break;
      case BUFFER_ENTRY_TYPE_ERROR:
        // kick off a thread to retry
        pEntry->ReSet();
        bStartNewThread = TRUE;
        break;
      case BUFFER_ENTRY_TYPE_INPROGRESS:
        // do nothing
        break;
      }
    }

  } else
  {
    //
    // not found in the buffer, need to start a new thread
    //
    bStartNewThread = TRUE;
    pEntry = new CEntryData(pszNodeName, nNodeType, hItem);
    PTSTR pszNode = _tcsdup(bstrUniqueNodeName);
    if (pEntry && pszNode) {
      m_map[pszNode] = pEntry;
    } else
    {
      hr = E_OUTOFMEMORY;
      if (pEntry)
        delete pEntry;
    }
  }

  if (SUCCEEDED(hr) && bStartNewThread)
  {
    hr = StartThread(pszNodeName, nNodeType);
    if (FAILED(hr))
    {
      delete pEntry;
      m_map.erase(bstrUniqueNodeName);
    }
  }

  LeaveCriticalSection(&m_CriticalSection);   // Unlock buffer

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::AddInfo
//
//  Synopsis:   Called by the thread function to add one result to the buffer.
//              It will pass back the pointer to the entry in the 5th parameters.
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::AddInfo(
    IN PCTSTR   pszNodeName, 
    IN PVOID    pList,
    IN HRESULT  hr,
    OUT PVOID*  ppv
)
{
  _ASSERT(pszNodeName);
  _ASSERT(*pszNodeName);

  dfsDebugOut((_T("CBufferManager::AddInfo for %s, hr=%x\n"), 
    pszNodeName, hr));

  PVOID   p = NULL;

  EnterCriticalSection(&m_CriticalSection);     // Lock buffer

  //
  // the entry must have been existed with a non-NULL pointer
  //
  Cache::iterator i = m_map.find(const_cast<PTSTR>(pszNodeName));
  _ASSERT(i != m_map.end());
  p = (*i).second;
  _ASSERT(p);

  ((CEntryData*)p)->SetEntry(pList, hr);

  LeaveCriticalSection(&m_CriticalSection);   // Unlock buffer

  *ppv = p;

  return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::FreeBuffer
//
//  Synopsis:   Clear m_map. 
//              This member holds all the results returned by various threads 
//              since the initialization of the owner dialog. Each one is 
//              in the form of (NodeName ==> CEntryData*)
//
//----------------------------------------------------------------------------
void
CBufferManager::FreeBuffer()
{
  EnterCriticalSection(&m_CriticalSection);     // Lock buffer

  if (!m_map.empty()) {
    for (Cache::iterator i = m_map.begin(); i != m_map.end(); i++)
    {
      if ((*i).first)
        free( (void *)((*i).first) );
      if ((*i).second)
        delete( (CEntryData*)((*i).second) );
    }
    m_map.clear();
  }

  LeaveCriticalSection(&m_CriticalSection);   // Unlock buffer
}

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::ThreadReport
//
//  Synopsis:   Report THREAD_DONE to the owner dialog. 
//
//----------------------------------------------------------------------------
void
CBufferManager::ThreadReport(
    IN PVOID    ptr,
    IN HRESULT  hr
)
{
  _ASSERT(ptr);

  PostMessage(m_hDlg, WM_USER_GETDATA_THREAD_DONE,
    reinterpret_cast<WPARAM>(ptr), hr);
}

/////////////////////////////////////////////////////////
// 
// thread info structure
typedef struct _GetDataThreadInfo
{
  PTSTR               pszNodeName;
  NODETYPE            nNodeType;
  CBufferManager      *pBufferManager;
} GETDATATHREADINFO;

//+---------------------------------------------------------------------------
//
//  Function:   CBufferManager::StartThread
//
//  Synopsis:   Start a thread. 
//
//     Pass the following info to the thread function:
//
//     pszNodeName: 
//          domain we need to get a list of DCs for.
//     pBufferManager:
//          the CBufferManager instance for the ThreadFunc to 
//          add result to the buffer
//
//----------------------------------------------------------------------------
HRESULT
CBufferManager::StartThread(
    IN PCTSTR   pszNodeName,
    IN NODETYPE nNodeType
) 
{
  _ASSERT(pszNodeName);
  _ASSERT(*pszNodeName);

  dfsDebugOut((_T("CBufferManager::StartThread for %s\n"), pszNodeName));

  GETDATATHREADINFO *pThreadInfo = new GETDATATHREADINFO;
  if (!pThreadInfo)
    return E_OUTOFMEMORY;

  if ( !(pThreadInfo->pszNodeName = _tcsdup(pszNodeName)) )
  {
    delete pThreadInfo;
    return E_OUTOFMEMORY;
  }

  pThreadInfo->nNodeType = nNodeType;
  pThreadInfo->pBufferManager = this;

  AddRef();

  unsigned threadID;
  HANDLE pThread = (HANDLE)ULongToPtr(_beginthreadex( 
                      NULL,               //void *security, 
                      0,                  //unsigned stack_size, 
                      &GetDataThreadFunc,   //unsigned ( __stdcall *start_address )( void * ), 
                      (void *)pThreadInfo, //void *arglist, 
                      0,                  //unsigned initflag, 
                      &threadID           //unsigned *thrdaddr
                      ));


  if (!pThread)
  {
    free(pThreadInfo->pszNodeName);
    delete pThreadInfo;

    Release();

    return E_FAIL;
  }

  return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDataThreadFunc
//
//  Synopsis:   The GetData Thread Function. 
//              This function invokes GetDomainDfsRoots to get a list
//              of dfs root names in the specified domain, and add them to the buffer of 
//              CBufferManager instance.
//              This function regularly checks to see if the owner dialog signals
//              it to exit, if not, it will finish its normal operation and
//              post a THREAD_DONE message to the owner dialog.
//
//----------------------------------------------------------------------------
unsigned __stdcall GetDataThreadFunc( void* lParam )
{
  GETDATATHREADINFO *pThreadInfo = reinterpret_cast<GETDATATHREADINFO *>(lParam);
  _ASSERT(pThreadInfo);
  _ASSERT(pThreadInfo->pszNodeName);
  _ASSERT(*(pThreadInfo->pszNodeName));
  _ASSERT(pThreadInfo->pBufferManager);

  dfsDebugOut((_T("GetDataThreadFunc pszNodeName=%s, pBufferManager=%p\n"),
    pThreadInfo->pszNodeName, pThreadInfo->pBufferManager));

  //
  // retrieve information passed into this function
  //
  CComBSTR             bstrNode = pThreadInfo->pszNodeName;
  NODETYPE             nNodeType = pThreadInfo->nNodeType; 
  CBufferManager      *pBufferManager = pThreadInfo->pBufferManager;
  free(pThreadInfo->pszNodeName);
  delete pThreadInfo;

  NETNAMELIST*        pNameList = NULL;
  PVOID               pEntry = NULL;
  HRESULT             hr = S_OK;

  if (FAILED(hr) || pBufferManager->ShouldExit() || FTDFS != nNodeType)
    goto Thread_Exit;

  pNameList = new NETNAMELIST;
  if (!pNameList)
  {
    hr = E_OUTOFMEMORY;
    goto Thread_Exit;
  }

  if (FTDFS == nNodeType)
  {
    hr = GetDomainDfsRoots(pNameList, bstrNode);
    bstrNode += DOMAIN_DFSROOTS_SUFFIX;
  } /*else
  {
    hr = GetServers(pNameList, bstrNode);
    bstrNode += ALL_DFSROOTS_SUFFIX;
  } */

  if (pBufferManager->ShouldExit())
  {
    if (SUCCEEDED(hr))
      FreeNetNameList(pNameList);
    delete pNameList;
    goto Thread_Exit;
  }

  if (FAILED(hr)) {
    // Add an error entry in the buffer.
    delete pNameList;
    pBufferManager->AddInfo(bstrNode, NULL, hr, &pEntry);
    goto Thread_Exit;
  }

  //
  // Add result to the buffer in CBufferManager
  //
  hr = pBufferManager->AddInfo(bstrNode, pNameList, S_OK, &pEntry);
  if (FAILED(hr)) {
    FreeNetNameList(pNameList);
    delete pNameList;
  }

Thread_Exit:

  if (FALSE == pBufferManager->ShouldExit())
  {
    //
    // report THREAD_DONE with the pointer to the entry
    //
    if (pEntry)
      pBufferManager->ThreadReport(pEntry, hr);
  }

  //
  // Decrement the reference count on the CBufferManager instance
  //
  pBufferManager->Release();

  return 0;
}

///////////////////////////////////////////////
// class CEntryData

CEntryData::CEntryData(LPCTSTR pszNodeName, NODETYPE nNodeType, HTREEITEM hItem)
{
  m_bstrNodeName = pszNodeName;
  m_nNodeType = nNodeType;
  m_hItem = hItem;
  m_pList = NULL;
  m_hr = S_OK;
}

CEntryData::~CEntryData()
{
  dfsDebugOut((_T("CEntryData::~CEntryData\n")));
  FreeNetNameList(m_pList);
  if (m_pList)
    delete m_pList;
}

void
CEntryData::SetEntry(PVOID pList, HRESULT hr)
{
  FreeNetNameList(m_pList);
  if (m_pList)
    delete m_pList;
  m_pList = (NETNAMELIST *)pList;
  
  m_hr = hr;
}

enum BUFFER_ENTRY_TYPE
CEntryData::GetEntryType()
{
  if (FAILED(m_hr))
    return BUFFER_ENTRY_TYPE_ERROR;
  if (m_pList == NULL)
    return BUFFER_ENTRY_TYPE_INPROGRESS;
  return BUFFER_ENTRY_TYPE_VALID;
}

void
CEntryData::ReSet()
{
  _ASSERT(GetEntryType() == BUFFER_ENTRY_TYPE_ERROR);
  m_hr = S_OK;
  _ASSERT(GetEntryType() == BUFFER_ENTRY_TYPE_INPROGRESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\connect.cpp ===
/*++
Module Name:

    Connect.cpp

Abstract:

    This module contains the implementation for CConnectToDialog.
  This is used to display the Connect To Dfs Root dialog box

--*/



#include "stdafx.h"
#include <process.h>
#include "DfsGUI.h"
#include "Utils.h"      // For the LoadStringFromResource and SetStandardCursor method
#include "Connect.h"
#include "dfshelp.h"

static const int      iFOLDER_IMAGE = 0;
static const int      iFOLDER_SELECTED_IMAGE = 1;
static const int      iDOMAIN_IMAGE      = 2;
static const int      iDOMAIN_SELECTED_IMAGE  = 2;
static const int      iSTANDALONE_DFSROOT_IMAGE = 3;
static const int      iFT_DFSROOT_IMAGE = 3;
static const int      iOVERLAY_BUSY_IMAGE = 4;
static const int      iOVERLAY_ERROR_IMAGE = 5;
static const int      OV_BUSY = 1;
static const int      OV_ERROR = 2;

CConnectToDialog::CConnectToDialog()
{
  CWaitCursor    WaitCursor;    // Display the wait cursor

  m_pBufferManager = NULL;

  m_hImageList = NULL;

  (void)Get50Domains(&m_50DomainList);

  LoadStringFromResource(IDS_DOMAIN_DFSROOTS_LABEL, &m_bstrDomainDfsRootsLabel);
  LoadStringFromResource(IDS_ALL_DFSROOTS_LABEL, &m_bstrAllDfsRootsLabel);
}

CConnectToDialog::~CConnectToDialog()
{
  CWaitCursor    WaitCursor;  // An object to set\reset the cursor to wait cursor

  if(NULL != m_hImageList)
  {
     ImageList_Destroy(m_hImageList);
     m_hImageList = NULL;
  }

  // Free Domain List
  FreeNetNameList(&m_50DomainList);

  if (m_pBufferManager)
  {
    //
    // signal all related running threads to terminate
    //
    m_pBufferManager->SignalExit();

    //
    // decrement the reference count on the CBufferManager instance
    //
    m_pBufferManager->Release();
  }

}

LRESULT
CConnectToDialog::OnInitDialog(
  UINT            uMsg,
  WPARAM          wParam,
  LPARAM          lParam,
  BOOL&           bHandled
  )
{
  //
  // create instance of CBufferManager
  // m_pBufferManager will be set to NULL if CreateInstance() failed.
  //
  (void) CBufferManager::CreateInstance(m_hWnd, &m_pBufferManager);

  ::SendMessage(GetDlgItem(IDC_EditDfsRoot), EM_LIMITTEXT, DNSNAMELIMIT, 0);

  InitTVImageList();        // Get the image list for the TV

  FillupTheTreeView();      // Fill up the Tree View

  return TRUE;              // let the dialog box set the focus to any control it wants.
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CConnectToDialog::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_DLGCONNECTTO);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CConnectToDialog::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_DLGCONNECTTO);

  return TRUE;
}

LRESULT
CConnectToDialog::OnGetDataThreadDone(
  UINT            uMsg,
  WPARAM          wParam,
  LPARAM          lParam,
  BOOL&           bHandled
  )
{
  _ASSERT(m_pBufferManager);

  bHandled = TRUE;

  CEntryData* pEntry = reinterpret_cast<CEntryData*>(wParam);
  HRESULT hr = (HRESULT)lParam;

  _ASSERT(pEntry);

  CComBSTR      bstrNode = pEntry->GetNodeName();
  HTREEITEM     hItem = pEntry->GetTreeItem();

  switch (pEntry->GetEntryType())
  {
  case BUFFER_ENTRY_TYPE_VALID:
    (void)InsertData(pEntry, hItem);
    ChangeIcon(hItem, ICONTYPE_NORMAL);
    break;
  case BUFFER_ENTRY_TYPE_ERROR:
    ExpandNodeErrorReport(hItem, bstrNode, pEntry->GetEntryHRESULT());
    break;
  default:
    _ASSERT(FALSE);
    break;
  }

  bHandled = TRUE;

  return TRUE;
}

void CConnectToDialog::ChangeIcon(
    IN HTREEITEM  hItem,
    IN ICONTYPE   IconType
)
{
  TVITEM TVItem;

  ZeroMemory(&TVItem, sizeof(TVItem));
  TVItem.hItem = hItem;
  TVItem.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE;

  switch (IconType)
  {
  case ICONTYPE_BUSY:
    TVItem.iImage = iOVERLAY_BUSY_IMAGE;
    TVItem.iSelectedImage = iOVERLAY_BUSY_IMAGE;
    break;
  case ICONTYPE_ERROR:
    TVItem.iImage = iOVERLAY_ERROR_IMAGE;
    TVItem.iSelectedImage = iOVERLAY_ERROR_IMAGE;
    break;
  default: // ICONTYPE_NORMAL
    {
      NODETYPE NodeType = UNASSIGNED;
      HRESULT hr = GetNodeInfo(hItem, NULL, &NodeType);

      if (FAILED(hr))
        return;

      switch (NodeType)
      {
      case TRUSTED_DOMAIN:
        TVItem.iImage = iDOMAIN_IMAGE;
        TVItem.iSelectedImage = iDOMAIN_SELECTED_IMAGE;
        break;
      case DOMAIN_DFSROOTS:
      case ALL_DFSROOTS:
        TVItem.iImage = iFOLDER_IMAGE;
        TVItem.iSelectedImage = iFOLDER_SELECTED_IMAGE;
        break;
      case FTDFS:
        TVItem.iImage = iFT_DFSROOT_IMAGE;
        TVItem.iSelectedImage = iFT_DFSROOT_IMAGE;
        break;
      case SADFS:
        TVItem.iImage = iSTANDALONE_DFSROOT_IMAGE;
        TVItem.iSelectedImage = iSTANDALONE_DFSROOT_IMAGE;
        break;
      default:
        return;
      }
    }
  }

  SendDlgItemMessage(IDC_TV, TVM_SETITEM, 0, (LPARAM)&TVItem);

  UpdateWindow();
}

/*
void CConnectToDialog::ChangeIcon(
    IN HTREEITEM  hItem,
    IN ICONTYPE   IconType
)
{
  TVITEM TVItem;

  ZeroMemory(&TVItem, sizeof(TVItem));
  TVItem.hItem = hItem;
  TVItem.mask = TVIF_STATE;
  TVItem.stateMask = TVIS_OVERLAYMASK;

  switch (IconType)
  {
  case ICONTYPE_BUSY:
    TVItem.state = INDEXTOOVERLAYMASK(OV_BUSY);
    break;
  case ICONTYPE_ERROR:
    TVItem.state = INDEXTOOVERLAYMASK(OV_ERROR);
    break;
  default:
    TVItem.state = 0;
    break;
  }

  SendDlgItemMessage(IDC_TV, TVM_SETITEM, 0, (LPARAM)&TVItem);

  UpdateWindow();
}
*/

void CConnectToDialog::ExpandNodeErrorReport(
    IN HTREEITEM  hItem,
    IN PCTSTR     pszNodeName,
    IN HRESULT    hr
)
{
  // change the icon to "X"
  dfsDebugOut((_T("Failed to expand: %s, hr=%x\n"), pszNodeName, hr));
  SetChildrenToZero(hItem);
  ChangeIcon(hItem, ICONTYPE_ERROR);
}

void CConnectToDialog::ExpandNode(
    IN PCTSTR       pszNodeName,
    IN NODETYPE     nNodeType,
    IN HTREEITEM    hParentItem
)
{
  HRESULT hr = S_OK;
  dfsDebugOut((_T("CConnectToDialog::ExpandNode for %s\n"), pszNodeName));

  if (m_pBufferManager)
  {
    //
    // change icon to wait
    //

    ChangeIcon(hParentItem, ICONTYPE_BUSY);

    UpdateWindow();

    //
    // start the thread to calculate a list of servers in the current selected domain
    //
    CEntryData *pEntry = NULL;
    hr = m_pBufferManager->LoadInfo(pszNodeName, nNodeType, hParentItem, &pEntry);

    if (SUCCEEDED(hr))
    {
      //
      // Either we get a valid ptr back (ie. data is ready), insert it;
      // or, a thread is alreay in progress, wait until a THREAD_DONE message.
      //
      if (pEntry)
      {
        _ASSERT(pEntry->GetEntryType() == BUFFER_ENTRY_TYPE_VALID);
        (void)InsertData(pEntry, hParentItem);
      }
    } else
    {
      ExpandNodeErrorReport(hParentItem, pszNodeName, hr);
    }
  }

  return;
}

HRESULT
CConnectToDialog::InsertData(
    IN CEntryData*    pEntry,
    IN HTREEITEM      hParentItem
)
{
  _ASSERT(pEntry);

  CComBSTR      bstrNode = pEntry->GetNodeName();
  NODETYPE      nNodeType = pEntry->GetNodeType();
  NETNAMELIST*  pList = pEntry->GetList();
  _ASSERT(pList);

  HRESULT       hr = S_OK;

  if (0 == pList->size())
  {
    SetChildrenToZero(hParentItem);
    return hr;
  }

  int nImageIndex;
  int nSelectedImageIndex;
  bool bChildren;

  nImageIndex = iSTANDALONE_DFSROOT_IMAGE;
  nSelectedImageIndex = iSTANDALONE_DFSROOT_IMAGE;
  bChildren = false;

  for (NETNAMELIST::iterator i = pList->begin(); i != pList->end(); i++)
  {
    hr = AddSingleItemtoTV(
            (*i)->bstrNetName,
            nImageIndex,
            nSelectedImageIndex,
            bChildren,
            nNodeType,
            hParentItem);

    RETURN_IF_FAILED(hr);
  }

  // make the child items visible
  HTREEITEM hChildItem = (HTREEITEM)SendDlgItemMessage(
    IDC_TV, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hParentItem);
  if (hChildItem)
    SendDlgItemMessage(IDC_TV, TVM_ENSUREVISIBLE, 0, (LPARAM)hChildItem);

  // sort all its child items
  SendDlgItemMessage(IDC_TV, TVM_SORTCHILDREN, 0, (LPARAM)hParentItem);

  return S_OK;
}

LRESULT
CConnectToDialog :: OnNotify(
  UINT    uMsg,
  WPARAM    wParam,
  LPARAM    lParam,
  BOOL&    bHandled
  )
/*++

Routine Description:

  Called on WM_NOTIFY.
  Used to set the Edit box depending on the current selection in the TV.


Arguments:
  uMsg  -  The windows message being sent. This is WM_NOTIFY.
  lParam  -  Info about the message like control for which the message is being sent,
        what sub type of message, etc


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  _ASSERTE(WM_NOTIFY == uMsg);
  _ASSERTE(lParam  != NULL);

  LRESULT      lr = FALSE;      // Set it to true if we handle this message.
  LPNM_TREEVIEW  pNMTreeView = (NM_TREEVIEW *) lParam;

  bHandled = FALSE;
                    // Check if the message  is for our tree control
  if (pNMTreeView && IDC_TV == pNMTreeView->hdr.idFrom)
  {
                    // Check if the message is for selection change.
    if (TVN_SELCHANGED == pNMTreeView->hdr.code)
    {
      lr = DoNotifySelectionChanged(pNMTreeView);
    }
    else if (TVN_ITEMEXPANDING == pNMTreeView->hdr.code)
    {
      lr = DoNotifyItemExpanding(pNMTreeView);
    }
    else if (NM_DBLCLK  == pNMTreeView->hdr.code)
    {
      lr = DoNotifyDoubleClick();
    } else
    {
      lr = FALSE;
    }
  }

  return (lr);
}




LRESULT
CConnectToDialog::DoNotifyDoubleClick(
  )
/*++

Routine Description:

  Handles the WM_NOTIFY for NM_DBLCLK.
  This acts like a click on OK, if the current item is a dfsroot.


Arguments:
  None


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  HRESULT          hr = E_FAIL;
  HTREEITEM        hCurrentItem = NULL;
  NODETYPE         NodeType = UNASSIGNED;

  hCurrentItem = TreeView_GetSelection(GetDlgItem(IDC_TV));
  if (NULL == hCurrentItem)      // Unable to get the current selection
  {
    return FALSE;
  }

  hr = GetNodeInfo(hCurrentItem, NULL, &NodeType);
  if(FAILED(hr))
    return FALSE;

                    // Take action only on a dfs root
  if (FTDFS == NodeType || SADFS == NodeType)
  {

    int    iHandled = TRUE;  // A variable used for communication with OnOK

    OnOK(NULL, 1, 0, iHandled);  // On a double click, we simulate a click on OK.
    _ASSERTE(TRUE == iHandled);

    return TRUE;
  }

  return FALSE;
}



LRESULT
CConnectToDialog::DoNotifyItemExpanding(
  IN LPNM_TREEVIEW    i_pNMTreeView
  )
/*++

Routine Description:

  Handles the WM_NOTIFY for TVN_ITEMEXPANDING.
  If the expand is for "Standalone label", we create another thread
  to fill it up.
  Else, we get the Fault Tolerant Dfs Roots for the domain name.

  Also we removes the '+' sign, if the tree node is empty.


Arguments:
  i_pNMTreeView  -  Information related to the tree and the node for which the message
            occurred


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  HTREEITEM    hCurrentItem = (i_pNMTreeView->itemNew).hItem;
  _ASSERT(hCurrentItem);

                      // If children actually exist, we have nothing to do. It is a normal expand
  HTREEITEM hItemChild = (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hCurrentItem);
  if (hItemChild)
    return FALSE;

  NODETYPE  NodeType = UNASSIGNED;
  HRESULT   hr = GetNodeInfo(hCurrentItem, NULL, &NodeType);
  if(FAILED(hr))
  {
    SetChildrenToZero(hCurrentItem);
    return TRUE;
  }

  switch (NodeType)
  {
  case TRUSTED_DOMAIN:
    {
      AddSingleItemtoTV(
            m_bstrDomainDfsRootsLabel,
            iFOLDER_IMAGE,
            iFOLDER_SELECTED_IMAGE,
            true,
            DOMAIN_DFSROOTS,
            hCurrentItem);
      return TRUE;
    }
  case DOMAIN_DFSROOTS:
    {
      CWaitCursor    WaitCursor;

      // get the domain name
      HTREEITEM hParentItem = (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hCurrentItem);
      _ASSERT(hParentItem);
      CComBSTR bstrDomainName;
      hr = GetNodeInfo(hParentItem, &bstrDomainName, NULL);
      if(FAILED(hr))
        SetChildrenToZero(hCurrentItem);

      ExpandNode(bstrDomainName, ((NodeType == DOMAIN_DFSROOTS) ? FTDFS : SADFS), hCurrentItem);

      return TRUE;
    } 
  default:
    break;
  }

  return FALSE;
}

LRESULT
CConnectToDialog::DoNotifySelectionChanged(
  IN LPNM_TREEVIEW    i_pNMTreeView
  )
/*++

Routine Description:

  Handles the WM_NOTIFY for TVN_SELCHANGED.
  The text in the edit box is set here to the dfs root path.


Arguments:
  i_pNMTreeView  -  Information related to the tree and the node for which the message
            occurred


Return value:

  TRUE, if we have handled the message
  FALSE, if we ignore it. The system handles the message then.
--*/
{
  HRESULT                 hr = S_OK;
  CComBSTR                bstrNameForEditBox;
  CComBSTR                bstrDisplayName;
  NODETYPE                NodeType;
  HTREEITEM               hItem = (i_pNMTreeView->itemNew).hItem;

  hr = GetNodeInfo(hItem, &bstrDisplayName, &NodeType);
  if(FAILED(hr))
    return FALSE;

  switch (NodeType)
  {
  case FTDFS:
    {
      // get its parent's display name
      HTREEITEM hParentItem =
        (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem);
      _ASSERT(hParentItem);
      HTREEITEM hGrandParentItem =
        (HTREEITEM)SendDlgItemMessage(IDC_TV, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hParentItem);
      _ASSERT(hGrandParentItem);

      CComBSTR  bstrDomainName;
      hr = GetNodeInfo(hGrandParentItem, &bstrDomainName, NULL);
      if(FAILED(hr))
        return FALSE;

      bstrNameForEditBox = _T("\\\\");
      bstrNameForEditBox += bstrDomainName;
      bstrNameForEditBox += _T("\\");
      bstrNameForEditBox += bstrDisplayName;

    }
    break;
/*  case SADFS:
    bstrNameForEditBox = bstrDisplayName;
    break; */
  default:
    bstrNameForEditBox = _T("");
    break;
  }

  return SetDlgItemText(IDC_DLG_EDIT, bstrNameForEditBox);
}

LRESULT
CConnectToDialog::OnOK(
  WORD  wNotifyCode,
  WORD  wID,
  HWND  hWndCtl,
  BOOL&  bHandled
  )
/*++

Routine Description:

  Called when the OK button is pressed.


Arguments:
  None  used.


Return value:

  0. As it is a command handler
  Calls EndDialog(S_OK). S_OK is passed back as return value of DoModal. This indicates
  that the dialog ended on OK being pressed

--*/
{
  DWORD     dwTextLength = 0;
  HRESULT   hr = S_OK;

  m_bstrDfsRoot.Empty();
  hr = GetInputText(GetDlgItem(IDC_DLG_EDIT), &m_bstrDfsRoot, &dwTextLength);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_DLG_EDIT));
    return FALSE;
  } else if (0 == dwTextLength)
  {
    DisplayMessageBoxWithOK(IDS_MSG_EMPTY_DFSROOT);
    ::SetFocus(GetDlgItem(IDC_DLG_EDIT));
    return FALSE;
  }

  EndDialog(S_OK);

  return 0;
}




LRESULT
CConnectToDialog::OnCancel(
  WORD  wNotifyCode,
  WORD  wID,
  HWND  hWndCtl,
  BOOL&  bHandled
  )
/*++

Routine Description:

  Called when the Cancel button is pressed.


Arguments:
  None used.


Return value:

  0. As it is a command handler
  Calls EndDialog(S_FALSE). S_FALSE is passed back as return value of DoModal.
  This indicates that the dialog ended on Cancel being pressed
--*/
{
  EndDialog(S_FALSE);

  return 0;
}



BOOL CConnectToDialog :: EndDialog(
  IN int    i_RetCode
  )
/*++

Routine Description:

  Overridden method that calls the parent method after some internal processing.
  This includes deleting the objects stored in the lparams of the TV items.


Arguments:
  None used.


Return value:

  The return value of the parent method.
--*/
{
  ::ShowCursor(FALSE);
  SetCursor(::LoadCursor(NULL, IDC_WAIT));
  ::ShowCursor(TRUE);

                    // Remove the Imagelist from the tree. We destroy it in the dtor
  SendDlgItemMessage(IDC_TV, TVM_SETIMAGELIST, TVSIL_NORMAL, (LPARAM)NULL);

  return CDialogImpl<CConnectToDialog>::EndDialog(i_RetCode);
}



STDMETHODIMP CConnectToDialog::get_DfsRoot(
  OUT BSTR*  pVal
  )
/*++

Routine Description:

  Return the selected DfsRoot name.
  Part of the interface IConnectToDialog.


Arguments:
  pVal - Return the BSTR in this.


Return value:

  S_OK, if successful
  E_FAIL, if the value is unavailable
  E_INVALIDARG, if the pointer is invalid(NULL)
  E_OUTOFMEMORY if we run out of memory
--*/
{
  RETURN_INVALIDARG_IF_NULL(pVal);

  if ((!m_bstrDfsRoot) || (0 == m_bstrDfsRoot.Length()))
  {
    return E_FAIL;
  }

  *pVal = SysAllocString(m_bstrDfsRoot);
  RETURN_OUTOFMEMORY_IF_NULL(*pVal);

  return S_OK;
}



void
CConnectToDialog::SetChildrenToZero(
  IN HTREEITEM      i_hItem
)
{
  TV_ITEM    TVItem;

  ZeroMemory(&TVItem, sizeof TVItem);
  TVItem.mask = TVIF_CHILDREN;
  TVItem.cChildren = 0;
  TVItem.hItem = i_hItem;

  SendDlgItemMessage( IDC_TV, TVM_SETITEM, 0, (LPARAM)&TVItem);
}

HRESULT CConnectToDialog::InitTVImageList()
{
  m_hImageList = ImageList_LoadBitmap(
                      _Module.GetModuleInstance(),
                      MAKEINTRESOURCE(IDB_CONNECT_16x16),
                      16,
                      8,
                      CLR_DEFAULT);
  if (NULL == m_hImageList)
    return E_FAIL;

  ImageList_SetOverlayImage(
              m_hImageList,
              iOVERLAY_BUSY_IMAGE,
              OV_BUSY);

  ImageList_SetOverlayImage(
              m_hImageList,
              iOVERLAY_ERROR_IMAGE,
              OV_ERROR);

  SendDlgItemMessage(
      IDC_TV,
      TVM_SETIMAGELIST,
      TVSIL_NORMAL,
      (LPARAM)m_hImageList);

  return S_OK;
}



HRESULT
CConnectToDialog::FillupTheTreeView(
  )
/*++

Routine Description:

  This routine does 2 things, adds the NT 5.0 domain names and the Standalone subtree label.
  Also makes the text over the TV invisible.

Arguments:

  None.

Return value:

    S_OK, On success
  HRESULT sent by methods called, if it is not S_OK.
  E_FAIL, on other errors.

--*/
{
  HRESULT        hr = S_OK;

  //
  // add trusted domains DNS names
  // FT dfs roots will be added under these nodes
  //
  if (m_50DomainList.empty())
    return hr;

  for(NETNAMELIST::iterator i = m_50DomainList.begin(); i != m_50DomainList.end(); i++)
  {
    _ASSERTE((*i)->bstrNetName);

    hr = AddSingleItemtoTV(
                (*i)->bstrNetName,
                iDOMAIN_IMAGE,
                iDOMAIN_SELECTED_IMAGE,
                true,    // Children = true
                TRUSTED_DOMAIN);
    if (FAILED(hr))
      break;
  }

  if (SUCCEEDED(hr))
  {
    // sort the trusted domains only
    SendDlgItemMessage(IDC_TV, TVM_SORTCHILDREN, 0, 0);
  }

  return hr;
}

HRESULT
CConnectToDialog::AddSingleItemtoTV(
  IN const BSTR         i_bstrItemLabel,
  IN const int          i_iImageIndex,
  IN const int          i_iImageSelectedIndex,
  IN const bool         i_bChildren,
  IN const NODETYPE     i_NodeType,
  IN HTREEITEM          i_hItemParent  /* = NULL */
  )
{
  RETURN_INVALIDARG_IF_NULL(i_bstrItemLabel);

  HRESULT                 hr = S_OK;
  TV_INSERTSTRUCT         TVInsertData;
  TV_ITEM                 TVItem;
  HTREEITEM               hCurrentItem = NULL;

  ZeroMemory(&TVItem, sizeof(TVItem));
  ZeroMemory(&TVInsertData, sizeof(TVInsertData));

  TVItem.mask = TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_PARAM;

  if (true == i_bChildren)    // To decide whether we add the '+' or not
  {
    TVItem.mask |= TVIF_CHILDREN;
    TVItem.cChildren = 1;
  }
  TVItem.pszText = i_bstrItemLabel;
  TVItem.cchTextMax = _tcslen(i_bstrItemLabel);
  TVItem.iImage = i_iImageIndex;
  TVItem.iSelectedImage = i_iImageSelectedIndex;
  TVItem.lParam = (LPARAM)i_NodeType;

  TVInsertData.hParent = i_hItemParent;
  TVInsertData.hInsertAfter = TVI_LAST; // No sorting to improve performance
  TVInsertData.item = TVItem;

  hCurrentItem = (HTREEITEM) SendDlgItemMessage(IDC_TV, TVM_INSERTITEM, 0, (LPARAM) (LPTV_INSERTSTRUCT) &TVInsertData);
  if (NULL == hCurrentItem)
    return E_FAIL;

  return S_OK;
}

HRESULT
CConnectToDialog::GetNodeInfo(
    IN  HTREEITEM               hItem,
    OUT BSTR*                   o_bstrName,
    OUT NODETYPE*               pNodeType
)
{
  _ASSERT(o_bstrName || pNodeType);

  HRESULT   hr = S_OK;
  TCHAR     szName[MAX_PATH];
  TVITEM    TVItem;
  ZeroMemory(&TVItem, sizeof(TVItem));

  TVItem.hItem = hItem;

  if (o_bstrName)
  {
    TVItem.mask |= TVIF_TEXT;
    TVItem.pszText = szName;
    TVItem.cchTextMax = MAX_PATH;
  }

  if (pNodeType)
    TVItem.mask |= TVIF_PARAM;

  if ( SendDlgItemMessage(IDC_TV, TVM_GETITEM, 0, (LPARAM)&TVItem) )
  {
    if (o_bstrName)
    {
      *o_bstrName = SysAllocString(szName);
      if (!*o_bstrName)
        hr = E_OUTOFMEMORY;
    }

    if (pNodeType)
    {
      *pNodeType = (NODETYPE)TVItem.lParam;
    }
  } else {
    hr = E_FAIL;
  }

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\custop.cpp ===
/*++
Module Name:

    CusTop.cpp

Abstract:

    This module contains the Implementation of CCustomTopology.
    This class displays the Customize Topology Dialog.

*/

#include "stdafx.h"
#include "CusTop.h"
#include "frsAdv.h"
#include "utils.h"
#include "dfshelp.h"
#include "ldaputils.h"

int g_FRS_CUSTOP_Last_SortColumn = 1;
#define NUM_OF_FRS_CUSTOP_COLUMNS   5

RSTOPOLOGYPREF_STRING g_TopologyPref[] = {
                    {FRS_RSTOPOLOGYPREF_RING, IDS_FRSPROP_RING}, 
                    {FRS_RSTOPOLOGYPREF_HUBSPOKE, IDS_FRSPROP_HUBSPOKE}, 
                    {FRS_RSTOPOLOGYPREF_FULLMESH, IDS_FRSPROP_FULLMESH}, 
                    {FRS_RSTOPOLOGYPREF_CUSTOM, IDS_FRSPROP_CUSTOM}
                    };

// sort member list based on m_bstrSite
struct CusTopMemberCompareSite : greater<CCusTopMember*>
{
      bool operator()(const CCusTopMember *pMem1, const CCusTopMember *pMem2) const
      { return (lstrcmpi(pMem1->m_bstrSite, pMem2->m_bstrSite) > 0); }
};

/////////////////////////////////////////////////////////////////////////////
//
// CCustomTopology
//

CCustomTopology::CCustomTopology()
{
}

CCustomTopology::~CCustomTopology()
{
}

HRESULT CCustomTopology::_GetMemberList()
{
    FreeCusTopMembers(&m_MemberList);

    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)m_piReplicaSet);

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = m_piReplicaSet->GetMemberListEx(&var);
    RETURN_IF_FAILED(hr);

    if (V_VT(&var) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa_1 = V_ARRAY(&var);
    if (!psa_1) // no member at all
        return hr;

    long    lLowerBound_1 = 0;
    long    lUpperBound_1 = 0;
    long    lCount_1 = 0;
    SafeArrayGetLBound(psa_1, 1, &lLowerBound_1);
    SafeArrayGetUBound(psa_1, 1, &lUpperBound_1);
    lCount_1 = lUpperBound_1 - lLowerBound_1 + 1;

    VARIANT HUGEP *pArray_1;
    SafeArrayAccessData(psa_1, (void HUGEP **) &pArray_1);

    for (long i = 0; i < lCount_1; i++)
    {
        if (V_VT(&(pArray_1[i])) != (VT_ARRAY | VT_VARIANT))
        {
            hr = E_INVALIDARG;
            break;
        }

        SAFEARRAY   *psa_0 = V_ARRAY(&(pArray_1[i]));
        if (!psa_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        long    lLowerBound_0 = 0;
        long    lUpperBound_0 = 0;
        long    lCount_0 = 0;
        SafeArrayGetLBound(psa_0, 1, &lLowerBound_0);
        SafeArrayGetUBound(psa_0, 1, &lUpperBound_0);
        lCount_0 = lUpperBound_0 - lLowerBound_0 + 1;
        if (NUM_OF_FRSMEMBER_ATTRS != lCount_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        VARIANT HUGEP *pArray_0;
        SafeArrayAccessData(psa_0, (void HUGEP **) &pArray_0);

        do {
            CCusTopMember* pNew = new CCusTopMember;
            BREAK_OUTOFMEMORY_IF_NULL(pNew, &hr);

            hr = pNew->Init(
                pArray_0[2].bstrVal, //bstrMemberDN,
                pArray_0[4].bstrVal, //bstrServer,
                pArray_0[6].bstrVal //bstrSite
                );

            if (SUCCEEDED(hr))
                m_MemberList.push_back(pNew);
            else
                delete pNew;

        } while (0);

        SafeArrayUnaccessData(psa_0);
    }

    SafeArrayUnaccessData(psa_1);

    if (SUCCEEDED(hr))
    {
        //
        // sort member list on m_bstrServer alphabetically
        //
        hr = _SortMemberList();
    }

    if (FAILED(hr))
        FreeCusTopMembers(&m_MemberList);

    SafeArrayDestroy(psa_1); // it should free psa_0 as well

    return hr;
}

HRESULT CCustomTopology::_GetConnectionList()
{
    FreeCusTopConnections(&m_ConnectionList);

    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)m_piReplicaSet);

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = m_piReplicaSet->GetConnectionListEx(&var);
    RETURN_IF_FAILED(hr);

    if (V_VT(&var) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa_1 = V_ARRAY(&var);
    if (!psa_1) // no connection at all
        return hr;

    long    lLowerBound_1 = 0;
    long    lUpperBound_1 = 0;
    long    lCount_1 = 0;
    SafeArrayGetLBound(psa_1, 1, &lLowerBound_1);
    SafeArrayGetUBound(psa_1, 1, &lUpperBound_1);
    lCount_1 = lUpperBound_1 - lLowerBound_1 + 1;

    VARIANT HUGEP *pArray_1;
    SafeArrayAccessData(psa_1, (void HUGEP **) &pArray_1);

    for (long i = 0; i < lCount_1; i++)
    {
        if (V_VT(&(pArray_1[i])) != (VT_ARRAY | VT_VARIANT))
        {
            hr = E_INVALIDARG;
            break;
        }

        SAFEARRAY   *psa_0 = V_ARRAY(&(pArray_1[i]));
        if (!psa_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        long    lLowerBound_0 = 0;
        long    lUpperBound_0 = 0;
        long    lCount_0 = 0;
        SafeArrayGetLBound(psa_0, 1, &lLowerBound_0);
        SafeArrayGetUBound(psa_0, 1, &lUpperBound_0);
        lCount_0 = lUpperBound_0 - lLowerBound_0 + 1;
        if (NUM_OF_FRSCONNECTION_ATTRS != lCount_0)
        {
            hr = E_INVALIDARG;
            break;
        }

        VARIANT HUGEP *pArray_0;
        SafeArrayAccessData(psa_0, (void HUGEP **) &pArray_0);

        do {
            CComBSTR bstrFromServer;
            CComBSTR bstrFromSite;
            hr = _GetMemberDNInfo(pArray_0[1].bstrVal, &bstrFromServer, &bstrFromSite);
            BREAK_IF_FAILED(hr);

            CComBSTR bstrToServer;
            CComBSTR bstrToSite;
            hr = _GetMemberDNInfo(pArray_0[2].bstrVal, &bstrToServer, &bstrToSite);
            BREAK_IF_FAILED(hr);

            BOOL bSyncImmediately = (BOOL)(NTDSCONN_IGNORE_SCHEDULE(pArray_0[4].lVal));
            Connection_Priority nPriority = PRIORITY_LOW;
            switch ((pArray_0[4].lVal & FRSCONN_PRIORITY_MASK) >> 28)
            {
            case 1:
            case 2:
                nPriority = PRIORITY_HIGH;
                break;
            case 3:
            case 4:
                nPriority = PRIORITY_MEDIUM;
                break;
            default:
                nPriority = PRIORITY_LOW;
                break;
            }

            CCusTopConnection* pNew = new CCusTopConnection;
            BREAK_OUTOFMEMORY_IF_NULL(pNew, &hr);
            hr = pNew->Init(
                            pArray_0[1].bstrVal, //bstrFromDN,
                            bstrFromServer,
                            bstrFromSite,
                            pArray_0[2].bstrVal, //bstrToDN,
                            bstrToServer,
                            bstrToSite,
                            (BOOL)(pArray_0[3].lVal),  //bEnable
                            CONNECTION_OPTYPE_OTHERS,
                            bSyncImmediately,
                            nPriority
                            );

            if (SUCCEEDED(hr))
                m_ConnectionList.push_back(pNew);
            else
                delete pNew;

        } while (0);

        SafeArrayUnaccessData(psa_0);
    }

    SafeArrayUnaccessData(psa_1);

    if (FAILED(hr))
        FreeCusTopConnections(&m_ConnectionList);

    SafeArrayDestroy(psa_1);

    return hr;
}

void CCustomTopology::_Reset()
{
    m_bstrTopologyPref.Empty();
    m_bstrHubMemberDN.Empty();

    FreeCusTopMembers(&m_MemberList);
    FreeCusTopConnections(&m_ConnectionList);

    m_piReplicaSet = NULL;
}

HRESULT CCustomTopology::put_ReplicaSet
(
  IReplicaSet* i_piReplicaSet
)
{
    RETURN_INVALIDARG_IF_NULL(i_piReplicaSet);

    _Reset();

    m_piReplicaSet = i_piReplicaSet;

    HRESULT hr = S_OK;

    do {
        hr = m_piReplicaSet->get_TopologyPref(&m_bstrTopologyPref);
        BREAK_IF_FAILED(hr);

        hr = m_piReplicaSet->get_HubMemberDN(&m_bstrHubMemberDN);
        BREAK_IF_FAILED(hr);

        hr = _GetMemberList();
        BREAK_IF_FAILED(hr);

        hr = _GetConnectionList();
        BREAK_IF_FAILED(hr);
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

int __cdecl CusTopMemberCompareServer(const void *arg1, const void *arg2 )
{
    return lstrcmpi(
                    (*(CCusTopMember**)arg1)->m_bstrServer,
                    (*(CCusTopMember**)arg2)->m_bstrServer
                    );
}

HRESULT CCustomTopology::_SortMemberList()
{
    HRESULT hr = S_OK;
    int     cMembers = m_MemberList.size();
    if (2 > cMembers)
        return hr;

    CCusTopMember** ppMember = (CCusTopMember **)calloc(cMembers, sizeof(CCusTopMember *));
    RETURN_OUTOFMEMORY_IF_NULL(ppMember);

    int i = 0;
    for (CCusTopMemberList::iterator it = m_MemberList.begin(); it != m_MemberList.end(); it++, i++)
    {
       ppMember[i] = (*it);
    }

    qsort((void *)ppMember, cMembers, sizeof(CCusTopMember *), CusTopMemberCompareServer);

    m_MemberList.clear();  // without deleting the object
    for (i = 0; i < cMembers; i++)
    {
        m_MemberList.push_back(ppMember[i]);
    }

    free((void *)ppMember);

    return hr;
}

HRESULT CCustomTopology::_GetMemberDNInfo(
    IN  BSTR    i_bstrMemberDN,
    OUT BSTR*   o_pbstrServer,
    OUT BSTR*   o_pbstrSite
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(o_pbstrServer);
    RETURN_INVALIDARG_IF_NULL(o_pbstrSite);

   for (CCusTopMemberList::iterator i = m_MemberList.begin(); i != m_MemberList.end(); i++)
   {
       if (!lstrcmpi(i_bstrMemberDN, (*i)->m_bstrMemberDN))
        break;
   }

   if (i == m_MemberList.end())
       return S_FALSE;

   *o_pbstrServer = (*i)->m_bstrServer.Copy();
   RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrServer);

   *o_pbstrSite = (*i)->m_bstrSite.Copy();
    if (!*o_pbstrSite)
    {
        SysFreeString(*o_pbstrServer);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

HRESULT CCustomTopology::_GetHubMember(
    OUT CCusTopMember** o_ppHubMember
    )
{
    RETURN_INVALIDARG_IF_NULL(o_ppHubMember);

    int     index = SendDlgItemMessage(IDC_FRS_CUSTOP_HUBSERVER, CB_GETCURSEL, 0, 0);
    int     len = SendDlgItemMessage(IDC_FRS_CUSTOP_HUBSERVER, CB_GETLBTEXTLEN, index, 0);
    PTSTR   pszServer = (PTSTR)calloc(len + 1, sizeof(TCHAR));
    RETURN_OUTOFMEMORY_IF_NULL(pszServer);

    SendDlgItemMessage(IDC_FRS_CUSTOP_HUBSERVER, CB_GETLBTEXT, index, (LPARAM)pszServer);

    CCusTopMemberList::iterator i;
    for (i = m_MemberList.begin(); i != m_MemberList.end(); i++)
    {
        if (!lstrcmpi(pszServer, (*i)->m_bstrServer))
         break;
    }

    free(pszServer);

    if (i == m_MemberList.end())
        return E_INVALIDARG;

    *o_ppHubMember = (*i);

    return S_OK;
}

LRESULT CCustomTopology::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    int i = 0;
    int nControlID = 0;

    //
    // set IDC_FRS_CUSTOP_TOPOLOGYPREF
    //
    nControlID = IDC_FRS_CUSTOP_TOPOLOGYPREF;
    for (i = 0; i < 4; i++)
    {
        CComBSTR bstrTopologyPref;
        LoadStringFromResource(g_TopologyPref[i].nStringID, &bstrTopologyPref);
        SendDlgItemMessage(nControlID, CB_INSERTSTRING, i, (LPARAM)(BSTR)bstrTopologyPref);
        if (!lstrcmpi(m_bstrTopologyPref, g_TopologyPref[i].pszTopologyPref))
        {
            SendDlgItemMessage(nControlID, CB_SETCURSEL, i, 0);
            ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_REBUILD), (0 != lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM)));
        }
    }

    //
    // set IDC_FRS_CUSTOP_HUBSERVER
    //
    nControlID = IDC_FRS_CUSTOP_HUBSERVER;
    int index = 0;
    CCusTopMemberList::iterator itMem;
    for (i = 0, itMem = m_MemberList.begin(); itMem != m_MemberList.end(); i++, itMem++)
    {
        SendDlgItemMessage(nControlID, CB_INSERTSTRING, i, (LPARAM)(BSTR)(*itMem)->m_bstrServer);
        if (!lstrcmpi(m_bstrHubMemberDN, (*itMem)->m_bstrMemberDN))
            index = i;
    }
    SendDlgItemMessage(nControlID, CB_SETCURSEL, index, 0);

    if (lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER), FALSE);
    }

    //
    // set IDC_FRS_CUSTOP_CONNECTIONS
    //
    nControlID = IDC_FRS_CUSTOP_CONNECTIONS;
    HWND hwndControl = GetDlgItem(nControlID);
    AddLVColumns(hwndControl, IDS_FRS_CUSTOP_COL_ENABLE, NUM_OF_FRS_CUSTOP_COLUMNS);
    ListView_SetExtendedListViewStyle(hwndControl, LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES);

    CCusTopConnectionList::iterator itConn;
    for (itConn = m_ConnectionList.begin(); itConn != m_ConnectionList.end(); itConn++)
        _InsertConnection(*itConn);

    ListView_SortItems( hwndControl,
                        ConnectionsListCompareProc,
                        (LPARAM)g_FRS_CUSTOP_Last_SortColumn);

    _EnableButtonsForConnectionList();

    return TRUE;  // Let the system set the focus
}

void CCustomTopology::_EnableButtonsForConnectionList()
{
    //
    // enable New/Delete/Schedule/Advanced buttons accordingly
    //
    HWND hwndList = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_ADVANCED), (ListView_GetItemCount(hwndList) >= 1));

    int nCount = ListView_GetSelectedCount(hwndList);
    ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_SCHEDULE), (nCount >= 1));

    int index = SendDlgItemMessage(IDC_FRS_CUSTOP_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
    if (3 == index) // bCustomTopology
    {
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_NEW), TRUE);
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_DELETE), (nCount >= 1));
    } else
    {
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_NEW), FALSE);
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS_DELETE), FALSE);
    }
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CCustomTopology::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_CUSTOP);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CCustomTopology::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_CUSTOP);

    return TRUE;
}

BOOL CCustomTopology::_EnableRebuild()
{
    BOOL bSameTopologyPref = FALSE;
    int index = SendDlgItemMessage(IDC_FRS_CUSTOP_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
    if (lstrcmpi(FRS_RSTOPOLOGYPREF_CUSTOM, g_TopologyPref[index].pszTopologyPref) &&
        !lstrcmpi(m_bstrTopologyPref, g_TopologyPref[index].pszTopologyPref))
    {
        bSameTopologyPref = TRUE;
    }
    if (!bSameTopologyPref || 0 != lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
        return bSameTopologyPref;

    BOOL bSameHub = FALSE;
    CCusTopMember* pHubMember = NULL;
    HRESULT hr = _GetHubMember(&pHubMember);
    if (SUCCEEDED(hr))
        bSameHub = (!lstrcmpi(m_bstrHubMemberDN, pHubMember->m_bstrMemberDN));

    return bSameHub;
}

LRESULT CCustomTopology::OnTopologyPref
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT   hr = S_OK;

    if (CBN_SELCHANGE == wNotifyCode)
    {
        int index = SendDlgItemMessage(wID, CB_GETCURSEL, 0, 0);
        BOOL bCmdShow = (1 == index);
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER_LABEL), bCmdShow); 
        MyShowWindow(GetDlgItem(IDC_FRS_CUSTOP_HUBSERVER), bCmdShow); 

        if (1 == index)
        {
            CCusTopMember* pHubMember = NULL;
            hr = _GetHubMember(&pHubMember);
            if (SUCCEEDED(hr))
                hr = _RebuildConnections(FRS_RSTOPOLOGYPREF_HUBSPOKE, pHubMember);
        } else
            hr = _RebuildConnections(g_TopologyPref[index].pszTopologyPref, NULL);

        _EnableButtonsForConnectionList();

        BOOL bSameTopology = _EnableRebuild();
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_REBUILD), bSameTopology);
    }

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnHubServer
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT hr = S_OK;

    if (CBN_SELCHANGE == wNotifyCode)
    {
        CCusTopMember* pHubMember = NULL;
        hr = _GetHubMember(&pHubMember);
        if (SUCCEEDED(hr))
            hr = _RebuildConnections(FRS_RSTOPOLOGYPREF_HUBSPOKE, pHubMember);

        BOOL bSameTopology = _EnableRebuild();
        ::EnableWindow(GetDlgItem(IDC_FRS_CUSTOP_REBUILD), bSameTopology);
    }

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnRebuild
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT hr = S_OK;

    if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        CCusTopMember* pHubMember = NULL;
        hr = _GetHubMember(&pHubMember);
        if (SUCCEEDED(hr))
            hr = _RebuildConnections(m_bstrTopologyPref, pHubMember);
    } else
        hr = _RebuildConnections(m_bstrTopologyPref, NULL);

    return (SUCCEEDED(hr));
}

HRESULT CCustomTopology::_RebuildConnections(
    IN  BSTR                i_bstrTopologyPref,
    IN  CCusTopMember*      i_pHubMember)
{
    HRESULT hr = S_OK;

    //
    // delete all existing connections from list and view
    //
    CCusTopConnectionList::iterator it = m_ConnectionList.begin();
    while (it != m_ConnectionList.end())
    {
        CCusTopConnectionList::iterator itConn = it++;

        if (CONNECTION_OPTYPE_ADD == (*itConn)->m_opType)
        {
            delete (*itConn);
            m_ConnectionList.erase(itConn);
        } else
        {
            (*itConn)->m_opType = CONNECTION_OPTYPE_DEL;
        }
    }

    ListView_DeleteAllItems(GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS));

    //
    // re-create the connections as specified
    //
    if (m_MemberList.size() == 1)
        return hr;

    CCusTopMemberList::iterator n1;
    CCusTopMemberList::iterator n2;
    CCusTopConnection Conn;
    if (!lstrcmpi(i_bstrTopologyPref, FRS_RSTOPOLOGYPREF_RING))
    {
        //
        // sort member list, such that members on the same site will be neighbors
        //
        m_MemberList.sort(CusTopMemberCompareSite());

        CCusTopMemberList::iterator head;

        head = n1 = m_MemberList.begin();
        while (n1 != m_MemberList.end())
        {
            n2 = n1++;
            if (n1 == m_MemberList.end())
            {
                if (m_MemberList.size() == 2)
                    break;

                n1 = head;
            }

            hr = Conn.Init((*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        (*n2)->m_bstrMemberDN, (*n2)->m_bstrServer, (*n2)->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);

            hr = Conn.Init((*n2)->m_bstrMemberDN, (*n2)->m_bstrServer, (*n2)->m_bstrSite,
                        (*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);

            if (n1 == head)
                break;
        }
    } else if (!lstrcmpi(i_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        for (n1 = m_MemberList.begin(); n1 != m_MemberList.end(); n1++)
        {
            if (!lstrcmpi((*n1)->m_bstrMemberDN, i_pHubMember->m_bstrMemberDN))
                continue;

            hr = Conn.Init((*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        i_pHubMember->m_bstrMemberDN, i_pHubMember->m_bstrServer, i_pHubMember->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);

            hr = Conn.Init(i_pHubMember->m_bstrMemberDN, i_pHubMember->m_bstrServer, i_pHubMember->m_bstrSite,
                        (*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                        TRUE, CONNECTION_OPTYPE_ADD);
            BREAK_IF_FAILED(hr);
            hr = _AddToConnectionListAndView(&Conn);
            BREAK_IF_FAILED(hr);
        }
    } else if (!lstrcmpi(i_bstrTopologyPref, FRS_RSTOPOLOGYPREF_FULLMESH))
    {
        for (n1 = m_MemberList.begin(); n1 != m_MemberList.end(); n1++)
        {
            for (n2 = m_MemberList.begin(); n2 != m_MemberList.end(); n2++)
            {
                if (!lstrcmpi((*n1)->m_bstrMemberDN, (*n2)->m_bstrMemberDN))
                    continue;

                hr = Conn.Init((*n1)->m_bstrMemberDN, (*n1)->m_bstrServer, (*n1)->m_bstrSite,
                            (*n2)->m_bstrMemberDN, (*n2)->m_bstrServer, (*n2)->m_bstrSite,
                            TRUE, CONNECTION_OPTYPE_ADD);
                BREAK_IF_FAILED(hr);
                hr = _AddToConnectionListAndView(&Conn);
                BREAK_IF_FAILED(hr);
            }
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}

HRESULT CCustomTopology::_SetConnectionState(CCusTopConnection *pConn)
{
    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL);
    while (-1 != nIndex)
    {
        if (pConn == (CCusTopConnection *)GetListViewItemData(hwnd, nIndex))
            break;

        nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL);
    }

    if (-1 != nIndex)
    {
        ListView_SetCheckState(hwnd, nIndex, pConn->m_bStateNew);
        ListView_Update(hwnd, nIndex);
    }

    return S_OK;
}

HRESULT CCustomTopology::_InsertConnection(CCusTopConnection *pConn)
{
    RETURN_INVALIDARG_IF_NULL(pConn);

    HWND hwndControl = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    LVITEM  lvItem;

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = (LPARAM)pConn;
    lvItem.pszText = _T("");
    lvItem.iSubItem = 0;
    int iItemIndex = ListView_InsertItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrFromServer;
    lvItem.iSubItem = 1;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrToServer;
    lvItem.iSubItem = 2;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrFromSite;
    lvItem.iSubItem = 3;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pConn->m_bstrToSite;
    lvItem.iSubItem = 4;
    ListView_SetItem(hwndControl, &lvItem);
    ListView_SetCheckState(hwndControl, iItemIndex, pConn->m_bStateNew);

    ListView_Update(hwndControl, iItemIndex);

    return S_OK;
}

LRESULT CCustomTopology::OnConnectionsNew
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  HRESULT   hr = S_OK;

  CNewConnections NewConnDlg;

  // Building the RING topology might have sorted the members on sites,
  // we need to re-sort it on server alphabetically before we give it to the New Connections dialog
  _SortMemberList();

  hr = NewConnDlg.Initialize(&m_MemberList);
  if (SUCCEEDED(hr))
  {
      hr = NewConnDlg.DoModal();
      if (S_OK == hr)
      {
          CCusTopConnectionList* pNewConnectionList = NULL;
          hr = NewConnDlg.get_NewConnections(&pNewConnectionList);
          if (SUCCEEDED(hr))
          {
              HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
              int nCount = ListView_GetItemCount(hwnd);

              CCusTopConnectionList::iterator it;
              for (it = pNewConnectionList->begin(); it != pNewConnectionList->end(); it++)
              {
                  hr = _AddToConnectionListAndView(*it);
                  BREAK_IF_FAILED(hr);
              }

              if (ListView_GetItemCount(hwnd) > nCount)
                ListView_SortItems(hwnd, ConnectionsListCompareProc, (LPARAM)g_FRS_CUSTOP_Last_SortColumn);
          }
      }
  }

  // if FAILED, display msg?

  return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnConnectionsDelete
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CCusTopConnection* pConn;
    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    while (-1 != nIndex &&
            (pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex)))
    {
        _RemoveFromConnectionList(pConn);        

        ListView_DeleteItem(hwnd, nIndex);
        
        nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    }

    return TRUE;
}

HRESULT CCustomTopology::_InitScheduleOnSelectedConnections()
{
    HRESULT             hr = S_OK;
    int                 nIndex = -1;
    CCusTopConnection*  pConn = NULL;
    HWND                hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    while ( -1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL | LVNI_SELECTED)) &&
            NULL != (pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex)))
    {
        if (!pConn->m_pScheduleNew)
        {
            if (pConn->m_pScheduleOld)
            {
                hr = CopySchedule(pConn->m_pScheduleOld, &pConn->m_pScheduleNew);
                RETURN_IF_FAILED(hr);
            } else
            {
                if (CONNECTION_OPTYPE_OTHERS == pConn->m_opType)
                {
                    //
                    // read schedule on an existing connection for the very first time
                    //
                    VARIANT var;
                    VariantInit(&var);
                    hr = m_piReplicaSet->GetConnectionScheduleEx(pConn->m_bstrFromMemberDN, pConn->m_bstrToMemberDN, &var);
                    RETURN_IF_FAILED(hr);

                    hr = VariantToSchedule(&var, &pConn->m_pScheduleOld);

                    VariantClear(&var);

                    if (SUCCEEDED(hr))
                        hr = CopySchedule(pConn->m_pScheduleOld, &pConn->m_pScheduleNew);

                    RETURN_IF_FAILED(hr);
                } else
                { // must be ADD operation
                    hr = GetDefaultSchedule(&pConn->m_pScheduleNew);
                    RETURN_IF_FAILED(hr);
                }
            }
        }
    }

    return hr;
}

HRESULT CCustomTopology::_UpdateScheduleOnSelectedConnections(IN SCHEDULE* i_pSchedule)
{
    HRESULT             hr = S_OK;
    int                 nIndex = -1;
    CCusTopConnection*  pConn = NULL;
    HWND                hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    while ( -1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL | LVNI_SELECTED)) &&
            NULL != (pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex)))
    {
        if (pConn->m_pScheduleNew)
        {
            free(pConn->m_pScheduleNew);
            pConn->m_pScheduleNew = NULL;
        }

        hr = CopySchedule(i_pSchedule, &pConn->m_pScheduleNew);
        BREAK_IF_FAILED(hr);
    }

    return hr;
}

LRESULT CCustomTopology::OnSchedule
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HRESULT hr = S_OK;

    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    int nCount = ListView_GetSelectedCount(hwnd);
    if (nCount < 1)
    {
        DisplayMessageBoxWithOK(IDS_FRS_CUSTOP_NOSELECTION);
        return FALSE;
    }

    do {
        //
        // get schedule info on each selected connections
        //
        hr = _InitScheduleOnSelectedConnections();
        BREAK_IF_FAILED(hr);

        //
        // get schedule of the first selected item
        //
        int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
        if (-1 == nIndex)
        {
            hr = E_INVALIDARG;
            break;
        }

        CCusTopConnection* pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex);
        if (!pConn)
        {
            hr = E_INVALIDARG;
            break;
        }

        SCHEDULE* pSchedule = NULL;
        hr = CopySchedule(pConn->m_pScheduleNew, &pSchedule);
        BREAK_IF_FAILED(hr);

        hr = InvokeScheduleDlg(m_hWnd, pSchedule);

        if (S_OK == hr)
            hr = _UpdateScheduleOnSelectedConnections(pSchedule);

        free(pSchedule);

    } while (0);

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnAdvanced
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);

    //
    // get ToServer of the first selected connection
    //
    PTSTR pszToServer = NULL;
    int nIndex = ListView_GetNextItem(hwnd, -1, LVNI_ALL | LVNI_SELECTED);
    if (-1 != nIndex)
    {
        CCusTopConnection* pConn = (CCusTopConnection *)GetListViewItemData(hwnd, nIndex);
        if (pConn)
        {
            pszToServer = pConn->m_bstrToServer;
        }
    }

    // Building the RING topology might have sorted the members on sites,
    // we need to re-sort it on server alphabetically before we give it to the Advanced dialog
    _SortMemberList();

    CFRSAdvanced frsAdvancedDlg;
    HRESULT hr = frsAdvancedDlg.Initialize(&m_MemberList, &m_ConnectionList, pszToServer);
    if (SUCCEEDED(hr))
    {
        hr = frsAdvancedDlg.DoModal();
    }

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return (SUCCEEDED(hr));
}

LRESULT CCustomTopology::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CWaitCursor wait;
    BOOL      bValidInput = FALSE;
    int       idString = 0;
    HRESULT   hr = S_OK;

    do {
        //
        // if changed, update TopologyPref
        //
        int index = SendDlgItemMessage(IDC_FRS_CUSTOP_TOPOLOGYPREF, CB_GETCURSEL, 0, 0);
        if (0 != lstrcmpi(m_bstrTopologyPref, g_TopologyPref[index].pszTopologyPref))
        {
            hr = m_piReplicaSet->put_TopologyPref(g_TopologyPref[index].pszTopologyPref);
            BREAK_IF_FAILED(hr);
        }

        //
        // if changed, update HubServer
        //
        if (!lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE) &&
            0 != lstrcmpi(g_TopologyPref[index].pszTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
        {
            hr = m_piReplicaSet->put_HubMemberDN(NULL);
            BREAK_IF_FAILED(hr);
        } else if (!lstrcmpi(g_TopologyPref[index].pszTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
        {
            CCusTopMember* pHubMember = NULL;
            hr = _GetHubMember(&pHubMember);
            BREAK_IF_FAILED(hr);

            if (0 != lstrcmpi(m_bstrHubMemberDN, pHubMember->m_bstrMemberDN))
                hr = m_piReplicaSet->put_HubMemberDN(pHubMember->m_bstrMemberDN);

            BREAK_IF_FAILED(hr);
        }

        //
        // if changed, update connections
        //
        CCusTopConnection* pConn = NULL;
        HWND hwnd = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
        index = -1;
        while (-1 != (index = ListView_GetNextItem(hwnd, index, LVNI_ALL)))
        {
            pConn = (CCusTopConnection *)GetListViewItemData(hwnd, index);
            if (pConn)
                pConn->m_bStateNew = ListView_GetCheckState(hwnd, index);
        }

        hr = _MakeConnections();
        BREAK_IF_FAILED(hr);

        bValidInput = TRUE;

    } while (0);

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        return FALSE;
    } else if (bValidInput)
    {
        EndDialog(S_OK);
        return TRUE;
    }
    else
    {
        if (idString)
            DisplayMessageBoxWithOK(idString);
        return FALSE;
    }
}

LRESULT CCustomTopology::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

int CALLBACK ConnectionsListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn)
{
  CCusTopConnection* pItem1 = (CCusTopConnection *)lParam1;
  CCusTopConnection* pItem2 = (CCusTopConnection *)lParam2;
  int iResult = 0;

  if (pItem1 && pItem2)
  {
    g_FRS_CUSTOP_Last_SortColumn = lParamColumn;

    switch (lParamColumn)
    {
    case 0:     // Sort by bStateNew.
      iResult = pItem1->m_bStateNew - pItem2->m_bStateNew;
      break;
    case 1:     // Sort by From Server.
      iResult = lstrcmpi(pItem1->m_bstrFromServer, pItem2->m_bstrFromServer);
      break;
    case 2:     // Sort by To Server.
      iResult = lstrcmpi(pItem1->m_bstrToServer, pItem2->m_bstrToServer);
      break;
    case 3:     // Sort by From Site.
      iResult = lstrcmpi(pItem1->m_bstrFromSite, pItem2->m_bstrFromSite);
      break;
    case 4:     // Sort by To Site.
      iResult = lstrcmpi(pItem1->m_bstrToSite, pItem2->m_bstrToSite);
      break;
    default:
      iResult = 0;
      break;
    }
  }

  return(iResult);
}

LRESULT
CCustomTopology::OnNotify(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  IN LPARAM          i_lParam,
  IN OUT BOOL&       io_bHandled
  )
{
  NM_LISTVIEW*    pNMListView = (NM_LISTVIEW*)i_lParam;
  io_bHandled = FALSE; // So that the base class gets this notify too

  if (IDC_FRS_CUSTOP_CONNECTIONS == pNMListView->hdr.idFrom)
  {
    HWND hwndList = GetDlgItem(IDC_FRS_CUSTOP_CONNECTIONS);
    if (LVN_COLUMNCLICK == pNMListView->hdr.code)
    {
      // sort items
      ListView_SortItems( hwndList,
                          ConnectionsListCompareProc,
                          (LPARAM)(pNMListView->iSubItem));
      io_bHandled = TRUE;
    } else if (LVN_ITEMCHANGED == pNMListView->hdr.code)
    {
        _EnableButtonsForConnectionList();
    }
  }

  return io_bHandled;
}

//
// Update the connection objects in the DS
//
HRESULT CCustomTopology::_MakeConnections()
{
    HRESULT hr = S_OK;

    CCusTopConnectionList::iterator it;
    for (it = m_ConnectionList.begin(); it != m_ConnectionList.end(); it++)
    {
        switch ((*it)->m_opType)
        {
        case CONNECTION_OPTYPE_ADD:
            hr = m_piReplicaSet->AddConnection(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN,
                                    (*it)->m_bStateNew,
                                    (*it)->m_bSyncImmediatelyNew,
                                    (*it)->m_nPriorityNew,
                                    NULL
                                    );
            BREAK_IF_FAILED(hr);

            if ((*it)->m_pScheduleNew)
            {
                VARIANT var;
                VariantInit(&var);
                hr = ScheduleToVariant((*it)->m_pScheduleNew, &var);
                BREAK_IF_FAILED(hr);

                hr = m_piReplicaSet->SetConnectionScheduleEx(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN,
                                    &var);
                VariantClear(&var);
            }
            break;

        case CONNECTION_OPTYPE_DEL:
            hr = m_piReplicaSet->RemoveConnectionEx(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN
                                    );
            break;

        default:
            if ((*it)->m_bStateNew != (*it)->m_bStateOld)
            {
                hr = m_piReplicaSet->EnableConnectionEx(
                                        (*it)->m_bstrFromMemberDN,
                                        (*it)->m_bstrToMemberDN,
                                        (*it)->m_bStateNew
                                        );
                BREAK_IF_FAILED(hr);
            }

            if ((*it)->m_bSyncImmediatelyNew != (*it)->m_bSyncImmediatelyOld ||
                (*it)->m_nPriorityNew != (*it)->m_nPriorityOld)
            {
                hr = m_piReplicaSet->SetConnectionOptionsEx(
                                        (*it)->m_bstrFromMemberDN,
                                        (*it)->m_bstrToMemberDN,
                                        (*it)->m_bSyncImmediatelyNew,
                                        (*it)->m_nPriorityNew
                                        );
                BREAK_IF_FAILED(hr);
            }

            if (S_OK == CompareSchedules((*it)->m_pScheduleNew, (*it)->m_pScheduleOld))
                break;  // no change on shcedule

            if ((*it)->m_pScheduleNew)
            {
                VARIANT var;
                VariantInit(&var);
                hr = ScheduleToVariant((*it)->m_pScheduleNew, &var);
                BREAK_IF_FAILED(hr);

                hr = m_piReplicaSet->SetConnectionScheduleEx(
                                    (*it)->m_bstrFromMemberDN,
                                    (*it)->m_bstrToMemberDN,
                                    &var);
                VariantClear(&var);
            }

            break;
        }

        BREAK_IF_FAILED(hr);
    }

    return hr;
}

//////////////////////////////////////////////////////////
//
//

void FreeCusTopMembers(CCusTopMemberList* pList)
{
    if (pList && !pList->empty())
   {
       for (CCusTopMemberList::iterator i = pList->begin(); i != pList->end(); i++)
           delete (*i);

       pList->clear();
   }
}

void FreeCusTopConnections(CCusTopConnectionList* pList)
{
    if (pList && !pList->empty())
   {
       for (CCusTopConnectionList::iterator i = pList->begin(); i != pList->end(); i++)
           delete (*i);

       pList->clear();
   }
}

//////////////////////////////////////////////////////////
//
// CCusTopMember
//
CCusTopMember::~CCusTopMember()
{
    _Reset();
}

HRESULT CCusTopMember::Init(BSTR bstrMemberDN, BSTR bstrServer, BSTR bstrSite)
{
    RETURN_INVALIDARG_IF_NULL(bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(bstrServer);
    RETURN_INVALIDARG_IF_NULL(bstrSite);

    _Reset();

    HRESULT hr = S_OK;
    do {
        m_bstrMemberDN = bstrMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrMemberDN, &hr);
        m_bstrServer = bstrServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrServer, &hr);
        m_bstrSite = bstrSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrSite, &hr);
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

void CCusTopMember::_Reset()
{
    m_bstrMemberDN.Empty();
    m_bstrServer.Empty();
    m_bstrSite.Empty();
}

//////////////////////////////////////////////////////////
//
// CCusTopConnection
//
CCusTopConnection::CCusTopConnection()
{
    m_bStateNew = m_bStateOld= TRUE;
    m_bSyncImmediatelyNew = m_bSyncImmediatelyOld = FALSE;
    m_nPriorityNew = m_nPriorityOld = PRIORITY_LOW;
    m_pScheduleNew = m_pScheduleOld = NULL;
    m_opType = CONNECTION_OPTYPE_OTHERS;
}

CCusTopConnection::~CCusTopConnection()
{
    _Reset();
}

HRESULT CCusTopConnection::Init(
    BSTR bstrFromMemberDN, BSTR bstrFromServer, BSTR bstrFromSite,
    BSTR bstrToMemberDN, BSTR bstrToServer, BSTR bstrToSite,
    BOOL bState, // = TRUE
    CONNECTION_OPTYPE opType, // = CONNECTION_OPTYPE_OTHERS
    BOOL bSyncImmediately, // = FALSE,
    Connection_Priority nPriority // = PRIORITY_LOW
    )
{
    RETURN_INVALIDARG_IF_NULL(bstrFromMemberDN);
    RETURN_INVALIDARG_IF_NULL(bstrFromServer);
    RETURN_INVALIDARG_IF_NULL(bstrFromSite);

    RETURN_INVALIDARG_IF_NULL(bstrToMemberDN);
    RETURN_INVALIDARG_IF_NULL(bstrToServer);
    RETURN_INVALIDARG_IF_NULL(bstrToSite);

    _Reset();

    HRESULT hr = S_OK;
    do {
        m_bstrFromMemberDN = bstrFromMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromMemberDN, &hr);
        m_bstrFromServer = bstrFromServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromServer, &hr);
        m_bstrFromSite = bstrFromSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromSite, &hr);

        m_bstrToMemberDN = bstrToMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToMemberDN, &hr);
        m_bstrToServer = bstrToServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToServer, &hr);
        m_bstrToSite = bstrToSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToSite, &hr);

        m_bStateNew = m_bStateOld = bState;

        m_opType = opType;

        m_pScheduleOld = m_pScheduleNew = NULL;

        m_bSyncImmediatelyNew = m_bSyncImmediatelyOld = bSyncImmediately;

        m_nPriorityNew = m_nPriorityOld = nPriority;

    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

void CCusTopConnection::_Reset()
{
    m_bstrFromMemberDN.Empty();
    m_bstrFromServer.Empty();
    m_bstrFromSite.Empty();
    m_bstrToMemberDN.Empty();
    m_bstrToServer.Empty();
    m_bstrToSite.Empty();
    m_bStateOld = TRUE;
    m_bStateNew = TRUE;
    m_opType = CONNECTION_OPTYPE_OTHERS;
    m_bSyncImmediatelyNew = m_bSyncImmediatelyOld = FALSE;
    m_nPriorityNew = m_nPriorityOld = PRIORITY_LOW;

    if (m_pScheduleOld)
    {
        free(m_pScheduleOld);
        m_pScheduleOld = NULL;
    }

    if (m_pScheduleNew)
    {
        free(m_pScheduleNew);
        m_pScheduleNew = NULL;
    }
}

HRESULT CCusTopConnection::Copy(CCusTopConnection* pConn)
{
    if (!pConn || !(pConn->m_bstrFromMemberDN) || !*(pConn->m_bstrFromMemberDN))
        return E_INVALIDARG;

    _Reset();

    HRESULT hr = S_OK;
    do {
        m_bstrFromMemberDN = pConn->m_bstrFromMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromMemberDN, &hr);
        m_bstrFromServer = pConn->m_bstrFromServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromServer, &hr);
        m_bstrFromSite = pConn->m_bstrFromSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrFromSite, &hr);

        m_bstrToMemberDN = pConn->m_bstrToMemberDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToMemberDN, &hr);
        m_bstrToServer = pConn->m_bstrToServer;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToServer, &hr);
        m_bstrToSite = pConn->m_bstrToSite;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)m_bstrToSite, &hr);

        m_bStateOld = pConn->m_bStateOld;
        m_bStateNew = pConn->m_bStateNew;

        m_bSyncImmediatelyOld = pConn->m_bSyncImmediatelyOld;
        m_bSyncImmediatelyNew = pConn->m_bSyncImmediatelyNew;

        m_nPriorityOld = pConn->m_nPriorityOld;
        m_nPriorityNew = pConn->m_nPriorityNew;

        m_opType = pConn->m_opType;

        if (pConn->m_pScheduleOld)
        {
            hr = CopySchedule(pConn->m_pScheduleOld, &m_pScheduleOld);
            BREAK_IF_FAILED(hr);
        }

        if (pConn->m_pScheduleNew)
        {
            hr = CopySchedule(pConn->m_pScheduleNew, &m_pScheduleNew);
            BREAK_IF_FAILED(hr);
        }
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

HRESULT CCustomTopology::_AddToConnectionListAndView(CCusTopConnection* pConn)
{
    RETURN_INVALIDARG_IF_NULL(pConn);

    BOOL bFound = FALSE;

    CCusTopConnectionList::iterator it;
    for (it = m_ConnectionList.begin(); it != m_ConnectionList.end(); it++)
    {
        if (!lstrcmpi((*it)->m_bstrFromMemberDN, pConn->m_bstrFromMemberDN) &&
            !lstrcmpi((*it)->m_bstrToMemberDN, pConn->m_bstrToMemberDN))
        {
            bFound = TRUE;
            break;
        }
    }

    HRESULT hr = S_OK;
    if (!bFound)
    {
        CCusTopConnection* pNew = new CCusTopConnection;
        RETURN_OUTOFMEMORY_IF_NULL(pNew);

        hr = pNew->Copy(pConn);
        if (FAILED(hr))
            delete pNew;
        else
        {
            m_ConnectionList.push_back(pNew);

            hr = _InsertConnection(pNew);
        }
    } else
    {
        (*it)->m_bStateNew = TRUE;
        (*it)->m_bSyncImmediatelyNew = FALSE;
        (*it)->m_nPriorityNew = PRIORITY_LOW;
        if ((*it)->m_opType == CONNECTION_OPTYPE_DEL)
        {
            (*it)->m_opType = CONNECTION_OPTYPE_OTHERS;
            hr = _InsertConnection(*it);
        } else
        {
            (*it)->m_opType = CONNECTION_OPTYPE_OTHERS;
            hr = _SetConnectionState(*it);
        }
    }

    return hr;
}

HRESULT CCustomTopology::_RemoveFromConnectionList(CCusTopConnection* pConn)
{
    RETURN_INVALIDARG_IF_NULL(pConn);

    BOOL bFound = FALSE;

    CCusTopConnectionList::iterator it;
    for (it = m_ConnectionList.begin(); it != m_ConnectionList.end(); it++)
    {
        if (!lstrcmpi((*it)->m_bstrFromMemberDN, pConn->m_bstrFromMemberDN) &&
            !lstrcmpi((*it)->m_bstrToMemberDN, pConn->m_bstrToMemberDN))
        {
            bFound = TRUE;
            break;
        }
    }

    if (it != m_ConnectionList.end())
    {
        if (CONNECTION_OPTYPE_ADD == (*it)->m_opType)
        {
            delete (*it);
            m_ConnectionList.erase(it);
        } else
        {
            (*it)->m_opType = CONNECTION_OPTYPE_DEL;
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//
// CNewConnections
//

CNewConnections::CNewConnections() : m_pMemberList(NULL)
{
}

CNewConnections::~CNewConnections()
{
    FreeCusTopConnections(&m_NewConnectionList);
}


HRESULT CNewConnections::Initialize
(
  CCusTopMemberList* i_pMemberList
)
{
    RETURN_INVALIDARG_IF_NULL(i_pMemberList);
    m_pMemberList = i_pMemberList;
    return S_OK;
}

#define NUM_OF_FRS_NEWCONN_COLUMNS      2

LRESULT CNewConnections::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    int nControlID[] = {IDC_FRS_NEWCONN_FROM, IDC_FRS_NEWCONN_TO};
    int nColStringID[] = {IDS_FRS_NEWCONN_COL_FROMSERVER, IDS_FRS_NEWCONN_COL_TOSERVER};

    HWND hwndControl = NULL;
    CCusTopMemberList::iterator it;

    for (int i = 0; i < 2; i++)
    {
        hwndControl = GetDlgItem(nControlID[i]);
        AddLVColumns(hwndControl, nColStringID[i], NUM_OF_FRS_NEWCONN_COLUMNS);
        ListView_SetExtendedListViewStyle(hwndControl, LVS_EX_FULLROWSELECT);

        for (it = m_pMemberList->begin(); it != m_pMemberList->end(); it++)
        {
            LVITEM  lvItem;

            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam = (LPARAM)(*it);
            lvItem.pszText = (*it)->m_bstrServer;
            lvItem.iSubItem = 0;
            int iItemIndex = ListView_InsertItem(hwndControl, &lvItem);

            lvItem.mask = LVIF_TEXT;
            lvItem.iItem = iItemIndex;
            lvItem.pszText = (*it)->m_bstrSite;
            lvItem.iSubItem = 1;
            ListView_SetItem(hwndControl, &lvItem);
        }
    }

    return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CNewConnections::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_NEWCONN);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CNewConnections::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_NEWCONN);

  return TRUE;
}

HRESULT CNewConnections::get_NewConnections(CCusTopConnectionList** ppConnectionList)
{
    RETURN_INVALIDARG_IF_NULL(ppConnectionList);
    *ppConnectionList = &m_NewConnectionList;
    return S_OK;
}

LRESULT CNewConnections::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    BOOL      bValidInput = FALSE;
    int       idString = 0;
    HRESULT   hr = S_OK;

    do {
        idString = IDS_FRS_NEWCONN_NOSELECTION;

        //
        // get all selected From servers
        //
        CCusTopMember* pMember;
        CCusTopMemberList fromMemberList;
        HWND hwndFrom = GetDlgItem(IDC_FRS_NEWCONN_FROM);
        int nIndexFrom = ListView_GetNextItem(hwndFrom, -1, LVNI_ALL | LVNI_SELECTED);
        while (-1 != nIndexFrom &&
                (pMember = (CCusTopMember *)GetListViewItemData(hwndFrom, nIndexFrom)))
        {
            fromMemberList.push_back(pMember);
            nIndexFrom = ListView_GetNextItem(hwndFrom, nIndexFrom, LVNI_ALL | LVNI_SELECTED);
        }
        if (fromMemberList.empty())
            break;

        //
        // get all selected To servers
        //
        CCusTopMemberList toMemberList;
        HWND hwndTo = GetDlgItem(IDC_FRS_NEWCONN_TO);
        int nIndexTo = ListView_GetNextItem(hwndTo, -1, LVNI_ALL | LVNI_SELECTED);
        while (-1 != nIndexTo &&
                (pMember = (CCusTopMember *)GetListViewItemData(hwndTo, nIndexTo)))
        {
            toMemberList.push_back(pMember);
            nIndexTo = ListView_GetNextItem(hwndTo, nIndexTo, LVNI_ALL | LVNI_SELECTED);
        }
        if (toMemberList.empty())
            break;

        //
        // init the list
        //
        FreeCusTopConnections(&m_NewConnectionList);

        //
        // build the connection list
        //
        CCusTopMemberList::iterator from, to;
        for (from = fromMemberList.begin(); from != fromMemberList.end(); from++)
        {
            for (to = toMemberList.begin(); to != toMemberList.end(); to++)
            {
                if (!lstrcmpi((*from)->m_bstrServer, (*to)->m_bstrServer))
                    continue;

                CCusTopConnection* pNew = new CCusTopConnection;
                BREAK_OUTOFMEMORY_IF_NULL(pNew, &hr);

                hr = pNew->Init(
                            (*from)->m_bstrMemberDN, (*from)->m_bstrServer, (*from)->m_bstrSite,
                            (*to)->m_bstrMemberDN, (*to)->m_bstrServer, (*to)->m_bstrSite,
                            TRUE, CONNECTION_OPTYPE_ADD);
                BREAK_IF_FAILED(hr);

                m_NewConnectionList.push_back(pNew);
            }
            BREAK_IF_FAILED(hr);
        }

        if (SUCCEEDED(hr))
            bValidInput = TRUE;

    } while (0);

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        return FALSE;
    } else if (bValidInput)
    {
        EndDialog(S_OK);
        return TRUE;
    }
    else
    {
        if (idString)
            DisplayMessageBoxWithOK(idString);
        return FALSE;
    }
}

LRESULT CNewConnections::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

int CALLBACK MembersListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn)
{
  CCusTopMember* pItem1 = (CCusTopMember *)lParam1;
  CCusTopMember* pItem2 = (CCusTopMember *)lParam2;
  int iResult = 0;

  if (pItem1 && pItem2)
  {
    switch( lParamColumn)
    {
    case 0:     // Sort by Server.
      iResult = lstrcmpi(pItem1->m_bstrServer, pItem2->m_bstrServer);
      break;
    case 1:     // Sort by Site.
      iResult = lstrcmpi(pItem1->m_bstrSite, pItem2->m_bstrSite);
      break;
    default:
      iResult = 0;
      break;
    }
  }

  return(iResult);
}

LRESULT
CNewConnections::OnNotify(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  IN LPARAM          i_lParam,
  IN OUT BOOL&       io_bHandled
  )
{
  NM_LISTVIEW*    pNMListView = (NM_LISTVIEW*)i_lParam;
  io_bHandled = FALSE; // So that the base class gets this notify too

  if (IDC_FRS_NEWCONN_FROM == pNMListView->hdr.idFrom ||
      IDC_FRS_NEWCONN_TO == pNMListView->hdr.idFrom)
  {
    HWND hwndList = GetDlgItem(pNMListView->hdr.idFrom);
    if (LVN_COLUMNCLICK == pNMListView->hdr.code)
    {
      // sort items
      ListView_SortItems( hwndList,
                          MembersListCompareProc,
                          (LPARAM)(pNMListView->iSubItem));
      io_bHandled = TRUE;
    }
  }

  return io_bHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\custop.h ===
/*++
Module Name:

    CusTop.cpp

Abstract:

    This module contains the declaration of the CCustomTopology.
    This class displays the Customize Topology Dialog.

*/

#ifndef __CUSTOP_H_
#define __CUSTOP_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"
#include "DfsCore.h"
#include <schedule.h>

#include <list>
using namespace std;

class CCusTopMember
{
public:
    ~CCusTopMember();

    CComBSTR    m_bstrMemberDN;
    CComBSTR    m_bstrServer;
    CComBSTR    m_bstrSite;
    HRESULT Init(BSTR bstrMemberDN, BSTR bstrServer, BSTR bstrSite);

    void _Reset();
};

typedef list<CCusTopMember *>    CCusTopMemberList;

void FreeCusTopMembers(CCusTopMemberList *pList);

class CCusTopConnection
{
public:
    CCusTopConnection();
    ~CCusTopConnection();

    CComBSTR    m_bstrFromMemberDN;
    CComBSTR    m_bstrFromServer;
    CComBSTR    m_bstrFromSite;
    CComBSTR    m_bstrToMemberDN;
    CComBSTR    m_bstrToServer;
    CComBSTR    m_bstrToSite;
    BOOL        m_bStateOld;
    BOOL        m_bStateNew;
    SCHEDULE*   m_pScheduleOld;
    SCHEDULE*   m_pScheduleNew;
    CONNECTION_OPTYPE m_opType;
    BOOL        m_bSyncImmediatelyOld;
    BOOL        m_bSyncImmediatelyNew;
    Connection_Priority m_nPriorityOld;
    Connection_Priority m_nPriorityNew;
    HRESULT Init(
        BSTR bstrFromMemberDN, BSTR bstrFromServer, BSTR bstrFromSite,
        BSTR bstrToMemberDN, BSTR bstrToServer, BSTR bstrToSite,
        BOOL bState = TRUE, CONNECTION_OPTYPE opType = CONNECTION_OPTYPE_OTHERS,
        BOOL bSyncImmediately = FALSE, Connection_Priority nPriority = PRIORITY_LOW);
    HRESULT Copy(CCusTopConnection* pConn);

    void _Reset();
};

typedef list<CCusTopConnection *>    CCusTopConnectionList;

void FreeCusTopConnections(CCusTopConnectionList *pList);

typedef struct _RSTOPOLOGYPREF_STRING
{
    PTSTR   pszTopologyPref;
    int     nStringID;
} RSTOPOLOGYPREF_STRING;

extern RSTOPOLOGYPREF_STRING g_TopologyPref[];

/////////////////////////////////////////////////////////////////////////////
// CCustomTopology
class CCustomTopology : 
  public CDialogImpl<CCustomTopology>
{
public:
    CCustomTopology();
    ~CCustomTopology();

    enum { IDD = IDD_FRS_CUSTOM_TOPOLOGY };

BEGIN_MSG_MAP(CCustomTopology)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_TOPOLOGYPREF, OnTopologyPref)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_HUBSERVER, OnHubServer)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_REBUILD, OnRebuild)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_CONNECTIONS_NEW, OnConnectionsNew)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_CONNECTIONS_DELETE, OnConnectionsDelete)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_SCHEDULE, OnSchedule)
    COMMAND_ID_HANDLER(IDC_FRS_CUSTOP_ADVANCED, OnAdvanced)
END_MSG_MAP()

    //  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTopologyPref(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHubServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRebuild(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnectionsNew(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnConnectionsDelete(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSchedule(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNotify(
                    IN UINT            i_uMsg, 
                    IN WPARAM          i_wParam, 
                    IN LPARAM          i_lParam, 
                    IN OUT BOOL&        io_bHandled
                    );

    //  Methods to access data in the dialog.
    HRESULT put_ReplicaSet(IReplicaSet* i_piReplicaSet);

protected:
    void    _Reset();
    void    _EnableButtonsForConnectionList();
    BOOL    _EnableRebuild();
    HRESULT _AddToConnectionListAndView(CCusTopConnection *pConn);
    HRESULT _RemoveFromConnectionList(CCusTopConnection *pConn);
    HRESULT _SetConnectionState(CCusTopConnection *pConn);
    HRESULT _InsertConnection(CCusTopConnection *pConn);
    HRESULT _SortMemberList();
    HRESULT _GetMemberList();
    HRESULT _GetConnectionList();
    HRESULT _GetMemberDNInfo(
        IN  BSTR    i_bstrMemberDN,
        OUT BSTR*   o_pbstrServer,
        OUT BSTR*   o_pbstrSite
        );
    HRESULT _GetHubMember(
        OUT CCusTopMember** o_ppMember
        );

    HRESULT _RebuildConnections(
        IN  BSTR            i_bstrTopologyPref,
        IN  CCusTopMember*  i_pHubMember
        );

    HRESULT _MakeConnections();

    HRESULT _InitScheduleOnSelectedConnections();
    HRESULT _UpdateScheduleOnSelectedConnections(IN SCHEDULE* i_pSchedule);

    CComBSTR                m_bstrTopologyPref;  // FRS_RSTOPOLOGYPREF
    CComBSTR                m_bstrHubMemberDN;    // HubMemberDN
    CComPtr<IReplicaSet>    m_piReplicaSet;
    CCusTopMemberList       m_MemberList;
    CCusTopConnectionList   m_ConnectionList;
};

/////////////////////////////////////////////////////////////////////////////
// CNewConnections
class CNewConnections : 
  public CDialogImpl<CNewConnections>
{
public:
    CNewConnections();
    ~CNewConnections();

    enum { IDD = IDD_FRS_NEW_CONNECTIONS };

BEGIN_MSG_MAP(CNewConnections)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

    //  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNotify(
                    IN UINT            i_uMsg, 
                    IN WPARAM          i_wParam, 
                    IN LPARAM          i_lParam, 
                    IN OUT BOOL&        io_bHandled
                    );

    HRESULT Initialize(CCusTopMemberList* i_pMemberList);
    HRESULT get_NewConnections(CCusTopConnectionList** ppConnectionList);

protected:
    CCusTopMemberList*      m_pMemberList;       // do not release it 
    CCusTopConnectionList   m_NewConnectionList; // released in desctructor
};

int CALLBACK ConnectionsListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn);

int CALLBACK MembersListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn);

#endif //__CUSTOP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsnodes.h ===
/*++
Module Name:

   DfsNodes.h

Abstract:

    Contains the declaration of DfsAdmin Snapin GUIDs for Nodes.

--*/

#ifndef _DFS_NODES_H
#define _DFS_NODES_H

extern GUID      s_guidDfsReplicaNodeType;

extern GUID      s_guidDfsJPNodeType;

extern GUID      s_guidDfsRootNodeType;

extern GUID      s_guidDfsAdminNodeType;

extern TCHAR*    s_tchDfsReplicaNodeType;

extern TCHAR*    s_tchDfsJPNodeType;

extern TCHAR*    s_tchDfsRootNodeType;

extern TCHAR*    s_tchDfsAdminNodeType;

#endif  //_DFS_NODES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsnodes.cpp ===
/*++
Module Name:

    DfsNodes.h

Abstract:

    Contains the definition of DfsAdmin Snapin GUIDs for Nodes.

--*/

#include "stdafx.h"

GUID      s_guidDfsReplicaNodeType = {0x58268345,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};

GUID      s_guidDfsJPNodeType = {0x58268344,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};

GUID      s_guidDfsRootNodeType = {0x58268343,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};

GUID      s_guidDfsAdminNodeType = {0x58268342,0x28e8,0x11d1,{0xa9,0x5b,0x0,0x80,0x48,0x91,0x8f,0xb1}};


TCHAR*    s_tchDfsReplicaNodeType = _T("{58268345-28E8-11d1-A95B-008048918FB1}");

TCHAR*    s_tchDfsJPNodeType = _T("{58268344-28E8-11d1-A95B-008048918FB1}");

TCHAR*    s_tchDfsRootNodeType = _T("{58268343-28E8-11d1-A95B-008048918FB1}");

TCHAR*    s_tchDfsAdminNodeType = _T("{58268342-28E8-11d1-A95B-008048918FB1}");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsgui.cpp ===
// DfsGUI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f DfsGUIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DfsGUI.h"

#include "DfsGUI_i.c"

#include "DfsScope.h"
#include "DfsReslt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_DfsSnapinResultManager, CDfsSnapinResultManager)
	OBJECT_ENTRY(CLSID_DfsSnapinScopeManager, CDfsSnapinScopeManager)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		SHFusionInitializeFromModuleID (hInstance, 2);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
		SHFusionUninitialize();
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsabout.cpp ===
/*++
Module Name:

    DfsAbout.cpp

Abstract:

    This module contains the implementation for the ISnapinAbout interface.
  Note: ISnapinAbout requires that we do a CoTaskMemAlloc for strings.

--*/


#include "stdafx.h"
#include "DfsGUI.h"
#include "Utils.h"      // For LoadResourceFromString
#include "DfsScope.h"




STDMETHODIMP 
CDfsSnapinScopeManager::GetSnapinDescription(
  OUT LPOLESTR*        o_ppaszOleString
  )
/*++

Routine Description:

  Returns a single string describing our snap-in.

Arguments:

  o_ppaszOleString  -  The pointer in which the description string is stored

Return value:

  S_OK, On success
  E_INVALIDARG, On null input parameter

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_ppaszOleString);

  CComBSTR        bstrTemp;
  HRESULT hr = LoadStringFromResource(IDS_SNAPIN_DESCRIPTION, &bstrTemp);
  RETURN_IF_FAILED(hr);  

  *o_ppaszOleString = reinterpret_cast<LPOLESTR>
          (CoTaskMemAlloc((lstrlen(bstrTemp) + 1) * sizeof(wchar_t)));
  if (*o_ppaszOleString == NULL)
      return E_OUTOFMEMORY;

  USES_CONVERSION;
  wcscpy(OUT *o_ppaszOleString, T2OLE(bstrTemp));

  return S_OK;
}



STDMETHODIMP 
CDfsSnapinScopeManager::GetProvider(
  OUT LPOLESTR*        o_lpszName
  )
/*++

Routine Description:

  Returns a single string describing this snap-in's provider, that is us.

Arguments:

  o_lpszName  -  The pointer in which the provider string is stored

Return value:

  S_OK, On success
  E_INVALIDARG, On null input parameter

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_lpszName);


                    // Read the required field from the version info struct
                    // 040904B0 - Lang-Code Page number
  HRESULT  hr = ReadFieldFromVersionInfo(
                  _T("CompanyName"),
                  o_lpszName
                  );
  RETURN_IF_FAILED(hr);  

  return S_OK;
}



STDMETHODIMP 
CDfsSnapinScopeManager::GetSnapinVersion(
  OUT LPOLESTR*        o_lpszVersion
  )
/*++

Routine Description:

  Returns a single string describing this snap-in's version number.

Arguments:

  o_lpszVersion  -  The pointer in which the version is stored

Return value:

  S_OK, On success
  E_INVALIDARG, On null input parameter

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_lpszVersion);



                    // Read the required field from the version info struct
                    // 040904B0 - Lang-Code Page number
  HRESULT  hr = ReadFieldFromVersionInfo(
                  _T("ProductVersion"),
                  o_lpszVersion
                  );
  RETURN_IF_FAILED(hr);  


  return S_OK;
}


//
// MMC makes copies of the returned icon. The snap-in can free the original
// when the ISnapinAbout interface is released.
// It is freed in ~CDfsSnapinScopeManager.
//
STDMETHODIMP 
CDfsSnapinScopeManager::GetSnapinImage(
  OUT  HICON*          o_hSnapinIcon
  )
{
  _ASSERT(o_hSnapinIcon);

  if (!m_hSnapinIcon)
  {
      m_hSnapinIcon = (HICON)LoadImage(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDI_MAIN32x32),
                                      IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR|LR_DEFAULTSIZE); 
      if (!m_hSnapinIcon)
        return HRESULT_FROM_WIN32(GetLastError());
  }

  *o_hSnapinIcon = m_hSnapinIcon;

  return S_OK;
}


//
// MMC makes copies of the returned bitmaps. The snap-in can free the originals
// when the ISnapinAbout interface is released.
// They are freed in ~CDfsSnapinScopeManager.
//
STDMETHODIMP 
CDfsSnapinScopeManager::GetStaticFolderImage(
  OUT HBITMAP*        o_hSmallImage,   
  OUT HBITMAP*        o_hSmallImageOpen,
  OUT HBITMAP*        o_hLargeImage,   
  OUT COLORREF*       o_cMask
  )
{
    _ASSERT(o_hSmallImage);
    _ASSERT(o_hSmallImageOpen);
    _ASSERT(o_hLargeImage);
    _ASSERT(o_cMask);

    HRESULT hr = S_OK;

    do {
        if (!m_hLargeBitmap)
        {
            m_hLargeBitmap = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_MAIN32x32),
                                                IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR); 
            if (!m_hLargeBitmap)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        if (!m_hSmallBitmap)
        {
            m_hSmallBitmap = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_MAIN16x16),
                                                IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR); 
            if (!m_hSmallBitmap)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        if (!m_hSmallBitmapOpen)
        {
            m_hSmallBitmapOpen = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_MAIN16x16),
                                                    IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR); 
            if (!m_hSmallBitmapOpen)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        *o_hLargeImage = m_hLargeBitmap;
        *o_hSmallImage = m_hSmallBitmap;
        *o_hSmallImageOpen = m_hSmallBitmapOpen;
        *o_cMask = RGB(255, 0, 255); // color of the 1st pixel: pink
    } while (0);

    return hr;
}


STDMETHODIMP 
CDfsSnapinScopeManager::ReadFieldFromVersionInfo(
  IN  LPTSTR            i_lpszField,
  OUT LPOLESTR*          o_lpszFieldValue
  )
/*++

Routine Description:

  Reads and returns a particular field from the binary's version information
  block.
  Allocates memory for the 'out' parameter using CoTaskMemAlloc.

Arguments:

  i_lpszField      -  The StringFileInfo field whose value is being queried. E.g
              ProductName, CompanyName etc.

  o_lpszFieldValue  -  The pointer in which the field value is returned
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpszField);
  RETURN_INVALIDARG_IF_NULL(o_lpszFieldValue);


  DWORD    dwVerInfoSize = 0;        // Size of version information block
  DWORD    dwIgnored = 0;          // An 'ignored' parameter, always '0'
  BOOL    bRetCode = 0;
  CComBSTR  bstrBinaryName;          // Name of our dll. %%% AC Could not find a way to get this??
  UINT    uVersionCharLen = 0;
  LPOLESTR  lpszReadFieldValue = NULL;    // Is temporary and is released as part of ver info block.
  LPVOID    lpVerInfo = NULL;        // The version information is read into this



                        // Load the dll name from resource
  HRESULT hr = LoadStringFromResource(IDS_APP_BINARY_NAME, &bstrBinaryName);
  RETURN_IF_FAILED(hr);  

                  // Get the size of the version struct
  dwVerInfoSize = ::GetFileVersionInfoSize(bstrBinaryName, &dwIgnored);
  if (dwVerInfoSize <= 0) 
  {
    return E_UNEXPECTED;
  }

  lpVerInfo = ::CoTaskMemAlloc(dwVerInfoSize);
  RETURN_OUTOFMEMORY_IF_NULL(lpVerInfo);
  

                // Read the version info resource
  bRetCode = ::GetFileVersionInfo(bstrBinaryName, dwIgnored, dwVerInfoSize, lpVerInfo);
  if (bRetCode <= 0)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_UNEXPECTED;
  }

              // First get the Language ID and page.
  DWORD    dwLangIDAndCodePage = 0;
  bRetCode = ::VerQueryValue(  (LPVOID)lpVerInfo, 
                _T("\\VarFileInfo\\Translation"),
                (LPVOID *)&lpszReadFieldValue, 
                &uVersionCharLen);

  if (bRetCode <= 0 || NULL == lpszReadFieldValue)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_UNEXPECTED;
  }

  
  dwLangIDAndCodePage = *((DWORD *)lpszReadFieldValue);
  
            // Using the LangId and the code page to form the query for Version Info.
  CComBSTR  bstrDesiredField;
  TCHAR    lpzStringOfLangIdCodePage[100];
  _stprintf(lpzStringOfLangIdCodePage, _T("%04x%04x"),LOWORD(dwLangIDAndCodePage), HIWORD(dwLangIDAndCodePage));

  bstrDesiredField = _T("\\StringFileInfo\\");
  bstrDesiredField += lpzStringOfLangIdCodePage;
  bstrDesiredField += _T("\\");
  bstrDesiredField += i_lpszField;

              // Read the Description from the versioninfo resource
  bRetCode = ::VerQueryValue(  (LPVOID)lpVerInfo, 
                bstrDesiredField,
                (LPVOID *)&lpszReadFieldValue, 
                &uVersionCharLen);
  if (bRetCode <= 0)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_UNEXPECTED;
  }

  UINT  uBufferLen = uVersionCharLen * sizeof (OLECHAR);
                // Allocate the memory and copy the structure
  *o_lpszFieldValue = (LPOLESTR)::CoTaskMemAlloc(uBufferLen);
  if (!*o_lpszFieldValue)
  {
    ::CoTaskMemFree(lpVerInfo);
    return E_OUTOFMEMORY;
  }

  memcpy(*o_lpszFieldValue, lpszReadFieldValue, uBufferLen);

  ::CoTaskMemFree(lpVerInfo);

  return S_OK;
}

STDMETHODIMP 
CDfsSnapinScopeManager::GetHelpTopic(
  OUT LPOLESTR*          o_lpszCompiledHelpFile
)
{
  if (o_lpszCompiledHelpFile == NULL)
    return E_POINTER;

  TCHAR   szSystemRoot[MAX_PATH + 1] = _T("");      
  GetSystemWindowsDirectory(szSystemRoot, MAX_PATH);

  CComBSTR bstrRelHelpPath;
  HRESULT hr = LoadStringFromResource(IDS_MMC_HELP_FILE_PATH, &bstrRelHelpPath);
  if (FAILED(hr))
    return hr;

  *o_lpszCompiledHelpFile = reinterpret_cast<LPOLESTR>
          (CoTaskMemAlloc((_tcslen(szSystemRoot) + _tcslen(bstrRelHelpPath) + 1) * sizeof(wchar_t)));

  if (*o_lpszCompiledHelpFile == NULL)
    return E_OUTOFMEMORY;

  USES_CONVERSION;

  wcscpy(*o_lpszCompiledHelpFile, T2OLE(szSystemRoot));
  wcscat(*o_lpszCompiledHelpFile, T2OLE((LPTSTR)(LPCTSTR)bstrRelHelpPath));

  return S_OK;
}

STDMETHODIMP 
CDfsSnapinScopeManager::GetLinkedTopics(
  OUT LPOLESTR*          o_lpszCompiledHelpFiles
)
{
  if (o_lpszCompiledHelpFiles == NULL)
    return E_POINTER;

  TCHAR   szSystemRoot[MAX_PATH + 1] = _T("");      
  GetSystemWindowsDirectory(szSystemRoot, MAX_PATH);

  CComBSTR bstrRelHelpPath;
  HRESULT hr = LoadStringFromResource(IDS_LINKED_HELP_FILE_PATH, &bstrRelHelpPath);
  if (FAILED(hr))
    return hr;

  *o_lpszCompiledHelpFiles = reinterpret_cast<LPOLESTR>
          (CoTaskMemAlloc((_tcslen(szSystemRoot) + _tcslen(bstrRelHelpPath) + 1) * sizeof(wchar_t)));

  if (*o_lpszCompiledHelpFiles == NULL)
    return E_OUTOFMEMORY;

  USES_CONVERSION;

  wcscpy(*o_lpszCompiledHelpFiles, T2OLE(szSystemRoot));
  wcscat(*o_lpszCompiledHelpFiles, T2OLE((LPTSTR)(LPCTSTR)bstrRelHelpPath));

  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfshelp.h ===
#ifndef __DFSHELP_H_
#define __DFSHELP_H_

#define DFS_CTX_HELP_FILE        _T("dfs.hlp")

#define IDH_ADDREP_DFSLINKPATH          70005000
#define IDH_ADDREP_EDITNETPATH          70005001
#define IDH_ADDREP_BUTTONNETBROWSE      70005002
#define IDH_ADDREP_REPLICATE            70005003
#define IDH_ADDTODFS_EDITCHLDNODE       70005025
#define IDH_ADDTODFS_DFSLINKPATH        70005026
#define IDH_ADDTODFS_EDITNETPATH        70005027
#define IDH_ADDTODFS_BUTTONNETBROWSE    70005028
#define IDH_ADDTODFS_EDITCOMMENT        70005029
#define IDH_ADDTODFS_EDITTIME           70005030
#define IDH_DLGCONNECTTO_EditDfsRoot    70005050
#define IDH_DLGCONNECTTO_TREEDFSRoots   70005051
#define IDH_FILTERDFSLINKS_MAXLIMIT     70005200
#define IDH_FILTERDFSLINKS_RADIO_NO     70005201
#define IDH_FILTERDFSLINKS_RADIO_YES    70005202
#define IDH_FILTERDFSLINKS_FILTER_TYPE  70005203
#define IDH_FILTERDFSLINKS_FILTER       70005204
#define IDH_PROP__REPLICA_SET_NAME      70005100
#define IDH_PROP_REFFERAL_TIME          70005102
#define IDH_PROP_REPLICA_SET_COMMENT    70005101
#define IDH_FRSPROP_FILEFILTER          70005206
#define IDH_FRSPROP_FILEFILTER_EDIT     70005207
#define IDH_FRSPROP_DIRFILTER           70005208
#define IDH_FRSPROP_DIRFILTER_EDIT      70005209
#define IDH_FRSPROP_PRIMARYMEMBER       70005210
#define IDH_FRSPROP_TOPOLOGYPREF        70005211
#define IDH_FRSPROP_HUBSERVER           70005212
#define IDH_FRSPROP_RESETSCHEDULE       70005213
#define IDH_FRSPROP_CUSTOMIZE           70005214
#define IDH_FRS_CUSTOP_TOPOLOGYPREF     70005215
#define IDH_FRS_CUSTOP_REBUILD          70005216
#define IDH_FRS_CUSTOP_HUBSERVER        70005217
#define IDH_FRS_CUSTOP_CONNECTIONS      70005218
#define IDH_FRS_CUSTOP_CONNECTIONS_NEW  70005219
#define IDH_FRS_CUSTOP_CONNECTIONS_DELETE   70005220
#define IDH_FRS_CUSTOP_SCHEDULE         70005221
#define IDH_FRS_NEWCONN_FROM            70005222
#define IDH_FRS_NEWCONN_TO              70005223
#define IDH_PUBPROP_PUBLISH             70005224
#define IDH_PUBPROP_UNCPATH             70005225
#define IDH_PUBPROP_DESCRIPTION         70005226
#define IDH_PUBPROP_KEYWORDS            70005227
#define IDH_PUBPROP_KEYWORDS_EDIT       70005228
#define IDH_PUBPROP_MANAGEDBY           70005229
#define IDH_MVSTRINGEDIT_STRING         70005230
#define IDH_MVSTRINGEDIT_LIST           70005231
#define IDH_MVSTRINGEDIT_ADD            70005232
#define IDH_MVSTRINGEDIT_REMOVE         70005233
#define IDH_MROOTS_LIST                 70005234
#define IDH_STAGING_TARGET              70005235
#define IDH_STAGING_FOLDER              70005236
#define IDH_STAGING_BROWSE              70005237
#define IDH_FRS_CUSTOP_ADVANCED         70005238
#define IDH_FRS_ADVANCED_SERVER         70005239
#define IDH_FRS_ADVANCED_SITE           70005240
#define IDH_FRS_ADVANCED_INBOUND_CONNS  70005241
#define IDH_FRS_ADVANCED_NEW_PRIORITY   70005242
#define IDH_FRS_ADVANCED_CHANGE         70005243

const DWORD g_aHelpIDs_IDD_ADDREP[]=
{
    IDC_EDIT_ADDREP_DFSLINK_PATH,IDH_ADDREP_DFSLINKPATH,
    IDC_EDITNETPATH,IDH_ADDREP_EDITNETPATH,
    IDC_BUTTONNETBROWSE,IDH_ADDREP_BUTTONNETBROWSE,
    IDC_ADDREP_REPLICATE,IDH_ADDREP_REPLICATE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_ADDTODFS[]=
{
    IDC_EDITCHLDNODE,IDH_ADDTODFS_EDITCHLDNODE,
    IDC_EDIT_ADDLINK_DFSLINK_PATH,IDH_ADDTODFS_DFSLINKPATH,
    IDC_EDITNETPATH,IDH_ADDTODFS_EDITNETPATH,
    IDC_BUTTONNETBROWSE,IDH_ADDTODFS_BUTTONNETBROWSE,
    IDC_EDITCOMMENT,IDH_ADDTODFS_EDITCOMMENT,
    IDC_EDITTIME,IDH_ADDTODFS_EDITTIME,
    0,0
};

const DWORD g_aHelpIDs_IDD_DLGCONNECTTO[]=
{
    IDC_TREEDFSRoots,IDH_DLGCONNECTTO_TREEDFSRoots,
    IDC_EditDfsRoot,IDH_DLGCONNECTTO_EditDfsRoot,
    0,0
};

const DWORD g_aHelpIDs_IDD_FILTERDFSLINKS[]=
{
    IDC_FILTERDFSLINKS_MAXLIMIT,IDH_FILTERDFSLINKS_MAXLIMIT,
    IDC_FILTERDFSLINKS_RADIO_NO,IDH_FILTERDFSLINKS_RADIO_NO,
    IDC_FILTERDFSLINKS_RADIO_YES,IDH_FILTERDFSLINKS_RADIO_YES,
    IDC_FILTERDFSLINKS_FILTER_TYPE,IDH_FILTERDFSLINKS_FILTER_TYPE,
    IDC_FILTERDFSLINKS_FILTER_LABEL,-1,
    IDC_FILTERDFSLINKS_FILTER,IDH_FILTERDFSLINKS_FILTER,
    0, 0
};

const DWORD g_aHelpIDs_IDD_JP_PROP[]=
{
    IDC_REPLICA_SET_NAME,IDH_PROP__REPLICA_SET_NAME,
    IDC_REPLICA_SET_COMMENT,IDH_PROP_REPLICA_SET_COMMENT,
    IDC_REFFERAL_TIME,IDH_PROP_REFFERAL_TIME,
    0,0
};

const DWORD g_aHelpIDs_IDD_FRS_PROP[]=
{
    IDC_FRSPROP_FILEFILTER, IDH_FRSPROP_FILEFILTER,
    IDC_FRSPROP_FILEFILTER_EDIT, IDH_FRSPROP_FILEFILTER_EDIT,
    IDC_FRSPROP_DIRFILTER, IDH_FRSPROP_DIRFILTER,
    IDC_FRSPROP_DIRFILTER_EDIT, IDH_FRSPROP_DIRFILTER_EDIT,
    IDC_FRSPROP_PRIMARYMEMBER, IDH_FRSPROP_PRIMARYMEMBER,
    IDC_FRSPROP_TOPOLOGYPREF, IDH_FRSPROP_TOPOLOGYPREF,
    IDC_FRSPROP_HUBSERVER, IDH_FRSPROP_HUBSERVER,
    IDC_FRSPROP_RESETSCHEDULE, IDH_FRSPROP_RESETSCHEDULE,
    IDC_FRSPROP_CUSTOMIZE, IDH_FRSPROP_CUSTOMIZE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FRS_CUSTOP[]=
{
    IDC_FRS_CUSTOP_TOPOLOGYPREF, IDH_FRS_CUSTOP_TOPOLOGYPREF,
    IDC_FRS_CUSTOP_REBUILD, IDH_FRS_CUSTOP_REBUILD,
    IDC_FRS_CUSTOP_HUBSERVER, IDH_FRS_CUSTOP_HUBSERVER,
    IDC_FRS_CUSTOP_CONNECTIONS, IDH_FRS_CUSTOP_CONNECTIONS,
    IDC_FRS_CUSTOP_CONNECTIONS_NEW, IDH_FRS_CUSTOP_CONNECTIONS_NEW,
    IDC_FRS_CUSTOP_CONNECTIONS_DELETE, IDH_FRS_CUSTOP_CONNECTIONS_DELETE,
    IDC_FRS_CUSTOP_SCHEDULE, IDH_FRS_CUSTOP_SCHEDULE,
    IDC_FRS_CUSTOP_ADVANCED, IDH_FRS_CUSTOP_ADVANCED,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FRS_NEWCONN[]=
{
    IDC_FRS_NEWCONN_FROM, IDH_FRS_NEWCONN_FROM,
    IDC_FRS_NEWCONN_TO, IDH_FRS_NEWCONN_TO,
    0, 0
};

const DWORD g_aHelpIDs_IDD_FRS_ADVANCED[]=
{
    IDC_FRS_ADVANCED_EXPLANATION, -1,
    IDC_FRS_ADVANCED_SERVER, IDH_FRS_ADVANCED_SERVER,
    IDC_FRS_ADVANCED_SITE, IDH_FRS_ADVANCED_SITE,
    IDC_FRS_ADVANCED_INBOUND_CONNS, IDH_FRS_ADVANCED_INBOUND_CONNS,
    IDC_FRS_ADVANCED_NEW_PRIORITY, IDH_FRS_ADVANCED_NEW_PRIORITY,
    IDC_FRS_ADVANCED_CHANGE, IDH_FRS_ADVANCED_CHANGE,
    IDC_FRS_ADVANCED_NEW_PRIORITY_DESC, -1,
    0, 0
};

const DWORD g_aHelpIDs_IDD_PUBLISH_PROP[]=
{
    IDC_PUBPROP_PUBLISH, IDH_PUBPROP_PUBLISH,
    IDC_PUBPROP_UNCPATH, IDH_PUBPROP_UNCPATH,
    IDC_PUBPROP_UNCPATH_LABEL, -1,
    IDC_PUBPROP_DESCRIPTION, IDH_PUBPROP_DESCRIPTION,
    IDC_PUBPROP_DESCRIPTION_LABEL, -1,
    IDC_PUBPROP_KEYWORDS, IDH_PUBPROP_KEYWORDS,
    IDC_PUBPROP_KEYWORDS_LABEL, -1,
    IDC_PUBPROP_KEYWORDS_EDIT, IDH_PUBPROP_KEYWORDS_EDIT,
    IDC_PUBPROP_MANAGEDBY, IDH_PUBPROP_MANAGEDBY,
    IDC_PUBPROP_MANAGEDBY_LABEL, -1,
    IDC_PUBPROP_ERROR, -1,
    0, 0
};

const DWORD g_aHelpIDs_IDD_MVSTRINGEDIT[]=
{
    IDC_MVSTRINGEDIT_STRING, IDH_MVSTRINGEDIT_STRING,
    IDC_MVSTRINGEDIT_LIST, IDH_MVSTRINGEDIT_LIST,
    IDC_MVSTRINGEDIT_ADD, IDH_MVSTRINGEDIT_ADD,
    IDC_MVSTRINGEDIT_REMOVE, IDH_MVSTRINGEDIT_REMOVE,
    0, 0
};

const DWORD g_aHelpIDs_IDD_MROOTS[]=
{
    IDC_MROOTS_LIST, IDH_MROOTS_LIST,
    0, 0
};

const DWORD g_aHelpIDs_IDD_STAGING[]=
{
    IDC_STAGING_TARGET, IDH_STAGING_TARGET,
    IDC_STAGING_FOLDER, IDH_STAGING_FOLDER,
    IDC_STAGING_BROWSE, IDH_STAGING_BROWSE,
    0, 0
};

#endif // __DFSHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsreslt.h ===
/*++
Module Name:

    DfsReslt.h

Abstract:

    This module contains the declaration for CDfsSnapinResultManager.

--*/


#ifndef __DFSRESLT_H_
#define __DFSRESLT_H_


#include "resource.h"       // main symbols
#include <mmc.h>
#include "mmcdispl.h"


class ATL_NO_VTABLE CDfsSnapinResultManager : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsSnapinResultManager, &CLSID_DfsSnapinResultManager>,
    public IComponent,
    public IExtendContextMenu,
    public IExtendControlbar
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DFSSNAPINRESULTMANAGER)

BEGIN_COM_MAP(CDfsSnapinResultManager)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
END_COM_MAP()



friend class CDfsSnapinScopeManager;
    


CDfsSnapinResultManager():m_pScopeManager(NULL),
                          m_pSelectScopeDisplayObject(NULL) 
    {
    }

    virtual ~CDfsSnapinResultManager()
    {
    }

// IComponent Methods
    STDMETHOD(Initialize)(
        IN LPCONSOLE                i_lpConsole
        );
    
    STDMETHOD(Notify)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN MMC_NOTIFY_TYPE            i_Event, 
        IN LPARAM                        i_lArg, 
        IN LPARAM                        i_lParam
        );
    
    STDMETHOD(Destroy)(
        IN MMC_COOKIE                        i_lCookie
        );
    
    STDMETHOD(GetResultViewType)(
        IN MMC_COOKIE                        i_lCookie,  
        OUT LPOLESTR*                o_ppViewType, 
        OUT LPLONG                    o_lpViewOptions
        );
    
    STDMETHOD(QueryDataObject)(
        IN MMC_COOKIE                        i_lCookie, 
        IN DATA_OBJECT_TYPES        i_DataObjectType, 
        OUT LPDATAOBJECT*            o_ppDataObject
        );
    
    STDMETHOD(GetDisplayInfo)(
        IN OUT RESULTDATAITEM*        io_pResultDataItem
        );
    
    STDMETHOD(CompareObjects)(
        IN LPDATAOBJECT                i_lpDataObjectA, 
        IN LPDATAOBJECT                i_lpDataObjectB
        );



// IExtendContextMenu methods.
    // For adding context menu items
    STDMETHOD (AddMenuItems)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
        IN LPLONG                    i_lpInsertionAllowed
        );



    // For taking action on a context menu selection.
    STDMETHOD (Command)(
        IN LONG                        i_lCommandID, 
        IN LPDATAOBJECT                i_lpDataObject
        );



// IExtendControlbar methods
    // Used to set the control bar
    STDMETHOD (SetControlbar)( 
        IN LPCONTROLBAR                i_pControlbar  
        );



  // A notify to the control bar
    STDMETHOD (ControlbarNotify)( 
        IN MMC_NOTIFY_TYPE            i_Event, 
        IN LPARAM                        i_lArg, 
        IN LPARAM                        i_lParam
        );



// helpers
private:
    void DetachAllToolbars();

   
    // Handling the Notify event for Select
    STDMETHOD(DoNotifySelect)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN BOOL                        i_bSelect,
        IN HSCOPEITEM                i_hParent                                       
        );


    // Handling the Notify event for Show
    STDMETHOD(DoNotifyShow)(
        IN LPDATAOBJECT                i_lpDataObject, 
        IN BOOL                        i_bShow,
        IN HSCOPEITEM                i_hParent                                       
        );


    // Handling the notify method for MMCN_CONTEXTHELP
    STDMETHOD(DfsHelp)();

    STDMETHOD(DoNotifyViewChange)(
        IN LPDATAOBJECT     i_lpDataObject,
        IN LONG_PTR         i_lArg,
        IN LONG_PTR         i_lParam
        );

// Data members
private:
    CDfsSnapinScopeManager*     m_pScopeManager;    // The corresponding Scope Manager object
    CComPtr<IHeaderCtrl2>       m_pHeader;            // The header control for the result view
    CComPtr<IResultData>        m_pResultData;
    CComPtr<IConsoleVerb>       m_pConsoleVerb;        // Sets the console verb
    CComPtr<IConsole2>          m_pConsole;
    CComPtr<IControlbar>        m_pControlbar;        // Callback used to handle toolbars, etc
    CMmcDisplay*                m_pSelectScopeDisplayObject;    // The CMmcDisplay pointer of the scope pane items
                                                                // That is currently selected in the view.
    CComPtr<IToolbar>           m_pMMCAdminToolBar;
    CComPtr<IToolbar>           m_pMMCRootToolBar;
    CComPtr<IToolbar>           m_pMMCJPToolBar;
    CComPtr<IToolbar>           m_pMMCReplicaToolBar;
};

#endif //__DFSRESLT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsreslt.cpp ===
/*++
Module Name:

    MmcAdmin.cpp

Abstract:

    This module contains the part of the declaration for CDfsSnapinResultManager. 

--*/



#include "stdafx.h"
#include "DfsGUI.h"
#include "DfsReslt.h"
#include "DfsScope.h"      // The CDfsSnapinScopeManager class




STDMETHODIMP CDfsSnapinResultManager :: AddMenuItems
(
    IN LPDATAOBJECT             i_lpDataObject, 
    IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
    IN LPLONG                   i_lpInsertionAllowed
)
/*++

Routine Description:

This routine adds the appropriate context menu using the ContextMenuCallback provided.

Arguments:

    i_lpDataObject - The dataobject used to identify the node.
    i_lpContextMenuCallback - A callback(function pointer) that is used to add the menu items
    i_lpInsertionAllowed - Specifies what menus can be added and where they can be added.

--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpDataObject);
  RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);
  RETURN_INVALIDARG_IF_NULL(i_lpInsertionAllowed);

  if (DOBJ_CUSTOMOCX == i_lpDataObject)
    return S_OK;

  return m_pScopeManager->AddMenuItems(i_lpDataObject, i_lpContextMenuCallback, i_lpInsertionAllowed);
}

STDMETHODIMP 
CDfsSnapinResultManager::Command(
  IN LONG           i_lCommandID, 
  IN LPDATAOBJECT   i_lpDataObject
)
/*++

Routine Description:

Action to be taken on a context menu selection or click is takes place.

Arguments:

  i_lpDataObject - The dataobject used to identify the node.
  i_lCommandID - The Command ID of the menu for which action has to be taken

--*/

{
  RETURN_INVALIDARG_IF_NULL(i_lpDataObject);

  return m_pScopeManager->Command(i_lCommandID, i_lpDataObject);
}


STDMETHODIMP 
CDfsSnapinResultManager::SetControlbar( 
  IN LPCONTROLBAR        i_pControlbar
  )
/*++

Routine Description:

  Called by MMC to allow us to set the IControlbar interface pointer
  As items are selected and deselected, snap-ins are activated and deactivated. 
  When a snap-in is activated, the console calls SetControlbar with a non-NULL
  pControlbar value. The snap-in should call AddRef on this IControlBar. The 
  snap-in should also use this opportunity to attach controls. Similarly, when 
  the snap-in is deactivated, the console calls SetControlbar with a NULL 
  pControlbar. The snap-in should then detach its controls and call Release 
  on the saved IControlBar. 

Arguments:

  i_pControlbar - The IControlbar interface pointer. Note, can be 0.

--*/
{
    if (!i_pControlbar)    // We are shutting down
        m_pControlbar.Release();
    else
        m_pControlbar = i_pControlbar;

    return S_OK;
}

void
CDfsSnapinResultManager::DetachAllToolbars()
{
    if (m_pMMCAdminToolBar)
        m_pControlbar->Detach(m_pMMCAdminToolBar);
    if (m_pMMCRootToolBar)
        m_pControlbar->Detach(m_pMMCRootToolBar);
    if (m_pMMCJPToolBar)
        m_pControlbar->Detach(m_pMMCJPToolBar);
    if (m_pMMCReplicaToolBar)
        m_pControlbar->Detach(m_pMMCReplicaToolBar);
}

STDMETHODIMP 
CDfsSnapinResultManager::ControlbarNotify( 
  IN MMC_NOTIFY_TYPE    i_Event, 
  IN LPARAM             i_lArg, 
  IN LPARAM             i_lParam
  )
/*++

Routine Description:

  Called by MMC to notify the toolbar about an event.
  This can be selection\disselection of node, click on a toolbar, etc.

Arguments:

  i_Event    -  The event that occurred.
  i_lArg    -  The argument for the event. Depends on the event
  i_lParam  -  The parameter for the event. Depends on the event

--*/
{
    // The snap-in should return S_FALSE for any notification it does not handle. 
    // MMC then performs a default operation for the notification. 
    HRESULT         hr = S_FALSE;

    LPDATAOBJECT    p_DataObject = NULL;
    CMmcDisplay*    pCMmcDisplayObj = NULL;

    switch (i_Event)        // Decide which method to call of the display object
    {
    case MMCN_BTN_CLICK:    // Click on a toolbar
        {
            // The MMCN_BTN_CLICK notification is sent to the snap-in's IComponent, 
            // IComponentData, or IExtendControlbar implementation when a user clicks 
            // one of the toolbar buttons.
            //
            // For IExtendControlBar::ControlbarNotify: 
            // arg: Data object of the currently selected scope or result item. 
            // param: [in] The snap-in-defined command ID of the selected toolbar button. 

            p_DataObject = (LPDATAOBJECT)i_lArg;  

                          // Get the display object from IDataObject
            hr = m_pScopeManager->GetDisplayObject(p_DataObject, &pCMmcDisplayObj);
            if (SUCCEEDED(hr))
                hr = pCMmcDisplayObj->ToolbarClick(m_pControlbar, i_lParam);
            break;
        }
    case MMCN_SELECT:      // A node is being selected\deselected
        {
            // The MMCN_SELECT notification is sent to the snap-in's IComponent::Notify 
            // or IExtendControlbar::ControlbarNotify method when an item is selected 
            // in either the scope pane or result pane.
            //
            // For IExtendControlbar::ControlbarNotify: 
            // arg: BOOL bScope = (BOOL) LOWORD(arg); BOOL bSelect = (BOOL) HIWORD(arg); 
            //      bScope is TRUE if an item in the scope pane is selected, or FALSE 
            //      if an item in the result pane is selected.
            //      bSelect is TRUE if the item is selected, or FALSE if the item is deselected.
            // param: LPDATAOBJECT pDataobject = (LPDATAOBJECT)param; 
            //        pDataobject is the data object of the item being selected or deselected. 

            p_DataObject = (LPDATAOBJECT)i_lParam;

            if (DOBJ_CUSTOMOCX == p_DataObject)
                break;
                          // Get the display object from IDataObject
            hr = m_pScopeManager->GetDisplayObject(p_DataObject, &pCMmcDisplayObj);
            RETURN_IF_FAILED(hr);

            //
            // Update the custom toolbars.
            // On select, it should detach unused toolbars and attach new ones as needed.
            // On deselect, to minimize flashing, it should not detach toolbars; it is 
            // best to disable them, but doing nothing on deselect is also acceptable. 
            //
            BOOL                bSelect = (BOOL) HIWORD(i_lArg);
            IToolbar            *pToolbar = NULL;
            DISPLAY_OBJECT_TYPE DisplayObType = pCMmcDisplayObj->GetDisplayObjectType();
            switch (DisplayObType)
            {
            case DISPLAY_OBJECT_TYPE_ADMIN:
                if (!m_pMMCAdminToolBar)
                    hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCAdminToolBar);

                pToolbar = (IToolbar *)m_pMMCAdminToolBar;
                break;
            case DISPLAY_OBJECT_TYPE_ROOT:
                if (!m_pMMCRootToolBar)
                    hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCRootToolBar);

                pToolbar = (IToolbar *)m_pMMCRootToolBar;
                break;
            case DISPLAY_OBJECT_TYPE_JUNCTION:
                if (!m_pMMCJPToolBar)
                    hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCJPToolBar);

                pToolbar = (IToolbar *)m_pMMCJPToolBar;
                break;
            case DISPLAY_OBJECT_TYPE_REPLICA:
                if (!m_pMMCReplicaToolBar)
                    hr = pCMmcDisplayObj->CreateToolbar(m_pControlbar, (LPEXTENDCONTROLBAR)this, &m_pMMCReplicaToolBar);

                pToolbar = (IToolbar *)m_pMMCReplicaToolBar;
                break;
            }

            if (SUCCEEDED(hr))
            {
                if (bSelect)
                {
                    DetachAllToolbars();
                    m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN)pToolbar);
                }

                hr = pCMmcDisplayObj->ToolbarSelect(i_lArg, pToolbar);
            }

            break;
        }

    default:
        break;
    }  // switch()

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsscope.cpp ===
/*++
Module Name:

    DfsScope.cpp

Abstract:

    This module contains the implementation for CDfsSnapinScopeManager. 
    Most of the method of the class CDfsSnapinScopeManager are in other files.
    Only the constructor  is here

--*/


#include "stdafx.h"
#include "DfsGUI.h"
#include "DfsScope.h"
#include "MmcAdmin.h"
#include "utils.h"
#include <ntverp.h>

CDfsSnapinScopeManager::CDfsSnapinScopeManager()
{
    m_hLargeBitmap = NULL;
    m_hSmallBitmap = NULL;
    m_hSmallBitmapOpen = NULL;
    m_hSnapinIcon = NULL;
    m_hWatermark = NULL;
    m_hHeader = NULL;

    m_pMmcDfsAdmin = new CMmcDfsAdmin( this );
}


CDfsSnapinScopeManager::~CDfsSnapinScopeManager()
{
    m_pMmcDfsAdmin->Release();

    if (m_hLargeBitmap)
    {
        DeleteObject(m_hLargeBitmap);
        m_hLargeBitmap = NULL;
    }
    if (m_hSmallBitmap)
    {
        DeleteObject(m_hSmallBitmap);
        m_hSmallBitmap = NULL;
    }
    if (m_hSmallBitmapOpen)
    {
        DeleteObject(m_hSmallBitmapOpen);
        m_hSmallBitmapOpen = NULL;
    }
    if (m_hSnapinIcon)
    {
        DestroyIcon(m_hSnapinIcon);
        m_hSnapinIcon = NULL;
    }
    if (m_hWatermark)
    {
        DeleteObject(m_hWatermark);
        m_hWatermark = NULL;
    }
    if (m_hHeader)
    {
        DeleteObject(m_hHeader);
        m_hHeader = NULL;
    }
}

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   sizeof(x)/sizeof(x[0])
#endif

typedef struct _RGSMAP {
  LPCTSTR szKey;
  UINT    idString;
} RGSMAP;

RGSMAP g_aRgsSnapinRegs[] = {
  OLESTR("DfsAppName"), IDS_APPLICATION_NAME
};

HRESULT
CDfsSnapinScopeManager::UpdateRegistry(BOOL bRegister)
{
  USES_CONVERSION;
  HRESULT hr = S_OK;
  struct _ATL_REGMAP_ENTRY *pMapEntries = NULL;
  int n = ARRAYSIZE(g_aRgsSnapinRegs);
  int i = 0;

  // allocate 1 extra entry that is set to {NULL, NULL}
  pMapEntries = (struct _ATL_REGMAP_ENTRY *)calloc(n+2+1, sizeof(struct _ATL_REGMAP_ENTRY));
  if (!pMapEntries)
      return E_OUTOFMEMORY;

  if (n > 0)
  {
    CComBSTR  bstrString;
    for (i=0; i<n; i++)
    {
      pMapEntries[i].szKey = g_aRgsSnapinRegs[i].szKey;

      hr = LoadStringFromResource(g_aRgsSnapinRegs[i].idString, &bstrString);
      if (FAILED(hr))
        break;

      pMapEntries[i].szData = T2OLE(bstrString.Detach());
    }
  }

  pMapEntries[n].szKey = OLESTR("DfsAppProvider");
  pMapEntries[n+1].szKey = OLESTR("DfsAppVersion");

  try {
      pMapEntries[n].szData = A2OLE(VER_COMPANYNAME_STR); //allocated on stack, will be freed automatically
      pMapEntries[n+1].szData = A2OLE(VER_PRODUCTVERSION_STR); // allocated on stack, will be freed automatically
  } catch (...) // (EXCEPTION_EXECUTE_HANDLER)
  {
      hr = E_OUTOFMEMORY; // stack over-flow
  }

  if (SUCCEEDED(hr))
    hr = _Module.UpdateRegistryFromResource(IDR_DFSSNAPINSCOPEMANAGER, bRegister, pMapEntries);

  // free resource strings
  if (n > 0)
  {
    for (i=0; i<n; i++)
    {
      if (pMapEntries[i].szData)
        SysFreeString( const_cast<LPTSTR>(OLE2CT(pMapEntries[i].szData)) );
    }

    free(pMapEntries);
  }

  return hr;
}

STDMETHODIMP CDfsSnapinScopeManager::CreatePropertyPages(
    IN LPPROPERTYSHEETCALLBACK      i_lpPropSheetCallback,
    IN LONG_PTR                     i_lhandle,
    IN LPDATAOBJECT                 i_lpDataObject
    )
/*++

Routine Description:

    Called to create PropertyPages for the given node.
    The fact that this has been called implies the display object has a 
    page to display.

Arguments:

    i_lpPropSheetCallback    -    The callback used to add pages.
    i_lhandle                -    The handle used for notification
    i_lpDataObject            -    The IDataObject pointer which is used to get 
                                the DisplayObject.
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpPropSheetCallback);

    // Assume we have page to display in case of NULL pDataObject, 
    // this allows us to invoke wizard without specifing the pDataObject
    // in IPropertySheetProvider::CreatePropertySheet
    if (!i_lpDataObject)
        return S_OK;

    CMmcDisplay* pCMmcDisplayObj = NULL;
    HRESULT hr = GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);

    if (SUCCEEDED(hr))
        hr = pCMmcDisplayObj->CreatePropertyPages(i_lpPropSheetCallback, i_lhandle);

    return hr;
}




STDMETHODIMP CDfsSnapinScopeManager::QueryPagesFor(
    IN LPDATAOBJECT                 i_lpDataObject
    )
/*++

Routine Description:

    Called by the console to decide whether there are PropertyPages 
    for the given node that should be displayed.
    We check, if the context is for scope or result(thereby skipping
    node manager) and if it is pass on the call to the Display object


Arguments:

    i_lpDataObject            -    The IDataObject pointer which is used to get 
                                the DisplayObject.

Return value:

    S_OK, if we want pages to be displayed. This is decided by the display object
    S_FALSE, if we don't want pages to be display.

--*/
{
    // Assume we have page to display in case of NULL pDataObject, 
    // this allows us to invoke wizard without specifing the pDataObject
    // in IPropertySheetProvider::CreatePropertySheet
    if (!i_lpDataObject)
        return S_OK;

    CMmcDisplay* pCMmcDisplayObj = NULL;
    HRESULT hr = GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);

    if (SUCCEEDED(hr))
        hr = pCMmcDisplayObj->QueryPagesFor();

    return hr;
}



STDMETHODIMP 
CDfsSnapinScopeManager::GetWatermarks( 
    IN LPDATAOBJECT                 pDataObject,
    IN HBITMAP*                     lphWatermark,
    IN HBITMAP*                     lphHeader,
    IN HPALETTE*                    lphPalette,
    IN BOOL*                        bStretch
    )
{
/*++

Routine Description:

    Gives the water mark bitmaps to mmc to display for 97-style wizard pages.
    The snap-in is responsible for freeing the watermark and header resource. 

Arguments:

    lphWatermark    -    Bitmap mark for body
    lphHeader        -    Bitmap for header
    lphPalette        -    Pallete
    bStretch        -    Strech / not?

--*/

    HRESULT hr = S_OK;

    do {
        if (!m_hWatermark)
        {
            m_hWatermark = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_CREATE_DFSROOT_WATERMARK), 
                                            IMAGE_BITMAP, 0, 0,    LR_DEFAULTCOLOR);
            if(!m_hWatermark)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        if (!m_hHeader)
        {
            m_hHeader = (HBITMAP)LoadImage(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDB_CREATE_DFSROOT_HEADER), 
                                        IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
            if(!m_hHeader)
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                break;
            }
        }

        *lphWatermark = m_hWatermark;
        *lphHeader = m_hHeader;
        *bStretch = FALSE;
        *lphPalette = NULL;

    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfsscope.h ===
/*++
Module Name:

    DfsScope.h

Abstract:

    This module contains the declaration for CDfsSnapinScopeManager.
    This class implements IComponentData and other related interfaces

--*/


#ifndef __DFSSCOPE_H_
#define __DFSSCOPE_H_

#include "resource.h"       // main symbols
#include "MMCAdmin.h"        // For CMMCDfsAdmin


/////////////////////////////////////////////////////////////////////////////
// CDfsSnapinScopeManager
class ATL_NO_VTABLE CDfsSnapinScopeManager : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDfsSnapinScopeManager, &CLSID_DfsSnapinScopeManager>,
    public IComponentData,
    public IExtendContextMenu,
    public IPersistStream,
    public ISnapinAbout,
    public ISnapinHelp2,
    public IExtendPropertySheet2
{
public:

//DECLARE_REGISTRY_RESOURCEID(IDR_DFSSNAPINSCOPEMANAGER)
  static HRESULT UpdateRegistry(BOOL bRegister);

BEGIN_COM_MAP(CDfsSnapinScopeManager)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinAbout)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
    COM_INTERFACE_ENTRY(IExtendPropertySheet2)
END_COM_MAP()

    CDfsSnapinScopeManager();

    virtual ~CDfsSnapinScopeManager();

//IComponentData Methods
    STDMETHOD(Initialize)(
            IN LPUNKNOWN                i_pUnknown
            );

    STDMETHOD(CreateComponent)(
            OUT LPCOMPONENT*            o_ppComponent
            );

    STDMETHOD(Notify)( 
            IN LPDATAOBJECT                i_lpDataObject, 
            IN MMC_NOTIFY_TYPE            i_Event, 
            IN LPARAM                        i_lArg, 
            IN LPARAM                        i_lParam
            );

    STDMETHOD(Destroy)();

    STDMETHOD(QueryDataObject)(
            IN MMC_COOKIE                        i_lCookie, 
            IN DATA_OBJECT_TYPES        i_DataObjectType, 
            OUT LPDATAOBJECT*            o_ppDataObject
            );

    STDMETHOD(GetDisplayInfo)(
            IN OUT SCOPEDATAITEM*        io_pScopeDataItem
            );       

    STDMETHOD(CompareObjects)(
            IN LPDATAOBJECT lpDataObjectA, 
            IN LPDATAOBJECT lpDataObjectB
            );



// IExtendContextMenu methods. Definition in ICtxMenu.cpp
    STDMETHOD (AddMenuItems)(
            IN LPDATAOBJECT                i_lpDataObject, 
            IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
            IN LPLONG                    i_lpInsertionAllowed
        );

    STDMETHOD (Command)(
            IN LONG                        i_lCommandID, 
            IN LPDATAOBJECT                i_lpDataObject
        );



// IPersistStream Implementation
    STDMETHOD (GetClassID)(
            OUT struct _GUID*            o_pClsid
        );
    
    // Use to check if the object has been changed since last save
    STDMETHOD (IsDirty)(
        );
    
    // Use to load the snap-in from a saved file
    STDMETHOD (Load)(
            IN LPSTREAM                    i_pStream
        );
    
    // Use to save the snap-in to a file
    STDMETHOD (Save)(
            OUT LPSTREAM                o_pStream,
            IN    BOOL                    i_bClearDirty
        );
    
    STDMETHOD (GetSizeMax)(
            OUT ULARGE_INTEGER*         o_pulSize
        );

// ISnapinAbout methods
    STDMETHOD (GetSnapinDescription)(
        OUT LPOLESTR*            o_lpszDescription
        );


    STDMETHOD (GetProvider)(
        OUT LPOLESTR*            o_lpszName
        );


    STDMETHOD (GetSnapinVersion)(
        OUT LPOLESTR*            o_lpszVersion
        );


    STDMETHOD (GetSnapinImage)(
        OUT    HICON*                o_hSnapIcon
        );


    STDMETHOD (GetStaticFolderImage)(
        OUT HBITMAP*                o_hSmallImage,   
        OUT HBITMAP*                o_hSmallImageOpen,
        OUT HBITMAP*                o_hLargeImage,   
        OUT COLORREF*                o_cMask
        );


  // ISnapinHelp2
    STDMETHOD (GetHelpTopic)(
      OUT LPOLESTR*          o_lpszCompiledHelpFile
    );

    STDMETHOD (GetLinkedTopics)(
      OUT LPOLESTR*          o_lpszCompiledHelpFiles
    );

// IExtendPropertySheet

    // Called to create the pages
    STDMETHOD (CreatePropertyPages)( 
        IN LPPROPERTYSHEETCALLBACK        i_lpPropSheetProvider,
        IN LONG_PTR                            i_lhandle,
        IN LPDATAOBJECT                    i_lpIDataObject
        );


    // Called to check, if the snapin was to display the pages
    STDMETHOD (QueryPagesFor)( 
        IN LPDATAOBJECT                    i_lpIDataObject
        );

    // Called to get water mar images for property pages.
    STDMETHOD (GetWatermarks)( 
        IN LPDATAOBJECT                    pDataObject,
        IN HBITMAP*                        lphWatermark,
        IN HBITMAP*                        lphHeader,
        IN HPALETTE*                    lphPalette,
        IN BOOL*                        bStretch
        );
    

    // Utility functions
public:
    // Get the Display Object from the IDataObject
    STDMETHOD(GetDisplayObject)(
        IN LPDATAOBJECT                    i_lpDataObject, 
        OUT CMmcDisplay**                o_ppMmcDisplay
        );


private:
    // Handle the notify event for MMCN_EXPAND
    STDMETHOD(DoNotifyExpand)(
        IN LPDATAOBJECT                    i_lpDataObject, 
        IN BOOL                            i_bExpanding,
        IN HSCOPEITEM                    i_hParent                                       
        );



    // Read a particular field from the version information block.
    STDMETHOD(ReadFieldFromVersionInfo)(
        IN    LPTSTR                        i_lpszField,
        OUT LPOLESTR*                    o_lpszFieldValue
        );


protected:
    CMmcDfsAdmin*               m_pMmcDfsAdmin;        // The Class used for display and for dfsroot list.
    CComPtr<IConsoleNameSpace>  m_pScope;            // Pointer to the Scope Pane.
    CComPtr<IConsole2>          m_pConsole;            // Pointer to the Console.
    HBITMAP                     m_hLargeBitmap;
    HBITMAP                     m_hSmallBitmap;
    HBITMAP                     m_hSmallBitmapOpen;
    HICON                       m_hSnapinIcon;
    HBITMAP                     m_hWatermark;
    HBITMAP                     m_hHeader;
};
#endif //__DFSSCOPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfswiz.cpp ===
/*++
Module Name:

    DfsWiz.cpp

Abstract:

    This module contains the implementation for CCreateDfsRootWizPage1, 2, 3, 4, 5, 6.
  These classes implement pages in the CreateDfs Root wizard.
--*/


#include "stdafx.h"
#include "resource.h"    // To be able to use the resource symbols
#include "DfsEnums.h"    // for common enums, typedefs, etc
#include "NetUtils.h"    
#include "ldaputils.h"    
#include "Utils.h"      // For the LoadStringFromResource method

#include "dfswiz.h"      // For Ds Query Dialog
#include <shlobj.h>
#include <dsclient.h>
#include <initguid.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <lmdfs.h>
#include <iads.h>
#include <icanon.h>
#include <dns.h>

HRESULT
ValidateFolderPath(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
);

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage1: Welcome page
CCreateDfsRootWizPage1::CCreateDfsRootWizPage1(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage1>(false),
      m_lpWizInfo(i_lpWizInfo)
{
}

BOOL 
CCreateDfsRootWizPage1::OnSetActive()
{
    ::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);
    ::SetControlFont(m_lpWizInfo->hBigBoldFont, m_hWnd, IDC_WELCOME_BIG_TITLE);
    ::SetControlFont(m_lpWizInfo->hBoldFont, m_hWnd, IDC_WELCOME_SMALL_TITLE);

    return TRUE;
}

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage2: Dfsroot type selection
CCreateDfsRootWizPage2::CCreateDfsRootWizPage2(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage2>(true),
      m_lpWizInfo(i_lpWizInfo)
{
    CComBSTR  bstrTitle;
    LoadStringFromResource(IDS_WIZ_PAGE2_TITLE, &bstrTitle);
    SetHeaderTitle(bstrTitle);

    CComBSTR  bstrSubTitle;
    LoadStringFromResource(IDS_WIZ_PAGE2_SUBTITLE, &bstrSubTitle);
    SetHeaderSubTitle(bstrSubTitle);
}

BOOL 
CCreateDfsRootWizPage2::OnSetActive()
{
    ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    if (DFS_TYPE_UNASSIGNED == m_lpWizInfo->DfsType)
    {
        CheckRadioButton(IDC_RADIO_FTDFSROOT, IDC_RADIO_STANDALONE_DFSROOT, IDC_RADIO_FTDFSROOT);
        m_lpWizInfo->DfsType = DFS_TYPE_FTDFS;
    }

    return TRUE;
}

BOOL 
CCreateDfsRootWizPage2::OnWizardNext()
{
    m_lpWizInfo->DfsType = (IsDlgButtonChecked(IDC_RADIO_FTDFSROOT) ? DFS_TYPE_FTDFS : DFS_TYPE_STANDALONE);

    return TRUE;
}

BOOL 
CCreateDfsRootWizPage2::OnWizardBack()
{
  m_lpWizInfo->DfsType = DFS_TYPE_UNASSIGNED;    // Reset the dfsroot type

  return TRUE;
}

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage3: Domain selection
CCreateDfsRootWizPage3::CCreateDfsRootWizPage3(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage3>(true),
      m_lpWizInfo(i_lpWizInfo)
{
    CComBSTR  bstrTitle;
    LoadStringFromResource(IDS_WIZ_PAGE3_TITLE, &bstrTitle);
    SetHeaderTitle(bstrTitle);

    CComBSTR  bstrSubTitle;
    LoadStringFromResource(IDS_WIZ_PAGE3_SUBTITLE, &bstrSubTitle);
    SetHeaderSubTitle(bstrSubTitle);
}

BOOL 
CCreateDfsRootWizPage3::OnSetActive()
{
    // Skip this page for standalone dfs roots
    if (DFS_TYPE_STANDALONE == m_lpWizInfo->DfsType)
        return FALSE;    

    CWaitCursor    WaitCursor;

    SetDefaultValues();

    ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

HRESULT 
CCreateDfsRootWizPage3::SetDefaultValues()
{
  if (NULL == m_lpWizInfo->bstrSelectedDomain)
  {
              // Page is displayed for the first time, Set domain to current domain
    CComBSTR    bstrDomain;
    HRESULT     hr = GetServerInfo(NULL, &bstrDomain);

    if (S_OK == hr && S_OK == Is50Domain(bstrDomain))
    {
      m_lpWizInfo->bstrSelectedDomain = bstrDomain.Detach();
    }
  }

  SetDlgItemText(IDC_EDIT_SELECTED_DOMAIN,
    m_lpWizInfo->bstrSelectedDomain ? m_lpWizInfo->bstrSelectedDomain : _T(""));

  // select the matching item in the listbox
  HWND hwndList = GetDlgItem(IDC_LIST_DOMAINS);
  if ( ListView_GetItemCount(hwndList) > 0)
  {
    int nIndex = -1;
    if (m_lpWizInfo->bstrSelectedDomain)
    {
        TCHAR   szText[DNS_MAX_NAME_BUFFER_LENGTH];
        while (-1 != (nIndex = ListView_GetNextItem(hwndList, nIndex, LVNI_ALL)))
        {
            ListView_GetItemText(hwndList, nIndex, 0, szText, DNS_MAX_NAME_BUFFER_LENGTH);
            if (!lstrcmpi(m_lpWizInfo->bstrSelectedDomain, szText))
            {
                ListView_SetItemState(hwndList, nIndex, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
                ListView_Update(hwndList, nIndex);
                break;
            }
        }
    }

    if (-1 == nIndex)
    {
        ListView_SetItemState(hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);
        ListView_Update(hwndList, 0);
    }
  }

  return S_OK;
}
  
BOOL 
CCreateDfsRootWizPage3::OnWizardNext()
{
  CWaitCursor    WaitCursor;

  DWORD     dwTextLength = 0;
  CComBSTR  bstrCurrentText;
  HRESULT   hr = GetInputText(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN), &bstrCurrentText, &dwTextLength);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN));
    return FALSE;
  } else if (0 == dwTextLength)
  {
    DisplayMessageBoxWithOK(IDS_MSG_EMPTY_FIELD);
    ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN));
    return FALSE;
  }

  CComBSTR bstrDnsDomain;
  hr = Is50Domain(bstrCurrentText, &bstrDnsDomain);
  if (S_OK != hr)  
  {                            // Error message on incorrect domain.
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_INCORRECT_DOMAIN, bstrCurrentText);
    return FALSE;
  }

  SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSelectedDomain);

  m_lpWizInfo->bstrSelectedDomain = bstrDnsDomain.Detach();

  return TRUE;
}

BOOL 
CCreateDfsRootWizPage3::OnWizardBack()
{
    SetDlgItemText(IDC_EDIT_SELECTED_DOMAIN, _T(""));  // Set edit box to empty
    SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSelectedDomain);

    return TRUE;
}

LRESULT 
CCreateDfsRootWizPage3::OnNotify(
  IN UINT            i_uMsg, 
  IN WPARAM          i_wParam, 
  IN LPARAM          i_lParam, 
  IN OUT BOOL&       io_bHandled
  )
{
    io_bHandled = FALSE;  // So that the base class gets this notify too

    NMHDR*    pNMHDR = (NMHDR*)i_lParam;
    if (!pNMHDR || IDC_LIST_DOMAINS != pNMHDR->idFrom)  // We need to handle notifies only to the LV
        return TRUE;

    switch(pNMHDR->code)
    {
    case LVN_ITEMCHANGED:
    case NM_CLICK:
        {
            OnItemChanged(((NM_LISTVIEW *)i_lParam)->iItem);
            return 0;    // Should be returning 0
        }
    case NM_DBLCLK:      // Double click event
        {
            OnItemChanged(((NM_LISTVIEW *)i_lParam)->iItem);
            if (0 <= ((NM_LISTVIEW *)i_lParam)->iItem)
                ::PropSheet_PressButton(GetParent(), PSBTN_NEXT);
            break;
        }
    default:
        break;
    }

    return TRUE;  
}

BOOL 
CCreateDfsRootWizPage3::OnItemChanged(IN INT i_iItem)
/*++

Routine Description:

  Handles item change notify. Change the edit box content to the current LV 
  selection

Arguments:

  i_iItem    -  Selected Item number of the LV.

--*/
{
    CComBSTR bstrDomain;
    HRESULT  hr = GetListViewItemText(GetDlgItem(IDC_LIST_DOMAINS), i_iItem, &bstrDomain);
    if ((S_OK == hr) && (BSTR)bstrDomain)
        SetDlgItemText(IDC_EDIT_SELECTED_DOMAIN, bstrDomain);

    return TRUE;
}

LRESULT 
CCreateDfsRootWizPage3::OnInitDialog(
  IN UINT          i_uMsg, 
  IN WPARAM        i_wParam, 
  IN LPARAM        i_lParam, 
  IN OUT BOOL&     io_bHandled
  )
{
    CWaitCursor    WaitCursor;

    ::SendMessage(GetDlgItem(IDC_EDIT_SELECTED_DOMAIN), EM_LIMITTEXT, DNSNAMELIMIT, 0);

    HIMAGELIST  hImageList = NULL;
    int         nIconIDs[] = {IDI_16x16_DOMAIN};
    HRESULT     hr = CreateSmallImageList(
                            _Module.GetResourceInstance(),
                            nIconIDs,
                            sizeof(nIconIDs) / sizeof(nIconIDs[0]),
                            &hImageList);
    if (SUCCEEDED(hr))
    {
        // The current image list will be destroyed when the list-view control 
        // is destroyed unless the LVS_SHAREIMAGELISTS style is set. If you 
        // use this message to replace one image list with another, your 
        // application must explicitly destroy all image lists other than 
        // the current one.
        HWND hwndDomainList = GetDlgItem(IDC_LIST_DOMAINS);
        ListView_SetImageList(hwndDomainList, hImageList, LVSIL_SMALL);

        AddDomainsToList(hwndDomainList);    // Add domains to the list view
    }

    return TRUE;
}

HRESULT 
CCreateDfsRootWizPage3::AddDomainsToList(IN HWND i_hImageList)
{
    RETURN_INVALIDARG_IF_NULL(i_hImageList);

    NETNAMELIST ListOf50Domains;
    HRESULT hr = Get50Domains(&ListOf50Domains);    // Get all the domains
    if (S_OK != hr)
        return hr;

    // Add domains to the LV
    for(NETNAMELIST::iterator i = ListOf50Domains.begin(); i != ListOf50Domains.end(); i++)
    {
        if ((*i)->bstrNetName)
            InsertIntoListView(i_hImageList, (*i)->bstrNetName);
    }

    if (!ListOf50Domains.empty())
    { 
        for (NETNAMELIST::iterator i = ListOf50Domains.begin(); i != ListOf50Domains.end(); i++)
        {
            delete (*i);
        }

        ListOf50Domains.erase(ListOf50Domains.begin(), ListOf50Domains.end());
    }

    return S_OK;
}


// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage4: Server selection 
CCreateDfsRootWizPage4::CCreateDfsRootWizPage4(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage4>(true),
      m_lpWizInfo(i_lpWizInfo), 
      m_cfDsObjectNames(NULL)
{
    CComBSTR  bstrTitle;
    LoadStringFromResource(IDS_WIZ_PAGE4_TITLE, &bstrTitle);
    SetHeaderTitle(bstrTitle);

    CComBSTR  bstrSubTitle;
    LoadStringFromResource(IDS_WIZ_PAGE4_SUBTITLE, &bstrSubTitle);
    SetHeaderSubTitle(bstrSubTitle);
}

BOOL 
CCreateDfsRootWizPage4::OnSetActive()
{
    CWaitCursor    WaitCursor;

    ::SendMessage(GetDlgItem(IDC_EDIT_SELECTED_SERVER), EM_LIMITTEXT, DNSNAMELIMIT, 0);

    if (DFS_TYPE_STANDALONE == m_lpWizInfo->DfsType)
    {
        // Standalone Setup, set domain to current domain.
        CComBSTR bstrDomain;
        HRESULT  hr = GetServerInfo(NULL, &bstrDomain);
        if (S_OK == hr)
            m_lpWizInfo->bstrSelectedDomain = bstrDomain.Detach();
    }

    // Is50Domain will call DsGetDCName which is too slow in case of standalone server.
    // To improve the performance, we should always enable the Browse button, and report
    // error if user clicks the button.
    ::EnableWindow(GetDlgItem(IDCSERVERS_BROWSE), m_lpWizInfo->bstrSelectedDomain && *m_lpWizInfo->bstrSelectedDomain);

    SetDlgItemText(IDC_EDIT_SELECTED_SERVER, m_lpWizInfo->bstrSelectedServer ? m_lpWizInfo->bstrSelectedServer : _T(""));

    if (m_lpWizInfo->bRootReplica)          // If a root replica is being added
    {  
        ::PropSheet_SetWizButtons(GetParent(), PSWIZB_NEXT);
        ::ShowWindow(GetDlgItem(IDC_SERVER_SHARE_LABEL), SW_NORMAL);
        ::ShowWindow(GetDlgItem(IDC_SERVER_SHARE), SW_NORMAL);
        SetDlgItemText(IDC_SERVER_SHARE, m_lpWizInfo->bstrDfsRootName);
    } else
        ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

BOOL 
CCreateDfsRootWizPage4::OnWizardNext()
{
    CWaitCursor    WaitCursor;

    HRESULT     hr = S_OK;
    DWORD       dwTextLength = 0;
    CComBSTR    bstrCurrentText;
    hr = GetInputText(GetDlgItem(IDC_EDIT_SELECTED_SERVER), &bstrCurrentText, &dwTextLength);
    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
        return FALSE;
    } else if (0 == dwTextLength)
    {
        DisplayMessageBoxWithOK(IDS_MSG_EMPTY_FIELD);
        ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
        return FALSE;
    }

    // I_NetNameValidate will fail with \\server, 
    // hence, removing the whackwhack when passing it to this validation api.
    PTSTR p = bstrCurrentText;
    if (!mylstrncmpi(p, _T("\\\\"), 2))
        p += 2;

    if (I_NetNameValidate(0, p, NAMETYPE_COMPUTER, 0))
    {
        DisplayMessageBoxWithOK(IDS_MSG_INVALID_SERVER_NAME, bstrCurrentText);
        ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
        return FALSE;
    }

    // remove the ending dot
    if (bstrCurrentText[dwTextLength - 1] == _T('.'))
        bstrCurrentText[dwTextLength - 1] = _T('\0');

    CComBSTR bstrComputerName;
    hr = CheckUserEnteredValues(bstrCurrentText, &bstrComputerName);
    if (S_OK != hr)        // If server is not a valid one. The above function has already displayed the message
    {
        ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
        return FALSE;
    }

    if (m_lpWizInfo->bRootReplica)
    {
        hr = CheckShare(bstrCurrentText, m_lpWizInfo->bstrDfsRootName, &m_lpWizInfo->bShareExists);
        if (FAILED(hr))
        {
            DisplayMessageBoxForHR(hr);
            ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
            return FALSE;
        } else if (S_FALSE == hr)
        {
            DisplayMessageBoxWithOK(IDS_MSG_ROOTSHARE_NOGOOD, m_lpWizInfo->bstrDfsRootName);  
            ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
            return FALSE;
        }

        if (m_lpWizInfo->bPostW2KVersion && m_lpWizInfo->bShareExists && !CheckReparsePoint(bstrCurrentText, m_lpWizInfo->bstrDfsRootName))
        {
            DisplayMessageBoxWithOK(IDS_MSG_ROOTSHARE_NOTNTFS5, m_lpWizInfo->bstrDfsRootName);  
            ::SetFocus(GetDlgItem(IDC_EDIT_SELECTED_SERVER));
            return FALSE;
        }
    }

    SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSelectedServer);
    m_lpWizInfo->bstrSelectedServer = bstrComputerName.Detach();

    return TRUE;
}

// S_OK:    Yes, it belongs to the selected domain
// S_FALSE: No, it does not belong to the selected domain
// hr:      other errors
HRESULT
CCreateDfsRootWizPage4::IsServerInDomain(IN LPCTSTR lpszServer)
{
    if (DFS_TYPE_FTDFS != m_lpWizInfo->DfsType)
        return S_OK;

    CComBSTR bstrActualDomain;
    HRESULT  hr = GetServerInfo((LPTSTR)lpszServer, &bstrActualDomain);
    if (S_OK == hr)
    {
        if (!lstrcmpi(bstrActualDomain, m_lpWizInfo->bstrSelectedDomain))
            hr = S_OK;
        else
            hr = S_FALSE;
    }

    return hr;
}
 
HRESULT IsHostingDfsRootEx(IN BSTR i_bstrServer, IN BSTR i_bstrRootEntryPath)
{
    if (!i_bstrServer || !*i_bstrServer || !i_bstrRootEntryPath || !*i_bstrRootEntryPath)
        return E_INVALIDARG;

    int len = lstrlen(i_bstrServer);

    DFS_INFO_3*  pDfsInfo = NULL;
    NET_API_STATUS dwRet = NetDfsGetInfo(
                                i_bstrRootEntryPath,
                                NULL,
                                NULL,
                                3,
                                (LPBYTE *)&pDfsInfo);

    dfsDebugOut((_T("NetDfsGetInfo entry=%s, level 3 for IsHostingDfsRootEx, nRet=%d\n"),
        i_bstrRootEntryPath, dwRet));

    if (ERROR_NO_MORE_ITEMS == dwRet || ERROR_NOT_FOUND == dwRet)
        return S_FALSE;

    HRESULT hr = S_FALSE;
    if (NERR_Success == dwRet)
    {
        if (pDfsInfo->NumberOfStorages > 0)
        {
            LPDFS_STORAGE_INFO pStorage = pDfsInfo->Storage;
            for (DWORD i = 0; i < pDfsInfo->NumberOfStorages; i++)
            {
                //
                // We're doing simple comparison here.
                // In case of one server is IP address or a different name of the same machine,
                // we'll just leave it to Dfs API.
                //
                int lenServer = lstrlen(pStorage[i].ServerName);
                if (lenServer == len)
                {
                    if (!lstrcmpi(pStorage[i].ServerName, i_bstrServer))
                    {
                        hr = S_OK;
                        break;
                    }
                } else
                {
                    //
                    // consider one is Netbios, the other is DNS
                    //
                    PTSTR pszLong = NULL;
                    PTSTR pszShort = NULL;
                    int   minLen = 0;

                    if (lenServer > len)
                    {
                        pszLong = pStorage[i].ServerName;
                        pszShort = i_bstrServer;
                        minLen = len;
                    } else
                    {
                        pszShort = pStorage[i].ServerName;
                        pszLong = i_bstrServer;
                        minLen = lenServer;
                    }

                    if (!mylstrncmpi(pszLong, pszShort, minLen) && pszLong[minLen] == _T('.'))
                    {
                        hr = S_OK;
                        break;
                    }
                }
            }
        }

        NetApiBufferFree(pDfsInfo);
    } else
    {
        hr = HRESULT_FROM_WIN32(dwRet);
    }

    return hr;
}

HRESULT 
CCreateDfsRootWizPage4::CheckUserEnteredValues(
  IN  LPCTSTR              i_szMachineName,
  OUT BSTR*                o_pbstrComputerName
  )
/*++

Routine Description:

  Checks the value that user has given for this page.
  This is done typically on "Next" key being pressed.
  Check, if the machine name is a server that is NT 5.0, belongs to
  the domain previously selected and is running dfs service.

Arguments:

  i_szMachineName  -  Machine name given by the user
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_szMachineName);
  RETURN_INVALIDARG_IF_NULL(o_pbstrComputerName);

  HRESULT         hr = S_OK;
  BOOL            bPostNTServer = FALSE;
  LONG            lMajorVer = 0;
  LONG            lMinorVer = 0;

  SERVER_INFO_101* pServerInfo = NULL;
  DWORD dwRet = NetServerGetInfo((LPTSTR)i_szMachineName, 101, (LPBYTE*)&pServerInfo);
  if (NERR_Success == dwRet)
  {
    lMajorVer = pServerInfo->sv101_version_major & MAJOR_VERSION_MASK;
    lMinorVer = pServerInfo->sv101_version_minor;

    bPostNTServer = (pServerInfo->sv101_type & SV_TYPE_NT) && 
        lMajorVer >= 5 &&
        ((pServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
         (pServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ||
         (pServerInfo->sv101_type & SV_TYPE_SERVER_NT));

    NetApiBufferFree(pServerInfo);
  } else
  {
    hr = HRESULT_FROM_WIN32(dwRet);
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_INCORRECT_SERVER, i_szMachineName);
    return hr;
  }

  if (!bPostNTServer)
  {
    DisplayMessageBoxWithOK(IDS_MSG_NOT_50);
    return S_FALSE;
  }
/* LinanT 3/19/99: remove "check registry, if set, get dns server"

  CComBSTR        bstrDnsComputerName;
  (void)GetServerInfo(
          (LPTSTR)i_szMachineName, 
          NULL, // domain
          NULL, // Netbios
          NULL, // ValidDSObject
          &bstrDnsComputerName, // Dns
          NULL, // Guid
          NULL, // FQDN
          NULL, // lMajorVer 
          NULL //lMinorVer
          );
  *o_pbstrComputerName = SysAllocString(bstrDnsComputerName ? bstrDnsComputerName : bstrNetbiosComputerName);
*/
  if ( !mylstrncmpi(i_szMachineName, _T("\\\\"), 2) )
    *o_pbstrComputerName = SysAllocString(i_szMachineName + 2);
  else
    *o_pbstrComputerName = SysAllocString(i_szMachineName);
  if (!*o_pbstrComputerName)
  {
    hr = E_OUTOFMEMORY;
    DisplayMessageBoxForHR(hr);
    return hr;
  }

/* 
//
// don't check, let DFS API handle it.
// This way, we have space to handle new DFS service if introduced in the future.
// 
  hr = IsServerRunningDfs(*o_pbstrComputerName);
  if(S_OK != hr)
  {
    DisplayMessageBoxWithOK(IDS_MSG_NOT_RUNNING_DFS, *o_pbstrComputerName);
    return hr;
  }
*/

  hr = IsServerInDomain(*o_pbstrComputerName);
  if (FAILED(hr))
  {
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_INCORRECT_SERVER, *o_pbstrComputerName);
    return hr;
  } else if (S_FALSE == hr)
  {
    DisplayMessageBoxWithOK(IDS_MSG_SERVER_FROM_ANOTHER_DOMAIN, *o_pbstrComputerName);
    return hr;
  }

    //
    // for W2K, check if server already has a dfs root set up        
    // do not check for Whistler (in which case the lMinorVer == 1).
    //
    if (lMajorVer == 5 && lMinorVer < 1 && S_OK == IsHostingDfsRoot(*o_pbstrComputerName))
    {
        DisplayMessageBoxWithOK(IDS_MSG_WIZ_DFS_ALREADY_PRESENT,NULL);  
        return S_FALSE;
    }

    m_lpWizInfo->bPostW2KVersion = (lMajorVer >= 5 && lMinorVer >= 1);

    //
    // for postW2K in case of newRootTarget, check if server already host for this dfs root 
    //
    if (m_lpWizInfo->bPostW2KVersion && m_lpWizInfo->bRootReplica)
    {
        CComBSTR bstrRootEntryPath = _T("\\\\");
        bstrRootEntryPath += m_lpWizInfo->bstrSelectedDomain;
        bstrRootEntryPath += _T("\\");
        bstrRootEntryPath += m_lpWizInfo->bstrDfsRootName;
        if  (S_OK == IsHostingDfsRootEx(*o_pbstrComputerName, bstrRootEntryPath))
        {
            DisplayMessageBoxWithOK(IDS_MSG_WIZ_ALREADY_ROOTTARGET,NULL);  
            return S_FALSE;
        }
    }

  return S_OK;
}

BOOL 
CCreateDfsRootWizPage4::OnWizardBack()
{
  SetDlgItemText(IDC_EDIT_SELECTED_SERVER, _T(""));  // Set edit box to empty
  SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSelectedServer);

  return TRUE;
}

HRESULT
GetComputerDnsNameFromLDAP(
    IN  LPCTSTR   lpszLDAPPath,
    OUT BSTR      *o_pbstrName
    )
{
    CComPtr<IADs>   spIADs;
    HRESULT hr = ADsGetObject(const_cast<LPTSTR>(lpszLDAPPath), IID_IADs, (void**)&spIADs);
    if (SUCCEEDED(hr))
    {
        VARIANT   var;
        VariantInit(&var);

        hr = spIADs->Get(_T("dnsHostName"), &var);
        if (SUCCEEDED(hr))
        {
            CComBSTR bstrComputer = V_BSTR(&var);
            *o_pbstrName = bstrComputer.Detach();

            VariantClear(&var);
        }
    }

    return hr;
}

HRESULT
GetComputerNetbiosNameFromLDAP(
    IN  LPCTSTR   lpszLDAPPath,
    OUT BSTR      *o_pbstrName
    )
{
    CComPtr<IADsPathname>   spIAdsPath;
    HRESULT hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER, IID_IADsPathname, (void**)&spIAdsPath);
    if (SUCCEEDED(hr))
    {
        hr = spIAdsPath->Set(const_cast<LPTSTR>(lpszLDAPPath), ADS_SETTYPE_FULL);
        if (SUCCEEDED(hr))
        {
            hr = spIAdsPath->SetDisplayType(ADS_DISPLAY_VALUE_ONLY);
            if (SUCCEEDED(hr))
            {
                // Get first Component which is computer's Netbios name.
                CComBSTR  bstrComputer;
                hr = spIAdsPath->GetElement(0, &bstrComputer);
                if (SUCCEEDED(hr))
                    *o_pbstrName = bstrComputer.Detach();
            }
        }
    }

    return hr;
}

BOOL 
CCreateDfsRootWizPage4::OnBrowse(
  IN WORD            wNotifyCode, 
  IN WORD            wID, 
  IN HWND            hWndCtl, 
  IN BOOL&           bHandled
  )
/*++

Routine Description:

  Handles the mouse click of the Browse button.
  Display the Computer Query Dialog.

--*/
{
  CWaitCursor     WaitCursor;
  DSQUERYINITPARAMS       dqip;
  OPENQUERYWINDOW         oqw;
  CComPtr<ICommonQuery>   pCommonQuery;
  CComPtr<IDataObject>    pDataObject;
  HRESULT                 hr = S_OK;
        
  do {
    CComBSTR bstrDCName;
    CComBSTR bstrLDAPDomainPath;
    hr = GetDomainInfo(
          m_lpWizInfo->bstrSelectedDomain,
          &bstrDCName,
          NULL,         // domainDns
          NULL,         // domainDN
          &bstrLDAPDomainPath);
    if (FAILED(hr))
      break;

    dfsDebugOut((_T("OnBrowse bstrDCName=%s, bstrLDAPDomainPath=%s\n"),
      bstrDCName, bstrLDAPDomainPath));

    hr = CoCreateInstance(CLSID_CommonQuery, NULL, CLSCTX_INPROC_SERVER, IID_ICommonQuery, (void **)&pCommonQuery);
    if (FAILED(hr)) break;

                          // Parameters for Query Dialog.
    ZeroMemory(&dqip, sizeof(dqip));
    dqip.cbStruct = sizeof(dqip);  
    dqip.dwFlags = DSQPF_HASCREDENTIALS;    
    dqip.pDefaultScope = bstrLDAPDomainPath;
    dqip.pServer = bstrDCName;

    ZeroMemory(&oqw, sizeof(oqw));
    oqw.cbStruct = sizeof(oqw);
    oqw.clsidHandler = CLSID_DsQuery;        // Handler is Ds Query.
    oqw.pHandlerParameters = &dqip;
    oqw.clsidDefaultForm = CLSID_DsFindComputer;  // Show Find Computers Query Dialog
    oqw.dwFlags = OQWF_OKCANCEL | 
            OQWF_SINGLESELECT | 
            OQWF_DEFAULTFORM | 
            OQWF_REMOVEFORMS | 
            OQWF_ISSUEONOPEN | 
            OQWF_REMOVESCOPES ;

    hr = pCommonQuery->OpenQueryWindow(m_hWnd, &oqw, &pDataObject);
    if (S_OK != hr) break;

    if (NULL == m_cfDsObjectNames )
    {
      m_cfDsObjectNames = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOBJECTNAMES);
    }

    FORMATETC fmte =  { 
                CF_HDROP, 
                NULL, 
                DVASPECT_CONTENT, 
                -1, 
                TYMED_HGLOBAL
              };
  
    STGMEDIUM medium =  { 
                TYMED_NULL, 
                NULL, 
                NULL 
              };

    fmte.cfFormat = m_cfDsObjectNames;  

    hr = pDataObject->GetData(&fmte, &medium);
    if (FAILED(hr)) break;

    LPDSOBJECTNAMES pDsObjects = (LPDSOBJECTNAMES)medium.hGlobal;
    if (!pDsObjects || pDsObjects->cItems <= 0)
    {
      hr = S_FALSE;
      break;
    }

    // retrieve the full LDAP path to the computer
    LPTSTR    lpszTemp = 
                (LPTSTR)(((LPBYTE)pDsObjects)+(pDsObjects->aObjects[0].offsetName));

    // try to retrieve its Dns name
    CComBSTR  bstrComputer;
    hr = GetComputerDnsNameFromLDAP(lpszTemp, &bstrComputer);

    // if failed, try to retrieve its Netbios name
    if (FAILED(hr))
      hr = GetComputerNetbiosNameFromLDAP(lpszTemp, &bstrComputer);

    if (FAILED(hr)) break;

    SetDlgItemText(IDC_EDIT_SELECTED_SERVER, bstrComputer);

  } while (0);

  if (FAILED(hr))
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_FAILED_TO_BROWSE_SERVER, m_lpWizInfo->bstrSelectedDomain);

  return (S_OK == hr);
}

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage5: Share selection
CCreateDfsRootWizPage5::CCreateDfsRootWizPage5(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage5>(true),
      m_lpWizInfo(i_lpWizInfo)
{
    CComBSTR  bstrTitle;
    LoadStringFromResource(IDS_WIZ_PAGE5_TITLE, &bstrTitle);
    SetHeaderTitle(bstrTitle);

    CComBSTR  bstrSubTitle;
    LoadStringFromResource(IDS_WIZ_PAGE5_SUBTITLE, &bstrSubTitle);
    SetHeaderSubTitle(bstrSubTitle);
}

BOOL 
CCreateDfsRootWizPage5::OnSetActive()
{
    if (m_lpWizInfo->bShareExists)
        return FALSE;  // root share exists, skip this page

  ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

BOOL 
CCreateDfsRootWizPage5::OnWizardNext()
{
    CWaitCursor WaitCursor;
    CComBSTR    bstrCurrentText;
    DWORD       dwTextLength = 0;

    // get share path
    HRESULT hr = GetInputText(GetDlgItem(IDC_EDIT_SHARE_PATH), &bstrCurrentText, &dwTextLength);
    if (FAILED(hr))
    {
      DisplayMessageBoxForHR(hr);
      ::SetFocus(GetDlgItem(IDC_EDIT_SHARE_PATH));
      return FALSE;
    } else if (0 == dwTextLength)
    {
      DisplayMessageBoxWithOK(IDS_MSG_EMPTY_FIELD);
      ::SetFocus(GetDlgItem(IDC_EDIT_SHARE_PATH));
      return FALSE;
    }

    // Removing the ending backslash, otherwise, GetFileAttribute/NetShareAdd will fail.
    TCHAR *p = bstrCurrentText + _tcslen(bstrCurrentText) - 1;
    if (IsValidLocalAbsolutePath(bstrCurrentText) && *p == _T('\\') && *(p-1) != _T(':'))
      *p = _T('\0');

    if (S_OK != ValidateFolderPath(m_lpWizInfo->bstrSelectedServer, bstrCurrentText))
    {
      ::SetFocus(GetDlgItem(IDC_EDIT_SHARE_PATH));
      return FALSE;
    }
    SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSharePath);
    m_lpWizInfo->bstrSharePath = bstrCurrentText.Detach();

              // Create the share.
    hr = CreateShare(
              m_lpWizInfo->bstrSelectedServer,
              m_lpWizInfo->bstrDfsRootName,
              _T(""),  // Blank Comment
              m_lpWizInfo->bstrSharePath
            );

    if (FAILED(hr))
    {
      DisplayMessageBoxForHR(hr);
      return FALSE;      
    }

    if (m_lpWizInfo->bPostW2KVersion && !CheckReparsePoint(m_lpWizInfo->bstrSelectedServer, m_lpWizInfo->bstrDfsRootName))
    {
        DisplayMessageBoxWithOK(IDS_MSG_ROOTSHARE_NOTNTFS5, m_lpWizInfo->bstrDfsRootName);
        NetShareDel(m_lpWizInfo->bstrSelectedServer, m_lpWizInfo->bstrDfsRootName, 0);
      ::SetFocus(GetDlgItem(IDC_EDIT_SHARE_PATH));
        return FALSE;
    }

    SetDlgItemText(IDC_EDIT_SHARE_PATH, _T(""));

    return TRUE;
}

BOOL 
CCreateDfsRootWizPage5::OnWizardBack()
{
    SetDlgItemText(IDC_EDIT_SHARE_PATH, _T(""));
    SAFE_SYSFREESTRING(&m_lpWizInfo->bstrSharePath);

    return TRUE;
}

LRESULT CCreateDfsRootWizPage5::OnInitDialog(
  IN UINT          i_uMsg,
  IN WPARAM        i_wParam,
  IN LPARAM        i_lParam,
  IN OUT BOOL&     io_bHandled
  )
{
  ::SendMessage(GetDlgItem(IDC_EDIT_SHARE_PATH), EM_LIMITTEXT, _MAX_DIR - 1, 0);

  return TRUE;
}

BOOL 
CCreateDfsRootWizPage5::OnBrowse(
  IN WORD            wNotifyCode, 
  IN WORD            wID, 
  IN HWND            hWndCtl, 
  IN BOOL&           bHandled
  )
/*++

Routine Description:

  Handles the mouse click of the Browse button.
  Display the folder Dialog.

--*/
{
  CWaitCursor     WaitCursor;

  BOOL bLocalComputer = (S_OK == IsComputerLocal(m_lpWizInfo->bstrSelectedServer));

  TCHAR       szDir[MAX_PATH * 2] = _T(""); // double the size in case the remote path is itself close to MAX_PATH
  OpenBrowseDialog(m_hWnd, IDS_BROWSE_FOLDER, bLocalComputer, m_lpWizInfo->bstrSelectedServer, szDir);

  CComBSTR bstrPath;
  if (szDir[0])
  {
    if (bLocalComputer)
      bstrPath = szDir;
    else
    { // szDir is in the form of \\server\share or \\server\share\path....
      LPTSTR pShare = _tcschr(szDir + 2, _T('\\'));
      pShare++;
      LPTSTR pLeftOver = _tcschr(pShare, _T('\\'));
      if (pLeftOver && *pLeftOver)
        *pLeftOver++ = _T('\0');

      SHARE_INFO_2 *psi = NULL;
      if (NERR_Success == NetShareGetInfo(m_lpWizInfo->bstrSelectedServer, pShare, 2, (LPBYTE *)&psi))
      {
        bstrPath = psi->shi2_path;
        if (pLeftOver && *pLeftOver)
        {
          if (_T('\\') != bstrPath[lstrlen(bstrPath) - 1])
            bstrPath += _T("\\");
          bstrPath += pLeftOver;
        }
        NetApiBufferFree(psi);
      }
    }
  }

  if ((BSTR)bstrPath && *bstrPath)
    SetDlgItemText(IDC_EDIT_SHARE_PATH, bstrPath);

  return TRUE;
}

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage6: DfsRoot name selection
CCreateDfsRootWizPage6::CCreateDfsRootWizPage6(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage6>(true),
      m_lpWizInfo(i_lpWizInfo)
{
    CComBSTR  bstrTitle;
    LoadStringFromResource(IDS_WIZ_PAGE6_TITLE, &bstrTitle);
    SetHeaderTitle(bstrTitle);

    CComBSTR  bstrSubTitle;
    LoadStringFromResource(IDS_WIZ_PAGE6_SUBTITLE, &bstrSubTitle);
    SetHeaderSubTitle(bstrSubTitle);
}

BOOL 
CCreateDfsRootWizPage6::OnSetActive()
{
    if (m_lpWizInfo->bRootReplica)
        return FALSE;  // we skip this page in case of creating new root target

    ::SendMessage(GetDlgItem(IDC_EDIT_DFSROOT_NAME), EM_LIMITTEXT, MAX_RDN_KEY_SIZE, 0);

    if (NULL != m_lpWizInfo->bstrDfsRootName)  // Set the default dfsroot name
        SetDlgItemText(IDC_EDIT_DFSROOT_NAME, m_lpWizInfo->bstrDfsRootName);

    ::SendMessage(GetDlgItem(IDC_EDIT_DFSROOT_COMMENT), EM_LIMITTEXT, MAXCOMMENTSZ, 0);

    UpdateLabels();              // Change the labels

    ::PropSheet_SetWizButtons(GetParent(), PSWIZB_BACK | PSWIZB_NEXT);

    return TRUE;
}

HRESULT 
CCreateDfsRootWizPage6::UpdateLabels()
{
    CComBSTR  bstrDfsRootName;
    DWORD     dwTextLength = 0;
    (void)GetInputText(GetDlgItem(IDC_EDIT_DFSROOT_NAME), &bstrDfsRootName, &dwTextLength);
    SetDlgItemText(IDC_ROOT_SHARE, bstrDfsRootName);

    CComBSTR bstrFullPath = _T("\\\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFullPath);
    if (DFS_TYPE_FTDFS == m_lpWizInfo->DfsType)
    bstrFullPath += m_lpWizInfo->bstrSelectedDomain;
    else
    bstrFullPath += m_lpWizInfo->bstrSelectedServer;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFullPath);
    bstrFullPath +=  _T("\\");
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFullPath);
    bstrFullPath += bstrDfsRootName;
    RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrFullPath);

    SetDlgItemText(IDC_TEXT_DFSROOT_PREFIX, bstrFullPath);

    ::SendMessage(GetDlgItem(IDC_TEXT_DFSROOT_PREFIX), EM_SETSEL, 0, (LPARAM)-1);
    ::SendMessage(GetDlgItem(IDC_TEXT_DFSROOT_PREFIX), EM_SETSEL, (WPARAM)-1, 0);
    ::SendMessage(GetDlgItem(IDC_TEXT_DFSROOT_PREFIX), EM_SCROLLCARET, 0, 0);

    return S_OK;
}

LRESULT
CCreateDfsRootWizPage6::OnChangeDfsRoot(
    WORD wNotifyCode,
    WORD wID, 
    HWND hWndCtl,
    BOOL& bHandled)
{
    UpdateLabels();

    return TRUE;
}


BOOL 
CCreateDfsRootWizPage6::OnWizardNext(
)
{
  CWaitCursor   WaitCursor;
  HRESULT       hr = S_OK;
  CComBSTR      bstrCurrentText;
  DWORD         dwTextLength = 0;
                    
  // get dfsroot name
  hr = GetInputText(GetDlgItem(IDC_EDIT_DFSROOT_NAME), &bstrCurrentText, &dwTextLength);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
    return FALSE;
  } else if (0 == dwTextLength)
  {
    DisplayMessageBoxWithOK(IDS_MSG_EMPTY_FIELD);
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
    return FALSE;
  }

                // See if the Dfs Name has illegal Characters.
  if (_tcscspn(bstrCurrentText, _T("\\/@")) != _tcslen(bstrCurrentText) ||
      (DFS_TYPE_FTDFS == m_lpWizInfo->DfsType && I_NetNameValidate(NULL, bstrCurrentText, NAMETYPE_SHARE, 0)) )
  {
    DisplayMessageBoxWithOK(IDS_MSG_WIZ_BAD_DFS_NAME,NULL);  
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
    return FALSE;
  }

                // domain DFS only: See if the Dfs Name exists.
  if (DFS_TYPE_FTDFS == m_lpWizInfo->DfsType)
  {
    BOOL        bRootAlreadyExist = FALSE;
    NETNAMELIST DfsRootList;
    if (S_OK == GetDomainDfsRoots(&DfsRootList, m_lpWizInfo->bstrSelectedDomain))
    {
        for (NETNAMELIST::iterator i = DfsRootList.begin(); i != DfsRootList.end(); i++)
        {
            if (!lstrcmpi((*i)->bstrNetName, bstrCurrentText))
            {
                bRootAlreadyExist = TRUE;
                break;
            }
        }

        FreeNetNameList(&DfsRootList);
    }
    if (bRootAlreadyExist)
    {
        DisplayMessageBoxWithOK(IDS_MSG_ROOT_ALREADY_EXISTS, bstrCurrentText);  
        ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
        return FALSE;
    }
  }

  hr = CheckShare(m_lpWizInfo->bstrSelectedServer, bstrCurrentText, &m_lpWizInfo->bShareExists);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
    return FALSE;
  } else if (S_FALSE == hr)
  {
    DisplayMessageBoxWithOK(IDS_MSG_ROOTSHARE_NOGOOD, bstrCurrentText);  
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
    return FALSE;
  }

  if (m_lpWizInfo->bPostW2KVersion && m_lpWizInfo->bShareExists && !CheckReparsePoint(m_lpWizInfo->bstrSelectedServer, bstrCurrentText))
  {
    DisplayMessageBoxWithOK(IDS_MSG_ROOTSHARE_NOTNTFS5, bstrCurrentText);  
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_NAME));
    return FALSE;
  }

  SAFE_SYSFREESTRING(&m_lpWizInfo->bstrDfsRootName);
  m_lpWizInfo->bstrDfsRootName = bstrCurrentText.Detach();

  // get dfsroot comment
  hr = GetInputText(GetDlgItem(IDC_EDIT_DFSROOT_COMMENT), &bstrCurrentText, &dwTextLength);
  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(IDC_EDIT_DFSROOT_COMMENT));
    return FALSE;
  }
  SAFE_SYSFREESTRING(&m_lpWizInfo->bstrDfsRootComment);
  m_lpWizInfo->bstrDfsRootComment = bstrCurrentText.Detach();

  return TRUE;
}

BOOL 
CCreateDfsRootWizPage6::OnWizardBack()
{
    SAFE_SYSFREESTRING(&m_lpWizInfo->bstrDfsRootName);

    return TRUE;
}




// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage7: Completion page
CCreateDfsRootWizPage7::CCreateDfsRootWizPage7(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo)
    : CQWizardPageImpl<CCreateDfsRootWizPage7>(false),
      m_lpWizInfo(i_lpWizInfo)
{
}

BOOL 
CCreateDfsRootWizPage7::OnSetActive()
{
    CWaitCursor wait;

    CComBSTR bstrText;
    if (DFS_TYPE_FTDFS == m_lpWizInfo->DfsType)
    {
        FormatMessageString(&bstrText, 0, IDS_DFSWIZ_TEXT_FTDFS, 
            m_lpWizInfo->bstrSelectedDomain,
            m_lpWizInfo->bstrSelectedServer,
            m_lpWizInfo->bstrDfsRootName,
            m_lpWizInfo->bstrDfsRootName);
    } else
    {
        FormatMessageString(&bstrText, 0, IDS_DFSWIZ_TEXT_SADFS, 
            m_lpWizInfo->bstrSelectedServer,
            m_lpWizInfo->bstrDfsRootName,
            m_lpWizInfo->bstrDfsRootName);
    }

    SetDlgItemText(IDC_DFSWIZ_TEXT, bstrText);

  ::PropSheet_SetWizButtons(GetParent(), PSWIZB_FINISH | PSWIZB_BACK);
  
  ::SetControlFont(m_lpWizInfo->hBigBoldFont, m_hWnd, IDC_COMPLETE_BIG_TITLE);
  ::SetControlFont(m_lpWizInfo->hBoldFont, m_hWnd, IDC_COMPLETE_SMALL_TITLE);

    return TRUE;
}

BOOL 
CCreateDfsRootWizPage7::OnWizardFinish()
{
    return (S_OK  == _SetUpDfs(m_lpWizInfo));
}


BOOL 
CCreateDfsRootWizPage7::OnWizardBack()
{
    //
    // if share was created by the previous page, blow it away when we go back
    //
    if (!m_lpWizInfo->bShareExists)
        NetShareDel(m_lpWizInfo->bstrSelectedServer, m_lpWizInfo->bstrDfsRootName, 0);
  
    return TRUE;
}

BOOL CCreateDfsRootWizPage7::OnQueryCancel()
{
    //
    // if share was created by the previous page, blow it away when we cancel the wizard
    //
    if (!m_lpWizInfo->bShareExists)
        NetShareDel(m_lpWizInfo->bstrSelectedServer, m_lpWizInfo->bstrDfsRootName, 0);

    return TRUE;    // ok to cancel
}

HRESULT _SetUpDfs(
  LPCREATEDFSROOTWIZINFO  i_lpWizInfo
    )
/*++

Routine Description:

  Helper Function to Setup Dfs, called from wizard and new root replica,
  Finish() method of Page5 if root level replca is created and Next() method of Page6
  for Create New Dfs Root Wizard.

Arguments:

  i_lpWizInfo - Wizard data.

Return value:
  
   S_OK, on success
--*/
{
    if (!i_lpWizInfo ||
        !(i_lpWizInfo->bstrSelectedServer) ||
        !(i_lpWizInfo->bstrDfsRootName))
        return(E_INVALIDARG);

    CWaitCursor    WaitCursor;
    NET_API_STATUS nstatRetVal = 0;
    if (DFS_TYPE_FTDFS == i_lpWizInfo->DfsType)
    {    
        nstatRetVal = NetDfsAddFtRoot(
                                    i_lpWizInfo->bstrSelectedServer, // Remote Server
                                    i_lpWizInfo->bstrDfsRootName,   // Root Share
                                    i_lpWizInfo->bstrDfsRootName,   // FtDfs Name
                                    i_lpWizInfo->bstrDfsRootComment,  // Comment
                                    0                 // No Flags.
                                    );
        dfsDebugOut((_T("NetDfsAddFtRoot server=%s, share=%s, DfsName=%s, comment=%s, nRet=%d\n"),
                i_lpWizInfo->bstrSelectedServer, i_lpWizInfo->bstrDfsRootName, i_lpWizInfo->bstrDfsRootName, i_lpWizInfo->bstrDfsRootComment, nstatRetVal));
    } else
    {
        nstatRetVal = NetDfsAddStdRoot(
                                    i_lpWizInfo->bstrSelectedServer, // Remote Server
                                    i_lpWizInfo->bstrDfsRootName,   // Root Share
                                    i_lpWizInfo->bstrDfsRootComment,  // Comment
                                    0                 // No Flags.
                                    );
        dfsDebugOut((_T("NetDfsAddStdRoot server=%s, share=%s, comment=%s, nRet=%d\n"),
                i_lpWizInfo->bstrSelectedServer, i_lpWizInfo->bstrDfsRootName, i_lpWizInfo->bstrDfsRootComment, nstatRetVal));
    }

    HRESULT hr = S_OK;
    if (NERR_Success != nstatRetVal)
    {
        hr = HRESULT_FROM_WIN32(nstatRetVal);
        DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_FAILED_TO_CREATE_DFSROOT, i_lpWizInfo->bstrSelectedServer);
        hr = S_FALSE; // failed to create dfsroot, wizard cannot be closed
    } else
    {
        i_lpWizInfo->bDfsSetupSuccess = true;
    }

    return hr;
}

HRESULT
ValidateFolderPath(
    IN LPCTSTR lpszServer,
    IN LPCTSTR lpszPath
)
{
  if (!lpszPath || !*lpszPath)
    return E_INVALIDARG;

  HWND hwnd = ::GetActiveWindow();
  HRESULT hr = S_FALSE;

  do {
    if (!IsValidLocalAbsolutePath(lpszPath))
    {
      DisplayMessageBox(hwnd, MB_OK, 0, IDS_INVALID_FOLDER);
      break;
    }

    hr = IsComputerLocal(lpszServer);
    if (FAILED(hr))
    {
      DisplayMessageBox(hwnd, MB_OK, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszPath);
      break;
    }

    BOOL bLocal = (S_OK == hr);
  
    hr = VerifyDriveLetter(lpszServer, lpszPath);
    if (FAILED(hr))
    {
      DisplayMessageBox(hwnd, MB_OK, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszPath);
      break;
    } else if (S_OK != hr)
    {
      DisplayMessageBox(hwnd, MB_OK, 0, IDS_INVALID_FOLDER);
      break;
    }

    if (!bLocal)
    {
      hr = IsAdminShare(lpszServer, lpszPath);
      if (FAILED(hr))
      {
        DisplayMessageBox(hwnd, MB_OK, hr, IDS_FAILED_TO_VALIDATE_FOLDER, lpszPath);
        break;
      } else if (S_OK != hr)
      {
        // there is no matching $ shares, hence, no need to call GetFileAttribute, CreateDirectory,
        // assume lpszDir points to an existing directory
        hr = S_OK;
        break;
      }
    }

    CComBSTR bstrFullPath;
    GetFullPath(lpszServer, lpszPath, &bstrFullPath);

    hr = IsAnExistingFolder(hwnd, bstrFullPath);
    if (FAILED(hr) || S_OK == hr)
      break;

    if ( IDYES != DisplayMessageBox(hwnd, MB_YESNO, 0, IDS_CREATE_FOLDER, lpszPath, lpszServer) )
    {
      hr = S_FALSE;
      break;
    }

    // create the directories layer by layer
    hr = CreateLayeredDirectory(lpszServer, lpszPath);
    if (FAILED(hr))
    {
      DisplayMessageBox(hwnd, MB_OK, hr, IDS_FAILED_TO_CREATE_FOLDER, lpszPath, lpszServer);
      break;
    }
  } while (0);

  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\frsadv.h ===
/*++
Module Name:

    frsAdv.cpp

Abstract:

    This module contains the declaration of the CFRSAdvanced.
    This class displays the FRS Advanced Dialog.

*/

#ifndef __FRSADV_H_
#define __FRSADV_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"
#include "DfsCore.h"
#include "CusTop.h"

#include <list>
using namespace std;

typedef struct _FRSADV_CONNECTION
{
    CCusTopConnection*  pConn;
    BOOL                bSyncImmediately;
    Connection_Priority nPriority;
} FRSADV_CONNECTION;

/////////////////////////////////////////////////////////////////////////////
// CFRSAdvanced
class CFRSAdvanced : 
  public CDialogImpl<CFRSAdvanced>
{
public:
    CFRSAdvanced();
    ~CFRSAdvanced();

    enum { IDD = IDD_FRS_ADVANCED };

BEGIN_MSG_MAP(CFRSAdvanced)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
    COMMAND_ID_HANDLER(IDC_FRS_ADVANCED_SERVER, OnServer)
    COMMAND_ID_HANDLER(IDC_FRS_ADVANCED_NEW_PRIORITY, OnNewPriority)
    COMMAND_ID_HANDLER(IDC_FRS_ADVANCED_CHANGE, OnChange)
END_MSG_MAP()

    //  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnServer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNewPriority(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnNotify(
                    IN UINT            i_uMsg, 
                    IN WPARAM          i_wParam, 
                    IN LPARAM          i_lParam, 
                    IN OUT BOOL&        io_bHandled
                    );

    HRESULT Initialize(CCusTopMemberList* i_pMemberList, CCusTopConnectionList*  i_pConnectionList, LPCTSTR i_pszToServer = NULL);
    void _SaveCheckStateOnConnections();
    HRESULT _InsertConnection(FRSADV_CONNECTION *pFrsAdvConn);

protected:
    CComBSTR                m_bstrPriorityHigh;
    CComBSTR                m_bstrPriorityMedium;
    CComBSTR                m_bstrPriorityLow;
    CComBSTR                m_bstrPriorityHighDesc;
    CComBSTR                m_bstrPriorityMediumDesc;
    CComBSTR                m_bstrPriorityLowDesc;
    CComBSTR                m_bstrToServer;
    CCusTopMemberList*      m_pMemberList;      // do not release it 
    CCusTopConnectionList*  m_pConnectionList;  // do not release it 
    UINT                    m_cConns;           // #connections we're dealing with in this dlg, a subset of m_pConnectionList
    FRSADV_CONNECTION*      m_pFrsAdvConnection;
};

int CALLBACK InboundConnectionsListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn);

#endif //__FRSADV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\dfswiz.h ===
/*++
Module Name:

    DfsWiz.h

Abstract:

    This module contains the declaration for CCreateDfsRootWizPage1, 2, 3, 4, 5, 6.
  These classes implement pages in the CreateDfs Root wizard.

--*/


#ifndef __CREATE_DFSROOT_WIZARD_PAGES_H_
#define __CREATE_DFSROOT_WIZARD_PAGES_H_

#include "QWizPage.h"      // The base class that implements the common functionality  
                // of wizard pages
#include "MmcAdmin.h"

#include "utils.h"

// This structure is used to pass information to and from the pages.
// Finally this is used to create the dfs root
class CREATEDFSROOTWIZINFO
{
public:
  HFONT      hBigBoldFont;
  HFONT      hBoldFont;

  DFS_TYPE    DfsType;
  BSTR      bstrSelectedDomain;
  BSTR      bstrSelectedServer;
  bool      bPostW2KVersion;
  BOOL      bShareExists;
  BSTR      bstrSharePath;
  BSTR      bstrDfsRootName;
  BSTR      bstrDfsRootComment;
  CMmcDfsAdmin*  pMMCAdmin;  
  bool      bRootReplica;
  bool      bDfsSetupSuccess;

  CREATEDFSROOTWIZINFO()
    :DfsType(DFS_TYPE_UNASSIGNED),
    bstrSelectedDomain(NULL),
    bstrSelectedServer(NULL),
    bPostW2KVersion(false),
    bShareExists(FALSE),
    bstrSharePath(NULL),
    bstrDfsRootName(NULL),
    bstrDfsRootComment(NULL),
    pMMCAdmin(NULL),
    bRootReplica(false),
    bDfsSetupSuccess(false)
  {
    SetupFonts( _Module.GetResourceInstance(), NULL, &hBigBoldFont, &hBoldFont );
    return;
  }


  ~CREATEDFSROOTWIZINFO()
  {
    DestroyFonts(hBigBoldFont, hBoldFont);

    SAFE_SYSFREESTRING(&bstrSelectedDomain);
    SAFE_SYSFREESTRING(&bstrSelectedServer);
    SAFE_SYSFREESTRING(&bstrSharePath);
    SAFE_SYSFREESTRING(&bstrDfsRootName);
    SAFE_SYSFREESTRING(&bstrDfsRootComment);

    return;
  }

};

typedef CREATEDFSROOTWIZINFO *LPCREATEDFSROOTWIZINFO;



// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage1: Welcome page

class CCreateDfsRootWizPage1: public CQWizardPageImpl<CCreateDfsRootWizPage1>
{
public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE1 };

  CCreateDfsRootWizPage1(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();

private:
  LPCREATEDFSROOTWIZINFO  m_lpWizInfo;
};

// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage2: Dfsroot type selection, domain or standalone

class CCreateDfsRootWizPage2: public CQWizardPageImpl<CCreateDfsRootWizPage2>
{
public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE2 };

  CCreateDfsRootWizPage2(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();
  BOOL OnWizardNext();
  BOOL OnWizardBack();

private:
  LPCREATEDFSROOTWIZINFO  m_lpWizInfo;
};



// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage3: Domain selection for DFS root

class CCreateDfsRootWizPage3: public CQWizardPageImpl<CCreateDfsRootWizPage3>
{
public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE3 };

  BEGIN_MSG_MAP(CCreateDfsRootWizPage3)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
    
    CHAIN_MSG_MAP(CQWizardPageImpl<CCreateDfsRootWizPage3>)
  END_MSG_MAP()

  CCreateDfsRootWizPage3(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();
  BOOL OnWizardNext();
  BOOL OnWizardBack();

  LRESULT OnNotify(
    IN UINT            i_uMsg, 
    IN WPARAM          i_wParam, 
    IN LPARAM          i_lParam, 
    IN OUT BOOL&       io_bHandled
    );

  BOOL OnItemChanged(
    IN  INT            i_iItem
    );

  LRESULT OnInitDialog(
    IN UINT            i_uMsg, 
    IN WPARAM          i_wParam, 
    IN LPARAM          i_lParam, 
    IN OUT BOOL&       io_bHandled
    );

private:

  // Add the domains to the list
  HRESULT AddDomainsToList(
    IN HWND            i_hImageList
    );

  // To set default values for the controls, etc
  HRESULT SetDefaultValues(
    );

private:
  LPCREATEDFSROOTWIZINFO    m_lpWizInfo;
};




// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage4: Server selection 

class CCreateDfsRootWizPage4: public CQWizardPageImpl<CCreateDfsRootWizPage4>
{
public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE4 };

  BEGIN_MSG_MAP(CCreateDfsRootWizPage4)
    COMMAND_ID_HANDLER(IDCSERVERS_BROWSE, OnBrowse)  
    CHAIN_MSG_MAP(CQWizardPageImpl<CCreateDfsRootWizPage4>)
  END_MSG_MAP()

  CCreateDfsRootWizPage4(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();
  BOOL OnWizardNext();
  BOOL OnWizardBack();

  BOOL OnBrowse(
    IN WORD            wNotifyCode, 
    IN WORD            wID, 
    IN HWND            hWndCtl, 
    IN BOOL&           bHandled
    );  

private:

  HRESULT IsServerInDomain(IN LPCTSTR lpszServer);

  // To check if the user entered proper values
  HRESULT CheckUserEnteredValues(
    IN  LPCTSTR          i_szMachineName,
    OUT BSTR*            o_pbstrComputerName
    );

private:
  LPCREATEDFSROOTWIZINFO  m_lpWizInfo;
  CLIPFORMAT              m_cfDsObjectNames;
};




// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage5: Share selection
// Displays the shares given a server. Allows choosing from this list or 
// creating a new one.

class CCreateDfsRootWizPage5: public CQWizardPageImpl<CCreateDfsRootWizPage5>
{
public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE5 };

  BEGIN_MSG_MAP(CCreateDfsRootWizPage5)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDCSHARE_BROWSE, OnBrowse)  
    
    CHAIN_MSG_MAP(CQWizardPageImpl<CCreateDfsRootWizPage5>)
  END_MSG_MAP()

  CCreateDfsRootWizPage5(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();
  BOOL OnWizardNext();
  BOOL OnWizardBack();

  LRESULT OnInitDialog(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
    );

  BOOL OnBrowse(
    IN WORD            wNotifyCode, 
    IN WORD            wID, 
    IN HWND            hWndCtl, 
    IN BOOL&           bHandled
    );  

private:
  LPCREATEDFSROOTWIZINFO  m_lpWizInfo;
};


// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage6: DfsRoot name selection, share has to be the same as the root

class CCreateDfsRootWizPage6: public CQWizardPageImpl<CCreateDfsRootWizPage6>
{
BEGIN_MSG_MAP(CCreateDfsRootWizPage6)
  COMMAND_HANDLER(IDC_EDIT_DFSROOT_NAME, EN_CHANGE, OnChangeDfsRoot)
  CHAIN_MSG_MAP(CQWizardPageImpl<CCreateDfsRootWizPage6>)
END_MSG_MAP()

public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE6 };

  CCreateDfsRootWizPage6(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();
  BOOL OnWizardNext();
  BOOL OnWizardBack();

  LRESULT OnChangeDfsRoot(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

private:
  // Update the text labels
  HRESULT  UpdateLabels();

private:
  LPCREATEDFSROOTWIZINFO  m_lpWizInfo;
};



// ----------------------------------------------------------------------------
// CCreateDfsRootWizPage7: Completion page

class CCreateDfsRootWizPage7: public CQWizardPageImpl<CCreateDfsRootWizPage7>
{
public:
  
  enum { IDD = IDD_CREATE_DFSROOT_WIZ_PAGE7 };

  CCreateDfsRootWizPage7(IN LPCREATEDFSROOTWIZINFO i_lpWizInfo);

  BOOL OnSetActive();
  BOOL OnWizardFinish();
  BOOL OnWizardBack();

  BOOL OnQueryCancel();

private:
    LPCREATEDFSROOTWIZINFO  m_lpWizInfo;

};

  // Helper Function to Set Up Dfs, called from wizard
HRESULT _SetUpDfs(LPCREATEDFSROOTWIZINFO  i_lpWizInfo);

#endif // __CREATE_DFSROOT_WIZARD_PAGES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\frsprop.h ===
/*++
Module Name:

    frsProp.h

Abstract:

--*/


#ifndef __FRSPROP_H_
#define __FRSPROP_H_

#include "dfsenums.h"
#include "dfscore.h"

#include "qwizpage.h"      // The base class that implements the common functionality  
                // of property and wizard pages



// ----------------------------------------------------------------------------
// CRealReplicaSetPropPage: Property Sheet Page for the Junction Point(Replica Set)

class CRealReplicaSetPropPage : public CQWizardPageImpl<CRealReplicaSetPropPage>
{
public:
  enum { IDD = IDD_FRS_PROP };
  
  BEGIN_MSG_MAP(CRealReplicaSetPropPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_PARENT_NODE_CLOSING, OnParentClosing)
    COMMAND_ID_HANDLER(IDC_FRSPROP_FILEFILTER_EDIT, OnEditFileFilter)
    COMMAND_ID_HANDLER(IDC_FRSPROP_DIRFILTER_EDIT, OnEditDirFilter)
    COMMAND_ID_HANDLER(IDC_FRSPROP_RESETSCHEDULE, OnResetSchedule)
    COMMAND_ID_HANDLER(IDC_FRSPROP_CUSTOMIZE, OnCustomize)

    CHAIN_MSG_MAP(CQWizardPageImpl<CRealReplicaSetPropPage>)
  END_MSG_MAP()

  
  CRealReplicaSetPropPage(
    );


  ~CRealReplicaSetPropPage(
    );

  LRESULT OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    LPARAM          i_lParam, 
    IN OUT BOOL&      io_bHandled
    );

  LRESULT OnCtxHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  LRESULT OnCtxMenuHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  HRESULT Initialize(IN IReplicaSet* i_piReplicaSet);

  // Message handlers

  LRESULT OnApply(
    );

  LRESULT OnEditFileFilter(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnEditDirFilter(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnResetSchedule(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnCustomize(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );

  // Used by the node to tell the propery page to close.
  LRESULT OnParentClosing(
    IN UINT            i_uMsg, 
    IN WPARAM          i_wParam, 
    LPARAM            i_lParam, 
    IN OUT BOOL&        io_bHandled
    );


  // Used to set notification data
  HRESULT SetNotifyData(
    IN LONG_PTR            i_lNotifyHandle,
    IN LPARAM            i_lParam
    );

protected:
    void _Reset();
    HRESULT _GetMemberDNInfo(
        IN  BSTR    i_bstrMemberDN,
        OUT BSTR*   o_pbstrServer
    );

private:
    LONG_PTR      m_lNotifyHandle;
    LPARAM        m_lNotifyParam;

    CComBSTR            m_bstrTopologyPref;
    CComBSTR            m_bstrFileFilter;
    CComBSTR            m_bstrDirFilter;
    CComBSTR            m_bstrPrimaryMemberDN;
    CComBSTR            m_bstrHubMemberDN;
    long                m_lNumOfMembers;
    long                m_lNumOfConnections;

    CComPtr<IReplicaSet> m_piReplicaSet;

};

#endif // __FRSPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\frsprop.cpp ===
/*++
Module Name:

    frsProp.cpp

Abstract:

--*/

#include "stdafx.h"
#include "resource.h"
#include "utils.h"
#include "frsProp.h"
#include "mvEdit.h"
#include "dfshelp.h"
#include "CusTop.h"
#include "ldaputils.h"

CRealReplicaSetPropPage::CRealReplicaSetPropPage() :
    m_lNotifyHandle(0), 
    m_lNotifyParam(0), 
	CQWizardPageImpl<CRealReplicaSetPropPage>(false)
{
    m_bstrTopologyPref = FRS_RSTOPOLOGYPREF_RING;
}

CRealReplicaSetPropPage::~CRealReplicaSetPropPage()
{
    // do not call MMCFreeNotifyHandle(m_lNotifyHandle);
    //
    // It should only be called once, and is already called 
    // by the main property page
}

HRESULT CRealReplicaSetPropPage::_GetMemberDNInfo(
    IN  BSTR    i_bstrMemberDN,
    OUT BSTR*   o_pbstrServer
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrMemberDN);
    RETURN_INVALIDARG_IF_NULL(o_pbstrServer);

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = m_piReplicaSet->GetMemberInfo(i_bstrMemberDN, &var);
    RETURN_IF_FAILED(hr);

    if (V_VT(&var) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa = V_ARRAY(&var);
    if (!psa) // no such member at all
        return S_FALSE;

    long    lLowerBound = 0;
    long    lUpperBound = 0;
    long    lCount = 0;
    SafeArrayGetLBound(psa, 1, &lLowerBound);
    SafeArrayGetUBound(psa, 1, &lUpperBound);
    lCount = lUpperBound - lLowerBound + 1;

    VARIANT HUGEP *pArray;
    SafeArrayAccessData(psa, (void HUGEP **) &pArray);

    *o_pbstrServer = SysAllocString(pArray[4].bstrVal);

    SafeArrayUnaccessData(psa);

    VariantClear(&var); // it will in turn call SafeArrayDestroy(psa);

    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrServer);

    return hr;
}

LRESULT
CRealReplicaSetPropPage::OnInitDialog(
	IN UINT						i_uMsg,
	IN WPARAM					i_wParam,
	LPARAM						i_lParam,
	IN OUT BOOL&				io_bHandled
	)
{
    SetDlgItemText(IDC_FRSPROP_FILEFILTER, ((BSTR)m_bstrFileFilter) ? m_bstrFileFilter : _T(""));
    SetDlgItemText(IDC_FRSPROP_DIRFILTER, ((BSTR)m_bstrDirFilter) ? m_bstrDirFilter : _T(""));
    
    for (int i = 0; i < 4; i++)
    {
        if (!lstrcmpi(m_bstrTopologyPref, g_TopologyPref[i].pszTopologyPref))
        {
            CComBSTR bstrText;
            LoadStringFromResource(g_TopologyPref[i].nStringID, &bstrText);
            SetDlgItemText(IDC_FRSPROP_TOPOLOGYPREF, bstrText);
        }
    }

    if (0 != lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        MyShowWindow(GetDlgItem(IDC_FRSPROP_HUBSERVER_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_FRSPROP_HUBSERVER), FALSE);
    }

    HRESULT hr = S_OK;
    if (CheckPolicyOnDisplayingInitialMaster())
    {
        CComBSTR bstrPrimaryServer;
        hr = _GetMemberDNInfo(m_bstrPrimaryMemberDN, &bstrPrimaryServer);
        SetDlgItemText(IDC_FRSPROP_PRIMARYMEMBER, (S_OK == hr) ? bstrPrimaryServer : _T(""));
    } else
    {
        MyShowWindow(GetDlgItem(IDC_FRSPROP_PRIMARYMEMBER_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_FRSPROP_PRIMARYMEMBER), FALSE);
    }

    CComBSTR bstrHubServer;
    hr = _GetMemberDNInfo(m_bstrHubMemberDN, &bstrHubServer);
    SetDlgItemText(IDC_FRSPROP_HUBSERVER, (S_OK == hr) ? bstrHubServer : _T(""));

    if (m_lNumOfMembers < 2)
        ::EnableWindow(GetDlgItem(IDC_FRSPROP_CUSTOMIZE), FALSE);

    ::EnableWindow(GetDlgItem(IDC_FRSPROP_RESETSCHEDULE), (m_lNumOfConnections > 0));

    return TRUE;			// To let the dialg set the control
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CRealReplicaSetPropPage::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_PROP);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CRealReplicaSetPropPage::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_PROP);

    return TRUE;
}

void CRealReplicaSetPropPage::_Reset()
{
    m_piReplicaSet = NULL;

    m_bstrTopologyPref.Empty();
    m_bstrFileFilter.Empty();
    m_bstrDirFilter.Empty();
    m_bstrPrimaryMemberDN.Empty();
    m_bstrHubMemberDN.Empty();
}

HRESULT CRealReplicaSetPropPage::Initialize(IN IReplicaSet* i_piReplicaSet)
{
    RETURN_INVALIDARG_IF_NULL(i_piReplicaSet);

    _Reset();

    m_piReplicaSet = i_piReplicaSet;

    HRESULT hr = S_OK;

    do {
        hr = m_piReplicaSet->get_TopologyPref(&m_bstrTopologyPref);
        BREAK_IF_FAILED(hr);
        hr = m_piReplicaSet->get_FileFilter(&m_bstrFileFilter);
        BREAK_IF_FAILED(hr);
        hr = m_piReplicaSet->get_DirFilter(&m_bstrDirFilter);
        BREAK_IF_FAILED(hr);
        hr = m_piReplicaSet->get_PrimaryMemberDN(&m_bstrPrimaryMemberDN);
        BREAK_IF_FAILED(hr);
        hr = m_piReplicaSet->get_HubMemberDN(&m_bstrHubMemberDN);
        BREAK_IF_FAILED(hr);
        hr = m_piReplicaSet->get_NumOfMembers(&m_lNumOfMembers);
        BREAK_IF_FAILED(hr);
        hr = m_piReplicaSet->get_NumOfConnections(&m_lNumOfConnections);
        BREAK_IF_FAILED(hr);
    } while (0);

    if (FAILED(hr))
        _Reset();

    return hr;
}

LRESULT
CRealReplicaSetPropPage::OnApply()
{
    if (m_lNotifyHandle && m_lNotifyParam)
        MMCPropertyChangeNotify(m_lNotifyHandle, m_lNotifyParam);

    return TRUE;
}

LRESULT
CRealReplicaSetPropPage::OnEditFileFilter(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
    CComBSTR bstrFileFilter = m_bstrFileFilter;
    if (S_OK == InvokeMultiValuedStringEditDlg(
                    &bstrFileFilter, 
                    _T(","),
                    IDS_MVSTRINGEDIT_TITLE_FILEFILTER,
                    IDS_MVSTRINGEDIT_TEXT_FILEFILTER,
                    MAX_PATH))
    {
        CWaitCursor wait;
        if (FALSE == PROPSTRNOCHNG((BSTR)m_bstrFileFilter, bstrFileFilter))
        {
            HRESULT hr = m_piReplicaSet->put_FileFilter(bstrFileFilter);
            if (SUCCEEDED(hr))
            {
                m_bstrFileFilter = bstrFileFilter;
                SetDlgItemText(IDC_FRSPROP_FILEFILTER, m_bstrFileFilter);
            } else
            {
                DisplayMessageBoxForHR(hr);
            }
        }
    }

	return TRUE;
}

LRESULT
CRealReplicaSetPropPage::OnEditDirFilter(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
    CComBSTR bstrDirFilter = m_bstrDirFilter;
    if (S_OK == InvokeMultiValuedStringEditDlg(
                        &bstrDirFilter,
                        _T(","),
                        IDS_MVSTRINGEDIT_TITLE_DIRFILTER,
                        IDS_MVSTRINGEDIT_TEXT_DIRFILTER,
                        MAX_PATH))
    {
        CWaitCursor wait;
        if (FALSE == PROPSTRNOCHNG((BSTR)m_bstrDirFilter, bstrDirFilter))
        {
            HRESULT hr = m_piReplicaSet->put_DirFilter(bstrDirFilter);
            if (SUCCEEDED(hr))
            {
                m_bstrDirFilter = bstrDirFilter;
                SetDlgItemText(IDC_FRSPROP_DIRFILTER, m_bstrDirFilter);
            } else
            {
                DisplayMessageBoxForHR(hr);
            }
        }
    }

	return TRUE;
}

LRESULT
CRealReplicaSetPropPage::OnResetSchedule(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
    HRESULT hr = S_OK;

    do {
        CWaitCursor wait;

        //
        // get connection list
        //
        if (!m_lNumOfConnections)
            break; // no connection at all

        //
        // get FQDN of the first connection
        //
        CComBSTR bstrConnectionDN;

        VARIANT var;
        VariantInit(&var);
        hr = m_piReplicaSet->GetConnectionList(&var);
        BREAK_IF_FAILED(hr);

        if (V_VT(&var) == (VT_ARRAY | VT_VARIANT))
        {
            SAFEARRAY   *psa = V_ARRAY(&var);

            long    lLowerBound = 0;
            long    lUpperBound = 0;
            SafeArrayGetLBound(psa, 1, &lLowerBound);
            SafeArrayGetUBound(psa, 1, &lUpperBound);
            if (m_lNumOfConnections != (lUpperBound - lLowerBound + 1))
            {
                hr = E_INVALIDARG;
            } else
            {
                VARIANT HUGEP *pArray;
                SafeArrayAccessData(psa, (void HUGEP **) &pArray);

                if (V_VT(&(pArray[0])) != VT_BSTR)
                {
                    hr = E_INVALIDARG;
                } else
                {
                    bstrConnectionDN = pArray[0].bstrVal;
                    if (!bstrConnectionDN)
                        hr = E_OUTOFMEMORY;
                }

                SafeArrayUnaccessData(psa);
            }
        } else
        {
            hr = E_INVALIDARG;
        }

        VariantClear(&var);

        BREAK_IF_FAILED(hr);

        //
        // get schedule info on the first connection
        //
        SCHEDULE *pSchedule = NULL;
        VARIANT varSchedule;
        VariantInit(&varSchedule);
        hr = m_piReplicaSet->GetConnectionSchedule(bstrConnectionDN, &varSchedule);
        if (SUCCEEDED(hr))
        {
            hr = VariantToSchedule(&varSchedule, &pSchedule);

            VariantClear(&varSchedule);
        }
        BREAK_IF_FAILED(hr);

        //
        // invoke the schedule dialog
        //
        hr = InvokeScheduleDlg(m_hWnd, pSchedule);

        if (S_OK == hr)
        {
            CWaitCursor wait;

            //
            // update schedule on all connections
            //
            VARIANT varNewSchedule;
            VariantInit(&varNewSchedule);
            hr = ScheduleToVariant(pSchedule, &varNewSchedule);
            BREAK_IF_FAILED(hr);
            if (SUCCEEDED(hr))
            {
                hr = m_piReplicaSet->SetScheduleOnAllConnections(&varNewSchedule);

                VariantClear(&varNewSchedule);
            }
        }

        free(pSchedule);

    } while (0);

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

	return TRUE;
}

LRESULT
CRealReplicaSetPropPage::OnCustomize(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    CCustomTopology CusTopDlg;
    CusTopDlg.put_ReplicaSet(m_piReplicaSet);
    hr = CusTopDlg.DoModal();
    if (S_OK != hr)
        return hr;

    hr = m_piReplicaSet->get_NumOfConnections(&m_lNumOfConnections);
    RETURN_IF_FAILED(hr);
    ::EnableWindow(GetDlgItem(IDC_FRSPROP_RESETSCHEDULE), (m_lNumOfConnections > 0));

    m_bstrTopologyPref.Empty();
    hr = m_piReplicaSet->get_TopologyPref(&m_bstrTopologyPref);
    RETURN_IF_FAILED(hr);

    for (int i = 0; i < 4; i++)
    {
        if (!lstrcmpi(m_bstrTopologyPref, g_TopologyPref[i].pszTopologyPref))
        {
            CComBSTR bstrText;
            LoadStringFromResource(g_TopologyPref[i].nStringID, &bstrText);
            SetDlgItemText(IDC_FRSPROP_TOPOLOGYPREF, bstrText);
        }
    }
    if (0 != lstrcmpi(m_bstrTopologyPref, FRS_RSTOPOLOGYPREF_HUBSPOKE))
    {
        MyShowWindow(GetDlgItem(IDC_FRSPROP_HUBSERVER_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_FRSPROP_HUBSERVER), FALSE);
    } else
    {
        MyShowWindow(GetDlgItem(IDC_FRSPROP_HUBSERVER_LABEL), TRUE);
        MyShowWindow(GetDlgItem(IDC_FRSPROP_HUBSERVER), TRUE);
    }

    m_bstrHubMemberDN.Empty();
    hr = m_piReplicaSet->get_HubMemberDN(&m_bstrHubMemberDN);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrHubServer;
    hr = _GetMemberDNInfo(m_bstrHubMemberDN, &bstrHubServer);
    SetDlgItemText(IDC_FRSPROP_HUBSERVER, (S_OK == hr) ? bstrHubServer : _T(""));

	return TRUE;
}

LRESULT
CRealReplicaSetPropPage::OnParentClosing(
	IN UINT							i_uMsg,
	IN WPARAM						i_wParam,
	LPARAM							i_lParam,
	IN OUT BOOL&					io_bHandled
	)
{
	::SendMessage(GetParent(), PSM_PRESSBUTTON, PSBTN_CANCEL, 0);

	return TRUE;
}

HRESULT
CRealReplicaSetPropPage::SetNotifyData(
	IN LONG_PTR						i_lNotifyHandle,
	IN LPARAM						i_lParam
	)
{
	m_lNotifyHandle = i_lNotifyHandle;
	m_lNotifyParam = i_lParam;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\frsadv.cpp ===
/*++
Module Name:

    frsAdv.cpp

Abstract:

    This module contains the Implementation of CFRSAdvanced.
    This class displays the FRS Advanced Dialog.

*/

#include "stdafx.h"
#include "frsAdv.h"
#include "utils.h"
#include "dfshelp.h"
#include "ldaputils.h"
#include <htmlhelp.h>

int g_FRS_ADVANCED_Last_SortColumn = 1;
#define NUM_OF_FRS_ADVANCED_COLUMNS   4

/////////////////////////////////////////////////////////////////////////////
//
// CFRSAdvanced
//

CFRSAdvanced::CFRSAdvanced() :
    m_pMemberList(NULL),
    m_pConnectionList(NULL),
    m_pFrsAdvConnection(NULL)
{
}

CFRSAdvanced::~CFRSAdvanced()
{
    if (m_pFrsAdvConnection)
        free(m_pFrsAdvConnection);
}

LRESULT CFRSAdvanced::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    int nControlID = 0;

    //
    // set columns of the inbound connections list box
    //
    nControlID = IDC_FRS_ADVANCED_INBOUND_CONNS;
    HWND hwndControl = GetDlgItem(nControlID);
    AddLVColumns(hwndControl, IDS_FRS_ADVANCED_COL_SYNC, NUM_OF_FRS_ADVANCED_COLUMNS);
    ListView_SetExtendedListViewStyle(hwndControl, LVS_EX_FULLROWSELECT | LVS_EX_CHECKBOXES);

    //
    // insert the new priority combobox
    //
    nControlID = IDC_FRS_ADVANCED_NEW_PRIORITY;
    int i = 0;
    SendDlgItemMessage(nControlID, CB_INSERTSTRING, i++, (LPARAM)_T(""));
    SendDlgItemMessage(nControlID, CB_INSERTSTRING, i++, (LPARAM)(BSTR)m_bstrPriorityHigh);
    SendDlgItemMessage(nControlID, CB_INSERTSTRING, i++, (LPARAM)(BSTR)m_bstrPriorityMedium);
    SendDlgItemMessage(nControlID, CB_INSERTSTRING, i, (LPARAM)(BSTR)m_bstrPriorityLow);
    SendDlgItemMessage(nControlID, CB_SETCURSEL, 0, 0);

    //
    // insert server combobox
    //
    nControlID = IDC_FRS_ADVANCED_SERVER;
    hwndControl = GetDlgItem(nControlID);
    int index = 0;
    CCusTopMemberList::iterator itMem;
    for (i = 0, itMem = m_pMemberList->begin(); itMem != m_pMemberList->end(); i++, itMem++)
    {
        SendDlgItemMessage(nControlID, CB_INSERTSTRING, i, (LPARAM)(BSTR)(*itMem)->m_bstrServer);
        if (!lstrcmpi(m_bstrToServer, (*itMem)->m_bstrServer))
            index = i;
    }

    //
    // select the proper server
    //
    SendDlgItemMessage(nControlID, CB_SETCURSEL, index, 0);

    // has to send CBN_SELCHANGE message because it is not sent when 
    // the current selection is set using the CB_SETCURSEL message. 
    SendNotifyMessage(WM_COMMAND, MAKEWPARAM(nControlID, CBN_SELCHANGE), (LPARAM)hwndControl);

    ::SetFocus(GetDlgItem(IDC_FRS_ADVANCED_SERVER));

    return FALSE;  // Set focus to the combo box
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CFRSAdvanced::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_ADVANCED);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CFRSAdvanced::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FRS_ADVANCED);

    return TRUE;
}

HRESULT CFRSAdvanced::_InsertConnection(FRSADV_CONNECTION *pFrsAdvConn)
{
    RETURN_INVALIDARG_IF_NULL(pFrsAdvConn);

    HWND hwndControl = GetDlgItem(IDC_FRS_ADVANCED_INBOUND_CONNS);

    LVITEM  lvItem;

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam = (LPARAM)pFrsAdvConn;
    lvItem.pszText = _T("");
    lvItem.iSubItem = 0;
    int iItemIndex = ListView_InsertItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pFrsAdvConn->pConn->m_bstrFromServer;
    lvItem.iSubItem = 1;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.pszText = pFrsAdvConn->pConn->m_bstrFromSite;
    lvItem.iSubItem = 2;
    ListView_SetItem(hwndControl, &lvItem);

    lvItem.mask = LVIF_TEXT;
    lvItem.iItem = iItemIndex;
    lvItem.iSubItem = 3;

    switch (pFrsAdvConn->nPriority)
    {
    case PRIORITY_HIGH:
        lvItem.pszText = m_bstrPriorityHigh;
        break;
    case PRIORITY_MEDIUM:
        lvItem.pszText = m_bstrPriorityMedium;
        break;
    default:
        lvItem.pszText = m_bstrPriorityLow;
        break;
    }

    ListView_SetItem(hwndControl, &lvItem);

    ListView_SetCheckState(hwndControl, iItemIndex, pFrsAdvConn->bSyncImmediately);

    ListView_Update(hwndControl, iItemIndex);

    return S_OK;
}

void CFRSAdvanced::_SaveCheckStateOnConnections()
{
    HWND hwnd = GetDlgItem(IDC_FRS_ADVANCED_INBOUND_CONNS);
    FRSADV_CONNECTION *pFrsAdvConn = NULL;

    int  nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
    {
        if (pFrsAdvConn = (FRSADV_CONNECTION *)GetListViewItemData(hwnd, nIndex))
        {
            pFrsAdvConn->bSyncImmediately = ListView_GetCheckState(hwnd, nIndex);
        }
    }
}

LRESULT CFRSAdvanced::OnServer
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    if (CBN_SELCHANGE != wNotifyCode)
        return 0;

    HWND hwnd = GetDlgItem(IDC_FRS_ADVANCED_INBOUND_CONNS);

    // reset the site, inbound connections listbox, and the new priority field
    SetDlgItemText(IDC_FRS_ADVANCED_SITE, _T(""));

    _SaveCheckStateOnConnections();

    ListView_DeleteAllItems(hwnd);

    SendDlgItemMessage(IDC_FRS_ADVANCED_NEW_PRIORITY, CB_SETCURSEL, 0, 0);
    // has to send CBN_SELCHANGE message because it is not sent when 
    // the current selection is set using the CB_SETCURSEL message. 
    SendNotifyMessage(WM_COMMAND,
                    MAKEWPARAM(IDC_FRS_ADVANCED_NEW_PRIORITY, CBN_SELCHANGE), 
                    (LPARAM)GetDlgItem(IDC_FRS_ADVANCED_NEW_PRIORITY));

    // get the current selected server
    int     index = SendDlgItemMessage(IDC_FRS_ADVANCED_SERVER, CB_GETCURSEL, 0, 0);
    int     len = SendDlgItemMessage(IDC_FRS_ADVANCED_SERVER, CB_GETLBTEXTLEN, index, 0);
    PTSTR   pszServer = (PTSTR)calloc(len + 1, sizeof(TCHAR));
    if (!pszServer)
    {
        DisplayMessageBoxForHR(E_OUTOFMEMORY);
        return 0;
    }

    SendDlgItemMessage(IDC_FRS_ADVANCED_SERVER, CB_GETLBTEXT, index, (LPARAM)pszServer);

    for (CCusTopMemberList::iterator it = m_pMemberList->begin(); it != m_pMemberList->end(); it++)
    {
        if (!lstrcmpi(pszServer, (*it)->m_bstrServer))
        {
            SetDlgItemText(IDC_FRS_ADVANCED_SITE, (*it)->m_bstrSite);
            break;
        }
    }

    int i = 0;
    for (i = 0; i < m_cConns; i++)
    {
        if (!lstrcmpi(pszServer, (m_pFrsAdvConnection + i)->pConn->m_bstrToServer))
        {
            // insert this inbound connection into the listbox
            _InsertConnection(m_pFrsAdvConnection + i);
        }
    }

    free(pszServer);

    ListView_SortItems( hwnd,
                        InboundConnectionsListCompareProc,
                        (LPARAM)g_FRS_ADVANCED_Last_SortColumn);
/*
    UINT uiState = ListView_GetItemState(hwnd, 0, LVIS_STATEIMAGEMASK);

    ListView_SetItemState(hwnd, 0, uiState | LVIS_SELECTED | LVIS_FOCUSED, 0xffffffff);

    // has to send LVN_ITEMCHANGED message. 
    NMHDR nmhdr = {hwnd, IDC_FRS_ADVANCED_INBOUND_CONNS, LVN_ITEMCHANGED};
    SendNotifyMessage(WM_NOTIFY,
                    (WPARAM)IDC_FRS_ADVANCED_INBOUND_CONNS,
                    (LPARAM)&nmhdr);
*/
    return 1;
}

LRESULT CFRSAdvanced::OnNewPriority
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    if (CBN_SELCHANGE != wNotifyCode)
        return 0;

    // get the current selected new priority
    int     index = SendDlgItemMessage(IDC_FRS_ADVANCED_NEW_PRIORITY, CB_GETCURSEL, 0, 0);

    ::EnableWindow(GetDlgItem(IDC_FRS_ADVANCED_CHANGE), index);

    switch (index)
    {
    case 1:
        SetDlgItemText(IDC_FRS_ADVANCED_NEW_PRIORITY_DESC, m_bstrPriorityHighDesc);
        break;
    case 2:
        SetDlgItemText(IDC_FRS_ADVANCED_NEW_PRIORITY_DESC, m_bstrPriorityMediumDesc);
        break;
    case 3:
        SetDlgItemText(IDC_FRS_ADVANCED_NEW_PRIORITY_DESC, m_bstrPriorityLowDesc);
        break;
    default:
        SetDlgItemText(IDC_FRS_ADVANCED_NEW_PRIORITY_DESC, _T(""));
        break;
    }

    return 1;
}

LRESULT CFRSAdvanced::OnChange
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    LVITEM lvItem;
    ZeroMemory(&lvItem, sizeof(LVITEM));

    lvItem.mask = LVIF_TEXT;
    lvItem.iSubItem = 3;

    Connection_Priority nNewPriority = PRIORITY_LOW;
    int   index = SendDlgItemMessage(IDC_FRS_ADVANCED_NEW_PRIORITY, CB_GETCURSEL, 0, 0);
    switch (index)
    {
    case 1:
        lvItem.pszText = m_bstrPriorityHigh;
        nNewPriority = PRIORITY_HIGH;
        break;
    case 2:
        lvItem.pszText = m_bstrPriorityMedium;
        nNewPriority = PRIORITY_MEDIUM;
        break;
    case 3:
        lvItem.pszText = m_bstrPriorityLow;
        nNewPriority = PRIORITY_LOW;
        break;
    default:
        return 1;
    }

    HWND hwnd = GetDlgItem(IDC_FRS_ADVANCED_INBOUND_CONNS);
    FRSADV_CONNECTION * pFrsAdvConn = NULL;
    int  nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL | LVNI_SELECTED)))
    {
        if (pFrsAdvConn = (FRSADV_CONNECTION *)GetListViewItemData(hwnd, nIndex))
        {
            pFrsAdvConn->nPriority = nNewPriority;

            lvItem.iItem = nIndex;
            ListView_SetItem(hwnd, &lvItem);
            ListView_Update(hwnd, nIndex);
        }
    }

    return 1;
}

LRESULT CFRSAdvanced::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CWaitCursor wait;

    _SaveCheckStateOnConnections();

    int i = 0;
    for (i = 0; i < m_cConns; i++)
    {
        (m_pFrsAdvConnection + i)->pConn->m_bSyncImmediatelyNew = (m_pFrsAdvConnection + i)->bSyncImmediately;
        (m_pFrsAdvConnection + i)->pConn->m_nPriorityNew = (m_pFrsAdvConnection + i)->nPriority;
    }

    EndDialog(S_OK);
    return TRUE;
}

LRESULT CFRSAdvanced::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
/*++

Routine Description:

  Called OnCancel. Ends the dialog with S_FALSE;

*/
  EndDialog(S_FALSE);
  return(true);
}

LRESULT
CFRSAdvanced::OnNotify(
  IN UINT            i_uMsg,
  IN WPARAM          i_wParam,
  IN LPARAM          i_lParam,
  IN OUT BOOL&       io_bHandled
  )
{
    NM_LISTVIEW*    pNMListView = (NM_LISTVIEW*)i_lParam;
    io_bHandled = FALSE; // So that the base class gets this notify too

    HWND hwndList = GetDlgItem(IDC_FRS_ADVANCED_INBOUND_CONNS);

    if (IDC_FRS_ADVANCED_EXPLANATION == pNMListView->hdr.idFrom)
    {
        if (NM_CLICK == pNMListView->hdr.code ||
            NM_RETURN == pNMListView->hdr.code)
        {
            CWaitCursor wait;

            ::HtmlHelp(0, _T("dfconcepts.chm"), HH_DISPLAY_TOPIC, 
                (DWORD_PTR)(_T("sag_DFconceptsFRSPriorities.htm")));
        }

        return io_bHandled;
    }

    if (IDC_FRS_ADVANCED_INBOUND_CONNS == pNMListView->hdr.idFrom)
    {
        if (LVN_COLUMNCLICK == pNMListView->hdr.code)
        {
            // sort items
            ListView_SortItems( hwndList,
                                InboundConnectionsListCompareProc,
                                (LPARAM)(pNMListView->iSubItem));
            io_bHandled = TRUE;
        } else if (LVN_ITEMCHANGED == pNMListView->hdr.code)
        {
            UINT cSelected = ListView_GetSelectedCount(hwndList);

            // update New Priority field
            int n = 0;
            if (1 == cSelected)
            {
                FRSADV_CONNECTION *pFrsAdvConn = NULL;
                int nIndex = ListView_GetNextItem(hwndList, -1, LVNI_ALL | LVNI_SELECTED);
                if (-1 != nIndex &&
                    (pFrsAdvConn = (FRSADV_CONNECTION *)GetListViewItemData(hwndList, nIndex)))
                {
                    switch (pFrsAdvConn->nPriority)
                    {
                    case PRIORITY_LOW:
                        n = 3;  // low
                        break;
                    case PRIORITY_MEDIUM:
                        n = 2;  // Medium;
                        break;
                    default:
                        n = 1;  // High;
                        break;
                    }
                }
            }

            SendDlgItemMessage(IDC_FRS_ADVANCED_NEW_PRIORITY, CB_SETCURSEL, n, 0);

            // has to send CBN_SELCHANGE message because it is not sent when 
            // the current selection is set using the CB_SETCURSEL message. 
            SendNotifyMessage(WM_COMMAND,
                            MAKEWPARAM(IDC_FRS_ADVANCED_NEW_PRIORITY, CBN_SELCHANGE), 
                            (LPARAM)GetDlgItem(IDC_FRS_ADVANCED_NEW_PRIORITY));

            ::EnableWindow(GetDlgItem(IDC_FRS_ADVANCED_NEW_PRIORITY), cSelected > 0);
        }
    }

    return io_bHandled;
}

HRESULT CFRSAdvanced::Initialize(
    CCusTopMemberList*      i_pMemberList,
    CCusTopConnectionList*  i_pConnectionList,
    LPCTSTR                 i_pszToServer /* = NULL */)
{
    if (!i_pMemberList || !i_pConnectionList)
        return E_INVALIDARG;

    m_pMemberList = i_pMemberList;

    m_pConnectionList = i_pConnectionList;

    // we deal with only the connections that appear in the list box of the CustomTopology dialog, which
    // is a subset of i_pConnectionList.
    m_cConns = 0;
    CCusTopConnectionList::iterator it;
    for (it = m_pConnectionList->begin(); it != m_pConnectionList->end(); it++)
    {
        if ((*it)->m_opType != CONNECTION_OPTYPE_DEL)
            m_cConns++;
    }

    if (0 == m_cConns)
        return E_INVALIDARG; // shouldn't happen since Advanced button should have been disabled

    if (m_pFrsAdvConnection)
        free(m_pFrsAdvConnection);
    m_pFrsAdvConnection = (FRSADV_CONNECTION *)calloc(m_cConns, sizeof(FRSADV_CONNECTION));
    if (!m_pFrsAdvConnection)
        return E_OUTOFMEMORY;

    int i = 0;
    for (it = m_pConnectionList->begin(); it != m_pConnectionList->end(); it++)
    {
        if ((*it)->m_opType != CONNECTION_OPTYPE_DEL)
        {
            (m_pFrsAdvConnection + i)->pConn = (*it);
            (m_pFrsAdvConnection + i)->bSyncImmediately = (*it)->m_bSyncImmediatelyNew;
            (m_pFrsAdvConnection + i)->nPriority = (*it)->m_nPriorityNew;
            i++;
        }
    }

    if (i_pszToServer && *i_pszToServer)
        m_bstrToServer = i_pszToServer;
    else
        m_bstrToServer = _T("");

    LoadStringFromResource(IDS_FRS_ADVANCED_PRIORITY_HIGH, &m_bstrPriorityHigh);
    LoadStringFromResource(IDS_FRS_ADVANCED_PRIORITY_MEDIUM, &m_bstrPriorityMedium);
    LoadStringFromResource(IDS_FRS_ADVANCED_PRIORITY_LOW, &m_bstrPriorityLow);

    LoadStringFromResource(IDS_FRS_ADVANCED_PRIORITY_HIGH_DESC, &m_bstrPriorityHighDesc);
    LoadStringFromResource(IDS_FRS_ADVANCED_PRIORITY_MEDIUM_DESC, &m_bstrPriorityMediumDesc);
    LoadStringFromResource(IDS_FRS_ADVANCED_PRIORITY_LOW_DESC, &m_bstrPriorityLowDesc);

    return S_OK;
}

int CALLBACK InboundConnectionsListCompareProc(
    IN LPARAM lParam1,
    IN LPARAM lParam2,
    IN LPARAM lParamColumn)
{
  FRSADV_CONNECTION* pItem1 = (FRSADV_CONNECTION *)lParam1;
  FRSADV_CONNECTION* pItem2 = (FRSADV_CONNECTION *)lParam2;
  int iResult = 0;

  if (pItem1 && pItem2)
  {
    g_FRS_ADVANCED_Last_SortColumn = lParamColumn;

    switch (lParamColumn)
    {
    case 0:     // Sort by bSyncImmediately.
      iResult = pItem1->bSyncImmediately - pItem2->bSyncImmediately;
      break;
    case 1:     // Sort by From Server.
      iResult = lstrcmpi(pItem1->pConn->m_bstrFromServer, pItem2->pConn->m_bstrFromServer);
      break;
    case 2:     // Sort by From Site.
      iResult = lstrcmpi(pItem1->pConn->m_bstrFromSite, pItem2->pConn->m_bstrFromSite);
      break;
    case 3:     // Sort by Priority
      iResult = pItem1->nPriority - pItem2->nPriority;
      break;
    default:
      iResult = 0;
      break;
    }
  }

  return(iResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\ictxmenu.cpp ===
/*++
Module Name:

    IctxMenu.cpp

Abstract:

    This module contains the implementation for CDfsSnapinScopeManager. 
	Contains the methods of Interface IExtendContextMenu

--*/


#include "stdafx.h"
#include "DfsGUI.h"
#include "MmcDispl.h"		// For CMmcDisplay
#include "DfsScope.h"




STDMETHODIMP 
CDfsSnapinScopeManager::AddMenuItems(
	IN LPDATAOBJECT					i_lpDataObject, 
	IN LPCONTEXTMENUCALLBACK		i_lpContextMenuCallback, 
	IN LPLONG						i_lpInsertionAllowed
	)
/*++

Routine Description:

	Calls the appropriate handler to add the context menu.

Arguments:

	i_lpDataObject			-	Pointer to the IDataObject that identifies the node to which 
								the menu must be added.

    i_lpContextMenuCallback -	A callback(function pointer) that is used to add the menu items

    i_lpInsertionAllowed	-	Specifies what menus can be added and where they can be added.

Return value:

	S_OK, On success
	E_INVALIDARG, On incorrect input parameters
	HRESULT sent by methods called, if it is not S_OK.
	E_UNEXPECTED, on other errors.
--*/
{
	RETURN_INVALIDARG_IF_NULL(i_lpDataObject);
    RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);
	RETURN_INVALIDARG_IF_NULL(i_lpInsertionAllowed);


    HRESULT					hr = E_UNEXPECTED;
	CMmcDisplay*			pCMmcDisplayObj = NULL;


	hr = GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
	RETURN_IF_FAILED(hr);


	// Use the virtual method AddMenus in the display object
	hr = pCMmcDisplayObj->AddMenuItems(i_lpContextMenuCallback, i_lpInsertionAllowed);
	RETURN_IF_FAILED(hr);

	return S_OK;
}




STDMETHODIMP 
CDfsSnapinScopeManager :: Command(
	IN LONG						i_lCommandID, 
	IN LPDATAOBJECT				i_lpDataObject
	)
/*++

Routine Description:

	Use to take action on a menu click or menu command.

Arguments:

	i_lCommandID			-	Used to identify which menu was clicked
	i_lpDataObject			-	Pointer to the IDataObject that identifies the node to which 
								the menu belongs.
--*/
{
	RETURN_INVALIDARG_IF_NULL(i_lpDataObject);


    HRESULT					hr = E_UNEXPECTED;
	CMmcDisplay*			pCMmcDisplayObj = NULL;



	hr = GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
	RETURN_IF_FAILED(hr);


	// Use the virtual method Command in the display object
	hr = pCMmcDisplayObj->Command(i_lCommandID);
	RETURN_IF_FAILED(hr);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\icomdata.cpp ===
/*++
Module Name:

    IComData.cpp

Abstract:

    This module contains the implementation for CDfsSnapinScopeManager.
  This class implements IComponentData and other related interfaces

--*/



#include "stdafx.h"

#include "DfsGUI.h"
#include "DfsScope.h"
#include "MmcDispl.h"
#include "DfsReslt.h"
#include "Utils.h"
#include "DfsNodes.h"


STDMETHODIMP 
CDfsSnapinScopeManager::Initialize(
  IN LPUNKNOWN      i_pUnknown
  )
/*++

Routine Description:

  Initialize the IComponentData interface.
  The variables needed later are QI'ed now

Arguments:

  i_pUnknown  - Pointer to the unknown object of IConsole2.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pUnknown);

    HRESULT hr = i_pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
    RETURN_IF_FAILED(hr);

    hr = m_pMmcDfsAdmin->PutConsolePtr(m_pConsole);
    RETURN_IF_FAILED(hr);

    hr = i_pUnknown->QueryInterface(IID_IConsoleNameSpace, reinterpret_cast<void**>(&m_pScope));
    RETURN_IF_FAILED(hr);

    // The snap-in should also call IConsole2::QueryScopeImageList
    // to get the image list for the scope pane and add images 
    // to be displayed on the scope pane side.
    CComPtr<IImageList>    pScopeImageList;
    hr = m_pConsole->QueryScopeImageList(&pScopeImageList);
    RETURN_IF_FAILED(hr);

    HBITMAP pBMapSm = NULL;
    HBITMAP pBMapLg = NULL;
    if (!(pBMapSm = LoadBitmap(_Module.GetModuleInstance(),
                               MAKEINTRESOURCE(IDB_SCOPE_IMAGES_16x16))) ||
        !(pBMapLg = LoadBitmap(_Module.GetModuleInstance(),
                                MAKEINTRESOURCE(IDB_SCOPE_IMAGES_32x32))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    } else
    {
        hr = pScopeImageList->ImageListSetStrip(
                             (LONG_PTR *)pBMapSm,
                             (LONG_PTR *)pBMapLg,
                             0,
                             RGB(255, 0, 255)
                             );
    }
    if (pBMapSm)
        DeleteObject(pBMapSm);
    if (pBMapLg)
        DeleteObject(pBMapLg);

    return hr;
}


STDMETHODIMP 
CDfsSnapinScopeManager::CreateComponent(
  OUT LPCOMPONENT*      o_ppComponent
  )
/*++

Routine Description:

  Creates the IComponent object  
  

Arguments:

  o_ppComponent  -  Pointer to the object in which the pointer to IComponent object
            is stored.

--*/
{
  RETURN_INVALIDARG_IF_NULL(o_ppComponent);
  
  CComObject<CDfsSnapinResultManager>*  pResultManager;
  CComObject<CDfsSnapinResultManager>::CreateInstance(&pResultManager);
  if (NULL == pResultManager)
  {
    return(E_FAIL);
  }
  
  pResultManager->m_pScopeManager = this;

  HRESULT hr = pResultManager->QueryInterface(IID_IComponent, (void**) o_ppComponent);
  _ASSERT(NULL != *o_ppComponent);
  
  return hr;
}




STDMETHODIMP 
CDfsSnapinScopeManager::Notify(
    IN LPDATAOBJECT     i_lpDataObject, 
    IN MMC_NOTIFY_TYPE  i_Event, 
    IN LPARAM           i_lArg, 
    IN LPARAM           i_lParam
  )
/*++

Routine Description:

  Handles different events in form of notify
  

Arguments:

  i_lpDataObject  -  The data object for the node for which the event occured
  i_Event      -  The type of event for which notify has occurred
  i_lArg      -  Argument for the event
  i_lParam    -  Parameters for the event.

--*/
{
    // The snap-in should return S_FALSE for any notification it does not handle. 
    // MMC then performs a default operation for the notification. 
    HRESULT hr = S_FALSE;
  
    switch(i_Event)
    {
    case MMCN_EXPAND:
        {
            // MMC sends the MMCN_EXPAND notification the first time it needs to display a 
            // scope item's children in either the scope or result pane. The notification 
            // is not sent each time the item is visually expanded or collapsed. 
            // On receipt of this notification the snap-in should enumerate the children 
            // (subcontainers only) of the specified scope item, if any, using 
            // IConsoleNameSpace2 methods. Subsequently, if a new item is added to or deleted 
            // from this scope object through some external means, that item should also be 
            // added to or deleted from the console's namespace using IConsoleNameSpace2 methods.

            // lpDataObject: [in] Pointer to the data object of the scope item that needs 
            //               to be expanded or collapsed. 
            // arg: [in] TRUE if the folder is being expanded; FALSE if the folder is being collapsed. 
            // param: [in] The HSCOPEITEM of the item that needs to be expanded or collapsed. 

            hr = DoNotifyExpand(i_lpDataObject, (BOOL)i_lArg, (HSCOPEITEM)i_lParam);
            break;
        }

    case MMCN_DELETE:
        {
            // This message is generated when the user presses the delete key or uses the 
            // mouse to click the toolbar's delete button.
            // The snap-in should delete the items specified in the data object.

            // lpDataObject: [in] Pointer to the data object of the currently selected scope
            //               or result item, provided by the snap-in. 
            // arg: Not used. 
            // param: Not used. 

            CMmcDisplay*    pCMmcDisplayObj = NULL;
            hr = GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
            if (SUCCEEDED(hr))
                hr = pCMmcDisplayObj->DoDelete();  // Delete the the item.
            break;
        }
    case MMCN_PROPERTY_CHANGE:      // Handle the property change
        {
            // i_lpDataObject is NULL because a data object is not required. 
            // i_lArg is TRUE if the property change is for a scope item. 
            // i_lParam is the param passed to MMCPropertyChangeNotify, this is the display object.

            hr = ((CMmcDisplay*)i_lParam)->PropertyChanged();
            break;
        }

    default:
        break;
    }

    return hr;
}




STDMETHODIMP 
CDfsSnapinScopeManager::DoNotifyExpand(
    IN LPDATAOBJECT     i_lpDataObject, 
    IN BOOL             i_bExpanding,
    IN HSCOPEITEM       i_hParent                     
)
/*++

Routine Description:

Take action on Notify with the event MMCN_EXPAND.


Arguments:

    i_lpDataObject  -  The IDataObject pointer which is used to get the DisplayObject.

  i_bExpanding  -  TRUE, if the node is expanding. FALSE otherwise

  i_hParent    -  HSCOPEITEM of the node that received this event
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpDataObject);

    if (!i_bExpanding)
        return S_OK;

    CWaitCursor     WaitCursor;

    CMmcDisplay*    pCMmcDisplayObj = NULL;
    HRESULT         hr = GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);

    if (SUCCEEDED(hr))
        hr = pCMmcDisplayObj->EnumerateScopePane(m_pScope, i_hParent);

    return hr;
}





STDMETHODIMP 
CDfsSnapinScopeManager::Destroy()
/*++

Routine Description:

  The IComponentData object is about to be destroyed. Explicitely release all interface pointers,
  otherwise, MMC may not call the destructor.

Arguments:

  None.

--*/
{
    // The snap-in is in the process of being unloaded. Release all references to the console.
    m_pScope.Release();
    m_pConsole.Release();

    return S_OK;
}




STDMETHODIMP 
CDfsSnapinScopeManager::QueryDataObject(
    IN MMC_COOKIE           i_lCookie, 
    IN DATA_OBJECT_TYPES    i_DataObjectType, 
    OUT LPDATAOBJECT*       o_ppDataObject
)
/*++

Routine Description:

  Returns the IDataObject for the specified node.
  

Arguments:

  i_lCookie      -  This parameter identifies the node for which IDataObject is 
              being queried.
  i_DataObjectType  -  The context in which the IDataObject is being queried. 
              Eg., Result or Scope or Snapin(Node) Manager.
  o_ppDataObject    -  The data object will be returned in this pointer.

--*/
{
    RETURN_INVALIDARG_IF_NULL(o_ppDataObject);

    // We get back the cookie we stored in lparam of the scopeitem.
    // The cookie is the MmcDisplay pointer.
    // For the static(root) node, Use m_pMmcDfsAdmin as no lparam is stored.
    CMmcDisplay* pMmcDisplay = ((0 == i_lCookie)? (CMmcDisplay *)m_pMmcDfsAdmin : (CMmcDisplay *)i_lCookie);

    pMmcDisplay->put_CoClassCLSID(CLSID_DfsSnapinScopeManager);

    return pMmcDisplay->QueryInterface(IID_IDataObject, (void **)o_ppDataObject);
}




STDMETHODIMP 
CDfsSnapinScopeManager::GetDisplayInfo(
    IN OUT SCOPEDATAITEM*   io_pScopeDataItem
)       
/*++

Routine Description:

  Retrieves display information for a scope item.

Arguments:

  io_pScopeDataItem  -  Contains details about what information is being asked for.
              The information being asked is returned in this object itself.

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pScopeDataItem);

    // This (cookie) is null for static node.
    // Static node display name is returned through IDataObject Clipboard.
    if (NULL == io_pScopeDataItem->lParam)
        return(S_OK);

    return ((CMmcDisplay*)(io_pScopeDataItem->lParam))->GetScopeDisplayInfo(io_pScopeDataItem);
}




STDMETHODIMP 
CDfsSnapinScopeManager::CompareObjects(
    IN LPDATAOBJECT lpDataObjectA, 
    IN LPDATAOBJECT lpDataObjectB
)
/*++
Routine Description:
    The method enables a snap-in to compare two data objects acquired through QueryDataObject. 

Return Values:
    S_OK: The data objects represented by lpDataObjectA and lpDataObjectB are the same. 
    S_FALSE: The data objects represented by lpDataObjectA and lpDataObjectB are not the same. 
--*/

{
    if (lpDataObjectA == lpDataObjectB)
        return S_OK;

    if (!lpDataObjectA || !lpDataObjectB)
        return S_FALSE;

    FORMATETC fmte = {CMmcDisplay::mMMC_CF_Dfs_Snapin_Internal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {TYMED_HGLOBAL, NULL, NULL};

    medium.hGlobal = ::GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE | GMEM_NODISCARD, (sizeof(ULONG_PTR)));
    if (medium.hGlobal == NULL)
        return STG_E_MEDIUMFULL;

    HRESULT hr = lpDataObjectA->GetDataHere(&fmte, &medium);
    RETURN_IF_FAILED(hr);  

    ULONG_PTR* pulVal = (ULONG_PTR*)(GlobalLock(medium.hGlobal));
    CMmcDisplay* pMmcDisplayA = reinterpret_cast<CMmcDisplay *>(*pulVal);
    GlobalUnlock(medium.hGlobal);

    hr = lpDataObjectB->GetDataHere(&fmte, &medium);
    RETURN_IF_FAILED(hr);  

    pulVal = (ULONG_PTR*)(GlobalLock(medium.hGlobal));
    CMmcDisplay* pMmcDisplayB = reinterpret_cast<CMmcDisplay *>(*pulVal);
    GlobalUnlock(medium.hGlobal);

    GlobalFree(medium.hGlobal);

    return ((pMmcDisplayA == pMmcDisplayB) ? S_OK : S_FALSE);
}




STDMETHODIMP 
CDfsSnapinScopeManager::GetDisplayObject(
    IN LPDATAOBJECT     i_lpDataObject, 
    OUT CMmcDisplay**   o_ppMmcDisplay
)
/*++

Routine Description:

Get the Display Object from the IDataObject. This is a derived object that is used for a 
lot of purposes


Arguments:

  i_lpDataObject  -  The IDataObject pointer which is used to get the DisplayObject.
  o_ppMmcDisplay  -  The MmcDisplayObject written by us. Used as a callback for Mmc
            related display operations.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpDataObject);
    RETURN_INVALIDARG_IF_NULL(o_ppMmcDisplay);


    FORMATETC fmte = {CMmcDisplay::mMMC_CF_Dfs_Snapin_Internal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {TYMED_HGLOBAL, NULL, NULL};

    medium.hGlobal = ::GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE | GMEM_NODISCARD, (sizeof(ULONG_PTR)));
    if (medium.hGlobal == NULL)
        return STG_E_MEDIUMFULL;

    HRESULT hr = i_lpDataObject->GetDataHere(&fmte, &medium);

    if (SUCCEEDED(hr))
    {
        ULONG_PTR* pulVal = (ULONG_PTR*)(GlobalLock(medium.hGlobal));
        *o_ppMmcDisplay = reinterpret_cast<CMmcDisplay *>(*pulVal);
        GlobalUnlock(medium.hGlobal);
    }

    GlobalFree(medium.hGlobal);  

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\jpprop.h ===
/*++
Module Name:

    JPProp.h

Abstract:

    This module contains the declaration for CReplicaSetPropPage
  This is used to implement the property page for Junction Point(aka Replica Set)

--*/


#ifndef __CREPLICA_SET_PROPPAGE_H_
#define __CREPLICA_SET_PROPPAGE_H_


#include "qwizpage.h"      // The base class that implements the common functionality  
                // of property and wizard pages
#include "DfsCore.h"

#define WM_SETPAGEFOCUS WM_APP+2


// ----------------------------------------------------------------------------
// CReplicaSetPropPage: Property Sheet Page for the Junction Point(Replica Set)

class CReplicaSetPropPage : public CQWizardPageImpl<CReplicaSetPropPage>
{
public:
  enum { IDD = IDD_JP_PROP };
  
  BEGIN_MSG_MAP(CReplicaSetPropPage)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_SETPAGEFOCUS, OnSetPageFocus)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    MESSAGE_HANDLER(WM_PARENT_NODE_CLOSING, OnParentClosing)
    COMMAND_ID_HANDLER(IDC_REPLICA_SET_COMMENT, OnComment)
    COMMAND_ID_HANDLER(IDC_REFFERAL_TIME, OnReferralTime)

    CHAIN_MSG_MAP(CQWizardPageImpl<CReplicaSetPropPage>)
  END_MSG_MAP()

  
  CReplicaSetPropPage(
    );


  ~CReplicaSetPropPage(
    );

  LRESULT OnInitDialog(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    LPARAM          i_lParam, 
    IN OUT BOOL&      io_bHandled
    );

  LRESULT OnCtxHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  LRESULT OnCtxMenuHelp(
    IN UINT          i_uMsg, 
    IN WPARAM        i_wParam, 
    IN LPARAM        i_lParam, 
    IN OUT BOOL&     io_bHandled
    );

  // Message handlers

  LRESULT OnApply(
    );


  LRESULT OnComment(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );


  LRESULT OnReferralTime(
    IN WORD            i_wNotifyCode, 
    IN WORD            i_wID, 
    IN HWND            i_hWndCtl, 
    IN OUT BOOL&        io_bHandled
    );


  // Used by the node to tell the propery page to close.
  LRESULT OnParentClosing(
    IN UINT            i_uMsg, 
    IN WPARAM          i_wParam, 
    LPARAM            i_lParam, 
    IN OUT BOOL&        io_bHandled
    );

  LRESULT OnSetPageFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

  BOOL OnSetActive();

  // Used to set notification data
  HRESULT SetNotifyData(
    IN LONG_PTR            i_lNotifyHandle,
    IN LPARAM            i_lParam
    );

  void _ReSet();

  HRESULT Initialize(
    IN IDfsRoot* i_piDfsRoot,
    IN IDfsJunctionPoint* i_piDfsJPObject
      );
  
  HRESULT _Save(
    IN BSTR i_bstrJPComment,
    IN long i_lTimeout
      );

private:
  CComPtr<IDfsRoot>          m_piDfsRoot;
  CComPtr<IDfsJunctionPoint> m_piDfsJPObject;

  CComBSTR      m_bstrJPEntryPath;
  CComBSTR      m_bstrJPComment;
  long          m_lReferralTime;
  LONG_PTR      m_lNotifyHandle;
  LPARAM        m_lNotifyParam;
  BOOL          m_bDfsRoot;
  BOOL          m_bHideTimeout;
};

#endif // __CREPLICA_SET_PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\jpprop.cpp ===
/*++
Module Name:

    JPProp.cpp

Abstract:

    This module contains the implementation for CReplicaSetPropPage
	This is used to implement the property page for Junction Point(aka Replica Set)

--*/

#include "stdafx.h"
#include "resource.h"
#include "utils.h"
#include "JpProp.h"
#include "dfshelp.h"

CReplicaSetPropPage::CReplicaSetPropPage() :
    m_lReferralTime(300),
    m_lNotifyHandle(0), 
    m_lNotifyParam(0), 
    m_bDfsRoot(FALSE),
    m_bHideTimeout(FALSE),
	CQWizardPageImpl<CReplicaSetPropPage>(false)
{
}

CReplicaSetPropPage::~CReplicaSetPropPage()
{
	if (m_lNotifyHandle)
		MMCFreeNotifyHandle(m_lNotifyHandle);
}

extern WNDPROC g_fnOldEditCtrlProc;

LRESULT
CReplicaSetPropPage::OnInitDialog(
	IN UINT						i_uMsg,
	IN WPARAM					i_wParam,
	LPARAM						i_lParam,
	IN OUT BOOL&				io_bHandled
	)
{	
    ::SendMessage(GetDlgItem(IDC_REFFERAL_TIME), EM_LIMITTEXT, 10, 0);
    ::SendMessage(GetDlgItem(IDC_REPLICA_SET_COMMENT), EM_LIMITTEXT, MAXCOMMENTSZ, 0);

    TCHAR szTime[16];
    _stprintf(szTime, _T("%u"), m_lReferralTime);
    SetDlgItemText(IDC_REFFERAL_TIME, szTime);
    g_fnOldEditCtrlProc = reinterpret_cast<WNDPROC>(
                 ::SetWindowLongPtr(
                                    GetDlgItem(IDC_REFFERAL_TIME),
                                    GWLP_WNDPROC, 
                                    reinterpret_cast<LONG_PTR>(NoPasteEditCtrlProc)));

    SetDlgItemText(IDC_REPLICA_SET_NAME, m_bstrJPEntryPath);
    SetDlgItemText(IDC_REPLICA_SET_COMMENT, m_bstrJPComment);

    if (m_bHideTimeout)
    {
        MyShowWindow(GetDlgItem(IDC_REFFERAL_TIME_LABEL), FALSE);
        MyShowWindow(GetDlgItem(IDC_REFFERAL_TIME), FALSE);
    }

    return TRUE;			// To let the dialg set the control
}

//
// Q148388 How to Change Default Control Focus on CPropertyPageEx
//
LRESULT CReplicaSetPropPage::OnSetPageFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ::SetFocus(GetDlgItem(IDC_REPLICA_SET_COMMENT));
    return 0;
}

BOOL CReplicaSetPropPage::OnSetActive()
{
    PostMessage(WM_SETPAGEFOCUS, 0, 0L);
    return TRUE;
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CReplicaSetPropPage::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    LPHELPINFO lphi = (LPHELPINFO) i_lParam;
    if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
        return FALSE;

    ::WinHelp((HWND)(lphi->hItemHandle),
            DFS_CTX_HELP_FILE,
            HELP_WM_HELP,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_JP_PROP);

    return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CReplicaSetPropPage::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
    ::WinHelp((HWND)i_wParam,
            DFS_CTX_HELP_FILE,
            HELP_CONTEXTMENU,
            (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_JP_PROP);

    return TRUE;
}

void
CReplicaSetPropPage::_ReSet()
{
    if ((IDfsRoot *)m_piDfsRoot)
        m_piDfsRoot.Release();
    if ((IDfsJunctionPoint *)m_piDfsJPObject)
        m_piDfsJPObject.Release();

    m_bstrJPEntryPath.Empty();
    m_bstrJPComment.Empty();
    m_lReferralTime = 0;
    m_bDfsRoot = FALSE;
    m_bHideTimeout = FALSE;
}

HRESULT
CReplicaSetPropPage::Initialize(
    IN IDfsRoot* i_piDfsRoot,
    IN IDfsJunctionPoint* i_piDfsJPObject
    )
{
    if (i_piDfsRoot && i_piDfsJPObject ||
        !i_piDfsRoot && !i_piDfsJPObject)
        return E_INVALIDARG;

    _ReSet();

    HRESULT hr = S_OK;

    do {
        if (i_piDfsRoot)
        {
            m_piDfsRoot = i_piDfsRoot;
            m_bDfsRoot = TRUE;

            hr = m_piDfsRoot->get_RootEntryPath(&m_bstrJPEntryPath);
            BREAK_IF_FAILED(hr);

            hr = m_piDfsRoot->get_Comment(&m_bstrJPComment);
            BREAK_IF_FAILED(hr);

            hr = m_piDfsRoot->get_Timeout(&m_lReferralTime);
            if (HRESULT_FROM_WIN32(RPC_X_BAD_STUB_DATA) == hr)
            {
                // NT4 doesn't support Timeout, NetDfsGetInfo with level 4 will return 1783 when managing a NT4 root
                hr = S_OK;
                m_bHideTimeout = TRUE;
                m_lReferralTime = 0;
            }
            BREAK_IF_FAILED(hr);
        }

        if (i_piDfsJPObject)
        {
            m_piDfsJPObject = i_piDfsJPObject;
            m_bDfsRoot = FALSE;

            hr = m_piDfsJPObject->get_EntryPath(&m_bstrJPEntryPath);
            BREAK_IF_FAILED(hr);

            hr = m_piDfsJPObject->get_Comment(&m_bstrJPComment);
            BREAK_IF_FAILED(hr);

            hr = m_piDfsJPObject->get_Timeout(&m_lReferralTime);
            if (HRESULT_FROM_WIN32(RPC_X_BAD_STUB_DATA) == hr)
            {
                // NT4 doesn't support Timeout, NetDfsGetInfo with level 4 will return 1783 when managing a NT4 root
                hr = S_OK;
                m_bHideTimeout = TRUE;
                m_lReferralTime = 0;
            }
            BREAK_IF_FAILED(hr);
        }

    } while (0);

    if (FAILED(hr))
        _ReSet();

    return hr;
}

HRESULT
CReplicaSetPropPage::_Save(
    IN BSTR i_bstrJPComment,
    IN long i_lTimeout)
{
    if (m_bDfsRoot)
    {
        RETURN_INVALIDARG_IF_NULL((IDfsRoot *)m_piDfsRoot);
    } else
    {
        RETURN_INVALIDARG_IF_NULL((IDfsJunctionPoint *)m_piDfsJPObject);
    }

    HRESULT hr = S_OK;

    if (FALSE == PROPSTRNOCHNG((BSTR)m_bstrJPComment, i_bstrJPComment))
    {
        if (m_bDfsRoot)
            hr = m_piDfsRoot->put_Comment(i_bstrJPComment);
        else
            hr = m_piDfsJPObject->put_Comment(i_bstrJPComment);

        if (SUCCEEDED(hr))
            m_bstrJPComment = i_bstrJPComment;
    }

    if (SUCCEEDED(hr) &&
        m_lReferralTime != i_lTimeout)
    {
        if (m_bDfsRoot)
            hr = m_piDfsRoot->put_Timeout(i_lTimeout);
        else
            hr = m_piDfsJPObject->put_Timeout(i_lTimeout);

        if (SUCCEEDED(hr))
            m_lReferralTime = i_lTimeout;
    }

    return hr;
}

LRESULT
CReplicaSetPropPage::OnApply()
/*++

Routine Description:

	Called on when OK or Apply are pressed by the user.
	We get the information from the dialog box and notify
	the snapin

	MMCPropertyChangeNotify is used to pass on this
	information to the snapin.
	
*/
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    DWORD   dwTextLength = 0;
    int     idControl = 0;
    int     idString = 0;
    BOOL    bValidInput = FALSE;

    ULONG ulTimeout = 0;
    CComBSTR bstrJPComment;
    do {
        idControl = IDC_REFFERAL_TIME;
        CComBSTR bstrTime;
        hr = GetInputText(GetDlgItem(IDC_REFFERAL_TIME), &bstrTime, &dwTextLength);
        BREAK_IF_FAILED(hr);

        if (0 == dwTextLength || !ValidateTimeout(bstrTime, &ulTimeout))
        {
            idString = IDS_MSG_TIMEOUT_INVALIDRANGE;
            break;
        }

        idControl = IDC_REPLICA_SET_COMMENT;
        hr = GetInputText(GetDlgItem(IDC_REPLICA_SET_COMMENT), &bstrJPComment, &dwTextLength);
        BREAK_IF_FAILED(hr);
        if (0 == dwTextLength)
            bstrJPComment = _T("");

        bValidInput = TRUE;
    } while (0);

    if (FAILED(hr))
    {
        SetActivePropertyPage(GetParent(), m_hWnd);
        DisplayMessageBoxForHR(hr);
        ::SetFocus(GetDlgItem(idControl));
        return FALSE;
    } else if (bValidInput)
    {
        hr = _Save(bstrJPComment, ulTimeout);
        if (FAILED(hr))
        {
            SetActivePropertyPage(GetParent(), m_hWnd);
            DisplayMessageBoxForHR(hr);
            return FALSE;
        }

        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0);
        
        if (m_lNotifyHandle && m_lNotifyParam)
            MMCPropertyChangeNotify(m_lNotifyHandle, m_lNotifyParam);

        return TRUE;
    } else
    {
        SetActivePropertyPage(GetParent(), m_hWnd);
        if (idString)
            DisplayMessageBoxWithOK(idString);
        ::SetFocus(GetDlgItem(idControl));
        return FALSE;
    }
}

LRESULT
CReplicaSetPropPage::OnComment(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
{
	if (EN_CHANGE == i_wNotifyCode)
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);

	return TRUE;
}

LRESULT
CReplicaSetPropPage::OnReferralTime(
	IN WORD						i_wNotifyCode,
	IN WORD						i_wID,
	IN HWND						i_hWndCtl,
	IN OUT BOOL&				io_bHandled
	)
/*++

Routine Description:

	Called on an event on the Referral edit box
	
Arguments:

	i_wNotifyCode	-	What type of event is this
	
*/
{
	if (EN_CHANGE == i_wNotifyCode)
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);

	return TRUE;
}


LRESULT
CReplicaSetPropPage::OnParentClosing(
	IN UINT							i_uMsg,
	IN WPARAM						i_wParam,
	LPARAM							i_lParam,
	IN OUT BOOL&					io_bHandled
	)
/*++

Routine Description:

	Used by the node to tell the propery page to close.

Arguments:

	Not used.

--*/
{
	::SendMessage(GetParent(), PSM_PRESSBUTTON, PSBTN_CANCEL, 0);

	return TRUE;
}

HRESULT
CReplicaSetPropPage::SetNotifyData(
	IN LONG_PTR						i_lNotifyHandle,
	IN LPARAM						i_lParam
	)
/*++

Routine Description:

	Set the value of notify handle to be used to notify changes
	and the lparam to be used for notifications.

Arguments:

	i_lNotifyHandle -	The notify handle.
	i_lParam		-	The lparam to be used with notifications

--*/
{
	m_lNotifyHandle = i_lNotifyHandle;
	m_lNotifyParam = i_lParam;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\ipstream.cpp ===
/*++
Module Name:

    IPStream.cpp

Abstract:

    This module contains the implementation for CDfsSnapinScopeManager.
  This class implements IPersistStream interface for the above.

--*/

#include "stdafx.h"
#include "DfsGUI.h"
#include "DfsScope.h"
#include "utils.h"
#include <lmdfs.h>


STDMETHODIMP 
CDfsSnapinScopeManager::GetClassID(
  OUT struct _GUID*      o_pClsid
  )
/*++

Routine Description:

  Return the snapin CLSID.

Arguments:

  o_pClsid  -  The clsid is returned here.
--*/
{
  *o_pClsid = CLSID_DfsSnapinScopeManager;

  return S_OK;
}




STDMETHODIMP 
CDfsSnapinScopeManager::IsDirty(
  )
/*++

Routine Description:

  Use to check if the object has been changed since last save.
  Returns S_OK if it has, otherwise returns S_FALSE

Return value:

  S_OK, if the object has changed. i.e., dirty
  S_FALSE, if the object has not changed, i.e., not dirty.
--*/
{
    return m_pMmcDfsAdmin->GetDirty() ? S_OK : S_FALSE;
}




STDMETHODIMP 
CDfsSnapinScopeManager::Load(
  IN LPSTREAM      i_pStream
  )
/*++

Routine Description:

  Used to load the snap-in from a saved file(.MSC file).
  We set dirty to false(to disbale save), if load succeeds completely

Arguments:

  i_pStream  -  Pointer to an IPersistStream object from which the saved information is to 
          be read.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pStream);

    CWaitCursor    WaitCursor;

                    // Get the size of data that was stored
    ULONG     ulDataLen = 0;
    ULONG     uBytesRead = 0;
    HRESULT   hr = i_pStream->Read(&ulDataLen, sizeof (ULONG), &uBytesRead);
    RETURN_IF_FAILED(hr);

    if (ulDataLen <= 0)          // No use in continuing if no data is there
    {
        // do we have a local dfsroot?
        TCHAR szLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
        DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
        GetComputerName(szLocalComputerName, &dwSize);

        ROOTINFOLIST DfsRootList;
        if (S_OK == GetMultiDfsRoots(&DfsRootList, szLocalComputerName) && !DfsRootList.empty())
        {
            for (ROOTINFOLIST::iterator i = DfsRootList.begin(); i != DfsRootList.end(); i++)
            {
                CComPtr<IDfsRoot>   pDfsRoot;
                hr = CoCreateInstance(CLSID_DfsRoot, NULL, CLSCTX_INPROC_SERVER, IID_IDfsRoot, (void**) &pDfsRoot);
                if(SUCCEEDED(hr))
                {
                    hr = pDfsRoot->Initialize((*i)->bstrRootName);
                    if (S_OK == hr)
                        (void)m_pMmcDfsAdmin->AddDfsRootToList(pDfsRoot);
                }
            }
        }
        FreeRootInfoList(&DfsRootList);

        /*
        CComBSTR bstrRootEntryPath;
        hr = IsHostingDfsRoot(szLocalComputerName, &bstrRootEntryPath);

        if (S_OK == hr)
        {
            CComPtr<IDfsRoot>   pDfsRoot;
            hr = CoCreateInstance (CLSID_DfsRoot, NULL, CLSCTX_INPROC_SERVER, IID_IDfsRoot, (void**) &pDfsRoot);
            if(SUCCEEDED(hr))
            {
                hr = pDfsRoot->Initialize(bstrRootEntryPath);
                if (S_OK == hr)
                    (void)m_pMmcDfsAdmin->AddDfsRootToList(pDfsRoot);
            }
        } */

    } else
    {
        bool      bSomeLoadFailed = false;
        BYTE*     pStreamData = NULL;
        do {
            pStreamData = new BYTE [ulDataLen];  // Allocate memory for the data to be read
            BREAK_OUTOFMEMORY_IF_NULL(pStreamData, &hr);

                          // Read the data from the stream
            hr = i_pStream->Read(pStreamData, ulDataLen, &uBytesRead);
            BREAK_IF_FAILED(hr);

            BYTE* pData = pStreamData;
            BYTE* pDataEnd = pStreamData + ulDataLen;

                          // Start by reading the first machines name
            ULONG nVersion = 0;
            TCHAR *lpszDfsName = (LPTSTR)pData;
            if (*lpszDfsName == _T('\\'))
            {
                nVersion = 0;
            } else
            {
                ULONG nVer = *(ULONG UNALIGNED *)pData;
                if (nVer == 1)
                {
                    nVersion = 1;
                    pData += sizeof(ULONG);
                } else
                { 
                    hr = S_FALSE; // corrupted console file
                    break;
                }
            }

            do
            {
                lpszDfsName = (LPTSTR)pData;
                pData += sizeof(TCHAR) * (_tcslen(lpszDfsName) + 1);

                CComPtr<IDfsRoot>    pDfsRoot;
                hr = CoCreateInstance (CLSID_DfsRoot, NULL, CLSCTX_INPROC_SERVER, IID_IDfsRoot, (void**) &pDfsRoot);
                BREAK_IF_FAILED(hr);

                // retrieve link filtering settings
                ULONG ulMaxLimit = FILTERDFSLINKS_MAXLIMIT_DEFAULT;
                FILTERDFSLINKS_TYPE lFilterType = FILTERDFSLINKS_TYPE_NO_FILTER;
                TCHAR *pszFilterName = NULL;

                if (nVersion == 1)
                {
                    ulMaxLimit = *((ULONG UNALIGNED *)pData);
                    pData += sizeof(ULONG);
                    lFilterType = *((enum FILTERDFSLINKS_TYPE UNALIGNED *)pData);
                    pData += sizeof(lFilterType);
                    if (lFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
                    {
                        pszFilterName = (LPTSTR)pData;
                        pData += sizeof(TCHAR) * (_tcslen(pszFilterName) + 1);
                    }
                }

                hr = pDfsRoot->Initialize(lpszDfsName);
                if (S_OK == hr)          
                {
                    CComBSTR    bstrDfsRootEntryPath;
                    hr = pDfsRoot->get_RootEntryPath(&bstrDfsRootEntryPath);
                    if (SUCCEEDED(hr))    
                    {
                                // If already present in the list, just ignore this entry
                        hr = m_pMmcDfsAdmin->IsAlreadyInList(bstrDfsRootEntryPath);
                        if (S_OK != hr)
                        {
                            (void) m_pMmcDfsAdmin->AddDfsRootToList(
                                pDfsRoot, ulMaxLimit, lFilterType, pszFilterName);
                        }
                    }
                }
                else
                {
                    DisplayMessageBoxWithOK(IDS_MSG_FAILED_TO_INITIALIZE_DFSROOT, lpszDfsName);

                    bSomeLoadFailed = true;    // Since we could not create a dfsroot
                }

            } while (pData < pDataEnd);
        } while (false);
  
        if (pStreamData)
            delete [] pStreamData;

        m_pMmcDfsAdmin->SetDirty(bSomeLoadFailed);    // Cause we just read the whole dfsroot list from file
    }

    return hr;
}




STDMETHODIMP 
CDfsSnapinScopeManager::Save(
  OUT LPSTREAM        o_pStream,
  IN  BOOL          i_bClearDirty
  )
/*++

Routine Description:

  Used to save the snap-in to a .MSC file. This uses a IPersistStream object.

Arguments:

  o_pStream    -  Pointer to an IPersistStream object to which the saved information is to 
            be written.

  i_bClearDirty  -  A flag indication whether the dirty flag should be cleared

--*/
{
    RETURN_INVALIDARG_IF_NULL(o_pStream);

    ULONG           nVersion = 1;
    DFS_ROOT_LIST*  lpDfsRootList = NULL;
    HRESULT         hr = m_pMmcDfsAdmin->GetList (&lpDfsRootList);
    RETURN_IF_FAILED(hr);

    ULONG ulDataLen = 0;
    DFS_ROOT_LIST::iterator i;
    for (i = lpDfsRootList->begin(); i != lpDfsRootList->end(); i++)
    {
        ulDataLen += 
            ((_tcslen((*i)->m_bstrRootEntryPath) + 1) * sizeof (TCHAR)) + // to hold RootEntryPath
            sizeof(ULONG) +                     // to hold LinkFilterMaxLimit
            sizeof(enum FILTERDFSLINKS_TYPE);   // to hold LinkFilterType

        if ((*i)->m_pMmcDfsRoot->get_LinkFilterType() != FILTERDFSLINKS_TYPE_NO_FILTER)
        {
            BSTR bstr = (*i)->m_pMmcDfsRoot->get_LinkFilterName();
            ulDataLen += ((bstr ? _tcslen(bstr) : 0) + 1) * sizeof(TCHAR); // to hold LinkFilterName
        }
    }

    if (!ulDataLen)
        return hr; // no root to presist, return

    ulDataLen += sizeof(nVersion); // to hold the version number

    // Allocate data
    BYTE* pStreamData = new BYTE [ulDataLen];
    RETURN_OUTOFMEMORY_IF_NULL(pStreamData);


    // Prepare the data
    BYTE* pData = pStreamData;
    ZeroMemory(pStreamData, ulDataLen);

    // hold version number
    memcpy(pData, &nVersion, sizeof(nVersion));
    pData += sizeof(nVersion);

    int len = 0;
    for (i = lpDfsRootList->begin(); i != lpDfsRootList->end(); i++)
    {
        // hold RootEntryPath
        len = (_tcslen((*i)->m_bstrRootEntryPath) + 1) * sizeof(TCHAR);
        memcpy(pData, (*i)->m_bstrRootEntryPath, len); 
        pData += len;

        // hold LinkFilterMaxLimit
        ULONG ulLinkFilterMaxLimit = (*i)->m_pMmcDfsRoot->get_LinkFilterMaxLimit();
        memcpy(pData, &ulLinkFilterMaxLimit, sizeof(ulLinkFilterMaxLimit));
        pData += sizeof(ulLinkFilterMaxLimit);

        // hold LinkFilterType
        FILTERDFSLINKS_TYPE  lLinkFilterType = (*i)->m_pMmcDfsRoot->get_LinkFilterType();
        memcpy(pData, &lLinkFilterType, sizeof(lLinkFilterType));
        pData += sizeof(lLinkFilterType);

        // hold LinkFilterName
        if (lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
        {
            BSTR bstr = (*i)->m_pMmcDfsRoot->get_LinkFilterName();
            len = ((bstr ? _tcslen(bstr) : 0) + 1) * sizeof(TCHAR);
            memcpy(pData, (bstr ? bstr : _T("")), len);
            pData += len;
        }
    }

    // Write the data length to the stream
    ULONG   uBytesWritten = 0;
    hr = o_pStream->Write(&ulDataLen, sizeof(ulDataLen), &uBytesWritten);
    if(SUCCEEDED(hr))
    {
        // Now write the data to the stream
        hr = o_pStream->Write(pStreamData, ulDataLen, &uBytesWritten);
    }

    if (pStreamData)
        delete [] pStreamData;

    if (i_bClearDirty)
        m_pMmcDfsAdmin->SetDirty(false);

    return hr;
}

STDMETHODIMP 
CDfsSnapinScopeManager::GetSizeMax(
  OUT ULARGE_INTEGER*      o_pulSize
  )
/*++

Routine Description:

  Return the size of the data we will write to the stream.

Arguments:

  o_ulcbSize    -  Return the size of data in the low byte of this variable

--*/
{
    RETURN_INVALIDARG_IF_NULL(o_pulSize);

    DFS_ROOT_LIST*    lpDfsRootList = NULL;
    HRESULT hr = m_pMmcDfsAdmin->GetList (&lpDfsRootList);
    RETURN_IF_FAILED(hr);

    ULONG ulDataLen = 0;
    for (DFS_ROOT_LIST::iterator i = lpDfsRootList->begin(); i != lpDfsRootList->end(); i++)
    {
        ulDataLen += (_tcslen ((*i)->m_bstrRootEntryPath) + 1) * sizeof (TCHAR);
    }

    o_pulSize->LowPart = ulDataLen;  // Return the size in the low bit
    o_pulSize->HighPart = 0;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\icompont.cpp ===
/*++
Module Name:

    ICompont.cpp

Abstract:

    This module contains the IComponent Interface implementation for Dfs Admin snapin,
  Implementation for the CDfsSnapinResultManager class

--*/



#include "stdafx.h"
#include "DfsGUI.h"
#include "DfsCore.h"    // For IDfsRoot
#include "DfsScope.h"    // For CDfsScopeManager
#include "DfsReslt.h"    // IComponent and other declarations
#include "MMCAdmin.h"    // For CMMCDfsAdmin
#include "Utils.h"
#include <htmlHelp.h>


STDMETHODIMP 
CDfsSnapinResultManager::Initialize(
  IN LPCONSOLE        i_lpConsole
  )
/*++

Routine Description:

  Initializes the Icomponent interface. Allows the interface to save pointers, 
  interfaces that are required later.

Arguments:

  i_lpConsole    - Pointer to the IConsole object.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpConsole);

    HRESULT hr = i_lpConsole->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
    RETURN_IF_FAILED(hr);

    hr = i_lpConsole->QueryInterface(IID_IHeaderCtrl2, reinterpret_cast<void**>(&m_pHeader));
    RETURN_IF_FAILED(hr);

    hr = i_lpConsole->QueryInterface (IID_IResultData, (void**)&m_pResultData);
    RETURN_IF_FAILED(hr);

    hr = i_lpConsole->QueryConsoleVerb(&m_pConsoleVerb);

    return hr;
}



STDMETHODIMP 
CDfsSnapinResultManager::Notify(
  IN LPDATAOBJECT       i_lpDataObject, 
  IN MMC_NOTIFY_TYPE    i_Event, 
  IN LPARAM             i_lArg, 
  IN LPARAM             i_lParam
  )
/*++

Routine Description:

  Handles different events in form of notify
  

Arguments:

  i_lpDataObject  -  The data object for the node for which the event occured
  i_Event      -  The type of event for which notify has occurred
  i_lArg      -  Argument for the event
  i_lParam    -  Parameters for the event.

--*/
{
    // The snap-in should return S_FALSE for any notification it does not handle.
    // MMC then performs a default operation for the notification. 
    HRESULT        hr = S_FALSE;

    switch(i_Event)
    {
    case MMCN_SHOW:    
        { 
            // The notification is sent to the snap-in's IComponent implementation 
            // when a scope item is selected or deselected. 
            //
            // arg: TRUE if selecting. Indicates that the snap-in should set up the 
            //      result pane and add the enumerated items. FALSE if deselecting. 
            //      Indicates that the snap-in is going out of focus and that it 
            //      should clean up all result item cookies, because the current 
            //      result pane will be replaced by a new one. 
            // param: The HSCOPEITEM of the selected or deselected item. 

            hr = DoNotifyShow(i_lpDataObject, i_lArg, i_lParam);
            break;
        }


    case MMCN_ADD_IMAGES:
        {
            // The MMCN_ADD_IMAGES notification is sent to the snap-in's IComponent
            // implementation to add images for the result pane. 
            //
            // lpDataObject: [in] Pointer to the data object of the currently selected scope item. 
            // arg: Pointer to the result pane's image list (IImageList). 
            //      This pointer is valid only while the specific MMCN_ADD_IMAGES notification is 
            //      being processed and should not be stored for later use. Additionally, the 
            //      snap-in must not call the Release method of IImageList because MMC is responsible
            //      for releasing it. 
            // param: Specifies the HSCOPEITEM of the currently selected scope item. The snap-in 
            //        can use this parameter to add images that apply specifically to the result
            //        items of this scope item, or the snap-in can ignore this parameter and add 
            //        all possible images. 

            CMmcDisplay*    pCMmcDisplayObj = NULL;
            hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
            if (SUCCEEDED(hr))
                hr = pCMmcDisplayObj->OnAddImages((IImageList *)i_lArg, (HSCOPEITEM)i_lParam);
            break;
        }


    case MMCN_SELECT:
        {
            // The MMCN_SELECT notification is sent to the snap-in's IComponent::Notify
            // or IExtendControlbar::ControlbarNotify method when an item is selected in 
            // either the scope pane or result pane.
            //
            // lpDataObject: [in] Pointer to the data object of the currently 
            //               selected/deselected scope pane or result item. 
            // arg: BOOL bScope = (BOOL) LOWORD(arg); BOOL bSelect = (BOOL) HIWORD(arg); 
            //      bScope is TRUE if the selected item is a scope item, or FALSE if 
            //      the selected item is a result item. For bScope = TRUE, MMC does 
            //      not provide information about whether the scope item is selected 
            //      in the scope pane or in the result pane. bSelect is TRUE if the 
            //      item is selected, or FALSE if the item is deselected.
            // param: ignored. 

            hr = DoNotifySelect(i_lpDataObject, i_lArg, i_lParam);
            break;
        }

    
    case MMCN_DBLCLICK:      // Ask MMC to use the default verb. Non documented feature
        {
            // The MMCN_DBLCLICK notification is sent to the snap-in's IComponent 
            // implementation when a user double-clicks a mouse button on a list 
            // view item or on a scope item in the result pane. Pressing enter 
            // while the list item or scope item has focus in the list view also 
            // generates an MMCN_DBLCLICK notification message.
            //
            // lpDataObject: [in] Pointer to the data object of the currently selected item. 
            // arg: Not used. 
            // param: Not used. 

            CMmcDisplay*  pCMmcDisplayObj = NULL;
            hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
            if (SUCCEEDED(hr))
                hr = pCMmcDisplayObj->DoDblClick();
            break;
        }


    case MMCN_DELETE:      // Delete the node. Time to remove item
        {
            // The MMCN_DELETE notification message is sent to the snap-in's IComponent 
            // and IComponentData implementations to inform the snap-in that the object 
            // should be deleted. This message is generated when the user presses the 
            // delete key or uses the mouse to click the toolbar's delete button. The 
            // snap-in should delete the items specified in the data object.
            //
            // lpDataObject: [in] Pointer to the data object of the currently selected 
            //               scope or result item, provided by the snap-in. 
            // arg: Not used. 
            // param: Not used. 

            CMmcDisplay*    pCMmcDisplayObj = NULL;
            hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
            if (SUCCEEDED(hr))  
                hr = pCMmcDisplayObj->DoDelete();  // Delete the the item.
            break;
        }

    case MMCN_SNAPINHELP:
    case MMCN_CONTEXTHELP:
        {
            // The MMCN_CONTEXTHELP notification message is sent to the snap-in's 
            // IComponent implementation when the user requests help about a selected 
            // item by pressing the F1 key or Help button. A snap-in responds to 
            // MMCN_CONTEXTHELP by displaying a Help topic for the particular context 
            // by calling the IDisplayHelp::ShowTopic method. 
            //
            // lpDataObject: [in] Pointer to the data object of the currently selected
            //               scope or result item. 
            // arg: Zero. 
            // param: Zero. 

            hr = DfsHelp();
            break;
        }

    case MMCN_VIEW_CHANGE:
        {
            // The MMCN_VIEW_CHANGE notification message is sent to the snap-in's 
            // IComponent implementation so it can update the view when a change occurs.
            // This notification is generated when the snap-in (IComponent or IComponentData)
            // calls IConsole2::UpdateAllViews.
            //
            // lpDataObject: [in] Pointer to the data object passed to IConsole::UpdateAllViews. 
            // arg: [in] The data parameter passed to IConsole::UpdateAllViews. 
            // param: [in] The hint parameter passed to IConsole::UpdateAllViews. 

            hr = DoNotifyViewChange(i_lpDataObject, (LONG_PTR)i_lArg, (LONG_PTR)i_lParam);
            break;
        }

    case MMCN_REFRESH:
        {
            // The MMCN_REFRESH notification message is sent to a snap-in's IComponent 
            // implementation when the refresh verb is selected. Refresh can be invoked 
            // through the context menu, through the toolbar, or by pressing F5.
            //
            // lpDataObject: [in] Pointer to the data object of the currently selected scope item. 
            // arg: Not used. 
            // param: Not used. 

            CMmcDisplay*    pCMmcDisplayObj = NULL;
            hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
            if (SUCCEEDED(hr))
                (void)pCMmcDisplayObj->OnRefresh();
            break;
        }
    default:
        break;
    }

    return hr;
}

STDMETHODIMP 
CDfsSnapinResultManager::DoNotifyShow(
    IN LPDATAOBJECT     i_lpDataObject, 
    IN BOOL             i_bShow,
    IN HSCOPEITEM       i_hParent                     
)
/*++

Routine Description:

  Take action on Notify with the event MMCN_SHOW.
  Do add the column headers to result pane and add items to result pane.


Arguments:

    i_lpDataObject  -  The IDataObject pointer which identifies the node for which 
            the event is taking place
    i_bShow      -  TRUE, if the node is being showed. FALSE otherwise
    i_hParent    -  HSCOPEITEM of the node that received this event

--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpDataObject);

  m_pSelectScopeDisplayObject = NULL;

  if(FALSE == i_bShow)  // If the item is being deselected.
    return S_OK;

  // This node is being shown.
  CMmcDisplay* pCMmcDisplayObj = NULL;
  HRESULT hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
  RETURN_IF_FAILED(hr);

  m_pSelectScopeDisplayObject = pCMmcDisplayObj;

  DISPLAY_OBJECT_TYPE DisplayObType = pCMmcDisplayObj->GetDisplayObjectType();
  if (DISPLAY_OBJECT_TYPE_ADMIN == DisplayObType)
  {
    CComPtr<IUnknown>     spUnknown;
    hr = m_pConsole->QueryResultView(&spUnknown);
    if (SUCCEEDED(hr))
    {
        CComPtr<IMessageView> spMessageView;
        hr = spUnknown->QueryInterface(IID_IMessageView, (PVOID*)&spMessageView);
        if (SUCCEEDED(hr))
        {
          CComBSTR bstrTitleText;
          CComBSTR bstrBodyText;
          LoadStringFromResource(IDS_APPLICATION_NAME, &bstrTitleText);
          LoadStringFromResource(IDS_MSG_DFS_INTRO, &bstrBodyText);

          spMessageView->SetTitleText(bstrTitleText);
          spMessageView->SetBodyText(bstrBodyText);
          spMessageView->SetIcon(Icon_Information);
        }
    }

    return hr;
  }

  CWaitCursor    WaitCursor;

  hr = pCMmcDisplayObj->SetColumnHeader(m_pHeader);  // Call the method SetColumnHeader in the Display callback

  if (SUCCEEDED(hr))
    hr = pCMmcDisplayObj->EnumerateResultPane (m_pResultData);  // Add the items to the Result pane

  return hr;
}




STDMETHODIMP 
CDfsSnapinResultManager::Destroy(
  IN MMC_COOKIE            i_lCookie
  )
/*++

Routine Description:

  The IComponent object is about to be destroyed. Explicitely release all interface pointers, 
  otherwise, MMC may not call the destructor.

Arguments:

  None.

--*/
{
    m_pHeader.Release();
    m_pResultData.Release();
    m_pConsoleVerb.Release();
    m_pConsole.Release();

    m_pControlbar.Release();
    m_pMMCAdminToolBar.Release();
    m_pMMCRootToolBar.Release();
    m_pMMCJPToolBar.Release();
    m_pMMCReplicaToolBar.Release();

    return S_OK;
}




STDMETHODIMP 
CDfsSnapinResultManager::GetResultViewType(
    IN MMC_COOKIE       i_lCookie,  
    OUT LPOLESTR*       o_ppViewType, 
    OUT LPLONG          o_lpViewOptions
)
/*++

Routine Description:

  Used to describe to MMC the type of view the result pane has.
  
--*/
{
    RETURN_INVALIDARG_IF_NULL(o_lpViewOptions);

    // The callee (snap-in) allocates the view type string using the COM API function 
    // CoTaskMemAlloc and the caller (MMC) frees it using CoTaskMemFree. 

    if (i_lCookie == 0) // the static node
    {
        *o_lpViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;
        StringFromCLSID(CLSID_MessageView, o_ppViewType);

        return S_OK;
    }

    *o_lpViewOptions = MMC_VIEW_OPTIONS_NONE | MMC_VIEW_OPTIONS_EXCLUDE_SCOPE_ITEMS_FROM_LIST;  // Use the default list view
    *o_ppViewType = NULL;

    return S_FALSE; // return S_FALSE if a standard list view should be used.
}




STDMETHODIMP 
CDfsSnapinResultManager::QueryDataObject(  
    IN MMC_COOKIE           i_lCookie, 
    IN DATA_OBJECT_TYPES    i_DataObjectType, 
    OUT LPDATAOBJECT*       o_ppDataObject
)
/*++

Routine Description:

  Returns the IDataObject for the specified node.

--*/
{
    return m_pScopeManager->QueryDataObject(i_lCookie, i_DataObjectType, o_ppDataObject);
}




STDMETHODIMP 
CDfsSnapinResultManager::GetDisplayInfo(
  IN OUT RESULTDATAITEM*    io_pResultDataItem
  )
/*++

Routine Description:

  Returns the display information being asked for by MMC.
  
Arguments:

  io_pResultDataItem  -  Contains details about what information is being asked for.
              The information being asked is returned in this object itself.
--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pResultDataItem);
    RETURN_INVALIDARG_IF_NULL(io_pResultDataItem->lParam);

    return ((CMmcDisplay*)(io_pResultDataItem->lParam))->GetResultDisplayInfo(io_pResultDataItem);
}




STDMETHODIMP 
CDfsSnapinResultManager::CompareObjects(
  IN LPDATAOBJECT        i_lpDataObjectA, 
  IN LPDATAOBJECT        i_lpDataObjectB
  )
{
  return m_pScopeManager->CompareObjects(i_lpDataObjectA, i_lpDataObjectB);
}


STDMETHODIMP 
CDfsSnapinResultManager::DoNotifySelect(
    IN LPDATAOBJECT     i_lpDataObject, 
    IN BOOL             i_bSelect,
    IN HSCOPEITEM       i_hParent                     
)
/*++

Routine Description:

Take action on Notify with the event MMCN_SELECT. 
Calling the Display object method to set the console verbs like Copy\Paste\Properties, etc

Arguments:

    i_lpDataObject  -  The IDataObject pointer which is used to get the DisplayObject.

  i_bSelect    -  Used to identify whether the item is in scope and if the item is
            being selected or deselected

  i_hParent    -  Not used.
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpDataObject);

    if (DOBJ_CUSTOMOCX == i_lpDataObject)
        return S_OK;

    HRESULT hr = S_OK;
    BOOL bSelected = HIWORD(i_bSelect);
    if (TRUE == bSelected)
    {
        CMmcDisplay*  pCMmcDisplayObj = NULL;
        hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
        if (SUCCEEDED(hr))
        {
            // Set MMC Console verbs like Cut\Paste\Properties, etc
            if ((IConsoleVerb *)m_pConsoleVerb)
                pCMmcDisplayObj->SetConsoleVerbs(m_pConsoleVerb);

            // Set the text in the description bar above the result view
            pCMmcDisplayObj->SetDescriptionBarText(m_pResultData);
            pCMmcDisplayObj->SetStatusText(m_pConsole);
        }
    } else
    {
        // Clear previous text
        m_pResultData->SetDescBarText(NULL);
        m_pConsole->SetStatusText(NULL);
    }

    return hr;
}

//+--------------------------------------------------------------
//
//  Function:   CDfsSnapinResultManager::DfsHelp
//
//  Synopsis:   Display dfs help topic.
//
//---------------------------------------------------------------
STDMETHODIMP 
CDfsSnapinResultManager::DfsHelp()
{
  CComPtr<IDisplayHelp> sp;

  HRESULT hr = m_pConsole->QueryInterface(IID_IDisplayHelp, (void**)&sp);
  if (SUCCEEDED(hr))
  {
    CComBSTR bstrTopic;
    hr = LoadStringFromResource(IDS_MMC_HELP_FILE_TOPIC, &bstrTopic);
    if (SUCCEEDED(hr))
    {
        USES_CONVERSION;
        hr = sp->ShowTopic(T2OLE(bstrTopic));
    }
  }

  return hr;

}


STDMETHODIMP CDfsSnapinResultManager::DoNotifyViewChange(
  IN LPDATAOBJECT    i_lpDataObject,
  IN LONG_PTR        i_lArg,
  IN LONG_PTR        i_lParam
  )
/*++

Routine Description:

  Take action on Notify with the event MMCN_VIEW_CHANGE


Arguments:

    i_lpDataObject  -  The IDataObject pointer which is used to get the DisplayObject.

    i_lArg - If this is present then the view change is for replica and this parameter
       contains the DisplayObject (CMmcDfsReplica*) pointer of the replica.

    i_lParam - This is the lHint used by Root and Link. 0 means clean up the result pane only.
       1 means to enumerate the result items and redisplay.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpDataObject);

    CMmcDisplay*    pCMmcDisplayObj = NULL;
    HRESULT hr = m_pScopeManager->GetDisplayObject(i_lpDataObject, &pCMmcDisplayObj);
    RETURN_IF_FAILED(hr);

    // Return if the view change node is NOT the currently selected node
    if (pCMmcDisplayObj != m_pSelectScopeDisplayObject)
        return S_OK;

    if (i_lArg)
    {
        // The view change is for a replica result item.
        ((CMmcDisplay*)i_lArg)->ViewChange(m_pResultData, i_lParam);

        if ((IToolbar *)m_pMMCReplicaToolBar)
            ((CMmcDisplay*)i_lArg)->ToolbarSelect(MAKELONG(0, 1), m_pMMCReplicaToolBar);

        return S_OK;
    }

    pCMmcDisplayObj->ViewChange(m_pResultData, i_lParam);

    IToolbar *piToolbar = NULL;
    switch (pCMmcDisplayObj->GetDisplayObjectType())
    {
    case DISPLAY_OBJECT_TYPE_ADMIN:
      piToolbar = m_pMMCAdminToolBar;
      break;
    case DISPLAY_OBJECT_TYPE_ROOT:
      pCMmcDisplayObj->SetStatusText(m_pConsole);
      piToolbar = m_pMMCRootToolBar;
      break;
    case DISPLAY_OBJECT_TYPE_JUNCTION:
      piToolbar = m_pMMCJPToolBar;
      break;
    default:
      break;
    }
    if (piToolbar)
        (void)pCMmcDisplayObj->ToolbarSelect(MAKELONG(0, 1), piToolbar);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\linkfilt.h ===
/*++
Module Name:

    LinkFilt.h

Abstract:

    This module contains the declaration of the CFilterDfsLinks.

*/

#ifndef __LINKFILT_H_
#define __LINKFILT_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"

/////////////////////////////////////////////////////////////////////////////
// CFilterDfsLinks
class CFilterDfsLinks : 
  public CDialogImpl<CFilterDfsLinks>
{
public:
  CFilterDfsLinks();
  ~CFilterDfsLinks();

  enum { IDD = IDD_FILTERDFSLINKS };

BEGIN_MSG_MAP(CFilterDfsLinks)
  MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
  MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
  MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
  COMMAND_ID_HANDLER(IDC_FILTERDFSLINKS_RADIO_NO, OnRadioNo)
  COMMAND_ID_HANDLER(IDC_FILTERDFSLINKS_RADIO_YES, OnRadioYes)
  COMMAND_ID_HANDLER(IDOK, OnOK)
  COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

//  Command Handlers
  LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
  LRESULT OnRadioNo(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnRadioYes(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
  LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

//  Methods to access data in the dialog.
  HRESULT put_EnumFilterType(FILTERDFSLINKS_TYPE i_lLinkFilterType);
  HRESULT get_EnumFilterType(FILTERDFSLINKS_TYPE *o_plLinkFilterType);
  HRESULT put_EnumFilter(BSTR i_bstrEnumFilter);
  HRESULT get_EnumFilter(BSTR *o_pbstrEnumFilter);
  HRESULT put_MaxLimit(ULONG i_ulMAxLimit);
  HRESULT get_MaxLimit(ULONG *o_pulMAxLimit);

protected:
    FILTERDFSLINKS_TYPE m_lLinkFilterType;
    CComBSTR            m_bstrEnumFilter;
    ULONG               m_ulMaxLimit;
};

#endif //__LINKFILT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\linkfilt.cpp ===
/*++
Module Name:

    LinkFilt.cpp

Abstract:

    This module contains the implementation for CFilterDfsLinks.
    This class displays the Dfs link filter Dialog.

*/

#include "stdafx.h"
#include "LinkFilt.h"
#include "utils.h"
#include "dfshelp.h"
#include "netutils.h"

/////////////////////////////////////////////////////////////////////////////
// CAddToDfs

CFilterDfsLinks::CFilterDfsLinks() :
    m_ulMaxLimit(0),
    m_lLinkFilterType(FILTERDFSLINKS_TYPE_NO_FILTER)
{
}

CFilterDfsLinks::~CFilterDfsLinks()
{
}


HRESULT CFilterDfsLinks::put_EnumFilterType
(
  FILTERDFSLINKS_TYPE i_lLinkFilterType
)
{
    m_lLinkFilterType = i_lLinkFilterType;

    return S_OK;
}


HRESULT CFilterDfsLinks::get_EnumFilterType
(
  FILTERDFSLINKS_TYPE *o_plLinkFilterType
)
{
    if (!o_plLinkFilterType)
        return E_INVALIDARG;

    *o_plLinkFilterType = m_lLinkFilterType;

    return S_OK;
}

HRESULT CFilterDfsLinks::put_EnumFilter
(
  BSTR i_bstrEnumFilter
)
{
    m_bstrEnumFilter = i_bstrEnumFilter ? i_bstrEnumFilter : _T("");

    if (!m_bstrEnumFilter)
        return E_OUTOFMEMORY;

    return S_OK;
}


HRESULT CFilterDfsLinks::get_EnumFilter
(
  BSTR *o_pbstrEnumFilter
)
{
    if (!o_pbstrEnumFilter)
        return E_INVALIDARG;

    *o_pbstrEnumFilter = SysAllocString(m_bstrEnumFilter);

    if (!*o_pbstrEnumFilter)
        return E_OUTOFMEMORY;

    return S_OK;
}


HRESULT CFilterDfsLinks::put_MaxLimit
(
  ULONG i_ulMaxLimit
)
{
  m_ulMaxLimit = i_ulMaxLimit;

  return S_OK;
}

HRESULT CFilterDfsLinks::get_MaxLimit
(
  ULONG *o_pulMaxLimit
)
{
  if (!o_pulMaxLimit)
    return E_INVALIDARG;

  *o_pulMaxLimit = m_ulMaxLimit;

  return S_OK;
}

extern WNDPROC g_fnOldEditCtrlProc;

LRESULT CFilterDfsLinks::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    CComBSTR bstrBeginWith, bstrContain;
    HRESULT hr = LoadStringFromResource(IDS_FILTERDFSLINKS_BEGINWITH, &bstrBeginWith);
    if (FAILED(hr))
        return FALSE;
    
    hr = LoadStringFromResource(IDS_FILTERDFSLINKS_CONTAIN, &bstrContain);
    if (FAILED(hr))
        return FALSE;

    SetDlgItemText(IDC_FILTERDFSLINKS_FILTER, m_bstrEnumFilter);

    TCHAR szMaxLimit[16];
    _stprintf(szMaxLimit, _T("%u"), m_ulMaxLimit);
    SetDlgItemText(IDC_FILTERDFSLINKS_MAXLIMIT, szMaxLimit);
    SendDlgItemMessage(IDC_FILTERDFSLINKS_MAXLIMIT, EM_LIMITTEXT, 5, 0);

    CheckRadioButton(
          IDC_FILTERDFSLINKS_RADIO_NO,
          IDC_FILTERDFSLINKS_RADIO_YES,
          (m_lLinkFilterType == FILTERDFSLINKS_TYPE_NO_FILTER ?
            IDC_FILTERDFSLINKS_RADIO_NO : 
            IDC_FILTERDFSLINKS_RADIO_YES));

    SendDlgItemMessage(IDC_FILTERDFSLINKS_FILTER_TYPE, CB_INSERTSTRING, 0, (LPARAM)(BSTR)bstrBeginWith);
    SendDlgItemMessage(IDC_FILTERDFSLINKS_FILTER_TYPE, CB_INSERTSTRING, 1, (LPARAM)(BSTR)bstrContain);
    if (m_lLinkFilterType == FILTERDFSLINKS_TYPE_CONTAIN)
        SendDlgItemMessage(IDC_FILTERDFSLINKS_FILTER_TYPE, CB_SETCURSEL, 1, 0);
    else
        SendDlgItemMessage(IDC_FILTERDFSLINKS_FILTER_TYPE, CB_SETCURSEL, 0, 0);

    if (m_lLinkFilterType == FILTERDFSLINKS_TYPE_NO_FILTER)
    {
        // disable combo and edit box
        ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER_TYPE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER), FALSE);
    }

    g_fnOldEditCtrlProc = reinterpret_cast<WNDPROC>(
        ::SetWindowLongPtr(
                                    GetDlgItem(IDC_FILTERDFSLINKS_MAXLIMIT),
                                    GWLP_WNDPROC, 
                                    reinterpret_cast<LONG_PTR>(NoPasteEditCtrlProc)));

    return TRUE;  // Let the system set the focus
}

LRESULT CFilterDfsLinks::OnRadioNo
(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled
)
{
    ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER_TYPE), FALSE);
    ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER_LABEL), FALSE);
    ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER), FALSE);
    return TRUE;
}

LRESULT CFilterDfsLinks::OnRadioYes
(
    WORD wNotifyCode,
    WORD wID,
    HWND hWndCtl,
    BOOL& bHandled
)
{
    ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER_TYPE), TRUE);
    ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER_LABEL), TRUE);
    ::EnableWindow(GetDlgItem(IDC_FILTERDFSLINKS_FILTER), TRUE);
    return TRUE;
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CFilterDfsLinks::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FILTERDFSLINKS);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CFilterDfsLinks::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_FILTERDFSLINKS);

  return TRUE;
}

LRESULT CFilterDfsLinks::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  BOOL    bValidInput = FALSE;
  int     idControl = 0;
  int     idString = 0;
  HRESULT hr = S_OK;

  do {
    DWORD dwTextLength = 0;

    // Validate IDC_FILTERDFSLINKS_MAXLIMIT
    idControl = IDC_FILTERDFSLINKS_MAXLIMIT;
    CComBSTR bstrTemp;
    hr = GetInputText(GetDlgItem(idControl), &bstrTemp, &dwTextLength);
    if (FAILED(hr))
      break;
    if (0 == dwTextLength)
    {
      idString = IDS_MSG_EMPTY_LINKFILTMAX;
      break;
    }
    m_ulMaxLimit = (ULONG)_wtoi64(bstrTemp);

    if (IsDlgButtonChecked(IDC_FILTERDFSLINKS_RADIO_NO))
    {
        m_lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER;
        m_bstrEnumFilter = _T("");
    } else
    {
        // Validate IDC_FILTERDFSLINKS_FILTER_TYPE
        m_lLinkFilterType = (0 == SendDlgItemMessage(IDC_FILTERDFSLINKS_FILTER_TYPE, CB_GETCURSEL, 0, 0))
            ? FILTERDFSLINKS_TYPE_BEGINWITH : FILTERDFSLINKS_TYPE_CONTAIN;

        // Validate IDC_FILTERDFSLINKS_FILTER
        idControl = IDC_FILTERDFSLINKS_FILTER;
        m_bstrEnumFilter.Empty();
        hr = GetInputText(GetDlgItem(idControl), &m_bstrEnumFilter, &dwTextLength);
        if (FAILED(hr))
            break;
        if (0 == dwTextLength)
            m_bstrEnumFilter = _T("");
    }

    bValidInput = TRUE;

  } while (0);

  if (FAILED(hr))
  {
    DisplayMessageBoxForHR(hr);
    ::SetFocus(GetDlgItem(idControl));
    return FALSE;
  } else if (bValidInput)
  {
    EndDialog(S_OK);
    return TRUE;
  } else
  {
    if (idString)
      DisplayMessageBoxWithOK(idString);
    ::SetFocus(GetDlgItem(idControl));
    return FALSE;
  }
}

LRESULT CFilterDfsLinks::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  EndDialog(S_FALSE);
  return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcadmin.cpp ===
/*++
Module Name:

    MmcAdmin.cpp

Abstract:

    This module contains the implementation for CMmcDfsAdmin. This is an class 
  for MMC display related calls for the static node(the DFS Admin root node)

--*/


#include "stdafx.h"
#include "DfsGUI.h"
#include "Utils.h"      // For the LoadStringFromResource method
#include "resource.h"    // Contains the menu and toolbar command ids
#include "MenuEnum.h"    // Contains the menu command ids
#include "MmcRoot.h"    // CMmcDfsRoot class
#include "MmcAdmin.h"
#include "DfsEnums.h"    // for common enums, typedefs, etc
#include "DfsWiz.h"      // For the wizard pages, CCreateDfsRootWizPage1, 2, ...
#include "DfsNodes.h"       // For Node GUIDs
#include "DfsScope.h"
#include "mroots.h"

static const TCHAR      s_szWhack[] = _T("\\");
static const TCHAR      s_szWhackWhack[] = _T("\\\\");

CMmcDfsAdmin::CMmcDfsAdmin(CDfsSnapinScopeManager* pScopeManager)
    : m_hItemParent(NULL),
      m_bDirty(false),
      m_lpConsole(NULL)
{
    dfsDebugOut((_T("CMmcDfsAdmin::CMmcDfsAdmin this=%p\n"), this));

    m_CLSIDNodeType = s_guidDfsAdminNodeType;
    m_bstrDNodeType = s_tchDfsAdminNodeType;
    m_pScopeManager = pScopeManager;
}

CMmcDfsAdmin::~CMmcDfsAdmin()
{
    CleanScopeChildren();

    dfsDebugOut((_T("CMmcDfsAdmin::~CMmcDfsAdmin this=%p\n"), this));
}

STDMETHODIMP 
CMmcDfsAdmin::AddMenuItems(  
  IN LPCONTEXTMENUCALLBACK  i_lpContextMenuCallback, 
  IN LPLONG                 i_lpInsertionAllowed
  )
/*++

Routine Description:

This routine adds a context menu using the ContextMenuCallback provided.

Arguments:

    lpContextMenuCallback - A callback(function pointer) that is used to add the menu items
    lpInsertionAllowed - Specifies what menus can be added and where they can be added.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);

    enum 
    {  
        IDM_CONTEXTMENU_COMMAND_MAX = IDM_STATIC_MAX,
        IDM_CONTEXTMENU_COMMAND_MIN = IDM_STATIC_MIN
    };

    LONG    lInsertionPoints [IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] = { 
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP
                        };
    LPTSTR aszLanguageIndependentName[IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] =
                        {
                        _T("StaticTopNewDfsRoot"),
                        _T("StaticTopConnectTo")
                        };

    CComPtr<IContextMenuCallback2> spiCallback2;
    HRESULT hr = i_lpContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void **)&spiCallback2);
    RETURN_IF_FAILED(hr);

    for (int iCommandID = IDM_CONTEXTMENU_COMMAND_MIN, iMenuResource = IDS_MENUS_STATIC_TOP_NEW_DFSROOT;
            iCommandID <= IDM_CONTEXTMENU_COMMAND_MAX; 
            iCommandID++,iMenuResource++)
    {
        CComBSTR bstrMenuText;
        CComBSTR bstrStatusBarText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, NULL, &bstrStatusBarText);
        RETURN_IF_FAILED(hr);  

        CONTEXTMENUITEM2 ContextMenuItem;
        ZeroMemory(&ContextMenuItem, sizeof(ContextMenuItem));
        ContextMenuItem.strName = bstrMenuText;
        ContextMenuItem.strStatusBarText = bstrStatusBarText;
        ContextMenuItem.lInsertionPointID = lInsertionPoints[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];
        ContextMenuItem.lCommandID = iCommandID;
        ContextMenuItem.strLanguageIndependentName = aszLanguageIndependentName[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];

        LONG lInsertionFlag = 0;  // Use to check if we have permission to add this menu.
        switch(ContextMenuItem.lInsertionPointID)
        {
        case CCM_INSERTIONPOINTID_PRIMARY_TOP:
            lInsertionFlag = CCM_INSERTIONALLOWED_TOP;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_NEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_NEW;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_TASK:
            lInsertionFlag = CCM_INSERTIONALLOWED_TASK;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_VIEW;
            break;
        default:
            break;
        }

        if (*i_lpInsertionAllowed & lInsertionFlag)  // Add the menu item we have have the permission
        {
            hr = spiCallback2->AddItem(&ContextMenuItem);
            RETURN_IF_FAILED(hr);
        }

    } // for

    return hr;
}

STDMETHODIMP 
CMmcDfsAdmin::Command(
    IN LONG    i_lCommandID
    ) 
/*++

Routine Description:

Action to be taken on a context menu selection or click is takes place.

Arguments:

    lCommandID - The Command ID of the menu for which action has to be taken

--*/
{ 
    HRESULT    hr = S_OK;

    switch (i_lCommandID)
    {
    case IDM_STATIC_TOP_CONNECTTO:
        hr = OnConnectTo();
        break;
    case IDM_STATIC_TOP_NEW_DFSROOT:
        hr = OnNewDfsRoot();
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr; 
};

STDMETHODIMP 
CMmcDfsAdmin::OnConnectTo(
  )
/*++

Routine Description:

  Action to be taken on menu command "Connect To Dfs Root"

--*/
{
    // Display the ConnectTo dialog
    CConnectToDialog ConnectTo;  // Connect To Dialog.
    HRESULT          hr = ConnectTo.DoModal();

    do 
    {
        if (hr != S_OK)          // Mostly an error or cancel operation
            return hr;

        // Get the Dfs Root selected by the user
        CComBSTR bstrUserEnteredText;
        hr = ConnectTo.get_DfsRoot(&bstrUserEnteredText);
        RETURN_IF_FAILED(hr);

        CWaitCursor    WaitCursor; 
        if (S_OK == CheckUNCPath(bstrUserEnteredText))
        {
            //
            // user has entered the fully spelled out root entry path
            // add it to scope pane directly
            //
            hr = AddDfsRoot(bstrUserEnteredText);
        } else
        {
            //
            // user has entered only a domain or server name, we need user to further
            // determine the roots he wants to display in the scope pane
            //
            PTSTR    pszScopeWithNoWhacks = NULL;
            if (!mylstrncmpi(bstrUserEnteredText, _T("\\\\"), 2))
            {
                pszScopeWithNoWhacks = bstrUserEnteredText + 2;
            } else
            {
                pszScopeWithNoWhacks = bstrUserEnteredText;
            }

            ROOTINFOLIST DfsRootList;
            hr = GetMultiDfsRoots(&DfsRootList, pszScopeWithNoWhacks);
            if (S_OK == hr && !DfsRootList.empty())
            {
                ROOTINFOLIST::iterator i = DfsRootList.begin();
                if (1 == DfsRootList.size())
                {
                    //
                    // this domain or server only hosts one root, add it to scope pane directly
                    //
                    hr = AddDfsRoot((*i)->bstrRootName);
                } else
                {
                    //
                    // invoke the multi roots dialog
                    //
                    CMultiRoots mroots;
                    hr = mroots.Init(pszScopeWithNoWhacks, &DfsRootList);
                    if (SUCCEEDED(hr))
                        hr = mroots.DoModal();

                    if (S_OK == hr)
                    {
                        //
                        // user has OK'ed the dialog, add each selected root to scope pane
                        //
                        NETNAMELIST *pList = NULL;
                        mroots.get_SelectedRootList(&pList);
                        for (NETNAMELIST::iterator j = pList->begin(); j != pList->end(); j++)
                        {        
                            hr = AddDfsRoot((*j)->bstrNetName);
                            if (FAILED(hr))
                                break;
                        }
                    } else if (S_FALSE == hr)
                    {
                        //
                        // user has cancelled the dialog, reset it to S_OK to avoid msg popup
                        //
                        hr = S_OK;
                    }
                }
            } else if (S_FALSE != hr)
            {
                //
                // could be downlevel server, try to add it to scope pane
                //
                hr = AddDfsRoot(bstrUserEnteredText);
            }

            FreeRootInfoList(&DfsRootList);
        }

        if (S_OK == hr)
            break;

        if (S_FALSE == hr)
            DisplayMessageBoxWithOK(IDS_DFSROOT_NOT_EXIST, NULL);

        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);

        hr = ConnectTo.DoModal();
    } while (TRUE);

    return hr;
}

STDMETHODIMP 
CMmcDfsAdmin::EnumerateScopePane(
  IN LPCONSOLENAMESPACE     i_lpConsoleNameSpace,
  IN HSCOPEITEM             i_hItemParent
) 
/*++

Routine Description:

To eumerate(add) items in the scope pane. Dfs Roots in this case

Arguments:

  i_lpConsoleNameSpace - The callback used to add items to the Scope pane
  i_hItemParent -  HSCOPEITEM of the parent under which all the items will be added.

--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_hItemParent);
    RETURN_INVALIDARG_IF_NULL(i_lpConsoleNameSpace);

    m_hItemParent = i_hItemParent;
    m_lpConsoleNameSpace = i_lpConsoleNameSpace;

    CWaitCursor    WaitCursor;
    for (DFS_ROOT_LIST::iterator i = m_RootList.begin(); i != m_RootList.end(); i++)
    {
        (void)((*i)->m_pMmcDfsRoot)->AddItemToScopePane(m_lpConsoleNameSpace, m_hItemParent);
    }

    return S_OK;
}


STDMETHODIMP 
CMmcDfsAdmin::AddDfsRoot(
  IN BSTR      i_bstrDfsRootName
  )
/*++

Routine Description:

  Adds the DfsRoot to the internal list and to the Scope pane. 

Arguments:
  i_bstrDfsRootName - The full path(display name) of the DfsRoot to be created. 
  Example, ComputerName\\DfsRootName or DomainName\DfsRootName 

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_bstrDfsRootName);

    CWaitCursor wait;

            // Create the IDfsRoot object
    CComPtr<IDfsRoot>  pDfsRoot;
    HRESULT hr = CoCreateInstance (CLSID_DfsRoot, NULL, CLSCTX_INPROC_SERVER, IID_IDfsRoot, (void**) &pDfsRoot);
    RETURN_IF_FAILED(hr);

    hr = pDfsRoot->Initialize(i_bstrDfsRootName);
    if (S_OK != hr)
        return hr;

            // Get the server hosting Dfs.
    CComBSTR      bstrDfsRootEntryPath;
    hr = pDfsRoot->get_RootEntryPath(&bstrDfsRootEntryPath);
    RETURN_IF_FAILED(hr);

            // If already present in the list, just display a message and return
    CMmcDfsRoot *pMmcDfsRoot = NULL;
    hr = IsAlreadyInList(bstrDfsRootEntryPath, &pMmcDfsRoot);
    if (S_OK == hr)
    {
        pMmcDfsRoot->OnRefresh(); // refresh to pick up other root replicas
        return hr;
    }

            // Add the IDfsRoot object to the list and to Scope Pane
    hr = AddDfsRootToList(pDfsRoot);

    m_bDirty = true;  // Dirty is true as we now have a new node in the list

    return hr;
}


STDMETHODIMP 
CMmcDfsAdmin::AddDfsRootToList(
    IN IDfsRoot*            i_pDfsRoot,
    IN ULONG                i_ulLinkFilterMaxLimit, // = FILTERDFSLINKS_MAXLIMIT_DEFAULT,
    IN FILTERDFSLINKS_TYPE  i_lLinkFilterType,      // = FILTERDFSLINKS_TYPE_NO_FILTER,
    IN BSTR                 i_bstrLinkFilterName    // = NULL
  )
/*++

Routine Description:

To add a new DFSRoot only to the list.

Arguments:

    i_pDfsRoot -  The IDfsRoot object being added to the list

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pDfsRoot);

    CMmcDfsRoot* pMmcDfsRoot = new CMmcDfsRoot(i_pDfsRoot, this, m_lpConsole,
        i_ulLinkFilterMaxLimit, i_lLinkFilterType, i_bstrLinkFilterName);  
    RETURN_OUTOFMEMORY_IF_NULL(pMmcDfsRoot);

    HRESULT hr = pMmcDfsRoot->m_hrValueFromCtor;
    if (FAILED(hr))
    {
        delete pMmcDfsRoot;
        return hr;
    }    

    CComBSTR      bstrRootEntryPath;
    hr = i_pDfsRoot->get_RootEntryPath(&bstrRootEntryPath);
    if (FAILED(hr))
    {
        delete pMmcDfsRoot;
        return hr;
    }

    // Create a new node for storing Dfs Root information.
    DFS_ROOT_NODE* pNewDfsRootNode = new DFS_ROOT_NODE(pMmcDfsRoot, bstrRootEntryPath);
    if (!pNewDfsRootNode || !pNewDfsRootNode->m_bstrRootEntryPath)
    {
        delete pMmcDfsRoot;
        delete pNewDfsRootNode;
        return E_OUTOFMEMORY;
    }

    m_RootList.push_back(pNewDfsRootNode);

              // Add this DfsRoot to scope pane. Need item parent to be non null
    if (m_hItemParent)
    {
        hr = (pNewDfsRootNode->m_pMmcDfsRoot)->AddItemToScopePane(m_lpConsoleNameSpace, m_hItemParent);
        RETURN_IF_FAILED(hr);
    }

    m_bDirty = true;    // Dirty is true as we now have a new node in the list

    return hr;
}

//  This method returns the pointer to the list containing information of all DfsRoots
//  added to the Snapin. The caller SHOULD NOT free the list.
STDMETHODIMP 
CMmcDfsAdmin::GetList(
    OUT DFS_ROOT_LIST**    o_pList
  )
{
    RETURN_INVALIDARG_IF_NULL(o_pList);

    *o_pList = &m_RootList;

    return S_OK;
}

STDMETHODIMP 
CMmcDfsAdmin::IsAlreadyInList(
  IN BSTR           i_bstrDfsRootEntryPath,
  OUT CMmcDfsRoot **o_ppMmcDfsRoot
  )
/*++

Routine Description:

Routine used to check if the DfsRoot is already in the list

Arguments:

    i_bstrDfsRootEntryPath -  The Server name of the DfsRoot object

Return value:

    S_OK, if node is present in the list.
    S_FALSE, if the node doesn't exist in the list
--*/
{
    for (DFS_ROOT_LIST::iterator i = m_RootList.begin(); i != m_RootList.end(); i++)
    {
        if (!lstrcmpi((*i)->m_bstrRootEntryPath, i_bstrDfsRootEntryPath))
        {
            if (o_ppMmcDfsRoot)
                *o_ppMmcDfsRoot = (*i)->m_pMmcDfsRoot;

            return S_OK;
        }
    }

    return S_FALSE;
}

HRESULT
CMmcDfsAdmin::OnRefresh(
  )
{
    // Select this node first
    m_lpConsole->SelectScopeItem(m_hItemParent);

    CWaitCursor    WaitCursor;

    HRESULT           hr = S_OK;
    NETNAMELIST       listRootEntryPaths;
    if (!m_RootList.empty())
    {  
        for (DFS_ROOT_LIST::iterator i = m_RootList.begin(); i != m_RootList.end(); i++)
        {
            // silently close all property pages
            ((*i)->m_pMmcDfsRoot)->CloseAllPropertySheets(TRUE);

            NETNAME *pName = new NETNAME;
            BREAK_OUTOFMEMORY_IF_NULL(pName, &hr);

            pName->bstrNetName = (*i)->m_bstrRootEntryPath;
            BREAK_OUTOFMEMORY_IF_NULL((BSTR)(pName->bstrNetName), &hr);

            listRootEntryPaths.push_back(pName);
        }
    }

    if (FAILED(hr))
    {
        FreeNetNameList(&listRootEntryPaths);
        return hr;
    }

    if (listRootEntryPaths.empty())
        return hr;

    CleanScopeChildren();

    for (NETNAMELIST::iterator i = listRootEntryPaths.begin(); i != listRootEntryPaths.end(); i++)
    {
        (void)AddDfsRoot((*i)->bstrNetName);
    }

    FreeNetNameList(&listRootEntryPaths);

    return hr;
}

// Delete the node from m_RootList
STDMETHODIMP
CMmcDfsAdmin::DeleteMmcRootNode(
  IN CMmcDfsRoot*            i_pMmcDfsRoot
  )
{
    RETURN_INVALIDARG_IF_NULL(i_pMmcDfsRoot);

    dfsDebugOut((_T("CMmcDfsAdmin::DeleteMmcRootNode %p\n"), i_pMmcDfsRoot)); 

    for (DFS_ROOT_LIST::iterator i = m_RootList.begin(); i != m_RootList.end(); i++)
    {
        if ((*i)->m_pMmcDfsRoot == i_pMmcDfsRoot)
        {
            m_RootList.erase(i);
            m_bDirty = true;
            break;
        }
    }

    return S_OK;
}

STDMETHODIMP 
CMmcDfsAdmin::SetConsoleVerbs(
  IN  LPCONSOLEVERB      i_lpConsoleVerb
  ) 
/*++

Routine Description:

  Routine used to set the console verb settings.
  Sets all of them except Open off. 
  For all scope pane items, default verb is "open'. For result items, 
  it is "properties"

Arguments:

    i_lpConsoleVerb -  The callback used to handle console verbs

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpConsoleVerb);

    i_lpConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);

    i_lpConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);  //For scope items, default verb is "open"

    return S_OK; 
}

STDMETHODIMP 
CMmcDfsAdmin::OnNewDfsRoot(
  )
/*++

Routine Description:

  Action to be taken on menu command "New Dfs Root".
  Here is a wizard is used to guide the user through the process of creating a new 
  dfs root.

Arguments:
  None

--*/
{
    //
    // Use MMC main window as the parent as our modal wizard
    //
    HWND  hwndMainWin = 0;
    HRESULT hr = m_lpConsole->GetMainWindow(&hwndMainWin);
    RETURN_IF_FAILED(hr);

    CREATEDFSROOTWIZINFO      CreateWizInfo;// 0 initializes all members to 0. Necessary
    CreateWizInfo.pMMCAdmin = this;

    CCreateDfsRootWizPage1      WizPage1(&CreateWizInfo);  // Wizard pages
    CCreateDfsRootWizPage2      WizPage2(&CreateWizInfo);
    CCreateDfsRootWizPage3      WizPage3(&CreateWizInfo);
    CCreateDfsRootWizPage4      WizPage4(&CreateWizInfo);
    CCreateDfsRootWizPage6      WizPage6(&CreateWizInfo);
    CCreateDfsRootWizPage5      WizPage5(&CreateWizInfo);
    CCreateDfsRootWizPage7      WizPage7(&CreateWizInfo);

    CComPtr<IPropertySheetCallback>  pPropSheetCallback;
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetCallback, (void**)&pPropSheetCallback);
    RETURN_IF_FAILED(hr);

    CComPtr<IPropertySheetProvider>  pPropSheetProvider;
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetProvider, (void**)&pPropSheetProvider);
    RETURN_IF_FAILED(hr);

    hr = pPropSheetProvider->CreatePropertySheet(  
                                _T(""),         // Property sheet title. Should not be null so send empty string.
                                FALSE,          // Wizard and not property sheet.
                                0,              // Cookie
                                NULL,           // IDataobject
                                MMC_PSO_NEWWIZARDTYPE);  // Creation flags

    if (SUCCEEDED(hr))
    {
        pPropSheetCallback->AddPage(WizPage1.Create());
        pPropSheetCallback->AddPage(WizPage2.Create());
        pPropSheetCallback->AddPage(WizPage3.Create());
        pPropSheetCallback->AddPage(WizPage4.Create());
        pPropSheetCallback->AddPage(WizPage6.Create());
        pPropSheetCallback->AddPage(WizPage5.Create());
        pPropSheetCallback->AddPage(WizPage7.Create());

        hr = pPropSheetProvider->AddPrimaryPages(
                                (IComponentData *)(m_pScopeManager),
                                FALSE,      // Don't create a notify handle
                                NULL, 
                                TRUE        // Scope pane (not result pane)
                                );

        if (SUCCEEDED(hr))
            hr = pPropSheetProvider->Show(
                                (LONG_PTR)hwndMainWin, // Parent window of the wizard
                                0                      // Starting page
                                ); 
        //
        // If failed, call IPropertySheetProvider::Show(-1,0) to 
        // delete the property sheet and free its resources
        //
        if (FAILED(hr))
            pPropSheetProvider->Show(-1, 0);
    }

    RETURN_IF_FAILED(hr);

    if (CreateWizInfo.bDfsSetupSuccess)
    {
        CComBSTR bstrRootEntryPath = _T("\\\\");
        if (CreateWizInfo.DfsType == DFS_TYPE_FTDFS)
            bstrRootEntryPath += CreateWizInfo.bstrSelectedDomain;
        else
            bstrRootEntryPath += CreateWizInfo.bstrSelectedServer;
        bstrRootEntryPath += _T("\\");
        bstrRootEntryPath += CreateWizInfo.bstrDfsRootName;

        hr = AddDfsRoot(bstrRootEntryPath);
    }

    return hr;
}

HRESULT
CMmcDfsAdmin::SetDescriptionBarText(
  IN LPRESULTDATA            i_lpResultData
  )
/*++

Routine Description:

  A routine used set the text in the Description bar above 
  the result view.

Arguments:
  i_lpResultData  -  Pointer to the IResultData callback which is
            used to set the description text

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpResultData);

    CComBSTR bstrTextForDescriptionBar;
    LoadStringFromResource(IDS_DESCRIPTION_BAR_TEXT_ADMIN, &bstrTextForDescriptionBar);

    i_lpResultData->SetDescBarText(bstrTextForDescriptionBar);

    return S_OK;
}

HRESULT 
CMmcDfsAdmin::ToolbarSelect(
  IN const LONG          i_lArg,
  IN  IToolbar*          i_pToolBar
  )
/*++

Routine Description:

  Handle a select event for a toolbar
  Enable the buttons, if the event for a selection.
  Disable the buttons, if the event was for a deselection

Arguments:
  i_lArg        -  The argument passed to the actual method.
  o_pToolBar      -  The Toolbar pointer.
    
--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pToolBar);

    EnableToolbarButtons(i_pToolBar, IDT_ADMIN_MIN, IDT_ADMIN_MAX, (BOOL)HIWORD(i_lArg));

    return S_OK; 
}


HRESULT
CMmcDfsAdmin::CreateToolbar(
  IN const LPCONTROLBAR      i_pControlbar,
  IN const LPEXTENDCONTROLBAR          i_lExtendControlbar,
  OUT  IToolbar**          o_pToolBar
  )
/*++

Routine Description:

  Create the toolbar.
  Involves the actual toolbar creation call, creating the bitmap and adding it
  and finally adding the buttons to the toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lExtendControlbar  -  The object implementing IExtendControlbar. This is 
              the class exposed to MMC.
  o_pToolBar      -  The Toolbar pointer.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);
    RETURN_INVALIDARG_IF_NULL(i_lExtendControlbar);
    RETURN_INVALIDARG_IF_NULL(o_pToolBar);

                  // Create the toolbar
    HRESULT hr = i_pControlbar->Create(TOOLBAR, i_lExtendControlbar, reinterpret_cast<LPUNKNOWN*>(o_pToolBar));
    RETURN_IF_FAILED(hr);

                  // Add the bitmap to the toolbar
    hr = AddBitmapToToolbar(*o_pToolBar, IDB_ADMIN_TOOLBAR);
    RETURN_IF_FAILED(hr);

    int      iButtonPosition = 0;    // The first button position
    for (int iCommandID = IDT_ADMIN_MIN, iMenuResource = IDS_MENUS_STATIC_TOP_NEW_DFSROOT;
            iCommandID <= IDT_ADMIN_MAX; 
            iCommandID++,iMenuResource++,iButtonPosition++)
    {
        CComBSTR bstrMenuText;
        CComBSTR bstrToolTipText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, &bstrToolTipText, NULL);
        RETURN_IF_FAILED(hr);  

                          // Add all the buttons to the toolbar
        MMCBUTTON      ToolbarButton;
        ZeroMemory(&ToolbarButton, sizeof ToolbarButton);
        ToolbarButton.nBitmap  = iButtonPosition;
        ToolbarButton.idCommand = iCommandID;
        ToolbarButton.fsState = TBSTATE_ENABLED;
        ToolbarButton.fsType = TBSTYLE_BUTTON;
        ToolbarButton.lpButtonText = bstrMenuText;
        ToolbarButton.lpTooltipText = bstrToolTipText;

                          // Add the button to the toolbar
        hr = (*o_pToolBar)->InsertButton(iButtonPosition, &ToolbarButton);
        RETURN_IF_FAILED(hr);
    }

    return hr;
}

STDMETHODIMP 
CMmcDfsAdmin::ToolbarClick(
  IN const LPCONTROLBAR         i_pControlbar, 
  IN const LPARAM               i_lParam
  ) 
/*++

Routine Description:

  Action to take on a click on a toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lParam      -  The lparam to the actual notify. This is the command id of
              the button on which a click occurred.
--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);

    HRESULT    hr = S_OK;

    switch(i_lParam)        // What button did the user click on.
    {
    case IDT_ADMIN_CONNECTTO:
        hr = OnConnectTo();
        break;
    case IDT_ADMIN_NEW_DFSROOT:
        hr = OnNewDfsRoot();
        break;
    default:
        hr = E_INVALIDARG;
        break;
    };

    return hr; 
}

STDMETHODIMP CMmcDfsAdmin::CleanScopeChildren(
    )
{
/*++

Routine Description:

  Recursively deletes all Scope pane children display objects.

--*/
    HRESULT hr = S_OK;

    if (!m_RootList.empty())
    {  
        // clean up display objects
        for (DFS_ROOT_LIST::iterator i = m_RootList.begin(); i != m_RootList.end(); i++)
        {
            (*i)->m_pMmcDfsRoot->RemoveFromMMC();
            delete (*i);
        }

        m_RootList.erase(m_RootList.begin(), m_RootList.end());
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcdispl.h ===
/*++
Module Name:

    MmcDispl.h

Abstract:

    This module contains the definition for CMmcDisplay class. This is an abstract class 
    for MMC Display related calls
--*/


#if !defined(AFX_MMCDISPLAY_H__2CC64E53_3BF4_11D1_AA17_00C06C00392D__INCLUDED_)
#define AFX_MMCDISPLAY_H__2CC64E53_3BF4_11D1_AA17_00C06C00392D__INCLUDED_


#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "stdafx.h"

#define    CCF_DFS_SNAPIN_INTERNAL    ( L"CCF_DFS_SNAPIN_INTERNAL" )

#define MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(ptr)     if (!(ptr)) {m_hrValueFromCtor = E_INVALIDARG; return;}
#define MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr)            if (FAILED(hr)) {m_hrValueFromCtor = hr; return;}
#define MMC_DISP_CTOR_RETURN_OUTOFMEMORY_IF_NULL(ptr)    if (!(ptr)) {m_hrValueFromCtor = E_OUTOFMEMORY; return;}

typedef enum DISPLAY_OBJECT_TYPE
{
    DISPLAY_OBJECT_TYPE_ADMIN = 0,
    DISPLAY_OBJECT_TYPE_ROOT,
    DISPLAY_OBJECT_TYPE_JUNCTION,
    DISPLAY_OBJECT_TYPE_REPLICA
};

class ATL_NO_VTABLE CMmcDisplay:
    public IDataObject,
    public CComObjectRootEx<CComSingleThreadModel>
{
public:

    CMmcDisplay();

    virtual ~CMmcDisplay();

BEGIN_COM_MAP(CMmcDisplay)
    COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP_X()

// Clipboard formats that are required by the console
public:

    // This stores the clipboard format identifier for CCF_NODETYPE.
    static CLIPFORMAT    mMMC_CF_NodeType;

    // stores the clipboard format identifier for CCF_SZNODETYPE.
    static CLIPFORMAT    mMMC_CF_NodeTypeString;

    // This stores the clipboard format identifier for CCF_DISPLAY_NAME.
    static CLIPFORMAT    mMMC_CF_DisplayName;

    // This stores the clipboard format identifier for CCF_SNAPIN_CLASSID.
    static CLIPFORMAT    mMMC_CF_CoClass;

    // This stores the clipboard format identifier for CCF_DFS_SNAPIN_INTERNAL.
    static CLIPFORMAT       mMMC_CF_Dfs_Snapin_Internal;

    // IUnknown Interface

    STDMETHOD(QueryInterface)(const struct _GUID & i_refiid, 
                              void ** o_pUnk);

    unsigned long __stdcall AddRef(void);

    unsigned long __stdcall Release(void);


    // IDataObject interface

    // Implemented : This is the method needed by MMC
    STDMETHOD(GetDataHere)(
        IN  LPFORMATETC             i_lpFormatetc,
        OUT LPSTGMEDIUM             o_lpMedium
        );

    STDMETHOD(GetData)(
        IN LPFORMATETC lpFormatetcIn, 
        OUT LPSTGMEDIUM lpMedium
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(EnumFormatEtc)(
        DWORD dwDirection, 
        LPENUMFORMATETC* ppEnumFormatEtc
        )
    {
        return E_NOTIMPL;
    }

    STDMETHOD(QueryGetData)(
        LPFORMATETC lpFormatetc
        )
    {
        return E_NOTIMPL;
    };

    STDMETHOD(GetCanonicalFormatEtc)(
        LPFORMATETC lpFormatetcIn, 
        LPFORMATETC lpFormatetcOut
        )
    {
        return E_NOTIMPL;
    };

    STDMETHOD(SetData)(
        LPFORMATETC lpFormatetc, 
        LPSTGMEDIUM lpMedium, 
        BOOL bRelease
        )
    {
        return E_NOTIMPL;
    };

    STDMETHOD(DAdvise)(
        LPFORMATETC lpFormatetc, 
        DWORD advf, 
        LPADVISESINK pAdvSink, 
        LPDWORD pdwConnection
        ) 
    {
        return E_NOTIMPL;
    };

    STDMETHOD(DUnadvise)(
        DWORD dwConnection
        )
    {
        return E_NOTIMPL;
    };

    STDMETHOD(EnumDAdvise)(
        LPENUMSTATDATA* ppEnumAdvise
        )
    {
        return E_NOTIMPL;
    };

public:

    // To set Snapin CLSID. 

    STDMETHOD(put_CoClassCLSID)(
        IN CLSID newVal
        );

    // For adding context menu items
    STDMETHOD(AddMenuItems)(    
        IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
        IN LPLONG                   i_lpInsertionAllowed
        ) = 0;

    // For taking action on a context menu selection.
    STDMETHOD(Command)(
        IN LONG                     i_lCommandID
        ) = 0;

    // Set the headers for the listview (in the result pane) column
    STDMETHOD(SetColumnHeader)(
        IN LPHEADERCTRL2            i_piHeaderControl
        ) = 0;

    // Return the requested display information for the Result Pane
    STDMETHOD(GetResultDisplayInfo)(
        IN OUT LPRESULTDATAITEM     io_pResultDataItem
        ) = 0;

    // Return the requested display information for the Scope Pane
    STDMETHOD(GetScopeDisplayInfo)(
        IN OUT  LPSCOPEDATAITEM     io_pScopeDataItem    
        ) = 0;

    // Add items(or folders), if any to the Scope Pane
    STDMETHOD(EnumerateScopePane)(
        IN LPCONSOLENAMESPACE       i_lpConsoleNameSpace,
        IN HSCOPEITEM               i_hParent
        ) = 0;

    // Add items(or folders), if any to the Result Pane
    STDMETHOD(EnumerateResultPane)(
        IN OUT     IResultData*     io_pResultData
        ) = 0;

    // Set the console verb settings. Change the state, decide the default verb, etc
    STDMETHOD(SetConsoleVerbs)(
        IN    LPCONSOLEVERB         i_lpConsoleVerb
        ) = 0;

    // MMCN_DBLCLICK, return S_FALSE if you want MMC handle the default verb.
    STDMETHOD(DoDblClick)(
        )  = 0;

    // Delete the current item.
    STDMETHOD(DoDelete)(
        ) = 0;

    // Checks whether the object has pages to display
    STDMETHOD(QueryPagesFor)(
        ) = 0;

    // Creates and passes back the pages to be displayed
    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK  i_lpPropSheetCallback,
        IN LONG_PTR                 i_lNotifyHandle
        ) = 0;

    // Used to notify the object that it's properties have changed
    STDMETHOD(PropertyChanged)(
        ) = 0;

    // Used to set the result view description bar text
    STDMETHOD(SetDescriptionBarText)(
        IN LPRESULTDATA             i_lpResultData
        ) = 0;

    // Used to set the result view description bar text
    STDMETHOD(SetStatusText)(
        IN LPCONSOLE2               i_lpConsole
        ) = 0;

    // Handle a select event for the node. Handle only toolbar related 
    // activities here
    STDMETHOD(ToolbarSelect)(
        IN const LONG               i_lArg,
        IN    IToolbar*             i_pToolBar
        ) = 0;

    // Handle a click on the toolbar
    STDMETHOD(ToolbarClick)(
        IN const LPCONTROLBAR       i_pControlbar, 
        IN const LPARAM             i_lParam
        ) = 0;

    STDMETHOD(RemoveFromMMC)() = 0;

    STDMETHOD(CleanScopeChildren)(
        VOID
        ) = 0;

    STDMETHOD(CleanResultChildren)(
        ) = 0;

    STDMETHOD(ViewChange)(
        IResultData*                i_pResultData,
        LONG_PTR                    i_lHint
    ) = 0;

    STDMETHOD(GetEntryPath)(
        BSTR*                       o_pbstrEntryPath
    ) = 0;

    virtual DISPLAY_OBJECT_TYPE GetDisplayObjectType(
        ) = 0;

    virtual HRESULT CreateToolbar(
        IN const LPCONTROLBAR       i_pControlbar,
        IN const LPEXTENDCONTROLBAR i_lExtendControlbar,
        OUT    IToolbar**           o_pToolBar
        ) = 0;

    virtual HRESULT OnRefresh(
        );

    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);

// Helper Methods
private:
    HRESULT WriteToStream(
        IN const void*              i_pBuffer, 
        IN int                      i_len, 
        OUT LPSTGMEDIUM             o_lpMedium
        );

    // Member variables.
protected:
    CLSID       m_CLSIDClass;           // The CLSID of the object
    CLSID       m_CLSIDNodeType;        // The node type as a CLSID
    CComBSTR    m_bstrDNodeType;        // The node type as a CLSID
    DWORD       m_dwRefCount;           // Reference Count for dataobjects returned.

public:
    HRESULT     m_hrValueFromCtor;
};

#endif // !defined(AFX_MMCDISPLAY_H__2CC64E53_3BF4_11D1_AA17_00C06C00392D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\menuenum.h ===
/*++
Module Name:

    MenuEnum.h

Abstract:

    Contains command ids for the context menus of the Dfs Admin snap-in
	and toolbar buttons of the Dfs Admin snap-in

--*/



enum STATIC_MENU_COMMANDS
{
	IDM_STATIC_TOP_NEW_DFSROOT = 1,
	IDM_STATIC_TOP_CONNECTTO,

	IDM_STATIC_MIN = IDM_STATIC_TOP_NEW_DFSROOT,
	IDM_STATIC_MAX = IDM_STATIC_TOP_CONNECTTO
};



enum ROOT_MENU_COMMANDS
{
	IDM_ROOT_TOP_NEW_DFS_LINK = 1,
	IDM_ROOT_TOP_NEW_ROOT_REPLICA,
	IDM_ROOT_TOP_CHECK_STATUS,
	IDM_ROOT_TOP_FILTER_DFS_LINKS,
	IDM_ROOT_TOP_DELETE_CONNECTION_TO_DFS_ROOT,
	IDM_ROOT_TOP_DELETE_DFS_ROOT,
	IDM_ROOT_TOP_DELETE_DISPLAYED_DFS_LINKS,
	IDM_ROOT_TOP_REPLICATION_TOPOLOGY,
	IDM_ROOT_TOP_SHOW_REPLICATION,
	IDM_ROOT_TOP_HIDE_REPLICATION,
	IDM_ROOT_TOP_STOP_REPLICATION,

	IDM_ROOT_MIN = IDM_ROOT_TOP_NEW_DFS_LINK,
	IDM_ROOT_MAX = IDM_ROOT_TOP_STOP_REPLICATION
};


enum JUNCTION_MENU_COMMANDS
{
	IDM_JUNCTION_TOP_NEW_DFS_REPLICA = 1,
	IDM_JUNCTION_TOP_CHECK_STATUS,
	IDM_JUNCTION_TOP_REMOVE_FROM_DFS,
	IDM_JUNCTION_TOP_REPLICATION_TOPOLOGY,
	IDM_JUNCTION_TOP_SHOW_REPLICATION,
	IDM_JUNCTION_TOP_HIDE_REPLICATION,
	IDM_JUNCTION_TOP_STOP_REPLICATION,

	IDM_JUNCTION_MIN = IDM_JUNCTION_TOP_NEW_DFS_REPLICA,
	IDM_JUNCTION_MAX = IDM_JUNCTION_TOP_STOP_REPLICATION
};


enum REPLICA_MENU_COMMANDS
{
	IDM_REPLICA_TOP_OPEN=1,
	IDM_REPLICA_TOP_CHECK_STATUS,
	IDM_REPLICA_TOP_TAKE_REPLICA_OFFLINE_ONLINE,
	IDM_REPLICA_TOP_REMOVE_FROM_DFS,
	IDM_REPLICA_TOP_REPLICATE,
	IDM_REPLICA_TOP_STOP_REPLICATION,

	IDM_REPLICA_MIN = IDM_REPLICA_TOP_OPEN,
	IDM_REPLICA_MAX = IDM_REPLICA_TOP_STOP_REPLICATION
};


// Toolbar command for the dfs admin static node
enum ADMIN_TOOLBAR_COMMANDS
{
	IDT_ADMIN_NEW_DFSROOT = 1,
	IDT_ADMIN_CONNECTTO,

	IDT_ADMIN_MIN = IDT_ADMIN_NEW_DFSROOT,
	IDT_ADMIN_MAX = IDT_ADMIN_CONNECTTO
};



// Toolbar command for the dfs admin root node
enum ROOT_TOOLBAR_COMMANDS
{
	IDT_ROOT_NEW_DFS_LINK = 1,
	IDT_ROOT_NEW_ROOT_REPLICA,
	IDT_ROOT_CHECK_STATUS,
	IDT_ROOT_FILTER_DFS_LINKS,
	IDT_ROOT_DELETE_CONNECTION_TO_DFS_ROOT,
	IDT_ROOT_DELETE_DFS_ROOT,
	IDT_ROOT_DELETE_DISPLAYED_DFS_LINKS,
	IDT_ROOT_REPLICATION_TOPOLOGY,
	IDT_ROOT_SHOW_REPLICATION,
	IDT_ROOT_HIDE_REPLICATION,
	IDT_ROOT_STOP_REPLICATION,

	IDT_ROOT_MIN = IDT_ROOT_NEW_DFS_LINK,
	IDT_ROOT_MAX = IDT_ROOT_STOP_REPLICATION
};


// Toolbar command for the dfs admin junction point(jp) node
enum JP_TOOLBAR_COMMANDS
{
	IDT_JP_NEW_DFS_REPLICA = 1,
	IDT_JP_CHECK_STATUS,
	IDT_JP_REMOVE_FROM_DFS,
	IDT_JP_REPLICATION_TOPOLOGY,
	IDT_JP_SHOW_REPLICATION,
	IDT_JP_HIDE_REPLICATION,
	IDT_JP_STOP_REPLICATION,

	IDT_JP_MIN = IDT_JP_NEW_DFS_REPLICA,
	IDT_JP_MAX = IDT_JP_STOP_REPLICATION
};



// Toolbar command for the dfs admin replica node
enum REPLICA_TOOLBAR_COMMANDS
{
	IDT_REPLICA_OPEN=1,
	IDT_REPLICA_CHECK_STATUS,
	IDT_REPLICA_TAKE_REPLICA_OFFLINE_ONLINE,
	IDT_REPLICA_REMOVE_FROM_DFS,
	IDT_REPLICA_REPLICATE,
	IDT_REPLICA_STOP_REPLICATION,

	IDT_REPLICA_MIN = IDT_REPLICA_OPEN,
	IDT_REPLICA_MAX = IDT_REPLICA_STOP_REPLICATION
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcdispl.cpp ===
/*++
Module Name:

    mmcdispl.cpp

Abstract:

    This class implements IDataObject interface and also provides a template
    for Display Object Classes.

--*/


#include "stdafx.h"
#include "MmcDispl.h"       
#include "DfsGUI.h"
#include "Utils.h"          // For LoadStringFromResource
#include "DfsNodes.h"

// Register the clipboard formats that MMC expects us to register
CLIPFORMAT CMmcDisplay::mMMC_CF_NodeType       = (CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CMmcDisplay::mMMC_CF_NodeTypeString = (CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);
CLIPFORMAT CMmcDisplay::mMMC_CF_DisplayName    = (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CMmcDisplay::mMMC_CF_CoClass        = (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
CLIPFORMAT CMmcDisplay::mMMC_CF_Dfs_Snapin_Internal = (CLIPFORMAT)RegisterClipboardFormat(CCF_DFS_SNAPIN_INTERNAL);

CMmcDisplay::CMmcDisplay() : m_dwRefCount(1), m_hrValueFromCtor(S_OK)
{
    dfsDebugOut((_T("CMmcDisplay::CMmcDisplay this=%p\n"), this));

    ZeroMemory(&m_CLSIDClass, sizeof(m_CLSIDClass));
    ZeroMemory(&m_CLSIDNodeType, sizeof(m_CLSIDNodeType));
}

CMmcDisplay::~CMmcDisplay()
{
    dfsDebugOut((_T("CMmcDisplay::~CMmcDisplay this=%p\n"), this));
}


//
// IUnknown Interface Implementation
//
STDMETHODIMP
CMmcDisplay::QueryInterface(
    IN const struct _GUID & i_refiid,
    OUT void ** o_pUnk
    )
{
    if (!o_pUnk)
        return E_INVALIDARG;

    if (i_refiid == __uuidof(IDataObject))
        *o_pUnk = (IDataObject *)this;
    else if (i_refiid == __uuidof(IUnknown))
        *o_pUnk = (IUnknown *)this;
    else
        return E_NOINTERFACE;

    m_dwRefCount++;

    return S_OK;
}

unsigned long __stdcall
CMmcDisplay::AddRef()
{
    m_dwRefCount++;
    return(m_dwRefCount);
}

unsigned long __stdcall
CMmcDisplay::Release()
{
    m_dwRefCount--;

    if (0 == m_dwRefCount)
    {
      delete this;
      return 0;
    }

    return(m_dwRefCount);
}

//
// Saves the CLSID of the object.
//
STDMETHODIMP
CMmcDisplay::put_CoClassCLSID(IN CLSID newVal)
{
    ZeroMemory(&m_CLSIDClass, sizeof m_CLSIDClass);

    m_CLSIDClass = newVal;

    return S_OK;
}

STDMETHODIMP 
CMmcDisplay::GetDataHere(
    IN  LPFORMATETC             i_lpFormatetc,
    OUT LPSTGMEDIUM             o_lpMedium
    )
/*++
Routine Description:
    Return the Data expected. The clipboard format specifies what kind of data
    is expected.

Arguments:
    i_lpFormatetc   -   Indicates what kind of data is expected back.
    o_lpMedium      -   The data is return here.
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpFormatetc);
    RETURN_INVALIDARG_IF_NULL(o_lpMedium);

    // Based on the required clipboard format, write data to the stream
    const CLIPFORMAT        clipFormat = i_lpFormatetc->cfFormat;

    if ( clipFormat == mMMC_CF_NodeType )               // CCF_NODETYPE
        return WriteToStream(reinterpret_cast<const void*>(&m_CLSIDNodeType), sizeof(m_CLSIDNodeType), o_lpMedium);


    if ( clipFormat == mMMC_CF_Dfs_Snapin_Internal )    // CCF_DFS_SNAPIN_INTERNAL
    {
        PVOID pThis = this;
        return WriteToStream(reinterpret_cast<const void*>(&pThis), sizeof(pThis), o_lpMedium);
    }

    if ( clipFormat == mMMC_CF_NodeTypeString )         // CCF_SZNODETYPE
        return WriteToStream(m_bstrDNodeType, (m_bstrDNodeType.Length() + 1) * sizeof(TCHAR), o_lpMedium);

    if ( clipFormat == mMMC_CF_DisplayName )            // CCF_DISPLAY_NAME
    {
        CComBSTR bstrDisplayName;
        LoadStringFromResource(IDS_NODENAME, &bstrDisplayName);
        return WriteToStream(bstrDisplayName, (bstrDisplayName.Length() + 1) * sizeof(TCHAR), o_lpMedium);
    }

    if ( clipFormat == mMMC_CF_CoClass )                // CCF_SNAPIN_CLASSID
        return  WriteToStream(reinterpret_cast<const void*>(&m_CLSIDClass), sizeof(m_CLSIDClass), o_lpMedium);

    return DV_E_CLIPFORMAT;
}


HRESULT
CMmcDisplay::WriteToStream(
    IN const void*              i_pBuffer,
    IN int                      i_iBufferLen,
    OUT LPSTGMEDIUM             o_lpMedium
    )
/*++

Routine Description:

    Writes data given in a buffer to a Global stream created on a handle passed in
    the STGMEDIUM structure.
    Only HGLOBAL is supported as the medium

Arguments:

    i_pBuffer       -   The buffer to be written to the stream
    i_iBufferLen    -   The length of the buffer.
    o_lpMedium      -   The data is return here.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pBuffer);
    RETURN_INVALIDARG_IF_NULL(o_lpMedium);

    if (i_iBufferLen <= 0)
        return E_INVALIDARG;

    // Make sure the type medium is HGLOBAL
    if (TYMED_HGLOBAL != o_lpMedium->tymed)
        return DV_E_TYMED;

                                // Create the stream on the hGlobal passed in
    LPSTREAM lpStream = NULL;
    HRESULT  hr = CreateStreamOnHGlobal(o_lpMedium->hGlobal, FALSE, &lpStream);

    if (SUCCEEDED(hr))
    {
        // Write to the stream the number of bytes
        ULONG ulBytesWritten = 0;
        hr = lpStream->Write(i_pBuffer, i_iBufferLen, &ulBytesWritten);

        // Only the stream is released here. The caller will free the HGLOBAL
        lpStream->Release();
    }

    return hr;
}

// Add images for the result pane. 
// A snap-in must load and destroy its image bitmap each time it responds to 
// a MMCN_ADD_IMAGES notification; failure to do so can result in undesirable
//  results if the user changes display settings.
HRESULT
CMmcDisplay::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi)
{
    HRESULT hr = S_OK;
    HBITMAP pBMapSm = NULL;
    HBITMAP pBMapLg = NULL;
    if (!(pBMapSm = LoadBitmap(_Module.GetModuleInstance(),
                               MAKEINTRESOURCE(IDB_SCOPE_IMAGES_16x16))) ||
        !(pBMapLg = LoadBitmap(_Module.GetModuleInstance(),
                                MAKEINTRESOURCE(IDB_SCOPE_IMAGES_32x32))))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    } else
    {
        hr = pImageList->ImageListSetStrip(
                             (LONG_PTR *)pBMapSm,
                             (LONG_PTR *)pBMapLg,
                             0,
                             RGB(255, 0, 255)
                             );
    }
    if (pBMapSm)
        DeleteObject(pBMapSm);
    if (pBMapLg)
        DeleteObject(pBMapLg);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcjp.cpp ===
/*++
Module Name:

    MmcJP.cpp

Abstract:

    This module contains the implementation for CMmcDfsJP. This is an class 
  for MMC display related calls for the second level node(the Junction Point nodes)

--*/

#include "stdafx.h"
#include "Utils.h"      // For the LoadStringFromResource method
#include "resource.h"    // For the Resource ID for strings, etc.
#include "DfsGUI.h"
#include "MmcAdmin.h"
#include "MmcRoot.h"
#include "MmcRep.h"
#include "MenuEnum.h"    // Contains the menu and toolbar command ids
#include "AddToDfs.h"
#include "AddRep.h"
#include "MmcJP.h"
#include "DfsNodes.h"       // For Node GUIDs
#include "DfsEnums.h"    // For DFS_TYPE_STANDALONE and other DfsRoot declarations
#include "NewFrs.h"

const int CMmcDfsJunctionPoint::m_iIMAGEINDEX = 12;
const int CMmcDfsJunctionPoint::m_iOPENIMAGEINDEX = 12;

CMmcDfsJunctionPoint::CMmcDfsJunctionPoint(
    IN  IDfsJunctionPoint*      i_pDfsJPObject,
    IN  CMmcDfsRoot*            i_pDfsParentRoot,
    IN  LPCONSOLENAMESPACE      i_lpConsoleNameSpace
  )
{
    dfsDebugOut((_T("CMmcDfsJunctionPoint::CMmcDfsJunctionPoint this=%p\n"), this));

    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pDfsJPObject);
    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pDfsParentRoot);
    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_lpConsoleNameSpace);

    m_pDfsJPObject = i_pDfsJPObject;
    m_pDfsParentRoot = i_pDfsParentRoot;

    HRESULT hr = m_pDfsJPObject->get_EntryPath(&m_bstrEntryPath);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
    hr = m_pDfsJPObject->get_JunctionName(FALSE, &m_bstrDisplayName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    m_lJunctionState = DFS_JUNCTION_STATE_UNASSIGNED;

    m_lpConsoleNameSpace = i_lpConsoleNameSpace;  // The Callback used to do Scope Pane operations
    m_lpConsole = m_pDfsParentRoot->m_lpConsole;
    m_hScopeItem = NULL;              // Scopeitem handle

    m_CLSIDNodeType = s_guidDfsJPNodeType;
    m_bstrDNodeType = s_tchDfsJPNodeType;

    m_bShowFRS = FALSE;

    m_bDirty = false;
}

CMmcDfsJunctionPoint :: ~CMmcDfsJunctionPoint(
  )
{
    // Silently close outstanding property sheet.
    ClosePropertySheet(TRUE);

    CleanResultChildren();

    if ((IReplicaSet *)m_piReplicaSet)
        m_piReplicaSet.Release();

    dfsDebugOut((_T("CMmcDfsJunctionPoint::~CMmcDfsJunctionPoint this=%p\n"), this));
}




STDMETHODIMP 
CMmcDfsJunctionPoint::AddMenuItems(
    IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
    IN LPLONG                   i_lpInsertionAllowed
  )
/*++

Routine Description:

This routine adds the context menu for Junction point nodes using the ContextMenuCallback 
provided.

Arguments:

    lpContextMenuCallback - A callback(function pointer) that is used to add the menu items

    lpInsertionAllowed - Specifies what menus can be added and where they can be added.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);

    enum 
    {  
        IDM_CONTEXTMENU_COMMAND_MAX = IDM_JUNCTION_MAX,
        IDM_CONTEXTMENU_COMMAND_MIN = IDM_JUNCTION_MIN
    };


    LONG  lInsertionPoints [IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] = { 
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP
                        };

    LPTSTR aszLanguageIndependentName[IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] =
                        {
                        _T("JunctionTopNewDfsReplica"),
                        _T("JunctionTopCheckStatus"),
                        _T("JunctionTopRemoveFromDfs"),
                        _T("JunctionTopReplicationTopology"),
                        _T("JunctionTopShowReplication"),
                        _T("JunctionTopHideReplication"),
                        _T("JunctionTopStopReplication")
                        };

    CComPtr<IContextMenuCallback2> spiCallback2;
    HRESULT hr = i_lpContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void **)&spiCallback2);
    RETURN_IF_FAILED(hr);

    if (m_MmcRepList.empty())
        m_lpConsole->SelectScopeItem(m_hScopeItem);

    BOOL    bReplicaSetExist = FALSE;
    hr = m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);

                                // we start with the first menu command id and continue till the last.
    for (int iCommandID = IDM_CONTEXTMENU_COMMAND_MIN, iMenuResource = IDS_MENUS_JUNCTION_TOP_NEW_DFS_REPLICA ;
        iCommandID <= IDM_CONTEXTMENU_COMMAND_MAX; 
        iCommandID++,iMenuResource++)
    {  
        CONTEXTMENUITEM2    ContextMenuItem;
        ZeroMemory(&ContextMenuItem, sizeof(ContextMenuItem));

        switch (iCommandID)
        {
        case IDM_JUNCTION_TOP_REPLICATION_TOPOLOGY:
            {
                if (bReplicaSetExist || (1 >= m_MmcRepList.size()) ||
                    (DFS_TYPE_STANDALONE == m_pDfsParentRoot->m_lDfsRootType))
                    continue;
                break;
            }
        case IDM_JUNCTION_TOP_SHOW_REPLICATION:
            {
                if (!bReplicaSetExist || m_bShowFRS)
                    continue;
                break;
            }
        case IDM_JUNCTION_TOP_HIDE_REPLICATION:
            {
                if (!bReplicaSetExist || !m_bShowFRS)
                    continue;
                break;
            }
        case IDM_JUNCTION_TOP_STOP_REPLICATION:
            {
                if (!bReplicaSetExist)
                    continue;
                break;
            }
        }

        CComBSTR bstrMenuText;
        CComBSTR bstrStatusBarText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, NULL, &bstrStatusBarText);
        RETURN_IF_FAILED(hr);  

        ContextMenuItem.strName = bstrMenuText;
        ContextMenuItem.strStatusBarText = bstrStatusBarText;
        ContextMenuItem.lInsertionPointID = lInsertionPoints[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];
        ContextMenuItem.lCommandID = iCommandID;
        ContextMenuItem.strLanguageIndependentName = aszLanguageIndependentName[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];

        LONG        lInsertionFlag = 0;
        switch(ContextMenuItem.lInsertionPointID)
        {
        case CCM_INSERTIONPOINTID_PRIMARY_TOP:
            lInsertionFlag = CCM_INSERTIONALLOWED_TOP;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_NEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_NEW;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_TASK:
            lInsertionFlag = CCM_INSERTIONALLOWED_TASK;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_VIEW;
            break;
        default:
            break;
        }

        if (*i_lpInsertionAllowed & lInsertionFlag)
        {
            hr = spiCallback2->AddItem(&ContextMenuItem);
            RETURN_IF_FAILED(hr);
        }
    }

    return hr;
}


STDMETHODIMP  
CMmcDfsJunctionPoint::Command(
  IN LONG          i_lCommandID
  )
/*++

Routine Description:

  Action to be taken on a context menu selection or click is takes place.

Arguments:

    lCommandID - The Command ID of the menu for which action has to be taken

--*/
{
    HRESULT hr = S_OK;

    switch (i_lCommandID)
    {
    case IDM_JUNCTION_TOP_NEW_DFS_REPLICA:    // "Add a replica to the Dfs Junction Point"
        hr = OnNewReplica();
        break;
    case IDM_JUNCTION_TOP_REMOVE_FROM_DFS:    // "Delete the junction point"
        hr = DoDelete();
        break;
    case IDM_JUNCTION_TOP_REPLICATION_TOPOLOGY:
        hr = OnNewReplicaSet();
        break;
    case IDM_JUNCTION_TOP_SHOW_REPLICATION:
    case IDM_JUNCTION_TOP_HIDE_REPLICATION:
        m_bShowFRS = !m_bShowFRS;
        hr = OnShowReplication();
        break;
    case IDM_JUNCTION_TOP_STOP_REPLICATION:
        hr = OnStopReplication(TRUE);
        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);
        break;
    case IDM_JUNCTION_TOP_CHECK_STATUS:
        hr = OnCheckStatus();
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

HRESULT CMmcDfsJunctionPoint::_InitReplicaSet()
{
    DFS_TYPE lDfsType = DFS_TYPE_UNASSIGNED;
    HRESULT hr = GetDfsType((long *)&lDfsType);
    RETURN_IF_FAILED(hr);
    if (lDfsType != DFS_TYPE_FTDFS)
        return S_FALSE;  // no replica set associate with standalone root

    BOOL bReplicaSetExist = FALSE;
    CComBSTR bstrDC;
    hr = m_pDfsJPObject->get_ReplicaSetExistEx(&bstrDC, &bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    if (!bReplicaSetExist)
    {
        if ((IReplicaSet *)m_piReplicaSet)
            m_piReplicaSet.Release();

        return S_FALSE;  // no replica set associate with it
    }

    if ((IReplicaSet *)m_piReplicaSet)
    {
        CComBSTR bstrTargetedDC;
        hr = m_piReplicaSet->get_TargetedDC(&bstrTargetedDC);
        if (FAILED(hr) || lstrcmpi(bstrTargetedDC, bstrDC))
        {
            // something is wrong or we're using a different DC, re-init m_piReplicaSet
            m_piReplicaSet.Release();
        }
    }

    //
    // read info of the replica set from DS
    //
    if (!m_piReplicaSet)
    {
        CComBSTR bstrDomain;
        hr = GetDomainName(&bstrDomain);
        RETURN_IF_FAILED(hr);

        CComBSTR bstrReplicaSetDN;
        hr = m_pDfsJPObject->get_ReplicaSetDN(&bstrReplicaSetDN);
        RETURN_IF_FAILED(hr);

        hr = CoCreateInstance(CLSID_ReplicaSet, NULL, CLSCTX_INPROC_SERVER, IID_IReplicaSet, (void**) &m_piReplicaSet);
        RETURN_IF_FAILED(hr);

        hr = m_piReplicaSet->Initialize(bstrDomain, bstrReplicaSetDN);
        if (FAILED(hr))
        {
            m_piReplicaSet.Release();
            return hr;
        }
    }

    return hr;
}

HRESULT
CMmcDfsJunctionPoint::OnNewReplicaSet()
{
    //
    // refresh to pick up possible namespace updates on targets by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this link has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
        return hr;
    }

    CWaitCursor wait;

    //
    // Use MMC main window as the parent as our modal wizard
    //
    HWND  hwndParent = 0;
    hr = m_lpConsole->GetMainWindow(&hwndParent);
    RETURN_IF_FAILED(hr);

    BOOL    bReplicaSetExist = FALSE;
    m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);
    if (bReplicaSetExist) // replica set exist, return
        return S_OK;

    CComBSTR bstrDomain;
    hr = GetDomainName(&bstrDomain);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrReplicaSetDN;
    hr = m_pDfsJPObject->get_ReplicaSetDN(&bstrReplicaSetDN);
    RETURN_IF_FAILED(hr);

    CNewReplicaSet      ReplicaSetInfo;
    hr = ReplicaSetInfo.Initialize(bstrDomain, bstrReplicaSetDN, &m_MmcRepList);
    RETURN_IF_FAILED(hr);
    
    if (S_FALSE == hr) // more than one targets on the same computer
    {
        if (IDYES != DisplayMessageBox(::GetActiveWindow(), MB_YESNO, 0, IDS_MSG_TARGETS_ONSAMECOMPUTER))
            return hr;
    }
    CNewReplicaSetPage0      WizPage0;
    CNewReplicaSetPage1      WizPage1(&ReplicaSetInfo);
    CNewReplicaSetPage2      WizPage2(&ReplicaSetInfo, IsNewSchema());

    CComPtr<IPropertySheetCallback>  pPropSheetCallback;  // MMC Callback used to add pages
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetCallback, reinterpret_cast<void**>(&pPropSheetCallback));
    RETURN_IF_FAILED(hr);

    CComPtr<IPropertySheetProvider>  pPropSheetProvider;  // MMC callback used to handle wizard
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetProvider, reinterpret_cast<void**>(&pPropSheetProvider));
    RETURN_IF_FAILED(hr);

    hr = pPropSheetProvider->CreatePropertySheet(  
                                _T(""), // title
                                FALSE,  // Wizard and not property sheet.
                                0,      // Cookie
                                NULL,   // IDataobject
                                MMC_PSO_NEWWIZARDTYPE);  // Creation flags

    if (SUCCEEDED(hr))
    {
        pPropSheetCallback->AddPage(WizPage0.Create());
        pPropSheetCallback->AddPage(WizPage1.Create());
        pPropSheetCallback->AddPage(WizPage2.Create());

        hr = pPropSheetProvider->AddPrimaryPages(
                                    NULL,
                                    FALSE,    // Don't create a notify handle
                                    NULL, 
                                    TRUE    // Scope pane (not result pane)
                                    );

        if (SUCCEEDED(hr))
            hr = pPropSheetProvider->Show((LONG_PTR)hwndParent, 0);

        //
        // If failed, call IPropertySheetProvider::Show(-1,0) to 
        // delete the property sheet and free its resources
        //
        if (FAILED(hr))
            pPropSheetProvider->Show(-1, 0);
    }

    RETURN_IF_FAILED(hr);

    //
    // handle th result
    //
    if (S_OK == ReplicaSetInfo.m_hr)
    {
        //
        // store the interface pointer
        //
        m_piReplicaSet = ReplicaSetInfo.m_piReplicaSet;
        m_pDfsJPObject->put_ReplicaSetExist(TRUE);

        //
        // update icon
        //
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.nImage += 4;
            ScopeDataItem.nOpenImage += 4;
            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);

            // update the toolbar
            m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);
        }
    }

    return hr;
}

HRESULT CMmcDfsJunctionPoint::OnShowReplication()
{
    BOOL bShowFRS = m_bShowFRS; // save it because refresh will reset it to FALSE

    //
    // refresh to pick up possible namespace updates on targets by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this link has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
        return hr;
    }

    CWaitCursor wait;

    DFS_REPLICA_LIST::iterator i;
    if (bShowFRS)
    {
        hr = _InitReplicaSet();
        if (S_OK != hr) // no replica set, do nothing and return
            return S_OK;

        //
        // fill in each alternate m_bstrFRSColumnText and m_bstrStatusText
        //
        for (i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
        {
            ((*i)->pReplica)->ShowReplicationInfo(m_piReplicaSet);
        }

        m_bShowFRS = TRUE;
    }

    // update the toolbar
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return hr;
}

HRESULT
CMmcDfsJunctionPoint::OnStopReplication(BOOL bConfirm /* = FALSE */, BOOL bRefresh /* = TRUE */)
{
    HRESULT hr = S_OK;

    //
    // refresh to pick up possible namespace updates on targets by others
    //
    if (bRefresh)
    {
        hr = OnRefresh();
        if (S_FALSE == hr)
        {
            // this link has been deleted by others, no more reference
            DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
            return hr;
        }
    }

    CWaitCursor wait;

    BOOL    bReplicaSetExist = FALSE;
    m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);
    if (!bReplicaSetExist) // replica set doesn't exist, return
        return S_OK;

    if (bConfirm)
    {
        hr = ConfirmOperationOnDfsLink(IDS_MSG_STOP_REPLICATION);
        if (S_OK != hr) return hr;
    }

    //
    // init m_piReplicaSet
    //
    hr = _InitReplicaSet();
    if (S_OK != hr) // no replica set, return
        return hr;

    hr = m_piReplicaSet->Delete();
    if (SUCCEEDED(hr))
    {
        m_piReplicaSet.Release();
        hr = m_pDfsJPObject->put_ReplicaSetExist(FALSE);

        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.nImage -= 4;
            ScopeDataItem.nOpenImage -= 4;
            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);

            // update the toolbar
            m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);
        }

        if (m_bShowFRS)
        { 
            m_bShowFRS = FALSE;
            OnShowReplication();
        }
    }

    return hr;
}

STDMETHODIMP  
CMmcDfsJunctionPoint::SetColumnHeader(
  IN LPHEADERCTRL2       i_piHeaderControl
  )
{
    RETURN_INVALIDARG_IF_NULL(i_piHeaderControl);

    CComBSTR  bstrColumn0;
    HRESULT hr = LoadStringFromResource(IDS_RESULT_COLUMN_REPLICA, &bstrColumn0);
    RETURN_IF_FAILED(hr);

    CComBSTR  bstrColumn1;
    hr = LoadStringFromResource(IDS_RESULT_COLUMN_DFSREFERRAL, &bstrColumn1);
    RETURN_IF_FAILED(hr);

    CComBSTR  bstrColumn2;
    hr = LoadStringFromResource(IDS_RESULT_COLUMN_STATUS, &bstrColumn2);
    RETURN_IF_FAILED(hr);

    i_piHeaderControl->InsertColumn(0, bstrColumn0, LVCFMT_LEFT, DFS_NAME_COLUMN_WIDTH);
    i_piHeaderControl->InsertColumn(1, bstrColumn1, LVCFMT_LEFT, MMCLV_AUTO);
    i_piHeaderControl->InsertColumn(2, bstrColumn2, LVCFMT_LEFT, MMCLV_AUTO);

    if (m_bShowFRS)
    {
        CComBSTR  bstrColumn3;
        hr = LoadStringFromResource(IDS_RESULT_COLUMN_FRS, &bstrColumn3);
        RETURN_IF_FAILED(hr);

        i_piHeaderControl->InsertColumn(3, bstrColumn3, LVCFMT_LEFT, MMCLV_AUTO);
    } else
    {
        i_piHeaderControl->DeleteColumn(3);
    }

    return hr;
}




STDMETHODIMP  
CMmcDfsJunctionPoint::GetResultDisplayInfo(
  IN OUT LPRESULTDATAITEM    io_pResultDataItem
  )
/*++

Routine Description:

Returns the information required for MMC display for this item.

Arguments:

    io_pResultDataItem - The ResultItem which specifies what display information is required

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pResultDataItem);

    if (RDI_IMAGE & io_pResultDataItem->mask)
        io_pResultDataItem->nImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + m_lJunctionState;

    if (RDI_STR & io_pResultDataItem->mask)
    {
        if (0 == io_pResultDataItem->nCol)
            io_pResultDataItem->str = m_bstrDisplayName;
    }

    return S_OK;
}




STDMETHODIMP 
CMmcDfsJunctionPoint::GetScopeDisplayInfo(
  IN OUT  LPSCOPEDATAITEM    io_pScopeDataItem
  )
/*++

Routine Description:

Returns the information required for MMC display for this item.

Arguments:

    i_pScopeDataItem - The ScopeItem which specifies what display information is required

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pScopeDataItem);

    if (SDI_STR & io_pScopeDataItem->mask)
        io_pScopeDataItem->displayname = m_bstrDisplayName;

    if (SDI_IMAGE & io_pScopeDataItem->mask)
        io_pScopeDataItem->nImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + m_lJunctionState;

    if (SDI_OPENIMAGE & io_pScopeDataItem->mask)
        io_pScopeDataItem->nOpenImage = CMmcDfsRoot::m_iOPENIMAGEINDEX + m_lJunctionState;

    return S_OK;
};

STDMETHODIMP
CMmcDfsJunctionPoint::EnumerateScopePane(
    IN LPCONSOLENAMESPACE		i_lpConsoleNameSpace,
    IN HSCOPEITEM				i_hParent
)
{
    return S_OK; // no scope pane children
}

STDMETHODIMP  
CMmcDfsJunctionPoint::EnumerateResultPane(
  IN OUT IResultData*      io_pResultData
  )
/*++

Routine Description:

To eumerate(add) items in the result pane. Replicas in this case

Arguments:

  io_pResultData - The callback used to add items to the Result pane

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pResultData);
    HRESULT  hr = S_OK;

    if (m_MmcRepList.empty())
    {
        CComPtr<IEnumVARIANT>      pRepEnum;
        hr = m_pDfsJPObject->get__NewEnum ((IUnknown**) &pRepEnum);
        RETURN_IF_FAILED(hr);

        VARIANT varReplicaObject;
        VariantInit(&varReplicaObject);
        while ( S_OK == (hr = pRepEnum->Next(1, &varReplicaObject, NULL)) )
        {
            CComPtr<IDfsReplica>  pReplicaObject;
            pReplicaObject = (IDfsReplica*) varReplicaObject.pdispVal;

            CMmcDfsReplica* pMMCReplicaObject = new CMmcDfsReplica(pReplicaObject, this);
            if (!pMMCReplicaObject)
            {
                hr = E_OUTOFMEMORY;
            } else
            {
                hr = pMMCReplicaObject->m_hrValueFromCtor;
                if (SUCCEEDED(hr))
                {
                    hr = pMMCReplicaObject->AddItemToResultPane(io_pResultData);
                    if (SUCCEEDED(hr))
                    {
                        REP_LIST_NODE*  pRepNode = new REP_LIST_NODE(pMMCReplicaObject);
                        if (!pRepNode)
                        {
                            hr = E_OUTOFMEMORY;
                        } else
                        {
                            m_MmcRepList.push_back(pRepNode);
                        }
                    }
                }

                if (FAILED(hr))
                  delete pMMCReplicaObject;
            }

            VariantClear(&varReplicaObject);

            if (FAILED(hr))
                break;
        }

    }
    else
    {
                    // The replicas of this junction are already enumerated,
                    // and the list exists, just add result items.
        for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
        {
            hr = ((*i)->pReplica)->AddItemToResultPane(io_pResultData);
            BREAK_IF_FAILED(hr);
        }
    }

    return hr;
}


STDMETHODIMP 
CMmcDfsJunctionPoint::SetConsoleVerbs(
  IN  LPCONSOLEVERB      i_lpConsoleVerb
  ) 
/*++

Routine Description:

  Routine used to set the console verb settings.
  Sets all of them except Open off. 
  For all scope pane items, default verb is "open'. For result items, 
  it is "properties"


Arguments:

    i_lpConsoleVerb -  The callback used to handle console verbs
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpConsoleVerb);

  i_lpConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
    
  i_lpConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);            

  i_lpConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);  //For scope items, default verb is "open"

  return S_OK; 
}

/*
Case1: add to a n-targets-link (repOn or repOff) which has actually been deleted by another DfsGui instance
    result: refresh the root (the whole namespace), put up the retry message
Case2: add to a n-targets-link (repOn) whose targets have been partly deleted and whose replication has been turned off by another DfsGui instance
    result: refresh the link, add the new target, if (checked && #targets>1), invoke the RepCfg wizard
Case3: add to a n-targets-link (repOn) whose targets have been partly deleted and whose replication has still been kept on by another DfsGui instance
    result: refresh the link, add the new target, if (checked && #targets>1), join the new target to replication set
Case4: add to a n-targets-link (repOn), no other DfsGui instances are involved
    result: refresh the link, add the new target, if (checked && #targets>1), join the new target to replication set
Case5: add to a n-targets-link (repOff), no other DfsGui instances are involved
    result: refresh the link, add the new target, if (checked && #targets>1), invoke the RepCfg wizard
*/

STDMETHODIMP  
CMmcDfsJunctionPoint::OnNewReplica(
  )
/*++

Routine Description:

  Adds a new replica to the Junction Point.

--*/
{
  HRESULT           hr = S_OK;
  CAddRep           AddRepDlg;
  CComBSTR          bstrServerName;
  CComBSTR          bstrShareName;
  CComBSTR          bstrNetPath;
  
  AddRepDlg.put_EntryPath(m_bstrEntryPath);
  AddRepDlg.put_DfsType(m_pDfsParentRoot->m_lDfsRootType);
  hr = AddRepDlg.DoModal();
  if (S_OK != hr)
    return hr;

  AddRepDlg.get_Server(&bstrServerName);
  AddRepDlg.get_Share(&bstrShareName);
  AddRepDlg.get_NetPath(&bstrNetPath);

/* bug#290375: both UI and core should allow interlink to have multiple targets
                // Is it a dfs based path? These are not allowed.
  if (IsDfsPath(bstrNetPath))
  {
    DisplayMessageBoxWithOK( IDS_MSG_MID_JUNCTION, bstrNetPath);    
    return(S_OK);
  }
*/

  //
  // refresh to pick up possible namespace updates on this link or link targets
  //
  hr = OnRefresh();
  if (S_FALSE == hr)
  {
      //
      // this link has been deleted by other means, scope pane has been refreshed,
      // ask user to retry
      //
      DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
      return hr;
  }

  CWaitCursor wait;

  CComPtr<IDfsReplica>  pReplicaObject;
  CMmcDfsReplica*       pMMCReplicaObject = NULL;
  VARIANT   varReplicaObject;
  VariantInit(&varReplicaObject);

  hr = m_pDfsJPObject->AddReplica(bstrServerName, bstrShareName, &varReplicaObject);
  if (FAILED(hr))
  {
    DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_FAILED_TO_CREATE_REPLICA);

    return hr;
  }

                // Get the IDfsReplica interface.
  pReplicaObject = (IDfsReplica*) varReplicaObject.pdispVal;

                // Create display object.
  pMMCReplicaObject = new CMmcDfsReplica(pReplicaObject, this);
  if (!pMMCReplicaObject)
    return E_OUTOFMEMORY;

                // Add item to replica list and update 
                // Result view.
  AddResultPaneItem(pMMCReplicaObject);
  m_bDirty = true;

  //
  // If requested and the link has more than 1 target, configure file replication
  //
  if (CAddRep::NORMAL_REPLICATION == AddRepDlg.get_ReplicationType() && (m_MmcRepList.size() > 1))
  {
    BOOL    bReplicaSetExist = FALSE;
    hr = m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    if (!bReplicaSetExist)
    {
        if (IDYES == DisplayMessageBox(::GetActiveWindow(), MB_YESNO, 0, IDS_MSG_NEWFRS_NOW))
            hr = OnNewReplicaSet();
    } else
    {
        hr = pMMCReplicaObject->OnReplicate();
    }
  }
  
  return hr;
}


STDMETHODIMP  
CMmcDfsJunctionPoint::AddItemToScopePane(
  IN  HSCOPEITEM        i_hParent
  )
{
    HRESULT hr = S_OK;
    BOOL    bReplicaSetExist = FALSE;
    hr = m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);

    if (SUCCEEDED(hr))
    {
        SCOPEDATAITEM        JPScopeDataItem;
        memset (&JPScopeDataItem, 0, sizeof(SCOPEDATAITEM));

        JPScopeDataItem.mask =  SDI_PARENT | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_STR | SDI_CHILDREN;
        JPScopeDataItem.relativeID = i_hParent;        //ID of DfsRoot Node
        JPScopeDataItem.nImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + (bReplicaSetExist ? 4 : 0);
        JPScopeDataItem.nOpenImage = CMmcDfsJunctionPoint::m_iOPENIMAGEINDEX + (bReplicaSetExist ? 4 : 0);
        JPScopeDataItem.lParam = reinterpret_cast<LPARAM> (this);
        JPScopeDataItem.displayname = MMC_TEXTCALLBACK ;

        hr = m_lpConsoleNameSpace->InsertItem(&JPScopeDataItem);
        if (SUCCEEDED(hr))
            m_hScopeItem = JPScopeDataItem.ID;
    }

    return hr;
}



STDMETHODIMP 
CMmcDfsJunctionPoint :: OnRemoveJP (IN BOOL bConfirm) 
/*++

Routine Description:

  This internal method handles the removal of Junction Points.

--*/
{
    // check outstanding property sheet.
    HRESULT hr = ClosePropertySheet(!bConfirm);

    if (bConfirm)
    {
        if (S_OK != hr) // open property page found, discontinue
            return hr;

        hr = ConfirmOperationOnDfsLink(IDS_MSG_REMOVE_JP);
        if(S_OK != hr)      // Error or User decided to abort the operation
            return hr;
    }

    CWaitCursor    WaitCursor;  // Display the wait cursor

    // Delete the associated replica set
    hr = _InitReplicaSet();
    if (S_OK == hr)
    {
        m_piReplicaSet->Delete();
        m_pDfsJPObject->put_ReplicaSetExist(FALSE);
        m_piReplicaSet.Release();
    }

    return m_pDfsParentRoot->DeleteMmcJPNode(this, bConfirm);
}

HRESULT
CMmcDfsJunctionPoint::ClosePropertySheet(BOOL bSilent)
{
    if (!m_PropPage.m_hWnd && !m_frsPropPage.m_hWnd)
        return S_OK; // no outstanding property sheet, return S_OK;

    CComPtr<IPropertySheetProvider>  pPropSheetProvider;
    HRESULT hr = m_lpConsole->QueryInterface(IID_IPropertySheetProvider, reinterpret_cast<void**>(&pPropSheetProvider));

    if (FAILED(hr))
    {
        hr = S_OK; // ignore the QI failure
    } else
    {
        //
        // find the outstanding property sheet and bring it to foreground
        //
        hr = pPropSheetProvider->FindPropertySheet((MMC_COOKIE)m_hScopeItem, NULL, this);
        if (S_OK == hr)
        {
            if (bSilent)
            {
                //
                // silently close outstanding property sheet, and return S_OK to continue user's operation
                //
                if (m_PropPage.m_hWnd)
                    ::SendMessage(m_PropPage.m_hWnd, WM_PARENT_NODE_CLOSING, 0, 0);

                if (m_frsPropPage.m_hWnd)
                    ::SendMessage(m_frsPropPage.m_hWnd, WM_PARENT_NODE_CLOSING, 0, 0);
            } else
            {
                //
                // ask user to close it, return S_FALSE to quit user's operation
                //
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_PROPERTYPAGE_NOTCLOSED);
                return S_FALSE;
            }
        } else
        {
            hr = S_OK; // no outstanding property sheet, return S_OK
        }
    }
    
    //
    // reset HWND
    //
    m_PropPage.m_hWnd = NULL;
    m_frsPropPage.m_hWnd = NULL;

    return hr;
}

STDMETHODIMP 
CMmcDfsJunctionPoint::ConfirmOperationOnDfsLink(int idString) 
/*++

Routine Description:

  Asks the user for confirmation of whether he really wants to remove the particular 
  Junction point.

Return value:

  S_OK, if the user chooses YES,
  S_FALSE, if the user chooses NO.

--*/
{
    CComBSTR    bstrAppName;
    HRESULT hr = LoadStringFromResource (IDS_APPLICATION_NAME, &bstrAppName);
    RETURN_IF_FAILED(hr);

    CComBSTR    bstrFormattedMessage;
    hr = FormatResourceString(idString, m_bstrEntryPath, &bstrFormattedMessage);
    RETURN_IF_FAILED(hr);

    CThemeContextActivator activator;
    if (IDNO == ::MessageBox(::GetActiveWindow(), bstrFormattedMessage, bstrAppName, MB_YESNO | MB_ICONEXCLAMATION | MB_APPLMODAL))
        return S_FALSE;

    return S_OK;
}


//
// Call the root's RemoveJP() method
//
STDMETHODIMP 
CMmcDfsJunctionPoint::DoDelete(
    ) 
{ 
    return m_pDfsParentRoot->RemoveJP(this, m_bstrDisplayName);
}

STDMETHODIMP 
CMmcDfsJunctionPoint::QueryPagesFor(
  )
/*++

Routine Description:

  Used to decide whether the object wants to display property pages.
  Returning S_OK typically results in a call to CreatePropertyPages.

--*/
{
    //
    // refresh to pick up possible namespace updates by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this link has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
        return hr; // no property page
    }

    return S_OK; // yes, we want to display a propertysheet
}



// Creates and passes back the pages to be displayed
STDMETHODIMP 
CMmcDfsJunctionPoint::CreatePropertyPages(
  IN LPPROPERTYSHEETCALLBACK      i_lpPropSheetCallback,
  IN LONG_PTR                i_lNotifyHandle
  )
/*++

Routine Description:

  Used to display the property sheet pages

Arguments:

  i_lpPropSheetCallback  -  The callback used to create the propertysheet.
  i_lNotifyHandle      -  Notify handle used by the property page

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpPropSheetCallback);

    m_lpConsole->SelectScopeItem(m_hScopeItem);

    CWaitCursor WaitCursor;
    HRESULT     hr = S_OK;

    do {
        hr = m_PropPage.Initialize(NULL, (IDfsJunctionPoint*)m_pDfsJPObject);
        BREAK_IF_FAILED(hr);

                // Create the page for the replica set.
                // Pass it to the Callback
        HPROPSHEETPAGE  h_proppage = m_PropPage.Create();
        if (!h_proppage)
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            break;
        }

              // Pass on the notify data to the Property Page
        hr = m_PropPage.SetNotifyData(i_lNotifyHandle, (LPARAM)this);
        BREAK_IF_FAILED (hr);

        hr = i_lpPropSheetCallback->AddPage(h_proppage);
        BREAK_IF_FAILED (hr);

        //
        // Add "Replica Set" page
        //
        hr = CreateFrsPropertyPage(i_lpPropSheetCallback, i_lNotifyHandle);
        if (S_OK != hr)
        {
            if (FAILED(hr))
                DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_REPPAGE_ERROR);
            hr = S_OK; // allow the other tabs to be brought up
        }
    } while (0);

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return hr;
}

STDMETHODIMP 
CMmcDfsJunctionPoint::CreateFrsPropertyPage
(
  IN LPPROPERTYSHEETCALLBACK    i_lpPropSheetCallback,
  IN LONG_PTR                   i_lNotifyHandle
)
{
    HRESULT hr = _InitReplicaSet();
    if (S_OK != hr)
        return hr;

    CComBSTR bstrType;
    hr = m_piReplicaSet->get_Type(&bstrType);
    RETURN_IF_FAILED(hr);

    if (lstrcmpi(bstrType, FRS_RSTYPE_DFS))
        return hr;

    //
    // set initial values on the property page
    //
    hr = m_frsPropPage.Initialize(m_piReplicaSet);
    RETURN_IF_FAILED(hr);

    //
    // create the property page
    //
    HPROPSHEETPAGE  h_frsproppage = m_frsPropPage.Create();
    if (!h_frsproppage)
        return HRESULT_FROM_WIN32(::GetLastError());

    //
    // pass on the notify data to the Property Page
    //
    hr = m_frsPropPage.SetNotifyData(i_lNotifyHandle, (LPARAM)this);
    RETURN_IF_FAILED(hr);

    //
    // AddPage
    //
    return i_lpPropSheetCallback->AddPage(h_frsproppage);
}


STDMETHODIMP 
CMmcDfsJunctionPoint::PropertyChanged(
    )
/*++

Routine Description:

  Used to update the properties.

--*/
{
  return S_OK;
}



HRESULT
CMmcDfsJunctionPoint::SetDescriptionBarText(
  IN LPRESULTDATA            i_lpResultData
  )
/*++

Routine Description:

  A routine used set the text in the Description bar above 
  the result view.

Arguments:
  i_lpResultData  -  Pointer to the IResultData callback which is
            used to set the description text
--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpResultData);

  CComBSTR  bstrTextForDescriptionBar;  // Text to be shown in the Result view Description bar
  HRESULT hr = FormatResourceString(IDS_DESCRIPTION_BAR_TEXT_JUNCTIONPOINT, m_bstrEntryPath, &bstrTextForDescriptionBar);
  RETURN_IF_FAILED(hr);

  hr = i_lpResultData->SetDescBarText(bstrTextForDescriptionBar);

  return hr;
}

HRESULT 
CMmcDfsJunctionPoint::ToolbarSelect(
  IN const LONG          i_lArg,
  IN  IToolbar*          i_pToolBar
  )
/*++

Routine Description:

  Handle a select event for a toolbar
  Create a toolbar, it it doesn't exist.
  Attach the toolbar and enable the buttons, if the event for a selection.
  Disable the buttons, if the event was for a deselection

Arguments:
  i_lArg        -  The argument passed to the actual method.
  o_pToolBar      -  The Toolbar pointer.

--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pToolBar);

    BOOL    bSelect = (BOOL) HIWORD(i_lArg);  // Is the event for selection?
    EnableToolbarButtons(i_pToolBar, IDT_JP_MIN, IDT_JP_MAX, bSelect);

    if (bSelect)
    {
        BOOL    bReplicaSetExist = FALSE;
        HRESULT hr = m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);
        RETURN_IF_FAILED(hr);

        if (bReplicaSetExist || (1 >= m_MmcRepList.size()) ||
            (DFS_TYPE_STANDALONE == m_pDfsParentRoot->m_lDfsRootType))
        {
            i_pToolBar->SetButtonState(IDT_JP_REPLICATION_TOPOLOGY, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_JP_REPLICATION_TOPOLOGY, HIDDEN, TRUE);
        }

        if (!bReplicaSetExist)
        {
            i_pToolBar->SetButtonState(IDT_JP_SHOW_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_JP_SHOW_REPLICATION, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_JP_HIDE_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_JP_HIDE_REPLICATION, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_JP_STOP_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_JP_STOP_REPLICATION, HIDDEN, TRUE);
        } else
        {
            if (m_bShowFRS)
            {
                i_pToolBar->SetButtonState(IDT_JP_SHOW_REPLICATION, ENABLED, FALSE);
                i_pToolBar->SetButtonState(IDT_JP_SHOW_REPLICATION, HIDDEN, TRUE);
            } else
            {
                i_pToolBar->SetButtonState(IDT_JP_HIDE_REPLICATION, ENABLED, FALSE);
                i_pToolBar->SetButtonState(IDT_JP_HIDE_REPLICATION, HIDDEN, TRUE);
            }
        }
    }

    return S_OK; 
}




HRESULT
CMmcDfsJunctionPoint::CreateToolbar(
  IN const LPCONTROLBAR      i_pControlbar,
  IN const LPEXTENDCONTROLBAR          i_lExtendControlbar,
  OUT  IToolbar**          o_pToolBar
  )
/*++

Routine Description:

  Create the toolbar.
  Involves the actual toolbar creation call, creating the bitmap and adding it
  and finally adding the buttons to the toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lExtendControlbar  -  The object implementing IExtendControlbar. This is 
              the class exposed to MMC.

--*/
{
  RETURN_INVALIDARG_IF_NULL(i_pControlbar);
  RETURN_INVALIDARG_IF_NULL(i_lExtendControlbar);
  RETURN_INVALIDARG_IF_NULL(o_pToolBar);

  CComBSTR  bstrAllTheMenuText;    
  int      iButtonPosition = 0;    // The first button position

                      // Create the toolbar
  HRESULT hr = i_pControlbar->Create(TOOLBAR, i_lExtendControlbar, reinterpret_cast<LPUNKNOWN*>(o_pToolBar));
  RETURN_IF_FAILED(hr);

                      // Add the bitmap to the toolbar
  hr = AddBitmapToToolbar(*o_pToolBar, IDB_JP_TOOLBAR);
  RETURN_IF_FAILED(hr);

  for (int iCommandID = IDT_JP_MIN, iMenuResource = IDS_MENUS_JUNCTION_TOP_NEW_DFS_REPLICA;
     iCommandID <= IDT_JP_MAX; 
     iCommandID++,iMenuResource++,iButtonPosition++)
  {
    CComBSTR bstrMenuText;
    CComBSTR bstrToolTipText;
    hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, &bstrToolTipText, NULL);
    RETURN_IF_FAILED(hr);  

    MMCBUTTON      ToolbarButton;
    ZeroMemory(&ToolbarButton, sizeof ToolbarButton);

    ToolbarButton.nBitmap  = iButtonPosition;
    ToolbarButton.idCommand = iCommandID;
    ToolbarButton.fsState = TBSTATE_ENABLED;
    ToolbarButton.fsType = TBSTYLE_BUTTON;
    ToolbarButton.lpButtonText = bstrMenuText;
    ToolbarButton.lpTooltipText = bstrToolTipText;


                          // Add the button to the toolbar
    hr = (*o_pToolBar)->InsertButton(iButtonPosition, &ToolbarButton);
    _ASSERTE(S_OK == hr);            // Assert, but continue as we want to try other buttons
  }


  return S_OK;
}



STDMETHODIMP 
CMmcDfsJunctionPoint::ToolbarClick(
  IN const LPCONTROLBAR            i_pControlbar, 
  IN const LPARAM                i_lParam
  ) 
/*++

Routine Description:

  Action to take on a click on a toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lParam      -  The lparam to the actual notify. This is the command id of
              the button on which a click occurred.

Return value:

    S_OK, if successful.
   E_INVALID_ARG, if any of the arguments is null
  Another other value returned from the called methods.
--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);

    HRESULT    hr = S_OK;

    switch(i_lParam)        // What button did the user click on.
    {
    case IDT_JP_NEW_DFS_REPLICA:      // "New Replica"
        hr = OnNewReplica();
        break;
    case IDT_JP_REMOVE_FROM_DFS:      // "Remove Junction Point"
        hr = DoDelete();
        break;
    case IDT_JP_REPLICATION_TOPOLOGY:    // "Replication Topology"
        hr = OnNewReplicaSet();
        break;
    case IDT_JP_SHOW_REPLICATION:
    case IDT_JP_HIDE_REPLICATION:
        m_bShowFRS = !m_bShowFRS;
        hr = OnShowReplication();
        break;
    case IDT_JP_STOP_REPLICATION:
        hr = OnStopReplication(TRUE);
        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);
        break;
    case IDT_JP_CHECK_STATUS:        // "Check Status"
        hr = OnCheckStatus ();
        break;
    default:
        hr = E_INVALIDARG;
        break;
    };

    return hr; 
}




HRESULT
CMmcDfsJunctionPoint::OnRefresh(
  )
/*++

Routine Description:

  Refreshes the junction point.

--*/
{
    // Select this node first
    m_lpConsole->SelectScopeItem(m_hScopeItem);

    CWaitCursor    WaitCursor;  // Display the wait cursor

    HRESULT hr = S_OK;

    // silently close outstanding property sheet.
    ClosePropertySheet(TRUE);

                    // Re-Initialize!
    BOOL bReplicaSetExist = FALSE;
    CComBSTR bstrDC;
    (void)m_pDfsJPObject->get_ReplicaSetExistEx(&bstrDC, &bReplicaSetExist);

    CComBSTR bstrReplicaSetDN;
    if (bReplicaSetExist)
    {
      (void)m_pDfsJPObject->get_ReplicaSetDN(&bstrReplicaSetDN);
    }

    m_bShowFRS = FALSE;
    if ((IReplicaSet *)m_piReplicaSet)
        m_piReplicaSet.Release();

    CleanResultChildren();

    hr = m_pDfsJPObject->Initialize((IUnknown *)(m_pDfsParentRoot->m_DfsRoot), m_bstrEntryPath, bReplicaSetExist, bstrReplicaSetDN);
    if (S_OK != hr) // fail to init the link or no such link any more, refresh the whole root
    {
        m_pDfsParentRoot->OnRefresh();
        return S_FALSE;   // indicate the current m_pDfsJPObject should NOT be used any more
    }

    // set the link icon
    if (m_lpConsoleNameSpace != NULL)
    {
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
            ScopeDataItem.nImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + (bReplicaSetExist ? 4 : 0);
            ScopeDataItem.nOpenImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + (bReplicaSetExist ? 4 : 0);

            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);
        }
    }

    // re-display the result pane
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return S_OK;
}

STDMETHODIMP CMmcDfsJunctionPoint::RemoveFromMMC()
{
    HRESULT hr = S_OK;

    if (m_hScopeItem)
    {
        // delete result pane items
        m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 0);

        // delete itself from MMC scope pane
        (void)m_lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);

        m_hScopeItem = NULL;
    }

    return S_OK;
}

STDMETHODIMP CMmcDfsJunctionPoint::CleanResultChildren(
    )
{
    if (!m_MmcRepList.empty())
    {
        // delete result pane items
        m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 0);

        // clean up display objects
        for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
        {
            delete (*i);
        }
        m_MmcRepList.erase(m_MmcRepList.begin(), m_MmcRepList.end());
    }

    return(S_OK);
}


STDMETHODIMP 
CMmcDfsJunctionPoint::OnCheckStatus(
    ) 
/*++

Routine Description:

  This method checks the state of the replica.

--*/
{ 
    //
    // refresh to pick up possible namespace updates on targets by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this link has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
        return hr;
    }

    CWaitCursor wait;

    UINT nTotal = m_MmcRepList.size();
    _ASSERT(nTotal != 0);

    UINT nMappingOn = 0;
    UINT nMappingOff = 0;
    UINT nUnreachable = 0;
                // Update state of all replicas also.
    for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
    {
        (*i)->pReplica->OnCheckStatus();

        if (DFS_TARGET_STATE_UNREACHABLE == (*i)->pReplica->m_lTargetState)
        {
            nUnreachable++;
        } else
        {
            switch ((*i)->pReplica->m_lReferralState)
            {
            case DFS_REFERRAL_STATE_ONLINE:
                nMappingOn++;
                break;
            case DFS_REFERRAL_STATE_OFFLINE:
                nMappingOff++;
                break;
            default:
                _ASSERT(FALSE);
                break;
            }
        }
    }

    if (0xffffffff != GetFileAttributes(m_bstrEntryPath))
    {
        if (nTotal == nMappingOn)
        {
            m_lJunctionState = DFS_JUNCTION_STATE_ALL_REP_OK;
        } else if (nTotal != (nMappingOff + nUnreachable))
        {
            m_lJunctionState = DFS_JUNCTION_STATE_NOT_ALL_REP_OK;
        } else
        {
            m_lJunctionState = DFS_JUNCTION_STATE_UNREACHABLE;
        }
    } else
    {
        m_lJunctionState = DFS_JUNCTION_STATE_UNREACHABLE;
    }

    BOOL    bReplicaSetExist = FALSE;
    hr = m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    if (m_lpConsoleNameSpace != NULL)
    {
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        RETURN_IF_FAILED(hr);

        ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        ScopeDataItem.nImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + (bReplicaSetExist ? 4 : 0) + m_lJunctionState;
        ScopeDataItem.nOpenImage = CMmcDfsJunctionPoint::m_iIMAGEINDEX + (bReplicaSetExist ? 4 : 0) + m_lJunctionState;

        hr = m_lpConsoleNameSpace->SetItem(&ScopeDataItem);
        RETURN_IF_FAILED(hr);
    }

    return hr;
}


STDMETHODIMP CMmcDfsJunctionPoint::ViewChange(
    IResultData*    i_pResultData,
    LONG_PTR        i_lHint
  )
/*++

Routine Description:

  This method handles the MMCN_VIEW_CHANGE notification.
  This updates the result view for the scope node on which the
  UpdateAllViews was called.

  if (0 == i_lHint) clean result pane only.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pResultData);
    i_pResultData->DeleteAllRsltItems();

    CComPtr<IHeaderCtrl2> spiHeader;
    HRESULT hr = i_pResultData->QueryInterface(IID_IHeaderCtrl2, reinterpret_cast<void**>(&spiHeader));
    RETURN_IF_FAILED(hr);

    if (m_bShowFRS)
    {
        CComBSTR  bstrColumn3;
        hr = LoadStringFromResource(IDS_RESULT_COLUMN_FRS, &bstrColumn3);
        RETURN_IF_FAILED(hr);

        spiHeader->DeleteColumn(3);
        spiHeader->InsertColumn(3, bstrColumn3, LVCFMT_LEFT, MMCLV_AUTO);
    } else
    {
        spiHeader->DeleteColumn(3);
    }

                // Re-display the view
    if (i_lHint)
        EnumerateResultPane(i_pResultData);

    return(S_OK);
}

STDMETHODIMP CMmcDfsJunctionPoint::AddResultPaneItem(
  CMmcDfsReplica*    i_pReplicaDispObject
  )
/*++

Routine Description:

  This method adds a new replica object to the list of replicas displayed
  in the result view.

Arguments:

  i_pReplicaDispObject - The CMmcReplica display object pointer..

--*/
{
    REP_LIST_NODE*  pNewReplica = new REP_LIST_NODE(i_pReplicaDispObject);
    if (!pNewReplica)
        return E_OUTOFMEMORY;

                    // Sort isnert. Find insertion position.
    for (DFS_REPLICA_LIST::iterator j = m_MmcRepList.begin(); j != m_MmcRepList.end(); j++)
    {
        if (lstrcmpi(pNewReplica->pReplica->m_bstrDisplayName, (*j)->pReplica->m_bstrDisplayName) <= 0)
            break;
    }

    m_MmcRepList.insert(j, pNewReplica);

    BOOL bReplicaSetExist = FALSE;
    m_pDfsJPObject->get_ReplicaSetExist(&bReplicaSetExist);

    if (bReplicaSetExist && m_bShowFRS)
    {
        i_pReplicaDispObject->ShowReplicationInfo(m_piReplicaSet);
    }
                    // Re-display to display this item.
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return S_OK;
}

//
// This function is called when removing a target from the result pane
//
STDMETHODIMP CMmcDfsJunctionPoint::RemoveReplica(LPCTSTR i_pszDisplayName)
{
    if (!i_pszDisplayName)
        return E_INVALIDARG;

    //
    // refresh to pick up possible namespace updates on targets by other means
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this link has already been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_LINK);
        return hr;
    }

    CWaitCursor wait;

    //
    // locate the correct target to remove, then call back.
    //
    for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
    {
        if (!lstrcmpi((*i)->pReplica->m_bstrDisplayName, i_pszDisplayName))
        {
            hr = (*i)->pReplica->RemoveReplica();
            break;
        }
    }

    return hr;
}

STDMETHODIMP CMmcDfsJunctionPoint::RemoveResultPaneItem(
  CMmcDfsReplica*    i_pReplicaDispObject
  )
/*++

Routine Description:

  This method adds a new replica object to the list of replicas displayed
  in the result view.

Arguments:

  i_pReplicaDispObject - The CMmcReplica display object pointer..

--*/
{
  dfsDebugOut((_T("CMmcDfsJunctionPoint::RemoveResultPaneItem replist=%d\n"), m_MmcRepList.size()));

  // Remove item from list.
  for (DFS_REPLICA_LIST::iterator i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
  {
    if ((*i)->pReplica == i_pReplicaDispObject)
    {
      delete (*i);
      m_MmcRepList.erase(i);
      break;
    }
  }

              // Last node is removed.
  if (m_MmcRepList.empty())
  {
    // silently close any open property sheet
    ClosePropertySheet(TRUE);

    return m_pDfsParentRoot->DeleteMmcJPNode(this);
  }
  else
  {
                  // Re-display to remove this item.
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);
  }

  return S_OK;
}

HRESULT CMmcDfsJunctionPoint::GetIReplicaSetPtr(IReplicaSet** o_ppiReplicaSet)
{
    RETURN_INVALIDARG_IF_NULL(o_ppiReplicaSet);

    HRESULT hr = _InitReplicaSet();
    if (S_OK == hr)
    {
        m_piReplicaSet.p->AddRef();
        *o_ppiReplicaSet = m_piReplicaSet;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcjp.h ===
/*++
Module Name:

    MmcJP.h

Abstract:

    This module contains the definition for CMmcDfsJunctionPoint class. This is an class 
    for MMC display related calls for the second level node(the DfsJunctionPoint nodes)

--*/


#if !defined(AFX_MMCDFSJP_H__6A7EDAC3_3FAC_11D1_AA1C_00C06C00392D__INCLUDED_)
#define AFX_MMCDFSJP_H__6A7EDAC3_3FAC_11D1_AA1C_00C06C00392D__INCLUDED_



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "DfsCore.h"
#include "MmcDispl.h"
#include "JPProp.h"            // For CReplicaSetPropPage
#include "frsProp.h"            // For CRealReplicaSetPropPage

// Forward declarations
class CMmcDfsAdmin;
class CMmcDfsRoot;
class CMmcDfsReplica;

class CMmcDfsJunctionPoint : public CMmcDisplay  
{
public:
    // Constructor
    CMmcDfsJunctionPoint (
        IN    IDfsJunctionPoint*        i_pDfsJPObject,
        IN    CMmcDfsRoot*            i_pDfsParentRoot,
        IN    LPCONSOLENAMESPACE        i_lpConsoleNameSpace
        );

    virtual ~CMmcDfsJunctionPoint();


    // For adding context menu items
    STDMETHOD(AddMenuItems)(    
        IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
        IN LPLONG                    i_lpInsertionAllowed
        );



    // For taking action on a context menu selection.
    STDMETHOD(Command)(
        IN LONG                        i_lCommandID
        );



    // Set the headers for the listview (in the result pane) column
    STDMETHOD(SetColumnHeader)(
        IN LPHEADERCTRL2               i_piHeaderControl
        );



    // Return the requested display information for the Result Pane
    STDMETHOD(GetResultDisplayInfo)(
        IN OUT LPRESULTDATAITEM        io_pResultDataItem
        );

    

    // Return the requested display information for the Scope Pane
    STDMETHOD(GetScopeDisplayInfo)(
        IN OUT  LPSCOPEDATAITEM        io_pScopeDataItem    
        );

    

    // Add items(or folders), if any to the Scope Pane
    STDMETHOD(EnumerateScopePane)(
        IN LPCONSOLENAMESPACE        i_lpConsoleNameSpace,
        IN HSCOPEITEM                i_hParent
        );



    // Add items(or folders), if any to the Result Pane
    STDMETHOD(EnumerateResultPane)(
        IN OUT     IResultData*            io_pResultData
        );



    // Set the console verb settings. Change the state, decide the default verb, etc
    STDMETHOD(SetConsoleVerbs)(
        IN    LPCONSOLEVERB                i_lpConsoleVerb
        );


    // let MMC handle the default verb.
    STDMETHOD(DoDblClick)(
    )  { return S_FALSE; }


    // Delete the current item.
    STDMETHOD(DoDelete)(
        );



    // Checks whether the object has pages to display
    STDMETHOD(QueryPagesFor)(
        );



    // Creates and passes back the pages to be displayed
    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK            i_lpPropSheetCallback,
        IN LONG_PTR                                i_lNotifyHandle
        );

    STDMETHOD(CreateFrsPropertyPage)(
        IN LPPROPERTYSHEETCALLBACK    i_lpPropSheetCallback,
        IN LONG_PTR                   i_lNotifyHandle
        );

    // Used to notify the object that it's properties have changed
    STDMETHOD(PropertyChanged)(
        );



    // Used to set the result view description bar text
    STDMETHOD(SetDescriptionBarText)(
        IN LPRESULTDATA                        i_lpResultData
        );


    STDMETHOD(SetStatusText)(
        IN LPCONSOLE2                        i_lpConsole
        )
    { 
        RETURN_INVALIDARG_IF_NULL(i_lpConsole);
        return i_lpConsole->SetStatusText(NULL);
    }

                                                        // Add an item to the scope pane
    STDMETHOD(AddItemToScopePane)(
        IN    HSCOPEITEM                    i_hParent
        );

    // Handle a select event for the node. Handle only toolbar related 
    // activities here
    STDMETHOD(ToolbarSelect)(
        IN const LONG                                i_lArg,
        IN    IToolbar*                                i_pToolBar
        );

    HRESULT CreateToolbar(
        IN const LPCONTROLBAR            i_pControlbar,
        IN const LPEXTENDCONTROLBAR                    i_lExtendControlbar,
        OUT    IToolbar**                    o_pToolBar
        );


    // Handle a click on the toolbar
    STDMETHOD(ToolbarClick)(
        IN const LPCONTROLBAR                        i_pControlbar, 
        IN const LPARAM                                i_lParam
        );

    DISPLAY_OBJECT_TYPE GetDisplayObjectType() { return DISPLAY_OBJECT_TYPE_JUNCTION; }

    HRESULT OnRefresh(
        );

    // helpers
private:                                                // For add Replica
    STDMETHOD(OnNewReplica)(
        );


                                                        // For deleteing Junction Point
    STDMETHOD(OnRemoveJP)(IN BOOL bConfirm = TRUE
        );

                                                        // Ask confirmation from the user
    STDMETHOD(ConfirmOperationOnDfsLink)(int idString);


    STDMETHOD(RemoveFromMMC)();

    STDMETHOD(CleanScopeChildren)() { return S_OK; }

    STDMETHOD(CleanResultChildren)(
        );

    // Check the replica status
    STDMETHOD(OnCheckStatus)(
        );

    STDMETHOD(ViewChange)(
        IResultData*        i_pResultData,
        LONG_PTR            i_lHint
    );

    STDMETHOD(AddResultPaneItem)(
        CMmcDfsReplica*        i_pReplicaDispObject
        );

    STDMETHOD(RemoveReplica)(LPCTSTR i_pszDisplayName);

    STDMETHOD(RemoveResultPaneItem)(
        CMmcDfsReplica*        i_pReplicaDispObject
        );

    HRESULT ClosePropertySheet(BOOL bSilent);

    STDMETHOD(GetEntryPath)(BSTR*   o_pbstrEntryPath) 
    { GET_BSTR(m_bstrEntryPath, o_pbstrEntryPath); }

    inline HRESULT GetDomainName(BSTR* pVal) 
    { return (m_pDfsParentRoot->m_DfsRoot)->get_DomainName(pVal); }

    inline HRESULT GetDfsType(long* pVal) 
    { return (m_pDfsParentRoot->m_DfsRoot)->get_DfsType(pVal); }

    BOOL get_ShowFRS() { return m_bShowFRS; }

    HRESULT _InitReplicaSet();

    HRESULT OnNewReplicaSet();

    HRESULT OnShowReplication();

    HRESULT OnStopReplication(BOOL bConfirm=FALSE, BOOL bRefresh=TRUE);

    HRESULT GetIReplicaSetPtr(IReplicaSet** o_ppiReplicaSet);

    BOOL IsNewSchema() { return m_pDfsParentRoot->IsNewSchema(); }

    // Constants, Statics, etc
public:
    static const int            m_iIMAGEINDEX;
    static const int            m_iOPENIMAGEINDEX;

private:
    friend class CMmcDfsRoot;
    friend class CMmcDfsReplica;

    CComPtr<IConsoleNameSpace>    m_lpConsoleNameSpace;    // The Callback used to do Scope Pane operations
    CComPtr<IConsole2>            m_lpConsole;  // The Console callback.
    HSCOPEITEM                    m_hScopeItem;            // Scopeitem handle
    
    CComBSTR                    m_bstrEntryPath;        // EntryPath;
    CComBSTR                    m_bstrDisplayName;        // Display name of the current JP
    long                        m_lJunctionState;

    DFS_REPLICA_LIST            m_MmcRepList;            // The list of replicas

    CComPtr<IDfsJunctionPoint>    m_pDfsJPObject;
    CMmcDfsRoot*                m_pDfsParentRoot;
    CComPtr<IReplicaSet>        m_piReplicaSet;

    CReplicaSetPropPage         m_PropPage;
    CRealReplicaSetPropPage     m_frsPropPage;
    BOOL                        m_bShowFRS;

    bool                        m_bDirty;                // Tells if a replica is added or removed.
};

#endif // !defined(AFX_MMCDFSJP_H__6A7EDAC3_3FAC_11D1_AA1C_00C06C00392D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcrep.cpp ===
/*++
Module Name:

    MmcRep.cpp

Abstract:

    This module contains the implementation for CMmcDfsReplica. This is an class 
  for MMC display related calls for the third level node(the Replica nodes)

--*/

#include "stdafx.h"
#include "DfsGUI.h"
#include "Utils.h"      // For the LoadStringFromResource method
#include "MenuEnum.h"    // Contains the menu and toolbar command ids
#include "resource.h"    // For the Resource ID for strings, etc.
#include "MmcRep.h"
#include "DfsEnums.h"
#include "DfsNodes.h"       // For Node GUIDs
#include "MmcRoot.h"
#include "netutils.h"
#include "staging.h"

HRESULT GetReplicationText(
    IN BOOL                     i_bFRSMember,
    IN CAlternateReplicaInfo*   i_pRepInfo,
    OUT BSTR*                   o_pbstrColumnText,
    OUT BSTR*                   o_pbstrStatusBarText
    );

const int CMmcDfsReplica::m_iIMAGE_OFFSET = 20;


//////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor For   _DFS_REPLICA_LIST

REP_LIST_NODE :: REP_LIST_NODE (CMmcDfsReplica* i_pMmcReplica)      
{
  pReplica = i_pMmcReplica;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// destructor

REP_LIST_NODE :: ~REP_LIST_NODE ()
{
  SAFE_RELEASE(pReplica);
}


CMmcDfsReplica::CMmcDfsReplica(
  IN IDfsReplica*           i_pReplicaObject,
  IN CMmcDfsJunctionPoint*  i_pJPObject
  )
{
    dfsDebugOut((_T("CMmcDfsReplica::CMmcDfsReplica this=%p\n"), this));

    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pReplicaObject);
    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pJPObject);

    m_pDfsReplicaObject = i_pReplicaObject;
    m_pDfsParentJP = i_pJPObject;
    m_pDfsParentRoot = NULL;

    m_pRepInfo = NULL;
    m_bFRSMember = FALSE;

    // Get the display name from the IDfsReplica
    HRESULT hr = m_pDfsReplicaObject->get_StorageServerName(&m_bstrServerName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
    hr = m_pDfsReplicaObject->get_StorageShareName(&m_bstrShareName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
    hr = GetDfsReplicaDisplayName(m_bstrServerName, m_bstrShareName, &m_bstrDisplayName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    hr = m_pDfsReplicaObject->get_State(&m_lReferralState);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    if (DFS_REFERRAL_STATE_ONLINE == m_lReferralState)
        LoadStringFromResource(IDS_ENABLED, &m_bstrDfsReferralColumnText);
    else
        LoadStringFromResource(IDS_DISABLED, &m_bstrDfsReferralColumnText);

    m_lTargetState = DFS_TARGET_STATE_UNASSIGNED;
    LoadStringFromResource(IDS_TARGET_STATUS_UNKNOWN, &m_bstrTargetStatusColumnText);

    m_CLSIDNodeType = s_guidDfsReplicaNodeType;
    m_bstrDNodeType = s_tchDfsReplicaNodeType;
}



CMmcDfsReplica::CMmcDfsReplica(
  IN IDfsReplica*        i_pReplicaObject,
  IN CMmcDfsRoot*        i_pRootObject
  )
{
    dfsDebugOut((_T("CMmcDfsReplica::CMmcDfsReplica this=%p\n"), this));

    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pReplicaObject);
    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pRootObject);

    m_pDfsReplicaObject = i_pReplicaObject;
    m_pDfsParentRoot = i_pRootObject;
    m_pDfsParentJP  = NULL;

    m_pRepInfo = NULL;
    m_bFRSMember = FALSE;

    // Get the display name from the IDfsReplica
    HRESULT hr = m_pDfsReplicaObject->get_StorageServerName(&m_bstrServerName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
    hr = m_pDfsReplicaObject->get_StorageShareName(&m_bstrShareName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
    hr = GetDfsReplicaDisplayName(m_bstrServerName, m_bstrShareName, &m_bstrDisplayName);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    hr = m_pDfsReplicaObject->get_State(&m_lReferralState);
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    if (DFS_REFERRAL_STATE_ONLINE == m_lReferralState)
        LoadStringFromResource(IDS_ENABLED, &m_bstrDfsReferralColumnText);
    else
        LoadStringFromResource(IDS_DISABLED, &m_bstrDfsReferralColumnText);

    m_lTargetState = DFS_TARGET_STATE_UNASSIGNED;
    LoadStringFromResource(IDS_TARGET_STATUS_UNKNOWN, &m_bstrTargetStatusColumnText);

    m_CLSIDNodeType = s_guidDfsReplicaNodeType;
    m_bstrDNodeType = s_tchDfsReplicaNodeType;
}



CMmcDfsReplica::~CMmcDfsReplica(
)
{
    if (m_pRepInfo)
        delete m_pRepInfo;

    dfsDebugOut((_T("CMmcDfsReplica::~CMmcDfsReplica this=%p\n"), this));
}




STDMETHODIMP 
CMmcDfsReplica :: AddMenuItems(
  IN LPCONTEXTMENUCALLBACK  i_lpContextMenuCallback, 
  IN LPLONG          i_lpInsertionAllowed
)
/*++

Routine Description:

This routine adds the context menu for Replica nodes using the ContextMenuCallback 
provided.

Arguments:

    lpContextMenuCallback - A callback(function pointer) that is used to add the menu items

    lpInsertionAllowed - Specifies what menus can be added and where they can be added.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);

    enum 
    {  
        IDM_CONTEXTMENU_COMMAND_MAX = IDM_REPLICA_MAX,
        IDM_CONTEXTMENU_COMMAND_MIN = IDM_REPLICA_MIN
    };

    LONG  lInsertionPoints [IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] = { 
                      CCM_INSERTIONPOINTID_PRIMARY_TOP,
                      CCM_INSERTIONPOINTID_PRIMARY_TOP,
                      CCM_INSERTIONPOINTID_PRIMARY_TOP,
                      CCM_INSERTIONPOINTID_PRIMARY_TOP,
                      CCM_INSERTIONPOINTID_PRIMARY_TOP,
                      CCM_INSERTIONPOINTID_PRIMARY_TOP
                      };

    LPTSTR aszLanguageIndependentName[IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] =
                        {
                        _T("ReplicaTopOpen"),
                        _T("ReplicaTopCheckStatus"),
                        _T("ReplicaTopTakeReplicaOfflineOnline"),
                        _T("ReplicaTopRemoveFromDfs"),
                        _T("ReplicaTopReplicate"),
                        _T("ReplicaTopStopReplication")
                        };

    CComPtr<IContextMenuCallback2> spiCallback2;
    HRESULT hr = i_lpContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void **)&spiCallback2);
    RETURN_IF_FAILED(hr);

    BOOL bShowFRS = FALSE;
    if (m_pDfsParentRoot)
        bShowFRS = m_pDfsParentRoot->get_ShowFRS();
    else
        bShowFRS = m_pDfsParentJP->get_ShowFRS();

    for (int iCommandID = IDM_CONTEXTMENU_COMMAND_MIN, iMenuResource = IDS_MENUS_REPLICA_TOP_OPEN;
            iCommandID <= IDM_CONTEXTMENU_COMMAND_MAX; 
            iCommandID++,iMenuResource++)
    {
        // No TakeOnlineOffline on root replicas
        if (m_pDfsParentRoot && IDM_REPLICA_TOP_TAKE_REPLICA_OFFLINE_ONLINE == iCommandID)
            continue;

        if (!bShowFRS &&
            (IDM_REPLICA_TOP_REPLICATE == iCommandID ||
            IDM_REPLICA_TOP_STOP_REPLICATION == iCommandID))
        {
            continue;
        }

        // bShowFRS is FALSE if it's a standalone DFS or user is not interested in seeing FRS info.
        // Hence, there is no need to retrieve replication info here. This will greatly improve PERF
        // especially when dealing with DFS hosted on standalone server, save us the call to DsGetDCName.
        if (bShowFRS && !m_pRepInfo)
            GetReplicationInfo();

        if (bShowFRS && m_pRepInfo && FRSSHARE_TYPE_OK != m_pRepInfo->m_nFRSShareType &&
            (IDM_REPLICA_TOP_REPLICATE == iCommandID ||
            IDM_REPLICA_TOP_STOP_REPLICATION == iCommandID))
        {
            continue;
        }

        if (m_bFRSMember &&
            IDM_REPLICA_TOP_REPLICATE == iCommandID)
        {
            continue;
        }

        if (!m_bFRSMember &&
            IDM_REPLICA_TOP_STOP_REPLICATION == iCommandID)
        {
            continue;
        }

        CComBSTR bstrMenuText;
        CComBSTR bstrStatusBarText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, NULL, &bstrStatusBarText);
        RETURN_IF_FAILED(hr);  

        CONTEXTMENUITEM2    ContextMenuItem;  // The structure which contains menu information
        ZeroMemory(&ContextMenuItem, sizeof(ContextMenuItem));
        ContextMenuItem.strName = bstrMenuText;
        ContextMenuItem.strStatusBarText = bstrStatusBarText;
        ContextMenuItem.lInsertionPointID = lInsertionPoints[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];
        ContextMenuItem.lCommandID = iCommandID;
        ContextMenuItem.strLanguageIndependentName = aszLanguageIndependentName[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];

        LONG        lInsertionFlag = 0;
        switch(ContextMenuItem.lInsertionPointID)
        {
        case CCM_INSERTIONPOINTID_PRIMARY_TOP:
            lInsertionFlag = CCM_INSERTIONALLOWED_TOP;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_NEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_NEW;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_TASK:
            lInsertionFlag = CCM_INSERTIONALLOWED_TASK;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_VIEW;
            break;
        default:
            break;
        }

        if (*i_lpInsertionAllowed & lInsertionFlag)
        {
            hr = spiCallback2->AddItem(&ContextMenuItem);
            RETURN_IF_FAILED(hr);
        }
    } // for

    return hr;
}




STDMETHODIMP 
CMmcDfsReplica::Command(
  IN LONG            i_lCommandID
  )
/*++

Routine Description:

  Action to be taken on a context menu selection or click is takes place.

Arguments:

    lCommandID - The Command ID of the menu for which action has to be taken

--*/
{
    HRESULT    hr = S_OK;

    switch (i_lCommandID)
    {
    case IDM_REPLICA_TOP_OPEN:
        hr = OnOpen();
        break;
    case IDM_REPLICA_TOP_REMOVE_FROM_DFS:
        hr = DoDelete();
        break;
    case IDM_REPLICA_TOP_CHECK_STATUS:
        hr = OnCheckStatus ();
        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);
        break;
    case IDM_REPLICA_TOP_TAKE_REPLICA_OFFLINE_ONLINE:
        hr = TakeReplicaOffline();
        break;
    case IDM_REPLICA_TOP_REPLICATE:
        {
            hr = m_pDfsReplicaObject->FindTarget();
            if (S_OK != hr)
            {
                //
                // the target has been deleted by others, refresh the root/link
                //
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_TARGET);
                if (m_pDfsParentRoot)
                    hr = m_pDfsParentRoot->OnRefresh();
                else
                    hr = m_pDfsParentJP->OnRefresh();
            } else
            {
                hr = OnReplicate ();
            }
            break;
        }
    case IDM_REPLICA_TOP_STOP_REPLICATION:
        {
            hr = m_pDfsReplicaObject->FindTarget();
            if (S_OK != hr)
            {
                //
                // the target has been deleted by others, refresh the root/link
                //
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_TARGET);
                if (m_pDfsParentRoot)
                    hr = m_pDfsParentRoot->OnRefresh();
                else
                    hr = m_pDfsParentJP->OnRefresh();
            } else
            {
                BOOL bRepSetExist = FALSE;
                hr = AllowFRSMemberDeletion(&bRepSetExist);
                if (bRepSetExist && SUCCEEDED(hr))
                {
                    if (S_OK == hr) 
                    {
                        hr = OnStopReplication(TRUE);
                        if (FAILED(hr))
                            DisplayMessageBoxForHR(hr);
                    }
                } else
                {
                    if (m_pDfsParentRoot)
                        hr = m_pDfsParentRoot->OnRefresh();
                    else
                        hr = m_pDfsParentJP->OnRefresh();
                }
            }
            break;
        }
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}




STDMETHODIMP 
CMmcDfsReplica::SetColumnHeader(
  IN LPHEADERCTRL2       i_piHeaderControl
  )
{
  return S_OK;
}




STDMETHODIMP 
CMmcDfsReplica::GetResultDisplayInfo(
  IN OUT LPRESULTDATAITEM    io_pResultDataItem
  )
/*++

Routine Description:

Returns the information required for MMC display for this item.

Arguments:

    io_pResultDataItem - The ResultItem which specifies what display information is required

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pResultDataItem);

    if (RDI_IMAGE & io_pResultDataItem->mask)
        io_pResultDataItem->nImage = CMmcDfsReplica::m_iIMAGE_OFFSET + m_lTargetState;

    if (RDI_STR & io_pResultDataItem->mask)
    {
        switch (io_pResultDataItem->nCol)
        {
        case 0:
            io_pResultDataItem->str = m_bstrDisplayName;
            break;
        case 1: // DFS Referral
            io_pResultDataItem->str = m_bstrDfsReferralColumnText;
            break;
        case 2: // Status
            io_pResultDataItem->str = m_bstrTargetStatusColumnText;
            break;
        case 3:
            io_pResultDataItem->str = m_bstrFRSColumnText;
            break;
        default:
            break;
        }
    }

    return S_OK;
}


STDMETHODIMP 
CMmcDfsReplica::SetConsoleVerbs(
  IN  LPCONSOLEVERB      i_lpConsoleVerb
  ) 
/*++

Routine Description:

  Routine used to set the console verb settings.
  Sets all of them except Open off. 
  For all scope pane items, default verb is "open'. For result items, 
  it is "properties"

Arguments:

    i_lpConsoleVerb -  The callback used to handle console verbs
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpConsoleVerb);

    i_lpConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
    i_lpConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);

    i_lpConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

    return S_OK; 
}


STDMETHODIMP 
CMmcDfsReplica::AddItemToResultPane (
  IResultData*        i_lpResultData
  ) 
/*++

Routine Description:

  Adds an item (a replica result pane item) to the result pane.

Arguments:

  i_lpResultData - The pointer to the IResultData interface on which InsertItem 
  will be called.

--*/
{
  RESULTDATAITEM        ReplicaResultDataItem;
  ZeroMemory(&ReplicaResultDataItem, sizeof(ReplicaResultDataItem));

  ReplicaResultDataItem.mask = RDI_PARAM | RDI_STR | RDI_IMAGE;
  ReplicaResultDataItem.lParam = reinterpret_cast<LPARAM> (this);
  ReplicaResultDataItem.str = MMC_TEXTCALLBACK;
  ReplicaResultDataItem.nImage = CMmcDfsReplica::m_iIMAGE_OFFSET + m_lTargetState;      // set the icon to the default status
                                      // i.e. no known status
  HRESULT hr = i_lpResultData -> InsertItem (&ReplicaResultDataItem);
  RETURN_IF_FAILED(hr);
  
  m_pResultData = i_lpResultData;
  m_hResultItem = ReplicaResultDataItem.itemID;

  return hr;
}


STDMETHODIMP 
CMmcDfsReplica :: RemoveReplica(
  ) 
/*++

Routine Description:

  Handles the removal of a replica from the replica set of a junction point.

--*/
{
    //
    // delete it from replica set
    //
    HRESULT hr = RemoveReplicaFromSet();
    RETURN_IF_FAILED(hr);

    CWaitCursor Wait;

    if (m_pDfsParentRoot)
    {
                      // This means that this is a root level replica.
                      // The removal of Root level Replica is by tearing
                      // down Dfs.
        CComBSTR  bstrFTDfsName;
        if (DFS_TYPE_FTDFS == m_pDfsParentRoot->m_lDfsRootType)
        {
            hr = m_pDfsParentRoot->m_DfsRoot->get_DfsName(&bstrFTDfsName);
            RETURN_IF_FAILED(hr);
        }

        hr = m_pDfsParentRoot->_DeleteDfsRoot(m_bstrServerName, m_bstrShareName, bstrFTDfsName);
        RETURN_IF_FAILED(hr);
    }
    else
    {
        hr = m_pDfsParentJP->m_pDfsJPObject->RemoveReplica(m_bstrServerName, m_bstrShareName);
        RETURN_IF_FAILED(hr);
    }

    m_pResultData->DeleteItem(m_hResultItem, 0);

          // Remove item from list and Re-display List.
    if (m_pDfsParentRoot)
        hr = m_pDfsParentRoot->RemoveResultPaneItem(this);
    else
        hr = m_pDfsParentJP->RemoveResultPaneItem(this);

    return hr;
}

//
// Call the corresponding root/link's RemoveReplica() method to:
// 1. refresh the root/link node to pick up possible namespace updates by others,
// 2. then locate the appropriate target to actually perform the removal operation.
//
STDMETHODIMP 
CMmcDfsReplica::OnRemoveReplica(
  ) 
{
    HRESULT hr = S_OK;

    if (m_pDfsParentRoot)
        hr = m_pDfsParentRoot->RemoveReplica(m_bstrDisplayName);
    else
        hr = m_pDfsParentJP->RemoveReplica(m_bstrDisplayName);

    return hr;
}


STDMETHODIMP 
CMmcDfsReplica :: ConfirmOperationOnDfsTarget(int idString)
/*++

Routine Description:

  Asks the user for confirmation of whether he really wants to remove the particular 
  replica from the replica set.

--*/
{
    CComBSTR    bstrAppName;
    HRESULT hr = LoadStringFromResource (IDS_APPLICATION_NAME, &bstrAppName);
    RETURN_IF_FAILED(hr);

    CComBSTR    bstrFormattedMessage;
    hr = FormatResourceString (idString, m_bstrDisplayName, &bstrFormattedMessage);
    RETURN_IF_FAILED(hr);

    CThemeContextActivator activator;
    if (IDNO == ::MessageBox(::GetActiveWindow(), bstrFormattedMessage, bstrAppName, MB_YESNO | MB_ICONEXCLAMATION | MB_APPLMODAL))
        return S_FALSE;

    return S_OK;
}

STDMETHODIMP 
CMmcDfsReplica::DoDelete(
    ) 
/*++

Routine Description:

  This method allows the item to delete itself.
  Called when DEL key is pressed or when the "Delete" context menu
  item is selected.

--*/
{
    HRESULT hr = S_OK;
    if (NULL != m_pDfsParentRoot)
        hr = m_pDfsParentRoot->ClosePropertySheet(FALSE);
    else
        hr = m_pDfsParentJP->ClosePropertySheet(FALSE);
    if (S_OK != hr)
        return hr; // if property page found, discontinue

    hr = ConfirmOperationOnDfsTarget(NULL != m_pDfsParentRoot ? IDS_MSG_REMOVE_ROOT_REPLICA : IDS_MSG_REMOVE_REPLICA);
    if(S_OK != hr)          // User decided to abort the operation
        return S_OK;

    CWaitCursor wait;

    BOOL bRepSetExist = FALSE;
    hr = AllowFRSMemberDeletion(&bRepSetExist);
    if (bRepSetExist && S_OK != hr)  // not allowed on a hub or user cancelled the operation
        return S_OK;

    hr = OnRemoveReplica();
    if(FAILED(hr) && !m_pDfsParentRoot) // For Root level replica 
                     // Error message is already displayed.
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_WIZ_DELETE_REPLICA_FAILURE);
    }

    return hr;
}

HRESULT CMmcDfsReplica::OnReplicate()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;
    
    CComPtr<IReplicaSet> piReplicaSet;
    if (m_pDfsParentRoot)
        hr = m_pDfsParentRoot->GetIReplicaSetPtr(&piReplicaSet);
    else
        hr = m_pDfsParentJP->GetIReplicaSetPtr(&piReplicaSet);
    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
        return hr;
    } else if (S_OK != hr) // no replica set on the corresponding link/root
        return hr;

    // refresh m_pRepInfo
    GetReplicationInfo();

    m_bFRSMember = FALSE;

    if (FRSSHARE_TYPE_OK != m_pRepInfo->m_nFRSShareType)
    {
        GetReplicationText(m_bFRSMember, m_pRepInfo, &m_bstrFRSColumnText, &m_bstrStatusText);
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, 
            IDS_MSG_ADDFRSMEMBER_FAILED_EX, m_pRepInfo->m_bstrDisplayName, m_bstrStatusText);
    } else
    {
        // confirm the staging path
        CStagingDlg dlg;
        hr = dlg.Init(m_pRepInfo);
        if (FAILED(hr))
        {
            DisplayMessageBoxForHR(hr);
            return hr;
        }

        dlg.DoModal();

        CWaitCursor wait;

        (void) CreateAndHideStagingPath(m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrStagingPath);

        hr = ConfigAndStartNtfrs(m_pRepInfo->m_bstrDnsHostName);
        if (SUCCEEDED(hr) || IDYES == DisplayMessageBox(
                                                ::GetActiveWindow(),
                                                MB_YESNO,
                                                hr,
                                                IDS_MSG_FRS_BADSERVICE,
                                                m_pRepInfo->m_bstrDisplayName,
                                                m_pRepInfo->m_bstrDnsHostName))
        {
            hr = AddFRSMember(piReplicaSet, m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrRootPath, m_pRepInfo->m_bstrStagingPath);

            if (S_OK == hr)
                m_bFRSMember = TRUE;
            else if (S_FALSE == hr)
            {
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_MSG_TARGETS_ONSAMECOMPUTER_1, m_pRepInfo->m_bstrDnsHostName);
            }

            GetReplicationText(m_bFRSMember, m_pRepInfo, &m_bstrFRSColumnText, &m_bstrStatusText);
        }
    }

    _UpdateThisItem();

    return hr;
}

HRESULT CMmcDfsReplica::OnStopReplication(BOOL bConfirm /* = FALSE */)
{
    HRESULT hr = S_OK;

    if (bConfirm)
    {
        hr = ConfirmOperationOnDfsTarget(IDS_MSG_STOP_REPLICATION_TARGET);
        if (S_OK != hr)
            return hr;
    }

    CWaitCursor wait;

    CComPtr<IReplicaSet> piReplicaSet;
    if (m_pDfsParentRoot)
        hr = m_pDfsParentRoot->GetIReplicaSetPtr(&piReplicaSet);
    else
        hr = m_pDfsParentJP->GetIReplicaSetPtr(&piReplicaSet);
    if (S_OK != hr) // no replica set on the corresponding link/root
        hr = S_OK;
    else
    {
        if (!m_pRepInfo)
            GetReplicationInfoEx(&m_pRepInfo);

        if (!m_pRepInfo->m_bstrDnsHostName || !m_pRepInfo->m_bstrRootPath)
        {
            hr = DeleteBadFRSMember(piReplicaSet, m_pRepInfo->m_bstrDisplayName, m_pRepInfo->m_hrFRS);

            if (S_FALSE == hr) // operation cancelled
                return hr;
        } else
        {
            hr = DeleteFRSMember(piReplicaSet, m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrRootPath);
        }
    }

    if (SUCCEEDED(hr))
    {
        m_bFRSMember = FALSE;

        m_bstrFRSColumnText.Empty();
        m_bstrStatusText.Empty();
        LoadStringFromResource(IDS_DISABLED, &m_bstrFRSColumnText);
        LoadStringFromResource(IDS_REPLICATION_STATUSBAR_NONMEMBER, &m_bstrStatusText);

        _UpdateThisItem();
    }

    return hr;
}

STDMETHODIMP 
CMmcDfsReplica::OnCheckStatus(
    ) 
/*++

Routine Description:

  This method checks the state of the replica.

--*/
{ 
    CWaitCursor WaitCursor;

    // check network connectivity from this client computer to this target
    m_bstrTargetStatusColumnText.Empty();
    if (0xffffffff == GetFileAttributes(m_bstrDisplayName))
    {
        m_lTargetState = DFS_TARGET_STATE_UNREACHABLE;
        LoadStringFromResource(IDS_TARGET_STATUS_UNREACHABLE, &m_bstrTargetStatusColumnText);
    } else
    {
        m_lTargetState = DFS_TARGET_STATE_OK;
        LoadStringFromResource(IDS_TARGET_STATUS_OK, &m_bstrTargetStatusColumnText);
    }

    _UpdateThisItem();

    return S_OK;
}

void CMmcDfsReplica::_UpdateThisItem()
{
    if (m_pDfsParentRoot)
    {
        m_pDfsParentRoot->m_lpConsole->UpdateAllViews(
                                            (IDataObject*)m_pDfsParentRoot, // Parent object 
                                            (LPARAM)((CMmcDisplay *)this), 
                                            1);
    }
    else
    {
        m_pDfsParentJP->m_pDfsParentRoot->m_lpConsole->UpdateAllViews(
                                            (IDataObject*)m_pDfsParentJP, // Parent object 
                                            (LPARAM)((CMmcDisplay *)this), 
                                            1);
    }
}

HRESULT 
CMmcDfsReplica::ToolbarSelect(
  IN const LONG          i_lArg,
  IN  IToolbar*          i_pToolBar
  )
/*++

Routine Description:

  Handle a select event for a toolbar
  Create a toolbar, it it doesn't exist.
  Attach the toolbar and enable the buttons, if the event for a selection.
  Disable the buttons, if the event was for a deselection

Arguments:
  i_lArg        -  The argument passed to the actual method.
  o_pToolBar      -  The Toolbar pointer.
              the class exposed to MMC.
--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pToolBar);

    BOOL    bSelect = (BOOL) HIWORD(i_lArg);

    EnableToolbarButtons(i_pToolBar, IDT_REPLICA_MIN, IDT_REPLICA_MAX, bSelect);

    if (bSelect)
    {
        // No TakeOnlineOffline on root replicas
        if (m_pDfsParentRoot)
        {
            i_pToolBar->SetButtonState(IDT_REPLICA_TAKE_REPLICA_OFFLINE_ONLINE, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_REPLICA_TAKE_REPLICA_OFFLINE_ONLINE, HIDDEN, TRUE);
        }

        BOOL bShowFRS = FALSE;
        if (m_pDfsParentRoot)
            bShowFRS = m_pDfsParentRoot->get_ShowFRS();
        else
            bShowFRS = m_pDfsParentJP->get_ShowFRS();

        // bShowFRS is FALSE if it's a standalone DFS or user is not interested in seeing FRS info.
        // Hence, there is no need to retrieve replication info here. This will greatly improve PERF
        // especially when dealing with DFS hosted on standalone server, save us the call to DsGetDCName.
        if (bShowFRS && !m_pRepInfo)
            GetReplicationInfo();

        if (!bShowFRS ||
            (m_pRepInfo && FRSSHARE_TYPE_OK != m_pRepInfo->m_nFRSShareType))
        {
            i_pToolBar->SetButtonState(IDT_REPLICA_REPLICATE, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_REPLICA_REPLICATE, HIDDEN, TRUE);
            i_pToolBar->SetButtonState(IDT_REPLICA_STOP_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_REPLICA_STOP_REPLICATION, HIDDEN, TRUE);
        } else if (m_bFRSMember)
        {
            i_pToolBar->SetButtonState(IDT_REPLICA_REPLICATE, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_REPLICA_REPLICATE, HIDDEN, TRUE);
        } else
        {
            i_pToolBar->SetButtonState(IDT_REPLICA_STOP_REPLICATION, ENABLED, FALSE);
            i_pToolBar->SetButtonState(IDT_REPLICA_STOP_REPLICATION, HIDDEN, TRUE);
        }

    }

    return S_OK; 
}




HRESULT
CMmcDfsReplica::CreateToolbar(
  IN const LPCONTROLBAR      i_pControlbar,
  IN const LPEXTENDCONTROLBAR          i_lExtendControlbar,
  OUT  IToolbar**          o_pToolBar
  )
/*++

Routine Description:

  Create the toolbar.
  Involves the actual toolbar creation call, creating the bitmap and adding it
  and finally adding the buttons to the toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lExtendControlbar  -  The object implementing IExtendControlbar. This is 
              the class exposed to MMC.
--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);
    RETURN_INVALIDARG_IF_NULL(i_lExtendControlbar);
    RETURN_INVALIDARG_IF_NULL(o_pToolBar);

                  // Create the toolbar
    HRESULT hr = i_pControlbar->Create(TOOLBAR, i_lExtendControlbar, reinterpret_cast<LPUNKNOWN*>(o_pToolBar));
    RETURN_IF_FAILED(hr);

                  // Add the bitmap to the toolbar
    hr = AddBitmapToToolbar(*o_pToolBar, IDB_REPLICA_TOOLBAR);
    RETURN_IF_FAILED(hr);

    int      iButtonPosition = 0;    // The first button position
    for (int iCommandID = IDT_REPLICA_MIN, iMenuResource = IDS_MENUS_REPLICA_TOP_OPEN;
            iCommandID <= IDT_REPLICA_MAX; 
            iCommandID++,iMenuResource++,iButtonPosition++)
    {
        CComBSTR bstrMenuText;
        CComBSTR bstrToolTipText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, &bstrToolTipText, NULL);
        RETURN_IF_FAILED(hr);  

        MMCBUTTON      ToolbarButton;
        ZeroMemory(&ToolbarButton, sizeof ToolbarButton);
        ToolbarButton.nBitmap  = iButtonPosition;
        ToolbarButton.idCommand = iCommandID;
        ToolbarButton.fsState = TBSTATE_ENABLED;
        ToolbarButton.fsType = TBSTYLE_BUTTON;
        ToolbarButton.lpButtonText = bstrMenuText;
        ToolbarButton.lpTooltipText = bstrToolTipText;

                          // Add the button to the toolbar
        hr = (*o_pToolBar)->InsertButton(iButtonPosition, &ToolbarButton);
        RETURN_IF_FAILED(hr);
    }

    return hr;
}



STDMETHODIMP 
CMmcDfsReplica::ToolbarClick(
  IN const LPCONTROLBAR            i_pControlbar, 
  IN const LPARAM                i_lParam
  ) 
/*++

Routine Description:

  Action to take on a click on a toolbar

Arguments:
  i_pControlbar    -  The controlbar used to create toolbar.
  i_lParam      -  The lparam to the actual notify. This is the command id of
              the button on which a click occurred.
--*/
{ 
    RETURN_INVALIDARG_IF_NULL(i_pControlbar);

    HRESULT    hr = S_OK;

    switch(i_lParam)        // What button did the user click on.
    {
    case IDT_REPLICA_REMOVE_FROM_DFS:
        hr = DoDelete();
        break;
    case IDT_REPLICA_TAKE_REPLICA_OFFLINE_ONLINE:
        hr = TakeReplicaOffline();
        break;
    case IDT_REPLICA_CHECK_STATUS:
        hr = OnCheckStatus ();
        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);
        break;
    case IDT_REPLICA_REPLICATE:
        {
            hr = m_pDfsReplicaObject->FindTarget();
            if (S_OK != hr)
            {
                //
                // the target has been deleted by others, refresh the root/link
                //
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_TARGET);
                if (m_pDfsParentRoot)
                    hr = m_pDfsParentRoot->OnRefresh();
                else
                    hr = m_pDfsParentJP->OnRefresh();
            } else
            {
                hr = OnReplicate();
            }

            break;
        }
    case IDT_REPLICA_STOP_REPLICATION:
        {
            hr = m_pDfsReplicaObject->FindTarget();
            if (S_OK != hr)
            {
                //
                // the target has been deleted by others, refresh the root/link
                //
                DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_TARGET);
                if (m_pDfsParentRoot)
                    hr = m_pDfsParentRoot->OnRefresh();
                else
                    hr = m_pDfsParentJP->OnRefresh();
            } else
            {
                BOOL bRepSetExist = FALSE;
                hr = AllowFRSMemberDeletion(&bRepSetExist);
                if (bRepSetExist && SUCCEEDED(hr))
                {
                    if (S_OK == hr) 
                    {
                        hr = OnStopReplication(TRUE);
                        if (FAILED(hr))
                            DisplayMessageBoxForHR(hr);
                    }
                } else
                {
                    if (m_pDfsParentRoot)
                        hr = m_pDfsParentRoot->OnRefresh();
                    else
                        hr = m_pDfsParentJP->OnRefresh();
                }
            }

            break;
        }
    case IDT_REPLICA_OPEN:
        hr = OnOpen();
        break;
    default:
        break;
    };

    return hr; 
}




HRESULT
CMmcDfsReplica::OnOpen(
  )
/*++

Routine Description:

  Open the display path for this replica

--*/
{
    CWaitCursor    WaitCursor;  // Display the wait cursor

    if (-1 == GetFileAttributes(m_bstrDisplayName) || // bug#96670
        32 >= (INT_PTR) ShellExecute(
                                    NULL,        // Handle to window
                                    _T("explore"),    // Action to take
                                    m_bstrDisplayName,    // Folder to explore
                                    NULL,        // Parameters
                                    NULL,        // Default directory
                                    SW_SHOWNORMAL    // Show command
                                    ))
    {
        DisplayMessageBoxWithOK(IDS_MSG_EXPLORE_FAILURE, m_bstrDisplayName);
        return(S_FALSE);
    }

    return S_OK;
}


STDMETHODIMP 
CMmcDfsReplica::TakeReplicaOffline(
  ) 
{
/*++

Routine Description:

  Take replica offline by calling put_State method of replica.

--*/

    CWaitCursor WaitCursor;

    // Always toggle the mapping status.
    long lReplicaState = DFS_REFERRAL_STATE_OFFLINE;
    HRESULT hr = m_pDfsReplicaObject->get_State(&lReplicaState);

    if (S_OK == hr)
    {
        long    newVal = 0;

        switch (lReplicaState)
        {
        case DFS_REFERRAL_STATE_ONLINE:
            newVal = DFS_REFERRAL_STATE_OFFLINE;
            hr = m_pDfsReplicaObject->put_State(newVal);
            if (SUCCEEDED(hr))
                m_lReferralState = newVal;
            break;
        case DFS_REFERRAL_STATE_OFFLINE:
            newVal = DFS_REFERRAL_STATE_ONLINE;
            hr = m_pDfsReplicaObject->put_State(newVal);
            if (SUCCEEDED(hr))
                m_lReferralState = newVal;
            break;
        default:
            break;
        }
    }

    if (S_OK == hr)
    {
        m_bstrDfsReferralColumnText.Empty();
        if (DFS_REFERRAL_STATE_ONLINE == m_lReferralState)
        {
            LoadStringFromResource(IDS_ENABLED, &m_bstrDfsReferralColumnText);
        } else
        {
            LoadStringFromResource(IDS_DISABLED, &m_bstrDfsReferralColumnText);
        }

        _UpdateThisItem();
    } else if (S_FALSE == hr)
    {
        //
        // this target has been deleted by other means, refresh the root/link,
        //
        m_lReferralState = DFS_REFERRAL_STATE_OFFLINE;
        m_bstrDfsReferralColumnText.Empty();
        LoadStringFromResource(IDS_DISABLED, &m_bstrDfsReferralColumnText);

        m_lTargetState = DFS_TARGET_STATE_UNASSIGNED;
        m_bstrTargetStatusColumnText.Empty();
        LoadStringFromResource(IDS_TARGET_STATUS_UNKNOWN, &m_bstrTargetStatusColumnText);

        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_TARGET);
        if (m_pDfsParentRoot)
            hr = m_pDfsParentRoot->OnRefresh();
        else
            hr = m_pDfsParentJP->OnRefresh();
    } else
    {
        DisplayMessageBoxForHR(hr);
    }

    return hr;
}

STDMETHODIMP CMmcDfsReplica::ViewChange(
  IResultData*    i_pResultData,
  LONG_PTR        i_lHint
  )
/*++

Routine Description:

  This method handles the MMCN_VIEW_CHANGE notification.
  This updates the icon for the replica item as this is called 
  when the state changes.
  i_lHint is ignored here.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_pResultData);

    HRESULT hr = S_OK;

    if (i_pResultData != NULL)
    {
        RESULTDATAITEM  ResultDataItem;
        ZeroMemory(&ResultDataItem, sizeof(ResultDataItem));
        hr = i_pResultData->FindItemByLParam((LPARAM)(this), &(ResultDataItem.itemID));
        RETURN_IF_FAILED(hr);

        ResultDataItem.mask = RDI_IMAGE;
        ResultDataItem.nCol = 0;
        ResultDataItem.nImage = CMmcDfsReplica::m_iIMAGE_OFFSET + m_lTargetState;
        i_pResultData->SetItem(&ResultDataItem);

        ResultDataItem.mask = RDI_STR;
        ResultDataItem.nCol = 1;
        ResultDataItem.str= MMC_TEXTCALLBACK;
        i_pResultData->SetItem(&ResultDataItem);

        ResultDataItem.mask = RDI_STR;
        ResultDataItem.nCol = 2;
        ResultDataItem.str= MMC_TEXTCALLBACK;
        i_pResultData->SetItem(&ResultDataItem);

        BOOL bShowFRS = FALSE;
        if (m_pDfsParentRoot)
            bShowFRS = m_pDfsParentRoot->get_ShowFRS();
        else
            bShowFRS = m_pDfsParentJP->get_ShowFRS();

        if (bShowFRS)
        {
            ResultDataItem.mask = RDI_STR;
            ResultDataItem.nCol = 3;
            ResultDataItem.str= MMC_TEXTCALLBACK;
            i_pResultData->SetItem(&ResultDataItem);
        }
    }

    return hr;
}

//
// Set m_ReplicationState and m_hrFRS appropriately
//
// Return:
// "No" if this alternate is not a Frs member
// "N/A: <reason>" if this alternate is not eligible to join frs
// hr: if we cannot get info on this alternate

void CAlternateReplicaInfo::Reset()
{
    m_bstrDisplayName.Empty();
    m_bstrDnsHostName.Empty();
    m_bstrRootPath.Empty();
    m_bstrStagingPath.Empty();
    m_nFRSShareType = FRSSHARE_TYPE_OK;
    m_hrFRS = S_OK;
    m_dwServiceStartType = SERVICE_AUTO_START;
    m_dwServiceState = SERVICE_RUNNING;
}

HRESULT PathOverlapped(LPCTSTR pszPath1, LPCTSTR pszPath2)
{
    if (!pszPath1 || !*pszPath1 || !pszPath2 || !*pszPath2)
        return E_INVALIDARG;

    BOOL bOverlapped = FALSE;

    int len1 = lstrlen(pszPath1);
    int len2 = lstrlen(pszPath2);
    int minLen = min(len1, len2);

    if (len1 == len2)
    {
        if (!lstrcmpi(pszPath1, pszPath2))
            bOverlapped = TRUE;
    } else 
    {
        LPCTSTR pszLongerOne = ((len1 < len2) ? pszPath2 : pszPath1);
        CComBSTR bstrShorterOne = ((len1 < len2) ? pszPath1 : pszPath2);
        RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrShorterOne);

        BOOL bEndingSlash = (_T('\\') == *(bstrShorterOne + minLen - 1));
        if (!bEndingSlash)
        {
            bstrShorterOne += _T("\\");
            RETURN_OUTOFMEMORY_IF_NULL((BSTR)bstrShorterOne);
            minLen++;
        }

        if (!mylstrncmpi(pszLongerOne, (BSTR)bstrShorterOne, minLen))
            bOverlapped = TRUE;
    }
    
    return bOverlapped ? S_OK : S_FALSE;
}

HRESULT CMmcDfsReplica::GetReplicationInfoEx(CAlternateReplicaInfo** o_ppInfo)
{
    RETURN_INVALIDARG_IF_NULL(o_ppInfo);

    CAlternateReplicaInfo* pInfo = new CAlternateReplicaInfo;
    RETURN_OUTOFMEMORY_IF_NULL(pInfo);

    pInfo->m_bstrDisplayName = m_bstrDisplayName;
    if (!pInfo->m_bstrDisplayName)
    {
        delete pInfo;
        return E_OUTOFMEMORY;
    }

    HRESULT hr = S_OK;
    do {
        //
        // validate connectivity
        //
        if (-1 == GetFileAttributes(pInfo->m_bstrDisplayName))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // exclude non-Lanman share resources, e.g., webdav
        //
        hr = CheckResourceProvider(pInfo->m_bstrDisplayName);
        if (S_OK != hr)
        {
            pInfo->m_nFRSShareType = FRSSHARE_TYPE_NOTSMBDISK;
            hr = S_OK;
            break;
        }

        //
        // retrieve DnsHostName
        //
        CComBSTR bstrComputerGuid;
        SUBSCRIBERLIST FRSRootList;
        hr= GetServerInfo(
                        m_bstrServerName,
                        NULL, // Domain,
                        NULL, // NetbiosServerName,
                        NULL, // bValidComputerObject,
                        &(pInfo->m_bstrDnsHostName),
                        &bstrComputerGuid,
                        NULL, // FQDN
                        &FRSRootList);
        BREAK_IF_FAILED(hr);
        if (S_FALSE == hr)
        {
            pInfo->m_nFRSShareType = FRSSHARE_TYPE_NODOMAIN;
            break;
        }

        //
        // retrieve RootPath
        //
        hr = GetFolderInfo(
                        m_bstrServerName,
                        m_bstrShareName,
                        &(pInfo->m_bstrRootPath));
        BREAK_IF_FAILED(hr);

        //
        // calculate memberDN for this target
        //
        CComBSTR bstrReplicaSetDN;
        if (m_pDfsParentRoot)
            hr = m_pDfsParentRoot->m_DfsRoot->get_ReplicaSetDN(&bstrReplicaSetDN);
        else
            hr = m_pDfsParentJP->m_pDfsJPObject->get_ReplicaSetDN(&bstrReplicaSetDN);
        BREAK_IF_FAILED(hr);

        CComBSTR bstrDomainDN;
        if (m_pDfsParentRoot)
            hr = m_pDfsParentRoot->m_DfsRoot->get_DomainDN(&bstrDomainDN);
        else
            hr = m_pDfsParentJP->m_pDfsParentRoot->m_DfsRoot->get_DomainDN(&bstrDomainDN);
        BREAK_IF_FAILED(hr);

        CComBSTR bstrMemberDN = _T("CN=");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += bstrComputerGuid;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += bstrReplicaSetDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += _T(",");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);
        bstrMemberDN += bstrDomainDN;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)bstrMemberDN, &hr);

        //
        // Detect if the current folder overlaps with an existing replicated folder that
        // is not in the same replica set
        //
        for (SUBSCRIBERLIST::iterator i = FRSRootList.begin(); i != FRSRootList.end(); i++)
        {
            if (!lstrcmpi((*i)->bstrMemberDN, bstrMemberDN))
                continue;

            if (S_OK == PathOverlapped(pInfo->m_bstrRootPath, (*i)->bstrRootPath))
            {
                // overlapping detected
                pInfo->m_nFRSShareType = FRSSHARE_TYPE_OVERLAPPING;
                break;
            }
        }

        FreeSubscriberList(&FRSRootList);

        if (FRSSHARE_TYPE_OK != pInfo->m_nFRSShareType)
            break;

        //
        // check if share is on non NTFS5.0 volume
        //
        hr = FRSShareCheck(
                        m_bstrServerName,
                        m_bstrShareName,
                        &(pInfo->m_nFRSShareType));
        BREAK_IF_FAILED(hr);

        if (FRSSHARE_TYPE_OK != pInfo->m_nFRSShareType)
            break;

        //
        // retrieve StagingPath
        //
        TCHAR    lpszDrive[2];
        lpszDrive[0] = GetDiskForStagingPath(m_bstrServerName, *(pInfo->m_bstrRootPath));
        lpszDrive[1] = NULL;

        pInfo->m_bstrStagingPath = lpszDrive;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)pInfo->m_bstrStagingPath, &hr);
        pInfo->m_bstrStagingPath += _T(":\\");
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)pInfo->m_bstrStagingPath, &hr);
        pInfo->m_bstrStagingPath += FRS_STAGE_PATH;
        BREAK_OUTOFMEMORY_IF_NULL((BSTR)pInfo->m_bstrStagingPath, &hr);

        //
        // ntfrs won't work if bstrSharePath points at the root directory of a volume
        // and no other volumes on this computer are suitable to store temporary file
        //
        if (_tcslen(pInfo->m_bstrRootPath) == 3 &&
            _totupper(*(pInfo->m_bstrRootPath)) == _totupper(*lpszDrive))
        {
            pInfo->m_nFRSShareType = FRSSHARE_TYPE_CONFLICTSTAGING;
        }
    } while (0);

    if (FAILED(hr))
        pInfo->m_nFRSShareType = FRSSHARE_TYPE_UNKNOWN;

    pInfo->m_hrFRS = hr;

    *o_ppInfo = pInfo;

    return S_OK;
}

HRESULT CMmcDfsReplica::GetReplicationInfo()
{
    if (m_pRepInfo)
        delete m_pRepInfo;

    return GetReplicationInfoEx(&m_pRepInfo);
}

HRESULT CMmcDfsReplica::ShowReplicationInfo(IReplicaSet* i_piReplicaSet)
{
    HRESULT hr = S_OK;

    m_bFRSMember = FALSE;
    m_bstrStatusText.Empty();
    m_bstrFRSColumnText.Empty();

    if (i_piReplicaSet) // show FRS
    {
        hr = GetReplicationInfo(); // refresh m_pRepInfo
        RETURN_IF_FAILED(hr);

        if (FRSSHARE_TYPE_OK == m_pRepInfo->m_nFRSShareType)
        {
            hr = i_piReplicaSet->IsFRSMember(m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrRootPath);
            m_bFRSMember = (S_OK == hr); // it is set to TRUE only when "Show Replication Info" and is a FRS member
        }

        GetReplicationText(m_bFRSMember, m_pRepInfo, &m_bstrFRSColumnText, &m_bstrStatusText);
    }

    return S_OK;
}

HRESULT CMmcDfsReplica::GetBadMemberInfo(
    IN  IReplicaSet* i_piReplicaSet,
    IN  BSTR    i_bstrServerName,
    OUT BSTR*   o_pbstrDnsHostName,
    OUT BSTR*   o_pbstrRootPath
    )
{
    RETURN_INVALIDARG_IF_NULL(i_bstrServerName);
    RETURN_INVALIDARG_IF_NULL(o_pbstrDnsHostName);
    RETURN_INVALIDARG_IF_NULL(o_pbstrRootPath);

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = i_piReplicaSet->GetBadMemberInfo(i_bstrServerName, &var);
    if (S_OK != hr)
        return hr;

    if (V_VT(&var) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    SAFEARRAY   *psa = V_ARRAY(&var);
    if (!psa) // no such member at all
        return S_FALSE;

    long    lLowerBound = 0;
    long    lUpperBound = 0;
    long    lCount = 0;
    SafeArrayGetLBound(psa, 1, &lLowerBound);
    SafeArrayGetUBound(psa, 1, &lUpperBound);
    lCount = lUpperBound - lLowerBound + 1;

    VARIANT HUGEP *pArray;
    SafeArrayAccessData(psa, (void HUGEP **) &pArray);

    *o_pbstrDnsHostName = SysAllocString(pArray[4].bstrVal);
    *o_pbstrRootPath = SysAllocString(pArray[3].bstrVal);

    SafeArrayUnaccessData(psa);

    VariantClear(&var); // it will in turn call SafeArrayDestroy(psa);

    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrDnsHostName);
    RETURN_OUTOFMEMORY_IF_NULL(*o_pbstrRootPath);

    return hr;
}

HRESULT CMmcDfsReplica::DeleteBadFRSMember(IReplicaSet* i_piReplicaSet, IN BSTR i_bstrDisplayName, IN HRESULT i_hres)
{
    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)i_piReplicaSet);

    CComBSTR bstrServerName;
    HRESULT hr = GetUNCPathComponent(i_bstrDisplayName, &bstrServerName, 2, 3);

    long lNumOfMembers = 0;
    hr = i_piReplicaSet->get_NumOfMembers(&lNumOfMembers);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrDnsHostName;
    CComBSTR bstrRootPath;
    hr = GetBadMemberInfo(i_piReplicaSet, bstrServerName, &bstrDnsHostName, &bstrRootPath);
    if (S_OK != hr)
        return S_OK; // no such bad member, continue with other operations

    int nRet = DisplayMessageBox(::GetActiveWindow(), 
                                MB_YESNOCANCEL,
                                i_hres,
                                IDS_MSG_ERROR_BADFRSMEMBERDELETION,
                                i_bstrDisplayName,
                                bstrRootPath,
                                bstrDnsHostName);

    if (IDNO == nRet)
        return S_OK; // return immediately, continue with other operations
    else if (IDCANCEL == nRet)
        return S_FALSE; // do not proceed

    CWaitCursor wait;

    if (lNumOfMembers <= 2)
    {
        if (m_pDfsParentRoot)
            hr = m_pDfsParentRoot->OnStopReplication(FALSE, FALSE);
        else
            hr = m_pDfsParentJP->OnStopReplication(FALSE, FALSE);
    } else
        hr = i_piReplicaSet->RemoveMemberEx(bstrDnsHostName, bstrRootPath);

    return hr;
}

HRESULT CMmcDfsReplica::AddFRSMember(
    IN IReplicaSet* i_piReplicaSet,
    IN BSTR i_bstrDnsHostName,
    IN BSTR i_bstrRootPath,
    IN BSTR i_bstrStagingPath)
{
    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)i_piReplicaSet);

    HRESULT hr = i_piReplicaSet->AddMember(i_bstrDnsHostName, i_bstrRootPath, i_bstrStagingPath, TRUE, NULL);

    if (FAILED(hr))
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, 
                IDS_MSG_ADDFRSMEMBER_FAILED, i_bstrDnsHostName);
    } else if (S_OK == hr) // let S_FALSE drop through: computer is already a member
    {
        CComBSTR bstrTopologyPref;
        hr = i_piReplicaSet->get_TopologyPref(&bstrTopologyPref);
        if (SUCCEEDED(hr) && !lstrcmpi(bstrTopologyPref, FRS_RSTOPOLOGYPREF_CUSTOM))
        {
            DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_MSG_ADDMEMBER_TO_CUSTOM);
        }
    }

    return hr;
}

HRESULT CMmcDfsReplica::DeleteFRSMember(
    IN IReplicaSet* i_piReplicaSet,
    IN BSTR i_bstrDnsHostName,
    IN BSTR i_bstrRootPath)
{
    RETURN_INVALIDARG_IF_NULL((IReplicaSet *)i_piReplicaSet);
    RETURN_INVALIDARG_IF_NULL(i_bstrDnsHostName);
    RETURN_INVALIDARG_IF_NULL(i_bstrRootPath);

    long lNumOfMembers = 0;
    HRESULT hr = i_piReplicaSet->get_NumOfMembers(&lNumOfMembers);
    RETURN_IF_FAILED(hr);

    hr = i_piReplicaSet->IsFRSMember(i_bstrDnsHostName, i_bstrRootPath);
    if (S_OK != hr)
        return hr;

    if (lNumOfMembers <= 2)
    {
        if (m_pDfsParentRoot)
            hr = m_pDfsParentRoot->OnStopReplication(FALSE, FALSE);
        else
            hr = m_pDfsParentJP->OnStopReplication(FALSE, FALSE);
    } else
        hr = i_piReplicaSet->RemoveMemberEx(i_bstrDnsHostName, i_bstrRootPath);

    return hr;
}

HRESULT CMmcDfsReplica::RemoveReplicaFromSet()
{
    CWaitCursor wait;

    HRESULT hr = S_OK;

    CComPtr<IReplicaSet> piReplicaSet;
    if (m_pDfsParentRoot)
        hr = m_pDfsParentRoot->GetIReplicaSetPtr(&piReplicaSet);
    else
        hr = m_pDfsParentJP->GetIReplicaSetPtr(&piReplicaSet);
    if (S_OK != hr) // no replica set on the corresponding link/root
        return hr;

    hr = GetReplicationInfo(); // fill in m_pRepInfo
    RETURN_IF_FAILED(hr);

    if (!m_pRepInfo->m_bstrDnsHostName)
        return DeleteBadFRSMember(piReplicaSet, m_pRepInfo->m_bstrDisplayName, m_pRepInfo->m_hrFRS);

    long lNumOfMembers = 0;
    hr = piReplicaSet->get_NumOfMembers(&lNumOfMembers);
    RETURN_IF_FAILED(hr);

    hr = piReplicaSet->IsFRSMember(m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrRootPath);

    if (S_OK != hr) // not a member
        return hr;

    if (lNumOfMembers <= 2)
    {
        if (m_pDfsParentRoot)
            hr = m_pDfsParentRoot->OnStopReplication(FALSE, FALSE);
        else
            hr = m_pDfsParentJP->OnStopReplication(FALSE, FALSE);
    } else
    {
        hr = piReplicaSet->RemoveMemberEx(m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrRootPath);
    }

    return hr;
}

//
// S_OK: either not the hub server or #Members is not more than 2, 
//       okay to proceed(e.g., remove the member from the set)
// S_FALSE: it is the hub server and #Members is more than 2, 
//          not safe to proceed
// others: error occurred 
//
HRESULT CMmcDfsReplica::AllowFRSMemberDeletion(BOOL *pbRepSetExist)
{
    RETURN_INVALIDARG_IF_NULL(pbRepSetExist);

    *pbRepSetExist = FALSE;

    HRESULT hr = S_OK;

    CComPtr<IReplicaSet> piReplicaSet;
    if (m_pDfsParentRoot)
        hr = m_pDfsParentRoot->GetIReplicaSetPtr(&piReplicaSet);
    else
        hr = m_pDfsParentJP->GetIReplicaSetPtr(&piReplicaSet);
    if (S_OK != hr) // no replica set on the corresponding link/root
        return S_OK;

    *pbRepSetExist = TRUE;

    long lNumOfMembers = 0;
    hr = piReplicaSet->get_NumOfMembers(&lNumOfMembers);
    RETURN_IF_FAILED(hr);

    if (lNumOfMembers <= 2) // removing this member will tear down the whole set
        return S_OK;        // no need to check if it's the hub or not

    if (!m_pRepInfo)
    {
        hr = GetReplicationInfo();
        RETURN_IF_FAILED(hr);
    }

    hr = piReplicaSet->IsHubMember(m_pRepInfo->m_bstrDnsHostName, m_pRepInfo->m_bstrRootPath);

    if (S_OK == hr) // do not proceed, for it's the hub
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_MSG_CANNOT_DELETE_HUBMEMBER);
        hr = S_FALSE; // do not proceed
    } else if (S_FALSE == hr)
    {
        hr = S_OK; // not a hub, okay to proceed
    } else if (FAILED(hr))
    {
        if (IDOK == DisplayMessageBox(::GetActiveWindow(), MB_OKCANCEL, hr, IDS_MSG_ERROR_ALLOWFRSMEMBERDELETION))
            hr = S_OK; // okay to proceed
        else
            hr = S_FALSE; // do not proceed
    }

    return hr;
}

HRESULT GetReplicationText(
    IN BOOL                     i_bFRSMember,
    IN CAlternateReplicaInfo*   i_pRepInfo,
    OUT BSTR*                   o_pbstrColumnText,
    OUT BSTR*                   o_pbstrStatusBarText
    )
{
    RETURN_INVALIDARG_IF_NULL(o_pbstrColumnText);
    RETURN_INVALIDARG_IF_NULL(o_pbstrStatusBarText);

    *o_pbstrColumnText = NULL;
    *o_pbstrStatusBarText = NULL;

    int nShortID = 0, nStatusID = 0;
    switch (i_pRepInfo->m_nFRSShareType)
    {
    case FRSSHARE_TYPE_OK:
        nShortID = (i_bFRSMember ? IDS_ENABLED : IDS_DISABLED);
        nStatusID = (i_bFRSMember ? IDS_REPLICATION_STATUSBAR_MEMBER : IDS_REPLICATION_STATUSBAR_NONMEMBER);
        break;
    case FRSSHARE_TYPE_NONTFRS:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_NONTFRS;
        break;
    case FRSSHARE_TYPE_NOTDISKTREE:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_NOTDISKTREE;
        break;
    case FRSSHARE_TYPE_NOTNTFS:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_NOTNTFS;
        break;
    case FRSSHARE_TYPE_CONFLICTSTAGING:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_CONFLICTSTAGING;
        break;
    case FRSSHARE_TYPE_NODOMAIN:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_NODOMAIN;
        break;
    case FRSSHARE_TYPE_NOTSMBDISK:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_NOTSMBDISK;
        break;
    case FRSSHARE_TYPE_OVERLAPPING:
        nShortID = IDS_REPLICATION_STATUS_NOTELIGIBLE;
        nStatusID = IDS_REPLICATION_STATUSBAR_OVERLAPPING;
        break;
    default:
        nShortID = IDS_REPLICATION_STATUS_UNKNOWN;
        break;
    }

    if (nStatusID)
        LoadStringFromResource(nStatusID, o_pbstrStatusBarText);
    if (FRSSHARE_TYPE_UNKNOWN == i_pRepInfo->m_nFRSShareType)
        GetErrorMessage(i_pRepInfo->m_hrFRS, o_pbstrStatusBarText);

    LoadStringFromResource(nShortID, o_pbstrColumnText);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcadmin.h ===
/*++
Module Name:
    MmcAdmin.h

Abstract:
    This module contains the definition for CMmcDfsAdmin. This is an class 
  for MMC display related calls for the static node(the DFS Admin root node)
  Also contains code use to wrap a list of Dfs Roots.

--*/



#if !defined(AFX_MMCDFSADMIN_H__2CC64E54_3BF4_11D1_AA17_00C06C00392D__INCLUDED_)
#define AFX_MMCDFSADMIN_H__2CC64E54_3BF4_11D1_AA17_00C06C00392D__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "MmcDispl.h"
#include "connect.h"
#include "MmcRoot.h"
#include "DfsCore.h"

#include <list>
using namespace std;

class CMmcDfsAdmin;
class CDfsSnapinScopeManager;

//  This structure defines a node of the list of Dfs Roots
//  added to the snapin. This is maintained internally by the CMmcDfsAdmin
class DFS_ROOT_NODE 
{
public:
  DFS_ROOT_NODE(CMmcDfsRoot* i_pMmcDfsRoot, BSTR i_bstrRootEntryPath)
  {    
    m_pMmcDfsRoot = i_pMmcDfsRoot;
    m_bstrRootEntryPath = i_bstrRootEntryPath;
  };

  ~DFS_ROOT_NODE()
  {
    SAFE_RELEASE(m_pMmcDfsRoot);
  };


  CComBSTR      m_bstrRootEntryPath;    // Root Entry path of the Dfs Volume

  CMmcDfsRoot*  m_pMmcDfsRoot;          // DfsRoot class for MMC display

};

typedef    list<DFS_ROOT_NODE*>    DFS_ROOT_LIST;

class CMmcDfsAdmin : public CMmcDisplay  
{
public:
  
  CMmcDfsAdmin( CDfsSnapinScopeManager* pScopeManager );
  virtual ~CMmcDfsAdmin();

  // For adding context menu items
  STDMETHOD(AddMenuItems)(  
    IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
    IN LPLONG                   i_lpInsertionAllowed
    );

  // For taking action on a context menu selection.
  STDMETHOD(Command)(
    IN LONG                     i_lCommandID
    );

  // Set the headers for the listview (in the result pane) column
  STDMETHOD(SetColumnHeader)(
    IN LPHEADERCTRL2            i_piHeaderControl
    ) { return E_NOTIMPL; } // the static node will dispay the messageview in the result pane

  // Return the requested display information for the Result Pane
  STDMETHOD(GetResultDisplayInfo)(
    IN OUT LPRESULTDATAITEM     io_pResultDataItem
    ) { return S_OK; };

  // Return the requested display information for the Scope Pane
  STDMETHOD(GetScopeDisplayInfo)(
    IN OUT  LPSCOPEDATAITEM     io_pScopeDataItem  
    ) { return S_OK; };

  // Add all the items to the Scope Pane
  STDMETHOD(EnumerateScopePane)(
    IN LPCONSOLENAMESPACE       i_lpConsoleNameSpace,
    IN HSCOPEITEM               i_hParent
    );

  // Add items(or folders), if any to the Result Pane
  STDMETHOD(EnumerateResultPane)(
    IN OUT   IResultData*       io_pResultData
    ) { return S_OK; };

  //  Returns the pointer to the list of DfsRoots currently added to the Snapin.
  STDMETHOD(GetList)(
    OUT DFS_ROOT_LIST**         o_pList
    );

  // This method checks if DfsRoot is already added to the list.
  STDMETHOD(IsAlreadyInList)(
    IN BSTR                     i_bstrDfsRootServerName,
    OUT CMmcDfsRoot             **o_ppMmcDfsRoot = NULL
    );

  // Delete the node from m_RootList
  STDMETHOD(DeleteMmcRootNode)(
    IN CMmcDfsRoot*             i_pMmcDfsRoot
    );

  // Add a Dfs root to the list and scope pane
  STDMETHOD(AddDfsRoot)(
    IN BSTR                     i_bstrDfsRootName
    );

  // Add a Dfs root to the list.
  STDMETHOD(AddDfsRootToList)(
    IN IDfsRoot*                i_pDfsRoot,  // IDfsRoot pointer of the DfsRoot.
    IN ULONG                    i_ulLinkFilterMaxLimit = FILTERDFSLINKS_MAXLIMIT_DEFAULT,
    IN FILTERDFSLINKS_TYPE      i_lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER,
    IN BSTR                     i_bstrLinkFilterName = NULL
    );

  // Set the console verb settings. Change the state, decide the default verb, etc
  STDMETHOD(SetConsoleVerbs)(
    IN  LPCONSOLEVERB           i_lpConsoleVerb
    );

  // let MMC handle the default verb.
  STDMETHOD(DoDblClick)(
    )  { return S_FALSE; }

  // Delete the current item.
  STDMETHOD(DoDelete)(
    )  { return S_FALSE; };

  // Checks whether the object has pages to display
  STDMETHOD(QueryPagesFor)(
    ) { return S_FALSE; };

  // Creates and passes back the pages to be displayed
  STDMETHOD(CreatePropertyPages)(
    IN LPPROPERTYSHEETCALLBACK  i_lpPropSheetCallback,
    IN LONG_PTR                 i_lNotifyHandle
    ) { return E_UNEXPECTED; };

  // Used to notify the object that it's properties have changed
  STDMETHOD(PropertyChanged)(
    ) { return E_UNEXPECTED; };

  // Used to set the result view description bar text
  STDMETHOD(SetDescriptionBarText)(
    IN LPRESULTDATA             i_lpResultData
    );

    STDMETHOD(SetStatusText)(
        IN LPCONSOLE2           i_lpConsole
        )
    { 
        RETURN_INVALIDARG_IF_NULL(i_lpConsole);
        return i_lpConsole->SetStatusText(NULL);
    }

  // Handle a select event for the node. Handle only toolbar related 
  // activities here
  STDMETHOD(ToolbarSelect)(
    IN const LONG               i_lArg,
    IN  IToolbar*               i_pToolBar
    );

  // Handle a click on the toolbar
  STDMETHOD(ToolbarClick)(
    IN const LPCONTROLBAR       i_pControlbar, 
    IN const LPARAM             i_lParam
    );

  STDMETHOD(RemoveFromMMC)() { return S_OK; }

  STDMETHOD(CleanScopeChildren)(
    VOID
    );

  STDMETHOD(CleanResultChildren)(
    )  { return S_OK; };

  STDMETHOD(ViewChange)(
    IResultData*                i_pResultData,
    LONG_PTR                    i_lHint
  )  { return S_OK; };

  // Getters/Setters
public:
  
  // Get the value of the dirty flag
  bool  GetDirty() {  return m_bDirty; }

  // Set the value of the dirty flag
  void  SetDirty(IN bool  i_bDirty) {  m_bDirty = i_bDirty; }

  HRESULT PutConsolePtr(
    IN const LPCONSOLE2         i_lpConsole
    ) { m_lpConsole = i_lpConsole; return S_OK; }

  STDMETHOD(OnNewDfsRoot)(
    );

  DISPLAY_OBJECT_TYPE GetDisplayObjectType(
    )
  {
    return DISPLAY_OBJECT_TYPE_ADMIN;
  };

  HRESULT CreateToolbar(
    IN const LPCONTROLBAR       i_pControlbar,
    IN const LPEXTENDCONTROLBAR i_lExtendControlbar,
    OUT  IToolbar**             o_pToolBar
    );

  HRESULT OnRefresh();

  virtual HRESULT OnAddImages(
      IImageList                *pImageList,
      HSCOPEITEM                hsi
      ) { return S_OK; } // no listview on the static node

  // Helper methods
private:

  // Menu Command handlers
  STDMETHOD(OnConnectTo)(
    );

  STDMETHOD(GetEntryPath)(
    BSTR*                       o_pbstrEntryPath
    ) { return E_NOTIMPL;};

  // Data members
private:                    
  
  DFS_ROOT_LIST                 m_RootList;        //  The list of Dfs Roots added to the snap-in
  
  HSCOPEITEM                    m_hItemParent;        // Parent of all nodes added in the Scope Pane
  CComPtr<IConsoleNameSpace>    m_lpConsoleNameSpace;    // The Callback used to do Scope Pane operations
  CComPtr<IConsole2>            m_lpConsole;        // The Console callback. The mother of all mmc interfaces

  bool                          m_bDirty;          // Dirty flag used while saving the console

public:
  CDfsSnapinScopeManager*       m_pScopeManager;  // The corresponding Scope Manager object
};

#endif // !defined(AFX_MMCDFSADMIN_H__2CC64E54_3BF4_11D1_AA17_00C06C00392D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mroots.h ===
/*++
Module Name:

    MRoots.cpp

Abstract:

    This module contains the declaration of the CMultiRoots.
    This class displays the Pick DFS Roots Dialog.

*/

#ifndef __MROOTS_H_
#define __MROOTS_H_

#include "resource.h"       // main symbols
#include "DfsEnums.h"
#include "netutils.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiRoots
class CMultiRoots : 
    public CDialogImpl<CMultiRoots>
{
public:
    CMultiRoots();
    ~CMultiRoots();

    enum { IDD = IDD_MROOTS };

BEGIN_MSG_MAP(CMultiRoots)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    MESSAGE_HANDLER(WM_HELP, OnCtxHelp)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnCtxMenuHelp)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()

//  Command Handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCtxMenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    //  Methods to access data in the dialog.
    HRESULT Init(BSTR i_bstrScope, ROOTINFOLIST *i_pRootList);
    HRESULT get_SelectedRootList(NETNAMELIST **o_ppSelectedRootList)
    {
        if (!o_ppSelectedRootList)
            return E_INVALIDARG;

        *o_ppSelectedRootList = &m_SelectedRootList;

        return S_OK;
    }

protected:
    CComBSTR      m_bstrScope;
    CComBSTR      m_bstrText;        // for IDC_MROOTS_TEXT
    ROOTINFOLIST* m_pRootList;
    NETNAMELIST   m_SelectedRootList;
};

#endif //__MROOTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mroots.cpp ===
/*++
Module Name:

    MRoots.cpp

Abstract:

    This module contains the Implementation of CMultiRoots.
    This class displays the Pick DFS Roots Dialog.

*/

#include "stdafx.h"
#include "utils.h"
#include "MRoots.h"
#include "dfshelp.h"

/////////////////////////////////////////////////////////////////////////////
// CMultiRoots

CMultiRoots::CMultiRoots() : m_pRootList(NULL)
{
}

CMultiRoots::~CMultiRoots()
{
    FreeNetNameList(&m_SelectedRootList);
}


HRESULT CMultiRoots::Init(BSTR i_bstrScope, ROOTINFOLIST *i_pRootList)
{
    if (!i_bstrScope || !*i_bstrScope ||
        !i_pRootList || !(i_pRootList->size()))
        return E_INVALIDARG;

    SAFE_SYSFREESTRING(&m_bstrScope);
    m_bstrScope = i_bstrScope;

    SAFE_SYSFREESTRING(&m_bstrText);
    HRESULT hr = FormatResourceString(IDS_MROOTS_TEXT, i_bstrScope, &m_bstrText);
    RETURN_IF_FAILED(hr);

    m_pRootList = i_pRootList;

    FreeNetNameList(&m_SelectedRootList);

    return S_OK;
}

LRESULT CMultiRoots::OnInitDialog
(
  UINT uMsg,
  WPARAM wParam,
  LPARAM lParam,
  BOOL& bHandled
)
{
    SetDlgItemText(IDC_MROOTS_TEXT, m_bstrText);

    HWND hwnd = GetDlgItem(IDC_MROOTS_LIST);

    HIMAGELIST  hImageList = NULL;
    int         nIconIDs[] = {IDI_16x16_FTROOT, IDI_16x16_SAROOT};
    HRESULT     hr = CreateSmallImageList(
                            _Module.GetResourceInstance(),
                            nIconIDs,
                            sizeof(nIconIDs) / sizeof(nIconIDs[0]),
                            &hImageList);
    if (SUCCEEDED(hr))
    {
        ListView_SetImageList(hwnd, hImageList, LVSIL_SMALL);

        for(ROOTINFOLIST::iterator i = m_pRootList->begin(); i != m_pRootList->end(); i++)
        {
            if ((*i)->bstrRootName) 
            {
                LVITEM  lvItem = {0};
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
                lvItem.pszText = (*i)->bstrRootName;
                lvItem.iSubItem = 0;
                lvItem.iImage = ((*i)->enumRootType == DFS_TYPE_FTDFS ? 0 : 1);
                ListView_InsertItem(hwnd, &lvItem);
            }
        }
    }

    return TRUE;  // Let the system set the focus
}

/*++
This function is called when a user clicks the ? in the top right of a property sheet
 and then clciks a control, or when they hit F1 in a control.
--*/
LRESULT CMultiRoots::OnCtxHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  LPHELPINFO lphi = (LPHELPINFO) i_lParam;
  if (!lphi || lphi->iContextType != HELPINFO_WINDOW || lphi->iCtrlId < 0)
    return FALSE;

  ::WinHelp((HWND)(lphi->hItemHandle),
        DFS_CTX_HELP_FILE,
        HELP_WM_HELP,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_MROOTS);

  return TRUE;
}

/*++
This function handles "What's This" help when a user right clicks the control
--*/
LRESULT CMultiRoots::OnCtxMenuHelp(
    IN UINT          i_uMsg,
    IN WPARAM        i_wParam,
    IN LPARAM        i_lParam,
    IN OUT BOOL&     io_bHandled
  )
{
  ::WinHelp((HWND)i_wParam,
        DFS_CTX_HELP_FILE,
        HELP_CONTEXTMENU,
        (DWORD_PTR)(PVOID)g_aHelpIDs_IDD_MROOTS);

  return TRUE;
}

LRESULT CMultiRoots::OnOK
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
    CWaitCursor wait;

    FreeNetNameList(&m_SelectedRootList);

    HRESULT hr = S_OK;
    HWND    hwnd = GetDlgItem(IDC_MROOTS_LIST);
    int     nIndex = -1;
    TCHAR   szText[MAX_PATH];
    do {
        while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_SELECTED)))
        {
            ListView_GetItemText(hwnd, nIndex, 0, szText, MAX_PATH);

            NETNAME* pCurrent = new NETNAME;
            BREAK_OUTOFMEMORY_IF_NULL(pCurrent, &hr);

            pCurrent->bstrNetName = szText;
            if (!(pCurrent->bstrNetName))
            {
                delete pCurrent;
                hr = E_OUTOFMEMORY;
                break;
            }

            m_SelectedRootList.push_back(pCurrent);
        }

    } while (0);

    if (FAILED(hr))
    {
        FreeNetNameList(&m_SelectedRootList);
        DisplayMessageBoxForHR(hr);
        return FALSE;
    }

    EndDialog(S_OK);
    return TRUE;
}

LRESULT CMultiRoots::OnCancel
(
  WORD wNotifyCode,
  WORD wID,
  HWND hWndCtl,
  BOOL& bHandled
)
{
  EndDialog(S_FALSE);
  return(true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcrep.h ===
/*++
Module Name:

    MmcRep.h

Abstract:

    This module contains the definition for CMmcDfsReplica class. This is an class 
    for MMC display related calls for the thrid level node(the DfsReplica nodes)

--*/



#if !defined(AFX_MMCDFSREPLICA_H__6A7EDAC4_3FAC_11D1_AA1C_00C06C00392D__INCLUDED_)
#define AFX_MMCDFSREPLICA_H__6A7EDAC4_3FAC_11D1_AA1C_00C06C00392D__INCLUDED_



#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include "DfsCore.h"
#include "MmcDispl.h"
#include "MmcRoot.h"
#include "MmcJP.h"
#include "NewFrs.h"

class CMmcDfsReplica : public CMmcDisplay
{
public:
    CMmcDfsReplica(
        IDfsReplica* i_pReplicaObject,
        CMmcDfsJunctionPoint* i_pJPObject
        );

    CMmcDfsReplica(
        IDfsReplica* i_pReplicaObject,
        CMmcDfsRoot* i_pJPObject
        );

    virtual ~CMmcDfsReplica();



    // For adding context menu items
    STDMETHOD(AddMenuItems)(    
        IN LPCONTEXTMENUCALLBACK    i_lpContextMenuCallback, 
        IN LPLONG                    i_lpInsertionAllowed
        );



    // For taking action on a context menu selection.
    STDMETHOD(Command)(
        IN LONG                        i_lCommandID
        );



    // Set the headers for the listview (in the result pane) column
    STDMETHOD(SetColumnHeader)(
        IN LPHEADERCTRL2               i_piHeaderControl
        );



    // Return the requested display information for the Result Pane
    STDMETHOD(GetResultDisplayInfo)(
        IN OUT LPRESULTDATAITEM        io_pResultDataItem
        );

    

    // Return the requested display information for the Scope Pane
    STDMETHOD(GetScopeDisplayInfo)(
        IN OUT  LPSCOPEDATAITEM        io_pScopeDataItem    
        ) { return S_OK; }

    

    // Add items(or folders), if any to the Scope Pane
    STDMETHOD(EnumerateScopePane)(
        IN LPCONSOLENAMESPACE        i_lpConsoleNameSpace,
        IN HSCOPEITEM                i_hParent
        ) { return S_OK; }



    // Add items(or folders), if any to the Result Pane
    STDMETHOD(EnumerateResultPane)(
        IN OUT     IResultData*            io_pResultData
        ) { return S_OK; }



    // Set the console verb settings. Change the state, decide the default verb, etc
    STDMETHOD(SetConsoleVerbs)(
        IN    LPCONSOLEVERB                i_lpConsoleVerb
        );


    // Add an item to the result pane
    STDMETHOD(AddItemToResultPane)(
        IN    IResultData*                i_lpResultData    
        );



    // Checks whether the object has pages to display
    STDMETHOD(QueryPagesFor)(
        ) { return S_FALSE; };



    // Creates and passes back the pages to be displayed
    STDMETHOD(CreatePropertyPages)(
        IN LPPROPERTYSHEETCALLBACK            i_lpPropSheetCallback,
        IN LONG_PTR                                i_lNotifyHandle
        ) { return E_UNEXPECTED; };



    // Used to notify the object that it's properties have changed
    STDMETHOD(PropertyChanged)(
        ) { return E_UNEXPECTED; };



    // Used to set the result view description bar text
    STDMETHOD(SetDescriptionBarText)(
        IN LPRESULTDATA                        i_lpResultData
        ) 
    { 
        RETURN_INVALIDARG_IF_NULL(i_lpResultData);
        return i_lpResultData->SetDescBarText(NULL);
    }

    STDMETHOD(SetStatusText)(
        IN LPCONSOLE2                        i_lpConsole
        )
    { 
        RETURN_INVALIDARG_IF_NULL(i_lpConsole);
        return i_lpConsole->SetStatusText(m_bstrStatusText);
    }

    // MMCN_DBLCLICK invoke the open ctxmenu.
    STDMETHOD(DoDblClick)(
        ) { (void) OnOpen();  return S_OK; }

    // Delete the current item.
    STDMETHOD(DoDelete)(
        );

    // Remove a replica
    STDMETHOD(RemoveReplica)(
        );
    
    // Remove a replica
    STDMETHOD(OnRemoveReplica)(
        );
    
    // confirm removal of replica
    STDMETHOD(ConfirmOperationOnDfsTarget)(int idString);

    // Check the replica status
    STDMETHOD(OnCheckStatus)(
        );

    // Handle a select event for the node. Handle only toolbar related 
    // activities here
    STDMETHOD(ToolbarSelect)(
        IN const LONG                                i_lArg,
        IN    IToolbar*                                i_pToolBar
        );



    // Handle a click on the toolbar
    STDMETHOD(ToolbarClick)(
        IN const LPCONTROLBAR                        i_pControlbar, 
        IN const LPARAM                                i_lParam
        );

    STDMETHOD(TakeReplicaOffline)(
        );

    STDMETHOD(ViewChange)(
        IResultData*        i_pResultData,
        LONG_PTR            i_lHint
    );

    DISPLAY_OBJECT_TYPE GetDisplayObjectType()
    { return DISPLAY_OBJECT_TYPE_REPLICA; }

    HRESULT CreateToolbar(
        IN const LPCONTROLBAR            i_pControlbar,
        IN const LPEXTENDCONTROLBAR                    i_lExtendControlbar,
        OUT    IToolbar**                    o_pToolBar
        );

    HRESULT OnRefresh(
        ) { return(E_NOTIMPL); }

    HRESULT OnReplicate();

    HRESULT OnStopReplication(BOOL bConfirm = FALSE);

    HRESULT GetReplicationInfo();

    HRESULT GetReplicationInfoEx(CAlternateReplicaInfo** o_ppInfo);

    HRESULT ShowReplicationInfo(IReplicaSet* i_piReplicaSet);

    HRESULT GetBadMemberInfo(
        IN  IReplicaSet* i_piReplicaSet,
        IN  BSTR    i_bstrServerName,
        OUT BSTR*   o_pbstrDnsHostName,
        OUT BSTR*   o_pbstrRootPath);

    HRESULT DeleteBadFRSMember(
        IN IReplicaSet* i_piReplicaSet,
        IN BSTR i_bstrDisplayName,
        IN HRESULT i_hres);

    HRESULT AddFRSMember(
        IN IReplicaSet* i_piReplicaSet,
        IN BSTR i_bstrDnsHostName,
        IN BSTR i_bstrRootPath,
        IN BSTR i_bstrStagingPath);

    HRESULT DeleteFRSMember(
        IN IReplicaSet* i_piReplicaSet,
        IN BSTR i_bstrDnsHostName,
        IN BSTR i_bstrRootPath);

    HRESULT RemoveReplicaFromSet();

    HRESULT AllowFRSMemberDeletion(BOOL* pbRepSetExist);

    // Internal methods
private:
    friend class CMmcDfsRoot;

    HRESULT OnOpen();

    STDMETHOD(RemoveFromMMC)() { return S_OK; }

    STDMETHOD(CleanScopeChildren)() { return S_OK; }

    STDMETHOD(CleanResultChildren)() { return S_OK; }

    STDMETHOD(GetEntryPath)(BSTR* o_pbstrEntryPath) { return E_NOTIMPL;}

    void _UpdateThisItem();

    // Constants, Statics, etc
public:
    static const int    m_iIMAGE_OFFSET;

    CComBSTR            m_bstrServerName;
    CComBSTR            m_bstrShareName;
    CComBSTR            m_bstrDisplayName;            // Display name of the current Replica
    long                m_lReferralState;
    long                m_lTargetState;

private:

    HRESULTITEM                 m_hResultItem;                // Resultitem handle
    CComPtr<IResultData>        m_pResultData;


    CComPtr<IDfsReplica>        m_pDfsReplicaObject;
    CMmcDfsJunctionPoint*       m_pDfsParentJP;
    CMmcDfsRoot*                m_pDfsParentRoot;

    BOOL                        m_bFRSMember;
    CAlternateReplicaInfo*      m_pRepInfo;
    CComBSTR                    m_bstrStatusText;
    CComBSTR                    m_bstrFRSColumnText;

    CComBSTR                    m_bstrDfsReferralColumnText;
    CComBSTR                    m_bstrTargetStatusColumnText;
};

#endif // !defined(AFX_MMCDFSREPLICA_H__6A7EDAC4_3FAC_11D1_AA1C_00C06C00392D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\dfsadmin\dfsgui\mmcroot.cpp ===
/*++
Module Name:

    MmcRoot.cpp

Abstract:

    This module contains the implementation for CMmcDfsRoot. This is an class 
  for MMC display related calls for the first level node(the DfsRoot nodes)
  Also contains members and method to be able to manipulate IDfsRoot object
  and add the same to the MMC Console
--*/

#include "stdafx.h"
#include <winuser.h>
#include "DfsGUI.h"
#include "Utils.h"      // For the LoadStringFromResource method
#include "MenuEnum.h"    // Contains the menu and toolbar command ids
#include "resource.h"    // For the Resource ID for strings, etc.
#include "MmcAdmin.h"    // For class CMmcDfsAdmin
#include "MmcRoot.h"
#include "MmcJP.h"      // For deleteing the child Junction points in the destructor of the root object
#include "MmcRep.h"
#include "DfsEnums.h"    // For DFS_TYPE_STANDALONE and other DfsRoot declarations
#include "AddToDfs.h"
#include "LinkFilt.h"
#include "DfsNodes.h"       // For Node GUIDs
#include "DfsWiz.h"      // For the wizard pages, CCreateDfsRootWizPage1, 2, ...
#include <lmdfs.h>
#include "permpage.h"
#include "ldaputils.h"

const int CMmcDfsRoot::m_iIMAGEINDEX = 0;
const int CMmcDfsRoot::m_iOPENIMAGEINDEX = 0;

//////////////////////////////////////////////////////////////////////////////////////////////////
// Constructor For   _JUNCTION_LIST

JP_LIST_NODE :: JP_LIST_NODE (CMmcDfsJunctionPoint* i_pMmcJP)      
{
  pJPoint = i_pMmcJP;
}


//////////////////////////////////////////////////////////////////////////////////////////////////
// destructor

JP_LIST_NODE :: ~JP_LIST_NODE ()
{
  SAFE_RELEASE(pJPoint);
}

CMmcDfsRoot::CMmcDfsRoot(
    IN IDfsRoot*            i_pDfsRoot,
    IN CMmcDfsAdmin*        i_pMmcDfsAdmin,
    IN LPCONSOLE2           i_lpConsole,  
    IN ULONG                i_ulLinkFilterMaxLimit, // = FILTERDFSLINKS_MAXLIMIT_DEFAULT,
    IN FILTERDFSLINKS_TYPE  i_lLinkFilterType,      // = FILTERDFSLINKS_TYPE_NO_FILTER,
    IN BSTR                 i_bstrLinkFilterName    // = NULL
    )
{
    dfsDebugOut((_T("CMmcDfsRoot::CMmcDfsRoot this=%p\n"), this));

    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pDfsRoot);
    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_pMmcDfsAdmin);
    MMC_DISP_CTOR_RETURN_INVALIDARG_IF_NULL(i_lpConsole);

    m_DfsRoot = i_pDfsRoot;      // Save the IDfsRoot pointer
    m_pParent = i_pMmcDfsAdmin;  // Save the parent pointer
    m_lpConsole = i_lpConsole;    // Save the console pointer

    HRESULT hr = m_DfsRoot->get_RootEntryPath(&m_bstrRootEntryPath);    // Get the Root entrypath.
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    hr = m_DfsRoot->get_DfsType((long *)&m_lDfsRootType);      // Get dfsroot type from the IDfsRoot
    MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);

    m_enumNewSchema = SCHEMA_VERSION_UNKNOWN;

    if (DFS_TYPE_FTDFS == m_lDfsRootType)
    {
        CComBSTR bstrDomainName;
        CComBSTR bstrDfsName;
        hr = m_DfsRoot->get_DomainName(&bstrDomainName);
        MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
        hr = m_DfsRoot->get_DfsName(&bstrDfsName);
        MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
        hr = GetDfsRootDisplayName(bstrDomainName, bstrDfsName, &m_bstrDisplayName);
        MMC_DISP_CTOR_RETURN_HR_IF_FAILED(hr);
    } else
    {
        m_bstrDisplayName = m_bstrRootEntryPath;
        MMC_DISP_CTOR_RETURN_OUTOFMEMORY_IF_NULL((BSTR)m_bstrDisplayName);
    }
  
    m_lpConsoleNameSpace = NULL;

    m_CLSIDNodeType = s_guidDfsRootNodeType;
    m_bstrDNodeType = s_tchDfsRootNodeType;

    m_lRootJunctionState = DFS_JUNCTION_STATE_UNASSIGNED;

    m_ulLinkFilterMaxLimit = i_ulLinkFilterMaxLimit;
    m_lLinkFilterType = i_lLinkFilterType;
    if (i_bstrLinkFilterName)
        m_bstrLinkFilterName = i_bstrLinkFilterName;
    else
        m_bstrLinkFilterName.Empty();

    m_bShowFRS = FALSE;
}



CMmcDfsRoot::~CMmcDfsRoot(
  )
{
    // Silently close all outstanding property sheets.
    CloseAllPropertySheets(TRUE);

    // Clean up display objects of children and result pane.
    CleanScopeChildren();
    CleanResultChildren();

    if ((IReplicaSet *)m_piReplicaSet)
        m_piReplicaSet.Release();

    dfsDebugOut((_T("CMmcDfsRoot::~CMmcDfsRoot this=%p\n"), this));
}




STDMETHODIMP
CMmcDfsRoot::AddItemToScopePane(
  IN LPCONSOLENAMESPACE     i_lpConsoleNameSpace,
  IN HSCOPEITEM             i_hItemParent
  )
/*++

Routine Description:

This routine adds the current item(itself) to the Scope pane.

Arguments:

    lpConsoleNameSpace  -  The interface which tells add item to the scope pane. A callback

    hItemParent      -  The handle of the parent. The current item is added as this 
              item's child

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpConsoleNameSpace);
    RETURN_INVALIDARG_IF_NULL(i_hItemParent);

    BOOL    bReplicaSetExist = FALSE;
    HRESULT hr = m_DfsRoot->get_ReplicaSetExist(&bReplicaSetExist);

    if (SUCCEEDED(hr))
    {
        SCOPEDATAITEM  ScopeItemDfsRoot;
        ZeroMemory(&ScopeItemDfsRoot, sizeof(ScopeItemDfsRoot));

        ScopeItemDfsRoot.mask = SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM | SDI_STR | SDI_PARENT;
        ScopeItemDfsRoot.nImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0);
        ScopeItemDfsRoot.nOpenImage = CMmcDfsRoot::m_iOPENIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + (bReplicaSetExist ? 4 : 0);
        ScopeItemDfsRoot.lParam = reinterpret_cast<LPARAM>(this);
        ScopeItemDfsRoot.displayname = MMC_TEXTCALLBACK;
        ScopeItemDfsRoot.relativeID = i_hItemParent;

        hr = i_lpConsoleNameSpace->InsertItem(&ScopeItemDfsRoot);
        RETURN_IF_FAILED(hr);

        m_hScopeItem = ScopeItemDfsRoot.ID;

        m_lpConsoleNameSpace = i_lpConsoleNameSpace;
    }

    return S_OK;
}




STDMETHODIMP 
CMmcDfsRoot::AddMenuItems(  
  IN LPCONTEXTMENUCALLBACK  i_lpContextMenuCallback, 
  IN LPLONG                 i_lpInsertionAllowed
  )
/*++

Routine Description:

This routine adds a context menu using the ContextMenuCallback provided.

Arguments:

    lpContextMenuCallback - A callback(function pointer) that is used to add the menu items

    lpInsertionAllowed - Specifies what menus can be added and where they can be added.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpContextMenuCallback);

    enum 
    {  
        IDM_CONTEXTMENU_COMMAND_MAX = IDM_ROOT_MAX,
        IDM_CONTEXTMENU_COMMAND_MIN = IDM_ROOT_MIN
    };

    LONG    lInsertionPoints [IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] = { 
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP
                        };
    LPTSTR aszLanguageIndependentName[IDM_CONTEXTMENU_COMMAND_MAX - IDM_CONTEXTMENU_COMMAND_MIN + 1] =
                        {
                        _T("RootTopNewDfsLink"),
                        _T("RootTopNewRootReplica"),
                        _T("RootTopCheckStatus"),
                        _T("RootTopFilterDfsLinks"),
                        _T("RootTopDeleteConnectionToDfsRoot"),
                        _T("RootTopDeleteDfsRoot"),
                        _T("RootTopDeleteDisplayedDfsLinks"),
                        _T("RootTopReplicationTopology"),
                        _T("RootTopShowReplication"),
                        _T("RootTopHideReplication"),
                        _T("RootTopStopReplication")
                        };

    CComPtr<IContextMenuCallback2> spiCallback2;
    HRESULT hr = i_lpContextMenuCallback->QueryInterface(IID_IContextMenuCallback2, (void **)&spiCallback2);
    RETURN_IF_FAILED(hr);

    // select the node to populate m_MmcRepList
    if (m_MmcRepList.empty())
        m_lpConsole->SelectScopeItem(m_hScopeItem);

    BOOL    bReplicaSetExist = FALSE;
    hr = m_DfsRoot->get_ReplicaSetExist(&bReplicaSetExist);
    RETURN_IF_FAILED(hr);
    
    for (int iCommandID = IDM_CONTEXTMENU_COMMAND_MIN,iMenuResource = IDS_MENUS_ROOT_TOP_NEW_DFS_LINK;
        iCommandID <= IDM_CONTEXTMENU_COMMAND_MAX; 
        iCommandID++,iMenuResource++ )
    {
        CONTEXTMENUITEM2    ContextMenuItem;  // The structure which contains menu information
        ZeroMemory(&ContextMenuItem, sizeof(ContextMenuItem));

        switch (iCommandID)
        {
        case IDM_ROOT_TOP_NEW_ROOT_REPLICA:
            {
                if (DFS_TYPE_STANDALONE == m_lDfsRootType)    
                    continue;
                break;
            }
        case IDM_ROOT_TOP_DELETE_DISPLAYED_DFS_LINKS:
            {
                if (m_MmcJPList.empty())
                    continue;
                break;
            }
        case IDM_ROOT_TOP_REPLICATION_TOPOLOGY:
            {
                if (bReplicaSetExist || (1 >= m_MmcRepList.size()) || (DFS_TYPE_STANDALONE == m_lDfsRootType))
                    continue;
                break;
            }
        case IDM_ROOT_TOP_SHOW_REPLICATION:
            {
                if (!bReplicaSetExist || m_bShowFRS)
                    continue;
                break;
            }
        case IDM_ROOT_TOP_HIDE_REPLICATION:
            {
                if (!bReplicaSetExist || !m_bShowFRS)
                    continue;
                break;
            }
        case IDM_ROOT_TOP_STOP_REPLICATION:
            {
                if (!bReplicaSetExist)
                    continue;
                break;
            }
        case IDM_ROOT_TOP_NEW_DFS_LINK:
        case IDM_ROOT_TOP_CHECK_STATUS:
        case IDM_ROOT_TOP_FILTER_DFS_LINKS:
            { // excluded when empty root container
                if (m_MmcRepList.empty())
                    continue;
                break;
            }
        }

        CComBSTR bstrMenuText;
        CComBSTR bstrStatusBarText;
        hr = GetMenuResourceStrings(iMenuResource, &bstrMenuText, NULL, &bstrStatusBarText);
        RETURN_IF_FAILED(hr);  
    
        ContextMenuItem.strName = bstrMenuText;  // Assign the menu text
        ContextMenuItem.strStatusBarText = bstrStatusBarText;  // Assign the menu help text
        ContextMenuItem.lInsertionPointID = lInsertionPoints[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];
        ContextMenuItem.lCommandID = iCommandID;
        ContextMenuItem.strLanguageIndependentName = aszLanguageIndependentName[iCommandID - IDM_CONTEXTMENU_COMMAND_MIN];

        LONG        lInsertionFlag = 0;
        switch(ContextMenuItem.lInsertionPointID)  // Checking for permission to add menus
        {
        case CCM_INSERTIONPOINTID_PRIMARY_TOP:
            lInsertionFlag = CCM_INSERTIONALLOWED_TOP;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_NEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_NEW;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_TASK:
            lInsertionFlag = CCM_INSERTIONALLOWED_TASK;
            break;
        case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
            lInsertionFlag = CCM_INSERTIONALLOWED_VIEW;
            break;
        default:
            break;
        }

        if (*i_lpInsertionAllowed & lInsertionFlag)
        {
            hr = spiCallback2->AddItem(&ContextMenuItem);
            RETURN_IF_FAILED(hr);
        }

    } // for

    return hr;
}



STDMETHODIMP 
CMmcDfsRoot::GetScopeDisplayInfo(
  IN OUT  LPSCOPEDATAITEM    io_pScopeDataItem
  )
/*++

Routine Description:

Returns the information required for MMC display for this item.

Arguments:

    i_pScopeDataItem - The ScopeItem which specifies what display information is required

--*/
{
    RETURN_INVALIDARG_IF_NULL(io_pScopeDataItem);

    HRESULT hr = S_OK;

    if (SDI_STR & io_pScopeDataItem->mask)  // MMC wants the displaystring
    {
        ULONG     ulTotalNumOfJPs = 0;
        hr = m_DfsRoot->get_CountOfDfsJunctionPoints((long*)&ulTotalNumOfJPs);
        RETURN_IF_FAILED(hr);

        if (m_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER ||
            m_MmcJPList.size() < ulTotalNumOfJPs)
        {
            m_bstrFullDisplayName.Empty();
            hr = FormatMessageString(&m_bstrFullDisplayName,
                        0,
                        IDS_DFSROOT_DISPLAY_STRING,
                        m_bstrDisplayName);
            RETURN_IF_FAILED(hr);

            io_pScopeDataItem->displayname = m_bstrFullDisplayName;
        } else
        {
            io_pScopeDataItem->displayname = m_bstrDisplayName;
        }
    }
  
    if (SDI_IMAGE & io_pScopeDataItem->mask)  // MMC wants the image index for the item
        io_pScopeDataItem->nImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + m_lRootJunctionState;

    if (SDI_OPENIMAGE & io_pScopeDataItem->mask)  // MMC wants the image index for the item
        io_pScopeDataItem->nOpenImage = CMmcDfsRoot::m_iOPENIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + m_lRootJunctionState;

    return hr;
}




STDMETHODIMP 
CMmcDfsRoot::GetResultDisplayInfo(
  IN OUT LPRESULTDATAITEM    io_pResultDataItem
  )
/*++

Routine Description:

Returns the information required for MMC display for this item.

Arguments:

    io_pResultDataItem - The ResultItem which specifies what display information is required

--*/
{
  RETURN_INVALIDARG_IF_NULL(io_pResultDataItem);

  if (RDI_IMAGE & io_pResultDataItem->mask)  // MMC wants the image index for the item
    io_pResultDataItem->nImage = CMmcDfsRoot::m_iIMAGEINDEX + ((DFS_TYPE_FTDFS == m_lDfsRootType)? 4 : 0) + m_lRootJunctionState;

  if (RDI_STR & io_pResultDataItem->mask)  // MMC wants the text for the item
  {    
    if (0 == io_pResultDataItem->nCol)      // Return the Dfs Root display name
      io_pResultDataItem->str = m_bstrDisplayName;
  }

  return S_OK;
}



STDMETHODIMP 
CMmcDfsRoot::Command(
  IN LONG      i_lCommandID
  ) 
/*++

Routine Description:

Action to be taken on a context menu selection or click is takes place.

Arguments:

    lCommandID - The Command ID of the menu for which action has to be taken

--*/
{ 
    HRESULT    hr = S_OK;

    switch (i_lCommandID)
    {
    case IDM_ROOT_TOP_NEW_DFS_LINK:
        hr = OnCreateNewJunctionPoint ();
        break;
    case IDM_ROOT_TOP_NEW_ROOT_REPLICA:
        hr = OnNewRootReplica();
        break;
    case IDM_ROOT_TOP_CHECK_STATUS:
        hr = OnCheckStatus();
        break;
    case IDM_ROOT_TOP_DELETE_DISPLAYED_DFS_LINKS:
        hr = OnDeleteDisplayedDfsLinks();
        break;
    case IDM_ROOT_TOP_DELETE_DFS_ROOT:      // Delete the Current dfs root
        hr = OnDeleteDfsRoot();
        break;
    case IDM_ROOT_TOP_DELETE_CONNECTION_TO_DFS_ROOT:  // "Delete Connection to Dfs Root"
        hr = OnDeleteConnectionToDfsRoot();
        break;
    case IDM_ROOT_TOP_FILTER_DFS_LINKS:
        hr = OnFilterDfsLinks();
        break;
    case IDM_ROOT_TOP_REPLICATION_TOPOLOGY:
        hr = OnNewReplicaSet();
        break;
    case IDM_ROOT_TOP_SHOW_REPLICATION:
    case IDM_ROOT_TOP_HIDE_REPLICATION:
        m_bShowFRS = !m_bShowFRS;
        hr = OnShowReplication();
        break;
    case IDM_ROOT_TOP_STOP_REPLICATION:
        hr = OnStopReplication(TRUE);
        if (FAILED(hr))
            DisplayMessageBoxForHR(hr);
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr; 
}

HRESULT CMmcDfsRoot::_InitReplicaSet()
{
    if (m_lDfsRootType != DFS_TYPE_FTDFS)
        return S_FALSE;  // no replica set associate with standalone root

    BOOL bReplicaSetExist = FALSE;
    CComBSTR bstrDC;
    HRESULT hr = m_DfsRoot->get_ReplicaSetExistEx(&bstrDC, &bReplicaSetExist);
    RETURN_IF_FAILED(hr);

    if (!bReplicaSetExist)
    {
        if ((IReplicaSet *)m_piReplicaSet)
            m_piReplicaSet.Release();

        return S_FALSE;  // no replica set associate with it
    }

    if ((IReplicaSet *)m_piReplicaSet)
    {
        CComBSTR bstrTargetedDC;
        hr = m_piReplicaSet->get_TargetedDC(&bstrTargetedDC);
        if (FAILED(hr) || lstrcmpi(bstrTargetedDC, bstrDC))
        {
            // something is wrong or we're using a different DC, re-init m_piReplicaSet
            m_piReplicaSet.Release();
        }
    }

    if (!m_piReplicaSet)
    {
        CComBSTR bstrDomain;
        hr = m_DfsRoot->get_DomainName(&bstrDomain);
        RETURN_IF_FAILED(hr);

        CComBSTR bstrReplicaSetDN;
        hr = m_DfsRoot->get_ReplicaSetDN(&bstrReplicaSetDN);
        RETURN_IF_FAILED(hr);

        //
        // read info of the replica set from DS
        //
        hr = CoCreateInstance(CLSID_ReplicaSet, NULL, CLSCTX_INPROC_SERVER, IID_IReplicaSet, (void**) &m_piReplicaSet);
        RETURN_IF_FAILED(hr);

        hr = m_piReplicaSet->Initialize(bstrDomain, bstrReplicaSetDN);
        if (FAILED(hr))
        {
            m_piReplicaSet.Release();
            return hr;
        }
    }

    return hr;
}

HRESULT CMmcDfsRoot::OnNewReplicaSet()
{
    //
    // refresh to pick up possible namespace updates on targets by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this root has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr;
    }

    CWaitCursor wait;

    //
    // Use MMC main window as the parent as our modal wizard
    //
    HWND  hwndParent = 0;
    hr = m_lpConsole->GetMainWindow(&hwndParent);
    RETURN_IF_FAILED(hr);

    BOOL    bReplicaSetExist = FALSE;
    m_DfsRoot->get_ReplicaSetExist(&bReplicaSetExist);
    if (bReplicaSetExist) // replica set exist, return
        return S_OK;

    CComBSTR bstrDomain;
    hr = m_DfsRoot->get_DomainName(&bstrDomain);
    RETURN_IF_FAILED(hr);

    CComBSTR bstrReplicaSetDN;
    hr = m_DfsRoot->get_ReplicaSetDN(&bstrReplicaSetDN);
    RETURN_IF_FAILED(hr);

    CNewReplicaSet      ReplicaSetInfo;
    hr = ReplicaSetInfo.Initialize(bstrDomain, bstrReplicaSetDN, &m_MmcRepList);
    RETURN_IF_FAILED(hr);
    
    CNewReplicaSetPage0      WizPage0;
    CNewReplicaSetPage1      WizPage1(&ReplicaSetInfo);
    CNewReplicaSetPage2      WizPage2(&ReplicaSetInfo, IsNewSchema());

    CComPtr<IPropertySheetCallback>  pPropSheetCallback;  // MMC Callback used to add pages
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetCallback, reinterpret_cast<void**>(&pPropSheetCallback));
    RETURN_IF_FAILED(hr);

    CComPtr<IPropertySheetProvider>  pPropSheetProvider;  // MMC callback used to handle wizard
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetProvider, reinterpret_cast<void**>(&pPropSheetProvider));
    RETURN_IF_FAILED(hr);

    hr = pPropSheetProvider->CreatePropertySheet(  
                                _T(""), // title
                                FALSE,  // Wizard and not property sheet.
                                0,      // Cookie
                                NULL,   // IDataobject
                                MMC_PSO_NEWWIZARDTYPE);  // Creation flags
    if (SUCCEEDED(hr))
    {
        pPropSheetCallback->AddPage(WizPage0.Create());
        pPropSheetCallback->AddPage(WizPage1.Create());
        pPropSheetCallback->AddPage(WizPage2.Create());

        hr = pPropSheetProvider->AddPrimaryPages(
                                NULL,
                                FALSE,  // Don't create a notify handle
                                NULL, 
                                TRUE    // Scope pane (not result pane)
                                );

        if (SUCCEEDED(hr))
            hr = pPropSheetProvider->Show((LONG_PTR)hwndParent, 0);

        //
        // If failed, call IPropertySheetProvider::Show(-1,0) to 
        // delete the property sheet and free its resources
        //
        if (FAILED(hr))
            pPropSheetProvider->Show(-1, 0);
    }

    RETURN_IF_FAILED(hr);

    //
    // handle th result
    //
    if (S_OK == ReplicaSetInfo.m_hr)
    {
        //
        // store the interface pointer
        //
        m_piReplicaSet = ReplicaSetInfo.m_piReplicaSet;
        m_DfsRoot->put_ReplicaSetExist(TRUE);

        //
        // update icon
        //
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        ScopeDataItem.ID = m_hScopeItem;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.nImage += 4;
            ScopeDataItem.nOpenImage += 4;
            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);

            // update the toolbar
            m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);
        }
    }

    return hr;
}

HRESULT CMmcDfsRoot::OnShowReplication()
{
    BOOL bShowFRS = m_bShowFRS; // save it because refresh will reset it to FALSE

    //
    // refresh to pick up possible namespace updates on targets by others
    //
    HRESULT hr = OnRefresh();
    if (S_FALSE == hr)
    {
        // this root has been deleted by others, no more reference
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr;
    }

    CWaitCursor wait;

    DFS_REPLICA_LIST::iterator i;
    if (bShowFRS)
    {
        //
        // init m_piReplicaSet
        //
        hr = _InitReplicaSet();
        if (S_OK != hr) // no replica set, do nothing and return
            return S_OK;

        //
        // fill in each alternate m_bstrFRSColumnText and m_bstrStatusText
        //
        for (i = m_MmcRepList.begin(); i != m_MmcRepList.end(); i++)
        {
            ((*i)->pReplica)->ShowReplicationInfo(m_piReplicaSet);
        }

        m_bShowFRS = TRUE;
    }

    // update the toolbar
    m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return hr;
}

HRESULT 
CMmcDfsRoot::OnStopReplication(BOOL bConfirm /* = FALSE */, BOOL bRefresh /* = TRUE */)
{
    HRESULT hr = S_OK;

    //
    // refresh to pick up possible namespace updates on targets by others
    //
    if (bRefresh)
    {
        hr = OnRefresh();
        if (S_FALSE == hr)
        {
            // this root has been deleted by others, no more reference
            DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
            return hr;
        }
    }

    CWaitCursor wait;

    BOOL    bReplicaSetExist = FALSE;
    m_DfsRoot->get_ReplicaSetExist(&bReplicaSetExist);
    if (!bReplicaSetExist) // replica set doesn't exist, return
        return S_OK;

    if (bConfirm)
    {
        hr = ConfirmOperationOnDfsRoot(IDS_MSG_STOP_REPLICATION);
        if (S_OK != hr) return hr;
    }

    //
    // init m_piReplicaSet
    //
    hr = _InitReplicaSet();
    if (S_OK != hr) // no replica set, return
        return hr;

    hr = m_piReplicaSet->Delete();
    if (SUCCEEDED(hr))
    {
        m_piReplicaSet.Release();
        hr = m_DfsRoot->put_ReplicaSetExist(FALSE);

        SCOPEDATAITEM     ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.mask = SDI_IMAGE | SDI_OPENIMAGE;
        ScopeDataItem.ID = m_hScopeItem;
        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.nImage -= 4;
            ScopeDataItem.nOpenImage -= 4;
            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);

            // update the toolbar
            m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);
        }
    }

    return hr;
}

STDMETHODIMP 
CMmcDfsRoot::OnNewRootReplica(
  )
/*++

Routine Description:

  Action to be taken on menu command "New Root Replica Member".
  Here is a wizard is used to guide the user through the process of 
  Deciding a new server and share.
--*/
{
    // Select this node to make sure m_MmcRepList populated
    if (m_MmcRepList.empty())
        m_lpConsole->SelectScopeItem(m_hScopeItem);

    //
    // Use MMC main window as the parent as our modal wizard
    //
    HWND  hwndMainWin = 0;
    HRESULT hr = m_lpConsole->GetMainWindow(&hwndMainWin);
    RETURN_IF_FAILED(hr);

    CREATEDFSROOTWIZINFO      CreateWizInfo;    // 0 initializes all members to 0. Necessary
    CreateWizInfo.pMMCAdmin = m_pParent;
    CreateWizInfo.bRootReplica = true;            // Set the flag that says this is for root replica

                  // Set the domain name and the dfs type
    hr = m_DfsRoot->get_DomainName(&CreateWizInfo.bstrSelectedDomain);
    RETURN_IF_FAILED(hr);

    CreateWizInfo.DfsType = DFS_TYPE_FTDFS;
    hr = m_DfsRoot->get_DfsName(&CreateWizInfo.bstrDfsRootName);
    RETURN_IF_FAILED(hr);

    CCreateDfsRootWizPage4      WizPage4(&CreateWizInfo);
    CCreateDfsRootWizPage5      WizPage5(&CreateWizInfo);
    CCreateDfsRootWizPage7      WizPage7(&CreateWizInfo);

    // Get the required interfaces from IConsole2.
    CComPtr<IPropertySheetCallback>  pPropSheetCallback;  // MMC Callback used to add pages
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetCallback, reinterpret_cast<void**>(&pPropSheetCallback));
    RETURN_IF_FAILED(hr);

    CComPtr<IPropertySheetProvider>  pPropSheetProvider;  // MMC callback used to handle wizard
    hr = m_lpConsole->QueryInterface(IID_IPropertySheetProvider, reinterpret_cast<void**>(&pPropSheetProvider));
    RETURN_IF_FAILED(hr);

    // Create the wizard
    hr = pPropSheetProvider->CreatePropertySheet(  
                                _T(""),         // Property sheet title. Should not be null so send empty string.
                                FALSE,          // Wizard and not property sheet.
                                0,              // Cookie
                                NULL,           // IDataobject
                                MMC_PSO_NEWWIZARDTYPE);  // Creation flags
    if (SUCCEEDED(hr))
    {
        pPropSheetCallback->AddPage(WizPage4.Create());
        pPropSheetCallback->AddPage(WizPage5.Create());
        pPropSheetCallback->AddPage(WizPage7.Create());

        hr = pPropSheetProvider->AddPrimaryPages(
                                (IComponentData *)(m_pParent->m_pScopeManager), 
                                FALSE,      // Don't create a notify handle
                                NULL, 
                                TRUE        // Scope pane (not result pane)
                                );

        if (SUCCEEDED(hr))
            hr = pPropSheetProvider->Show(
                                (LONG_PTR)hwndMainWin,  // Parent window of the wizard
                                0                       // Starting page
                                ); 
        //
        // If failed, call IPropertySheetProvider::Show(-1,0) to 
        // delete the property sheet and free its resources
        //
        if (FAILED(hr))
            pPropSheetProvider->Show(-1, 0);
    }

    RETURN_IF_FAILED(hr);

    if (CreateWizInfo.bDfsSetupSuccess)
        return OnRefresh(); // to pick the most recent root targets and links

    return (S_OK);
}




STDMETHODIMP 
CMmcDfsRoot::SetColumnHeader(
  IN LPHEADERCTRL2     i_piHeaderControl
  )
{
    RETURN_INVALIDARG_IF_NULL(i_piHeaderControl);

    CComBSTR  bstrColumn0;
    HRESULT hr = LoadStringFromResource(IDS_RESULT_COLUMN_ROOTREPLICA, &bstrColumn0);
    RETURN_IF_FAILED(hr);

    CComBSTR  bstrColumn1;
    hr = LoadStringFromResource(IDS_RESULT_COLUMN_DFSREFERRAL, &bstrColumn1);
    RETURN_IF_FAILED(hr);

    CComBSTR  bstrColumn2;
    hr = LoadStringFromResource(IDS_RESULT_COLUMN_STATUS, &bstrColumn2);
    RETURN_IF_FAILED(hr);

    i_piHeaderControl->InsertColumn(0, bstrColumn0, LVCFMT_LEFT, DFS_NAME_COLUMN_WIDTH);
    i_piHeaderControl->InsertColumn(1, bstrColumn1, LVCFMT_LEFT, MMCLV_AUTO);
    i_piHeaderControl->InsertColumn(2, bstrColumn2, LVCFMT_LEFT, MMCLV_AUTO);

    if (m_bShowFRS)
    {
        CComBSTR  bstrColumn3;
        hr = LoadStringFromResource(IDS_RESULT_COLUMN_FRS, &bstrColumn3);
        RETURN_IF_FAILED(hr);

        i_piHeaderControl->InsertColumn(3, bstrColumn3, LVCFMT_LEFT, MMCLV_AUTO);
    } else
    {
        i_piHeaderControl->DeleteColumn(3);
    }

    return hr;
}




STDMETHODIMP 
CMmcDfsRoot::OnDeleteConnectionToDfsRoot(
  BOOLEAN              i_bForRemoveDfs
  )
/*++

Routine Description:

Used to delete the current object. Both to remove from Scope and from list

--*/
{
    // check outstanding property sheet, discontinue if any.
    HRESULT hr = CloseAllPropertySheets(FALSE);
    if (S_OK != hr)
        return hr;

    // Confirm with the user, if he wants to delete this connection
    hr = ConfirmOperationOnDfsRoot(i_bForRemoveDfs ? IDS_MSG_DELETE_DFSROOT : IDS_MSG_DELETE_CONNECTION_TO_DFSROOT);
    if (S_OK != hr) return hr;

    CWaitCursor wait;

    CleanScopeChildren();

    // Delete the item from Scope Pane
    hr = m_lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);
    RETURN_IF_FAILED(hr);

    // Delete it from the internal list
    hr = m_pParent->DeleteMmcRootNode(this);
    RETURN_IF_FAILED(hr);
  
    Release();  // delete this CMmcDfsRoot object

    return S_OK;
}

// Delete the node from m_MmcJPList
STDMETHODIMP
CMmcDfsRoot::DeleteMmcJPNode(
  IN CMmcDfsJunctionPoint*    i_pJPoint,
  IN BOOL                     i_bRefresh
  )
{
  RETURN_INVALIDARG_IF_NULL(i_pJPoint);

  dfsDebugOut((_T("CMmcDfsRoot::DeleteMmcJPNode %p, size=%d\n"), i_pJPoint, m_MmcJPList.size()));

  // Remove the actual junction point(from DS)
  HRESULT hr = m_DfsRoot->DeleteJunctionPoint(i_pJPoint->m_bstrDisplayName);  
  RETURN_IF_FAILED(hr);

  // Delete the node from m_MmcJPList
  for (DFS_JUNCTION_LIST::iterator i = m_MmcJPList.begin(); i != m_MmcJPList.end(); i++)
  {
    if ((*i)->pJPoint == i_pJPoint)
    {
      (*i)->pJPoint->RemoveFromMMC();
      delete (*i);
      m_MmcJPList.erase(i);
      break;
    }
  }

  if (i_bRefresh)
  {
    hr = OnRefresh(); 
    if (S_FALSE == hr)
    {
        //
        // this root has been deleted by other means, scope pane has been refreshed,
        // ask user to retry
        //
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr;
    }
  }

  return hr;
}

HRESULT 
CMmcDfsRoot::ConfirmOperationOnDfsRoot(int idString)
/*++

Routine Description:

Used to confirm with the user, if he wants to delete the connection to the Dfs Root

Return value:

  S_OK, if the user wants to delete.
  S_FALSE, if the user decided not to continue with the operation.
--*/
{
  // Confirm delete operation
  CComBSTR  bstrAppName;
  HRESULT   hr = LoadStringFromResource(IDS_APPLICATION_NAME, &bstrAppName);
  RETURN_IF_FAILED(hr);
  
  CComBSTR  bstrFormattedMessage;
  hr = FormatResourceString(idString, m_bstrDisplayName, &bstrFormattedMessage);
  RETURN_IF_FAILED(hr);

  // Return now, if the user doesn't want to continue
  CThemeContextActivator activator;
  if (IDYES != ::MessageBox(::GetActiveWindow(), bstrFormattedMessage, bstrAppName, MB_YESNO | MB_ICONEXCLAMATION | MB_APPLMODAL))
  {
    return S_FALSE;
  }

  return S_OK;
}

HRESULT 
CMmcDfsRoot::ConfirmDeleteDisplayedDfsLinks(
  )
{
  // Confirm delete operation
  CComBSTR  bstrAppName;
  HRESULT   hr = LoadStringFromResource(IDS_APPLICATION_NAME, &bstrAppName);
  RETURN_IF_FAILED(hr);
  
  CComBSTR  bstrMessage;
  hr = LoadStringFromResource(IDS_MSG_DELETE_DISPLAYEDDFSLINKS, &bstrMessage);
  RETURN_IF_FAILED(hr);

  // Return now, if the user doesn't want to continue
  CThemeContextActivator activator;
  if (IDYES != ::MessageBox(::GetActiveWindow(), bstrMessage, bstrAppName, MB_YESNO | MB_ICONEXCLAMATION | MB_APPLMODAL))
  {
    return S_FALSE;
  }

  return S_OK;
}


STDMETHODIMP 
CMmcDfsRoot::EnumerateScopePane(
  IN LPCONSOLENAMESPACE     i_lpConsoleNameSpace,
  IN HSCOPEITEM             i_hParent
  )
/*++

Routine Description:

To eumerate(add) items in the scope pane. Junction points in this case

Arguments:

  i_lpConsoleNameSpace - The callback used to add items to the Scope pane

    i_hParent -  HSCOPEITEM of the parent under which all the items will be added.

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_lpConsoleNameSpace);
    RETURN_INVALIDARG_IF_NULL(i_hParent);

    HRESULT hr = m_DfsRoot->put_EnumFilterType(m_lLinkFilterType);
    RETURN_IF_FAILED(hr);

    if (m_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
    {
        hr = m_DfsRoot->put_EnumFilter(m_bstrLinkFilterName);
        RETURN_IF_FAILED(hr);
    }

    CComPtr<IEnumVARIANT>   pJPEnum;
    hr = m_DfsRoot->get__NewEnum((IUnknown**) (&pJPEnum));
    RETURN_IF_FAILED(hr);

    hr = m_DfsRoot->get_CountOfDfsJunctionPointsFiltered((long*)&m_ulCountOfDfsJunctionPointsFiltered);
    RETURN_IF_FAILED(hr);

    VARIANT varJPObject;
    VariantInit(&varJPObject);
    ULONG   ulCount = 0;

    while ( ulCount < m_ulLinkFilterMaxLimit && S_OK == (hr = pJPEnum->Next(1, &varJPObject, NULL)) )
    {
        CComPtr<IDfsJunctionPoint>  pDfsJPObject;  
        pDfsJPObject = (IDfsJunctionPoint*) varJPObject.pdispVal;
      
                    // Create the object to be used for MMC display
        CMmcDfsJunctionPoint* pMMCJPObject = new CMmcDfsJunctionPoint (pDfsJPObject, this, i_lpConsoleNameSpace);
        if (!pMMCJPObject)
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            hr = pMMCJPObject->m_hrValueFromCtor;

            if (SUCCEEDED(hr))    
                hr = pMMCJPObject->AddItemToScopePane(i_hParent);

            if (SUCCEEDED(hr))
            {
                JP_LIST_NODE *pJPList = new JP_LIST_NODE (pMMCJPObject);
                if (!pJPList)
                    hr = E_OUTOFMEMORY;
                else
                    m_MmcJPList.push_back(pJPList);
            }

            if (FAILED(hr))
                delete pMMCJPObject;
        }

        VariantClear(&varJPObject);

        if (FAILED(hr))
            break;

        ulCount++;
    }

    //
    // set the root name appropriately
    //
    if (SUCCEEDED(hr))
    {
        SCOPEDATAITEM      ScopeDataItem;
        ZeroMemory(&ScopeDataItem, sizeof(SCOPEDATAITEM));
        ScopeDataItem.ID = i_hParent;

        hr = m_lpConsoleNameSpace->GetItem(&ScopeDataItem);
        if (SUCCEEDED(hr))
        {
            ScopeDataItem.mask = SDI_STR;
            ScopeDataItem.displayname = MMC_TEXTCALLBACK;
            m_lpConsoleNameSpace->SetItem(&ScopeDataItem);
        }
    }

    return hr;
}


STDMETHODIMP 
CMmcDfsRoot::SetConsoleVerbs(
  IN  LPCONSOLEVERB      i_lpConsoleVerb
  ) 
/*++

Routine Description:

  Routine used to set the console verb settings.
  Sets all of them except Open off. 
  For all scope pane items, default verb is "open'. For result items, 
  it is "properties"


Arguments:

    i_lpConsoleVerb -  The callback used to handle console verbs


--*/
{
  RETURN_INVALIDARG_IF_NULL(i_lpConsoleVerb);

  i_lpConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_PRINT, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
    
  i_lpConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
  i_lpConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
            
  i_lpConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN); //For scope items, default verb is "open"

  return S_OK; 
}


STDMETHODIMP 
CMmcDfsRoot :: OnCreateNewJunctionPoint(
  ) 
/*++

Routine Description:

  This method handles the creation of new Junction Points.
  Display a dialog box to get the user input.

--*/
{
    CAddToDfs   AddToDfsDlg;  //Add To Dfs Dialog Object
    HRESULT     hr = AddToDfsDlg.put_ParentPath(m_bstrRootEntryPath);
    RETURN_IF_FAILED(hr);

    hr = AddToDfsDlg.DoModal();          // Display the dialog box
    RETURN_IF_NOT_S_OK(hr);

    hr = OnRefresh(); 
    if (S_FALSE == hr)
    {
        //
        // this root has been deleted by other means, scope pane has been refreshed,
        // ask user to retry
        //
        DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        return hr;
    }

    CWaitCursor wait;

    CComBSTR bstrJPName;
    hr = AddToDfsDlg.get_JPName(&bstrJPName);
    RETURN_IF_FAILED(hr);

    CComBSTR    bstrServerName;
    hr = AddToDfsDlg.get_Server(&bstrServerName);
    RETURN_IF_FAILED(hr);

    CComBSTR    bstrShareName;
    hr = AddToDfsDlg.get_Share(&bstrShareName);
    RETURN_IF_FAILED(hr);

    CComBSTR    bstrComment;
    hr = AddToDfsDlg.get_Comment(&bstrComment);
    RETURN_IF_FAILED(hr);

    long        lTimeout = 0;
    hr = AddToDfsDlg.get_Time(&lTimeout);
    RETURN_IF_FAILED(hr);

    /* we allow interlink at the junction level
                      // Is it a Dfs based path? These are not allowed.
        if (IsDfsPath(bstrSharePath))
        {
            DisplayMessageBoxWithOK(IDS_MSG_MID_JUNCTION, bstrSharePath);    
            return(S_OK);
        }
    */

    hr = OnCreateNewJunctionPoint(bstrJPName, bstrServerName, bstrShareName, bstrComment, lTimeout);
    if (FAILED(hr))
    {
        DisplayMessageBox(::GetActiveWindow(), MB_OK, hr, IDS_MSG_FAILED_TO_CREATE_JUNCTION_POINT);
    }

    return hr;
}




STDMETHODIMP 
CMmcDfsRoot :: OnCreateNewJunctionPoint(
  IN LPCTSTR          i_szJPName,
  IN LPCTSTR          i_szServerName,
  IN LPCTSTR          i_szShareName,
  IN LPCTSTR          i_szComment,
  IN long             i_lTimeout
  ) 
/*++

Routine Description:

  This method handles the creation of new Junction Points.
  It is called by the method that display the message box

--*/
{
    RETURN_INVALIDARG_IF_NULL(i_szJPName);
    RETURN_INVALIDARG_IF_NULL(i_szServerName);
    RETURN_INVALIDARG_IF_NULL(i_szShareName);
    RETURN_INVALIDARG_IF_NULL(i_szComment);

    VARIANT varJPObject;
    VariantInit(&varJPObject);

    HRESULT hr = m_DfsRoot->CreateJunctionPoint(
                                            (LPTSTR)i_szJPName, 
                                            (LPTSTR)i_szServerName, 
                                            (LPTSTR)i_szShareName, 
                                            (LPTSTR)i_szComment,
                                            i_lTimeout,
                                            &varJPObject);
    RETURN_IF_FAILED(hr);

    // Add the newly created junction point to scope pane if matches the filter
    if ( m_MmcJPList.size() < m_ulLinkFilterMaxLimit &&
         FilterMatch(i_szJPName, m_lLinkFilterType, m_bstrLinkFilterName) )
    {
        m_ulCountOfDfsJunctionPointsFiltered++;

        CComPtr<IDfsJunctionPoint> pDfsJPObject = (IDfsJunctionPoint*)varJPObject.pdispVal;

                          // Create the object to be used for MMC display
        CMmcDfsJunctionPoint* pMMCJPObject = new CMmcDfsJunctionPoint(pDfsJPObject, this, m_lpConsoleNameSpace);
  
        if (!pMMCJPObject)
        {
            hr = E_OUTOFMEMORY;
        } else
        {
            hr = pMMCJPObject->m_hrValueFromCtor;

            if (SUCCEEDED(hr))
                hr = pMMCJPObject->AddItemToScopePane(m_hScopeItem);

            if (SUCCEEDED(hr))
            {
                JP_LIST_NODE* pJPList = new JP_LIST_NODE(pMMCJPObject);
                if (!pJPList)
                    hr = E_OUTOFMEMORY;
                else
                    m_MmcJPList.push_back(pJPList);
            }

                        // Select the newly added scope item.
            if (SUCCEEDED(hr))
            {
                m_lpConsole->SelectScopeItem(pMMCJPObject->m_hScopeItem);
            } else
                delete pMMCJPObject;
        }
    } else
    {
        // select the root scope item to update status text on filtered links
        m_lpConsole->SelectScopeItem(m_hScopeItem);
    }

    VariantClear(&varJPObject);

    // Send View change notification for all views to update filtered link status text.
    if (SUCCEEDED(hr))
        m_lpConsole->UpdateAllViews((IDataObject*)this, 0, 1);

    return hr;
}



STDMETHODIMP 
CMmcDfsRoot::DoDelete() 
/*++

Routine Description:

  This method allows the item to delete itself.
  Called when DEL key is pressed or when the "Delete" context menu
  item is selected.

--*/
{ 
  return OnDeleteConnectionToDfsRoot();
}




STDMETHODIMP CMmcDfsRoot::OnDeleteDfsRoot()
{
    // Select this node to make sure m_MmcRepList populated
    if (m_MmcRepList.empty())
        m_lpConsole->SelectScopeItem(m_hScopeItem);

    // check outstanding property sheet, discontinue if any.
    HRESULT hr = CloseAllPropertySheets(FALSE);
    if (S_OK != hr)
        return hr;

    // Confirm with the user, if he wants to delete this dfs root
    hr = ConfirmOperationOnDfsRoot(IDS_MSG_DELETE_DFSROOT);
    if (S_OK != hr) return hr;

    if (DFS_TYPE_STANDALONE == m_lDfsRootType)
    {
        CComBSTR bstrDfsServer;
        CComBSTR bstrRootShare;
        hr = m_DfsRoot->GetOneDfsHost(&bstrDfsServer, &bstrRootShare);

        if (SUCCEEDED(hr))
            hr = _DeleteDfsRoot(bstrDfsServer, bstrRootShare, NULL);

        if (SUCCEEDED(hr))
        {
            CleanScopeChildren();

            // Delete the item from Scope Pane
            m_lpConsoleNameSpace->DeleteItem(m_hScopeItem, TRUE);

            // Delete it from the internal list
            m_pParent->DeleteMmcRootNode(this);

            Release();  // delete this CMmcDfsRoot object

            return S_OK;
        }

        return hr;
    }

    //
    // delete the replica set associated with the root (the internal link)
    //
    hr = OnStopReplication();
    if (S_FALSE == hr)
    {
        // this root has already been deleted by others, no more reference
        // OnStopReplication has already called OnRefresh and popped up the msgbox
        return hr;
    }

    //  
    // delete the rest of replica sets related to this Dfs root
    //
    (void)m_DfsRoot->DeleteAllReplicaSets();

    //
    // remove root alternates
    //
    UINT nSize = m_MmcRepList.size();
    DFS_REPLICA_LIST::iterator i;
    while (nSize >= 1)
    {
        i = m_MmcRepList.begin();

        hr = (*i)->pReplica->RemoveReplica();
        BREAK_IF_FAILED(hr);

        nSize--;
    }

    if (FAILED(hr))
        DisplayMessageBoxForHR(hr);

    return hr;
}

STDMETHODIMP CMmcDfsRoot::OnDeleteDisplayedDfsLinks()
{
    // make sure all property pages are closed
    HRESULT hr = ClosePropertySheetsOfAllLinks(FALSE);
    if (S_OK != hr)
        return hr; // property page found, discontinue

    // Confirm with the user, if he wants to delete all the displayed dfs links
    hr = ConfirmDeleteDisplayedDfsLinks();
    if (S_OK != hr) return hr;

    CWaitCursor wait;

    ULONG ulSize = m_MmcJPList.size();

    BOOL bSetNoFilter = TRUE;
    if (m_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
    {
        ULONG     ulNumOfJPsFiltered = 0;
        m_DfsRoot->get_CountOfDfsJunctionPointsFiltered((long*)&ulNumOfJPsFiltered);

        if (ulNumOfJPsFiltered > ulSize)
            bSetNoFilter = FALSE;
    }

    DFS_JUNCTION_LIST::iterator i;
    while (ulSize >= 1)
    {
        i = m_MmcJPList.begin();

        hr = ((*i)->pJPoint)->OnRemoveJP(FALSE);
        BREAK_IF_FAILED(hr);

        ulSize--;
    }

    if (FAILED(hr))
    {
        DisplayMessageBoxForHR(hr);
    } else
    {
        if (bSetNoFilter)
            m_lLinkFilterType = FILTERDFSLINKS_TYPE_NO_FILTER;

        // update the scope pane with new filtered links
        hr = OnRefresh();
        if (S_FALSE == hr)
        {
            // this root has already been deleted by others, no more reference
            DisplayMessageBox(::GetActiveWindow(), MB_OK, 0, IDS_INVALID_ROOT);
        }
    }

    return hr;
}

STDMETHODIMP 
CMmcDfsRoot :: OnFilterDfsLinks(
  ) 
/*++

Routine Description:

  This method handles the link filter options.
  Display a dialog box to get the user input.

--*/
{
    HRESULT         hr = ClosePropertySheetsOfAllLinks(FALSE);
    if (S_OK != hr)
        return hr; // property sheet found, discontinue

    CFilterDfsLinks FilterDfsLinksDlg;
    hr = FilterDfsLinksDlg.put_EnumFilterType(m_lLinkFilterType);
    RETURN_IF_FAILED(hr);

    if (m_lLinkFilterType != FILTERDFSLINKS_TYPE_NO_FILTER)
    {
        hr = FilterDfsLinksDlg.put_EnumFilter(m_bstrLinkFilterName);
        RETURN_IF_FA