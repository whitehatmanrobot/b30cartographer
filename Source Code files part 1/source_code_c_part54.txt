al = MAX_BLOCK_INTERVAL;
                m_state         = SKIPPED_TWO_BLOCKS;
                break;
                }

            case SKIPPED_TWO_BLOCKS:
                {
                m_BlockSize     = min( BUSY_BLOCK_SIZE, MaxBlockSize);
                m_BlockInterval = MAX_BLOCK_INTERVAL;
                m_state         = DOWNLOADED_BLOCK;
                break;
                }

            default:
                ASSERT( 0 );
            }
        }

    SetTimerInterval( m_BlockInterval );

    LogDl( "block %d bytes, interval %f seconds", m_BlockSize, m_BlockInterval );

    ASSERT( m_BlockSize <= MaxBlockSize );
}

BOOL
CNetworkInterface::SetTimerInterval(
    SECONDS interval
    )
{
    DWORD msec = interval*1000;

    if (msec <= 0)
        {
        msec = MIN_BLOCK_INTERVAL;
        }

    LogDl( "%d milliseconds", msec );

    if (FALSE == m_Timer.Start( msec ))
        {
        return FALSE;
        }

    return TRUE;
}

HRESULT
CNetworkInterface::FindInterfaceIndex(
    const TCHAR host[],
    DWORD * pIndex
    )
{
    //related to finding statistics
    /* Use GetBestInterface with some IP address to get the index. Double check that this index
     * occurs in the output of the IP Address table and look it up in the results of GetIfTable.
     */

    #define AOL_ADAPTER         _T("AOL Adapter")
    #define AOL_DIALUP_ADAPTER  _T("AOL Dial-Up Adapter")

    BOOL bFound = FALSE;
    BOOL bAOL = FALSE;

    unsigned i;
    DWORD   dwAddr;

    ULONG  HostAddress;
    struct sockaddr_in dest;

    DWORD dwIndex = -1;
    static TCHAR szIntfName[512];

    *pIndex = -1;

    try
        {
        //
        // Translate the host name into a SOCKADDR.
        //

        unsigned length = 3 * lstrlen(host);

        CAutoStringA AsciiHost ( new char[ length ]);

        if (! WideCharToMultiByte( CP_ACP,
                                   0,       // no flags
                                   host,
                                   -1,      // use strlen
                                   AsciiHost.get(),
                                   length,  // use strlen
                                   NULL,    // no default char
                                   NULL     // no default char
                                   ))
            {
            DWORD dwError = GetLastError();
            LogError( "Unicode conversion failed %!winerr!", dwError );
            return HRESULT_FROM_WIN32( dwError );
            }

        HostAddress = inet_addr( AsciiHost.get() );
        if (HostAddress == -1)
            {
            struct hostent *pHostEntry = gethostbyname( AsciiHost.get() );

            if (pHostEntry == 0)
                {
                DWORD dwError = WSAGetLastError();
                LogError( "failed to find host '%s': %!winerr!", AsciiHost.get(), dwError );
                return HRESULT_FROM_WIN32( dwError );
                }

            if (pHostEntry->h_addr_list[0] == NULL)
                {
                DWORD dwError = WSANO_DATA;
                LogError( "host address list empty '%s': %!winerr!", AsciiHost.get(), dwError );
                return HRESULT_FROM_WIN32( dwError );
                }

            HostAddress = *PULONG(pHostEntry->h_addr_list[0]);
            }
        }
    catch ( ComError err )
        {
        LogError( "exception 0x%x finding server IP address", err.Error() );
        return err.Error();
        }

    //for remote addr
    dest.sin_addr.s_addr = HostAddress;
    dest.sin_family = AF_INET;
    dest.sin_port = 80;

    DWORD dwGetBestInterfaceError = GetBestInterface(dest.sin_addr.s_addr, &dwIndex);

    if (dwGetBestInterfaceError != NO_ERROR)
        {
        LogError( "GetBestInterface failed with error %!winerr!, might be Win95", dwGetBestInterfaceError);

        //manually parse the routing table

        ULONG size = 0;
        DWORD dwIpForwardError = GetIpForwardTable(NULL, &size, FALSE);
        if (dwIpForwardError != ERROR_INSUFFICIENT_BUFFER)
            {
            LogError( "sizing GetIpForwardTable failed %!winerr!", dwIpForwardError );
            return HRESULT_FROM_WIN32( dwIpForwardError );
            }


        auto_ptr<MIB_IPFORWARDTABLE> pIpFwdTable((PMIB_IPFORWARDTABLE)new char[size]);
        if ( !pIpFwdTable.get() )
            {
            LogError( "out of memory getting %d bytes", size);
            return E_OUTOFMEMORY;
            }

        dwIpForwardError = GetIpForwardTable(pIpFwdTable.get(), &size, TRUE);

        if (dwIpForwardError == NO_ERROR)    //sort by dest addr
            {
            //perform bitwise AND of dest address with netmask and see if it matches network dest
            //todo check for multiple matches and then take longest mask
            for (i=0; i < pIpFwdTable->dwNumEntries; i++)
                {
                if ((dest.sin_addr.s_addr & pIpFwdTable->table[i].dwForwardMask) == pIpFwdTable->table[i].dwForwardDest)
                    {
                    dwIndex = pIpFwdTable->table[i].dwForwardIfIndex;
                    break;
                    }
                }

            if (dwIndex == -1)
                {
                // no match
                return HRESULT_FROM_WIN32( ERROR_NETWORK_UNREACHABLE );
                }
            }
        else
            {
            LogError( "GetIpForwardTable failed with error %!winerr!, exiting", dwIpForwardError );
            return HRESULT_FROM_WIN32( dwIpForwardError );
            }
        }

    //
    // At this point dwIndex should be correct.
    //
    ASSERT( dwIndex != -1 );

#if DBG
    try
        {
        //
        // Discover the local IP address for the correct interface.
        //
        ULONG size = 0;
        DWORD dwGetIpAddr = GetIpAddrTable(NULL, &size, FALSE);
        if (dwGetIpAddr != ERROR_INSUFFICIENT_BUFFER)
            {
            LogError( "GetIpAddrTable #1 returned %!winerr!", dwGetIpAddr );
            return HRESULT_FROM_WIN32( dwGetIpAddr );
            }

        auto_ptr<MIB_IPADDRTABLE> pAddrTable( (PMIB_IPADDRTABLE) new char[size] );

        dwGetIpAddr = GetIpAddrTable(pAddrTable.get(), &size, TRUE);
        if (dwGetIpAddr != NO_ERROR)
            {
            LogError( "GetIpAddrTable #2 returned %!winerr!", dwGetIpAddr );
            return HRESULT_FROM_WIN32( dwGetIpAddr );
            }

        for (i=0; i < pAddrTable->dwNumEntries; i++)
            {
            if (dwIndex == pAddrTable->table[i].dwIndex)
                {
                in_addr address;

                address.s_addr = pAddrTable->table[i].dwAddr;

                LogDl( "Throttling on interface with IP address - %s", inet_ntoa( address ));
                break;
                }
            }

        if (i >= pAddrTable->dwNumEntries)
            {
            LogWarning( "can't find interface with index %d in the IP address table", dwIndex );
            }
        }
    catch ( ComError err )
        {
        LogWarning("unable to print the local IP address due to exception %x", err.Error() );
        }
#endif // DBG

    //
    // See if the adapter in question is the AOL adapter.  If so, use the AOL dial-up adapter instead.
    //

    static MIB_IFROW s_TempRow;
    s_TempRow.dwIndex = dwIndex;

    DWORD dwEntryError = GetIfEntry( &s_TempRow );
    if ( NO_ERROR != dwEntryError )
        {
        LogError( "GetIfEntry(%d) returned %!winerr!", dwIndex, dwEntryError );
        return HRESULT_FROM_WIN32( dwEntryError );
        }

    if (lstrcmp( LPCWSTR(s_TempRow.bDescr), AOL_ADAPTER) == 0)
        {
        LogWarning( "found AOL adapter, searching for dial-up adapter...");

        dwIndex = -1;

        ULONG size = 0;
        DWORD dwGetIfTableError = GetIfTable( NULL, &size, FALSE );

        if (dwGetIfTableError != ERROR_INSUFFICIENT_BUFFER)
            {
            LogError( "GetIfTable #2 returned %!winerr!", dwGetIfTableError );
            return HRESULT_FROM_WIN32( dwGetIfTableError );
            }

        auto_ptr<MIB_IFTABLE> pIfTable( (PMIB_IFTABLE) new char[size] );
        if ( !pIfTable.get() )
            {
            LogError( "out of memory getting %d bytes", size);
            return E_OUTOFMEMORY;
            }

        dwGetIfTableError = GetIfTable( pIfTable.get(), &size, FALSE );
        if ( NO_ERROR != dwGetIfTableError )
            {
            LogError( "GetIfTable #2 returned %!winerr!", dwGetIfTableError );
            return HRESULT_FROM_WIN32( dwGetIfTableError );
            }

        for (i=0; i < pIfTable->dwNumEntries; ++i)
            {
            if (lstrcmp( LPCWSTR(pIfTable->table[i].bDescr), AOL_DIALUP_ADAPTER) == 0)
                {
                dwIndex = pIfTable->table[i].dwIndex;
                break;
                }
            }
        }

    ASSERT( dwIndex != -1 );

    *pIndex = dwIndex;

    LogDl( "using interface index %d", dwIndex );
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\logontable.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    logontable.cpp

Abstract :

    Source file for the logon table.

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"

#include <winsta.h>
#include <wtsapi32.h>
#include <userenv.h>

#include "logontable.tmh"

HRESULT DetectTerminalServer( bool * pfTS );

HRESULT
GetUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    );

HRESULT
WaitForUserToken(
    DWORD session,
    HANDLE * pToken
    )
{
    const MaxWait = 30 * 1000;
    const WaitInterval = 500;

    long StartTime = GetTickCount();

    HRESULT Hr = E_FAIL;

    do
        {

        Hr = GetUserToken( session, pToken );

        if ( SUCCEEDED( Hr ) )
            return Hr;

        LogError("logon : unable to get token : %!winerr!", Hr );

        Sleep( WaitInterval );
        }
    while ( GetTickCount() - StartTime < MaxWait );

    return Hr;
}

CLoggedOnUsers::CLoggedOnUsers(
    TaskScheduler & sched
    ) : m_TaskScheduler( sched ),
    m_SensNotifier( NULL )
{
    FILETIME time;
    GetSystemTimeAsFileTime( &time );

    m_CurrentCookie = time.dwLowDateTime;

    if ( WINDOWS2000_PLATFORM == g_PlatformVersion )
        {
        try
            {
            bool fTS;

            THROW_HRESULT( DetectTerminalServer( &fTS ));

            if (fTS)
                {
                m_SensNotifier = new CTerminalServerLogonNotification;
                LogInfo( "TS-enabled SENS notification activated" );
                }
            else
                {
                m_SensNotifier = new CLogonNotification;
                LogInfo( "regular SENS notification activated" );
                }
            }
        catch( ComError Error )
            {
            if ( Error.Error() == TYPE_E_CANTLOADLIBRARY ||
                 Error.Error() == TYPE_E_LIBNOTREGISTERED )
                {
                LogInfo( "SENS doesn't exist on this platform, skipping" );
                return;
                }
            else
                {
                LogInfo("SENS object failed with %x", Error.Error() );
                throw;
                }
            }
        }
}

CLoggedOnUsers::~CLoggedOnUsers()
{
    if (m_SensNotifier)
        {
        m_SensNotifier->DeRegisterNotification();
        m_SensNotifier->Release();
        }
}


HRESULT
CLoggedOnUsers::LogonSession(
    DWORD session
    )
{
    CUser * user = NULL;

    try
        {
        HANDLE Token = NULL;
        auto_HANDLE<NULL> AutoToken;

        //
        // Get the user's token and SID, then create a user object.
        //
        THROW_HRESULT( WaitForUserToken( session, &Token ));

        ASSERT( Token ); // Token can't be NULL

        AutoToken = Token;

        user = new CUser( Token );

        //
        // Add the user to our by-session and by-SID indexes.
        //
        HoldWriterLock lock ( m_TaskScheduler );

        try
            {
            // Just in case...delete any previously recorded user.
            //
            LogoffSession( session );

            //
            // Subtlety: if the node for m_ActiveSessions[ session ] doesn't exist,
            // then the first reference to it will cause a node to be allocated.  This may
            // throw E_OUTOFMEMORY.
            //
            m_ActiveSessions[ session ] = user;

            m_ActiveUsers.insert( make_pair( user->QuerySid(), user ) );
            }
        catch( ComError Error )
            {
            m_ActiveSessions.erase( session );
            throw;
            }

        Dump();

        g_Manager->UserLoggedOn( user->QuerySid() );

        return S_OK;
        }
    catch( ComError err )
        {
        delete user;

        LogError("logon : returning error 0x%x", err.Error() );
        Dump();
        return err.Error();
        }
}

HRESULT
CLoggedOnUsers::LogoffSession(
    DWORD session
    )
{
    try
        {
        HoldWriterLock lock ( m_TaskScheduler );

        CUser * user = m_ActiveSessions[ session ];

        if (!user)
            return S_OK;

        bool b = m_ActiveUsers.RemovePair( user->QuerySid(), user );

        ASSERT( b );

        m_ActiveSessions.erase( session );

        Dump();

        if (false == g_Manager->IsUserLoggedOn( user->QuerySid() ))
            {
            g_Manager->UserLoggedOff( user->QuerySid() );
            }

        user->DecrementRefCount();

        return S_OK;
        }
    catch( ComError err )
        {
        LogWarning("logoff : exception 0x%x thrown", err.Error());
        Dump();
        return err.Error();
        }
}

CUser *
CLoggedOnUsers::CUserList::FindSid(
    SidHandle sid
    )
{
    iterator iter = find( sid );

    if (iter == end())
        {
        return NULL;
        }

    return iter->second;
}


bool
CLoggedOnUsers::CUserList::RemovePair(
    SidHandle sid,
    CUser * user
    )
{
    //
    // Find the user in the user list and delete it.
    //
    pair<iterator, iterator> b = equal_range( sid );

    for (iterator i = b.first; i != b.second; ++i)
        {
        if (i->second == user)
            {
            erase( i );
            return true;
            }
        }

    return false;
}

CUser *
CLoggedOnUsers::CUserList::RemoveByCookie(
    SidHandle sid,
    DWORD cookie
    )
{
    //
    // Find the user in the user list and delete it.
    //
    pair<iterator, iterator> b = equal_range( sid );

    for (iterator i = b.first; i != b.second; ++i)
        {
        CUser * user = i->second;

        if (user->GetCookie() == cookie)
            {
            erase( i );
            return user;
            }
        }

    return NULL;
}

HRESULT
CLoggedOnUsers::LogonService(
    HANDLE Token,
    DWORD * pCookie
    )
{
    CUser * user = NULL;

    try
        {
        user = new CUser( Token );

        *pCookie = InterlockedIncrement( &m_CurrentCookie );

        user->SetCookie( *pCookie );

        HoldWriterLock lock ( m_TaskScheduler );

        m_ActiveServiceAccounts.insert( make_pair( user->QuerySid(), user ));

        return S_OK;
        }
    catch( ComError err )
        {
        delete user;

        LogError("logon service : returning error 0x%x", err.Error() );
        return err.Error();
        }
}


HRESULT
CLoggedOnUsers::LogoffService(
    SidHandle Sid,
    DWORD  Cookie
    )
{
    try
        {
        HoldWriterLock lock ( m_TaskScheduler );

        CUser * user = m_ActiveServiceAccounts.RemoveByCookie( Sid, Cookie );

        if (!user)
            {
            LogWarning("logoff : invalid cookie %d", Cookie);
            return E_INVALIDARG;
            }

        user->DecrementRefCount();

        return S_OK;
        }
    catch( ComError err)
        {
        LogWarning("logoff : exception 0x%x thrown", err.Error());
        return err.Error();
        }
}

HRESULT
CLoggedOnUsers::AddServiceAccounts()
{
    HRESULT hr = S_OK;
    DWORD ignore;

    HoldWriterLock lock ( m_TaskScheduler );

    //
    // Add the LOCAL_SYSTEM account.
    //
    HANDLE Token;
    if (OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY | TOKEN_DUPLICATE, &Token ))
        {
        hr = LogonService( Token, &ignore );
        CloseHandle( Token );
        }
    else
        {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        }

    if (FAILED(hr))
        {
        LogWarning( "failed to register LocalSystem : %!winerr!", hr );
        return hr;
        }

    if (g_PlatformVersion >= WINDOWSXP_PLATFORM)
        {
        //
        // Add the LocalService account.
        //
        if (LogonUser( L"LocalService",
                        L"NT AUTHORITY",
                        L"",
                        LOGON32_LOGON_SERVICE,
                        LOGON32_PROVIDER_DEFAULT,
                        &Token))
            {
            hr = LogonService( Token, &ignore );
            CloseHandle( Token );
            }
        else
            {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            }

        if (FAILED(hr))
            {
            LogWarning( "failed to register LocalService : %!winerr!", hr );
            if ( HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE ) == hr )
               LogWarning( "LocalService doesn't exist, skip it.\n");
            else
               return hr;
            }

        //
        // Add the NetworkService account.
        //
        if (LogonUser( L"NetworkService",
                        L"NT AUTHORITY",
                        L"",
                        LOGON32_LOGON_SERVICE,
                        LOGON32_PROVIDER_DEFAULT,
                        &Token))
            {
            hr = LogonService( Token, &ignore );
            CloseHandle( Token );
            }
        else
            {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            }

        if (FAILED(hr))
            {
            LogWarning( "failed to register NetworkService : %!winerr!", hr );
            if ( HRESULT_FROM_WIN32( ERROR_LOGON_FAILURE ) == hr )
               LogWarning( "NetworkService doesn't exist, skip it.\n");
            else
               return hr;
            }
        }

    //
    // done
    //
    return S_OK;
}

HRESULT
CLoggedOnUsers::AddActiveUsers()
{
    HRESULT hr = S_OK;
    WTS_SESSION_INFO * SessionInfo = 0;

    HANDLE Token;

    HoldWriterLock lock ( m_TaskScheduler );

    //
    // Get the console token, if any, without using Terminal Services.
    //
    if ( SUCCEEDED( GetUserToken( 0, &Token) ) )
        {
        CloseHandle( Token );

        hr = LogonSession( 0 );
        if (FAILED(hr))
            {
            // ignore it and try to carry on...
            LogWarning( "service : unable to logon session zero : %!winerr!", hr );
            }
        }

    //
    // The call may return FALSE, because Terminal Services is not always loaded.
    //
    DWORD SessionCount = 0;

    BOOL b = WTSEnumerateSessions( WTS_CURRENT_SERVER_HANDLE,
                                   0,                   // reserved
                                   1,                   // version 1 is the only supported v.
                                   &SessionInfo,
                                   &SessionCount
                                   );

    if (b)
        {
        int i;
        for (i=0; i < SessionCount; ++i)
            {
            if (SessionInfo[i].SessionId == 0)
                {
                // console was handled by GetCurrentUserToken.
                continue;
                }

            if (SessionInfo[i].State == WTSActive ||
                SessionInfo[i].State == WTSDisconnected)
                {
                LogInfo("service : logon session %d, state %d",
                        SessionInfo[i].SessionId,
                        SessionInfo[i].State );

                hr = LogonSession( SessionInfo[i].SessionId );
                if (FAILED(hr))
                    {
                    // ignore it and try to carry on...
                    LogWarning( "service : unable to logon session %d : %!winerr!",
                                SessionInfo[i].SessionId,
                                hr );
                    }
                }
            }
        }

    if (SessionInfo)
        {
        WTSFreeMemory( SessionInfo );
        }

    //
    // Now that the current population is recorded, keep abreast of changes.
    //
    if (m_SensNotifier)
        {
        m_SensNotifier->SetEnableState( true );
        }

    return S_OK;
}

CUser *
CLoggedOnUsers::FindUser(
    SidHandle sid,
    DWORD     session
    )
{
    HoldReaderLock lock ( m_TaskScheduler );

    CUser * user = 0;

    //
    // Look for a session with the right user.
    //
    if (session == ANY_SESSION)
        {
        user = m_ActiveUsers.FindSid( sid );
        }
    else
        {
        try
            {
            user = m_ActiveSessions[ session ];

            if (user && user->QuerySid() != sid)
                {
                user = 0;
                }
            }
        catch( ComError Error )
            {
            user = 0;
            }
        }

    //
    // Look in the service account list, if the session is compatible.
    //
    if (!user && (session == 0 || session == ANY_SESSION))
        {
        user = m_ActiveServiceAccounts.FindSid( sid );
        }

    if (user)
        {
        user->IncrementRefCount();
        }

    return user;

}

void CLoggedOnUsers::Dump()
{
    HoldReaderLock lock ( m_TaskScheduler );

    LogInfo("sessions:");

    m_ActiveSessions.Dump();

    LogInfo("users:");

    m_ActiveUsers.Dump();

    LogInfo("service accounts:");

    m_ActiveServiceAccounts.Dump();
}

void CLoggedOnUsers::CSessionList::Dump()
{
    for (iterator iter = begin(); iter != end(); ++iter)
        {
        LogInfo("    session %d  user %p", iter->first, iter->second);
        }
}

void CLoggedOnUsers::CUserList::Dump()
{
    for (iterator iter = begin(); iter != end(); ++iter)
        {
        if (iter->second)
            {
            (iter->second)->Dump();
            }
        }
}

CLoggedOnUsers::CUserList::~CUserList()
{
    iterator iter;

    while ((iter=begin()) != end())
        {
        delete iter->second;

        erase( iter );
        }
}


void CUser::Dump()
{
    LogInfo( "    user at %p:", this);

    LogInfo( "          %d refs,  sid %!sid!", _ReferenceCount, _Sid.get());
}

long CUser::IncrementRefCount()
{
    long count = InterlockedIncrement( & _ReferenceCount );

    LogRef("refs %d", count);

    return count;
}

long CUser::DecrementRefCount()
{
    long count = InterlockedDecrement( & _ReferenceCount );

    LogRef("refs %d", count);

    if (0 == count)
        {
        delete this;
        }

    return count;
}

CUser::CUser(
       HANDLE Token
       )
/*++

Routine Description:

    Initializes a new CUser.

At entry:

    <Sid> points to the user's SID.
    <Token> points to the user's token.  It can be an impersonation or primary token.
    <phr> points to an error-return variable.

At exit:

    The CUser is set up.  The caller can delete <Sid> and <Token> if it wants to.

    if an error occurs, it is mapped to an HRESULT and written to <phr>.
    otherwise <*phr> is untouched and the CUser is ready for use.

--*/
{
    _ReferenceCount = 1;

    _Sid = CopyTokenSid( Token );

    //
    // Copy the token.  Whether the source is primary or impersonation,
    // the result will be a primary token.
    //
    if (!DuplicateHandle(
        GetCurrentProcess(),
        Token,
        GetCurrentProcess(),
        &_Token,
        TOKEN_ALL_ACCESS,
        FALSE,                // not inheritable
        0                     // no funny options
        ))
        {

        HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );

        LogError( "CUser: can't duplicate token %!winerr!", HrError );

        throw ComError( HrError );
        }
}

CUser::~CUser()
{
    CloseHandle( _Token );
}

HRESULT
CUser::LaunchProcess(
    StringHandle Program,
    StringHandle Parameters
    )
{
    DWORD s;

    PVOID EnvironmentBlock = 0;

    PROCESS_INFORMATION ProcessInformation;
    memset( &ProcessInformation, 0, sizeof( PROCESS_INFORMATION ));

    try
        {
        STARTUPINFO si;
        memset( &si, 0, sizeof( STARTUPINFO ));
        si.cb = sizeof(STARTUPINFO);

        //
        // Parameters must be a writable string for some reason.
        //
        CAutoString WritableParms( CopyString( LPCWSTR(Parameters) ));

        LogInfo( "creating process: cmd line: '%S' '%S'", Program, WritableParms.get() );

        if (!CreateEnvironmentBlock( &EnvironmentBlock,
                                     _Token,
                                     FALSE
                                     ))
            {
            ThrowLastError();
            }

        //
        // Need to impersonate the token so that the program file is accessed as the user.
        // Otherwise launching a UNC path would fail, and the job would also be able to
        // launch local programs otherwise inaccessible to the job owner.
        //
        CNestedImpersonation imp( _Token );

        if (!CreateProcessAsUser( _Token,
                                  Program,
                                  WritableParms.get(),
                                  0,     // no special security attributes
                                  0,     // no special thread attributes
                                  false, // don't inherit my handles
                                  NORMAL_PRIORITY_CLASS | CREATE_UNICODE_ENVIRONMENT,
                                  EnvironmentBlock,
                                  NULL,  // default current directory
                                  &si,
                                  &ProcessInformation
                                  ))
            {
            ThrowLastError();
            }

        DestroyEnvironmentBlock( EnvironmentBlock );
        EnvironmentBlock = 0;

        CloseHandle( ProcessInformation.hThread );
        ProcessInformation.hThread = 0;

        CloseHandle( ProcessInformation.hProcess );
        ProcessInformation.hProcess = 0;

        LogInfo("success, pid is 0x%x", ProcessInformation.dwProcessId);

        //
        // We succeeded.
        //
        return S_OK;
        }
    catch ( ComError err )
        {
        LogError("unable to create process, %x", err.Error() );

        if (EnvironmentBlock)
            {
            DestroyEnvironmentBlock( EnvironmentBlock );
            }

        return err.Error();
        }
}

#if ENABLE_STL_LOCK_OVERRIDE

    /*
        This file implements the STL lockit class to avoid linking to msvcprt.dll.
    */
    CCritSec CrtLock;

    #pragma warning(push)
    #pragma warning(disable:4273)  // __declspec(dllimport) attribute overridden

     std::_Lockit::_Lockit()
    {
        CrtLock.WriteLock();
    }

     std::_Lockit::~_Lockit()
    {
        CrtLock.WriteUnlock();
    }

    #pragma warning(pop)

#endif

extern "C"
{
HANDLE
GetCurrentUserTokenW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      );

void * __RPC_USER MIDL_user_allocate(size_t size)
{
    try
    {
        return new char[size];
    }
    catch( ComError Error )
    {
        return NULL;
    }
}

void __RPC_USER MIDL_user_free( void * block)
{
    delete block;
}


}


HRESULT
GetUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    )
{
    //
    // Win2000 compatibility is important only for x86 builds.
    //
#if defined(_X86_) && defined(MULTIPLATFORM_SUPPORT)
    if (g_PlatformVersion == WINDOWS2000_PLATFORM)
        {
        //
        // This gets the token of the user logged onto the WinStation
        // if we are an admin caller.
        //
        if (LogonId == 0)
            {
            // don't need the TS API.

            *pUserToken = GetCurrentUserTokenW( L"WinSta0", TOKEN_ALL_ACCESS );
            if (*pUserToken != NULL)
                {
                return S_OK;
                }

            // if not, try the TS API.
            }

        //
        // Use Terminal Services for non-console Logon IDs.
        //
        BOOL   Result;
        ULONG  ReturnLength;
        NTSTATUS Status;
        OBJECT_ATTRIBUTES ObjA;
        HANDLE ImpersonationToken;
        WINSTATIONUSERTOKEN Info;
        SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;

        static PWINSTATIONQUERYINFORMATIONW pWinstationQueryInformation = 0;

        //
        // See if the entry point is loaded yet.
        //
        if (!pWinstationQueryInformation)
            {
            HMODULE module = LoadLibrary(_T("winsta.dll"));
            if (module == NULL)
                {
                HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
                ASSERT( S_OK != HrError );
                LogInfo( "Load library of winsta failed, error %!winerr!", HrError );
                return HrError;
                }

            pWinstationQueryInformation = (PWINSTATIONQUERYINFORMATIONW) GetProcAddress( module, "WinStationQueryInformationW" );
            if (!pWinstationQueryInformation)
                {
                HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
                ASSERT( S_OK != HrError );
                LogInfo( "GetProcAddress of WinStationQueryInformationW, error %!winerr!", HrError );
                FreeLibrary(module);
                return HrError;
                }
            }

        //
        // Ask for the token.
        //
        Info.ProcessId = UlongToHandle(GetCurrentProcessId());
        Info.ThreadId = UlongToHandle(GetCurrentThreadId());

        Result = (*pWinstationQueryInformation)(
                     SERVERNAME_CURRENT,
                     LogonId,
                     WinStationUserToken,
                     &Info,
                     sizeof(Info),
                     &ReturnLength
                     );

        if( !Result )
            {
            HRESULT HrError = HRESULT_FROM_WIN32( GetLastError() );
            ASSERT( S_OK != HrError );
            LogError("token : WinstationQueryInfo failed with %!winerr!%", HrError );
            return HrError;
            }

        //
        // The token returned is a duplicate of a primary token.
        //
        *pUserToken = Info.UserToken;

        return S_OK;
        }
    else
#endif // _X86_ and MULTIPLATFORM_SUPPORT
        {
        typedef BOOL (WINAPI * PWTSQUERYUSERTOKEN)( ULONG SessionId, PHANDLE phToken );

        static PWTSQUERYUSERTOKEN pWtsQueryUserToken = 0;

        //
        // See if the entry point is loaded yet.
        //
        if (!pWtsQueryUserToken)
            {
            HMODULE module = LoadLibrary(_T("wtsapi32.dll"));
            if (module == NULL)
                {
                DWORD s = GetLastError();
                ASSERT( s != 0 );

                LogInfo( "Load library of winsta failed, error %!winerr!", s );
                return HRESULT_FROM_WIN32( s );
                }

            pWtsQueryUserToken = (PWTSQUERYUSERTOKEN) GetProcAddress( module, "WTSQueryUserToken" );
            if (!pWtsQueryUserToken)
                {
                DWORD s = GetLastError();
                ASSERT( s != 0 );

                LogInfo( "GetProcAddress of WTSQueryUserToken, error %!winerr!", s );
                FreeLibrary(module);
                return HRESULT_FROM_WIN32( s );
                }
            }

        //
        // Ask for the token.
        //
        if (!(*pWtsQueryUserToken)( LogonId, pUserToken ))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        return S_OK;
        }
}

BOOL
SidToString(
    PSID sid,
    wchar_t buffer[],
    USHORT bytes
    )
{
    UNICODE_STRING UnicodeString;

    UnicodeString.Buffer        = buffer;
    UnicodeString.Length        = 0;
    UnicodeString.MaximumLength = bytes;

    NTSTATUS NtStatus;
    NtStatus = RtlConvertSidToUnicodeString( &UnicodeString,
                                             sid,
                                             FALSE
                                             );
    if (!NT_SUCCESS(NtStatus))
        {
        LogWarning( "RtlConvertSid failed %x", NtStatus);
        StringCbCopy( buffer, bytes, L"(conversion failed)" );
        return FALSE;
        }

    buffer[ UnicodeString.Length ] = 0;

    return TRUE;
}

HRESULT
SetStaticCloaking(
    IUnknown *pUnk
    )
{
    // Sets static cloaking on the current object so that we
    // should always impersonate the current context.
    // Also sets the impersonation level to identify.

    HRESULT Hr = S_OK;

    IClientSecurity *pSecurity = NULL;
    OLECHAR *ServerPrincName = NULL;

    try
    {
        Hr = pUnk->QueryInterface( __uuidof( IClientSecurity ),
                                             (void**)&pSecurity );
        if (Hr == E_NOINTERFACE)
            {
            //
            // This is not a proxy; the client is in the same apartment as we are.
            // Identity issn't an issue, because the client already has access to system
            // credentials.
            //
            return S_OK;
            }

        DWORD AuthnSvc, AuthzSvc;
        DWORD AuthnLevel, ImpLevel, Capabilites;

        THROW_HRESULT(
            pSecurity->QueryBlanket(
                pUnk,
                &AuthnSvc,
                &AuthzSvc,
                &ServerPrincName,
                &AuthnLevel,
                NULL, // Don't need impersonation handle since were setting that
                NULL, // don't need indenty handle since were setting that
                &Capabilites ) );

        THROW_HRESULT(
            pSecurity->SetBlanket(
                pUnk,
                AuthnSvc,
                AuthzSvc,
                ServerPrincName,
                AuthnLevel,
                RPC_C_IMP_LEVEL_IDENTIFY,
                NULL, // COM use indentity from token
                EOAC_STATIC_CLOAKING // The point of the exercise
                ) );

    }
    catch( ComError Error )
    {
        Hr = Error.Error();
    }

    CoTaskMemFree( ServerPrincName );
    SafeRelease( pSecurity );

    return Hr;
}

HRESULT DetectTerminalServer( bool * pfTS )
/*

    This function checks whether Terminal Services is installed.  This is the "official" way to check
    for machines running Win2000 and above.

*/
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;

    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

    if (0 != VerifyVersionInfo(
        &osVersionInfo,
        VER_SUITENAME,
        dwlConditionMask
        ))
        {
        LogInfo("TS test: TS is installed");
        *pfTS = true;
        return S_OK;
        }

    DWORD s = GetLastError();
    if (s == ERROR_OLD_WIN_VERSION)
        {
        LogInfo("TS test: no TS");
        *pfTS = false;
        return S_OK;
        }

    LogError("TS test returned %d", s);
    return HRESULT_FROM_WIN32( s );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\request.cpp ===
#include "stdafx.h"
#include <malloc.h>

#if !defined(BITS_V12_ON_NT4)
#include "request.tmh"
#endif

CBitsCommandRequest::CBitsCommandRequest(
    URL_INFO * UrlInfo
    ) : m_UrlInfo( UrlInfo ),
    m_hRequest( 0 )
{
    THROW_HRESULT( OpenHttpRequest( L"BITS_POST", L"HTTP/1.1", *UrlInfo, &m_hRequest ));
}

CBitsCommandRequest::~CBitsCommandRequest()
{
    InternetCloseHandle(m_hRequest);
}

void
CBitsCommandRequest::AddContentName(
    StringHandle FullPath
    )
{
    wchar_t Template[] = L"Content-Name: %s\r\n";

    StringHandle DirectoryName;
    StringHandle FileName;

    DirectoryName = BITSCrackFileName( FullPath, FileName );

    size_t Length = RTL_NUMBER_OF(Template) + wcslen(FileName);

    CAutoString Header ( new wchar_t[ Length ] );

    THROW_HRESULT( StringCchPrintf( Header.get(), Length, Template, LPCWSTR(FileName) ));

    // add the header

    if (!HttpAddRequestHeaders(m_hRequest,
                               Header.get(),
                               -1L,
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        ThrowLastError();
        }
}

void
CBitsCommandRequest::AddPacketType(
    wchar_t * type
    )
{
    LogDl("upload: adding packet type '%S'", type );

    //
    // Assemble the header.
    //
    wchar_t Template[] = _T("BITS-Packet-Type: %s\r\n");
    size_t Length = RTL_NUMBER_OF(Template) + wcslen(type);

    CAutoString Header ( new wchar_t[ Length ] );

    THROW_HRESULT( StringCchPrintf( Header.get(), Length, Template, type ));

    // add the header

    if (!HttpAddRequestHeaders(m_hRequest,
                               Header.get(),
                               -1L,
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        ThrowLastError();
        }
}

void
CBitsCommandRequest::AddContentRange(
    UINT64 RangeStart,
    UINT64 RangeEnd,
    UINT64 Size
    )
{
    wchar_t Template[] = _T("Content-Range: bytes %I64u-%I64u/%I64u\r\n");
    size_t Length = RTL_NUMBER_OF(Template) + INT64_DIGITS + INT64_DIGITS + INT64_DIGITS;

    CAutoString header ( new wchar_t[ Length ] );

    THROW_HRESULT( StringCchPrintf( header.get(), Length, Template, RangeStart, RangeEnd, Size ));

    if (!HttpAddRequestHeaders(m_hRequest,
                               header.get(),
                               -1L,
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        ThrowLastError();
        }
}

void
CBitsCommandRequest::AddSessionId(
    StringHandle & id
    )
{
    //
    // Assemble the header.
    //
    wchar_t Template[] = _T("BITS-Session-Id: %s\r\n");
    size_t Length = RTL_NUMBER_OF(Template) + wcslen(id);

    CAutoString header ( new wchar_t[ Length ] );

    THROW_HRESULT( StringCchPrintf( header.get(), Length, Template, LPCWSTR(id) ));

    if (!HttpAddRequestHeaders(m_hRequest,
                               header.get(),
                               -1L,
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        ThrowLastError();
        }
}

void
CBitsCommandRequest::AddSupportedProtocols()
{
    wchar_t header[] = L"BITS-Supported-Protocols: {7df0354d-249b-430f-820d-3d2a9bef4931}\r\n";

    // add the header

    if (!HttpAddRequestHeaders(m_hRequest,
                               header,
                               -1L,
                               HTTP_ADDREQ_FLAG_ADD | HTTP_ADDREQ_FLAG_REPLACE ))
        {
        ThrowLastError();
        }
}

// Upload Protocol ID:  {7df0354d-249b-430f-820d-3d2a9bef4931}
// DEFINE_GUID(UploadProtocolId,0x7df0354d,0x249b,0x430f,0x82,0x0d,0x3d,0x2a,0x9b,0xef,0x49,0x31);

static const GUID UploadProtocolId =
{ 0x7df0354d, 0x249b, 0x430f, {0x82, 0x0d, 0x3d, 0x2a, 0x9b, 0xef, 0x49, 0x31} };

HRESULT
CBitsCommandRequest::CheckResponseProtocol( GUID *pGuid )
{
    HRESULT hr = S_OK;

    if (!IsEqualGUID(*pGuid,UploadProtocolId))
        {
        hr = BG_E_CLIENT_SERVER_PROTOCOL_MISMATCH;
        }

    return hr;
}

DWORD
CBitsCommandRequest::Send(
    CAbstractDataReader * Reader
    )
{
    bool bNeedLock;
    try
        {
        ReleaseWriteLock( bNeedLock );

        //
        // Send the request, and read the reply code.
        //
        THROW_HRESULT( SendRequest( m_hRequest, m_UrlInfo, Reader ));

        DWORD dwStatus;

        {
        DWORD dwLength;

        dwLength = sizeof(dwStatus);
        if (! HttpQueryInfo(m_hRequest,
                    HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
                    (LPVOID)&dwStatus,
                    &dwLength,
                    NULL))
            {
            ThrowLastError();
            }
        }

        if (dwStatus == 200 ||
            dwStatus == 201)
            {
            THROW_HRESULT( CheckReplyPacketType() );
            }

        DrainReply();

        ReclaimWriteLock( bNeedLock );

        return dwStatus;
        }
    catch ( ComError err )
        {
        ReclaimWriteLock( bNeedLock );
        throw;
        }
}

void
CBitsCommandRequest::DrainReply()
/*
    Server replies often contain an entity body even though BITS did not ask for one.
    For example, a 404 error may be accompanied by HTML explaining how to contact the
    system administrator.  BITS needs to read all of the reply entity body before sending
    the next request on the HTTP connection, or it will read data instead of headers after
    the next request.
*/
{
    //
    // Look for a length header.
    //
    HRESULT hr;
    UINT64 Length;

    hr = GetContentLength( &Length );

    if (hr == BG_E_HEADER_NOT_FOUND)
        {
        //
        // If a content length is not specified, then the response may be in chunked encoding,
        // terminated by a connection close, or invalid.  In those cases, the client won't be reading
        // more from this connection anyway, so reading all the data is not necessary.
        //
        return;
        }

    THROW_HRESULT( hr );

    //
    // drain the pipe.
    //
    DWORD BytesRead;

    while ( Length > 0 )
        {
        if (!InternetReadFile( m_hRequest,
                               g_FileDataBuffer,
                               FILE_DATA_BUFFER_LEN,
                               &BytesRead
                               ))
            {
            LogWarning("read failed %d", GetLastError() );
            break;
            }

        Length -= BytesRead;

        if (BytesRead == 0)
            {
            // graceful closure
            return;
            }
        }

    return;
}

HRESULT
CBitsCommandRequest::GetServerRange(
    UINT64 * RangeEnd
    )
{
    const wchar_t Name[] = L"BITS-Received-Content-Range";
    wchar_t Header[ INT64_DIGITS+1 ];

    RETURN_HRESULT( GetMandatoryHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__));

    // parse the data

    if (1 != _stscanf( Header, _T("%I64u"), RangeEnd ))
        {
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    LogInfo("content range: %I64u", *RangeEnd );

    return S_OK;
}

HRESULT
CBitsCommandRequest::GetContentLength(
    UINT64 * Length
    )
{

    *Length = 0;

    wchar_t  Header[INT64_DIGITS+1];

    RETURN_HRESULT( GetOptionalHeaderCb( WINHTTP_QUERY_CONTENT_LENGTH, WINHTTP_HEADER_NAME_BY_INDEX, Header, sizeof(Header), __LINE__));

    if ( 1 != swscanf( Header, L"%I64u", Length ) )
        {
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    LogInfo("Content-Length was %I64u", *Length );
    return S_OK;

}

HRESULT
CBitsCommandRequest::GetProtocol(
    GUID * id
    )
{
    const wchar_t Name[] = L"BITS-Protocol";
    wchar_t Header[ MAX_GUID_CHARS ];

    RETURN_HRESULT( GetMandatoryHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__));

    HRESULT hr = IIDFromString( Header, id );

    if (hr == E_INVALIDARG)
        {
        hr = BG_E_INVALID_SERVER_RESPONSE;
        }

    return hr;
}

HRESULT
CBitsCommandRequest::GetSessionId(
    StringHandle * id
    )
{
    const wchar_t Name[] = L"BITS-Session-Id";
    wchar_t Header[ MAX_SESSION_ID ];

    RETURN_HRESULT( GetMandatoryHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__));

    try
        {
        // this may throw an out-of-memory exception
        //
        *id = Header;
        }
    catch ( ComError err )
        {
        return err.Error();
        }

    return S_OK;
}

HRESULT
CBitsCommandRequest::CheckReplyPacketType()
{
    const wchar_t Name[] = L"BITS-Packet-Type";
    wchar_t Header[ MAX_PACKET_TYPE ];

    RETURN_HRESULT( GetMandatoryHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__));

    if (0 != _wcsicmp( Header, L"Ack"))
        {
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    return S_OK;
}

HRESULT
CBitsCommandRequest::GetBitsError(
    HRESULT * phr
    )
{
    const wchar_t Name[] = L"BITS-Error";
    wchar_t Header[ INT_DIGITS+3+1 ];   // allow space for "0x" prefix and negative sign - in case we later allow those

    RETURN_HRESULT( GetOptionalHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__));

    LogWarning("BITS-Error was '%S'", Header );

    // parse the data

    if (1 != _stscanf( Header, _T("0x%x"), phr ))
        {
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    return S_OK;
}

HRESULT
CBitsCommandRequest::GetBitsErrorContext(
    DWORD * pdw
    )
{
    const wchar_t Name[] = L"BITS-Error-Context";
    wchar_t Header[ INT_DIGITS+1 ];

    RETURN_HRESULT( GetOptionalHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__));

    LogWarning("BITS-Error-Context was '%S'", Header );

    // parse the data

    if (1 != _stscanf( Header, _T("0x%x"), pdw ) ||
        (*pdw != BG_ERROR_CONTEXT_REMOTE_FILE && *pdw != BG_ERROR_CONTEXT_REMOTE_APPLICATION))
        {
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    return S_OK;
}

HRESULT
CBitsCommandRequest::GetReplyUrl(
    CAutoString & ReplyUrl
    )
{
    const wchar_t Name[] = L"BITS-Reply-Url";

    HRESULT hr = GetRequestHeader( m_hRequest, HTTP_QUERY_CUSTOM, Name, ReplyUrl, INTERNET_MAX_URL_LENGTH );
    if (hr == S_FALSE)
        {
        return BG_E_HEADER_NOT_FOUND;
        }

    return hr;
}

HRESULT
CBitsCommandRequest::GetHostId(
    StringHandle * pstr
    )
{
    *pstr = StringHandle();

    CAutoString Value;
    const wchar_t Name[] = L"BITS-Host-Id";

    HRESULT hr = GetRequestHeader( m_hRequest, HTTP_QUERY_CUSTOM, Name, Value, MAX_HOST_ID );
    if (hr == S_FALSE)
        {
        return S_OK;
        }

    if (hr != S_OK)
        {
        return hr;
        }

    //
    // The StringHandle will copy Value.get() instead of taking ownership of it,
    // so this fn still needs to delete the original.
    //
    *pstr = Value.get();
    return S_OK;
}

HRESULT
CBitsCommandRequest::GetHostIdFallbackTimeout(
    DWORD * pVal
    )
{

    *pVal = 0xFFFFFFFF;

    const wchar_t * Name = L"BITS-Host-Id-Fallback-Timeout";
    wchar_t Header[ INT_DIGITS+1 ];

    HRESULT hr = GetOptionalHeaderCb( WINHTTP_QUERY_CUSTOM, Name, Header, sizeof(Header), __LINE__);
    if (hr == BG_E_HEADER_NOT_FOUND)
        {
        return S_OK;
        }

    if (FAILED(hr))
        {
        return hr;
        }

    if ( !swscanf( Header, L"%u", pVal ) )
        return BG_E_INVALID_SERVER_RESPONSE;

    return S_OK;

}

HRESULT
CBitsCommandRequest::GetOptionalHeaderCb(
    DWORD dwInfoLevel,
    LPCWSTR Name,
    LPWSTR Value,
    DWORD ValueBytes,
    DWORD Line
    )
{
    if (WinHttpQueryHeaders( m_hRequest,
                              dwInfoLevel,
                              Name,
                              Value,
                              &ValueBytes,
                              WINHTTP_NO_HEADER_INDEX
                               ))
        {
        return S_OK;
        }

    DWORD s = GetLastError();
    if (s == ERROR_INSUFFICIENT_BUFFER)
        {
        LogError("line %d: header is too large", Line);
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    // note that BG_E_HEADER_NOT_FOUND is the same as HRESULT_FROM_WIN32(ERROR_WINHTTP_HEADER_NOT_FOUND)

    return HRESULT_FROM_WIN32( s );
}

HRESULT
CBitsCommandRequest::GetMandatoryHeaderCb(
    DWORD dwInfoLevel,
    LPCWSTR Name,
    LPWSTR Value,
    DWORD ValueBytes,
    DWORD Line
    )
{
    HRESULT hr;

    hr = GetOptionalHeaderCb( dwInfoLevel, Name, Value, ValueBytes, Line );

    if (hr == BG_E_HEADER_NOT_FOUND)
        {
        LogError("line %d: header not present", Line);
        return BG_E_INVALID_SERVER_RESPONSE;
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\proxy.h ===
inline DWORD
ProxyUsageFromJobProxyUsage(
    BG_JOB_PROXY_USAGE JobUsage
    )
{
    switch( JobUsage )
        {
        case BG_JOB_PROXY_USAGE_PRECONFIG: return WINHTTP_ACCESS_TYPE_DEFAULT_PROXY;
        case BG_JOB_PROXY_USAGE_NO_PROXY:  return WINHTTP_ACCESS_TYPE_NO_PROXY;
        case BG_JOB_PROXY_USAGE_OVERRIDE:  return WINHTTP_ACCESS_TYPE_NAMED_PROXY;
        default:                           ASSERT( 0 ); return WINHTTP_ACCESS_TYPE_NO_PROXY;
        }
}


struct PROXY_SETTINGS
{
   BG_JOB_PROXY_USAGE   ProxyUsage;
   LPTSTR               ProxyList;
   LPTSTR               ProxyBypassList;

   PROXY_SETTINGS()
   {
       ProxyUsage = BG_JOB_PROXY_USAGE_PRECONFIG;

       ProxyList       =  NULL;
       ProxyBypassList =  NULL;
   }

   ~PROXY_SETTINGS()
   {
       delete ProxyList;
       delete ProxyBypassList;
   }
};

class PROXY_SETTINGS_CONTAINER
{
    DWORD           m_ProxyUsage;
    StringHandle    m_BypassList;
    StringHandle    m_MasterProxyList;
    DWORD           m_AccessType;

    StringHandle    m_ProxyList;
    LPWSTR          m_CurrentProxy;
    LPWSTR          m_TokenCursor;

public:

    PROXY_SETTINGS_CONTAINER(
        LPCWSTR Url,
        const PROXY_SETTINGS * ProxySettings
        );

    bool UseNextProxy()
    {
        m_CurrentProxy = m_ProxyList.GetToken( m_TokenCursor, _T("; "), &m_TokenCursor );
        if (m_CurrentProxy == NULL)
            {
            return false;
            }

        return true;
    }

    void ResetCurrentProxy()
    {
        m_ProxyList = m_MasterProxyList.Copy();

        m_CurrentProxy = m_ProxyList.GetToken( NULL, _T(";"), &m_TokenCursor );
    }

    DWORD GetProxyUsage()
    {
        return m_ProxyUsage;
    }

    LPCWSTR GetCurrentProxy()
    {
        return m_CurrentProxy;
    }

    LPCWSTR GetProxyList()
    {
        return m_MasterProxyList;
    }

    LPCWSTR GetBypassList()
    {
        if (static_cast<LPCWSTR>(m_BypassList)[0] == 0)
            {
            return NULL;
            }

        return m_BypassList;
    }
};

class CACHED_AUTOPROXY
{
public:

    // a cache entry lasts for 5 minutes.
    //
    const static CACHED_PROXY_LIFETIME_IN_MSEC = (5 * 60 * 1000);

    //----------------------------------------------------------

    inline CACHED_AUTOPROXY()
    {
        m_fValid = false;
        m_TimeStamp = 0;
        m_hInternet = 0;

        ZeroMemory(&m_ProxyInfo, sizeof(m_ProxyInfo));

        m_hInternet = WinHttpOpen( C_BITS_USER_AGENT,
                                    WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                                    NULL,  // proxy list
                                    NULL,  // proxy bypass list
                                    0 );
        if (!m_hInternet)
            {
            ThrowLastError();
            }
    }

    inline ~CACHED_AUTOPROXY()
    {
        Clear();

        if (m_hInternet)
            {
            InternetCloseHandle( m_hInternet );
            }
    }

    void Clear();

    HRESULT
    Generate(
        const TCHAR Host[]
        );

    HRESULT
    SetRequestProxy(
        HINTERNET hRequest,
        const PROXY_SETTINGS * ProxySettings
        );

    void Invalidate()
    /*
        When the set of network interfaces changes, cached results may no longer be valid.
        A separate thread will call this function to mark the results invalid.
        This function is safe to call while the downloader thread is calling Generate().
        If that becomes untrue, then explicit synchronization will be needed.
    */
    {
        //
        // Invalidate m_HostName.  We don't touch it, because Generate() may be using it.
        //
        m_TimeStamp = GetTickCount() - CACHED_PROXY_LIFETIME_IN_MSEC - 1;
    }

    LPCWSTR GetProxyList()
    {
        return m_ProxyInfo.lpszProxy;
    }

    LPCWSTR GetBypassList()
    {
        return m_ProxyInfo.lpszProxyBypass;
    }

    DWORD GetAccessType()
    {
        return m_ProxyInfo.dwAccessType;
    }

protected:

    //
    // m_ProxyInfo contains valid data.
    //
    bool m_fValid;

    //
    // The host used to calculate the proxy value.
    //
    StringHandleT   m_HostName;

    //
    // The results of the proxy calculation.
    //
    WINHTTP_PROXY_INFO m_ProxyInfo;

    //
    // Time of last update.
    //
    long m_TimeStamp;

    HINTERNET m_hInternet;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\proxy.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "proxy.tmh"
#endif


HRESULT
CACHED_AUTOPROXY::Generate(
    const TCHAR Host[]
    )
{
    if (GetTickCount() - m_TimeStamp > CACHED_PROXY_LIFETIME_IN_MSEC)
        {
        m_HostName = L"";
        }

    if (0 == _tcscmp( Host, m_HostName ))
        {
        LogInfo("using existing proxy info for '%S'", Host );
        return S_OK;
        }

    LogInfo( "detecting proxy for '%S'", Host );

    //
    // Detect IE settings and look up proxy if necessary.
    // Boilerplate from Stephen Sulzer.
    //
    WINHTTP_PROXY_INFO          ProxyInfo;
    WINHTTP_AUTOPROXY_OPTIONS   AutoProxyOptions;
    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG    IEProxyConfig;
    LPWSTR AutoConfigUrl = 0;
    BOOL fTryAutoProxy = FALSE;
    BOOL fSuccess = FALSE;

    //
    // This implicitly sets ProxyInfo.dwAccessType to zero, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY.
    // If there is no proxy, the WinHttp functions don't update it, and it will therefore stay that way.
    // But lpszProxy will be NULL so SetRequestProxy will work anyway.
    //
    ZeroMemory(&ProxyInfo, sizeof(ProxyInfo));
    ZeroMemory(&AutoProxyOptions, sizeof(AutoProxyOptions));
    ZeroMemory(&IEProxyConfig, sizeof(IEProxyConfig));

    if (WinHttpGetIEProxyConfigForCurrentUser(&IEProxyConfig))
        {
        LogInfo("got user's IE info");

        if (IEProxyConfig.fAutoDetect)
            {
            LogInfo("IE specifies auto-detect");

            AutoProxyOptions.dwFlags = WINHTTP_AUTOPROXY_AUTO_DETECT;
            AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                                 WINHTTP_AUTO_DETECT_TYPE_DNS_A;
            fTryAutoProxy = TRUE;
            }

        if (IEProxyConfig.lpszAutoConfigUrl)
            {
            LogInfo("IE specifies auto-config URL '%S'", IEProxyConfig.lpszAutoConfigUrl ? IEProxyConfig.lpszAutoConfigUrl : NullString );

            AutoProxyOptions.dwFlags |= WINHTTP_AUTOPROXY_CONFIG_URL;
            AutoProxyOptions.lpszAutoConfigUrl = IEProxyConfig.lpszAutoConfigUrl;
            AutoConfigUrl                      = IEProxyConfig.lpszAutoConfigUrl;
            fTryAutoProxy = TRUE;
            }

        AutoProxyOptions.fAutoLogonIfChallenged = TRUE;
        }
    else
        {
        LogInfo("no user IE info: %d", GetLastError());

        // WinHttpGetIEProxyForCurrentUser failed, try autodetection anyway...
        AutoProxyOptions.dwFlags =           WINHTTP_AUTOPROXY_AUTO_DETECT;
        AutoProxyOptions.dwAutoDetectFlags = WINHTTP_AUTO_DETECT_TYPE_DHCP |
                                             WINHTTP_AUTO_DETECT_TYPE_DNS_A;
        fTryAutoProxy = TRUE;
        }

    if (fTryAutoProxy)
        {
        LogInfo("trying auto-detect...");

        fSuccess = WinHttpGetProxyForUrl( m_hInternet,
                                          Host,
                                          &AutoProxyOptions,
                                          &ProxyInfo
                                          );
        LogInfo("auto-detect returned %d (%d)", fSuccess, fSuccess ? 0 : GetLastError() );
        }

    // If we didn't do autoproxy or if it failed, see
    // if there's an explicit proxy server in the IE
    // proxy configuration...
    //
    // This is where the WinHttpGetIEProxyConfigForCurrentUser API
    // really comes in handy: in environments in which autoproxy is
    // not supported and so the user's IE browser must be
    // configured with an explicit proxy server.
    //
    if (!fTryAutoProxy || !fSuccess)
        {
        LogInfo("looking for backup ideas");

        if (IEProxyConfig.lpszProxy)
            {
            LogInfo("using named proxy '%S'", IEProxyConfig.lpszProxy ? IEProxyConfig.lpszProxy : NullString );

            ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
            ProxyInfo.lpszProxy       = IEProxyConfig.lpszProxy;
            ProxyInfo.lpszProxyBypass = IEProxyConfig.lpszProxyBypass;
            }
        }

    //
    // If we are not using the proxy strings from IEProxyConfig, then we better delete them.
    //
    if (IEProxyConfig.lpszProxy && ProxyInfo.lpszProxy != IEProxyConfig.lpszProxy)
        {
        GlobalFree( IEProxyConfig.lpszProxy );
        IEProxyConfig.lpszProxy = NULL;
        }

    if (IEProxyConfig.lpszProxyBypass && ProxyInfo.lpszProxyBypass != IEProxyConfig.lpszProxyBypass)
        {
        GlobalFree( IEProxyConfig.lpszProxyBypass );
        IEProxyConfig.lpszProxyBypass = NULL;
        }

    //
    // Sometimes the registry contains a single or double colon for the proxy or, oddly, bypass list.
    // SetRequestProxy rejects them.  Both cases should be treated like a NULL string.
    //
    static wchar_t SingleColon[] = L":";
    static wchar_t DoubleColon[] = L"::";

    if (ProxyInfo.lpszProxy)
        {
        if (0 == wcscmp( ProxyInfo.lpszProxy, SingleColon ) ||
            0 == wcscmp( ProxyInfo.lpszProxy, DoubleColon ))
            {
            LogWarning("suppressing invalid proxy string %S", ProxyInfo.lpszProxy );
            GlobalFree( ProxyInfo.lpszProxy );
            ProxyInfo.lpszProxy = NULL;
            }
        }

    if (ProxyInfo.lpszProxyBypass)
        {
        if (0 == wcscmp( ProxyInfo.lpszProxyBypass, SingleColon ) ||
            0 == wcscmp( ProxyInfo.lpszProxyBypass, DoubleColon ))
            {
            LogWarning("suppressing invalid bypass string %S", ProxyInfo.lpszProxyBypass );
            GlobalFree( ProxyInfo.lpszProxyBypass );
            ProxyInfo.lpszProxyBypass = NULL;
            }
        }

    LogInfo("proxy '%S'", ProxyInfo.lpszProxy ? ProxyInfo.lpszProxy : NullString );
    LogInfo("bypass list '%S'", ProxyInfo.lpszProxyBypass ? ProxyInfo.lpszProxyBypass : NullString );
    LogInfo("access type %d", ProxyInfo.dwAccessType );

    if (AutoConfigUrl)
        {
        GlobalFree( AutoConfigUrl );
        }

    Clear();

    m_ProxyInfo = ProxyInfo;
    m_HostName = Host;
    m_fValid = true;
    m_TimeStamp = GetTickCount();

    //
    // We don't have to release the proxy server and proxy bypass strings
    // because Clear() will do that.
    //

    return S_OK;
}

void
CACHED_AUTOPROXY::Clear()
{
    if (m_fValid)
        {
        m_fValid = false;
        if (m_ProxyInfo.lpszProxy)       GlobalFree(m_ProxyInfo.lpszProxy);
        if (m_ProxyInfo.lpszProxyBypass) GlobalFree(m_ProxyInfo.lpszProxyBypass);
        }

    ZeroMemory(&m_ProxyInfo, sizeof(m_ProxyInfo));
    m_HostName = NULL;
}

PROXY_SETTINGS_CONTAINER::PROXY_SETTINGS_CONTAINER(
    LPCWSTR Url,
    const PROXY_SETTINGS * ProxySettings
    ) :
    m_ProxyUsage( ProxyUsageFromJobProxyUsage( ProxySettings->ProxyUsage )),
    m_ProxyList(  NULL ),
    m_BypassList( NULL ),
    m_TokenCursor( NULL )
{
    //
    // Set up the list of proxy servers.
    //
    switch (m_ProxyUsage)
        {
        case WINHTTP_ACCESS_TYPE_NO_PROXY:
            break;

        case WINHTTP_ACCESS_TYPE_NAMED_PROXY:
            {
            m_MasterProxyList  = ProxySettings->ProxyList;
            m_BypassList       = ProxySettings->ProxyBypassList;
            break;
            }

        case WINHTTP_ACCESS_TYPE_DEFAULT_PROXY:
            {
            THROW_HRESULT( g_ProxyCache->Generate( Url ));

            m_MasterProxyList  = g_ProxyCache->GetProxyList();
            m_BypassList       = g_ProxyCache->GetBypassList();
            m_AccessType = g_ProxyCache->GetAccessType();
            break;
            }

        default:
            ASSERT( 0 );
            break;
        }

    ResetCurrentProxy();
}


HRESULT
SetRequestProxy(
    HINTERNET hRequest,
    PROXY_SETTINGS_CONTAINER * ProxySettings
    )
{
    WINHTTP_PROXY_INFO ProxyInfo;

    ProxyInfo.dwAccessType    = ProxySettings->GetProxyUsage();
    ProxyInfo.lpszProxy       = const_cast<LPWSTR>( ProxySettings->GetCurrentProxy() );
    ProxyInfo.lpszProxyBypass = const_cast<LPWSTR>( ProxySettings->GetBypassList() );

    LogInfo("proxy info:");
    LogInfo("access: %d",  ProxyInfo.dwAccessType );
    LogInfo("server '%S'", ProxyInfo.lpszProxy       ? ProxyInfo.lpszProxy       : NullString );
    LogInfo("bypass '%S'", ProxyInfo.lpszProxyBypass ? ProxyInfo.lpszProxyBypass : NullString );

    if (ProxyInfo.dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
        {
        LogInfo("proxy usage disabled");
        return S_OK;
        }

    if (ProxyInfo.lpszProxy == NULL)
        {
        LogInfo("null proxy");
        return S_OK;
        }

    if (ProxyInfo.dwAccessType == WINHTTP_ACCESS_TYPE_DEFAULT_PROXY)
        {
        LogInfo("mapping PRECONFIG to named proxy");
        ProxyInfo.dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
        }

    if (!WinHttpSetOption( hRequest,
                           WINHTTP_OPTION_PROXY,
                           &ProxyInfo,
                           sizeof(ProxyInfo)
                           ))
        {
        DWORD err = GetLastError();

        LogWarning( "can't set proxy option: %!winerr!", err );
        return HRESULT_FROM_WIN32( err );
        }

    return S_OK;
}

bool IsPossibleProxyFailure( DWORD err )
{
    switch (err)
        {
        case ERROR_WINHTTP_NAME_NOT_RESOLVED:
        case ERROR_WINHTTP_CANNOT_CONNECT:
        case ERROR_WINHTTP_CONNECTION_ERROR:
        case ERROR_WINHTTP_TIMEOUT:
            return true;

        default:
            return false;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\stl.cpp ===
#include "stdafx.h"


CRITICAL_SECTION g_STLCs;
BOOL g_STLCsInitialized = FALSE;



bool InitCompilerLibrary()
{
    if ( !InitializeCriticalSectionAndSpinCount( &g_STLCs, 0x80000000 ) )
        return false;

    g_STLCsInitialized = TRUE;

    return true;
}

bool UninitCompilerLibrary()
{
    if ( g_STLCsInitialized )
        {
        DeleteCriticalSection( &g_STLCs );
        g_STLCsInitialized = FALSE;
        }

    return true;
}

#if 1

#pragma warning( disable : 4273 )

std::_Lockit::_Lockit()
{
    EnterCriticalSection(&g_STLCs);
}

std::_Lockit::~_Lockit()
{
    LeaveCriticalSection(&g_STLCs);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\request.h ===
class CBitsCommandRequest
/*
    This class represents a particular HTTP "BITS_COMMAND" request.

*/
{
public:

    CBitsCommandRequest(
        URL_INFO * UrlInfo
        );

    ~CBitsCommandRequest();

    void AddPacketType( wchar_t type[] );

    void AddSessionId( StringHandle & id );
    void AddSupportedProtocols();
    void AddContentName( StringHandle name );

    void AddContentRange(
        UINT64 RangeStart,
        UINT64 RangeEnd,
        UINT64 Size
        );

    DWORD Send(
        CAbstractDataReader * Reader = 0
        );

    HRESULT
    CheckResponseProtocol(
        GUID * pId
        );

    HRESULT
    GetServerRange(
        UINT64 * RangeEnd
        );

    HRESULT
    GetContentLength(
        UINT64 * Length
        );

    HRESULT
    GetProtocol(
        GUID * id
        );

    HRESULT
    GetSessionId(
        StringHandle * id
        );

    HRESULT
    CheckReplyPacketType();

    HRESULT
    GetBitsError(
        HRESULT * phr
        );

    HRESULT
    GetBitsErrorContext(
        DWORD * pdw
        );

    HRESULT
    GetReplyUrl(
        CAutoString & ReplyUrl
        );

    HRESULT
    GetHostId(
        StringHandle * pstr
        );

    HRESULT
    GetHostIdFallbackTimeout(
        DWORD * pVal
        );

    void DrainReply();

    HINTERNET Query()
    {
        return m_hRequest;
    }


    HRESULT
    GetMandatoryHeaderCb(
        DWORD dwInfoLevel,
        LPCWSTR Name,
        LPWSTR Value,
        DWORD ValueBytes,
        DWORD Line
        );

    HRESULT
    GetOptionalHeaderCb(
        DWORD dwInfoLevel,
        LPCWSTR Name,
        LPWSTR Value,
        DWORD ValueBytes,
        DWORD Line
        );

protected:

    HINTERNET     m_hRequest;
    URL_INFO *  m_UrlInfo;



};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\tasksched.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    tasksched.cpp

Abstract :

    Source file for task manager classes and routines.

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "tasksched.tmh"
#endif

////////////////////////////////////////////////////////////////////////////////////
//
// TaskSchedulerWorkItem
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
// Constructor/Destructor
////////////////////////////////////////////////////////////////////////////////////

TaskSchedulerWorkItem::TaskSchedulerWorkItem( FILETIME *pTimeToRun ) :
m_Container( NULL ),
m_CancelEvent(NULL),
m_ItemComplete(NULL),
m_State(TASK_STATE_NOTHING),
m_WorkGroup(NULL)
{
    try
        {
        // All events are manual reset.
        // new items are complete
        m_CancelEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
        if ( !m_CancelEvent )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        m_ItemComplete = CreateEvent( NULL, TRUE, FALSE, NULL );
        if ( !m_ItemComplete )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        }
    catch ( ComError Error )
        {
        this->~TaskSchedulerWorkItem();
        throw;
        }
}

TaskSchedulerWorkItem::~TaskSchedulerWorkItem()
{
    if ( m_ItemComplete ) SetEvent( m_ItemComplete );
    if ( m_CancelEvent ) CloseHandle( m_CancelEvent );
    if ( m_ItemComplete ) CloseHandle( m_ItemComplete );
}

void
TaskSchedulerWorkItem::Serialize(
    HANDLE hFile
    )
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    bool fActive = g_Manager->m_TaskScheduler.IsWorkItemInScheduler( this );

    SafeWriteFile( hFile, fActive );

    if (fActive)
        {
        SafeWriteFile( hFile, m_InsertionTime );
        SafeWriteFile( hFile, m_TimeToRun );
        }
}

void
TaskSchedulerWorkItem::Unserialize(
    HANDLE hFile
    )
{
    bool fActive;

    SafeReadFile( hFile, &fActive );

    if (fActive)
        {
        SafeReadFile( hFile, &m_InsertionTime );
        SafeReadFile( hFile, &m_TimeToRun );

        LogTask("workitem %p : adding to scheduler for %I64d", this, FILETIMEToUINT64(m_TimeToRun) );

        g_Manager->m_TaskScheduler.InsertWorkItem( this, &m_TimeToRun );
        }
    else
        {
        LogTask("workitem %p: not in scheduler", this );
        }
}

////////////////////////////////////////////////////////////////////////////////////
//
// TaskScheduler
//
////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////
// Constructor/Destructor
////////////////////////////////////////////////////////////////////////////////////

TaskScheduler::TaskScheduler() :
m_bShouldDie(false),
m_WaitableTimer(NULL),
m_ReaderLock(NULL),
m_WriterSemaphore(NULL),
m_ReaderCount(0),
m_WorkItemTLS((DWORD)-1),
m_WriterOwner(0),
m_WorkerInitialized(NULL)
{
    try
        {
        m_WorkItemTLS = TlsAlloc();
        if ( (DWORD)-1 == m_WorkItemTLS)
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_SchedulerLock = CreateMutex( NULL, FALSE, NULL );
        if ( !m_SchedulerLock )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_WaitableTimer = CreateWaitableTimer( NULL, FALSE, NULL );
        if ( !m_WaitableTimer )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        // Create and autoreset event for synchronization on startup
        m_WorkerInitialized = CreateEvent( NULL, FALSE, FALSE, NULL );
        if ( !m_WorkerInitialized )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_ReaderLock = CreateMutex( NULL, FALSE, NULL );
        if ( !m_ReaderLock )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));

        m_WriterSemaphore = CreateSemaphore( NULL, 1, 1, NULL );
        if ( !m_WriterSemaphore )
            throw ComError( HRESULT_FROM_WIN32(GetLastError()));
        }
    catch ( ComError Error )
        {
        this->~TaskScheduler();
        throw;
        }
}

TaskScheduler::~TaskScheduler()
{
    if ((DWORD)-1 != m_WorkItemTLS)
        TlsFree( m_WorkItemTLS );
    if ( m_SchedulerLock )
        CloseHandle( m_SchedulerLock );
    if ( m_WaitableTimer )
        CloseHandle( m_WaitableTimer );
    if ( m_WorkerInitialized )
        CloseHandle( m_WorkerInitialized );
    if ( m_ReaderLock )
        CloseHandle( m_ReaderLock );
    if ( m_WriterSemaphore )
        CloseHandle( m_WriterSemaphore );
}

//////////////////////////////////////////////////////////////////////////////////////////
//  WorkItem control
//////////////////////////////////////////////////////////////////////////////////////////

bool TaskScheduler::CancelWorkItem( TaskSchedulerWorkItem * pWorkItem )
{
    LogTask( "cancelling %p", pWorkItem );

    RTL_VERIFY( WAIT_OBJECT_0 == WaitForSingleObject( m_SchedulerLock, INFINITE ) );

    DWORD dwResult = WaitForSingleObject( pWorkItem->m_ItemComplete , 0 );
    if ( WAIT_OBJECT_0 == dwResult )
        {
        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
        return true; // Job completed before the cancel
        }

    // If canceling the current work item, call Acknowlege immedialtly
    if ( GetCurrentWorkItem() == pWorkItem )
        {
        LogTask( "Canceling work item %p, we are the owner", pWorkItem );
        RTL_VERIFY( SetEvent( pWorkItem->m_CancelEvent ) );
        AcknowledgeWorkItemCancel();
        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
        return false; // Job canceled
        }

    //
    // Remove the work item from its list.
    //

    switch( pWorkItem->m_State )
        {

        case TASK_STATE_WAITING:
            {

            m_WaitingList.erase( *pWorkItem );
            pWorkItem->m_State = TASK_STATE_CANCELED;
            pWorkItem->m_WorkGroup = NULL;
            Reschedule();
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
            return false;

            }

        case TASK_STATE_READY:
            {

            TaskSchedulerWorkGroup *pGroup =
                static_cast<TaskSchedulerWorkGroup*>(pWorkItem->m_WorkGroup);
            pGroup->m_ReadyList.erase( *pWorkItem );
            // Kill one on the semaphore
            RTL_VERIFY( WAIT_OBJECT_0 == WaitForSingleObject( pGroup->m_ItemAvailableSemaphore, 0 ) );
            pWorkItem->m_State = TASK_STATE_CANCELED;
            pWorkItem->m_WorkGroup = NULL;
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
            return false;

            }
        case TASK_STATE_RUNNING:
            {

            // cancelling on another thread
            RTL_VERIFY( SetEvent( pWorkItem->m_CancelEvent ) );
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

            dwResult = WaitForSingleObject( pWorkItem->m_ItemComplete, INFINITE );
            ASSERT( WAIT_OBJECT_0 == dwResult );

            return WAIT_OBJECT_0 != dwResult;

            }

        case TASK_STATE_CANCELED:
        case TASK_STATE_COMPLETE:
        case TASK_STATE_NOTHING:
        default:

           ASSERT( TASK_STATE_CANCELED == pWorkItem->m_State ||
                   TASK_STATE_COMPLETE == pWorkItem->m_State ||
                   TASK_STATE_NOTHING == pWorkItem->m_State );
           ASSERT( NULL == pWorkItem->m_WorkGroup );
           RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
           return true;
        }

}

void TaskScheduler::CompleteWorkItem( bool bCancel )
{
    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    TaskSchedulerWorkItem *pWorkItem = GetCurrentWorkItem();

    LogTask( "completing %p", pWorkItem );

//    ASSERT( pWorkItem );
    if (pWorkItem)
        {
        RTL_VERIFY( TlsSetValue( m_WorkItemTLS, NULL ) );
        TaskSchedulerWorkGroup *pGroup =
            static_cast<TaskSchedulerWorkGroup*>(pWorkItem->m_WorkGroup);
        pGroup->m_RunningList.erase( *pWorkItem );
        pWorkItem->m_WorkGroup = NULL;
        pWorkItem->m_State = bCancel ? TASK_STATE_CANCELED : TASK_STATE_COMPLETE;
        RTL_VERIFY( SetEvent( pWorkItem->m_ItemComplete ));
        }

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
}

void TaskScheduler::DispatchWorkItem()
{
    TaskSchedulerWorkItem *pWorkItem = NULL;

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    // Move all the jobs that are available from waiting
    // to ready
    while ( !m_WaitingList.empty() )
        {
        FILETIME ftCurrentTime;
        GetSystemTimeAsFileTime( &ftCurrentTime );

        TaskSchedulerWorkItem * pHeadItem = &(*m_WaitingList.begin());
        UINT64 CurrentTime = FILETIMEToUINT64( ftCurrentTime );
        UINT64 HeadTime = FILETIMEToUINT64( pHeadItem->m_TimeToRun );


        if ( HeadTime > CurrentTime )
            {
            // All the jobs in the list are still waiting,
            // let them continue waiting
            break;
            }

        // transfer the head work item from the waiting list
        // to the ready list of the correct work group
        m_WaitingList.erase( *pHeadItem );
        AddItemToWorkGroup( pHeadItem->GetSid(), pHeadItem );

        }

    Reschedule();
    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

}

void
TaskScheduler::InsertDelayedWorkItem(
    TaskSchedulerWorkItem *pWorkItem,
    UINT64 Delay100Nsec
    )
{
    FILETIME ftCurrentTime;

    GetSystemTimeAsFileTime( &ftCurrentTime );

    UINT64 TimeToRun = Delay100Nsec + FILETIMEToUINT64( ftCurrentTime );

    FILETIME ftTimeToRun = UINT64ToFILETIME( TimeToRun );

    InsertWorkItem( pWorkItem, &ftTimeToRun );
}

void
TaskScheduler::RescheduleDelayedTask(
    TaskSchedulerWorkItem *pWorkItem,
    UINT64 Delay100Nsec
    )
{
    // Resets the time for the work item to run to be Delay100NSec after
    // the insertion time.

    // If the work item is not in the queue, running, completed,
    // or canceled then this operation is ignored.

    // Otherwise, the job is rescheduled.

    LogTask( "rescheduling %p", pWorkItem );

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    // If the work item is not on a running list or the pending list,
    // ignore the call.

    if ( TASK_STATE_READY == pWorkItem->m_State )
        {
        TaskSchedulerWorkGroup *pGroup =
            static_cast<TaskSchedulerWorkGroup*>( pWorkItem->m_WorkGroup );
        pGroup->m_ReadyList.erase( *pWorkItem );
        RTL_VERIFY( WAIT_OBJECT_0 == WaitForSingleObject( pGroup->m_ItemAvailableSemaphore, 0 ) );
        }
    else if ( TASK_STATE_WAITING == pWorkItem->m_State )
        {
        m_WaitingList.erase( *pWorkItem );
        }
    else
        {
        LogTask( "item %p not pending.  Ignoring.", pWorkItem );
        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
        return;
        }

    UINT64 TimeToRun = Delay100Nsec + FILETIMEToUINT64( pWorkItem->m_InsertionTime );
    pWorkItem->m_TimeToRun = UINT64ToFILETIME( TimeToRun );

    m_WaitingList.insert( *pWorkItem );
    pWorkItem->m_State = TASK_STATE_WAITING;
    pWorkItem->m_WorkGroup = NULL;
    Reschedule();

    LogTask( "item %p rescheduled", pWorkItem );

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
}

inline INT64 abs(INT64 x)
{
    if (x >= 0)
        {
        return x;
        }
    else
        {
        return -x;
        }
}

void TaskScheduler::InsertWorkItem( TaskSchedulerWorkItem *pWorkItem, FILETIME *pTimeToRun )
{
    {
    INT64  Difference;
    FILETIME ftCurrentTime;
    GetSystemTimeAsFileTime( &ftCurrentTime );

    if (pTimeToRun)
        {
        Difference = INT64(FILETIMEToUINT64( *pTimeToRun )) - INT64(FILETIMEToUINT64( ftCurrentTime ));

        if (abs(Difference) > 86400 * NanoSec100PerSec)
            {
            LogTask( "inserting %p; activates in %f days", pWorkItem, float(Difference) / (float(NanoSec100PerSec) * 86400) );
            }
        else
            {
            LogTask( "inserting %p; activates in %f seconds", pWorkItem, float(Difference) / float(NanoSec100PerSec) );
            }
        }
    else
        {
        LogTask( "inserting %p; activates now", pWorkItem );
        }
    }

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );
    GetSystemTimeAsFileTime( &pWorkItem->m_InsertionTime );

    RTL_VERIFY( ResetEvent( pWorkItem->m_CancelEvent ) );
    RTL_VERIFY( ResetEvent( pWorkItem->m_ItemComplete ) );

    if ( !pTimeToRun && !m_bShouldDie )
        {
        pWorkItem->m_TimeToRun = pWorkItem->m_InsertionTime;
        AddItemToWorkGroup( pWorkItem->GetSid(), pWorkItem );
        }
    else
        {
        if (pTimeToRun)
            {
            pWorkItem->m_TimeToRun = *pTimeToRun;
            }
        else
            {
            GetSystemTimeAsFileTime( &pWorkItem->m_TimeToRun );
            }

        pWorkItem->m_State = TASK_STATE_WAITING;
        m_WaitingList.insert( *pWorkItem );
        Reschedule();
        }

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

}

bool TaskScheduler::IsWorkItemInScheduler( TaskSchedulerWorkItem *pWorkItem )
{
    bool b;

    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    b = ( TASK_STATE_WAITING == pWorkItem->m_State ||
          TASK_STATE_READY == pWorkItem->m_State ||
          TASK_STATE_RUNNING == pWorkItem->m_State );

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

    return b;
}

void TaskScheduler::Reschedule()
{
    if ( m_WaitingList.empty() )
        {
        // Nothing to do, cancel waitable timer.
        RTL_VERIFY( CancelWaitableTimer( m_WaitableTimer ) );
        return;
        }

    LARGE_INTEGER NextItemTime;
    FILETIME ftNextItemTime = (*m_WaitingList.begin()).m_TimeToRun;
    NextItemTime.QuadPart = (INT64)FILETIMEToUINT64( ftNextItemTime );

    RTL_VERIFY(
        SetWaitableTimer(
            m_WaitableTimer,
            &NextItemTime,
            0,
            NULL,
            NULL,
            FALSE ) );
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//  Reader/Writer lock
//
//  Algorithm:
//
//  Writer:
//     Wait on writer lock and cancel event.   Return when either is signaled
//
//  Unlock writer:
//     Release the writer lock
//
//  Lock reader:
//     Lock reader lock to protect count.   If I am the first reader, grab the writer semaphore.
//     Unlock reader lock.   If on either wait the cancel event is signaled, abort.
//
//  Unlock reader:
//     Decrement the reader count.  If last reader, release the writer lock.
//
/////////////////////////////////////////////////////////////////////////////////////////////////

bool TaskScheduler::LockReader()
{
    LogLock( "reader" );
    HANDLE hCancel = GetCancelEvent();
    if ( !hCancel )
        {
        RTL_VERIFY( WaitForSingleObject( m_ReaderLock, INFINITE ) == WAIT_OBJECT_0 );

        // InterlockedIncrement returns the new value
        if ( InterlockedIncrement( &m_ReaderCount ) == 1 )
            {
            RTL_VERIFY( WaitForSingleObject( m_WriterSemaphore, INFINITE ) == WAIT_OBJECT_0 );
            }

        RTL_VERIFY( ReleaseMutex( m_ReaderLock ) );
        LogLock("reader lock acquired");
        ASSERT( !m_WriterOwner );
        return false;
        }

    DWORD dwResult;
    HANDLE hReaderLockHandles[2];
    hReaderLockHandles[0] = hCancel;
    hReaderLockHandles[1] = m_ReaderLock;

    dwResult = WaitForMultipleObjects( 2, hReaderLockHandles, false, INFINITE );
    switch ( dwResult )
        {
        case WAIT_OBJECT_0 + 0:
            // cancel request
            LogLock( "Cancel requested, aborting read lock" );
            return true;
        case WAIT_OBJECT_0 + 1:
            // lock acquired
            break;
        default:
            ASSERT(0);
        }

    bool bReturnVal = false;
    ULONG NewReaderCount = InterlockedIncrement( &m_ReaderCount );
    if (1 == NewReaderCount )
        {
        LogLock("First reader, need to block writers");
        HANDLE hWriterLockHandles[2];
        hWriterLockHandles[0] = hCancel;
        hWriterLockHandles[1] = m_WriterSemaphore;

        dwResult = WaitForMultipleObjects( 2, hWriterLockHandles, false, INFINITE );
        switch ( dwResult )
            {
            case WAIT_OBJECT_0 + 0:
                // cancel request
                LogLock( "Cancel requested, aborting acquire of writer lock");
                InterlockedDecrement( &m_ReaderCount );
                bReturnVal = true;
                break;

            case WAIT_OBJECT_0 + 1:
                // lock acquired
                break;
            default:
                ASSERT(0);
            }

        }
    RTL_VERIFY( ReleaseMutex( m_ReaderLock ) );

    if (!bReturnVal)
        {
        LogLock("reader lock acquired");
        ASSERT( !m_WriterOwner );
        }

    return bReturnVal;
}

void TaskScheduler::UnlockReader()
{
    LogLock( "reader unlock" );
    LONG lNewReaderCount = InterlockedDecrement( &m_ReaderCount );
    ASSERT( lNewReaderCount >= 0 );
    if (!lNewReaderCount ) //Last reader
        {
        LogLock( "Last reader, letting writers pass" );
        RTL_VERIFY( ReleaseSemaphore( m_WriterSemaphore, 1, NULL ) );
        }
    LogLock( "Unlocked read access to lock" );
}

bool TaskScheduler::LockWriter()
{
    LogLock( "writer lock" );
    HANDLE hCancel = GetCancelEvent();

    if (!hCancel)
        {
        RTL_VERIFY( WaitForSingleObject( m_WriterSemaphore, INFINITE ) == WAIT_OBJECT_0 );
        ASSERT( !m_WriterOwner );
        m_WriterOwner = GetCurrentThreadId();
        LogLock("Lock acquired with write access");
        return false;
        }

    HANDLE hHandles[2];
    hHandles[0] = hCancel;
    hHandles[1] = m_WriterSemaphore;

    DWORD dwResult = WaitForMultipleObjects( 2, hHandles, false, INFINITE );

    switch ( dwResult )
        {
        case WAIT_OBJECT_0 + 0:
            // cancel request
            LogLock("Cancel requested, aborting lock with write access");
            return true;
        case WAIT_OBJECT_0 + 1:
            // lock acquired
            ASSERT( !m_WriterOwner );
            m_WriterOwner = GetCurrentThreadId();
            LogLock("Lock acquired with write access");
            return false;
        default:
            ASSERT(0);
            return false;
        }

}

void TaskScheduler::UnlockWriter()
{
    LogLock( "writer unlock" );
    ASSERT( GetCurrentThreadId() == m_WriterOwner );
    m_WriterOwner = 0;
    RTL_VERIFY( ReleaseSemaphore( m_WriterSemaphore, 1, NULL ) );
    LogLock("Unlocked lock with write access");
}

TaskScheduler::TaskSchedulerWorkGroup::TaskSchedulerWorkGroup(
    SidHandle Sid ) :
    m_Sid(Sid),
    m_ItemAvailableSemaphore(NULL),
    m_Threads(0),
    m_BusyThreads(0)
{
    memset( m_Thread, 0, sizeof( m_Thread ) );
    memset( m_ThreadId, 0, sizeof( m_ThreadId ) );

    m_ItemAvailableSemaphore =
        CreateSemaphore(
            NULL,
            0, // InitialCount
            0x7FFFFFFF, // MaxCount
            NULL );

    if ( !m_ItemAvailableSemaphore )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

}

TaskScheduler::TaskSchedulerWorkGroup::~TaskSchedulerWorkGroup()
{
   if ( m_ItemAvailableSemaphore )
       CloseHandle( m_ItemAvailableSemaphore );
}

void
TaskScheduler::AddItemToWorkGroup(
    SidHandle Sid,
    TaskSchedulerWorkItem *pWorkItem )
{
   // If the work group has alread been created,
   // don't create it again

   WorkGroupMapType::iterator i = m_WorkGroupMap.find( Sid );
   TaskSchedulerWorkGroup *pWorkGroup = NULL;

   if ( m_WorkGroupMap.end() != i )
       {
       pWorkGroup = (*i).second;
       }
   else
       {
       LogTask( "Creating a new work group" );

       while(1)
           {

           try
           {
               pWorkGroup = new TaskSchedulerWorkGroup( Sid );
               m_WorkGroupMap.insert( WorkGroupMapType::value_type( Sid, pWorkGroup ) );
               LogTask( "Created new workgroup %p", pWorkGroup );
               break;
           }
           catch( ComError Error )
           {
               LogError( "Unable to create new workgroup sleeping, error %!winerr!", Error.Error() );
               m_WorkGroupMap.erase( Sid );
               delete pWorkGroup;
               pWorkGroup = NULL;
               Sleep( 5000 );
           }

           }
       }


   LogInfo( "Adding %p to workgroup %p", pWorkItem, pWorkGroup );
   pWorkGroup->m_ReadyList.insert( *pWorkItem );
   pWorkItem->m_State = TASK_STATE_READY;
   pWorkItem->m_WorkGroup = pWorkGroup;
   RTL_VERIFY( ReleaseSemaphore( pWorkGroup->m_ItemAvailableSemaphore, 1, NULL ) );

   // use a very aproximative heuristic to determine when to add more threads.
   // The load is the number of work items that are ready to run plus the number
   // of items being worked on(busy threads). See the note below why the number of
   // ready work items is not a good estimate.
   size_t Load = pWorkGroup->m_ReadyList.size() + pWorkGroup->m_BusyThreads;
   if ( Load > pWorkGroup->m_Threads &&
        pWorkGroup->m_Threads < MAX_WORKGROUP_THREADS )
       {

       LogInfo( "load of %u and %u threads. Add another thread",
                Load, pWorkGroup->m_Threads );

       while(1)
           {

           m_NewWorkerGroup = pWorkGroup;
           ASSERT( m_WorkGroupMap.end() != m_WorkGroupMap.find( m_NewWorkerGroup->m_Sid ) );
           RTL_VERIFY( ResetEvent( m_WorkerInitialized ) );

           HANDLE & ThreadHandle = pWorkGroup->m_Thread[ pWorkGroup->m_Threads ];
           DWORD & ThreadId = pWorkGroup->m_ThreadId[ pWorkGroup->m_Threads ];

           ThreadHandle =
               CreateThread(
                   NULL, // security descriptor
                   0,    // Use default stack
                   TaskScheduler::WorkGroupWorkerThunk,
                   static_cast<LPVOID>( this ),
                   0,
                   &ThreadId );

           if ( !ThreadHandle )
               {
               LogError( "Unable to create new worker, error %!winerr!", GetLastError() );
               Sleep( 5000 );
               continue;
               }


           LogTask( "Created new worker with a handle %p, ID %u", ThreadHandle, ThreadId );

           HANDLE WaitHandles[2] = { ThreadHandle, m_WorkerInitialized };
           DWORD dwResult =
               WaitForMultipleObjectsEx(
                   2,
                   WaitHandles,
                   FALSE,
                   INFINITE,
                   FALSE );

           switch( dwResult )
               {
               case WAIT_OBJECT_0:
                   GetExitCodeThread( ThreadHandle, &dwResult );
                   LogError( "Thread exited with code %!winerr!, sleeping", dwResult );
                   CloseHandle( ThreadHandle );
                   ThreadHandle = 0;
                   ThreadId = 0;

                   Sleep( 5000 );
                   continue;

               case WAIT_OBJECT_0 + 1:
                   break;

               default:
                   LogError( "Unexpected error, %!winerr!", dwResult );
                   ASSERT( 0 );
               }

           LogTask( "Worker signaled success" );
           m_NewWorkerGroup = NULL;
           pWorkGroup->m_Threads++;

           break;
           }
       }
}

void
TaskScheduler::KillBackgroundTasks()
{

    LogTask( "Killing background threads" );
    RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

    m_bShouldDie = TRUE;
    DWORD Result;

    while(1)
        {

        if ( m_WorkGroupMap.empty() )
            {
            LogTask( "No more work groups, all done" );
            RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
            return;
            }

        TaskSchedulerWorkGroup *pGroup = (*m_WorkGroupMap.begin()).second;
        RTL_VERIFY( ReleaseSemaphore( pGroup->m_ItemAvailableSemaphore, pGroup->m_Threads, NULL ) );

        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

        Result = WaitForMultipleObjects( pGroup->m_Threads, pGroup->m_Thread, TRUE, INFINITE );
        // WAIT_OBJECT_0 == 0 so Result >= WAIT_OBJECT_0 is always true
        ASSERT(  Result < WAIT_OBJECT_0 + pGroup->m_Threads );

        RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );

        for(size_t c=0; c < pGroup->m_Threads; c++ )
            {
            CloseHandle( pGroup->m_Thread[c] );
            }

        m_WorkGroupMap.erase( pGroup->m_Sid );
        delete pGroup;

        LogTask( "Killed everyone in work group %p", pGroup );

        }
}

DWORD BackgroundThreadProcFilter(
    LPEXCEPTION_POINTERS ExceptionPointers );

DWORD
TaskScheduler::WorkGroupWorkerThunk( void *pContext )
{
   __try
   {
       return
       static_cast<TaskScheduler*>( pContext )->WorkGroupWorker();
   }
    __except( BackgroundThreadProcFilter(
                  GetExceptionInformation() ) )
    {
        ASSERT( 0 );
    }
    ASSERT( 0 );

    return 0;
}

DWORD
TaskScheduler::WorkGroupWorker( )

{
    HRESULT Hr;

    LogTask( "I'm alive!" );

    Hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED( Hr ) )
        {
        LogError( "CoInitializeEx failed, %!winerr!", Hr );
        return (DWORD)(Hr);
        }

    TaskSchedulerWorkGroup *pGroup = m_NewWorkerGroup;

    ASSERT( m_WorkGroupMap.end() != m_WorkGroupMap.find( pGroup->m_Sid ) );

    RTL_VERIFY( SetEvent( m_WorkerInitialized ) );

    LogTask( "Initialization complete" );

    while(1)
        {
        TaskSchedulerWorkItem *pWorkItem = NULL;
        HANDLE Handles[] = { pGroup->m_ItemAvailableSemaphore, m_SchedulerLock };

        DWORD dwWaitResult =
           WaitForMultipleObjectsEx(
               sizeof(Handles)/sizeof(*Handles),
               Handles,
               TRUE,  // Wait for all events
               30000,
               FALSE ); // ablertable wait

        switch( dwWaitResult )
            {
            case WAIT_OBJECT_0:
            case WAIT_OBJECT_0+1:
                break;
            case WAIT_TIMEOUT:
                {
                LogInfo( "Timeout expired, check if we have something to do");
                RTL_VERIFY( WaitForSingleObject( m_SchedulerLock, INFINITE ) == WAIT_OBJECT_0 );
                if ( pGroup->m_ReadyList.empty() )
                    {
                    goto cleanup_on_timeout;
                    }
                else
                    {
                    LogTask( "Still stuff to do, stay alive" );
                    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );
                    continue;
                    }
                }
            default:
                ASSERT(0);
            }

        if ( m_bShouldDie )
            {
            LogTask( "Ordered to die, do so" );
            goto dodie;
            }


        ASSERT( !pGroup->m_ReadyList.empty() );

        // Get first item in ready list and move
        // it over to running list.
        pWorkItem = &(*pGroup->m_ReadyList.begin());
        pGroup->m_ReadyList.erase( *pWorkItem );
        pGroup->m_RunningList.insert( *pWorkItem );
        pWorkItem->m_State = TASK_STATE_RUNNING;
        ASSERT( pGroup == pWorkItem->m_WorkGroup );

        // Mark this thread as busy
        // NOTE: This counter is needed because some
        // code marks work items as complete even though
        // the really arn't complete yet.  So we need
        // to have this to indicatate has many threads
        // are really available.
        InterlockedIncrement( &pGroup->m_BusyThreads );

        RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

        // Now do the real dispatching

        LogTask( "dispatching %p", pWorkItem );

        RTL_VERIFY( TlsSetValue( m_WorkItemTLS, pWorkItem ) );
        pWorkItem->OnDispatch();
        if (GetCurrentWorkItem())
            CompleteWorkItem();

        // Mark this thread as free
        InterlockedDecrement( &pGroup->m_BusyThreads );

        }

cleanup_on_timeout:

    if ( 1 == pGroup->m_Threads )
        {
        // If were the last thread, destroy the workgroup

        LogTask( "We are the only thread, destroy work group %p", pGroup );

        CloseHandle( pGroup->m_Thread[0] );
        WorkGroupMapType::iterator i = m_WorkGroupMap.find( pGroup->m_Sid );
        ASSERT( m_WorkGroupMap.end() != i );
        m_WorkGroupMap.erase( i );
        delete pGroup;

        }
    else
        {

        // we were not the last thread, so remove ourselves from the list.
        // First, find the slot for this thread.

        size_t index = 0;
        for (;index < pGroup->m_Threads; index++ )
            {
            if ( GetCurrentThreadId() == pGroup->m_ThreadId[index] )
                break;
            }
        ASSERT( index < pGroup->m_Threads );

        LogTask( "We are not the only thread, remove thread in slot %u", index );

        CloseHandle( pGroup->m_Thread[index] );

        // collapse the list
        size_t slots = pGroup->m_Threads - index - 1;
        memmove( &pGroup->m_Thread[index], &pGroup->m_Thread[index+1], slots * sizeof(*pGroup->m_Thread) );
        memmove( &pGroup->m_ThreadId[index], &pGroup->m_ThreadId[index+1], slots * sizeof(*pGroup->m_ThreadId) );

        pGroup->m_Threads--;

        pGroup->m_Thread[pGroup->m_Threads] = 0;
        pGroup->m_ThreadId[pGroup->m_Threads] = 0;
        }

dodie:

    RTL_VERIFY( ReleaseMutex( m_SchedulerLock ) );

    CoUninitialize();
    return 0;

}

//------------------------------------------------------------------------

void
ReleaseWriteLock( bool & bNeedLock )
{
    bNeedLock = false;

    if (g_Manager->m_TaskScheduler.IsWriter())
        {
        g_Manager->m_TaskScheduler.UnlockWriter();
        bNeedLock = true;
        }
}

void
ReclaimWriteLock( bool & bNeedLock )
{
    bool bCancelled = false;

    if (bNeedLock && !g_Manager->m_TaskScheduler.IsWriter())
        {
        while (g_Manager->m_TaskScheduler.LockWriter() )
            {
            g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
            bCancelled = true;
            }

        bNeedLock = false;
        }

    if (bCancelled)
        {
        LogInfo("can't retake writer lock: the workitem was cancelled");
        throw ComError( S_FALSE );
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\stdafx.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    stdafx.h

Abstract :

    Main header file for QMGR.

Author :

Revision History :

 ***********************************************************************/

#pragma once
#if !defined(__QMGR_QMGR_STDAFX__)

#define INITGUID

// Global Headers
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>

#include <windows.h>
#include <olectl.h>
#include <objbase.h>
#include <docobj.h>
//shell related
#include <shlwapi.h>            //for PathFindFileName
#include <shlguid.h>            //for CGID_ShellServiceObject

#include <tchar.h>
#include <lmcons.h>
#include <setupapi.h>
#include <inseng.h>

#ifdef USE_WININET
#include <wininet.h>
#else
#include "winhttp.h"
#include "inethttp.h"
#endif

#include <coguid.h>
#include <sens.h>
#include <sensevts.h>
#include <eventsys.h>

#include <winsock2.h>
#include <iphlpapi.h>
#include <bitsmsg.h>
#include <memory>

#include <vss.h>        // used by the backup writer code
#include <vswriter.h>   // used by the backup writer code

#include "qmgrlib.h"
#include "eventlog.h"
#include "metadata.h"

#include "bits.h"
#include "locks.hxx"
#include "caddress.h"
#include "cmarshal.h"
#include "ccred.h"
#include "proxy.h"
#include "downloader.h"
#include "request.h"
#include "uploader.h"
#include "csd.h"
#include "cunknown.h"
#include "csens.h"
#include "logontable.h"
#include "tasksched.h"
#include "cfile.h"
#include "cerror.h"
#include "cjob.h"
#include "cenum.h"
#include "drizcpat.h"
#include "cmanager.h"

using namespace std;

#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

inline void SafeFreeBSTR( BSTR & p) { if (NULL != (p)) { SysFreeString(p); p = NULL; } }

#define QM_STATUS_FILE_ERROR        0x00000004#

// Global vars
extern long g_cLocks;
extern long g_cComponents;
extern HINSTANCE g_hinstDll;

// Macros
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))
#endif

HRESULT GlobalLockServer(BOOL fLock);

#endif //__QMGR_QMGR_STDAFX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\tasksched.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    tasksched.h

Abstract :

    Header file for task manager classes and routines.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#if !defined(__QMGR_TASKSCHEDULER_)
#define __QMGR_TASKSCHEDULER__

#include <set>
#include <map>
#include <clist.h>

using namespace std;

#define SYNCHRONIZED_READ
#define SYNCHRONIZED_WRITE

class TaskScheduler;
class TaskSchedulerWorkItem;
class TaskSchedulerWorkItemSorter;
class SortedWorkItemList;

enum TASK_SCHEDULER_WORK_ITEM_STATE
{
    TASK_STATE_WAITING,
    TASK_STATE_READY,
    TASK_STATE_RUNNING,
    TASK_STATE_CANCELED,
    TASK_STATE_COMPLETE,
    TASK_STATE_NOTHING
};

class TaskSchedulerWorkItem :
    public IntrusiveList<TaskSchedulerWorkItem>::Link
    {
private:

    FILETIME m_InsertionTime;
    FILETIME m_TimeToRun; // 0 if should run now.
    HANDLE m_CancelEvent; // Signaled on request to cancel.
    HANDLE m_ItemComplete; // Signaled on item complete or cancel.

    void * m_WorkGroup;
    TASK_SCHEDULER_WORK_ITEM_STATE m_State;


public:

    SortedWorkItemList * m_Container;

    //--------------------------------------------------------------------

    TaskSchedulerWorkItem( FILETIME *pTimeToRun = NULL );
    virtual ~TaskSchedulerWorkItem();

    virtual void OnDispatch() = 0;   // Called when work item is dispatched

    friend TaskScheduler;
    friend TaskSchedulerWorkItemSorter;

    void Serialize(
        HANDLE hFile
        );

    void Unserialize(
        HANDLE hFile
        );

    virtual SidHandle GetSid() = 0;

    };

class TaskSchedulerWorkItemSorter
    {
public:
    bool operator()(TaskSchedulerWorkItem *pA, TaskSchedulerWorkItem *pB ) const
    {
        // Convert all times to UINT64
        UINT64 TimeToRunA = FILETIMEToUINT64( pA->m_TimeToRun );
        UINT64 TimeToRunB = FILETIMEToUINT64( pB->m_TimeToRun );
        UINT64 InsertionTimeA = FILETIMEToUINT64( pA->m_InsertionTime );
        UINT64 InsertionTimeB = FILETIMEToUINT64( pB->m_InsertionTime );

        if ( TimeToRunA != TimeToRunB )
            return(TimeToRunA < TimeToRunB );
        if ( InsertionTimeA != InsertionTimeB )
            return(InsertionTimeA < InsertionTimeB);
        return pA < pB;
    }
    };

class SortedWorkItemList : public IntrusiveList<TaskSchedulerWorkItem>

{
    typedef IntrusiveList<TaskSchedulerWorkItem>::iterator iterator;

    TaskSchedulerWorkItemSorter m_sorter;

public:

    void insert( TaskSchedulerWorkItem & val )
    {
        for (iterator iter=begin(); iter != end(); ++iter)
            {
            if ( false == m_sorter( &(*iter), &val ))
                {
                break;
                }
            }

        IntrusiveList<TaskSchedulerWorkItem>::insert( iter, val );

        val.m_Container = this;
    }

    size_t erase(  TaskSchedulerWorkItem & val )
    {
        ASSERT( val.m_Container == NULL || val.m_Container == this );

        val.m_Container = NULL;

        return IntrusiveList<TaskSchedulerWorkItem>::erase( val );
    }
};

class TaskScheduler
    {
public:

    TaskScheduler(); //Throws an HRESULT exception on error
    virtual ~TaskScheduler();

    // Handle which is signaled when a work item may be available.
    HANDLE GetWaitableObject();

    // Gets the current work item for the current thread.
    // Returns NULL if no work item is active.
    TaskSchedulerWorkItem* GetCurrentWorkItem();

    // Gets the cancel event for current work item, else return NULL
    HANDLE GetCancelEvent();

    // Returns true if the job assigned to the current thread
    // has a requested abort. Returns false if no job is assigned.
    bool PollAbort();

    // Gets a work item off the queue if available and dispatches it.
    void DispatchWorkItem();

    // returns true if the job completed before the cancel
    // This should not happen if both the thread that does the canceling
    // and the canceler thread are holdering the writer lock.
    // If the current thread is canceling the work item, the cancel is acknowledged immediatly.
    bool CancelWorkItem( TaskSchedulerWorkItem *pWorkItem );

    // Completes the current work item.
    void CompleteWorkItem();

    // Acknoledges a cancel of the current work item
    void AcknowledgeWorkItemCancel();

    void
    InsertDelayedWorkItem(
        TaskSchedulerWorkItem *pWorkItem,
        UINT64 Delay100Nsec
        );

    void RescheduleDelayedTask( TaskSchedulerWorkItem *pWorkItem, UINT64 Delay100Nsec );


    void InsertWorkItem( TaskSchedulerWorkItem *pWorkItem, FILETIME *pTimeToRun = NULL );

    bool IsWorkItemInScheduler( TaskSchedulerWorkItem *pWorkItem );

    // returns true if current job cancelled before lock acquire
    bool LockReader();
    void UnlockReader();
    // returns true if current job cancelled before lock acquire
    bool LockWriter();
    void UnlockWriter();

    bool IsWriter()
    {
        if (m_WriterOwner == GetCurrentThreadId())
            {
            return true;
            }

        return false;
    }

    void KillBackgroundTasks();

private:

    static const size_t MAX_WORKGROUP_THREADS = 4;

    class TaskSchedulerWorkGroup
    {
    public:
        SidHandle m_Sid;
        SortedWorkItemList m_ReadyList;
        SortedWorkItemList m_RunningList;
        HANDLE m_ItemAvailableSemaphore;
        DWORD m_Threads;
        HANDLE m_Thread[MAX_WORKGROUP_THREADS];
        DWORD m_ThreadId[MAX_WORKGROUP_THREADS];
        LONG m_BusyThreads;
        TaskSchedulerWorkGroup( SidHandle Sid );
        ~TaskSchedulerWorkGroup();
    };

    bool m_bShouldDie;
    HANDLE m_SchedulerLock, m_WaitableTimer, m_ReaderLock, m_WriterSemaphore;
    LONG m_ReaderCount;
    DWORD m_WorkItemTLS;
    DWORD m_WriterOwner;

    SortedWorkItemList m_WaitingList;

    typedef map<SidHandle, TaskSchedulerWorkGroup*, CSidSorter> WorkGroupMapType;
    WorkGroupMapType m_WorkGroupMap;

    // Only used when creating a new background worker
    HANDLE m_WorkerInitialized;
    TaskSchedulerWorkGroup *m_NewWorkerGroup;

    void CompleteWorkItem( bool bCancel );
    void Reschedule();

    void AddItemToWorkGroup(
        SidHandle Sid,
        TaskSchedulerWorkItem *pWorkItem );
    static DWORD WorkGroupWorkerThunk( void *pContext );
    DWORD WorkGroupWorker( );
};


/////////////////////////////////////////////////////////////////////////////
// Simple inlined functions
/////////////////////////////////////////////////////////////////////////////

inline HANDLE
TaskScheduler::GetWaitableObject()
{
    return m_WaitableTimer;
}

inline TaskSchedulerWorkItem*
TaskScheduler::GetCurrentWorkItem()
{
    return(TaskSchedulerWorkItem*)TlsGetValue( m_WorkItemTLS );
}

inline HANDLE
TaskScheduler::GetCancelEvent()
{
    TaskSchedulerWorkItem *pWorkItem = GetCurrentWorkItem();
    return pWorkItem ? pWorkItem->m_CancelEvent : NULL;
}

inline bool
TaskScheduler::PollAbort()
{
    return( WaitForSingleObject( GetCancelEvent(), 0 ) == WAIT_OBJECT_0 );
}

inline void
TaskScheduler::CompleteWorkItem()
{
    CompleteWorkItem(false);
}

inline void
TaskScheduler::AcknowledgeWorkItemCancel()
{
    ASSERT( PollAbort() );
    CompleteWorkItem(true);
}

class HoldReaderLock
    {
    TaskScheduler * const m_TaskScheduler;
    bool                  m_Taken;

public:
    HoldReaderLock( TaskScheduler *pTaskScheduler ) :
        m_TaskScheduler( pTaskScheduler ),
        m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockReader() );
            m_Taken = true;
            }
    }

    HoldReaderLock( TaskScheduler & TaskScheduler ) :
        m_TaskScheduler( &TaskScheduler ),
        m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockReader() );
            m_Taken = true;
            }
    }

    ~HoldReaderLock()
    {
        if (m_Taken)
            {
            m_TaskScheduler->UnlockReader();
            }
    }
    };

class HoldWriterLock
    {
    TaskScheduler * const m_TaskScheduler;
    bool                  m_Taken;

public:
    HoldWriterLock( TaskScheduler *pTaskScheduler ) :
        m_TaskScheduler( pTaskScheduler ),
        m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockWriter() );
            m_Taken = true;
            }
    }

    HoldWriterLock( TaskScheduler & TaskScheduler ) :
    m_TaskScheduler( &TaskScheduler ),
    m_Taken( false )
    {
        if (false == m_TaskScheduler->IsWriter() )
            {
            RTL_VERIFY( !m_TaskScheduler->LockWriter() );
            m_Taken = true;
            }
    }

    ~HoldWriterLock()
    {
        if (m_Taken)
            {
            m_TaskScheduler->UnlockWriter();
            }
    }
    };

/*
    Boilerplate code to release and reclaim the write lock, throwing S_FALSE
    if the current workitem is cancelled.  Use them like this:

            bool bNeedLock;
            try
                {
                ReleaseWriteLock( bNeedLock );

                code....

                ReclaimWriteLock( bNeedLock );
                return;
                }
            catch ( ComError err )
                {
                ReclaimWriteLock( bNeedLock );
                throw;
                }

*/

void ReleaseWriteLock( bool & bNeedLock );
void ReclaimWriteLock( bool & bNeedLock );

//
//
//
template<class T, DWORD LockFlags >
class CLockedReadPointer
    {
protected:
    const T * const m_Pointer;
public:
    CLockedReadPointer( const T * Pointer) :
       m_Pointer(Pointer)
    {
        RTL_VERIFY( !g_Manager->LockReader() );
    }
    ~CLockedReadPointer()
    {
        g_Manager->UnlockReader();
    }
    HRESULT ValidateAccess()
    {
        return m_Pointer->CheckClientAccess(LockFlags);
    }
    const T * operator->() const { return m_Pointer; }
    };

template<class T, DWORD LockFlags>
class CLockedWritePointer
    {
protected:
    T * const m_Pointer;
public:
    CLockedWritePointer( T * Pointer ) :
        m_Pointer(Pointer)
    {
        RTL_VERIFY( !g_Manager->LockWriter() );
    }
    ~CLockedWritePointer()
    {
        g_Manager->UnlockWriter();
    }
    HRESULT ValidateAccess()
    {
        return m_Pointer->CheckClientAccess(LockFlags);
    }
    T * operator->() const { return m_Pointer; }
    };

#endif //__QMGR_TASKSCHEDULER__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\tescape.cpp ===
#include "stdafx.h"
#include "Shellapi.h"

int _cdecl main( int argc, char*argv[] )
{

    int argcw;

    WCHAR** argvw =
        CommandLineToArgvW( GetCommandLineW(), &argcw );

    WCHAR EscapedURL[ INTERNET_MAX_URL_LENGTH ];

    HRESULT Hr =
        EscapeURL(
            EscapedURL,
            argvw[1],
            false,
            INTERNET_MAX_URL_LENGTH );

    if ( FAILED( Hr ) )
        {
        printf( "Unable to escape URL, error 0x%8.8X\n", Hr );
        return Hr; 
        }        

    printf( "%S\n", EscapedURL );

    return 0; 

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\testcsd.cpp ===
#if 0

//++++++++++++++++++++++++++++++++++

#include <sspi.h>
#include <secext.h>


void PrintIdentity();
SidHandle MakeSessionUserSid( unsigned session );
BOOL
GetUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    );


HANDLE
MakeToken(
    wchar_t Domain[],
    wchar_t User[],
    wchar_t Password[]
    );

void TestImpersonationObjects()
{
    HANDLE token;
    SidHandle sid;

    PrintIdentity();

        {
        sid = MakeSessionUserSid( 0 );
        CNestedImpersonation imp( sid );

        // verify that ID changed to the logged-on user
        //
        PrintIdentity();

        token = MakeToken( NULL, L"u2", L"Test222" );

            {
            CNestedImpersonation imp( token );

            // verify that ID changed to the token
            //
            PrintIdentity();

            DbgPrint("end of u2 scope\n");
            }

        // verify that ID reverted to previous impersonation
        //
        PrintIdentity();
        DbgPrint("end of u1 scope\n");
        }

    // verify that ID reverted to non-impersonated ID
    //
    PrintIdentity();

        {
        token = MakeToken( NULL, L"u1", L"Test111" );
        CNestedImpersonation imp( token );

        // verify that ID changed to the token
        //
        PrintIdentity();

        token = MakeToken( NULL, L"u2", L"Test222" );

            {
            CNestedImpersonation imp( token );

            // verify that ID changed to the token
            //
            PrintIdentity();

            DbgPrint("end of u2 scope\n");
            }

        // verify that ID reverted to previous impersonation
        //
        PrintIdentity();
        DbgPrint("end of u1 scope\n");
        }
}

HANDLE
MakeToken(
    wchar_t Domain[],
    wchar_t User[],
    wchar_t Password[]
    )
{
    HANDLE Token;
    if (!LogonUser( User,
                   Domain,
                   Password,
                   LOGON32_LOGON_INTERACTIVE,
                   LOGON32_PROVIDER_DEFAULT,
                   &Token))
        {
        DbgPrint("ERROR: LogonUser failed with %d\n", GetLastError() );
        exit(1);
        }

    DbgPrint("made token for %S\n", User);
    return Token;
}

SidHandle MakeSessionUserSid( unsigned session )
{
    HANDLE token;

    if (!GetUserToken( session, &token ))
        {
        DbgPrint("ERROR: GetUserToken failed with %d\n", GetLastError() );
        }

    SidHandle sid = CopyTokenSid( token );

    wchar_t buf[1000];

    if (!SidToString( sid.get(), buf, sizeof(buf)))
        {
        DbgPrint("ERROR: unable to print the sid\n");
        exit(1);
        }

    DbgPrint("made sid handle for %S\n", buf);

    return sid;
}

void PrintIdentity()
{
    ULONG size;
    wchar_t buf[1000];

    size = sizeof(buf)/sizeof(buf[0]);

    if (!GetUserNameEx( NameSamCompatible,
                        buf,
                        &size))
        {
        DbgPrint("ERROR: GetUserNameEx failed with %d\n", GetLastError() );
        exit(1);
        }

    DbgPrint("current identity is %S\n", buf);
}
#endif  // 1

#if 0

//++++++++++++++++++++++++++++++++++

#include <sspi.h>
#include <secext.h>


void PrintIdentity();
SidHandle MakeSessionUserSid( unsigned session );
BOOL
GetUserToken(
    ULONG LogonId,
    PHANDLE pUserToken
    );


HANDLE
MakeToken(
    wchar_t Domain[],
    wchar_t User[],
    wchar_t Password[]
    );

void TestComImpersonation()
{
    HANDLE token;
    SidHandle sid;

    PrintIdentity();

        {
        CNestedImpersonation imp;

        // verify that ID changed to the logged-on user
        //
        PrintIdentity();

        token = MakeToken( NULL, L"u2", L"Test222" );

            {
            CNestedImpersonation imp( token );

            // verify that ID changed to the token
            //
            PrintIdentity();

            DbgPrint("end of u2 scope\n");
            }

        // verify that ID reverted to previous impersonation
        //
        PrintIdentity();

        imp.SwitchToLogonToken();

        // verify that ID reverted to previous impersonation
        //
        PrintIdentity();

        DbgPrint("end of u1 scope\n");
        }

    PrintIdentity();
}

HANDLE
MakeToken(
    wchar_t Domain[],
    wchar_t User[],
    wchar_t Password[]
    )
{
    HANDLE Token;
    if (!LogonUser( User,
                   Domain,
                   Password,
                   LOGON32_LOGON_INTERACTIVE,
                   LOGON32_PROVIDER_DEFAULT,
                   &Token))
        {
        DbgPrint("ERROR: LogonUser failed with %d\n", GetLastError() );
        exit(1);
        }

    DbgPrint("made token for %S\n", User);
    return Token;
}

SidHandle MakeSessionUserSid( unsigned session )
{
    HANDLE token;

    if (!GetUserToken( session, &token ))
        {
        DbgPrint("ERROR: GetUserToken failed with %d\n", GetLastError() );
        }

    SidHandle sid = CopyTokenSid( token );

    wchar_t buf[1000];

    if (!SidToString( sid.get(), buf, sizeof(buf)))
        {
        DbgPrint("ERROR: unable to print the sid\n");
        exit(1);
        }

    DbgPrint("made sid handle for %S\n", buf);

    return sid;
}

void PrintIdentity()
{
    ULONG size;
    wchar_t buf[1000];

    size = sizeof(buf)/sizeof(buf[0]);

    if (!GetUserNameEx( NameSamCompatible,
                        buf,
                        &size))
        {
        DbgPrint("ERROR: GetUserNameEx failed with %d\n", GetLastError() );
        exit(1);
        }

    DbgPrint("current identity is %S\n", buf);
}
#endif  // 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\uploader.cpp ===
/************************************************************************

Copyright (c) 2001 - 2002 Microsoft Corporation

Module Name :

    uploader.cpp

Abstract :

    Implements HTTP upload and upload-reply transactions.

Author :

    Jeff Roberts

 ***********************************************************************/

#include "stdafx.h"
#include "uploader.tmh"

void
CProgressiveDL::Upload(
    CUploadJob *        job,
    ITransferCallback * Callbacks,
    HANDLE              Token,
    QMErrInfo &         ErrInfo
    )
{
    try
        {
        ErrInfo.Clear();
        ErrInfo.result = QM_IN_PROGRESS;

        THROW_HRESULT( CheckLanManHashDisabled());

        CNestedImpersonation imp( Token );

        Uploader uploader( this, m_Network, job, Token, Callbacks, ErrInfo );

        uploader.Transfer();
        }
    catch ( ComError err )
        {
        if (err.m_error == S_FALSE)
            {
            // abort detected while taking the global lock.
            //
            ErrInfo.result = QM_FILE_ABORTED;
            }
        else
            {
            if (!ErrInfo.IsSet())
                {
                Uploader::SetResult( ErrInfo, SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, err.Error() );
                }

            if (ErrInfo.result == QM_IN_PROGRESS)
                {
                ErrInfo.result = CategorizeError( ErrInfo );
                }
            }
        }

    //
    // Map any connection failure to BG_E_NETWORK_DISCONNECTED, if no nets are active.
    //
    if (ErrInfo.result == QM_FILE_TRANSIENT_ERROR)
        {
        if (g_Manager->m_NetworkMonitor.GetAddressCount() == 0)
            {
            ErrInfo.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
            }
        }
}

void
Uploader::SetResult(
    QMErrInfo &  err,
    ERROR_SOURCE source,
    ERROR_STYLE  style,
    DWORD        code,
    char *       comment
    )
{
    err.Set( source, style, code, comment );
    err.result = CategorizeError( err );
}


Uploader::ResponseTable Uploader::CreateSession_ResponseTable =
{
    GenericServerError,

    {
    { HTTP_STATUS_OK,       CreateSession_NewSession },
    { HTTP_STATUS_CREATED,  CreateSession_NewSession },
    { NULL,                 NULL                     }
    }
};

Uploader::ResponseTable Uploader::SendData_ResponseTable =
{
    SendData_Failure,

    {
    { HTTP_STATUS_OK,                    SendData_Success        },
    { HTTP_STATUS_RANGE_NOT_SATISFIABLE, SendData_Success        },
    { NULL,                              NULL                    }
    }
};

Uploader::ResponseTable Uploader::CancelSession_ResponseTable =
{
    CancelSession_Failure,

    {
    { HTTP_STATUS_OK,                       CancelSession_Success   },
    { NULL,                                 NULL                    }
    }
};

Uploader::ResponseTable Uploader::CloseSession_ResponseTable =
{
    CloseSession_Failure,

    {
    { HTTP_STATUS_OK,                       CloseSession_Success   },
    { NULL,                                 NULL                    }
    }
};

Uploader::Uploader(
    Downloader * dl,
    CNetworkInterface & net,
    CUploadJob * job,
    HANDLE Token,
    ITransferCallback * Callbacks,
    QMErrInfo  & ErrorInfo
    )
    :
      m_Network( net ),
      m_Token( Token ),
      m_Callbacks( Callbacks ),
      m_Credentials( &job->QueryCredentialsList() ),
      m_job( job ),
      m_file( job->GetUploadFile() ),
      m_data( job->GetUploadData() ),
      m_JobType( job->GetType() ),
      m_ErrorInfo( ErrorInfo ),
      m_Downloader( dl ),
      m_Restarts( 0 )
{
    m_ErrorInfo.Clear();

    //
    // Open the local file.
    //
    auto_HANDLE<NULL> hFile;

    try
        {
        hFile = m_file->OpenLocalFileForUpload();
        }
    catch ( ComError err )
        {
        ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, err.Error() );
        throw;
        }

    //
    // Create a connection to the server and init the network object.
    //
    m_UrlInfo = ContactServer();

    UINT64 BytesRemaining = m_file->_GetBytesTotal() - m_file->_GetBytesTransferred();

    m_Network.CalculateIntervalAndBlockSize( BytesRemaining );

    //
    // Success: now the object owns the file handle.
    //
    m_hFile = hFile.release();
}

Uploader::~Uploader()
{
    CloseHandle( m_hFile );
}

void
Uploader::Transfer()
{
    bool fRetry;

    do
        {
        fRetry = false;

        try
            {
            while (!m_ErrorInfo.IsSet() &&
                   !InTerminalState())
                {
                if (m_Callbacks->PollAbort())
                    {
                    throw ComError( S_FALSE );
                    }

                switch (m_data.State)
                    {
                    case UPLOAD_STATE_CREATE_SESSION:   CreateSession();    break;
                    case UPLOAD_STATE_SEND_DATA:        SendData();         break;
                    case UPLOAD_STATE_GET_REPLY:        GetReply();         break;
                    case UPLOAD_STATE_CLOSE_SESSION:    CloseSession();     break;
                    case UPLOAD_STATE_CANCEL_SESSION:   CancelSession();    break;
                    }
                }
            }
        catch (ComError err )
            {
            if (err.Error() == E_RETRY)
                {
                fRetry = true;
                }
            else
                {
                throw;
                }
            }
        }
    while ( fRetry );
}

void
Uploader::AnalyzeResponse(
    CBitsCommandRequest & request,
    DWORD result,
    ResponseTable & table
    )
{
    ResponseEntry * entry = table.Entries;

    LogDl( "HTTP status %d", result );

    while (entry->Fn != NULL)
        {
        if (result == entry->Code)
            {
            (this->*(entry->Fn))( request, result );
            return;
            }

        ++entry;
        }

    (this->*(table.DefaultFn))( request, result );
}

void
Uploader::CreateSession()
{
    CBitsCommandRequest Request( m_UrlInfo.get() );

    Request.AddPacketType( L"Create-Session" );

    Request.AddContentName(  m_file->GetLocalName() );

    Request.AddSupportedProtocols();

    DWORD result = Request.Send();

    AnalyzeResponse( Request, result, CreateSession_ResponseTable );
}

void
Uploader::CreateSession_NewSession(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    // new upload established.
    THROW_HRESULT( request.GetProtocol( &m_data.Protocol ));
    THROW_HRESULT( request.CheckResponseProtocol( &m_data.Protocol ));

    THROW_HRESULT( request.GetSessionId(  &m_data.SessionId ));
    THROW_HRESULT( request.GetHostId( &m_data.HostId ) );
    THROW_HRESULT( request.GetHostIdFallbackTimeout( &m_data.HostIdFallbackTimeout ) );

    if ( m_data.HostId.Size() )
        {
        m_UrlInfo = ContactServer();
        }

    SetState( UPLOAD_STATE_SEND_DATA );
    m_file->SetBytesTransferred( 0 );
}

auto_ptr<URL_INFO>
Uploader::ContactServer()
{
    bool bNeedLock;
    try
        {
        ReleaseWriteLock( bNeedLock );

        //
        // Open the remote file.
        //
        auto_ptr<URL_INFO> UrlInfo;
        UrlInfo = auto_ptr<URL_INFO>( ConnectToUrl( m_file->GetRemoteName(),
                                                    &m_job->QueryProxySettings(),
                                                    m_Credentials,
                                                    m_data.HostId,
                                                    &m_ErrorInfo
                                                    ));
        if (!UrlInfo.get())
            {
            ASSERT( m_ErrorInfo.IsSet());
            THROW_HRESULT( E_FAIL );
            }

        //
        // Ping the server to set up the HTTP connection.
        //
        CBitsCommandRequest Request( UrlInfo.get() );

        Request.AddPacketType( L"Ping" );

        DWORD result = Request.Send();

        if (result != HTTP_STATUS_OK)
            {
            HRESULT hr;
            HRESULT Error;

            hr = Request.GetBitsError( &Error );
            if (hr != S_OK && hr != BG_E_HEADER_NOT_FOUND)
                {
                THROW_HRESULT( hr );
                }

            if (SUCCEEDED( hr ))
                {
                SetResult( m_ErrorInfo, SOURCE_HTTP_SERVER, ERROR_STYLE_HRESULT, Error );
                }
            else
                {
                SetResult( m_ErrorInfo, SOURCE_HTTP_SERVER, ERROR_STYLE_HTTP, result );
                }

            throw ComError( E_FAIL );
            }

        // Update proxy and NIC info.
        //
        THROW_HRESULT( UrlInfo->GetProxyUsage( Request.Query(), &m_ErrorInfo ));
        THROW_HRESULT( m_Network.SetInterfaceIndex( UrlInfo.get()->fProxy ? UrlInfo.get()->ProxyHost.get() : UrlInfo.get()->HostName ));

        ReclaimWriteLock( bNeedLock );
        return UrlInfo;
        }
    catch ( ComError err )
        {
        ReclaimWriteLock( bNeedLock );
        throw;
        }
}

void
Uploader::CreateSession_InProgress(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    // upload already in progress

    SetState( UPLOAD_STATE_SEND_DATA );
    SendData_Success( request, result );
}

class CFileDataReader : public CAbstractDataReader
/*
    SendRequest() uses CAbstractDataReader to read data and rewind if a retry is necessary.
    CFileDataReader is the implementation used by Uploader::SendData().
    It reads from an NT file handle.  The handle must be seekable so that Rewind() works.

*/
{
private:

    HANDLE m_hFile;
    LARGE_INTEGER m_OriginalOffset;
    DWORD m_Length;

public:

    CFileDataReader( HANDLE hFile, UINT64 Offset, DWORD Length )
    : m_hFile( hFile ), m_Length( Length )
    {
        m_OriginalOffset.QuadPart = Offset;
    }

    virtual DWORD GetLength() const
    {
        return m_Length;
    }

    virtual HRESULT Rewind()
    {
        if (!SetFilePointerEx( m_hFile, m_OriginalOffset, NULL, FILE_BEGIN ))
            {
            return HRESULT_FROM_WIN32( GetLastError() );
            }

        return S_OK;
    }

    virtual HRESULT Read(PVOID Buffer, DWORD Length, DWORD * pBytesRead)
    {
        if  (!ReadFile( m_hFile, Buffer, Length, pBytesRead, NULL ))
            {
            DWORD s = GetLastError();
            LogError("ReadFile failed %!winerr!", s);
            return HRESULT_FROM_WIN32( s );
            }

        if (*pBytesRead != Length)
            {
            LogWarning("only read %d bytes of %d", *pBytesRead, Length );
            }

        if (*pBytesRead == 0)
            {
            LogInfo("at EOF");
            return S_FALSE;
            }

        return S_OK;
    }

    virtual bool IsCancelled( DWORD BytesRead )
    {
        if (g_Manager->m_TaskScheduler.PollAbort() ||
            g_Manager->CheckForQuantumTimeout())
            {
            return true;
            }

        return false;
    }
};

void
Uploader::SendData()
{
    //
    // If the block size is zero, we still have to send a packet in two cases:
    // 1. The file has length zero.
    // 2. The file is completely uploaded, but the server app hasn't replied yet.
    //
    if (m_Network.m_BlockSize == 0 &&
        (m_file->_GetBytesTotal() - m_file->_GetBytesTransferred()) > 0)
        {
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_START );
        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_END );
        }
    else
        {
        UINT64 FileOffset = m_file->_GetBytesTransferred();
        UINT64 BodyLength = min( m_Network.m_BlockSize, m_file->_GetBytesTotal() - FileOffset );
        m_ExpectedServerOffset = FileOffset + BodyLength;

        CFileDataReader Reader( m_hFile, FileOffset, BodyLength );
        CBitsCommandRequest Request( m_UrlInfo.get() );

        Request.AddSessionId( m_data.SessionId );
        Request.AddPacketType( L"Fragment" );
        Request.AddContentName( m_file->GetLocalName() );
        Request.AddContentRange( FileOffset, FileOffset + BodyLength-1, m_file->_GetBytesTotal() );

        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_START );

        DWORD result = Request.Send( &Reader );

        m_Network.TakeSnapshot( CNetworkInterface::BLOCK_END );

        AnalyzeResponse( Request, result, SendData_ResponseTable );
        }

    //
    // Allow other apps to use the network for the rest of the time interval,
    // then take the end-of-interval snapshot.
    //
    LogInfo("waiting for end of interval");

    {
    bool bNeedLock;
    try
        {
        ReleaseWriteLock( bNeedLock );

        m_Network.Wait();

        ReclaimWriteLock( bNeedLock );
        }
    catch ( ComError err )
        {
        ReclaimWriteLock( bNeedLock );
        throw;
        }
    }

    HRESULT hr = m_Network.TakeSnapshot( CNetworkInterface::BLOCK_INTERVAL_END );

    if (FAILED(hr))
        {
        if (hr == HRESULT_FROM_WIN32( ERROR_INVALID_DATA ))
            {
            //
            // If the snapshot fails with ERROR_INVALID_DATA and the downloads
            // keep working, then our NIC has been removed and the networking
            // layer has silently transferred our connection to another available
            // NIC.  We need to identify the NIC that we are now using.
            //
            LogWarning("NIC is no longer valid.  Requesting retry.");
            hr = E_RETRY;
            }

        throw ComError( hr );
        }

    UINT64 BytesRemaining = m_file->_GetBytesTotal() - m_file->_GetBytesTransferred();

    m_Network.SetInterfaceSpeed();
    m_Network.CalculateIntervalAndBlockSize( BytesRemaining );
}

void
Uploader::SendData_Success(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    HRESULT hr;
    UINT64 RangeEnd;

    // update our notion of the server's data range

    hr = request.GetServerRange( &RangeEnd );
    if (FAILED(hr))
        {
        if (hr == BG_E_HEADER_NOT_FOUND)
            {
            hr = BG_E_INVALID_SERVER_RESPONSE;
            }

        throw ComError( hr );
        }

    UINT64 Total = m_file->_GetBytesTotal();

    if (RangeEnd > Total)
        {
        throw ComError( BG_E_INVALID_SERVER_RESPONSE );
        }

    //
    // If the received range fails to move forward several times, then the connection is flaky and
    // it begins to look like an error condition.
    //
    if (RangeEnd <= m_file->_GetBytesTransferred())
        {
        if (++m_Restarts >= 3)
            {
            throw ComError( BG_E_NO_PROGRESS );
            }
        }

    m_Callbacks->UploaderProgress( RangeEnd );

    //
    // If the server adjusted the received-range, move the file pointer to match it.
    //
    if (RangeEnd != m_ExpectedServerOffset)
        {
        LARGE_INTEGER Offset;

        Offset.QuadPart = RangeEnd;

        if (!SetFilePointerEx( m_hFile, Offset, NULL, FILE_BEGIN ))
            {
            m_ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, HRESULT_FROM_WIN32( GetLastError() ) );
            ThrowLastError();
            }
        }
    // check for end of data upload

    if (RangeEnd == Total)
        {
        if (m_JobType == BG_JOB_TYPE_UPLOAD_REPLY)
            {
            CAutoString ReplyUrl;

            hr = request.GetReplyUrl( ReplyUrl );

            if (hr == BG_E_HEADER_NOT_FOUND )
                {
                if (result == HTTP_STATUS_RANGE_NOT_SATISFIABLE)
                    {
                    //
                    // If the client didn't see a server ACK, its range may be incorrect
                    // and the server might not send the reply URL.
                    // So send another [zero-length] request.
                    //
                    }
                else
                    {
                    m_job->SetReplyFile( new CFile( m_job,
                                                    BG_JOB_TYPE_DOWNLOAD,
                                                    m_file->GetRemoteName(),
                                                    m_job->QueryReplyFileName()
                                                    ));

                    m_job->QueryReplyFile()->SetBytesTotal( 0 );

                    SetState( UPLOAD_STATE_CLOSE_SESSION );
                    }
                }
            else if (FAILED(hr))
                {
                throw ComError(hr);
                }
            else
                {
                //
                // Impersonate the user while checking file access.
                //
                CNestedImpersonation imp( m_Token );

                StringHandle AbsoluteUrl = CombineUrl( m_file->GetRemoteName(),
                                                       ReplyUrl.get(),
                                                       0 // flags
                                                       );

                m_job->SetReplyFile( new CFile( m_job,
                                                BG_JOB_TYPE_DOWNLOAD,
                                                AbsoluteUrl,
                                                m_job->QueryReplyFileName()
                                                ));

                SetState( UPLOAD_STATE_GET_REPLY );
                }
            }
        else
            {
            SetState( UPLOAD_STATE_CLOSE_SESSION );
            }
        }
}

void
Uploader::SendData_Failure(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    HRESULT hr;
    UINT64 RangeEnd;

    // update our notion of the server's data range

    hr = request.GetServerRange( &RangeEnd );
    if (hr == S_OK)
        {
        UINT64 Total = m_file->_GetBytesTotal();

        if (RangeEnd > Total)
            {
            throw ComError( BG_E_INVALID_SERVER_RESPONSE );
            }

        m_Callbacks->UploaderProgress( RangeEnd );
        }

    HRESULT Error = S_OK;

    hr = request.GetBitsError( &Error );
    if (hr != S_OK && hr != BG_E_HEADER_NOT_FOUND)
        {
        THROW_HRESULT( hr );
        }

    if (SUCCEEDED( hr ))
        {
        //
        // if the server doesn't recognize the session, retry from the beginning.
        // If the server resets us three times, it is probably messed up.  Go into transient error state and retry later.
        //
        if (Error == BG_E_SESSION_NOT_FOUND)
            {
            if (++m_Restarts >= 3)
                {
                throw ComError( BG_E_NO_PROGRESS );
                }

            SetState( UPLOAD_STATE_CREATE_SESSION );
            m_Callbacks->UploaderProgress( 0 );

            LARGE_INTEGER Offset;

            Offset.QuadPart = 0;

            if (!SetFilePointerEx( m_hFile, Offset, NULL, FILE_BEGIN ))
                {
                m_ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, HRESULT_FROM_WIN32( GetLastError() ) );
                ThrowLastError();
                }
            return;
            }
        }

    GenericServerError( request, result );
}

void
Uploader::GetReply()
{
    CFile * file = m_job->QueryReplyFile();

    const PROXY_SETTINGS & ProxySettings = m_job->QueryProxySettings();

    //
    // Make sure the file size is known; neded by the downloader.
    //
    if (file->_GetBytesTotal() == BG_SIZE_UNKNOWN)
        {
        file->DiscoverBytesTotal( m_Token, ProxySettings, m_Credentials, m_ErrorInfo);

        switch (m_ErrorInfo.result)
            {
            case QM_FILE_DONE:            break;
            case QM_FILE_ABORTED:         throw ComError( S_FALSE );

            case QM_SERVER_FILE_CHANGED:  ASSERT( 0 );
            case QM_IN_PROGRESS:          ASSERT( 0 );

            case QM_FILE_TRANSIENT_ERROR: return;
            case QM_FILE_FATAL_ERROR:     return;
            }
        }

    //
    // Download the reply URL.
    //
    file->Transfer( m_Token,
                    m_job->_GetPriority(),
                    ProxySettings,
                    m_Credentials,
                    m_ErrorInfo
                    );

    switch (m_ErrorInfo.result)
        {
        case QM_FILE_DONE:            SetState( UPLOAD_STATE_CLOSE_SESSION ); break;

        case QM_FILE_ABORTED:         throw ComError( S_FALSE );

        case QM_SERVER_FILE_CHANGED:  file->SetBytesTotal( BG_SIZE_UNKNOWN ); break;

        case QM_FILE_TRANSIENT_ERROR: break;
        case QM_FILE_FATAL_ERROR:     break;
        case QM_IN_PROGRESS:          ASSERT( 0 ); break;
        }
}

void
Uploader::CloseSession()
{
    CBitsCommandRequest Request( m_UrlInfo.get() );

    Request.AddSessionId( m_data.SessionId );

    Request.AddPacketType( L"Close-Session" );

    Request.AddContentName( m_file->GetLocalName() );

    DWORD result = Request.Send();

    AnalyzeResponse( Request, result, CloseSession_ResponseTable );
}

void
Uploader::CloseSession_Success(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    SetState( UPLOAD_STATE_CLOSED );
    m_ErrorInfo.result = QM_FILE_DONE;
}

void
Uploader::CloseSession_Failure(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    //
    // If the session was cleaned up, we need to retry.
    // If the server resets us three times, it is probably messed up.  Go into transient error state and retry later.
    //
    HRESULT hr;
    HRESULT Error = S_OK;

    hr = request.GetBitsError( &Error );
    if (hr != S_OK && hr != BG_E_HEADER_NOT_FOUND)
        {
        THROW_HRESULT( hr );
        }

    if (SUCCEEDED( hr ))
        {
        if (Error == BG_E_SESSION_NOT_FOUND)
            {
            if (++m_Restarts >= 3)
                {
                throw ComError( BG_E_NO_PROGRESS );
                }

            SetState( UPLOAD_STATE_CREATE_SESSION );
            m_Callbacks->UploaderProgress( 0 );

            LARGE_INTEGER Offset;

            Offset.QuadPart = 0;

            if (!SetFilePointerEx( m_hFile, Offset, NULL, FILE_BEGIN ))
                {
                m_ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, HRESULT_FROM_WIN32( GetLastError() ) );
                ThrowLastError();
                }
            return;
            }
        }

    if (result >= 500 && result <= 599)
        {
        HRESULT Error = S_OK;

        // temporary server error; retry later
        GenericServerError( request, result );
        return;
        }

    //
    // Either success (100 and 200 series) or a permanent failure (300 and 400 series).
    //
    CloseSession_Success( request, result );
}

void
Uploader::CancelSession()
{
    CBitsCommandRequest Request( m_UrlInfo.get() );

    Request.AddSessionId( m_data.SessionId );

    Request.AddPacketType( L"Cancel-Session" );

    Request.AddContentName( m_file->GetLocalName() );

    DWORD result = Request.Send();

    AnalyzeResponse( Request, result, CancelSession_ResponseTable );
}

void
Uploader::CancelSession_Success(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    SetState( UPLOAD_STATE_CANCELLED );
    m_ErrorInfo.result = QM_FILE_DONE;
}

void
Uploader::CancelSession_Failure(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    if (result >= 500 && result <= 599)
        {
        HRESULT hr;
        HRESULT Error = S_OK;

        hr = request.GetBitsError( &Error );
        if (hr != S_OK && hr != BG_E_HEADER_NOT_FOUND)
            {
            THROW_HRESULT( hr );
            }

        if (SUCCEEDED( hr ))
            {
            if (Error == BG_E_SESSION_NOT_FOUND)
                {
                CancelSession_Success( request, result );
                return;
                }
            }

        // temporary server error; retry later
        GenericServerError( request, result );
        return;
        }

    //
    // Either success (100 and 200 series) or a permanent failure (300 and 400 series).
    //
    CancelSession_Success( request, result );
}

void
Uploader::GenericServerError(
    CBitsCommandRequest & request,
    DWORD result
    )
{
    HRESULT Error;
    HRESULT hr;
    DWORD   context;
    ERROR_SOURCE InternalContext;

    //
    // BITS-Error-Context is optional, defaulting to REMOTE_FILE
    //
    hr = request.GetBitsErrorContext( &context );

    if (hr == BG_E_HEADER_NOT_FOUND)
        {
        context = BG_ERROR_CONTEXT_REMOTE_FILE;
        }
    else if (FAILED(hr))
        {
        throw ComError( hr );
        }

    switch (context)
        {
        case BG_ERROR_CONTEXT_REMOTE_FILE:
            InternalContext = SOURCE_HTTP_SERVER;
            break;

        case BG_ERROR_CONTEXT_REMOTE_APPLICATION:
            InternalContext = SOURCE_HTTP_SERVER_APP;
            break;

        default:
            //
            // Don't understand; map it to something reasonable.
            //
            InternalContext = SOURCE_HTTP_SERVER;
            break;
        }

    //
    // BITS-Error is mandatory.
    //
    hr = request.GetBitsError( &Error );

    if (hr == BG_E_HEADER_NOT_FOUND)
        {
        SetResult( m_ErrorInfo, InternalContext, ERROR_STYLE_HTTP, result );
        return;
        }

    if (FAILED(hr))
        {
        throw ComError( hr );
        }

    SetResult( m_ErrorInfo, InternalContext, ERROR_STYLE_HRESULT, Error );
}

FILE_DOWNLOAD_RESULT
CategorizeError(
    QMErrInfo  & ErrInfo
    )
{
    if ( ErrInfo.Style == ERROR_STYLE_HRESULT )
        {
        switch( LONG(ErrInfo.Code) )
            {
            case S_OK:

                return QM_FILE_DONE;

            case S_FALSE:

                return QM_FILE_ABORTED;

            // These codes indicate dynamic content or
            // an unsupported server so no retries are necessary.
            case BG_E_MISSING_FILE_SIZE:
            case BG_E_INSUFFICIENT_HTTP_SUPPORT:
            case BG_E_INSUFFICIENT_RANGE_SUPPORT:
            case BG_E_INVALID_SERVER_RESPONSE:
            case BG_E_LOCAL_FILE_CHANGED:
            case BG_E_TOO_LARGE:
            case BG_E_CLIENT_SERVER_PROTOCOL_MISMATCH:
            case HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ):
            case HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_ERRORS ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_INVALID_CA ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_CN_INVALID ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_DATE_INVALID ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_REV_FAILED ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_REVOKED ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_CERT_NO_REV ):
            case HRESULT_FROM_WIN32( ERROR_INTERNET_SEC_INVALID_CERT ):

                return QM_FILE_FATAL_ERROR;

            default:

                return QM_FILE_TRANSIENT_ERROR;
            }
        }
    else if (ErrInfo.Style == ERROR_STYLE_HTTP)
        {
        switch ((ErrInfo.Code / 100))
            {
            case 1:
            case 2:

                LogError("HTTP code %u treated as an error", ErrInfo.Code);
                ASSERT( 0 );
                return QM_FILE_TRANSIENT_ERROR;

            case 3:

                return QM_FILE_TRANSIENT_ERROR;

            case 4:

                if (ErrInfo.Code == 408 ||
                    ErrInfo.Code == 409)
                    {
                    return QM_FILE_TRANSIENT_ERROR;
                    }

                return QM_FILE_FATAL_ERROR;

            case 5:
            default:

                if (ErrInfo.Code == 501)
                    {
                    return QM_FILE_FATAL_ERROR;
                    }

                return QM_FILE_TRANSIENT_ERROR;

            }
        }
    else if (ErrInfo.Style == ERROR_STYLE_WIN32)
        {
        switch( ErrInfo.Code )
            {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:

                return QM_FILE_FATAL_ERROR;

            default:

                return QM_FILE_TRANSIENT_ERROR;
            }
        }
    else
        {
        ASSERT( 0 );
        return QM_FILE_TRANSIENT_ERROR;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\newjob\uploader.h ===
class CFile;

enum UPLOAD_STATE
{
    UPLOAD_STATE_CREATE_SESSION,
    UPLOAD_STATE_SEND_DATA,
    UPLOAD_STATE_GET_REPLY,
    UPLOAD_STATE_CLOSE_SESSION,
    UPLOAD_STATE_CLOSED,
    UPLOAD_STATE_CANCEL_SESSION,
    UPLOAD_STATE_CANCELLED
};

struct UPLOAD_DATA
{
    UPLOAD_STATE    State;
    bool            fSchedulable;
    GUID            Protocol;
    StringHandle    SessionId;

    StringHandle    ReplyUrl;

    StringHandle    HostId;
    DWORD           HostIdFallbackTimeout;
    FILETIME        HostIdNoProgressStartTime;

    //---------------------------

    UPLOAD_DATA();
    ~UPLOAD_DATA();

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );

    void SetUploadState( UPLOAD_STATE NewState );
};

class Uploader
/*
    This class handles a particular upload attempt, updating the upload state
    and the job progress data as appropriate.

    It uses the UPLOAD_DATA in a CUploadJob to determine the starting state.
    Then it runs the upload state machine until the job is complete or is interrupted.

*/
{
public:

    Uploader(
        Downloader * dl,
        CNetworkInterface & net,
        CUploadJob * job,
        HANDLE Token,
        ITransferCallback * CallBacks,
        QMErrInfo  & ErrorInfo
        );

    ~Uploader();

    void Transfer();

    bool InTerminalState() { return (m_data.State == UPLOAD_STATE_CLOSED || m_data.State == UPLOAD_STATE_CANCELLED); }

    void SetState( UPLOAD_STATE state ) { m_data.State = state; }

    static void
    SetResult(
        QMErrInfo &  err,
        ERROR_SOURCE source,
        ERROR_STYLE  style,
        DWORD        code,
        char *       comment = 0
        );

private:

    //
    // Uploader objects are created on the stack, so member data must be kept small (under 200 bytes on x86).
    //

    CNetworkInterface & m_Network;
    ITransferCallback * m_Callbacks;
    Downloader        * m_Downloader;
    HANDLE              m_Token;
    CUploadJob *        m_job;
    CFile *             m_file;
    BG_JOB_TYPE         m_JobType;
    UPLOAD_DATA &       m_data;

    auto_ptr<URL_INFO>  m_UrlInfo;

    QMErrInfo &         m_ErrorInfo;

    HANDLE              m_hFile;

    DWORD               m_ExpectedServerOffset;
    long                m_Restarts;

    const CCredentialsContainer  * m_Credentials;

    typedef void (Uploader::* RESPONSE_FN )( CBitsCommandRequest & request, DWORD result );

    struct ResponseEntry
    {
        DWORD           Code;
        RESPONSE_FN     Fn;
    };

#pragma warning( disable:4200 )

    struct ResponseTable
    {
        RESPONSE_FN     DefaultFn;
        ResponseEntry   Entries[];
    };

    static ResponseTable Ping_ResponseTable;
    static ResponseTable CreateSession_ResponseTable;
    static ResponseTable SendData_ResponseTable;
    static ResponseTable CloseSession_ResponseTable;
    static ResponseTable CancelSession_ResponseTable;

#pragma warning( default:4200 )

    //---------------------------------------------------------------------

    auto_ptr<URL_INFO> ContactServer();

    void
    AnalyzeResponse(
        CBitsCommandRequest & request,
        DWORD result,
        ResponseTable & table
        );

    //
    // fns to send data to the server
    //
    void Ping();
    void CreateSession();
    void SendData();
    void GetReply();
    void CloseSession();
    void CancelSession();

    //
    // fns to react to server responses
    //
    void
    Ping_Success(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    CreateSession_NewSession(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    CreateSession_InProgress(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    SendData_Success(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    SendData_Failure(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    CloseSession_Success(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    CloseSession_Failure(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    CancelSession_Success(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    CancelSession_Failure(
        CBitsCommandRequest & request,
        DWORD result
        );

    void
    GenericServerError(
        CBitsCommandRequest & request,
        DWORD result
        );

    //--------------------------------------------------------------------

    void
    ReadReplyData(
        CBitsCommandRequest & request,
        bool fKeep
        );
};


FILE_DOWNLOAD_RESULT
CategorizeError(
    QMErrInfo  & ErrInfo
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\bitsoc\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for ocgen.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION  1

// !!! WARNING !!! Don't change the resource ID, unless you
// also change the corresponding ID in the affected INF files.
// 
#define IDB_ROOT_AUTO_UPDATE                  1001      // DSIE: Bitmap ID for RootAU.INF
#define IDB_ROOT_IE                           1002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\proxy\qmgrproxy.cxx ===
#include "qmgrlib.h"
#include <objbase.h>
#include "qmgr.h"

UpdateNotificationPointer(
    IBackgroundCopyGroup * This,
    REFCLSID clsid
    )
{
    IBackgroundCopyCallback1 * callback = NULL;

    try
        {
        THROW_HRESULT( CoCreateInstance( clsid,
                                         NULL,        // no aggregation
                                         CLSCTX_INPROC,
                                         _uuidof(IBackgroundCopyCallback1),
                                         (LPVOID *) &callback
                                         ));

        THROW_HRESULT( This->SetNotificationPointer( _uuidof(IBackgroundCopyCallback1), callback ));

        callback->Release();

        return S_OK;
        }
    catch( ComError err )
        {
        SafeRelease( callback );

        return err.Error() ;
        }
}


HRESULT
IBackgroundCopyGroup_SetProp_Proxy(
    IBackgroundCopyGroup * This,
    GROUPPROP propID,
    VARIANT *pvarVal
    )
/*
    This is the client-side proxy function that maps from SetProp (a local function)
    to InternalSetProp (a remoted function).

*/
{
    switch (propID)
        {
        case GROUPPROP_NOTIFYCLSID:
            {
            INT     flags;
            CLSID   clsid;
            VARIANT vFlags;

            RETURN_HRESULT( IBackgroundCopyGroup_InternalSetProp_Proxy( This, propID, pvarVal ));
            RETURN_HRESULT( This->GetProp( GROUPPROP_NOTIFYFLAGS, &vFlags ));
            RETURN_HRESULT( CLSIDFromString( pvarVal->bstrVal, &clsid ));

            flags = vFlags.intVal;

            if (clsid != GUID_NULL &&
                0 == (flags & QM_NOTIFY_DISABLE_NOTIFY))
                {
                RETURN_HRESULT( UpdateNotificationPointer( This, clsid ));
                }

            return S_OK;
            }

        case GROUPPROP_NOTIFYFLAGS:
            {
            INT     flags;
            CLSID   clsid;
            VARIANT vClsid;

            RETURN_HRESULT( IBackgroundCopyGroup_InternalSetProp_Proxy( This, propID, pvarVal ));
            RETURN_HRESULT( This->GetProp( GROUPPROP_NOTIFYCLSID, &vClsid ));
            RETURN_HRESULT( CLSIDFromString( vClsid.bstrVal, &clsid ));

            flags = pvarVal->intVal;

            if (clsid != GUID_NULL &&
                0 == (flags & QM_NOTIFY_DISABLE_NOTIFY))
                {
                RETURN_HRESULT( UpdateNotificationPointer( This, clsid ));
                }

            return S_OK;
            }

        default:

            return IBackgroundCopyGroup_InternalSetProp_Proxy( This, propID, pvarVal );
        }

    ASSERT( 0 );
}

HRESULT
IBackgroundCopyGroup_SetProp_Stub(
    IBackgroundCopyGroup * This,
    GROUPPROP propID,
    VARIANT *pvarVal
    )
/*
    This is the server-side stub function that maps from InternalSetProp (a remote function)
    to SetProp (a local function).

*/
{
    return This->SetProp( propID, pvarVal );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\bitsoc\ocgen.cpp ===
/*
 *  Copyright (c) 2001  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Michael Zoran (mzoran) Dec-2001
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OCGEN_CPP_
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include <malloc.h>
#include "ocgen.h"
#pragma hdrstop

// also referred to in ocgen.h        // forward reference

struct BITS_SUBCOMPONENT_DATA
{
   const TCHAR * SubcomponentName;
   const TCHAR * SubcomponentKeyFileName;
   UINT64 FileVersion;
   BOOL Preinstalled;
   BOOL ShouldUpgrade;
};

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc);
DWORD_PTR OnQueryImage();
DWORD OnQuerySelStateChange(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state, UINT flags);
DWORD OnCalcDiskSpace(LPCTSTR ComponentId, LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnQueryState(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state);
DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per);

BOOL  VerifyComponent(LPCTSTR ComponentId);
BOOL  StateInfo(LPCTSTR SubcomponentId, BOOL *state);
DWORD RegisterServers(HINF hinf, LPCTSTR component, DWORD state);
DWORD EnumSections(HINF hinf, const TCHAR *component, const TCHAR *key, DWORD index, INFCONTEXT *pic, TCHAR *name);
DWORD RegisterServices(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD CleanupNetShares(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD RunExternalProgram(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);

BITS_SUBCOMPONENT_DATA* FindSubcomponent( LPCTSTR SubcomponentId );
DWORD InitializeSubcomponentStates( );
DWORD GetFileVersion64( LPCTSTR szFullPath, ULONG64 *pVer );
DWORD GetModuleVersion64( HMODULE hDll, ULONG64 * pVer );

BOOL StopIIS();
BOOL RestartIIS();
BOOL RegBITSSrv();
BOOL UnregBITSSrv();
BOOL SrvFileIsInUse();

// for registering dlls

typedef HRESULT (__stdcall *pfn)(void);

#define KEYWORD_REGSVR       TEXT("RegSvr")
#define KEYWORD_UNREGSVR     TEXT("UnregSvr")
#define KEYWORD_UNINSTALL    TEXT("Uninstall")
#define KEYWORD_SOURCEPATH   TEXT("SourcePath")
#define KEYWORD_DELSHARE     TEXT("DelShare")
#define KEYWORD_ADDSERVICE   TEXT("AddService")
#define KEYWORD_DELSERVICE   TEXT("DelService")
#define KEYWORD_SHARENAME    TEXT("Share")
#define KEYWORD_RUN          TEXT("Run")
#define KEYVAL_SYSTEMSRC     TEXT("SystemSrc")
#define KEYWORD_COMMANDLINE  TEXT("CommandLine")
#define KEYWORD_TICKCOUNT    TEXT("TickCount")

// Services keywords/options
#define KEYWORD_SERVICENAME  TEXT("ServiceName")
#define KEYWORD_DISPLAYNAME  TEXT("DisplayName")
#define KEYWORD_SERVICETYPE  TEXT("ServiceType")
#define KEYWORD_STARTTYPE    TEXT("StartType")
#define KEYWORD_ERRORCONTROL TEXT("ErrorControl")
#define KEYWORD_IMAGEPATH    TEXT("BinaryPathName")
#define KEYWORD_LOADORDER    TEXT("LoadOrderGroup")
#define KEYWORD_DEPENDENCIES TEXT("Dependencies")
#define KEYWORD_STARTNAME    TEXT("ServiceStartName")
#define KEYWORD_PASSWORD     TEXT("Password")

#define KEYVAL_ON            TEXT("on")
#define KEYVAL_OFF           TEXT("off")
#define KEYVAL_DEFAULT       TEXT("default")

const char gszRegisterSvrRoutine[]   = "DllRegisterServer";
const char gszUnregisterSvrRoutine[] = "DllUnregisterServer";
BOOL g_fRebootNeed = FALSE;

BITS_SUBCOMPONENT_DATA g_Subcomponents[] =
{
    {
    TEXT("BITSServerExtensionsManager"),
    TEXT("bitsmgr.dll"),
    0,
    FALSE,
    FALSE
    },

    {
    TEXT("BITSServerExtensionsISAPI"),
    TEXT("bitssrv.dll"),
    0,
    FALSE,
    FALSE
    }
};

const ULONG g_NumberSubcomponents   = 2;
BOOL g_AllSubcomponentsPreinstalled = FALSE;
BOOL g_UpdateNeeded                 = FALSE;
BOOL g_IISStopped                   = FALSE;

PER_COMPONENT_DATA g_Component; 

/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{

    BOOL b;

    UNREFERENCED_PARAMETER(reserved);

    b = true;

    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        ghinst = hinstance;
        loginit();

        // Fall through to process first thread

    case DLL_THREAD_ATTACH:
        b = true;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(b);
}


DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{

    DWORD_PTR rc;

    DebugTraceOCNotification(Function, ComponentId);
    logOCNotification(Function, ComponentId);

    switch(Function)
    {

     case OC_PREINITIALIZE:
#ifdef ANSI
        rc = OCFLAG_ANSI;
#else
        rc = OCFLAG_UNICODE;
#endif
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_SET_LANGUAGE:
        rc = (DWORD_PTR)false;
        break;

    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;

    case OC_REQUEST_PAGES:
        rc = 0;
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(ComponentId, SubcomponentId, (HSPFILEQ)Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        rc = NO_ERROR;
        break;

    case OC_QUERY_STEP_COUNT:
        rc = 2;
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_CLEANUP:
        rc = NO_ERROR;
        break;

    case OC_QUERY_STATE:
        rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    case OC_NEED_MEDIA:
        rc = false;
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(ComponentId,SubcomponentId);
        break;

    case OC_QUERY_SKIP_PAGE:
        rc = false;
        break;

    case OC_WIZARD_CREATED:
        rc = NO_ERROR;
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    DebugTrace(1, TEXT("processing completed"));
    logOCNotificationCompletion();

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/

/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc)
{
    INFCONTEXT context;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

    memset( &g_Component, 0, sizeof( g_Component ) );

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    DWORD dwResult = InitializeSubcomponentStates();
    if ( ERROR_SUCCESS != dwResult )
        return dwResult;

    g_IISStopped = FALSE;

    // store component inf handle

    g_Component.hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                        ? NULL
                        : psc->ComponentInfHandle;

    // open the inf

    if (g_Component.hinf)
        SetupOpenAppendInfFile(NULL, g_Component.hinf,NULL);

    // copy helper routines and flags

    g_Component.HelperRoutines = psc->HelperRoutines;

    g_Component.Flags = psc->SetupData.OperationFlags;

    g_Component.SourcePath = NULL;

    // play

    srand(GetTickCount());

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per)
{

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    memcpy(&g_Component.ExtraRoutines, per, sizeof( g_Component.ExtraRoutines ) );
    g_Component.ExtraRoutines.size = sizeof( g_Component.ExtraRoutines );

    return NO_ERROR;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD_PTR OnQueryImage()
{
    return (DWORD_PTR)LoadBitmap(NULL,MAKEINTRESOURCE(32754));     // OBM_CLOSE
}


/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySelStateChange(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{

    DWORD rc = true;

    if ( !VerifyComponent( ComponentId ) )
        return rc;


    if ( !_tcsicmp( SubcomponentId, TEXT( "BITSServerExtensions" ) ) )
        {

        if ( state )
            {

            if ( flags & OCQ_DEPENDENT_SELECTION )
                {
                rc = false;
                }

            }
        }
    return rc;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD OnCalcDiskSpace(LPCTSTR ComponentId,
                      LPCTSTR SubcomponentId,
                      DWORD addComponent,
                      HDSKSPC dspace)
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    StringCchCopy(section, S_SIZE, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   g_Component.hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        g_Component.hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnQueueFileOps()
 *
 * handler for OC_QUEUE_FILE_OPS
 */

DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!VerifyComponent(ComponentId))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    g_Component.queue = queue;

    if (!StateInfo(SubcomponentId, &state))
        return NO_ERROR;

    StringCchPrintfW(section, 256, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(g_Component.hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }

#if 0

	// removing this since it is redundant

        // also, unregister the dlls and kill services before deletion

        SetupInstallServicesFromInfSection(g_Component.hinf, section, 0);
        SetupInstallFromInfSection(NULL,g_Component.hinf,section,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL);        
#endif
    }

    if (rc) {
        // if uninstalling, don't use version checks
        rc = SetupInstallFilesFromInfSection(g_Component.hinf,
                                             NULL,
                                             queue,
                                             section,
                                             g_Component.SourcePath,
//                                             state ? SP_COPY_NEWER : 0);
                                             0 );
    }

    if (!rc)
        return GetLastError();

    return NO_ERROR;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    INFCONTEXT          context;
    TCHAR               section[256];
    BOOL                state;
    BOOL                rc;
    DWORD               Error = NO_ERROR;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!VerifyComponent(ComponentId))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    // if this is gui mode setup, need to regsvr just in case something
    // changed even if the files are not being replaced.

    if ( !(g_Component.Flags & SETUPOP_STANDALONE) &&
         ( ( _tcsicmp( TEXT("BITSServerExtensionsManager"), SubcomponentId ) == 0 ) ||
           ( _tcsicmp( TEXT("BITSServerExtensionsISAPI"), SubcomponentId ) == 0 ) ) )
        {

        BOOL SettingChanged = StateInfo( SubcomponentId, &state );

        if ( !SettingChanged && !state )
            return NO_ERROR; // if its not installed, leave it uninstalled.

        }

    else if ( !StateInfo( SubcomponentId, &state) )
        return NO_ERROR;

    StringCchPrintfW(section, 256, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(g_Component.hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }
    }

    if (state) { 
        //
        // installation
        //

        if (rc) {

            if ( _tcsicmp( TEXT("BITSServerExtensionsISAPI"), SubcomponentId ) == 0 )
                {

                //
                // Need to register bitssrv.dll from a separate process since
                // registration uses ADSI and ADSI has a bug where it doesn't 
                // load propertly if installed from the same process.
                //

                // process the inf file
                rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                                g_Component.hinf,                    // inf handle
                                                section,                             // name of component
                                                SPINST_ALL & ~SPINST_FILES & ~SPINST_REGSVR,
                                                NULL,                                // relative key root
                                                NULL,                                // source root path
                                                0,                                   // copy flags
                                                NULL,                                // callback routine
                                                NULL,                                // callback routine context
                                                NULL,                                // device info set
                                                NULL);                               // device info struct


                if ( rc )
                    rc = RegBITSSrv();

                if ( rc & g_UpdateNeeded & g_IISStopped )
                    {
                    rc = RestartIIS();
                    g_IISStopped = FALSE;
                    }


                }
            else
                {

                // process the inf file
                rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                                g_Component.hinf,                    // inf handle
                                                section,                             // name of component
                                                SPINST_ALL & ~SPINST_FILES,
                                                NULL,                                // relative key root
                                                NULL,                                // source root path
                                                0,                                   // copy flags
                                                NULL,                                // callback routine
                                                NULL,                                // callback routine context
                                                NULL,                                // device info set
                                                NULL);                               // device info struct

                }
    
            if (rc) {
                rc = SetupInstallServicesFromInfSection(g_Component.hinf, section, 0);
                Error = GetLastError();        
            
                if (!rc && Error == ERROR_SECTION_NOT_FOUND) {
                    rc = TRUE;
                    Error = NO_ERROR;
                }
            
                if (rc) {
                    if (Error == ERROR_SUCCESS_REBOOT_REQUIRED) {
                        g_Component.HelperRoutines.SetReboot(g_Component.HelperRoutines.OcManagerContext,TRUE);
                    }
                    Error = NO_ERROR;
                    rc = RunExternalProgram(&g_Component, section, state);            
                }
            }
        }

    } else { 
        
        //
        // uninstallation
        //
    
        if (rc)
        {

            rc = RunExternalProgram(&g_Component, section, state);

        }
        if (rc) {
            
            rc = CleanupNetShares(&g_Component, section, state);

        }
    }

    if (!rc && (Error == NO_ERROR) ) {
        Error = GetLastError( );
    }

    return Error;
}


/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD OnQueryState(LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    if ( !VerifyComponent( ComponentId ) )
        return SubcompUseOcManagerDefault;

    BITS_SUBCOMPONENT_DATA* SubcomponentData =
        FindSubcomponent( SubcomponentId );

    if ( !SubcomponentData )
        {

        if ( !_tcsicmp( TEXT( "BITSServerExtensions" ), SubcomponentId ) )
            {

            if ( OCSELSTATETYPE_ORIGINAL == state &&
                 g_AllSubcomponentsPreinstalled )
                return SubcompOn;
            else
                return SubcompUseOcManagerDefault;


            }
        else
            return SubcompUseOcManagerDefault;

        }

    if ( OCSELSTATETYPE_ORIGINAL == state )
        {

        return SubcomponentData->Preinstalled ? SubcompOn : SubcompOff;

        }

    return SubcompUseOcManagerDefault;
}

/*
 * OnAboutToCommitQueue()
 *
 * handler for OC_ABOUT_TO_COMMIT_QUEUE
 */

DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!VerifyComponent( ComponentId ))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo( SubcomponentId, &state))
        return NO_ERROR;

    if (state) {

        if ( g_UpdateNeeded &&
             ( _tcsicmp( TEXT("BITSServerExtensionsISAPI"), SubcomponentId ) == 0 ))
            {

            // determine if IIS needs to be stopped.  

            BOOL ISAPIState;
            StateInfo( _T("BITSServerExtensionsISAPI"), &ISAPIState );

            if ( ISAPIState &&
                 SrvFileIsInUse( ) )
                {
                    
                if (!StopIIS())
                    return GetLastError();

                g_IISStopped=TRUE;
                }

            }

        return NO_ERROR;
    }

    // Fetch uninstall section name.
    rc = SetupFindFirstLine(
                    g_Component.hinf,
                    SubcomponentId,
                    KEYWORD_UNINSTALL,
                    &context);

    if (rc) {
        rc = SetupGetStringField(
                     &context,
                     1,
                     section,
                     sizeof(section) / sizeof(TCHAR),
                     NULL);
    }

    if (rc) 
        rc = SetupInstallServicesFromInfSection(g_Component.hinf, section, 0);

    if ( _tcsicmp( TEXT("BITSServerExtensionsISAPI"), SubcomponentId ) == 0 )
        {

        //
        // Unregister BITS from a separate process for consistency with
        // register.  Also, COM has a problem where bitsmgr.dll isn't
        // always unloaded properly after existing virtual directories
        // are disabled.  By running uninstall in a separate process,
        // we forece COM to unload bitsmgr.dll.
        //

        // process the inf file
        if ( rc )
            rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                            g_Component.hinf,                    // inf handle
                                            section,                             // name of component
                                            SPINST_ALL & ~SPINST_FILES & ~SPINST_REGSVR & ~SPINST_UNREGSVR,
                                            NULL,                                // relative key root
                                            NULL,                                // source root path
                                            0,                                   // copy flags
                                            NULL,                                // callback routine
                                            NULL,                                // callback routine context
                                            NULL,                                // device info set
                                            NULL);                               // device info struct


        if ( rc )
            rc = UnregBITSSrv();

        }
    else
        {

        if (rc) {
            rc = SetupInstallFromInfSection(
                        NULL,
                        g_Component.hinf,
                        section,
                        SPINST_ALL & ~SPINST_FILES,
                        NULL,
                        NULL,
                        0,
                        NULL,
                        NULL,
                        NULL,
                        NULL);        

        }


    }
    
    if (rc) {
       SetLastError(NO_ERROR);
    }
    return GetLastError();

}

BOOL VerifyComponent( LPCTSTR ComponentId )
{
    if ( !_tcsicmp( ComponentId, TEXT("BITSServerExtensions") ) )
        return TRUE;
    return FALSE;
}

// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
StateInfo(
    LPCTSTR             SubcomponentId,
    BOOL               *state
    )
{
    BOOL rc = TRUE;

    assert(state);

	// otherwise, check for a change in installation state
		
    *state = g_Component.HelperRoutines.QuerySelectionState(
        g_Component.HelperRoutines.OcManagerContext,
        SubcomponentId,
        OCSELSTATETYPE_CURRENT);

    if (*state == g_Component.HelperRoutines.QuerySelectionState(
        g_Component.HelperRoutines.OcManagerContext,
        SubcomponentId,
        OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

    if ( *state )
        {

        BITS_SUBCOMPONENT_DATA* SubcomponentData = FindSubcomponent( SubcomponentId );

        if ( SubcomponentData && g_UpdateNeeded )
            rc = TRUE;

        }

    return rc;
}

/*
 * EnumSections()
 *
 * finds the name of a section for a specified keyword
 */

DWORD
EnumSections(
    HINF hinf,
    const TCHAR *component,
    const TCHAR *key,
    DWORD index,
    INFCONTEXT *pic,
    TCHAR *name
    )
{
    TCHAR section[S_SIZE];

    if (!SetupFindFirstLine(hinf, component, NULL, pic))
        return 0;

    if (!SetupFindNextMatchLine(pic, key, pic))
        return 0;

    if (index > SetupGetFieldCount(pic))
        return 0;

    if (!SetupGetStringField(pic, index, section, S_SIZE, NULL))
        return 0;

    if (name)
        StringCchCopy(name, S_SIZE, section);

    return SetupFindFirstLine(hinf, section, NULL, pic);
}


DWORD
OcLog(
      LPCTSTR ComponentId,
      UINT level,
      LPCTSTR sz
      )
{
    TCHAR fmt[5000];
    PPER_COMPONENT_DATA cd;

    if (!VerifyComponent( ComponentId ) )
        return NO_ERROR;

    assert(g_Component.ExtraRoutines.LogError);
    assert(level);
    assert(sz);

    StringCchCopy(fmt, 5000, TEXT("%s: %s"));

    return g_Component.ExtraRoutines.LogError(
        g_Component.HelperRoutines.OcManagerContext,
        level,
        fmt,
        ComponentId,
        sz);
}

DWORD
CleanupNetShares(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    if (state) {
        return NO_ERROR;
    } else {
        keyword = KEYWORD_DELSHARE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        NET_API_STATUS netStat;

        CHAR Temp[SBUF_SIZE];
        TCHAR ShareName[ SBUF_SIZE ];

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SHARENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ShareName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

#ifdef UNICODE
        netStat = NetShareDel( NULL, ShareName, 0 );
#else // UNICODE
        WCHAR ShareNameW[ SBUF_SIZE ];
        mbstowcs( ShareNameW, ShareName, lstrlen(ShareName));
        netStat = NetShareDel( NULL, ShareNameW, 0 );
#endif // UNICODE
        if ( netStat != NERR_Success )
        {
            log( TEXT("OCGEN: Failed to remove %s share. Error 0x%08x\r\n"), ShareName, netStat );
            continue;
        }

        log( TEXT("OCGEN: %s share removed successfully.\r\n"), ShareName );
    }

    return TRUE;
}

DWORD
RunExternalProgram(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    keyword = KEYWORD_RUN;

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        TCHAR CommandLine[ SBUF_SIZE ];
        CHAR szTickCount[ SBUF_SIZE ];
        ULONG TickCount;
        BOOL b;
        STARTUPINFO startupinfo;
        PROCESS_INFORMATION process_information;
        DWORD dwErr;

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_COMMANDLINE , &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, CommandLine, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_TICKCOUNT, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        if (!SetupGetStringFieldA(&sic, 1, szTickCount, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        TickCount = atoi( szTickCount );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        b = CreateProcess( NULL,
                           CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_DEFAULT_ERROR_MODE,
                           NULL,
                           NULL,
                           &startupinfo,
                           &process_information );
        if ( !b )
        {
            log( TEXT("OCGEN: failed to spawn %s process.\r\n"), CommandLine );
            continue;
        }

        dwErr = WaitForSingleObject( process_information.hProcess, TickCount * 1000 );
        if ( dwErr != NO_ERROR )
        {
            log( TEXT("OCGEN: WaitForSingleObject() failed. Error 0x%08x\r\n"), dwErr );
            TerminateProcess( process_information.hProcess, -1 );
            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
            continue;
        }

        CloseHandle( process_information.hProcess );
        CloseHandle( process_information.hThread );

        log( TEXT("OCGEN: %s successfully completed within %u seconds.\r\n"), CommandLine, TickCount );
    }

    return TRUE;
}

BITS_SUBCOMPONENT_DATA* 
FindSubcomponent( LPCTSTR SubcomponentId )
{

    for( unsigned int i = 0; i < g_NumberSubcomponents; i++ )
        {

        if ( _tcsicmp( SubcomponentId, g_Subcomponents[i].SubcomponentName ) == 0 )
            return &g_Subcomponents[i];

        }
    return NULL;

}


DWORD 
InitializeSubcomponentStates()
{
    
    // Load this module's version information
    DWORD dwResult;
    ULONG64 ThisModuleVersion;
    BOOL AllSubcomponentsPreinstalled = TRUE;
    BOOL UpdateNeeded                 = FALSE;

    dwResult = GetModuleVersion64( ghinst, &ThisModuleVersion );
    if ( ERROR_SUCCESS != dwResult )
        return dwResult;

    TCHAR SystemDirectory[ MAX_PATH * 2 ];
    GetSystemWindowsDirectory( SystemDirectory, MAX_PATH + 1 );
    StringCchCat( SystemDirectory, MAX_PATH * 2, TEXT("\\System32\\") );

    for( unsigned int i = 0; i < g_NumberSubcomponents; i++ )
        {

        TCHAR FileName[ MAX_PATH * 2 ];
        StringCchCopy( FileName, MAX_PATH * 2, SystemDirectory );
        StringCchCatW( FileName, MAX_PATH * 2, g_Subcomponents[ i ].SubcomponentKeyFileName );

        dwResult = GetFileVersion64( FileName, &g_Subcomponents[ i ].FileVersion );

        // If the file isn't found, skip it
        if ( ERROR_FILE_NOT_FOUND == dwResult ||
             ERROR_PATH_NOT_FOUND == dwResult )
            {
            AllSubcomponentsPreinstalled = FALSE;
            continue;
            }

        if ( dwResult != ERROR_SUCCESS )
            return dwResult;

        g_Subcomponents[ i ].Preinstalled = TRUE;
        g_Subcomponents[ i ].ShouldUpgrade = g_Subcomponents[ i ].FileVersion < ThisModuleVersion;

        if ( g_Subcomponents[i].ShouldUpgrade )
            UpdateNeeded = TRUE;

        }

    g_AllSubcomponentsPreinstalled = AllSubcomponentsPreinstalled;
    g_UpdateNeeded                 = UpdateNeeded;
    return ERROR_SUCCESS;

}

DWORD
GetFileVersion64(
    LPCTSTR      szFullPath,
    ULONG64 *   pVer
    )
{
    DWORD dwHandle;
    DWORD dwLen;

    *pVer = 0;

    //
    // Check to see if the file exists
    //

    DWORD dwAttributes = GetFileAttributes( szFullPath );

    if ( INVALID_FILE_ATTRIBUTES == dwAttributes )
        return GetLastError();

    //
    // Get the file version info size
    //

    if ((dwLen = GetFileVersionInfoSize( (LPTSTR)szFullPath, &dwHandle)) == 0)
        return GetLastError();

    //
    // Allocate enough size to hold version info
    //
    char * VersionInfo = new char[ dwLen ];

    if ( !VersionInfo )
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Get the version info
    //
    if (!GetFileVersionInfo( (LPTSTR)szFullPath, dwHandle, dwLen, VersionInfo ))
        {
        DWORD Error = GetLastError();
        delete[] VersionInfo;
        return Error;
        }

    {

         VS_FIXEDFILEINFO *pvsfi;
         UINT              dwLen2;

         if ( VerQueryValue(
                  VersionInfo,
                  TEXT("\\"),
                  (LPVOID *)&pvsfi,
                  &dwLen2
                  ) )
             {
             *pVer = ( ULONG64(pvsfi->dwFileVersionMS) << 32) | (pvsfi->dwFileVersionLS);
             }

    }

    delete[] VersionInfo;
    return ERROR_SUCCESS;

}

//
// This ungainly typedef seems to have no global definition.  There are several identical
// definitions in the Windows NT sources, each of which has that bizarre bit-stripping
// on szKey.  I got mine from \nt\base\ntsetup\srvpack\update\splib\common.h.
//
typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

DWORD
GetModuleVersion64(
    HMODULE hDll,
    ULONG64 * pVer
    )
{
    DWORD* pdwTranslation;
    VS_FIXEDFILEINFO* pFileInfo;
    UINT uiSize;

    *pVer = 0;

    HRSRC hrsrcVersion = FindResource(
                                hDll,
                                MAKEINTRESOURCE(VS_VERSION_INFO),
                                RT_VERSION);

    if (!hrsrcVersion) 
        return GetLastError();

    HGLOBAL hglobalVersion = LoadResource(hDll, hrsrcVersion);
    if (!hglobalVersion) 
        return GetLastError();

    VERHEAD * pVerHead = (VERHEAD *) LockResource(hglobalVersion);
    if (!pVerHead) 
        return GetLastError();

    // I stole this code from \nt\com\complus\src\shared\util\svcerr.cpp,
    // and the comment is theirs:
    //
    // VerQueryValue will write to the memory, for some reason.
    // Therefore we must make a writable copy of the version
    // resource info before calling that API.
    void *pvVersionInfo = new char[ pVerHead->wTotLen + pVerHead->wTotLen/2 ];

    if ( !pvVersionInfo )
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pvVersionInfo, pVerHead, pVerHead->wTotLen);

    // Retrieve file version info
    if ( VerQueryValue( pvVersionInfo,
                        L"\\",
                        (void**)&pFileInfo,
                        &uiSize) )
        {
        *pVer = (ULONG64(pFileInfo->dwFileVersionMS) << 32) | (pFileInfo->dwFileVersionLS);
        }

    delete[] pvVersionInfo;

    return ERROR_SUCCESS;
}

HRESULT
BITSGetStartupInfo( 
    LPSTARTUPINFOA lpStartupInfo )
{

    __try
    {
        GetStartupInfoA( lpStartupInfo );
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;

}

BOOL
RunProcess(
    const CHAR *Exe,
    const CHAR *CmdLine )
{

    //
    // Restarts IIS by calling "iisreset /stop" at the commandline.
    //

    STARTUPINFOA StartupInfo;

    HRESULT Hr = BITSGetStartupInfo( &StartupInfo );

    if ( FAILED( Hr ) )
        {
        SetLastError( Hr );
        return FALSE;
        }

    PROCESS_INFORMATION ProcessInfo;
    CHAR    sApplicationPath[MAX_PATH];
    CHAR   *pApplicationName = NULL;
    CHAR    sCmdLine[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    DWORD   dwCount;

    dwCount = SearchPathA(NULL,               // Search Path, NULL is PATH
                         Exe,                 // Application
                         NULL,                // Extension (already specified)
                         dwLen,               // Length (char's) of sApplicationPath
                         sApplicationPath,    // Path + Name for application
                         &pApplicationName ); // File part of sApplicationPath

    if (dwCount == 0)
        {
        return FALSE;
        }

    if (dwCount > dwLen)
        {
        SetLastError( ERROR_BUFFER_OVERFLOW );
        return FALSE;
        }

    StringCbCopyA(sCmdLine, MAX_PATH, CmdLine);

    BOOL RetVal = CreateProcessA(
            sApplicationPath,                          // name of executable module
            sCmdLine,                                  // command line string
            NULL,                                      // SD
            NULL,                                      // SD
            FALSE,                                     // handle inheritance option
            CREATE_NO_WINDOW,                          // creation flags
            NULL,                                      // new environment block
            NULL,                                      // current directory name
            &StartupInfo,                              // startup information
            &ProcessInfo                               // process information
        );

    if ( !RetVal )
        return FALSE;

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );

    DWORD Status;
    GetExitCodeProcess( ProcessInfo.hProcess, &Status );

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );

    if ( ERROR_SUCCESS == Status )
        return TRUE;

    SetLastError( Status );
    return FALSE;
}

BOOL
StopIIS()
{

    //
    // Restarts IIS by calling "iisreset /stop" at the commandline.
    //

    return
    RunProcess(
        "iisreset.exe",
        "iisreset /STOP /NOFORCE" );

}

BOOL
RestartIIS()
{

    //
    // Restarts IIS by calling "iisreset /restart" at the commandline.
    //

    return
    RunProcess(
        "iisreset.exe",
        "iisreset /RESTART /NOFORCE" );
}


BOOL
RegBITSSrv()
{
    
    return
    RunProcess(
        "regsvr32.exe",
        "regsvr32 /s bitssrv.dll" );
}

BOOL
UnregBITSSrv()
{
    return
    RunProcess(
        "regsvr32.exe",
        "regsvr32 /u /s bitssrv.dll" );
}

BOOL 
SrvFileIsInUse()
{
    // returns true if bitssrv.dll is in use

    TCHAR FileName[ MAX_PATH * 2 ];
    GetSystemWindowsDirectory( FileName, MAX_PATH + 1 );
    StringCchCat( FileName, MAX_PATH * 2, TEXT("\\System32\\bitssrv.dll") );

    HANDLE hFile =
        CreateFile(
            FileName,
            GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            0,
            NULL );

    if ( INVALID_HANDLE_VALUE == hFile )
        {
        if ( GetLastError() == ERROR_SHARING_VIOLATION )
            return TRUE;
        else 
            return FALSE;
        }

    CloseHandle( hFile );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\bitsoc\ocgen.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OCGEN_H_
 #error "ocgen.h already included!"
#else
 #define _OCGEN_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#include <strsafe.h>

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// unicode version is for NT only.

#ifdef UNICODE
 #define NT
#endif
#ifdef ANSI
 #define WIN95
#endif

// just my preference

#define true    TRUE
#define false   FALSE

// to help root out hard coded strings that don't belong

#define FMT     TEXT

#define NullString(a)   *(a) = TCHAR('\0')

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

#define OCO_COLLECT_NODEPENDENT 0x80000000

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA *Next;
    LPCTSTR ComponentId;
    HINF hinf;
    DWORDLONG Flags;
    LANGID LanguageId;
    TCHAR *SourcePath;
    OCMANAGER_ROUTINES HelperRoutines;
    EXTRA_ROUTINES ExtraRoutines;
    HSPFILEQ queue;
    LONG UnattendedOverride;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif

// from util.cpp

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, LPCTSTR fmt, LPCTSTR caption, UINT type, ... );
DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... );
DWORD TMBox(LPCTSTR fmt, ... );
#define mbox MBox
#define tmbox TMBox
void logOCNotification(DWORD msg, const TCHAR *component);
void logOCNotificationCompletion();
void loginit();
void log(TCHAR *fmt, ...);
BOOL IsNT();

#if defined(__cplusplus)
  extern "C" {
#endif

// from ocgen.cpp

BOOL  ToBeInstalled(TCHAR *component);
BOOL  WasInstalled(TCHAR *component);
DWORD SetupCurrentUser();
DWORD GetMyVersion(DWORD *major, DWORD *minor);
VOID  ReplaceExplorerStartMenuBitmap(VOID);
DWORD OcLog(LPCTSTR ComponentId, UINT level, LPCTSTR sz);

DWORD SysGetDebugLevel();

// from util.cpp

void DebugTraceNL(DWORD level, const TCHAR *text);
void DebugTrace(DWORD level, const TCHAR *text);
void DebugTraceOCNotification(DWORD msg, const TCHAR *component);
void DebugTraceFileCopy(const TCHAR *file);
void DebugTraceFileCopyError();
void DebugTraceDirCopy(const TCHAR *dir);

#if defined(__cplusplus)
  }
#endif

/*-[ global data ]-----------------------------------------*/

#ifndef _OCGEN_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\bitsoc\util.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      util.cpp
 *
 *  Abstract:
 *
 *      This file communicates with  exchange
 *
 *  Author:
 *
 *      Pat Styles (patst) 25-March-1997
 *
 *  Environment:
 *
 *    User Mode
 */

#define _UTIL_CPP_
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <tchar.h>
#include <time.h>
#include "ocgen.h"
#pragma hdrstop

TCHAR glabel[] = TEXT("\n[OCGEN] ");

// for logging

#define gsLogFile           TEXT("%windir%\\ocgen.log")
#define gsLogCompletionMsg  TEXT(" - complete\r\n")
#define gsLogInitMsg        TEXT("\r\n\r\nInitialize setup: OCGEN.DLL %s %s\r\n")

// for trace statements

#define gsTrace             TEXT("OCGEN.DLL: Trace")

typedef enum {

    nPreInit,               // OC_PREINITIALIZE
    nInit,                  // OC_INIT_COMPONENT
    nSetLang,               // OC_SET_LANGUAGE
    nQueryImage,            // OC_QUERY_IMAGE
    nRequestPages,          // OC_REQUEST_PAGES
    nQueryChangeSel,        // OC_QUERY_CHANGE_SEL_STATE
    nCalcSpace,             // OC_CALC_DISK_SPACE
    nQueueFile,             // OC_QUEUE_FILE_OPS
    nQueueNot,              // OC_NOTIFICATION_FROM_QUEUE
    nQueryStep,             // OC_QUERY_STEP_COUNT
    nComplete,              // OC_COMPLETE_INSTALLATION
    nCleanup,               // OC_CLEANUP
    nQueryState,            // OC_QUERY_STATE
    nNeedMedia,             // OC_NEED_MEDIA
    nAboutToCommit,         // OC_ABOUT_TO_COMMIT_QUEUE
    nQuerySkip,             // OC_QUERY_SKIP_PAGE  
    nWizardCreated,         // OC_WIZARD_CREATED
    nExtraRoutines,         // OC_EXTRA_ROUTINES
    nMaximum
} notifications;

typedef struct _OcMsgs {
    DWORD  msg;
    TCHAR *desc;
} OcMsgs;

OcMsgs gMsgs[nMaximum] = {
    {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                TEXT("OC_CLEANUP")},
    {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
    {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
};

TCHAR gUnknown[] = TEXT("Unknown Notification: ");

// determines whether or not to display debug info

DWORD gDebugLevel = (DWORD)-1;

// forward reference

TCHAR *NotificationText(DWORD msg);
BOOL  CheckLevel(DWORD level);

/*
 * DebugTrace()
 */

void DebugTrace(DWORD level, const TCHAR *text)
{
    if (!CheckLevel(level))
        return;

    OutputDebugString(text);
}

/*
 * DebugTraceNL()
 *
 * precedes a trace statement with a newline and id prefix
 */

void DebugTraceNL(DWORD level, const TCHAR *text)
{
    DebugTrace(level, glabel);
    DebugTrace(level, text);
}

/*
 * NotificationText()
 */

TCHAR *NotificationText(DWORD msg)
{
    int i;
    static TCHAR desc[S_SIZE];

    for (i = 0; i < nMaximum; i++)
    {
        if (gMsgs[i].msg == msg)
            return gMsgs[i].desc;
    }

    StringCchPrintf(desc, S_SIZE, TEXT("OC_%d: "), msg);
    return desc;
}

/*
 * DebugTraceOCNotification()
 */

void DebugTraceOCNotification(DWORD msg, const TCHAR *component)
{
    DebugTraceNL(1, NotificationText(msg));
    DebugTrace(1, TEXT(": "));
    DebugTrace(1, component);
    DebugTrace(1, TEXT(" - "));
}

/*
 * DebugTraceFileCopy()
 */

void DebugTraceFileCopy(const TCHAR *file)
{
    DebugTraceNL(5, TEXT("TreeCopy: FILE="));
    DebugTrace(5, file);
}

/*
 * DebugTraceFileCopyError()
 */

void DebugTraceFileCopyError()
{
    TCHAR buf[S_SIZE];
    
    StringCchPrintf(buf, S_SIZE, FMT(" FAILURE CODE:[%d] "), GetLastError());
    DebugTrace(5, buf);
}

/*
 * DebugTraceDirCopy()
 */

void DebugTraceDirCopy(const TCHAR *dir)
{
    DebugTraceNL(3, TEXT("TreeCopy: DIR="));
    DebugTrace(3, dir);
}


/*
 * CheckLevel()
 */

BOOL CheckLevel(DWORD level)
{
    if (gDebugLevel == (DWORD)-1)
        gDebugLevel = SysGetDebugLevel();

    return (gDebugLevel >= level);
}

/*
 * MsgBox
 *
 */

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... )
{
    static BOOL initialize = true;
    static TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(hwnd && textID && type);

    if (initialize)
    {
        len = LoadString(ghinst, IDS_DIALOG_CAPTION, caption, S_SIZE);
        assert(len);
        if (!len) {
            StringCchCopy( caption, S_SIZE, TEXT("Setup"));
        }
        initialize = false;
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        StringCchCopy( format, S_SIZE, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    StringCchVPrintf(text, S_SIZE, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, TCHAR *fmt, TCHAR *caption, UINT type, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(hwnd && text && caption && type);

    va_start(vaList, type);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt && caption);

    va_start(vaList, caption);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, caption, MB_ICONINFORMATION | MB_OK);
}

DWORD TMBox(LPCTSTR fmt, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, gsTrace, MB_ICONINFORMATION | MB_OK);
}

/*
 * SysGetDebugLevel()
 */

DWORD SysGetDebugLevel()
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, 
                     TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), 
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          TEXT("OCGen Debug Level"),
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

/*
 * TCharStringToAnsiString
 */

DWORD TCharStringToAnsiString(TCHAR *tsz ,char *asz)
{
    DWORD count;

    assert(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}

void logOCNotification(DWORD msg, const TCHAR *component)
{
    log(FMT("[%s - %s]"), component, NotificationText(msg));
}

void logOCNotificationCompletion()
{
    log(gsLogCompletionMsg);
}

void loginit()
{
    HANDLE hfile;
    TCHAR  logfile[MAX_PATH];
    char   fmt[S_SIZE];
    char   output[S_SIZE];
    char   time[S_SIZE];
    char   date[S_SIZE];
    DWORD  bytes;

//#ifdef DEBUG
    TCharStringToAnsiString(gsLogInitMsg, fmt);
    _strdate(date);
    _strtime(time);
    StringCchPrintfA(output, S_SIZE, fmt, date, time);

    // open the log file

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void log(TCHAR *fmt, ...)
{
    TCHAR  logfile[MAX_PATH];
    TCHAR  text[S_SIZE];
    char   output[S_SIZE];
    DWORD  bytes;
    HANDLE hfile;

    va_list vaList;

//#ifdef DEBUG
    assert(fmt);

    // create the output string

    va_start(vaList, fmt);
    StringCchVPrintf(text, S_SIZE, fmt, vaList);
    va_end(vaList);

    TCharStringToAnsiString(text, output);

    // create the log file name in the root directory

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    // open the log file

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

BOOL IsNT()
{
    DWORD dwver;

    dwver = GetVersion();

    if (dwver < 0x8000000)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\inc\bitssrvcfg.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bitssrvcfg.h

Abstract:

    Header to define server configuration information.

--*/

#pragma once

#include <iads.h>

#define BITS_COMMAND_VERBW L"BITS_POST"
#define BITS_COMMAND_VERBA "BITS_POST"

#define BITS_GROUP_IDW L"BITSEXTS"
#define BITS_GROUP_IDA "BITSEXTS"

const DWORD METABASE_OPEN_KEY_TIMEOUT           = 10000; // 10 seconds

const DWORD MD_BITS_UPLOAD_ENABLED              = 0; 
const DWORD MD_BITS_CONNECTION_DIR              = 1;
const DWORD MD_BITS_MAX_FILESIZE                = 2;
const DWORD MD_BITS_NO_PROGRESS_TIMEOUT         = 3;
const DWORD MD_BITS_NOTIFICATION_URL_TYPE       = 4;
const DWORD MD_BITS_NOTIFICATION_URL            = 5;
const DWORD MD_BITS_CLEANUP_WORKITEM_KEY        = 6;
const DWORD MD_BITS_HOSTID                      = 7;
const DWORD MD_BITS_HOSTID_FALLBACK_TIMEOUT     = 8;
const DWORD MD_BITS_UPLOAD_METADATA_VERSION     = 9;

#define ALLOW_OVERWRITES 1

#if defined( ALLOW_OVERWRITES )
const DWORD MD_BITS_ALLOW_OVERWRITES            = 10;
#endif

enum BITS_SERVER_NOTIFICATION_TYPE
{
    BITS_NOTIFICATION_TYPE_NONE         = 0,
    BITS_NOTIFICATION_TYPE_POST_BYREF   = 1,
    BITS_NOTIFICATION_TYPE_POST_BYVAL   = 2,
    BITS_NOTIFICATION_TYPE_MAX          = 2
};
                                                                       
const WCHAR * const MD_BITS_UNLIMITED_MAX_FILESIZE                          = L"18446744073709551615";
const CHAR * const MD_BITS_UNLIMITED_MAX_FILESIZEA                          = "18446744073709551615";
const UINT64 MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64                        = 18446744073709551615;
const DWORD MD_BITS_NO_TIMEOUT                                              = 0xFFFFFFFF;

const WCHAR * const MD_DEFAULT_BITS_CONNECTION_DIR                          = L"BITS-Sessions";
const CHAR * const MD_DEFAULT_BITS_CONNECTION_DIRA                          = "BITS-Sessions";
const WCHAR * const MD_DEFAULT_BITS_MAX_FILESIZE                            = MD_BITS_UNLIMITED_MAX_FILESIZE;
const CHAR * const MD_DEFAULT_BITS_MAX_FILESIZEA                            = MD_BITS_UNLIMITED_MAX_FILESIZEA;
const UINT64 MD_DEFAULT_BITS_MAX_FILESIZE_AS_INT64                          = MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64;
const DWORD MD_DEFAULT_NO_PROGESS_TIMEOUT                                   = 60 /*seconds*/ * 60 /* minutes */ * 24 /* hours */ * 14 /* days */;
const BITS_SERVER_NOTIFICATION_TYPE MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE   = BITS_NOTIFICATION_TYPE_NONE;
const WCHAR * const MD_DEFAULT_BITS_NOTIFICATION_URL                        = L"";
const CHAR * const MD_DEFAULT_BITS_NOTIFICATION_URLA                        = "";
const WCHAR * const MD_DEFAULT_BITS_HOSTID                                  = L"";
const CHAR * const MD_DEFAULT_BITS_HOSTIDA                                  = "";
const DWORD MD_DEFAULT_HOSTID_FALLBACK_TIMEOUT                              = 60 /*seconds*/ * 60 /* minutes */ * 24 /* hours */; /* 1 day */

const DWORD CURRENT_UPLOAD_METADATA_VERSION                                 = 1;

#if defined( ALLOW_OVERWRITES )
const bool MD_DEFAULT_BITS_ALLOW_OVERWRITES                                 = false;
#endif

const CHAR RESPONSE_FILE_NAME[]                                             = "responsefile.bin";
const CHAR REQUEST_FILE_NAME[]                                              = "requestfile.bin";
const CHAR REQUESTS_DIR_NAME[]                                              = "Requests";
const WCHAR REQUESTS_DIR_NAMEW[]                                            = L"Requests";
const CHAR REPLIES_DIR_NAME[]                                               = "Replies";
const WCHAR REPLIES_DIR_NAMEW[]                                             = L"Replies";
const CHAR CLEANUP_GUIDS_NAME[]                                             = "CleanupGuids";
const WCHAR STATE_FILE_NAMEW[]                                              = L"statefile";
const CHAR STATE_FILE_NAME[]                                                = "statefile";
const DWORD STATE_FILE_SIZE                                                 = 1024 * 4; // 4 KB

const DWORD STATE_FILE_VERSION                                              = 1;


//
// These ACLs are set by BITS at setup time.
//
// annah: 
// 0x6 is create files/data write + create folders/data append
//
// The inheritance of the ACL from the parent directory will occur if
// the proper API is called. CreateBITSCacheDirectory was updated for that.
//
// Also not that the CO permissions is not as usefull as we would like. CO
// rights are only effective during the object's creation period. (!!!)
// Where needed, we will explicitly add the SID for the owner in the ACL.
//
const WCHAR BITS_SESSIONS_DIR_ACL[]          = L"D:AI(A;;GA;;;CO)(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)(A;OICIIO;0x6;;;WD)";
const WCHAR BITS_CLEANUPGUIDS_DIR_ACL[]      = L"D:AI(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)";
const WCHAR BITS_REQUESTS_DIR_ACL[]          = L"D:AI(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)(A;OICIIO;GA;;;CO)";
const WCHAR BITS_REPLIES_DIR_ACL[]           = L"D:AI(A;OICI;GA;;;BA)(A;OICI;GA;;;SY)(A;OICIIO;GA;;;CO)";
const WCHAR BITS_EXPLICITOWNER_PARTIAL_ACL[] = L"(A;OICI;GA;;;";

const WCHAR BITS_AGENT_NAMEW[] = L"BITSExts 1.5";
const CHAR  BITS_AGENT_NAMEA[] =  "BITSExts 1.5";

const DWORD BITS_MAX_HEADER_SIZE = 4096;

struct PROPERTY_ITEM
{
    WCHAR * PropertyName;
    WCHAR * ClassName;
    WCHAR * Syntax;
    DWORD UserType;
    DWORD PropertyNumber;
};

const PROPERTY_ITEM g_Properties[] =
{
    {
    L"BITSUploadEnabled",
    L"IIsWebVirtualDir",
    L"Boolean",
    IIS_MD_UT_FILE,
    0
    },

    {
    L"BITSSessionDirectory",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    1
    },

    {
    L"BITSMaximumUploadSize",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,    
    2
    },

    {
    L"BITSSessionTimeout",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    3
    },

    {
    L"BITSServerNotificationType",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    4
    },

    {
    L"BITSServerNotificationURL",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    5
    },

    {
    L"BITSCleanupWorkItemKey",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    6
    },

    {
    L"BITSHostId",
    L"IIsWebVirtualDir",
    L"String",
    IIS_MD_UT_FILE,
    7
    },

    {
    L"BITSHostIdFallbackTimeout",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    8
    },

    {
    L"BITSUploadMetadataVersion",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    9
    }

#if defined( ALLOW_OVERWRITES )
,

    {
    L"BITSAllowOverwrites",
    L"IIsWebVirtualDir",
    L"Integer",
    IIS_MD_UT_FILE,
    10
    }
#endif

};

const SIZE_T g_NumberOfProperties = sizeof(g_Properties)/sizeof(*g_Properties);

class PropertyIDManager
{

    DWORD m_PropertyIDs[ g_NumberOfProperties ];
    DWORD m_PropertyUserTypes[ g_NumberOfProperties ];

public:

    PropertyIDManager()
    {
        memset( &m_PropertyIDs, 0, sizeof( m_PropertyIDs ) );
        memset( &m_PropertyUserTypes, 0, sizeof( m_PropertyUserTypes ) );
    }

    HRESULT LoadPropertyInfo( const WCHAR *MachineName = L"LocalHost" );

    DWORD GetPropertyMetabaseID( DWORD PropID )
    {
        return m_PropertyIDs[PropID];
    }

    DWORD GetPropertyUserType( DWORD PropID )
    {
        return m_PropertyUserTypes[PropID];
    }

};

#include "smartptr.h"
typedef SmartRefPointer<IMSAdminBase>   SmartIMSAdminBasePointer;

//
// CSimplePropertyReader
//
// This class is just a 'container' for utility functions related with
// Meta base access that are used both on mmcexts and isapi code.
// These could appear in a library to be shared between both codes,
// but to minimize code churn for a RC2 fix we are using an existing
// .h file that is shared on both codes.
//
// This class will replace original mmcexts code that implemented
// CleanupWorker::ConvertObjectPathToADSI and CleanupWorker::GetPropBSTR.
// That's the reason this class has static methods: so we can use them
// trully as auxiliary functions without requiring object instantiation.
// Another way of doing this would be to create standalone functions,
// But the class wrapping sort of give them a "namespace", which
// is convenient when reading code.
//
class CSimplePropertyReader
{

public:
    static WCHAR *ConvertObjectPathToADSI(const WCHAR *ObjectPath);

    static BSTR   GetADsStringProperty(IADs *MetaObj, BSTR bstrPropName);

    static LPWSTR GetAdmObjStringProperty( 
        SmartIMSAdminBasePointer IISAdminBase, 
        METADATA_HANDLE          MdVDirKey,
        DWORD                    dwMDIdentifier 
    );

};

//
// CAccessRemoteVDir
//
// This class offers methods that implement getting IIS's credentials for
// a virtual directory's UNC path.
// Then, it is able to login and impersonate this user, such that we
// can do filesystem operations in this remote path.
//
class CAccessRemoteVDir
{
    IADs        *m_MetaObj;
    BOOL         m_fIsImpersonated;
    HANDLE       m_hUserToken;

    LPWSTR m_szUNCPath;
    LPWSTR m_szUNCUsername;
    LPWSTR m_szUNCPassword;

public:
    CAccessRemoteVDir();
    ~CAccessRemoteVDir();

    void LoginToUNC(SmartIMSAdminBasePointer IISAdminBase, METADATA_HANDLE MdVDirKey );
    void RevertFromUNCAccount();

    static BOOL IsUNCPath(LPCWSTR szPath);
    static void ImpersonateUNCUser(IN LPCWSTR szUNCPath, IN LPCWSTR szUNCUsername, IN LPCWSTR szUNCPassword, OUT HANDLE *hUserToken);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\inc\smartptr.h ===
/************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name :

    smartptr.h

Abstract :

    This file contains a class for implementing smart ref counted pointers. 

Author :

    Mike Zoran  mzoran   Feb 2002.

Revision History :

  ***********************************************************************/

#if !defined( _BITS_SMARTPTR_H )

#include <strsafe.h>

#define ARRAY_ELEMENTS( array ) ( sizeof( array ) / sizeof( *(array) ) )

class ComError
{

public:
    HRESULT m_Hr;

    ComError( const ComError & Other ) :
        m_Hr( Other.m_Hr )
    {
    }

    ComError( HRESULT Hr ) :
        m_Hr( Hr )
    {
    }
};

inline void THROW_COMERROR( HRESULT Hr )
{
    if ( FAILED( Hr ) )
        throw ComError( Hr );
}

inline void THROW_OUTOFMEMORY_IFNULL( void *p )
{
    if (p == NULL)
        throw ComError( E_OUTOFMEMORY );
}

template<class T> class SmartRefPointer
{
private:
   T * m_Interface;

   void ReleaseIt()
   {
      if ( m_Interface )
         m_Interface->Release();
      m_Interface = NULL;
   }

   void RefIt()
   {
      if ( m_Interface )
          m_Interface->AddRef();
   }

public:

   SmartRefPointer()
   {
      m_Interface = NULL;
   }

   SmartRefPointer( T * RawInterface )
   {
      m_Interface = RawInterface;
      RefIt();
   }

   SmartRefPointer( SmartRefPointer & Other )
   {
      m_Interface = Other.m_Interface;
      RefIt();
   }

   ~SmartRefPointer()
   {
      ReleaseIt();
   }

   T * Get() const
   {
      return m_Interface;
   }

   T * Release()
   {
      T * temp = m_Interface;
      m_Interface = NULL;
      return temp;
   }

   void Clear()
   {
      ReleaseIt();
   }

   T** GetRecvPointer()
   {
      ReleaseIt();
      return &m_Interface;
   }

   SmartRefPointer & operator=( SmartRefPointer & Other )
   {
      ReleaseIt();
      m_Interface = Other.m_Interface;
      RefIt();
      return *this;
   }

   T* operator->() const
   {
      return m_Interface;
   }

   operator const T*() const
   {
      return m_Interface;
   }

   const GUID & GetUUID() const
   {
      return __uuidof( T );
   }
};

typedef SmartRefPointer<IUnknown>       SmartIUnknownPointer;
typedef SmartRefPointer<IDispatch>      SmartIDispatchPointer;

class SmartVariant : public VARIANT
{
public:
    SmartVariant()
    {
        VariantInit( this );
    }
    ~SmartVariant()
    {
        VariantClear( this );
    }
};

class SafeArrayLocker 
{
    SAFEARRAY*  m_Array;
    bool        m_Locked;

public:
    SafeArrayLocker(
        SAFEARRAY*  Array,
        bool        Locked = false ) :
        m_Array( Array ),
        m_Locked( Locked )
    {
    }
    ~SafeArrayLocker()
    {
        Unlock();
    }
    void Lock()
    {
        if ( m_Array && !m_Locked )
            {
            THROW_COMERROR( SafeArrayLock( m_Array ) );
            m_Locked = true;
            }
    }
    void Unlock()
    {
        if ( m_Array && m_Locked )
            {
            THROW_COMERROR( SafeArrayUnlock( m_Array ) );
            m_Locked = false;
            }
    }
};

template<class T>
class MemoryArrayCleaner
{
    T *& m_Pointer;
public:
    MemoryArrayCleaner( T *& Pointer ) :
        m_Pointer( Pointer )
    {
    }
    ~MemoryArrayCleaner()
    {
        delete[] m_Pointer;
        m_Pointer = NULL;
    }
};

class CharStringRoutines
{

public:
    static int strcmp( const char *str1, const char *str2 )
    {
        return ::strcmp( str1, str2 );
    }

    static HRESULT StringCchCopy( char *str1, size_t cchDest, const char *str2 )
    {
        return ::StringCchCopyA( str1, cchDest, str2 );
    }

    static size_t strlen( const char *str )
    {
        return ::strlen( str );
    }

    static void* ConvertToInternal( SIZE_T Pad, const char *String, SIZE_T & Size )
    {
        Size = ::strlen( String );
        char *Ret = new char[ Pad + Size + 1 ];
        ::StringCchCopyA( Ret + Pad, Size + 1, String );
        return (void*)Ret;
    }

    static void* ConvertToInternal( SIZE_T Pad, const WCHAR *String, SIZE_T & Size )
    {

        int Alloc =
            WideCharToMultiByte(
                  CP_THREAD_ACP,            // code page
                  0,                        // performance and mapping flags
                  String,                   // wide-character string
                  -1,                       // number of chars in string
                  NULL,                     // buffer for new string
                  0,                        // size of buffer
                  NULL,                     // default for unmappable chars
                  NULL                      // set when default char used
                  );

        if ( !Alloc )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        char *Ret = new char[ Pad + Alloc ];

        int Actual =
            WideCharToMultiByte(
                  CP_THREAD_ACP,            // code page
                  0,                        // performance and mapping flags
                  String,                   // wide-character string
                  -1,                       // number of chars in string
                  Ret + Pad,                // buffer for new string
                  Alloc,                    // size of buffer
                  NULL,                     // default for unmappable chars
                  NULL                      // set when default char used
                  );

        if ( !Actual )
            {
            HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
            delete[] Ret;
            throw ComError( Hr );
            }

        Size = Actual - 1;
        return Ret;

    }
};

class WCHARStringRoutines
{

public:
   static int strcmp( const WCHAR *str1, const WCHAR *str2 )
   {
       return ::wcscmp( str1, str2 );
   }

   static HRESULT StringCchCopy( WCHAR *str1, size_t cchDest, const WCHAR *str2 )
   {
       return ::StringCchCopyW( str1, cchDest, str2 );
   }

   static size_t strlen( const wchar_t *str )
   {
       return ::wcslen( str );
   }

   static void* ConvertToInternal( SIZE_T Pad, const WCHAR *String, SIZE_T & Size )
   {
       Size = ::wcslen( String );
       char *Ret = new char[ Pad + ( ( Size + 1 ) * sizeof(WCHAR) ) ];
       ::StringCchCopyW( (WCHAR*)(Ret + Pad), Size + 1, String );
       return (void*)Ret;
   }

   static void* ConvertToInternal( SIZE_T Pad, const char *String, SIZE_T & Size )
   {

        int Alloc =
            MultiByteToWideChar(
                CP_THREAD_ACP,         // code page
                0,                     // character-type options
                String,                // string to map
                -1,                    // number of bytes in string
                NULL,                  // wide-character buffer
                0                      // size of buffer
            );

        if ( !Alloc )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        char *Ret = new char[ Pad + ( Alloc * sizeof(WCHAR) ) ];

        int Actual =
            MultiByteToWideChar(
                CP_THREAD_ACP,         // code page
                0,                     // character-type options
                String,                // string to map
                -1,                    // number of bytes in string
                (WCHAR*)( Ret + Pad ), // wide-character buffer
                Alloc                  // size of buffer
            );

        if ( !Actual )
            {
            HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
            delete[] Ret;
            throw ComError( Hr );
            }

        Size = Actual - 1;
        return Ret;

   }
};

template<class T, class CONV>
class StringHandleTemplate : private CONV
{

    struct StringData
    {
        SIZE_T          m_Count;
        long            m_Refs;
    };

    struct EmptyStringData
    {
        StringData      m_StringData;
        T               m_Data;
    };

    static EmptyStringData s_EmptyString;

    StringData *m_Value;

    void NewString( const char *String, bool ReplaceExisting = false );
    void NewString( const WCHAR *String, bool ReplaceExisting = false );

    StringData * RefIt() const
    {
        InterlockedIncrement( &m_Value->m_Refs );
        return m_Value;
    }

    void FreeIt()
    {
        if ( m_Value->m_Refs && InterlockedDecrement( &m_Value->m_Refs ) == 0 )
            {
            delete [] m_Value;
            m_Value = NULL;
            }
    }

    // Create String by concating 2 strings
    StringHandleTemplate( const StringData *LeftValue, const T *RightValue, SIZE_T RightSize );


public:

    StringHandleTemplate()
    {
        NewString( (T*)NULL );
    }

    StringHandleTemplate( const char *String )
    {
        NewString( String );
    }

    StringHandleTemplate( const WCHAR *String )
    {
        NewString( String );
    }


    StringHandleTemplate( const StringHandleTemplate & Other ) :
        m_Value( Other.RefIt() )
    {
    }

    ~StringHandleTemplate()
    {
        FreeIt();
    }

    void SetStringSize()
    {
        m_Value->m_Count = strlen( (T*)(m_Value + 1) );
    }

    T *AllocBuffer( SIZE_T Size );

    StringHandleTemplate & operator=( const StringHandleTemplate & r )
    {
        FreeIt();
        m_Value = r.RefIt();
        return *this;
    }

    StringHandleTemplate & operator=( const T * r )
    {
        NewString( r, true );
        return *this;
    }

    SIZE_T Size() const
    {
        return m_Value->m_Count;
    }

    operator const T*() const
    {
        return (const T*)(m_Value + 1);
    }

    bool operator <( const StringHandleTemplate & r ) const
    {
        if ( m_Value == r.m_Value)
            return false;
        return (strcmp( (const T*)*this, (const T*)r ) < 0);
    }

    StringHandleTemplate operator+( const StringHandleTemplate & r ) const
    {
        return StringHandleTemplate( m_Value, (T*)(r.m_Value+1), r.m_Value->m_Count );
    }

    StringHandleTemplate operator+( const T * p ) const
    {
        static const T EmptyChar = '\0';

        if ( !p )
            return StringHandleTemplate( m_Value, &EmptyChar, 0 );

        return StringHandleTemplate( m_Value, p, strlen(p) );
    }
    StringHandleTemplate & operator+=( const StringHandleTemplate & r )
    {
        return (*this = (*this + r ) );
    }
    StringHandleTemplate & operator+=( const T * p )
    {
        return (*this = (*this + p ) );
    }
};

template<class T,class CONV>
void
StringHandleTemplate<T,CONV>::NewString( const char *String, bool ReplaceExisting )
{
   if ( !String )
       {
       
       InterlockedIncrement( &s_EmptyString.m_StringData.m_Refs );
       StringData* Value = (StringData*)&s_EmptyString;
       
       if ( ReplaceExisting )
           FreeIt();
       
       m_Value = Value;
       return;
       
       }

   SIZE_T Size;
   StringData* Value = (StringData*)ConvertToInternal( sizeof(StringData), String, Size );
   Value->m_Count = Size;
   Value->m_Refs  = 1;

   if ( ReplaceExisting )
       FreeIt();

   m_Value = Value;

}

template<class T,class CONV>
void
StringHandleTemplate<T,CONV>::NewString( const WCHAR *String, bool ReplaceExisting )
{
   
   if ( !String )
       {
       InterlockedIncrement( &s_EmptyString.m_StringData.m_Refs );
       StringData* Value = (StringData*)&s_EmptyString;

       if ( ReplaceExisting )
           FreeIt();
       
       m_Value = Value;
       return;
       }

   SIZE_T Size;
   StringData* Value = (StringData*)ConvertToInternal( sizeof(StringData), String, Size );
   Value->m_Count = Size;
   Value->m_Refs  = 1;

   if ( ReplaceExisting )
       FreeIt();

   m_Value = Value;

}


// Create String by concating 2 strings
template<class T,class CONV>
StringHandleTemplate<T,CONV>::StringHandleTemplate( const StringData *LeftValue, const T *RightValue, SIZE_T RightSize )
{
   SIZE_T Size = LeftValue->m_Count + RightSize;
   m_Value = (StringData*)new char[ sizeof(StringData) + (Size*sizeof(T)) + sizeof(T) ];
   m_Value->m_Count = Size;
   m_Value->m_Refs  = 1;
   
   T *DestData = (T*)( m_Value + 1 );
   memcpy( DestData, (T*)(LeftValue + 1), sizeof(T) * LeftValue->m_Count );
   memcpy( DestData + LeftValue->m_Count, RightValue, sizeof( T ) * RightSize );
   DestData[ Size ] = 0;
}


template<class T,class CONV>
T *
StringHandleTemplate<T,CONV>::AllocBuffer( SIZE_T Size )
{
    StringData *Data = (StringData*)new T[sizeof(StringData)+(Size*sizeof(T))+sizeof(T)];
    Data->m_Count   = 0;
    Data->m_Refs    = 1;
    T *String = (T*)(Data + 1);
    String[0] = '\0';

    FreeIt(); // Free old string
    m_Value = Data;

    // Whoever fills in the string needs to call SetStringSize
    return String;

}

template<class T,class CONV>
typename StringHandleTemplate<T,CONV>::EmptyStringData StringHandleTemplate<T,CONV>::s_EmptyString =
    {
        0, 1, L'\0'            // Initialize with 1 ref so it is never deleted
    };

typedef StringHandleTemplate<char, CharStringRoutines> StringHandleA;
typedef StringHandleTemplate<WCHAR, WCHARStringRoutines> StringHandleW;

#define _BITS_SMARTPTR_H 
#endif //_BITS_SMARTPTR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\config.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    config.cpp

Abstract:

    This file implements metabase access routines for virtual directories.

--*/

#include "precomp.h"

StringHandle
VDirConfig::GetFullPath( StringHandle Path )
{
    StringHandle ParsedPath;
    CHAR *FilePart = NULL;
    DWORD BufferLength = MAX_PATH;

    while( 1 )
        {
            
        CHAR *PathBuffer = ParsedPath.AllocBuffer( BufferLength );

        DWORD Result =
            GetFullPathName(
                Path,
                BufferLength,
                PathBuffer,
                &FilePart );

        if ( Result > BufferLength )
            {
            BufferLength = Result;
            continue;
            }

        if ( !Result )
            {
            Log( LOG_ERROR, "Unable to get the full path name for %s, error 0x%8.8X",
                 (const char*)Path, HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
            }

	ParsedPath.SetStringSize();
        break;

        }

	return ParsedPath;
}

VDirConfig::VDirConfig( 
    StringHandle Path, 
    SmartMetabasePointer AdminBase
    ) :
    m_Refs(1)
{

    //
    // Read in all the metabase configuration for the virtual directory.
    //

    HRESULT Hr;
    METADATA_HANDLE MdVDirKey   = NULL;
    GetSystemTimeAsFileTime( &m_LastLookup );
        
    try
    {
        
        m_Path = Path;

        StringHandleW UnicodePath = Path;

        Hr = AdminBase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            (const WCHAR*)UnicodePath,
            METADATA_PERMISSION_READ,
            METABASE_OPEN_KEY_TIMEOUT,
            &MdVDirKey );


        if ( FAILED(Hr) )
            throw ServerException( Hr );

        m_PhysicalPath =
            GetMetaDataString(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                MD_VR_PATH,
                "" );

        m_PhysicalPath = GetFullPath( m_PhysicalPath );

        DWORD UploadEnabled =
            GetMetaDataDWORD(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED ),
                0);

        m_UploadEnabled = UploadEnabled ? true : false;

        m_ConnectionsDir =
            GetMetaDataString(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR ),
                MD_DEFAULT_BITS_CONNECTION_DIRA );
        
        m_SessionDir    = m_PhysicalPath + StringHandle( "\\" ) + m_ConnectionsDir;
        m_RequestsDir   = m_SessionDir + StringHandle( "\\" ) + StringHandle( REQUESTS_DIR_NAME );
        m_RepliesDir    = m_SessionDir + StringHandle( "\\" ) + StringHandle( REPLIES_DIR_NAME );

        m_NoProgressTimeout =
            GetMetaDataDWORD(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_NO_PROGRESS_TIMEOUT ),
                MD_DEFAULT_NO_PROGESS_TIMEOUT );

        StringHandle MaxFilesizeString =
            GetMetaDataString(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_MAX_FILESIZE ),
                MD_DEFAULT_BITS_MAX_FILESIZEA );

        if ( MaxFilesizeString.Size() == 0 )
            {
            m_MaxFileSize = 0xFFFFFFFFFFFFFFFF;
            }
        else
            {
            UINT64 MaxFileSize;
            int ScanRet = sscanf( (const char*)MaxFilesizeString, "%I64u", &MaxFileSize );

            if ( 1 != ScanRet )
                throw ServerException( E_INVALIDARG );

            m_MaxFileSize = MaxFileSize;
            }

        DWORD NotificationType =
            GetMetaDataDWORD(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL_TYPE ),
                MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE );

        if ( NotificationType > BITS_NOTIFICATION_TYPE_MAX )
            throw ServerException( E_INVALIDARG );

        m_NotificationType = (BITS_SERVER_NOTIFICATION_TYPE)NotificationType;


        m_NotificationURL =
            GetMetaDataString(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL ),
                MD_DEFAULT_BITS_NOTIFICATION_URLA );


        m_HostId =
            GetMetaDataString(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID ),
                MD_DEFAULT_BITS_HOSTIDA );

        m_HostIdFallbackTimeout =
            GetMetaDataDWORD(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID_FALLBACK_TIMEOUT ),
                MD_DEFAULT_HOSTID_FALLBACK_TIMEOUT );

        m_ExecutePermissions =
            GetMetaDataDWORD(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                MD_ACCESS_PERM,
                MD_ACCESS_READ );

#if defined( ALLOW_OVERWRITES )

        m_AllowOverwrites =
            !!GetMetaDataDWORD(
                AdminBase.Get(),
                MdVDirKey,
                NULL,
                g_PropertyMan->GetPropertyMetabaseID( MD_BITS_ALLOW_OVERWRITES ),
                MD_DEFAULT_BITS_ALLOW_OVERWRITES );

#else
      
        m_AllowOverwrites = false;

#endif

        AdminBase->CloseKey( MdVDirKey );

    }
    catch( const ComError & )
    {
        if ( MdVDirKey )
            AdminBase->CloseKey( MdVDirKey );
        throw;
    }

}

ConfigurationManager::ConfigurationManager()
{

    bool CSInitialize = false;
    
    memset( m_PathCacheEntries, 0, sizeof( m_PathCacheEntries ) );
    memset( m_MapCacheEntries, 0, sizeof( m_MapCacheEntries ) );

    HRESULT Hr =
        CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED(Hr) )
        throw ServerException( Hr );

    try
    {
        if ( !InitializeCriticalSectionAndSpinCount( &m_CacheCS, 0x80000100 ) )
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

        CSInitialize = true;

        Hr =
            CoCreateInstance(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                __uuidof( IMSAdminBase ),
                (LPVOID*)m_IISAdminBase.GetRecvPointer() );

        if ( FAILED(Hr) )
            throw ServerException( Hr );

        Hr = m_IISAdminBase->GetSystemChangeNumber( &m_ChangeNumber );

        if ( FAILED(Hr))
            throw ServerException( Hr );

        CoUninitialize();
            
    }
    catch( const ComError & )
    {
        if ( CSInitialize )
            DeleteCriticalSection( &m_CacheCS );
        CoUninitialize();
        throw;
    }

}

ConfigurationManager::~ConfigurationManager()
{
    FlushCache();
    DeleteCriticalSection( &m_CacheCS );

}

void
ConfigurationManager::FlushCache()
{

    for( unsigned int i = 0; i < PATH_CACHE_ENTRIES; i++ )
        {
        if ( m_PathCacheEntries[i] )
            m_PathCacheEntries[i].Clear();
        }
    for( unsigned int i = 0; i < MAP_CACHE_ENTRIES; i++ )
        {
        delete m_MapCacheEntries[i];
        m_MapCacheEntries[i] = NULL;
        }

}

SmartVDirConfig        
ConfigurationManager::Lookup( 
    StringHandle Path )
{

    for( unsigned int i=0; i < PATH_CACHE_ENTRIES; i++ )
        {

        if ( m_PathCacheEntries[i] )
            {

            if ( _stricmp( (const char*)m_PathCacheEntries[i]->m_Path, (const char*)Path) == 0 )
                {
                SmartVDirConfig ReturnVal = m_PathCacheEntries[i];
                GetSystemTimeAsFileTime( &ReturnVal->m_LastLookup );
                return ReturnVal;
                }
            }
        }

    return SmartVDirConfig();
}

void  
ConfigurationManager::Insert( 
    SmartVDirConfig NewConfig )
{

    //
    // Insert a new virtual directory configuration into the 
    // virtual directory cache.  Expire an old entry if needed.
    //

    int BestSlot = 0;
    FILETIME WorstTime;
    memset( &WorstTime, 0xFF, sizeof( WorstTime ) );

    for( unsigned int i=0; i < PATH_CACHE_ENTRIES; i++ )
        {

        if ( !m_PathCacheEntries[i] )
            {
            BestSlot = i;
            break;
            }
        else if ( CompareFileTime( &m_PathCacheEntries[i]->m_LastLookup, &WorstTime  ) < 0 )
            {
            WorstTime = m_PathCacheEntries[i]->m_LastLookup;
            BestSlot = i;
            }

        }

    m_PathCacheEntries[BestSlot] = NewConfig;

}

SmartVDirConfig
ConfigurationManager::Lookup( 
    StringHandle InstanceMetabasePath,
    StringHandle URL,
    DWORD *pURLDepth )
{

    //
    // Find the virtual directories configuration in the cache.
    //

    for( unsigned int i=0; i < MAP_CACHE_ENTRIES; i++ )
        {

        MapCacheEntry* CacheEntry = m_MapCacheEntries[i]; 

        if ( CacheEntry )
            {

            if ( ( _stricmp( (const char*)CacheEntry->m_InstanceMetabasePath, 
                             (const char*)InstanceMetabasePath) == 0 ) &&
                 ( _stricmp( (const char*)CacheEntry->m_URL,
                             (const char*)URL ) == 0 ) )
                {

                GetSystemTimeAsFileTime( &CacheEntry->m_LastLookup );
                *pURLDepth = CacheEntry->m_URLDepth;
                return CacheEntry->m_Config;
                }
            }
        }

    return SmartVDirConfig();

}

SmartVDirConfig
ConfigurationManager::GetVDirConfig(
    StringHandle Path )
{

    SmartVDirConfig Config = Lookup( Path );

    if ( !Config.Get() )
        {
        *Config.GetRecvPointer() = new VDirConfig( Path, m_IISAdminBase );
        Insert( Config );
        }

    return Config;

}


SmartVDirConfig         
ConfigurationManager::Insert( 
    StringHandle InstanceMetabasePath, 
    StringHandle URL, 
    StringHandle Path,
    DWORD URLDepth )
{

    SmartVDirConfig Config = GetVDirConfig( Path );

    MapCacheEntry* CacheEntry = 
        new MapCacheEntry(
            InstanceMetabasePath,
            URL,
            Config,
            URLDepth );


    int BestSlot = 0;
    FILETIME WorstTime;
    memset( &WorstTime, 0xFF, sizeof( WorstTime ) );

    for( unsigned int i=0; i < MAP_CACHE_ENTRIES; i++ )
        {

        if ( !m_MapCacheEntries[i] )
            {
            BestSlot = i;
            break;
            }
        else if ( CompareFileTime( &m_MapCacheEntries[i]->m_LastLookup, &WorstTime  ) < 0 )
            {
            WorstTime = m_MapCacheEntries[i]->m_LastLookup;
            BestSlot = i;
            }

        }

    if ( m_MapCacheEntries[BestSlot] )
        delete m_MapCacheEntries[BestSlot];

    m_MapCacheEntries[BestSlot] = CacheEntry;
    return Config;    

}

StringHandle        
ConfigurationManager::GetVDirPath( 
    StringHandle InstanceMetabasePath, 
    StringHandle URL,
    DWORD *pURLDepth )
{


    //
    // Find the virtual directory that coresponds to the URL.  
    // Do this by matching the URL up with the metabase keys.  Keep
    // pruning off the URL untill the longest metabase path is found
    // that is a virtual directory.
    //


    StringHandleW InstanceMetabasePathW = InstanceMetabasePath;
    StringHandleW URLW                  = URL;
    WCHAR *Path                         = NULL;
    METADATA_HANDLE MdVDirKey           = NULL;
    *pURLDepth                          = 0;

    try
    {
        
        WCHAR *PathEnd      = NULL;
        WCHAR *CurrentEnd   = NULL;
        WCHAR RootString[]  = L"/Root";

        SIZE_T InstancePathSize = InstanceMetabasePathW.Size();
        SIZE_T URLSize          = URLW.Size();
        SIZE_T RootStringSize   = ( sizeof( RootString ) / sizeof( *RootString ) ) - 1;

        Path = new WCHAR[ InstancePathSize + URLSize + RootStringSize + 1 ];
        memcpy( Path, (const WCHAR*)InstanceMetabasePathW, InstancePathSize * sizeof( WCHAR ) );
        
        PathEnd = Path + InstancePathSize;
        memcpy( PathEnd, RootString, RootStringSize * sizeof( WCHAR ) );
        memcpy( PathEnd + RootStringSize, (const WCHAR*)URLW, ( URLSize + 1 )* sizeof( WCHAR ) );

        CurrentEnd = PathEnd + RootStringSize + URLSize;

        while( 1 )
            {

            HRESULT Hr =
                m_IISAdminBase->OpenKey(
                    METADATA_MASTER_ROOT_HANDLE,    //metabase handle.
                    Path,                           //path to the key, relative to hMDHandle.
                    METADATA_PERMISSION_READ,       //specifies read and write permissions.
                    METABASE_OPEN_KEY_TIMEOUT,      //the time, in milliseconds, before the method times out.
                    &MdVDirKey                      //receives the handle to the opened key.
                    );

            if ( SUCCEEDED( Hr ) )
                {
                
                // 
                // Check if this is a virtual directory
                // 

                WCHAR NodeName[ 255 ];
                DWORD RequiredDataLen;
                METADATA_RECORD MDRecord;
                MDRecord.dwMDIdentifier     = MD_KEY_TYPE;
                MDRecord.dwMDAttributes     = METADATA_NO_ATTRIBUTES;
                MDRecord.dwMDUserType       = IIS_MD_UT_SERVER;
                MDRecord.dwMDDataType       = STRING_METADATA;
                MDRecord.dwMDDataLen        = sizeof( NodeName );
                MDRecord.pbMDData           = (unsigned char*)NodeName;
                MDRecord.dwMDDataTag        = 0;
                    
                Hr = m_IISAdminBase->GetData(
                    MdVDirKey,
                    NULL,
                    &MDRecord,
                    &RequiredDataLen );

                if ( FAILED(Hr) && ( Hr != MD_ERROR_DATA_NOT_FOUND ) &&
                     ( Hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) )
                    throw ServerException( Hr );


                if ( SUCCEEDED( Hr ) && wcscmp( L"IIsWebVirtualDir", NodeName ) == 0 )
                    {

                    // Found the path, so return the data
                    StringHandle VDirPath = Path;
                    delete[] Path;
                    m_IISAdminBase->CloseKey( MdVDirKey );

                    return VDirPath;

                    }

                }

            else if ( Hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) 
                {
                throw ServerException( Hr );
                }

                
            //
            // If this is the end of the URL, then nothing else can be done
            //

            if ( CurrentEnd == PathEnd )
                throw ServerException( E_INVALIDARG );

            m_IISAdminBase->CloseKey( MdVDirKey );
            MdVDirKey = NULL;

            // Chop off the rightmost subpart
            while( CurrentEnd != PathEnd && *CurrentEnd != L'/' &&
                   *CurrentEnd != L'\\' )
                CurrentEnd--;

            if ( *CurrentEnd == L'/' || *CurrentEnd == L'\\' )
                *CurrentEnd = L'\0';

            (*pURLDepth)++;

            // Attempt another round
            
            }

    }
    catch( const ComError & )
    {
        delete[] Path;

        if ( MdVDirKey )
            m_IISAdminBase->CloseKey( MdVDirKey );

        throw;

    }
}


bool
ConfigurationManager::HandleCacheConsistency()
{

    //
    // Handle cache consistency.  This is done my calling IIS to check the change number.
    // If the current change number is different then the change number for the last lookup,
    // then flush the cache.
    // 

    DWORD ChangeNumber;
    HRESULT Hr = m_IISAdminBase->GetSystemChangeNumber( &ChangeNumber );
    if ( FAILED(Hr) )
        {
        throw ServerException( Hr );
        }

    if ( ChangeNumber == m_ChangeNumber )
        return true; // cache is consistent

    FlushCache();
	m_ChangeNumber = ChangeNumber;
    return false; // cache was flushed.
    
}

SmartVDirConfig 
ConfigurationManager::GetConfig2( 
    StringHandle InstanceMetabasePath, 
    StringHandle URL,
    DWORD *      pURLDepth )
{

    //
    // Toplevel function to do everything to lookup the configuration to use for an URL.
    //

    METADATA_HANDLE MdVDirKey   = NULL;
    SmartVDirConfig Config;

    HANDLE ImpersonationToken   = NULL;
    bool DidRevertToSelf        = false;

    try
    {

        EnterCriticalSection( &m_CacheCS );

        if ( HandleCacheConsistency() )
            {

            // The cache was consistent.  Chances are good
            // that the lookup will succeed

            Config = Lookup( InstanceMetabasePath, URL, pURLDepth );

            if ( Config.Get() )
                {
                LeaveCriticalSection( &m_CacheCS );
                return Config;
                }

            }

        StringHandle Path = GetVDirPath( InstanceMetabasePath, URL, pURLDepth );

        Config = Insert( InstanceMetabasePath, URL, Path, *pURLDepth );

        LeaveCriticalSection( &m_CacheCS );
        return Config;

    }
    catch( const ComError & )
    {
        if ( MdVDirKey )
            m_IISAdminBase->CloseKey( MdVDirKey );

        LeaveCriticalSection( &m_CacheCS );

        throw;
    }
}

SmartVDirConfig
ConfigurationManager::GetConfig(
    StringHandle InstanceMetabasePath,
    StringHandle URL,
    DWORD *      pURLDepth )
{

    bool DidRevertToSelf = false;
    bool ComInitialized = false;

    HANDLE ImpersonationToken = NULL;
    SmartVDirConfig ReturnVal; 

    HRESULT Hr =
        CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( FAILED(Hr) )
        throw ServerException( Hr );

    ComInitialized = true;

    try
    {

        // Need to revert to the system process
        // to address the metabase

        if ( !OpenThreadToken(
                GetCurrentThread(),
                TOKEN_ALL_ACCESS,
                TRUE,
                &ImpersonationToken ) )
            {
            DWORD dwError = GetLastError();

            if (dwError != ERROR_NO_TOKEN)
                throw ServerException( HRESULT_FROM_WIN32( dwError ) );
            }
        else
            {
            if ( !RevertToSelf() )
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

            DidRevertToSelf = true;
            }

        ReturnVal =
            GetConfig2(
                InstanceMetabasePath,
                URL,
                pURLDepth );

		if ( DidRevertToSelf ) 
            {
            BITSSetCurrentThreadToken( ImpersonationToken );
            }

        if ( ImpersonationToken )
            CloseHandle( ImpersonationToken );

        CoUninitialize();

        return ReturnVal;

    }
    catch( ComError & )
    {
		if ( DidRevertToSelf )
            BITSSetCurrentThreadToken( ImpersonationToken );

        if ( ImpersonationToken )
            CloseHandle( ImpersonationToken );

        throw;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\inc\bitssrvcfgimp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    bitssrvcfgimp.h

Abstract:

    Implementation header to define server configuration information.

--*/


HRESULT PropertyIDManager::LoadPropertyInfo( const WCHAR * MachineName )
{
    
    bool ComLoaded;
    HRESULT Hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

    if ( RPC_E_CHANGED_MODE == Hr )
        ComLoaded = false;
    else if ( FAILED(Hr) )
        return Hr;
    else
        ComLoaded = true;

    BSTR MetaIDBSTR         = NULL;
    BSTR UserTypeBSTR       = NULL;
    WCHAR *PathBuffer       = NULL;
    SIZE_T PathBufferSize   = 0;

    MetaIDBSTR      = SysAllocString( L"MetaId" );
    UserTypeBSTR    = SysAllocString( L"UserType" );

    if ( !MetaIDBSTR || !UserTypeBSTR)
        {
        Hr = E_OUTOFMEMORY;
        goto exit;
        }

    PathBuffer = (WCHAR*)HeapAlloc( GetProcessHeap(), 0, 1024 );

    if ( !PathBuffer )
        {
        Hr = E_OUTOFMEMORY;
        goto exit;
        }

    PathBufferSize          = 1024;

    for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
        {

        WCHAR SchemaPrefix[] = L"IIS://";
        WCHAR SchemaPath[]   = L"/Schema/";
        
        SIZE_T SchemaPrefixSize = ( sizeof( SchemaPrefix ) / sizeof( WCHAR ) ) - 1;
        SIZE_T SchemaPathSize   = ( sizeof( SchemaPath ) / sizeof( WCHAR ) ) - 1;
        SIZE_T MachineNameSize  = wcslen( MachineName );
        SIZE_T PropertyNameSize = wcslen( g_Properties[i].PropertyName );

        SIZE_T PathSize = SchemaPrefixSize + SchemaPathSize +
                          MachineNameSize + PropertyNameSize + 1;
        
        if ( PathBufferSize < ( PathSize * sizeof( WCHAR ) ) )
            {
            WCHAR *NewBuffer = 
                (WCHAR*)HeapReAlloc(
                    GetProcessHeap(),
                    0,
                    PathBuffer,
                    PathSize * sizeof( WCHAR ) );

            if ( !NewBuffer )
                {
                Hr = E_OUTOFMEMORY;
                goto exit;
                }

            PathBuffer      = NewBuffer;
            PathBufferSize  = PathSize * sizeof( WCHAR );

            }

        // build schema path

        WCHAR *ObjectPath = PathBuffer;
        {
            WCHAR *TempPointer = ObjectPath;

            memcpy( TempPointer, SchemaPrefix, SchemaPrefixSize * sizeof( WCHAR ) );
            TempPointer += SchemaPrefixSize;
            memcpy( TempPointer, MachineName, MachineNameSize * sizeof( WCHAR ) );
            TempPointer += MachineNameSize;
            memcpy( TempPointer, SchemaPath, SchemaPathSize * sizeof( WCHAR ) );
            TempPointer += SchemaPathSize;
            memcpy( TempPointer, g_Properties[i].PropertyName, ( PropertyNameSize + 1 ) * sizeof( WCHAR ) );
        }

        // Open the object
        IADs *MbObject = NULL;

        Hr = ADsGetObject( 
            ObjectPath,
            __uuidof( *MbObject ),
            reinterpret_cast<void**>( &MbObject ) );

        if ( FAILED( Hr ) )
            {
#if defined( ALLOW_OVERWRITES )
            // workaround for IIS issue.  IIS isn't handling schema extension property.  Dream up a ID.
            
            if ( E_ADS_UNKNOWN_OBJECT == Hr && 
                 MD_BITS_ALLOW_OVERWRITES == i )
                {
                m_PropertyIDs[i]        = m_PropertyIDs[ i - 1] + 1;
                m_PropertyUserTypes[i]  = m_PropertyUserTypes[ i - 1 ];
                continue;
                }
            else
#endif
                goto exit;

            }

        VARIANT var;
        VariantInit( &var );

        Hr = MbObject->Get( MetaIDBSTR, &var );

        if ( FAILED(Hr ) )
            {
            MbObject->Release();
            goto exit;
            }

        Hr = VariantChangeType( &var, &var, 0, VT_UI4 );

        if ( FAILED(Hr ) )
            {
            MbObject->Release();
            VariantClear( &var );
            goto exit;
            }

        m_PropertyIDs[i] = var.ulVal;

        VariantClear( &var );

        Hr = MbObject->Get( UserTypeBSTR, &var );

        if ( FAILED( Hr ) )
            {
            MbObject->Release();
            goto exit;
            }

        Hr = VariantChangeType( &var, &var, 0, VT_UI4 );

        if ( FAILED( Hr ) )
            {
            MbObject->Release();
            VariantClear( &var );
            goto exit;
            }

        m_PropertyUserTypes[i] = var.ulVal;

        VariantClear( &var );

        MbObject->Release();
        

        }
    Hr = S_OK;

exit:

    SysFreeString( MetaIDBSTR );
    SysFreeString( UserTypeBSTR );

    if ( ComLoaded )
        CoUninitialize();
    
    if ( PathBuffer )
        {
        HeapFree( GetProcessHeap(), 0, PathBuffer );
        PathBuffer      = 0;
        PathBufferSize  = 0;
        }

    return Hr;

}

// ================================================================================================
// Auxiliary functions that access the IIS Metabase
// ================================================================================================


LPWSTR
CSimplePropertyReader::ConvertObjectPathToADSI( 
    LPCWSTR szObjectPath )
{
    WCHAR *szReturnPath      = NULL;
    SIZE_T ReturnPathSize   = 0;

    if ( _wcsnicmp( L"IIS://", szObjectPath, wcslen( L"IIS://") ) == 0 )
        {
        // already have an adsi path
        ReturnPathSize  = wcslen( szObjectPath ) + 1;
        szReturnPath      = new WCHAR[ ReturnPathSize ];

        THROW_OUTOFMEMORY_IFNULL( szReturnPath );

        memcpy( szReturnPath, szObjectPath, ReturnPathSize * sizeof( WCHAR ) );
        }
    else if ( _wcsnicmp( L"/LM/", szObjectPath, wcslen( L"/LM/" ) ) == 0 )
        {
        //metabase path to local machine
        ReturnPathSize  = wcslen( szObjectPath ) + wcslen( L"IIS://LocalHost/" ) + 1;
        szReturnPath      = new WCHAR[ ReturnPathSize  ];

        THROW_OUTOFMEMORY_IFNULL( szReturnPath );

        StringCchCopyW( szReturnPath, ReturnPathSize, L"IIS://LocalHost/" );
        StringCchCatW( szReturnPath, ReturnPathSize, szObjectPath + wcslen( L"/LM/" ) );
        }
    else if ( _wcsnicmp( L"LM/", szObjectPath, wcslen( L"LM/" ) ) == 0 )
        {
        //metabase path to local machine
        ReturnPathSize  = wcslen( szObjectPath ) + wcslen( L"IIS://LocalHost/" ) + 1;
        szReturnPath      = new WCHAR[ ReturnPathSize ];

        THROW_OUTOFMEMORY_IFNULL( szReturnPath );

        StringCchCopyW( szReturnPath, ReturnPathSize, L"IIS://LocalHost/" );
        StringCchCatW( szReturnPath, ReturnPathSize, szObjectPath + wcslen( L"LM/" ) );
        }
    else 
        {
        //metabase path to another server
        ReturnPathSize  = wcslen( szObjectPath ) + wcslen( L"IIS://" ) + 1;
        szReturnPath      = new WCHAR[ ReturnPathSize ];

        THROW_OUTOFMEMORY_IFNULL( szReturnPath );

        if ( '/' == szObjectPath[0] )
            StringCchCopyW( szReturnPath, ReturnPathSize, L"IIS:/" );
        else
            StringCchCopyW( szReturnPath, ReturnPathSize, L"IIS://" );

        StringCchCatW( szReturnPath, ReturnPathSize, (WCHAR*)szObjectPath );

        }

    // check for a trailing \ character
    SIZE_T StringLength = wcslen( szReturnPath );
    if ( StringLength >= 1 )
        {

        if ( L'\\' == szReturnPath[ StringLength - 1 ] || 
             L'/' == szReturnPath[ StringLength - 1 ] )
            {
            szReturnPath[ StringLength - 1 ] = L'\0';
            }
        
        }

    return szReturnPath;
}


BSTR CSimplePropertyReader::GetADsStringProperty( IADs *MetaObj, BSTR bstrPropName)
{

  BSTR    bstrRetval;
  VARIANT vt;

  THROW_COMERROR( MetaObj->Get( bstrPropName, &vt ) );
  THROW_COMERROR( VariantChangeType( &vt, &vt, 0, VT_BSTR ) );

  bstrRetval = vt.bstrVal;
  vt.bstrVal = NULL;

  VariantClear( &vt );

  return bstrRetval;
}

LPWSTR CSimplePropertyReader::GetAdmObjStringProperty(
    SmartIMSAdminBasePointer    IISAdminBase,
    METADATA_HANDLE             MdVDirKey,
    DWORD                       dwMDIdentifier )
{
    METADATA_RECORD     MdRecord;
    DWORD               dwBytesRequired = 0;
    WCHAR              *szBuffer        = NULL;

    try
    {
        memset( &MdRecord, 0, sizeof( MdRecord ) );

        MdRecord.dwMDIdentifier = dwMDIdentifier;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDDataType   = STRING_METADATA;
        MdRecord.dwMDDataLen    = 0;
        MdRecord.pbMDData       = NULL;

        HRESULT hr = 
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &dwBytesRequired );

        if (hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ))
            throw ComError( hr );

        szBuffer = reinterpret_cast<WCHAR *>(new BYTE[ dwBytesRequired ]);
        THROW_OUTOFMEMORY_IFNULL(szBuffer);

        memset( szBuffer, 0, dwBytesRequired );

        MdRecord.dwMDDataLen    = dwBytesRequired;
        MdRecord.pbMDData       = (PBYTE)szBuffer;

        THROW_COMERROR(  
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &dwBytesRequired ) );
    }
    catch( ComError Error )
    {
        // just forward the error
        throw;
    }

    return szBuffer;
}



CAccessRemoteVDir::CAccessRemoteVDir() :
    m_MetaObj(NULL),
    m_fIsImpersonated(FALSE),
    m_hUserToken(INVALID_HANDLE_VALUE),
    m_szUNCPath(NULL),
    m_szUNCUsername(NULL),
    m_szUNCPassword(NULL)
{
}

CAccessRemoteVDir::~CAccessRemoteVDir()
{
    //
    // Free the user token obtained when/if LogonUser() was called
    //
    if (m_hUserToken != INVALID_HANDLE_VALUE)
        {
        CloseHandle( m_hUserToken );
        m_hUserToken = INVALID_HANDLE_VALUE;
        }

    //
    // If CAccessRemoteVDir::RevertFromUNCAccount() wasn't called before
    // the destructor was called, then make sure we revert the impersonation.
    // Is advised the the code that is using this class explicity call
    // RevertFromUNCAccount(), however. This test is a safe guard in case
    // the call is not made.
    // 
    if (m_fIsImpersonated)
        {
        RevertToSelf();
        }

    //
    // Free variables used when using the IIS AdmObj to access the meta store.
    // All the m_szUNC* variables assume memory was allocated by calling 
    // CSimplePropertyReader::GetAdmObjStringProperty(), which allocated a buffer
    // by calling "new BYTE[ ...]"
    //
    if (m_szUNCPath)
        {
        delete [] reinterpret_cast<BYTE*>(m_szUNCPath);
        m_szUNCPath = NULL;
        }

    if (m_szUNCUsername)
        {
        delete [] reinterpret_cast<BYTE*>(m_szUNCUsername);
        m_szUNCUsername = NULL;
        }

    if (m_szUNCPassword)
        {
        delete [] reinterpret_cast<BYTE*>(m_szUNCPassword);
        m_szUNCPassword = NULL;
        }
}

void
CAccessRemoteVDir::RevertFromUNCAccount()
{
    // revert to previous security setting
    if (m_fIsImpersonated)
        {
        if (!RevertToSelf())
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        m_fIsImpersonated = FALSE;
        }


    if (m_hUserToken != INVALID_HANDLE_VALUE)
        {
        // revert to previous security setting
        CloseHandle( m_hUserToken );
        m_hUserToken = INVALID_HANDLE_VALUE;
        }
}

inline BOOL
CAccessRemoteVDir::IsUNCPath(LPCWSTR szPath)
{
    if ( szPath && szPath[0] == L'\\' && szPath[1] == L'\\' )
        {
        return TRUE;
        }

    return FALSE;
}

void
CAccessRemoteVDir::LoginToUNC( 
    SmartIMSAdminBasePointer    IISAdminBase,
    METADATA_HANDLE             MdVDirKey )
{
    try
    {
        m_szUNCPath = CSimplePropertyReader::GetAdmObjStringProperty(IISAdminBase, MdVDirKey, MD_VR_PATH);

        //
        // Don't logon if the path isn't a UNC path
        //
        if (!IsUNCPath(m_szUNCPath))
            {
            // this class destructor will free m_szUNCPath;
            return;
            }

        m_szUNCUsername = CSimplePropertyReader::GetAdmObjStringProperty(IISAdminBase, MdVDirKey, MD_VR_USERNAME);
        m_szUNCPassword = CSimplePropertyReader::GetAdmObjStringProperty(IISAdminBase, MdVDirKey, MD_VR_PASSWORD);

        ImpersonateUNCUser(m_szUNCPath, m_szUNCUsername, m_szUNCPassword, &m_hUserToken);
        m_fIsImpersonated = TRUE;
    }
    catch( ComError Error )
    {
        // just forward the error
        throw;
    }
}

void
CAccessRemoteVDir::ImpersonateUNCUser(IN LPCWSTR szUNCPath, IN LPCWSTR szUNCUsername, IN LPCWSTR szUNCPassword, OUT HANDLE *hUserToken)
{
    *hUserToken = INVALID_HANDLE_VALUE;

    // make sure we are not getting unexpected data
    if (!szUNCUsername || !szUNCPassword || szUNCUsername[0] == L'\0')
        {
        throw ComError( HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) );
        }

    // crack the user name into a user and domain
    WCHAR *szUserName     = (WCHAR*)szUNCUsername;
    WCHAR *szDomainName   = NULL;

    WCHAR *p = szUserName;
    while(*p != L'\0')
    {
        if(*p == L'\\')
        {
            *p = L'\0';
            p++;
            //
            // first part is domain
            // second is user.
            //
            szDomainName  = szUserName;
            szUserName    = p;
            break;
        }
        p++;
    }

    if ( !LogonUserW(
            szUserName,
            szDomainName,
            (WCHAR*)szUNCPassword,
            LOGON32_LOGON_BATCH,
            LOGON32_PROVIDER_DEFAULT,
            hUserToken ) )
        {

        if ( GetLastError() == ERROR_LOGON_TYPE_NOT_GRANTED )
            {


            if ( !LogonUserW(
                    szUserName,
                    szDomainName,
                    (WCHAR*)szUNCPassword,
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    hUserToken ) )
                {

                // LogonUser() may touch the handle
                // make sure we don't think we have a valid handle
                *hUserToken = INVALID_HANDLE_VALUE;

                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
                }

             }
        else
            {
            *hUserToken = INVALID_HANDLE_VALUE;

            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        }


    if ( !ImpersonateLoggedOnUser( *hUserToken ) )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\log.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    log.cpp

Abstract:

    This file implements the BITS server extensions logging

--*/

#include "precomp.h"
#include "sddl.h"

#define ARRAYSIZE(x)   (sizeof((x))/sizeof((x)[0]))

const DWORD g_LogLineSize = 160;
typedef char LOG_LINE_TYPE[g_LogLineSize];

CRITICAL_SECTION g_LogCs;

bool g_LogFileEnabled       = false;
#ifdef DEBUG
bool g_LogDebuggerEnabled   = true;
#else
bool g_LogDebuggerEnabled   = false;
#endif
bool g_fPerProcessLog       = false;

UINT32 g_LogFlags = DEFAULT_LOG_FLAGS; 
HANDLE g_LogFile = INVALID_HANDLE_VALUE;
HANDLE g_LogFileMapping = NULL;

const DWORD LOG_FILENAME_LEN = MAX_PATH*2;
char g_LogDefaultFileName[ LOG_FILENAME_LEN ];
char g_LogRegistryFileName[ LOG_FILENAME_LEN ];

char          *g_LogFileName    = NULL;
char          g_LogBuffer[512];
UINT64        g_LogSlots        = (DEFAULT_LOG_SIZE * 1000000 ) / g_LogLineSize;
DWORD         g_LogSequence     = 0;
UINT64        g_LogCurrentSlot  = 1;
LOG_LINE_TYPE *g_LogFileBase    = NULL;

// Allow access to local system, administrators, creator/owner
const char g_LogBaseSecurityString[]    = "D:P(A;;GA;;;SY)(A;;GA;;;BA)(A;;GA;;;CO)";
const char g_LogPartialSecurityString[] = "(A;;GA;;;";

LPSTR 
GetCurrentThreadSidString()
{
    HANDLE hToken       = NULL;
    LPBYTE pTokenUser   = NULL;
    DWORD  dwReqSize    = 0;
    PSID   pUserSid     = NULL;
    DWORD  dwError      = ERROR_SUCCESS;
    LPSTR  pszSidString = NULL;

    try
    {
        //
        // Open the thread token.
        //
        if ( !OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
            {
            dwError = GetLastError();

            if ( dwError == ERROR_NO_TOKEN )
                {
                //
                // This thread is not impersonated and has no SID.
                // Try to open process token instead
                //
                if ( !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken) )
                    {
                    dwError = GetLastError();
                    throw ComError( HRESULT_FROM_WIN32( dwError ) );
                    }
                }
            else
                {
                throw ComError( HRESULT_FROM_WIN32( dwError ) );
                }
            }

        //
        // Get the user's SID.
        //
        if ( !GetTokenInformation(hToken,
                                  TokenUser,
                                  NULL,
                                  0,
                                  &dwReqSize) )
            {
            dwError = GetLastError();

            if ( dwError != ERROR_INSUFFICIENT_BUFFER )
                {
                throw ComError( HRESULT_FROM_WIN32( dwError ) );
                }

            dwError = ERROR_SUCCESS;
            }

        pTokenUser = new BYTE[ dwReqSize ];

        if ( !GetTokenInformation(hToken,
                                  TokenUser,
                                  (LPVOID)pTokenUser,
                                  dwReqSize,
                                  &dwReqSize) )
            {
            dwError = GetLastError();
            throw ComError( HRESULT_FROM_WIN32( dwError ) );
            }

        if (pTokenUser)
            {
            pUserSid = (reinterpret_cast<TOKEN_USER *>(pTokenUser))->User.Sid;
            }

        if ( !IsValidSid(pUserSid) )
            {
            throw ComError( HRESULT_FROM_WIN32( ERROR_INVALID_SID ) );
            }

        if ( !ConvertSidToStringSid(pUserSid, &pszSidString) )
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }
    }
    catch ( ComError Error )
    {
        if ( hToken )
            {
            CloseHandle(hToken);
            hToken = NULL;
            }

        if ( pTokenUser )
            {
            delete [] pTokenUser;
            pTokenUser = NULL;
            }

        throw;
    }

    if ( hToken )
        {
        CloseHandle(hToken);
        hToken = NULL;
        }

    if ( pTokenUser )
        {
        delete [] pTokenUser;
        pTokenUser = NULL;
        }

    //
    //  caller has to free this memory by calling 
    //  LocalFree(static_cast<HLOCAL>(pszSidString));
    //
    return pszSidString;
} 

LPSTR
AddAclForCurrentUser(LPCSTR szBaseAcl, LPCSTR szUserPartialAclPrefix)
{
    LPCSTR szUserPartialAclSuffix = ")"; 
    LPSTR  szFullAcl  = NULL;
    DWORD  cchFullAcl = 0;
    LPSTR  pszUserSID = NULL;

    try
    {
        pszUserSID = GetCurrentThreadSidString();
        cchFullAcl = strlen(szBaseAcl) + strlen(szUserPartialAclPrefix) + strlen(pszUserSID) + strlen(szUserPartialAclSuffix) + 1;

        // ATT: this buffer is being allocated and it should be freed by the caller
        szFullAcl  = new CHAR[ cchFullAcl ];

        StringCchPrintf(szFullAcl, cchFullAcl, "%s%s%s%s", szBaseAcl, szUserPartialAclPrefix, pszUserSID, szUserPartialAclSuffix);
    }
    catch( ComError Error )
    {
        //
        // Free the String SID obtained by calling ConvertSidToStringSid()
        //
        if (pszUserSID)
            {
            LocalFree(reinterpret_cast<HLOCAL>(pszUserSID));
            pszUserSID = NULL;
            }

        throw;
    }

    //
    // Free the String SID obtained by calling ConvertSidToStringSid()
    //
    if (pszUserSID)
        {
        LocalFree(reinterpret_cast<HLOCAL>(pszUserSID));
        pszUserSID = NULL;
        }

    //
    // this string should be freed by the caller
    // by calling delete [] szFullAcl
    //
    return szFullAcl;
}


void OpenLogFile()
{
    bool  NewFile = false;
    LPSTR szSDDLString = NULL;

    {
		SECURITY_ATTRIBUTES  SecurityAttributes;
        PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

        try
        {
            //
            // We get into the trouble of adding the thread's impersonation sid because on IIS6
            // the w3wp.exe process can run with arbitrary identities. The default is to launch
            // the process using the Network Services account.
            //
            // So we will be granting log file access to Administrators, Local System and whom
            // ever is impersonating the host process when the isapi is loaded. Note that
            // if the account used for these process is changed after the file is first created,
            // the isapi might lose the right to open the log, if the new user is not part of
            // the administrator's group. 
            //
            szSDDLString = AddAclForCurrentUser(g_LogBaseSecurityString, g_LogPartialSecurityString);
        }
        catch ( ComError Error )
        {
            // bail out -- we will have no logging
            return;
        }

        if (!ConvertStringSecurityDescriptorToSecurityDescriptor(
                szSDDLString,
                SDDL_REVISION_1,
                &pSecurityDescriptor,
                NULL ) )
            return;

		SecurityAttributes.nLength              = sizeof( SECURITY_ATTRIBUTES );
		SecurityAttributes.lpSecurityDescriptor = pSecurityDescriptor;
		SecurityAttributes.bInheritHandle       = FALSE;

        g_LogFile =
            CreateFile(
                g_LogFileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                &SecurityAttributes,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

        LocalFree( (HLOCAL)pSecurityDescriptor );


        if ( INVALID_HANDLE_VALUE == g_LogFile )
            return;

    }

    SetFilePointer( g_LogFile, 0, NULL, FILE_BEGIN );

    LOG_LINE_TYPE FirstLine;
    DWORD dwBytesRead = 0;

    if (!ReadFile( g_LogFile,
              FirstLine,
              g_LogLineSize,
              &dwBytesRead,
              NULL ) )
        goto fatalerror;

    DWORD LineSize;
    UINT64 LogSlots;
    if ( dwBytesRead != g_LogLineSize ||
         4 != sscanf( FirstLine, "# %u %I64u %u %I64u", &LineSize, &LogSlots, &g_LogSequence, &g_LogCurrentSlot ) ||
         LineSize != g_LogLineSize ||
         LogSlots != g_LogSlots )
        {
        
        NewFile = true;

        g_LogSequence       = 0;
        g_LogCurrentSlot    = 1;

        if ( INVALID_SET_FILE_POINTER == SetFilePointer( g_LogFile, (DWORD)g_LogSlots * g_LogLineSize, NULL, FILE_BEGIN ) )
            goto fatalerror;

        if ( !SetEndOfFile( g_LogFile ) )
            goto fatalerror;

        SetFilePointer( g_LogFile, 0, NULL, FILE_BEGIN );

        }

    g_LogFileMapping =
        CreateFileMapping(
            g_LogFile,
            NULL,
            PAGE_READWRITE,
            0,
            0,
            NULL );
    

    if ( !g_LogFileMapping )
        goto fatalerror;

    g_LogFileBase = (LOG_LINE_TYPE *)
        MapViewOfFile(
             g_LogFileMapping,              // handle to file-mapping object
             FILE_MAP_WRITE | FILE_MAP_READ,// access mode
             0,                             // high-order DWORD of offset
             0,                             // low-order DWORD of offset
             0                              // number of bytes to map
           );


    if ( !g_LogFileBase )
        goto fatalerror;

    if ( NewFile )
        {

        LOG_LINE_TYPE FillTemplate;
        memset( FillTemplate, ' ', sizeof( FillTemplate ) );
        StringCchPrintfA( 
            FillTemplate,
            g_LogLineSize,
            "# %u %I64u %u %I64u", 
            g_LogLineSize, 
            g_LogSlots, 
            g_LogSequence, 
            g_LogCurrentSlot ); 
        FillTemplate[ g_LogLineSize - 2 ] = '\r';
        FillTemplate[ g_LogLineSize - 1 ] = '\n';
        memcpy( g_LogFileBase, FillTemplate, sizeof( FillTemplate ) );


        memset( FillTemplate, '9', sizeof( FillTemplate ) );
        FillTemplate[ g_LogLineSize - 2 ] = '\r';
        FillTemplate[ g_LogLineSize - 1 ] = '\n';

        for( SIZE_T i=1; i < g_LogSlots; i++ )
            memcpy( g_LogFileBase + i, FillTemplate, sizeof( FillTemplate ) );

        }

    g_LogFileEnabled = true;
    return;

fatalerror:

    if ( g_LogFileBase )
        {
        UnmapViewOfFile( (LPCVOID)g_LogFileBase );
        g_LogFileBase = NULL;
        }

    if ( g_LogFileMapping )
        {
        CloseHandle( g_LogFileMapping );
        g_LogFileMapping = NULL;
        }

    if ( INVALID_HANDLE_VALUE != g_LogFile )
        {
        CloseHandle( g_LogFile );
        g_LogFile = INVALID_HANDLE_VALUE;
        }

}

HRESULT LogInit()
{

    if ( !InitializeCriticalSectionAndSpinCount( &g_LogCs, 0x80000000 ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    if (!GetSystemDirectory( g_LogDefaultFileName, LOG_FILENAME_LEN ) )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        DeleteCriticalSection( &g_LogCs );
        return Hr;
        }
        
    StringCchCatA( 
        g_LogDefaultFileName, 
        LOG_FILENAME_LEN,
        "\\bitsserver.log" );
    g_LogFileName = g_LogDefaultFileName;

    HKEY Key = NULL;
    if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, LOG_SETTINGS_PATH, &Key ) )
        {

        DWORD Type;
        DWORD DataSize = sizeof( g_LogRegistryFileName );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               LOG_FILENAME_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)g_LogRegistryFileName,
                                               &DataSize ) &&
             ( ( REG_EXPAND_SZ == Type ) || ( REG_SZ == Type ) ) )
            {
            g_LogFileName = g_LogRegistryFileName;
            }
          
        DWORD LogRegistryFlags;
        DataSize = sizeof( LogRegistryFlags );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               LOG_FLAGS_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)&LogRegistryFlags,
                                               &DataSize ) &&
             ( REG_DWORD == Type ) )
            {
            g_LogFlags = LogRegistryFlags;
            }

        DWORD LogSize;
        DataSize = sizeof( LogSize );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               LOG_SIZE_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)&LogSize,
                                               &DataSize ) &&
             ( REG_DWORD == Type ) )
            {
            g_LogSlots = ( LogSize * 1000000 ) / g_LogLineSize;
            }

        DWORD fRegistryPerProcessLog;
        DataSize = sizeof( fRegistryPerProcessLog );
        if ( ERROR_SUCCESS == RegQueryValueEx( Key, 
                                               PER_PROCESS_LOG_VALUE,
                                               NULL,
                                               &Type,
                                               (LPBYTE)&fRegistryPerProcessLog,
                                               &DataSize ) &&
             ( REG_DWORD == Type ) )
            {
            g_fPerProcessLog = ((fRegistryPerProcessLog == 0)? false : true);
            }


        RegCloseKey( Key );
        Key = NULL;
        }

    //
    // Override the filename key and set the logfilename to be <logfilename>_pid<processid>.log
    // this feature is important for the case where we have more than one application pool
    // or webgardens is enabled.
    //
    // We won't be looking for failures of the StringCch* functions here. The buffer used
    // is very large for path names (2*MAX_PATH), and there's not a lot we can do to
    // handle the error cases. THe functions are guaranteed to be safe -- no buffer overruns.
    // The worst that can happen is the filename extension to be truncated.
    //
    if ( g_fPerProcessLog )
        {
           CHAR szExt[_MAX_EXT];
           CHAR *pExt = NULL;
           CHAR szPid[30];

           pExt = PathFindExtension(g_LogFileName);

           // if the file doesn't have an extension, pExt will point to the trainling '\0', 
           // and this is fine
           StringCchCopyA(szExt, ARRAYSIZE(szExt), pExt);

           // get rid of the extension so we can append the process id
           *pExt = '\0';

           // Add the processId
           StringCchPrintf(szPid, ARRAYSIZE(szPid), "%u", GetCurrentProcessId());
           StringCchCatA(g_LogFileName, LOG_FILENAME_LEN, "_pid");
           StringCchCatA(g_LogFileName, LOG_FILENAME_LEN, szPid);

           // add the extension back to the filename
           StringCchCatA(g_LogFileName, LOG_FILENAME_LEN, szExt);
        }

    if ( g_LogFlags && g_LogFileName && g_LogSlots )
        {     
        OpenLogFile();
        }

    Log( LOG_INFO, "Starting log session");

    return S_OK;

}

void LogClose()
{

    EnterCriticalSection( &g_LogCs );

    Log( LOG_INFO, "Closing log session");

    if ( g_LogFileBase )
        {

        memset( g_LogFileBase[0], ' ', sizeof( g_LogLineSize ) );
        StringCchPrintfA( 
            g_LogFileBase[0],
            g_LogLineSize,
            "# %u %I64u %u %I64u", 
            g_LogLineSize, 
            g_LogSlots, 
            g_LogSequence, 
            g_LogCurrentSlot ); 
        g_LogFileBase[0][ g_LogLineSize - 2 ] = '\r';
        g_LogFileBase[0][ g_LogLineSize - 1 ] = '\n';

        UnmapViewOfFile( (LPCVOID)g_LogFileBase );
        g_LogFileBase = NULL;
        }

    if ( g_LogFileMapping )
        {
        CloseHandle( g_LogFileMapping );
        g_LogFileMapping = NULL;
        }

    if ( INVALID_HANDLE_VALUE != g_LogFile )
        {
        CloseHandle( g_LogFile );
        g_LogFile = INVALID_HANDLE_VALUE;
        }

    DeleteCriticalSection( &g_LogCs );
}

void LogInternal( UINT32 LogFlags, char *Format, va_list arglist )
{

    if ( !g_LogFileEnabled && !g_LogDebuggerEnabled )
        return;

    DWORD LastError = GetLastError();

    EnterCriticalSection( &g_LogCs );

    DWORD ThreadId = GetCurrentThreadId();
    DWORD ProcessId = GetCurrentProcessId();

    SYSTEMTIME Time;

    GetLocalTime( &Time );
  
    StringCchVPrintfA( 
          g_LogBuffer, 
          sizeof(g_LogBuffer) - 1,
          Format, arglist );

    int CharsWritten = strlen( g_LogBuffer );

    char *BeginPointer = g_LogBuffer;
    char *EndPointer = g_LogBuffer + CharsWritten;
    DWORD MinorSequence = 0;

    while ( BeginPointer < EndPointer )
        {

        static char StaticLineBuffer[ g_LogLineSize ];
        char *LineBuffer = StaticLineBuffer;

        if ( g_LogFileBase )
            {
            LineBuffer = g_LogFileBase[ g_LogCurrentSlot ];
            g_LogCurrentSlot = ( g_LogCurrentSlot + 1 ) % g_LogSlots;

            // leave the first line alone
            if ( !g_LogCurrentSlot )
                g_LogCurrentSlot = ( g_LogCurrentSlot + 1 ) % g_LogSlots;

            }

        char *CurrentOutput = LineBuffer;

        StringCchPrintfA( 
             LineBuffer,
             g_LogLineSize,
             "%.8X.%.2X %.2u/%.2u/%.4u-%.2u:%.2u:%.2u.%.3u %.4X.%.4X %s|%s|%s|%s|%s ",
             g_LogSequence,
             MinorSequence++,
             Time.wMonth,
             Time.wDay,
             Time.wYear,
             Time.wHour,
             Time.wMinute,
             Time.wSecond,
             Time.wMilliseconds,
             ProcessId,
             ThreadId,
             ( LogFlags & LOG_INFO )        ? "I" : "-",
             ( LogFlags & LOG_WARNING )     ? "W" : "-",
             ( LogFlags & LOG_ERROR )       ? "E" : "-",
             ( LogFlags & LOG_CALLBEGIN )   ? "CB" : "--",
             ( LogFlags & LOG_CALLEND )     ? "CE" : "--" );

        int HeaderSize      = strlen( LineBuffer );
        int SpaceAvailable  = g_LogLineSize - HeaderSize - 2;  // 2 bytes for /r/n
        int OutputChars     = min( (int)( EndPointer - BeginPointer ), SpaceAvailable );
        int PadChars        = SpaceAvailable - OutputChars;
        CurrentOutput       += HeaderSize;

        memcpy( CurrentOutput, BeginPointer, OutputChars );
        CurrentOutput       += OutputChars;
        BeginPointer        += OutputChars;

        memset( CurrentOutput, ' ', PadChars );
        CurrentOutput       += PadChars;

        *CurrentOutput++    = '\r';
        *CurrentOutput++    = '\n';

        ASSERT( CurrentOutput - LineBuffer == g_LogLineSize );

        if ( g_LogDebuggerEnabled )
            {
            static char DebugLineBuffer[ g_LogLineSize + 1];
            memcpy( DebugLineBuffer, LineBuffer, g_LogLineSize );
            DebugLineBuffer[ g_LogLineSize ] = '\0';
            OutputDebugString( DebugLineBuffer );
            }

        }

    g_LogSequence++;

    LeaveCriticalSection( &g_LogCs );

    SetLastError( LastError );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\resource.h ===
#define IDS_EXTENSION_NAME              1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\precomp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Main header for BITS server extensions

--*/

#define INITGUID
#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <httpfilt.h>
#include <httpext.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <shlwapi.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include <sddl.h>
#include <aclapi.h>

#include "winhttp.h"
// #include "inethttp.h"

#include <activeds.h>
#include <bitsmsg.h>
#include "resource.h"

#include <smartptr.h>
typedef StringHandleA StringHandle;

#include <bitscfg.h>
typedef SmartRefPointer<IMSAdminBase>   SmartMetabasePointer;
typedef SmartRefPointer<IBITSExtensionSetupFactory> SmartBITSExtensionSetupFactoryPointer;
typedef SmartRefPointer<IBITSExtensionSetup> SmartBITSExtensionSetupPointer;
#if defined(DBG)

// check build
#define BITS_MUST_SUCCEED( expr ) ASSERT( expr )

#else

// free build
#define BITS_MUST_SUCCEED( expr ) ( expr )

#endif

const UINT32 LOG_INFO       = 0x1;
const UINT32 LOG_WARNING    = 0x2;
const UINT32 LOG_ERROR      = 0x4;
const UINT32 LOG_CALLBEGIN  = 0x8;
const UINT32 LOG_CALLEND    = 0x10;

#if defined(DBG)
const UINT32 DEFAULT_LOG_FLAGS = LOG_INFO | LOG_WARNING | LOG_ERROR | LOG_CALLBEGIN | LOG_CALLEND;
#else
const UINT32 DEFAULT_LOG_FLAGS = 0;
#endif

const UINT32 DEFAULT_LOG_SIZE  = 20;

// LogSetings path under HKEY_LOCAL_MACHINE
const char * const LOG_SETTINGS_PATH = "SOFTWARE\\Microsoft\\BITSServer";

// Values
// (REG_EXPAND_SZ). Contains the full path of the log file name
const char * const LOG_FILENAME_VALUE     = "LogFileName";
// (REG_DWORD) Contains the log flags
const char * const LOG_FLAGS_VALUE        = "LogFlags";
// (REG_DWORD) Contains the log size in MB
const char * const LOG_SIZE_VALUE         = "LogSize";
// (REG_DWORD) Indicates if we will be appending the ProcessId to the log file name
const char * const PER_PROCESS_LOG_VALUE  = "PerProcessLog";

extern UINT32 g_LogFlags;

HRESULT LogInit();
void LogClose();
void LogInternal( UINT32 LogFlags, char *Format, va_list arglist );

void inline Log( UINT32 LogFlags, char *Format, ... )
{

    if ( !( g_LogFlags & LogFlags ) )
        return;

    va_list arglist;
    va_start( arglist, Format );

    LogInternal( LogFlags, Format, arglist );

}

const char *LookupHTTPStatusCodeText( DWORD HttpCode );

class ServerException : public ComError
{
public:

    ServerException() :
        ComError( 0 ),
        m_HttpCode( 0 ),
        m_Context( 0 )
    {
    }

    ServerException( HRESULT Code, DWORD HttpCode = 0, DWORD Context = 0x5 ) :
        ComError( Code ),
        m_HttpCode( HttpCode ? HttpCode : MapStatus( Code ) ),
        m_Context( Context )
    {
    }
    ServerException( const ComError & Error ) :
        ComError( Error.m_Hr ),
        m_HttpCode( MapStatus( Error.m_Hr ) ),
        m_Context( 0x5 )
    {
    }
    ServerException( const ServerException & Error ) :
        ComError( Error.m_Hr ),
        m_HttpCode( Error.m_HttpCode ),
        m_Context( Error.m_Context )
    {
    }

    HRESULT GetCode() const
    {
        return m_Hr;
    }
    DWORD GetHttpCode() const
    {
        return m_HttpCode;
    }

    DWORD GetContext() const
    {
        return m_Context;
    }

    void SendErrorResponse( EXTENSION_CONTROL_BLOCK * ExtensionControlBlock ) const;
    DWORD MapStatus( HRESULT Hr ) const;

private:
    DWORD m_HttpCode;
    DWORD m_Context;
};

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
}

inline FILETIME UINT64ToFILETIME( UINT64 Int64Value )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.QuadPart = Int64Value;

    FILETIME FileTime;
    FileTime.dwHighDateTime = LargeInteger.HighPart;
    FileTime.dwLowDateTime = LargeInteger.LowPart;

    return FileTime;
}


// API thunks

UINT64 BITSGetFileSize(
    HANDLE Handle );

UINT64 BITSSetFilePointer(
    HANDLE Handle,
    INT64 Distance,
    DWORD MoveMethod );

DWORD
BITSWriteFile(
    HANDLE Handle,
    LPCVOID Buffer,
    DWORD NumberOfBytesToWrite);

void
BITSCreateDirectory(
    const CHAR *Path );
void
BITSRenameFile(
    LPCTSTR ExistingName,
    LPCTSTR NewName,
    bool AllowOverwrites );

void
BITSDeleteFile(
    LPCTSTR FileName );

GUID
BITSCreateGuid();

GUID
BITSGuidFromString( const char *String );

StringHandle
BITSStringFromGuid(
    GUID Guid );


StringHandle
BITSUnicodeToStringHandle( const WCHAR *pStr );

StringHandle
BITSUrlCombine(
    const char *Base,
    const char *Relative,
    DWORD dwFlags );

StringHandle
BITSUrlCanonicalize(
    const char *URL,
    DWORD dwFlags );

void
BITSSetCurrentThreadToken(
    HANDLE hToken );

// Metadata wrappers

StringHandle
GetMetaDataString(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    LPCSTR              DefaultValue );

DWORD
GetMetaDataDWORD(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    DWORD               DefaultValue );

class WorkStringBufferA
{
    char *Data;

public:

    WorkStringBufferA( SIZE_T Size )
    {
        Data = new char[Size];
    }
    WorkStringBufferA( const char* String )
    {
        size_t BufferSize = strlen(String) + 1;
        Data = new char[ BufferSize ];
        memcpy( Data, String, BufferSize );
    }
    ~WorkStringBufferA()
    {
        delete[] Data;
    }

    char *GetBuffer()
    {
        return Data;
    }
};

class WorkStringBufferW
{
    WCHAR *Data;

public:

    WorkStringBufferW( SIZE_T Size )
    {
        Data = new WCHAR[Size];
    }
    WorkStringBufferW( const WCHAR* String )
    {
        size_t BufferSize = wcslen(String) + 1;
        Data = new WCHAR[ BufferSize ];
        memcpy( Data, String, BufferSize * sizeof( WCHAR ) );
    }
    ~WorkStringBufferW()
    {
        delete[] Data;
    }

    WCHAR *GetBuffer()
    {
        return Data;
    }
};


typedef WorkStringBufferA WorkStringBuffer;

const char * const BITS_CONNECTIONS_NAME_WITH_SLASH="BITS-Connections\\";
const char * const BITS_CONNECTIONS_NAME="BITS-Connections";
const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per sec
const DWORD WorkerRunInterval = 1000 * 60 /*secs*/ * 60 /*mins*/ * 12; /* hours */ /* twice a day */
const UINT64 CleanupThreshold = NanoSec100PerSec * 60 /*secs*/ * 60 /*mins*/ * 24 /* hours */ * 3; // 3 days


//
// Configuration manager
//

#include "bitssrvcfg.h"


class ConfigurationManager;
class VDirConfig
{
    friend ConfigurationManager;

    LONG                            m_Refs;
    FILETIME                        m_LastLookup;

	static StringHandle GetFullPath( StringHandle Path );

public:
    StringHandle                    m_Path;
    StringHandle                    m_PhysicalPath;
    StringHandle                    m_SessionDir;
    StringHandle                    m_ConnectionsDir;
    StringHandle                    m_RequestsDir;
    StringHandle                    m_RepliesDir;
    DWORD                           m_NoProgressTimeout;
    UINT64                          m_MaxFileSize;
    BITS_SERVER_NOTIFICATION_TYPE   m_NotificationType;
    StringHandle                    m_NotificationURL;
    bool                            m_UploadEnabled;
    StringHandle                    m_HostId;
    DWORD                           m_HostIdFallbackTimeout;
    DWORD                           m_ExecutePermissions;
    bool                            m_AllowOverwrites;

    VDirConfig(
        StringHandle Path,
        SmartMetabasePointer AdminBase );

    void AddRef()
    {
        InterlockedIncrement( &m_Refs );
    }

    void Release()
    {

        if (!InterlockedDecrement( &m_Refs ))
            delete this;
    }
};

typedef SmartRefPointer<VDirConfig> SmartVDirConfig; 

class MapCacheEntry
{
    friend ConfigurationManager;
    FILETIME    m_LastLookup;

public:

    StringHandle    m_InstanceMetabasePath;
    StringHandle    m_URL;
    SmartVDirConfig m_Config;
    DWORD           m_URLDepth;

    MapCacheEntry(
        StringHandle InstanceMetabasePath,
        StringHandle URL,
        SmartVDirConfig Config,
        DWORD URLDepth ) :
        m_InstanceMetabasePath( InstanceMetabasePath ),
        m_URL( URL ),
        m_Config( Config ),
        m_URLDepth( URLDepth )
    {
        GetSystemTimeAsFileTime( &m_LastLookup );
    }

};

class ConfigurationManager
{
public:

    ConfigurationManager();
    ~ConfigurationManager();

    SmartVDirConfig GetConfig2( StringHandle InstanceMetabasePath, StringHandle URL,
                                DWORD *pURLDepth );
    SmartVDirConfig GetConfig( StringHandle InstanceMetabasePath, StringHandle URL,
                               DWORD *pURLDepth );

    static const PATH_CACHE_ENTRIES = 10;
    static const MAP_CACHE_ENTRIES = 10;

private:

    SmartMetabasePointer    m_IISAdminBase;
    CRITICAL_SECTION    m_CacheCS;
    DWORD               m_ChangeNumber;

    SmartVDirConfig     m_PathCacheEntries[ PATH_CACHE_ENTRIES ];
    MapCacheEntry       *m_MapCacheEntries[ MAP_CACHE_ENTRIES ];

    void                FlushCache();
    bool                HandleCacheConsistency();

    // L2 cache
    SmartVDirConfig     Lookup( StringHandle Path );
    void                Insert( SmartVDirConfig NewConfig );
    SmartVDirConfig     GetVDirConfig( StringHandle Path );

    // L1 cache
    SmartVDirConfig     Lookup( StringHandle InstanceMetabasePath,
                                StringHandle URL,
                                DWORD *pURLDepth );
    SmartVDirConfig     Insert( StringHandle InstanceMetabasePath,
                                StringHandle URL,
                                StringHandle Path,
                                DWORD URLDepth );

    StringHandle        GetVDirPath( StringHandle InstanceMetabasePath,
                                     StringHandle URL,
                                     DWORD *pURLDepth );

};

extern ConfigurationManager *g_ConfigMan;
extern HMODULE g_hinst;
extern PropertyIDManager *g_PropertyMan;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\dload.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    dload.cpp

Abstract:

    This file implement dload error handling

--*/

#include "precomp.h"
#include <delayimp.h>

BOOL
BITSFailureHookWinHttpAddRequestHeaders(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    )
{

    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;

}

BOOL
BITSFailureHookWinHttpCloseHandle(
    IN HINTERNET hInternet
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

HINTERNET
BITSFailureHookWinHttpConnect(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return NULL;
}

BOOL
BITSFailureHookWinHttpCrackUrl(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS pUCW
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

HINTERNET
BITSFailureHookWinHttpOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return NULL;
}

HINTERNET
BITSFailureHookWinHttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return NULL;
}

BOOL
BITSFailureHookWinHttpQueryHeaders(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN     LPCWSTR lpszName OPTIONAL, 
       OUT LPVOID  lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpReadData(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut OPTIONAL
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

BOOL
BITSFailureHookWinHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )
{
    SetLastError( ERROR_MOD_NOT_FOUND );
    return FALSE;
}

struct FailureHookTableEntry
{
    LPCSTR  pszDllName;
    LPCSTR  pszProcName;
    FARPROC pfnHandler;
};
 
FailureHookTableEntry FailureHookTable[] =
{

    {
    "winhttp.dll",
    "WinHttpAddRequestHeaders",
    (FARPROC)BITSFailureHookWinHttpAddRequestHeaders
    },

    {
    "winhttp.dll",
    "WinHttpCloseHandle",
    (FARPROC)BITSFailureHookWinHttpCloseHandle
    },

    {
    "winhttp.dll",
    "WinHttpConnect",
    (FARPROC)BITSFailureHookWinHttpConnect
    },

    {
    "winhttp.dll",
    "WinHttpCrackUrl",
    (FARPROC)BITSFailureHookWinHttpCrackUrl
    },

    {
    "winhttp.dll",
    "WinHttpOpen",
    (FARPROC)BITSFailureHookWinHttpOpen
    },

    {
    "winhttp.dll",
    "WinHttpOpenRequest",
    (FARPROC)BITSFailureHookWinHttpOpenRequest
    },

    {
    "winhttp.dll",
    "WinHttpQueryHeaders",
    (FARPROC)BITSFailureHookWinHttpQueryHeaders
    },

    {
    "winhttp.dll",
    "WinHttpReadData",
    (FARPROC)BITSFailureHookWinHttpReadData
    },

    {
    "winhttp.dll",
    "WinHttpReceiveResponse",
    (FARPROC)BITSFailureHookWinHttpReceiveResponse
    },

    {
    "winhttp.dll",
    "WinHttpSendRequest",
    (FARPROC)BITSFailureHookWinHttpSendRequest
    },

    {
    "winhttp.dll",
    "WinHttpWriteData",
    (FARPROC)BITSFailureHookWinHttpWriteData
    },

    {
    NULL,
    NULL,
    NULL
    }

};

FARPROC
LookupFailureHook(
    LPCSTR pszDllName,
    LPCSTR pszProcName
    )
{

    for ( FailureHookTableEntry *p = FailureHookTable; 
          p->pszDllName; p++ )
        {

        if ( ( lstrcmpiA( pszDllName, p->pszDllName ) == 0   ) &&
             ( lstrcmpiA( pszProcName, p->pszProcName ) == 0 )  )
            {
            return p->pfnHandler;
            }

        }
    
    ASSERT( 0 );
    return NULL;

}

FARPROC
WINAPI
BITSSERVER_DelayLoadFailureHook(
    UINT unReason,
    PDelayLoadInfo pDelayInfo
    )
{
    
    // For a failed LoadLibrary, we return a bogus HMODULE of -1 to force
    // DLOAD call again with dliFailGetProc
    
    if (dliFailLoadLib == unReason)
        {
        return (FARPROC)-1;
        }

    if (dliFailGetProc == unReason)
        {
        
        // The loader is asking us to return a pointer to a procedure.
        // Lookup the handler for this DLL/procedure and, if found, return it.
        return LookupFailureHook(pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\server.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    server.cpp                         

Abstract:

    This file implements the BITS server extensions

--*/

#include "precomp.h"

#if DBG
#define CLEARASYNCBUFFERS
#endif

typedef StringHandleW HTTPStackStringHandle;
#define HTTP_STRING( X ) L ## X

#define INTERNET_MAX_URL_LENGTH       2200


const DWORD SERVER_REQUEST_SPINLOCK = 0x80000040;
const DWORD ASYNC_READER_SPINLOCK   = 0x80000040;

const char * const UPLOAD_PROTOCOL_STRING_V1 = "{7df0354d-249b-430f-820d-3d2a9bef4931}";

// packet types that are sent in the protocol
const char * const PACKET_TYPE_CREATE_SESSION   = "Create-Session";
const char * const PACKET_TYPE_FRAGMENT         = "Fragment";
const char * const PACKET_TYPE_CLOSE_SESSION    = "Close-Session";
const char * const PACKET_TYPE_CANCEL_SESSION   = "Cancel-Session";
const char * const PACKET_TYPE_PING             = "Ping";

//
// IISLogger
//
// Manages the circular debugging log.
//

class IISLogger
{
   EXTENSION_CONTROL_BLOCK *m_ExtensionControlBlock;

   void LogString( const char *String, int Size );

public:

   IISLogger( EXTENSION_CONTROL_BLOCK *ExtensionControlBlock ) :
       m_ExtensionControlBlock( ExtensionControlBlock )
   {
   }
   
   void LogError( ServerException Error );
   void LogError( const GUID & SessionID, ServerException Error );
   void LogNewSession( const GUID & SessionID );
   void LogUploadComplete( const GUID & SessionID, UINT64 FileSize );
   void LogSessionClose( const GUID & SessionID );
   void LogSessionCancel( const GUID & SessionID );
   void LogExecuteEnabled();



};

class CriticalSectionLock
{
    CRITICAL_SECTION* m_cs;
public:
    CriticalSectionLock( CRITICAL_SECTION *cs ) :
        m_cs( cs )
    {
        EnterCriticalSection( m_cs );
    }
    ~CriticalSectionLock()
    {
        LeaveCriticalSection( m_cs );
    }      
};

class AsyncReader;

struct STATE_FILE_STRUCT 
{
   UINT StateVersion;
   UINT64 UploadFileSize;

   BOOL NotifyCached;
   DWORD HttpCode;
   BOOL ReplyURLReturned;
   CHAR ReplyURL[ INTERNET_MAX_URL_LENGTH + 1 ];

   void Initialize()
   {
       StateVersion     = STATE_FILE_VERSION;
       UploadFileSize   = 0;
       NotifyCached     = FALSE;
       ReplyURLReturned = FALSE;
   }
};

//
// ServerRequest
//
// Contains all data needed to service a request.   A request is a single POST not a single 
// upload.

class ServerRequest : IISLogger
{

public:
    ServerRequest( EXTENSION_CONTROL_BLOCK * ExtensionControlBlock );
    ~ServerRequest();

    long AddRef();
    long Release();
    bool IsPending() { return m_IsPending; }

    // The do it function!
    void DispatchRequest();
    friend AsyncReader;

private:
    long m_refs;
    CRITICAL_SECTION m_cs;
    bool m_IsPending;
    EXTENSION_CONTROL_BLOCK *m_ExtensionControlBlock;
    AsyncReader *m_AsyncReader;
    HANDLE m_ImpersonationToken; // Do not free this


    // Filled in by dispatch Request
    StringHandle m_PacketType;

    // Variables filled in by GeneratePhysicalPaths

    StringHandle m_DestinationDirectory;
    StringHandle m_DestinationFile;
    StringHandle m_ResponseDirectory;
    StringHandle m_ResponseFile;
    StringHandle m_RequestDirectory;
    StringHandle m_RequestFile;
    StringHandle m_StateFile;

    // Filled in by OpenCacheFile
    HANDLE m_CacheFile;

    // Filed in by OpenStateFile
    STATE_FILE_STRUCT *m_StateFileStruct;

    GUID m_SessionId;
    StringHandle    m_SessionIdString;
    SmartVDirConfig m_DirectoryConfig;
    DWORD m_URLDepth;

    void GetConfig();
    StringHandle GetServerVariable( char *ServerVariable );
    bool TestServerVariable( char *ServerVariable );
    StringHandle GetRequestURL();

    void ValidateProtocol();
    void CrackSessionId();
    void GeneratePhysicalPaths();

    CHAR *BasePathOf(const CHAR *pPath);
    StringHandle GeneratePathInDestinationDir(LPCSTR szOriginalPath);
    HANDLE CreateFileWithDestinationAcls(const CHAR *szOriginalFile, DWORD fOnlyCreateNew, DWORD dwAttributes);
    
    void OpenStateFile();
    void CloseStateFile();

    void VerifySessionExists();
    void CheckFilesystemAccess();
    void OpenCacheFile();
    void ReopenCacheFileAsSync();
    void CloseCacheFile();
    void CrackContentRange(
        UINT64 & RangeStart,
        UINT64 & RangeLength,
        UINT64 & TotalLength );
    void ScheduleAsyncOperation(
        DWORD   OperationID,
        LPVOID  Buffer,
        LPDWORD Size,
        LPDWORD DataType );
    void CloseCancelSession();

    // dispatch routines
    void CreateSession();
    void AddFragment();
    void CloseSession();
    void CancelSession();
    void Ping();


    // Response handling
    void SendResponse( char *Format, DWORD Code = 200, ... );
    void SendResponse( ServerException Exception );
    void FinishSendingResponse();
    void DrainFragmentBlockComplete( DWORD cbIO, DWORD dwError );
    static void DrainFragmentBlockCompleteWrapper(
        LPEXTENSION_CONTROL_BLOCK lpECB,
        PVOID pContext,
        DWORD cbIO,
        DWORD dwError);
    void StartDrainBlock( );
    void DrainData();

    StringHandle m_ResponseString;
    DWORD   m_ResponseCode;
    HRESULT m_ResponseHRESULT;

    UINT64  m_BytesToDrain;
    UINT64  m_ContentLength;

    // async IO handling
    void CompleteIO( AsyncReader *Reader, UINT64 TotalBytesRead );
    void HandleIOError( AsyncReader *Reader, ServerException Error, UINT64 TotalBytesRead );

    // backend notification
    char m_NotifyBuffer[ 1024 ];
    void  SendResponseAfterNotification( DWORD HttpStatus, UINT64 RequestFileSize, const CHAR * ReplyURL );
    DWORD GetStatusCode( HINTERNET hRequest );
    void  CallServerNotification( UINT64 CacheFileSize );
    bool  TestResponseHeader( HINTERNET hRequest, const WCHAR *Header );
    StringHandle GetResponseHeader( HINTERNET hRequest, const WCHAR *Header );

    // deal with chaining
    static void ForwardComplete(
        LPEXTENSION_CONTROL_BLOCK lpECB, PVOID pContext,
        DWORD cbIO, DWORD dwError );
    void ForwardToNextISAPI();

};

// AsyncReader
//
// Manages the buffering needed to handle the async read/write operations.

class AsyncReader : private OVERLAPPED
{

public:
    AsyncReader( ServerRequest *Request,
                 UINT64 BytesToDrain,
                 UINT64 BytesToWrite,
                 UINT64 WriteOffset,
                 HANDLE WriteHandle,
                 char *PrereadBuffer,
                 DWORD PrereadSize );


    ~AsyncReader();

    UINT64 GetWriteOffset()
    {
        return m_WriteOffset;
    }


private:

    ServerRequest *m_Request;
    UINT64 m_BytesToDrain;
    UINT64 m_WriteOffset;
    UINT64 m_ReadOffset;
    UINT64 m_BytesToWrite;
    UINT64 m_BytesToRead;
    char * m_PrereadBuffer;
    DWORD  m_PrereadSize;
    UINT64 m_TotalBytesRead;
    HANDLE m_WriteHandle;
    HANDLE m_ThreadToken;

    char m_OperationsPending;

    DWORD m_ReadBuffer;
    DWORD m_WriteBuffer;
    DWORD m_BuffersToWrite;

    bool m_WritePending;
    bool m_ReadPending;

    bool m_ErrorValid;
    ServerException m_Error;

    const static NUMBER_OF_IO_BUFFERS = 3;
    struct IOBuffer
    {
        UINT64  m_BufferWriteOffset;
        DWORD   m_BufferUsed;
        char    m_Buffer[ 32768 ];
    } m_IOBuffers[ NUMBER_OF_IO_BUFFERS ];

    void HandleError( ServerException Error );
    void CompleteIO();
    void StartReadRequest();
    void StartWriteRequest();
    void StartupIO( );
    void WriteComplete( DWORD dwError, DWORD BytesWritten );
    void ReadComplete( DWORD dwError, DWORD BytesRead );

    static DWORD StartupIOWraper( LPVOID Context );
    static void CALLBACK WriteCompleteWraper( DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped );
    static void WINAPI ReadCompleteWraper( LPEXTENSION_CONTROL_BLOCK, PVOID pContext, DWORD cbIO, DWORD dwError );
};

ServerRequest::ServerRequest(
    EXTENSION_CONTROL_BLOCK * ExtensionControlBlock
    ) :
    IISLogger( ExtensionControlBlock ),
    m_refs(1),
    m_IsPending( false ),
    m_ExtensionControlBlock( ExtensionControlBlock ),
    m_AsyncReader( NULL ),
    m_ImpersonationToken( NULL ),
    m_StateFileStruct( NULL ),
    m_CacheFile( INVALID_HANDLE_VALUE ),
    m_DirectoryConfig( NULL ),
    m_ResponseCode( 0 ),
    m_ResponseHRESULT( 0 ),
    m_BytesToDrain( 0 ),
    m_ContentLength( 0 )
{
    memset( &m_SessionId, 0, sizeof(m_SessionId) );

    if ( !InitializeCriticalSectionAndSpinCount( &m_cs, SERVER_REQUEST_SPINLOCK ) )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
}


ServerRequest::~ServerRequest()
{

    // The destructor handles most of the cleanup.

    Log( LOG_CALLEND, "Connection: %p, Packet-Type: %s, Method: %s, Path %s, HTTPError: %u, HRESULT: 0x%8.8X",
         m_ExtensionControlBlock->ConnID,
         (const char*)m_PacketType,
         m_ExtensionControlBlock->lpszMethod,
         m_ExtensionControlBlock->lpszPathTranslated,
         m_ResponseCode,
         m_ResponseHRESULT );

    delete m_AsyncReader;

    CloseCacheFile();
    CloseStateFile();

    m_DirectoryConfig.Clear();

    DeleteCriticalSection( &m_cs );

    if ( m_IsPending )
        {

        Log( LOG_INFO, "Ending session" );

        (*m_ExtensionControlBlock->ServerSupportFunction)
        (   m_ExtensionControlBlock->ConnID,
            HSE_REQ_DONE_WITH_SESSION,
            NULL,
            NULL,
            NULL );

        }

}

long
ServerRequest::AddRef()
{
    long Result = InterlockedIncrement( &m_refs );
    ASSERT( Result > 0 );
    return Result;
}

long
ServerRequest::Release()
{
    long Result = InterlockedDecrement( &m_refs );
    ASSERT( Result >= 0 );
    
    if ( !Result )
        delete this;

    return Result;

}


StringHandle
ServerRequest::GetServerVariable(
    char * ServerVariable )
{
    //
    // Retrive a server variable from IIS.  Throws an exception 
    // is the variable can not be retrieved.
    //

    DWORD SizeOfBuffer = 0;

    BOOL Result = (*m_ExtensionControlBlock->GetServerVariable)
        ( m_ExtensionControlBlock->ConnID,
          ServerVariable,
          NULL,
          &SizeOfBuffer );

    if ( Result )
        return StringHandle();

    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {

        Log( LOG_ERROR, "Unable to lookup server variable %s, error %x",
             ServerVariable,
             HRESULT_FROM_WIN32( GetLastError() ) );

        throw ServerException( HRESULT_FROM_WIN32(GetLastError()) );
        }

    if ( SizeOfBuffer > BITS_MAX_HEADER_SIZE )
        {
        Log( LOG_ERROR, "Variable is larger then the maximum size" );
        throw ServerException( E_INVALIDARG );
        }

    StringHandle WorkString;
    char *Buffer = WorkString.AllocBuffer( SizeOfBuffer );

    Result = (*m_ExtensionControlBlock->GetServerVariable)
        ( m_ExtensionControlBlock->ConnID,
          ServerVariable,
          Buffer,
          &SizeOfBuffer );

    if ( !Result )
        {
        Log( LOG_ERROR, "Unable to lookup server variable %s, error %x",
             ServerVariable,
             HRESULT_FROM_WIN32( GetLastError() ) );

        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    WorkString.SetStringSize();
    return WorkString;
}

bool
ServerRequest::TestServerVariable(
    char *ServerVariable )
{

    // Test for the existence of a server variable.
    // Returns true if the variable exists, and false if it doesn't.
    // throw an exception on an error.

    DWORD SizeOfBuffer = 0;

    BOOL Result = (*m_ExtensionControlBlock->GetServerVariable)
        ( m_ExtensionControlBlock->ConnID,
          ServerVariable,
          NULL,
          &SizeOfBuffer );

    if ( Result )
        return true;

    DWORD dwError = GetLastError();

    if ( ERROR_INVALID_INDEX == dwError ||
         ERROR_NO_DATA == dwError )
        return false;

    if ( ERROR_INSUFFICIENT_BUFFER == dwError )
        return true;

    Log( LOG_ERROR, "Unable to test server variable %s, error %x",
         ServerVariable,
         HRESULT_FROM_WIN32( GetLastError() ) );

    throw ServerException( HRESULT_FROM_WIN32( dwError ) );

}

StringHandle
ServerRequest::GetRequestURL()
{

    // Recreate the request URL from the information available from IIS.
    // This may not always be possible, but do the best that we can do.

    StringHandle ServerName     =   GetServerVariable("SERVER_NAME");
    StringHandle ServerPort     =   GetServerVariable("SERVER_PORT");
    StringHandle URL            =   GetServerVariable("URL");
    StringHandle HTTPS          =   GetServerVariable("HTTPS");
    StringHandle QueryString    =   GetServerVariable("QUERY_STRING");

    StringHandle RequestURL;

    if ( _stricmp( HTTPS, "on" ) == 0 )
        RequestURL = "https://";
    else
        RequestURL = "http://";

    RequestURL += ServerName;
    RequestURL += ":";
    RequestURL += ServerPort;
    RequestURL += URL;

    if ( QueryString.Size() > 0 )
        {
        RequestURL += "?";
        RequestURL += QueryString;
        }

    return BITSUrlCanonicalize( RequestURL, URL_ESCAPE_UNSAFE );
}

void
ServerRequest::FinishSendingResponse()
{

    // Completes the response.   The response is taken from the buffer and
    // sent to the client via IIS. The choice to cancel or keep-alive the
    // connection made by IIS.

    Log( LOG_INFO, "Finish sending response" );

    // Close the cache and state files before sending the response in case the client starts a new request immediatly.

    CloseCacheFile();
    CloseStateFile();

    // Finish sending the response using the information
    // in m_ResponseBuffer and m_ResponseCode.

    // If an error occures, give up and force a disconnect.

    m_ExtensionControlBlock->dwHttpStatusCode = m_ResponseCode;

    BOOL Result;
    BOOL KeepConnection;

    Result =
        (m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            HSE_REQ_IS_KEEP_CONN,
            &KeepConnection,
            NULL,
            NULL );

    if ( !Result )
        {
        // Error occured quering the disconnect setting.  Assume
        // a disconnect.

        KeepConnection = 0;
        }

    // IIS5.0(Win2k) has a bug where KeepConnect is returned as -1
    // to keep the connection alive.   Apparently, this confuses the
    // HSE_REQ_SEND_RESPONSE_HEADER_EX call.   Bash the value into a real bool.

    KeepConnection = KeepConnection ? 1 : 0;

    HSE_SEND_HEADER_EX_INFO HeaderInfo;
    HeaderInfo.pszStatus = LookupHTTPStatusCodeText( m_ResponseCode );
    HeaderInfo.cchStatus = strlen( HeaderInfo.pszStatus );
    HeaderInfo.pszHeader = (const char*)m_ResponseString;
    HeaderInfo.cchHeader = (DWORD)m_ResponseString.Size();
    HeaderInfo.fKeepConn = KeepConnection;

    Result =
        (m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &HeaderInfo,
            NULL,
            NULL );

    if ( !Result )
        {

        Log( LOG_ERROR, "Unable to send response, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );

        Log( LOG_INFO, "Forcing the connection closed" );

        // Couldn't send the response, attempt to close the connection
        Result =
            (m_ExtensionControlBlock->ServerSupportFunction)(
               m_ExtensionControlBlock->ConnID,
               HSE_REQ_CLOSE_CONNECTION,
               NULL,
               NULL,
               NULL );

        if ( !Result )
            {

            // The close connection request failed.   No choice but to invoke
            // the hammer of death

            (m_ExtensionControlBlock->ServerSupportFunction)(
               m_ExtensionControlBlock->ConnID,
               HSE_REQ_ABORTIVE_CLOSE,
               NULL,
               NULL,
               NULL );

            }

        }

}

void
ServerRequest::SendResponse( char *Format, DWORD Code, ...)
{
    // Starts the sending of a response.   Unfortunatly, many HTTP
    // client stacks do not handle a response being returned while
    // data is still being sent.  To handle this, it is necessary
    // to capture the response to a buffer.  Then after all the sent data
    // is drained, finally send the response.

    va_list arglist;
    va_start( arglist, Code );

    SIZE_T ResponseBufferSize = 512;

    while( 1 )
        {
        
        char * ResponseBuffer = m_ResponseString.AllocBuffer( ResponseBufferSize );

        HRESULT Hr =
           StringCchVPrintfA( 
               ResponseBuffer,
               ResponseBufferSize,
               Format,
               arglist );

        if ( SUCCEEDED( Hr ) )
            {
            m_ResponseString.SetStringSize();
            break;
            }
        else if ( STRSAFE_E_INSUFFICIENT_BUFFER == Hr )
            ResponseBufferSize *= 2;
        else
            throw ServerException( Hr );

        if ( ResponseBufferSize >= 0xFFFFFFFF )
            throw ServerException( E_INVALIDARG );

        }


    m_ResponseCode = Code;

    if ( m_BytesToDrain )
        {

        // Drain the data first, then send the response.

        Log( LOG_INFO, "Draining data" );

        try
        {
            // start draining data.  DrainData() calls FinishSendingResponse
            // when it is finished.

            DrainData();
        }
        catch( const ComError & )
        {
            // something is very broken, and an attempt to drain excess data
            // failed.   Nothing else to do except try sending the response.

            FinishSendingResponse();
        }
        return;

        }
    else
        {

        // Just send the response since we already handled draining

        FinishSendingResponse();

        }
}

void
ServerRequest::SendResponse( ServerException Exception )
{

    // Starts the sending of a response.   Unfortunatly, many HTTP
    // client stacks do not handle a response being returned while
    // data is still being sent.  To handle this, it is necessary
    // to capture the response to a buffer.  Then after all the sent data
    // is drained, finally send the response.

    GUID NullGuid;
    memset( &NullGuid, 0, sizeof( NullGuid ) );

    if ( memcmp( &NullGuid, &m_SessionId, sizeof( NullGuid ) ) == 0 )
        LogError( Exception );
    else
        LogError( m_SessionId, Exception );

    SIZE_T ResponseBufferSize = 512;

    while( 1 )
        {
        
        char * ResponseBuffer = m_ResponseString.AllocBuffer( ResponseBufferSize );

        HRESULT Hr =
            StringCchPrintfA( 
                   ResponseBuffer,
                   ResponseBufferSize,
                   "Pragma: no-cache\r\n"
                   "BITS-packet-type: Ack\r\n"
                   "BITS-Error: 0x%8.8X\r\n"
                   "BITS-Error-Context: 0x%X\r\n"
                   "Content-Length: 0\r\n"
                   "\r\n",
                   Exception.GetCode(),
                   Exception.GetContext() );

        if ( SUCCEEDED( Hr ) )
            {
            m_ResponseString.SetStringSize();
            break;
            }
        else if ( STRSAFE_E_INSUFFICIENT_BUFFER == Hr )
            ResponseBufferSize *= 2;
        else
            throw ServerException( Hr );

        if ( ResponseBufferSize >= 0xFFFFFFFF )
            throw ServerException( E_INVALIDARG );

        }

    m_ResponseCode      = Exception.GetHttpCode();
    m_ResponseHRESULT   = Exception.GetCode();

    Log( LOG_INFO, "Sending error response of HRESULT: 0x%8.8X, HTTP status: %d",
         m_ResponseHRESULT, m_ResponseCode );

    try
    {
        DrainData();
    }
    catch( const ComError & )
    {
        FinishSendingResponse();
    }

}


void
ServerRequest::DrainFragmentBlockComplete(
  DWORD cbIO,
  DWORD dwError )
{

    // A drain block has been completed.   If this is the last block, finish sending the response.
    // Otherwise, 

    Log( LOG_INFO, "Drain fragment complete, cbIO: %u, dwError: %u", cbIO, dwError );

    m_BytesToDrain -= cbIO;

    if ( !m_BytesToDrain || !cbIO || dwError )
        {
        FinishSendingResponse();
        return;
        }

    try
    {
        StartDrainBlock();
    }
    catch( const ComError & )
    {
        // An error occured while draining data, exit
        FinishSendingResponse();
    }

}


void
ServerRequest::DrainFragmentBlockCompleteWrapper(
  LPEXTENSION_CONTROL_BLOCK lpECB,
  PVOID pContext,
  DWORD cbIO,
  DWORD dwError)
{
    // Wrapper, handles critical section

    ServerRequest *This = (ServerRequest*)pContext;
    {
        CriticalSectionLock CSLock( &This->m_cs );
        This->DrainFragmentBlockComplete( cbIO, dwError );
    }
    This->Release();
}

void
ServerRequest::StartDrainBlock( )
{

    // start the next block to drain.

    BOOL Result;
    static char s_Buffer[ 32768 ];
    DWORD ReadSize  = (DWORD)min( 0xFFFFFFFF, min( m_BytesToDrain, sizeof( s_Buffer ) ) );
    DWORD Flags     = HSE_IO_ASYNC;

    Log( LOG_INFO, "Starting next drain block of %u bytes", ReadSize );

    ScheduleAsyncOperation(
        HSE_REQ_ASYNC_READ_CLIENT,
        (LPVOID)s_Buffer,
        &ReadSize,
        &Flags );

}

void
ServerRequest::DrainData()
{

    // Make the decission regarding the amount of data to drain
    // and the start the first block

    if ( m_DirectoryConfig )
        m_BytesToDrain = min( m_BytesToDrain, m_DirectoryConfig->m_MaxFileSize );
    else
        // use an internal max of 4KB
        m_BytesToDrain = min( 4096, m_BytesToDrain );

    if ( !m_BytesToDrain )
        {
        Log( LOG_INFO, "No bytes to drain, finish it" );
        FinishSendingResponse();
        return;
        }

    Log( LOG_INFO, "Starting pipe drain" );

    BOOL Result;

    Result =
        (*m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            HSE_REQ_IO_COMPLETION,
            (LPVOID)DrainFragmentBlockCompleteWrapper,
            0,
            (LPDWORD)this );

    if ( !Result )
        {
        Log( LOG_ERROR, "Error settings callback, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    StartDrainBlock();
}


void
ServerRequest::ValidateProtocol()
{

    // Negotiate the protocol with the client.   The client sends a list of
    // supported protocols to the server and the server picks the best protocol.
    // For now, only one protocol is supported.

    StringHandle SupportedProtocolsHandle = GetServerVariable( "HTTP_BITS-SUPPORTED-PROTOCOLS" );
    WorkStringBuffer SupportedProtocolsBuffer( (const char*) SupportedProtocolsHandle );
    char *SupportedProtocols = SupportedProtocolsBuffer.GetBuffer();

    char *Protocol = strtok( SupportedProtocols, " ," );

    while( Protocol )
        {

        if ( _stricmp( Protocol, UPLOAD_PROTOCOL_STRING_V1 ) == 0 )
            {
            Log( LOG_INFO, "Detected protocol upload protocol V1" );
            return;
            }

        Protocol = strtok( NULL, " ," );
        }

    Log( LOG_INFO, "Unsupported protocols, %s", (const char*)SupportedProtocols );
    throw ServerException( E_INVALIDARG );
}

void
ServerRequest::CrackSessionId()
{
    // Convert the session ID from a string into a GUID.
    StringHandle SessionId = GetServerVariable( "HTTP_BITS-Session-Id" );

    m_SessionId         = BITSGuidFromString( SessionId );
    m_SessionIdString   = BITSStringFromGuid( m_SessionId );
}

void
ServerRequest::CrackContentRange(
    UINT64 & RangeStart,
    UINT64 & RangeLength,
    UINT64 & TotalLength )
{

    // Crack the content range header which contains the client's view of where the 
    // upload is at.

    StringHandle ContentRange = GetServerVariable( "HTTP_Content-Range" );

    UINT64 RangeEnd;

    int ReturnVal = sscanf( ContentRange, " bytes %I64u - %I64u / %I64u ",
                            &RangeStart, &RangeEnd, &TotalLength );

    if ( ReturnVal != 3 )
        {
        Log( LOG_ERROR, "Range has %d elements instead of the expected number of 3", ReturnVal );
        throw ServerException( E_INVALIDARG );
        }

    if ( TotalLength > m_DirectoryConfig->m_MaxFileSize )
        {
        Log( LOG_ERROR, "Size of the upload at %I64u is greater then the maximum of %I64u",
             TotalLength, m_DirectoryConfig->m_MaxFileSize  );
        throw ServerException( BG_E_TOO_LARGE );
        }

    if ( ( RangeStart == RangeEnd + 1 ) &&
         ( 0 == m_ContentLength ) && 
         ( RangeStart == TotalLength ) )
        {

        // Continue after a failed notification
        RangeStart  = TotalLength;
        RangeLength = 0;
        return;

        }

    if ( RangeEnd < RangeStart )
        {
        Log( LOG_ERROR, "Range start is greater then the range length, End %I64u, Start %I64u",
             RangeEnd, RangeStart );
        throw ServerException( E_INVALIDARG );
        }

    RangeLength = RangeEnd - RangeStart + 1;

    if ( m_ContentLength != RangeLength )
        {
        Log( LOG_ERROR, "The content length is different from the range length. Content %I64u, Range %I64u",
             m_ContentLength, RangeLength );
        throw ServerException( E_INVALIDARG );
        }

}

void
ServerRequest::ScheduleAsyncOperation(
    DWORD   OperationID,
    LPVOID  Buffer,
    LPDWORD Size,
    LPDWORD DataType )
{

    // start an async operation and handle all the flags and recounting required.

    BOOL Result;

    AddRef();

    Result =
        (*m_ExtensionControlBlock->ServerSupportFunction)(
            m_ExtensionControlBlock->ConnID,
            OperationID,
            Buffer,
            Size,
            DataType );

    if ( !Result )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );

        Log( LOG_ERROR, "Error starting async operation, error %x", Hr );

        // Operation was never scheduled, remove the callbacks refcount
        Release();
        throw ServerException( Hr );
        }

    m_IsPending = true;

}

void
ServerRequest::CloseStateFile()
{

    if ( m_StateFileStruct )
        {
        UnmapViewOfFile( m_StateFileStruct );
        m_StateFileStruct = NULL;
        }

}

void
ServerRequest::OpenStateFile()
{
    HANDLE StateFileHandle  = INVALID_HANDLE_VALUE;
    HANDLE FileMapping      = NULL;

    try
    {
        StateFileHandle = CreateFileWithDestinationAcls( m_StateFile, FALSE, FILE_ATTRIBUTE_NORMAL );

        LARGE_INTEGER FileSize;

        if ( !GetFileSizeEx( StateFileHandle, &FileSize ) ) 
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        if ( STATE_FILE_SIZE != FileSize.QuadPart )
            {

            if ( FileSize.QuadPart )
                {
                
                Log( LOG_WARNING, "State file is corrupt" );

                // Clear out the old file bytes

                if ( INVALID_SET_FILE_POINTER == SetFilePointer( StateFileHandle, 0, NULL, FILE_BEGIN ) )
                    throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

                if ( !SetEndOfFile( StateFileHandle ) )
                    throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

                }

            if ( INVALID_SET_FILE_POINTER == SetFilePointer( StateFileHandle, STATE_FILE_SIZE, NULL, FILE_BEGIN ) )
                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            
            // reextend the file

            if ( !SetEndOfFile( StateFileHandle ) )
                {
                HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
                Log( LOG_ERROR, "Unable to extend the state file, error %x", Hr );
                throw ComError( Hr );
                }

            }

        //
        // Map the state file 
        //

        FileMapping =
            CreateFileMapping(
                StateFileHandle,
                NULL,
                PAGE_READWRITE,
                0,
                0,
                NULL );

        if ( !FileMapping )
            {
            HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
            Log( LOG_ERROR, "Unable to map the state file, error %x", Hr );
            throw ComError( Hr );
            }

        m_StateFileStruct =
            (STATE_FILE_STRUCT*)MapViewOfFile(
                FileMapping,
                FILE_MAP_ALL_ACCESS,
                0, 
                0,
                0 );

        if ( !m_StateFileStruct )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        if ( m_StateFileStruct->StateVersion != STATE_FILE_VERSION )
            m_StateFileStruct->Initialize();

        CloseHandle( FileMapping );
        CloseHandle( StateFileHandle );

        return;

    }
    catch( ComError Error )
    {
        
        if ( m_StateFileStruct )
            {
            UnmapViewOfFile( m_StateFileStruct );
            m_StateFileStruct = NULL;
            }

        if ( !FileMapping )
            CloseHandle( FileMapping );
        
        if ( INVALID_HANDLE_VALUE != StateFileHandle )
            CloseHandle( StateFileHandle );

        throw Error;
    }

}

// dispatch routines
void
ServerRequest::CreateSession()
{
   // Handles the Create-Session command from the client.
   // Create a new session and all the directories required to 
   // support that session.

   ValidateProtocol();
   m_SessionId       = BITSCreateGuid();
   m_SessionIdString = BITSStringFromGuid( m_SessionId );
   GeneratePhysicalPaths();

   CheckFilesystemAccess();

   BITSCreateDirectory( (LPCTSTR)m_RequestDirectory );

   OpenStateFile();

   if ( m_DirectoryConfig->m_HostId.Size() )
       {
       
       if ( m_DirectoryConfig->m_HostIdFallbackTimeout != MD_BITS_NO_TIMEOUT )
           {

           SendResponse(
               "Pragma: no-cache\r\n"
               "BITS-Packet-Type: Ack\r\n"
               "BITS-Protocol: %s\r\n"
               "BITS-Session-Id: %s\r\n"
               "BITS-Host-Id: %s\r\n"
               "BITS-Host-Id-Fallback-Timeout: %u\r\n"
               "Content-Length: 0\r\n"
               "Accept-encoding: identity\r\n"
               "\r\n",
               200,
               UPLOAD_PROTOCOL_STRING_V1,
               (const char*)m_SessionIdString, // SessionId
               (const char*)m_DirectoryConfig->m_HostId,
               m_DirectoryConfig->m_HostIdFallbackTimeout
               );

           }
       else
           {

           SendResponse(
               "Pragma: no-cache\r\n"
               "BITS-Packet-Type: Ack\r\n"
               "BITS-Protocol: %s\r\n"
               "BITS-Session-Id: %s\r\n"
               "BITS-Host-Id: %s\r\n"
               "Content-Length: 0\r\n"
               "Accept-encoding: identity\r\n"
               "\r\n",
               200,
               UPLOAD_PROTOCOL_STRING_V1,
               (const char*)m_SessionIdString, // SessionId
               (const char*)m_DirectoryConfig->m_HostId
               );

           }

       }
   else
       {

       SendResponse(
           "Pragma: no-cache\r\n" 
           "BITS-Packet-Type: Ack\r\n"
           "BITS-Protocol: %s\r\n"
           "BITS-Session-Id: %s\r\n"
           "Content-Length: 0\r\n"
           "Accept-encoding: identity\r\n"
           "\r\n",
           200,
           UPLOAD_PROTOCOL_STRING_V1,
           (const char*)m_SessionIdString // SessionId
           );

       }


   LogNewSession( m_SessionId );

}

void
ServerRequest::AddFragment()
{

   // Handles the fragment command from the client.   Opens the cache file
   // and resumes the upload.

   CrackSessionId();
   GeneratePhysicalPaths();

   VerifySessionExists();

   OpenStateFile();
   
   UINT64 RangeStart, RangeLength, TotalLength;
   CrackContentRange( RangeStart, RangeLength, TotalLength );

   if ( RangeStart + RangeLength > TotalLength )
       {
       Log( LOG_ERROR, "Range extends past end of file. Start %I64u, Length %I64u, Total %I64u",
            RangeStart, RangeLength, TotalLength );

       throw ServerException( E_INVALIDARG );
       }

   if ( m_StateFileStruct->UploadFileSize )
       {
       
       //
       // Check to make sure the client didn't try anything tricky and change the size of 
       // the upload on the fly.  If it did, its an error.
       // 

       if ( m_StateFileStruct->UploadFileSize != TotalLength )
           {
           // The client is attempting to change the file size, throw an error
           Log( LOG_ERROR, "Client is attempting to change the file size from %I64u to %I64u",
                m_StateFileStruct->UploadFileSize, TotalLength );

           throw ComError( E_INVALIDARG );
           }

       }
   else
       m_StateFileStruct->UploadFileSize = TotalLength;

   if ( m_StateFileStruct->NotifyCached )
       {

            //
            // The backend was already notified with a reasonable error code.
            // No need to notify it again.
            //

           SendResponseAfterNotification(
                m_StateFileStruct->HttpCode,
                m_StateFileStruct->UploadFileSize,
                m_StateFileStruct->ReplyURLReturned ?
                    m_StateFileStruct->ReplyURL : NULL );
            
           return;

       }

   CheckFilesystemAccess();
   OpenCacheFile();

   UINT64 CacheFileSize = BITSGetFileSize( m_CacheFile );


   if ( CacheFileSize < RangeStart )
       {

       // Can't recover from this error on the server since we have a gap.
       // Need to get the client to backup and start again.

       Log( LOG_INFO, "Client and server are hopelessly out of sync, sending the 416 error code" );

       SendResponse(
           "Pragma: no-cache\r\n"
           "BITS-Packet-Type: Ack\r\n"
           "BITS-Received-Content-Range: %I64u\r\n"
           "Content-Length: 0\r\n"
           "\r\n",
           416,
           CacheFileSize );

       return;

       }

   BITSSetFilePointer( m_CacheFile, 0, FILE_END );

   // Some thought cases for these formulas.
   // 1. RangeLength = 0
   //    BytesToDrain will be 0 and BytesToWrite will be 0
   // 2. RangeStart = CacheFileSize ( most common case )
   //    BytesToDrain will be 0, and BytesToWrite will be BytesToDrain
   // 3. RangeStart < CacheFileSize
   //    BytesToDrain will be nonzero, and BytesToWrite will be the remainder.


   UINT64 BytesToDrain  = min( (CacheFileSize - RangeStart), RangeLength );
   UINT64 BytesToWrite  = RangeLength - BytesToDrain;
   UINT64 WriteOffset   = CacheFileSize;

   // Start the async reader

   m_AsyncReader =
       new AsyncReader(
           this,
           BytesToDrain,
           BytesToWrite,    // bytes to write
           WriteOffset,    // write offset
           m_CacheFile,
           (char*)m_ExtensionControlBlock->lpbData,
           m_ExtensionControlBlock->cbAvailable );

}

// async IO handling

void
ServerRequest::CompleteIO( AsyncReader *Reader, UINT64 TotalBytesRead )
{

    //
    // Called by the AsyncReader when the request finished successfully.
    //

    Log( LOG_INFO, "Async IO operation complete, finishing" );

    try
    {
        if ( TotalBytesRead > m_BytesToDrain )
            m_BytesToDrain = 0; // shouldn't happen, but just in case
        else
            m_BytesToDrain -= TotalBytesRead;

        UINT64 CacheFileSize = BITSGetFileSize( m_CacheFile );

        ASSERT( Reader->GetWriteOffset() == CacheFileSize );

        bool IsLastBlock = ( CacheFileSize == m_StateFileStruct->UploadFileSize );

        if ( IsLastBlock &&
             BITS_NOTIFICATION_TYPE_NONE != m_DirectoryConfig->m_NotificationType )
            {
            CallServerNotification( CacheFileSize );
            }
        else
            {            
            // No server notification to make

            SendResponse(
                "Pragma: no-cache\r\n"
                "BITS-Packet-Type: Ack\r\n"
                "Content-Length: 0\r\n"
                "BITS-Received-Content-Range: %I64u\r\n"
                "\r\n",
                200,
                CacheFileSize );

            }

        if ( IsLastBlock && TotalBytesRead )
            LogUploadComplete( m_SessionId, CacheFileSize );


    }
    catch( ServerException Error )
    {
         SendResponse( Error );
    }
    catch( ComError Error )
    {
        SendResponse( Error );
    }

}

void
ServerRequest::HandleIOError( AsyncReader *Reader, ServerException Error, UINT64 TotalBytesRead )
{

    //
    // Called by AsyncReader when a fatal error occures in processing the request
    //

    Log( LOG_ERROR, "An error occured while handling the async IO" );

    if ( TotalBytesRead > m_BytesToDrain )
        m_BytesToDrain = 0; // shouldn't happen, but just in case
    else
        m_BytesToDrain -= TotalBytesRead;

    SendResponse( Error );
}

void
ServerRequest::SendResponseAfterNotification(
    DWORD HttpStatus,
    UINT64 RequestFileSize,
    const CHAR * ReplyURL )
{

    if ( ReplyURL )
        {

        if ( 200 != HttpStatus )
            {

            SendResponse(
                "Pragma: no-cache\r\n"
                "BITS-Packet-Type: Ack\r\n"
                "Content-Length: 0\r\n"
                "BITS-Received-Content-Range: %I64u\r\n"
                "BITS-Reply-URL: %s\r\n"
                "BITS-Error-Context: 0x7\r\n"
                "\r\n",
                HttpStatus,
                RequestFileSize,
                ReplyURL );

            }
        else
            {

            SendResponse(
                "Pragma: no-cache\r\n"
                "BITS-Packet-Type: Ack\r\n"
                "Content-Length: 0\r\n"
                "BITS-Received-Content-Range: %I64u\r\n"
                "BITS-Reply-URL: %s\r\n"
                "\r\n",
                HttpStatus,
                RequestFileSize,
                ReplyURL );

            }

        }
    else
        {

        if ( 200 != HttpStatus )
            {

            SendResponse(
                "Pragma: no-cache\r\n"
                "BITS-Packet-Type: Ack\r\n"
                "Content-Length: 0\r\n"
                "BITS-Received-Content-Range: %I64u\r\n"
                "BITS-Error-Context: 0x7\r\n"
                "\r\n",
                HttpStatus,
                RequestFileSize );

            }
        else
            {

            SendResponse(
                "Pragma: no-cache\r\n"
                "BITS-Packet-Type: Ack\r\n"
                "Content-Length: 0\r\n"
                "BITS-Received-Content-Range: %I64u\r\n"
                "\r\n",
                HttpStatus,
                RequestFileSize );

            }

        }
}

DWORD
ServerRequest::GetStatusCode( HINTERNET hRequest )
{
    DWORD dwStatus;
    DWORD dwLength = sizeof(dwStatus);

    if (!WinHttpQueryHeaders(hRequest,
                             WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                             WINHTTP_HEADER_NAME_BY_INDEX,
                             &dwStatus,
                             &dwLength,
                             NULL))
        {
        Log( LOG_ERROR, "WinHttpQueryHeaders failed, error %x", HRESULT_FROM_WIN32(GetLastError()) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
        }

    return dwStatus;
}

void
ServerRequest::CallServerNotification( UINT64 CacheFileSize )
{
    
    // Handles notifications and all the exciting pieces to it.

    HRESULT   hr;
    HINTERNET hInternet = NULL;
    HINTERNET hConnect = NULL;
    HINTERNET hRequest = NULL;
    HANDLE hResponseFile = INVALID_HANDLE_VALUE;
    BOOL      fDoResend = FALSE;

    Log( LOG_INFO, "Calling backend notification, type %u",
         m_DirectoryConfig->m_NotificationType );

    try
    {

        BITSCreateDirectory( (LPCTSTR)m_ResponseDirectory );

        if ( BITS_NOTIFICATION_TYPE_POST_BYVAL == m_DirectoryConfig->m_NotificationType )
            {
                // only create the response file if this is a byval notification
                try
                {
                    hResponseFile = CreateFileWithDestinationAcls( m_ResponseFile, TRUE, FILE_ATTRIBUTE_NORMAL);
                }
                catch (ComError Error)
                {
                    HRESULT hr = Error.m_Hr;

                    Log( LOG_ERROR, "Unable to create the response file %s, error %x", (const char*)m_ResponseFile, hr );
                    throw ServerException(hr,0,0x7);
                }
            }

        Log( LOG_INFO, "Connecting to backend for notification" );


        hInternet = WinHttpOpen( BITS_AGENT_NAMEW,
                                 WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
                                 NULL,
                                 NULL,
                                 0 );

        if ( !hInternet )
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            Log( LOG_ERROR, "WinHttpOpen failed, error %x", hr );
            throw ServerException( hr, 0, 0x7 );
            }

        StringHandle  RequestURL  = GetRequestURL();
        StringHandleW NotificationURL;       
         
        if ( m_DirectoryConfig->m_NotificationURL.Size() != 0 )
            {
            // if the a notification URL was set, then combine that URL with the original URL.
            // Otherwise just use the original URL.  This allows BITS to be used to call
            // many arbitrary ASP pages.

            NotificationURL = StringHandleW( 
                                  BITSUrlCombine( RequestURL, m_DirectoryConfig->m_NotificationURL, 
                                                  URL_ESCAPE_UNSAFE  ) );

            }
        else
            {
            NotificationURL = StringHandleW( RequestURL );
            }

        Log( LOG_INFO, "Request URL:      %s", (const char*)StringHandle( RequestURL ) );
        Log( LOG_INFO, "Notification URL: %s", (const char*)StringHandle( NotificationURL ) );

        //
        // Split the URL into server, path, name, and password components.
        //

        HTTPStackStringHandle HostName;
        HTTPStackStringHandle UrlPath;
        HTTPStackStringHandle UserName;
        HTTPStackStringHandle Password;


        URL_COMPONENTS  UrlComponents;
        ZeroMemory(&UrlComponents, sizeof(UrlComponents));

        UrlComponents.dwStructSize        = sizeof(UrlComponents);
        UrlComponents.lpszHostName        = HostName.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwHostNameLength    = INTERNET_MAX_URL_LENGTH + 1;
        UrlComponents.lpszUrlPath         = UrlPath.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwUrlPathLength     = INTERNET_MAX_URL_LENGTH + 1;
        UrlComponents.lpszUserName        = UserName.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwUserNameLength    = INTERNET_MAX_URL_LENGTH + 1;
        UrlComponents.lpszPassword        = Password.AllocBuffer( INTERNET_MAX_URL_LENGTH + 1 );
        UrlComponents.dwPasswordLength    = INTERNET_MAX_URL_LENGTH + 1;


        if ( !WinHttpCrackUrl( NotificationURL,
                               (DWORD)NotificationURL.Size(),
                               0,
                               &UrlComponents ) )
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            Log( LOG_ERROR, "WinHttpCrackURL failed, error %x", hr);
            throw ServerException(hr,0,0x7);
            }

        HostName.SetStringSize();
        UrlPath.SetStringSize();
        UserName.SetStringSize();
        Password.SetStringSize();

        StringHandle QueryString = GetServerVariable( "QUERY_STRING" );

        if ( QueryString.Size() )
            {
            UrlPath += HTTPStackStringHandle( StringHandle("?") );
            UrlPath += HTTPStackStringHandle( QueryString );
            }

        if ( BITS_NOTIFICATION_TYPE_POST_BYREF == m_DirectoryConfig->m_NotificationType )
            CloseCacheFile();

        hConnect = WinHttpConnect( hInternet,
                                   HostName,
                                   UrlComponents.nPort,
                                   0 );

        if ( !hConnect )
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            Log( LOG_ERROR, "WinHttpConnect failed, error %x", hr );
            throw ServerException(hr,0,0x7);
            }


        const WCHAR *AcceptTypes[] = { HTTP_STRING( "*/*" ), NULL };

        hRequest = WinHttpOpenRequest( hConnect,
                                       HTTP_STRING( "POST" ),
                                       UrlPath,
                                       HTTP_STRING( "HTTP/1.1" ),
                                       NULL,
                                       AcceptTypes,
                                       WINHTTP_FLAG_ESCAPE_DISABLE_QUERY ); 
        if ( !hRequest )
            {
            Log( LOG_ERROR, "WinHttpOpenRequest failed, error %x", HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }

        //
        // The autologon policy for WinHttp is by default to not allow authenticated logon 
        // when it thinks the URL is directed to an machine on the internet. Sense this URL is 
        // specifically configured by the administrator, we will allways allow autologin.
        //
        // Note: WinHttp assumes any DNS name with a "dot" in it is an internet (vs. intranet)
        // name.
        //
        DWORD  dwPolicy = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;
        if (!WinHttpSetOption(hRequest,
                              WINHTTP_OPTION_AUTOLOGON_POLICY,
                              &dwPolicy,
                              sizeof(dwPolicy)) )
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            Log( LOG_ERROR, "WinHttpSetOption(WINHTTP_OPTION_AUOTLOGON_POLICY) failed, error %x",hr);
            throw ServerException(hr,0,0x7);
            }


        DWORD dwBufferTotal = (DWORD)CacheFileSize;

        HTTPStackStringHandle AdditionalHeaders = HTTP_STRING( "BITS-Original-Request-URL: " );
        AdditionalHeaders += HTTPStackStringHandle( RequestURL );
        AdditionalHeaders += HTTP_STRING( "\r\n" );

        if ( BITS_NOTIFICATION_TYPE_POST_BYREF == m_DirectoryConfig->m_NotificationType )
            {

            // Add the path to the request datafile name
            AdditionalHeaders += HTTP_STRING( "BITS-Request-DataFile-Name: " );
            AdditionalHeaders += HTTPStackStringHandle( m_RequestFile );
            AdditionalHeaders += HTTP_STRING( "\r\n" );

            // Add the path to where to place the response datafile name
            AdditionalHeaders += HTTP_STRING( "BITS-Response-DataFile-Name: " );
            AdditionalHeaders += HTTPStackStringHandle( m_ResponseFile );
            AdditionalHeaders += HTTP_STRING( "\r\n" );

            dwBufferTotal = 0;
            }

        if ( !WinHttpAddRequestHeaders( hRequest,
                                        AdditionalHeaders,
                                        (DWORD)AdditionalHeaders.Size(),
                                        WINHTTP_ADDREQ_FLAG_ADD | WINHTTP_ADDREQ_FLAG_REPLACE ) )
            {
            Log( LOG_ERROR, "WinHttpAddRequestHeaders failed error %x", HRESULT_FROM_WIN32(GetLastError()) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
            }


        // 
        //  Go ahead and send the Request
        //  Note that for both BYVAL and BYREF cases we will first try without credentials (anonymous request)
        //  if we get a 401, then we will loop again and winhttp will take care of sending the credentials
        //  (autologon policy is set to low)
        //

        if ( dwBufferTotal )
            {
            //
            // BY VAL case
            //
            Log(LOG_INFO, "Making HTTP request with Notification URL for BYVAL case");

            do
                {

                Log( LOG_INFO, "Sending data..." );
    
                fDoResend = FALSE;

                if ( !WinHttpSendRequest( hRequest,
                                          NULL,
                                          0,
                                          NULL,
                                          WINHTTP_NO_REQUEST_DATA,
                                          dwBufferTotal,
                                          0 ) )
                    {
                    Log( LOG_ERROR, "WinHttpSendRequest failed error %x", HRESULT_FROM_WIN32(GetLastError()) );
                    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                    }
    
    
                ReopenCacheFileAsSync();
    
                SetFilePointer( m_CacheFile, 0, NULL, FILE_BEGIN );
    
                DWORD BytesRead;
                DWORD TotalRead = 0;
                do
                    {
                    BOOL b;
    
                    if  (!(b = ReadFile (m_CacheFile,
                                         m_NotifyBuffer,
                                         sizeof(m_NotifyBuffer),
                                         &BytesRead,
                                         NULL)))
                        {
                        Log( LOG_ERROR, "ReadFile failed, error %x",
                             HRESULT_FROM_WIN32( GetLastError() ) );
                        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                        }
    
                    TotalRead += BytesRead;
    
                    if (BytesRead > 0)
                        {
    
                        DWORD BytesWritten;
                        DWORD TotalWritten = 0;
    
                        do
                            {
    
                            if (!(b = WinHttpWriteData( hRequest,
                                                        m_NotifyBuffer + TotalWritten,
                                                        BytesRead - TotalWritten,
                                                        &BytesWritten)))
                                {
                                Log( LOG_ERROR, "WinHttpWriteData failed, error %x",
                                     HRESULT_FROM_WIN32( GetLastError() ) );
                                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                                }
    
                            TotalWritten += BytesWritten;
    
                            } while( TotalWritten != BytesRead );
                        }
                    }
                while ( TotalRead < dwBufferTotal );
    
                //
                // Note: On slow connections, it is possible to receive a 100-Continue status after
                // receiving the headers. If that happens, then we want to skip the response and do
                // the WinHttpReceiveResponse again to get the final response/status.
                //
                for (int i=0; i<2; i++)
                    {
                    if (!WinHttpReceiveResponse(hRequest,0))
                        {
                        DWORD dwError = GetLastError();

                        //
                        // Note that 401 will be a case for RESEND.
                        // We don't need to set credentials explicitly because our autologon policy
                        // is set to LOW and winhttp will automatically grab the NTLM credentials
                        // for us
                        //
                        if (dwError == ERROR_WINHTTP_RESEND_REQUEST)
                            {
                            Log( LOG_INFO, "WinHttpReceiveResponse failed with ERROR_RESEND_REQUEST" );

                            // here we go: do the main loop again and resend 
                            fDoResend = TRUE;
                            break;
                            }
                        else
                            {
                            Log( LOG_ERROR, "WinHttpReceiveResponse failed, error %x", HRESULT_FROM_WIN32(GetLastError()) );
                            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                            }
                        }

                    //
                    // Get the status code from the response and decide what to do next
                    //
                    DWORD dwStatus = GetStatusCode(hRequest);
                    if (dwStatus != HTTP_STATUS_CONTINUE)
                        {
                        // don't do the Receive one more time
                        break;
                        }
                    }
                } while (fDoResend);
            }
        else
            {
            //
            // BY REF case
            //
            Log(LOG_INFO, "Making HTTP request with Notification URL for BYREF case");

            BOOL fRepeat;
            do
                {
                fRepeat = FALSE;

                if ( !WinHttpSendRequest( hRequest,
                                          NULL,
                                          0,
                                          NULL,
                                          0,
                                          0,
                                          0) )
                    {
                    Log( LOG_ERROR, "WinHttpSendRequest failed, error %x", HRESULT_FROM_WIN32(GetLastError()) );
                    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0,0x7 );
                    }

                if (!WinHttpReceiveResponse(hRequest, 0) )
                    {
                    DWORD dwError = GetLastError();

                    //
                    // Note that 401 will be a case for RESEND.
                    // We don't need to set credentials explicitly because our autologon policy
                    // is set to LOW and winhttp will automatically grab the NTLM credentials
                    // for us
                    //
                    if (dwError == ERROR_WINHTTP_RESEND_REQUEST)
                        {
                        Log( LOG_INFO, "WinHttpReceiveResponse failed with ERROR_RESEND_REQUEST" );
                        // repeat the loop
                        fRepeat = TRUE;
                        }
                    else
                        {
                        Log( LOG_ERROR, "WinHttpReceiveResponse failed, error %x", HRESULT_FROM_WIN32(GetLastError()) );
                        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                        }
                    }
                } while (fRepeat);

            }

        //
        // Check for a BITS-Static-Response-URL. If a static response is given,
        // remove the response file and format URL
        //

        bool HasStaticResponse = TestResponseHeader( hRequest, HTTP_STRING( "BITS-Static-Response-URL" ) );

        if ( HasStaticResponse )
            {

            if ( INVALID_HANDLE_VALUE != hResponseFile )
                {
                CloseHandle( hResponseFile );
                hResponseFile = INVALID_HANDLE_VALUE;
                BITSDeleteFile( m_ResponseFile );
                }

            }

        //
        // drain the pipe.
        //

        Log( LOG_INFO, "Processing backend response" );

        DWORD dwStatus = GetStatusCode(hRequest);

        DWORD BytesRead;
        DWORD BytesWritten;
        do
            {

            if (!WinHttpReadData( hRequest,
                                  m_NotifyBuffer,
                                  sizeof( m_NotifyBuffer ),
                                  &BytesRead ))
                {
                Log( LOG_ERROR, "InternetReadFile failed, error %x", HRESULT_FROM_WIN32(GetLastError()) );
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                }

            if ( INVALID_HANDLE_VALUE != hResponseFile )
                {

                if ( !WriteFile(
                        hResponseFile,
                        m_NotifyBuffer,
                        BytesRead,
                        &BytesWritten,
                        NULL ) )
                    {
                    Log( LOG_ERROR, "WriteFile failed, error %x",
                         HRESULT_FROM_WIN32( GetLastError() ) );
                    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ), 0, 0x7 );
                    }

                }

            }
        while ( BytesRead > 0 );


        //
        // Retrieve or compute the reply URL( the default is to use self-relative form).
        //

        StringHandle ReplyURL;

        if ( HasStaticResponse )
            {
            ReplyURL = GetResponseHeader( hRequest, HTTP_STRING( "BITS-Static-Response-URL" ) );
            }
        else
            {

            if ( INVALID_FILE_ATTRIBUTES != GetFileAttributes( m_ResponseFile ) )
                {

                //
                // Build the relative reply URL
                //

                DWORD URLDepth = m_URLDepth;
                
                if ( URLDepth )  // The last part is automatically stripped with 
                    URLDepth--;  // relative URLs

                while( URLDepth-- )
                    {
                    ReplyURL += "..\\";
                    }

                ReplyURL += m_DirectoryConfig->m_ConnectionsDir;
                ReplyURL += "\\";
                ReplyURL += REPLIES_DIR_NAME;
                ReplyURL += "\\";
                ReplyURL += m_SessionIdString;
                ReplyURL += "\\";
                ReplyURL += RESPONSE_FILE_NAME;

                }
            }

        if ( TestResponseHeader( hRequest, HTTP_STRING( "BITS-Copy-File-To-Destination" ) ) )
            {
            BITSRenameFile( m_RequestFile,
                            m_DestinationFile,
                            m_DirectoryConfig->m_AllowOverwrites );
            }

        WinHttpCloseHandle( hRequest );
        WinHttpCloseHandle( hConnect );
        WinHttpCloseHandle( hInternet );
        hRequest = hInternet = hConnect = NULL;

        if ( INVALID_HANDLE_VALUE != hResponseFile )
            CloseHandle( hResponseFile );

        hResponseFile = INVALID_HANDLE_VALUE;


        if ( ReplyURL.Size() > INTERNET_MAX_URL_LENGTH )
            {
            Log( LOG_ERROR, "The reply URL is too long." );
            throw ComError( E_INVALIDARG );
            }

        //
        // Cache the notification response if the error code is
        // 200 or 403
        //
        if ( 200 == dwStatus ||
             403 == dwStatus )
            {

            m_StateFileStruct->HttpCode = dwStatus;

            if ( ReplyURL.Size() )
                {
                StringCchCopy( m_StateFileStruct->ReplyURL, INTERNET_MAX_URL_LENGTH+1,
                               (const CHAR*)ReplyURL );
                m_StateFileStruct->ReplyURLReturned = TRUE;
                }

            m_StateFileStruct->NotifyCached = TRUE;

            }

#if 0
        // test caching of reply values
        throw ComError( E_FAIL );
#endif

        if ( ReplyURL.Size() )
            {

            Log( LOG_INFO, "The backend supplied a response url, send client response including URL" );

            SendResponseAfterNotification(
                dwStatus,
                CacheFileSize,
                (const char*)ReplyURL );

            }
        else
            {

            Log( LOG_INFO, "The backend didn't supply a response URL, sending simple client response" );

            SendResponseAfterNotification(
                dwStatus,
                CacheFileSize,
                NULL );

            }


    }
    catch( const ComError & )
    {
        // cleanup

        if ( INVALID_HANDLE_VALUE != hResponseFile )
            {
            CloseHandle( hResponseFile );
            hResponseFile = INVALID_HANDLE_VALUE;
            }

        DeleteFile( m_ResponseFile );


        if ( hRequest )
            WinHttpCloseHandle( hRequest );

        if ( hConnect )
            WinHttpCloseHandle( hConnect );

        if ( hInternet )
            WinHttpCloseHandle( hInternet );

        throw;
    }

}

bool
ServerRequest::TestResponseHeader( HINTERNET hRequest,
                                   const WCHAR *Header )
{

    // test for a header in the notification response.   If the header is 
    // found return true, false if not.   Throw an exception on an error.

    SIZE_T HeaderSize = wcslen(Header) + 2;
    WorkStringBufferW WorkStringBufferData( HeaderSize );
    WCHAR *HeaderDup = (WCHAR *)WorkStringBufferData.GetBuffer();
    memcpy( HeaderDup, Header, ( HeaderSize - 1 ) * sizeof( WCHAR ) );

    DWORD BufferLength = (DWORD)HeaderSize;

    BOOL Result = WinHttpQueryHeaders( hRequest,
                                       WINHTTP_QUERY_CUSTOM,
                                       Header,
                                       HeaderDup,
                                       &BufferLength,
                                       NULL );

    if ( Result )
        return true;

    DWORD dwLastError = GetLastError();

    if ( ERROR_INSUFFICIENT_BUFFER == dwLastError )
        return true;

    if ( ERROR_WINHTTP_HEADER_NOT_FOUND == dwLastError )
        return false;

    Log( LOG_ERROR, "Unable to test response header %s, error %x",
         (const char*) StringHandle( Header ), HRESULT_FROM_WIN32( GetLastError() ) );

    throw ServerException( HRESULT_FROM_WIN32( dwLastError ) );
}

StringHandle
ServerRequest::GetResponseHeader( HINTERNET    hRequest,
                                  const WCHAR *Header )
{

    // Retrieve a header from a notification response.   If the header is not
    // found or an other error occures, throw an exception.

    SIZE_T HeaderSize = wcslen( Header );
    DWORD  BufferLength = (DWORD)( ( HeaderSize + 1024 ) & ~( 1024 - 1 ) );

    HTTPStackStringHandle RetVal;

    while(1)
        {

        WCHAR *Buffer = RetVal.AllocBuffer( BufferLength );

        memcpy( Buffer, Header, ( HeaderSize + 1 ) * sizeof( WCHAR ) );

        BOOL Result = WinHttpQueryHeaders( hRequest,
                                           WINHTTP_QUERY_CUSTOM,
                                           Header,
                                           Buffer,
                                           &BufferLength,
                                           NULL );

        if ( Result )
            {
            RetVal.SetStringSize();
            return StringHandle( RetVal );
            }

        DWORD dwError = GetLastError();

        if ( ERROR_INSUFFICIENT_BUFFER != dwError )
            {

            Log( LOG_ERROR, "Unable to get response header %s, error %x",
                 ( const char *) StringHandle( Header ), HRESULT_FROM_WIN32( GetLastError() ) );

            throw ServerException( HRESULT_FROM_WIN32( dwError ) );
            }

        RetVal = HTTPStackStringHandle();

        if ( BufferLength > BITS_MAX_HEADER_SIZE )
            {
            Log( LOG_ERROR, "The returned header is larger then the maximum size" );
            throw ServerException( E_INVALIDARG );
            }

        }

}

void
ServerRequest::VerifySessionExists()
{
    
    WIN32_FILE_ATTRIBUTE_DATA FileInformation;

    if ( !GetFileAttributesEx(
             (const char*)m_RequestDirectory,
             GetFileExInfoStandard,
             (LPVOID)&FileInformation ) )
        {

        DWORD dwError = GetLastError();

        Log( LOG_ERROR, "Error validation on session directory, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );

        if ( ERROR_PATH_NOT_FOUND == dwError ||
             ERROR_FILE_NOT_FOUND == dwError )
            {
            Log( LOG_ERROR, "Session directory is missing" );
            throw ServerException( BG_E_SESSION_NOT_FOUND );
            }

        throw ServerException( HRESULT_FROM_WIN32( dwError ) );

        }

    if ( !( FileInformation.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
        {
        Log( LOG_ERROR, "Session directory is missing" );
        throw ServerException( BG_E_SESSION_NOT_FOUND );
        }        

}

void
ServerRequest::CloseSession()
{
   
   // Handles the Close-Session command from the client.  

   CrackSessionId();
   GeneratePhysicalPaths();

   VerifySessionExists();

   if ( BITS_NOTIFICATION_TYPE_NONE == m_DirectoryConfig->m_NotificationType )
       {
       BITSRenameFile( m_RequestFile,
                       m_DestinationFile,
                       m_DirectoryConfig->m_AllowOverwrites );
       }
   else
       {
       BITSDeleteFile( m_RequestFile );
       }

   BITSDeleteFile( m_ResponseFile );
   BITSDeleteFile( m_StateFile );

   RemoveDirectory( m_RequestDirectory );
   RemoveDirectory( m_ResponseDirectory );

   SendResponse(
       "Pragma: no-cache\r\n"
       "BITS-Packet-Type: Ack\r\n"
       "Content-Length: 0\r\n"
       "\r\n" );

   LogSessionClose( m_SessionId );

}

void
ServerRequest::CancelSession()
{
    // Handles the Cancel-Session command from the client.  Deletes
    // all the temporary files, of the current state.

    CrackSessionId();
    GeneratePhysicalPaths();

    VerifySessionExists();

    BITSDeleteFile( m_ResponseFile );
    BITSDeleteFile( m_RequestFile );
    BITSDeleteFile( m_StateFile );
    
    RemoveDirectory( m_RequestDirectory );
    RemoveDirectory( m_ResponseDirectory );

    SendResponse(
        "Pragma: no-cache\r\n"
        "BITS-Packet-Type: Ack\r\n"
        "Content-Length: 0\r\n"
        "\r\n" );

    LogSessionCancel( m_SessionId );

}

void
ServerRequest::Ping()
{
    // Handles the Ping command which is essentually just a no-op.

   SendResponse(
       "Pragma: no-cache\r\n"
       "BITS-Packet-Type: Ack\r\n"
       "Content-Length: 0\r\n"
       "\r\n" );

}

CHAR *
ServerRequest::BasePathOf(const CHAR *pPath)
{
    CHAR *pBasePath;

    if (!pPath)
        {
        return NULL;
        }

    if (  (pBasePath=strrchr(pPath,'/'))
       || (pBasePath=strrchr(pPath,'\\')) )
        {
        pBasePath++;
        }
    else
        {
        pBasePath = (char *)pPath;
        }

    return pBasePath;
}

StringHandle
ServerRequest::GeneratePathInDestinationDir(LPCSTR szOriginalPath)
{
    StringHandle        NewPath;
    StringHandle        TempFileGuid;
    CHAR  *pFilePart  = NULL;
    GUID  guidTempFile;

    if ( !szOriginalPath )
        {
        Log( LOG_ERROR, "Unexpected NULL path was detected" );
        throw ServerException( E_INVALIDARG );
        }

    pFilePart   = BasePathOf(szOriginalPath);

    //
    // This will create a file name in the form
    // <destinationdir>\bitssrv_<guid>_<filename>
    // We add the GUID to avoid colision with other threads
    // Note that we won't be using the session GUID to avoid disclosuring the session id.
    // Instead, we will be using a new and random guid.
    //
    guidTempFile  = BITSCreateGuid();
    TempFileGuid  = BITSStringFromGuid( guidTempFile );


    NewPath     = m_DestinationDirectory + 
                  StringHandle("bitssrv") +
                  StringHandle("_") +
                  TempFileGuid + 
                  StringHandle("_") +
                  StringHandle(pFilePart);

    return NewPath;
}

void
ServerRequest::GeneratePhysicalPaths()
{

    const CHAR *PathTranslated = m_ExtensionControlBlock->lpszPathTranslated;
    
    {

        StringHandle DestinationPath;
        CHAR *FilePart = NULL;
        DWORD BufferLength = MAX_PATH;

        while( 1 )
            {
            
            CHAR *PathBuffer = DestinationPath.AllocBuffer( BufferLength );

            DWORD Result =
                GetFullPathName(
                    m_ExtensionControlBlock->lpszPathTranslated,
                    BufferLength,
                    PathBuffer,
                    &FilePart );

            if ( Result > BufferLength )
                {
                BufferLength = Result;
                continue;
                }

            if ( !Result )
                {
                Log( LOG_ERROR, "Unable to get the full path name for %s, error 0x%8.8X",
                     m_ExtensionControlBlock->lpszPathTranslated, HRESULT_FROM_WIN32( GetLastError() ) );
                throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
                }

            if ( !FilePart )
                {
                Log( LOG_ERROR, "Uploading to directories are not supported" );
                throw ServerException( E_INVALIDARG );
                }

            m_DestinationFile       = PathBuffer;
            *FilePart = '\0';
            m_DestinationDirectory  = PathBuffer;

            break;

            }


    }

    // perform some basic tests on the file name

    DWORD Attributes =
        GetFileAttributes( m_DestinationFile );

    if ( (DWORD)INVALID_FILE_ATTRIBUTES == Attributes )
        {

        if ( ( GetLastError() != ERROR_FILE_NOT_FOUND ) &&
             ( GetLastError() != ERROR_ACCESS_DENIED ) )
            {

            Log( LOG_ERROR, "Unable to get the file attributes for %s, error 0x%8.8X",
                 m_ExtensionControlBlock->lpszPathTranslated, HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

            }

        }
    else
        {

        // file exists, check if its a directory

        if ( FILE_ATTRIBUTE_DIRECTORY & Attributes )
            {
            Log( LOG_ERROR, "Uploading to directories are not supported" );
            throw ServerException( E_INVALIDARG );
            }

        // deny access if the ability to overwrite existing files is turned off

        if ( !m_DirectoryConfig->m_AllowOverwrites &&
             ( BITS_NOTIFICATION_TYPE_NONE == m_DirectoryConfig->m_NotificationType ) )
            {
            Log( LOG_ERROR, "The destination exists, but the ability to allow overwrites is turned off" );
            throw ServerException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) );
            }

        }

    // validate that the physical path is below the virtual directory root
    {

        SIZE_T VDirPathSize = m_DirectoryConfig->m_PhysicalPath.Size();

        if ( _strnicmp( m_DirectoryConfig->m_PhysicalPath, m_DestinationDirectory, VDirPathSize ) != 0 )
            {
            Log( LOG_ERROR, "Path is not below the virtual directory root, error" );
            throw ServerException( E_INVALIDARG );
            }
    }

    // validate that the physical path does not end with a slash or colon
    {
        SIZE_T PathSize = strlen( PathTranslated );

        if ( PathSize )
            {

            if ( '\\' == PathTranslated[ PathSize - 1 ] ||
                 '/' == PathTranslated[ PathSize - 1 ] )
                {
                Log( LOG_ERROR, "Path can not end with a slash" );
                throw ServerException( E_INVALIDARG );
                }

            if ( ':' == PathTranslated[ PathSize - 1 ] )
                {
                Log( LOG_ERROR, "Path may not end with a colon" );
                throw ServerException( E_INVALIDARG );
                }

            }

    }

    m_RequestDirectory              = m_DirectoryConfig->m_RequestsDir + StringHandle("\\") +
                                      m_SessionIdString;
    m_RequestFile                   = m_RequestDirectory + StringHandle("\\") +
                                      StringHandle( REQUEST_FILE_NAME );

    m_StateFile                     = m_RequestDirectory + StringHandle("\\") +
                                      StringHandle( STATE_FILE_NAME );

    m_ResponseDirectory             = m_DirectoryConfig->m_RepliesDir + StringHandle("\\") +
                                      m_SessionIdString;
    m_ResponseFile                  = m_ResponseDirectory + StringHandle("\\") +
                                      StringHandle(RESPONSE_FILE_NAME);

    // validate that the physical path is not inside the cache directory
    {

        SIZE_T SessionDirSize = m_DirectoryConfig->m_SessionDir.Size();

        if ( _strnicmp( (const char*)m_DirectoryConfig->m_SessionDir, 
                        (const char*)m_DestinationDirectory, SessionDirSize ) == 0 )
            {
            Log( LOG_ERROR, "Path can not be inside the cache directory" );
            throw ServerException( HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) );
            }

    }

}

void
ServerRequest::CheckFilesystemAccess()
{

    if ( !m_ImpersonationToken )
        return;

    PSECURITY_DESCRIPTOR pSd = NULL;

    DWORD Result =
        GetNamedSecurityInfo(
            (char*)(const char*)m_DestinationDirectory,
            SE_FILE_OBJECT,
            DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION,
            NULL,
            NULL,
            NULL,
            NULL,
            &pSd );

    // If we can't read the SD, assume that everything is ok
    if ( ERROR_ACCESS_DENIED == Result )
        {
        Log( LOG_WARNING, "Assuming access is granted, let later operations fail" );
        return;
        }

    GENERIC_MAPPING FileMapping =
        {
        FILE_GENERIC_READ,
        FILE_GENERIC_WRITE,
        FILE_GENERIC_EXECUTE,
        FILE_ALL_ACCESS
        };
    
   BYTE PrivilageBuffer[ sizeof( PRIVILEGE_SET ) + sizeof( LUID_AND_ATTRIBUTES ) ];

   DWORD PrivilegeSetLength = sizeof( PrivilageBuffer );    // size of privileges buffer
   DWORD GrantedAccess = 0;                                 // granted access rights
   BOOL AccessStatus = FALSE;                               // result of access check
   


   if ( !AccessCheck(
        pSd,                                      // SD
        m_ImpersonationToken,                     // handle to client access token
        FILE_WRITE_DATA,                          // requested access rights 
        &FileMapping,                             // mapping
        (PPRIVILEGE_SET)PrivilageBuffer,          // privileges
        &PrivilegeSetLength,                      // size of privileges buffer
        &GrantedAccess,                           // granted access rights
        &AccessStatus                             // result of access check
        ) )
       {

       HRESULT Error = HRESULT_FROM_WIN32( GetLastError() );
       Log( LOG_ERROR, "Unable to check access, error 0x%8.8X", Error );
       LocalFree( pSd );
       throw ComError( Error );
       
       }

   LocalFree( pSd );

   if ( !AccessStatus )
       {
       Log( LOG_ERROR, "Denying access since the caller does not have create file rights" );
       throw ServerException( E_ACCESSDENIED, 403 );
       }

}

HANDLE
ServerRequest::CreateFileWithDestinationAcls(const CHAR *szOriginalFile, DWORD fOnlyCreateNew, DWORD dwAttributes)
{
    CHAR  *pFile              = const_cast<char *>(szOriginalFile);
    DWORD  dwDispositionFlags = OPEN_EXISTING;
    BOOL   fRetry             = FALSE;
    HANDLE hFile              = INVALID_HANDLE_VALUE;
    StringHandle TempPath;

    if (fOnlyCreateNew)
        {
        TempPath = GeneratePathInDestinationDir(szOriginalFile);

        pFile               = const_cast<char *>(static_cast<const char *>(TempPath));
        dwDispositionFlags  = CREATE_ALWAYS;
        }

    //
    // Open the file.
    // If the file exists, we will leave it alone an assume the Acls are correct
    // Otherwise we will create the file first in m_DestinationDir so it has the VDIR Acls,
    // and then move it to the proper directory.
    //
    do
        {
        fRetry = FALSE;

        hFile =
            CreateFile(
                pFile,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                dwDispositionFlags,
                dwAttributes,
                NULL );

        if (hFile == INVALID_HANDLE_VALUE)
            {
            DWORD dwError = GetLastError();

            //
            // if we are creating the file, we want to create it in the DestinationDir
            // so it has the right ACLs, and then move it to the right directory.
            //
            if (!fOnlyCreateNew && dwError == ERROR_FILE_NOT_FOUND)
                {
                TempPath = GeneratePathInDestinationDir(szOriginalFile);

                pFile               = const_cast<char *>(static_cast<const char *>(TempPath));
                dwDispositionFlags  = CREATE_ALWAYS;
                fRetry              = TRUE;
                
                Log( LOG_INFO, "First time creating file. Will create file first at %s", pFile);
                continue;
                }
            else
                {
                Log( LOG_ERROR, "Unable to open file %s, error 0x%8.8X", pFile, HRESULT_FROM_WIN32( dwError ));
                throw ComError( HRESULT_FROM_WIN32( dwError ) );
                }

            }
        } while (fRetry);


    //
    // Ok, we are done opening the file, now see if we need to move the file to 
    // the right location. 
    // Unfortunately, because we want to open the file with no sharing allowed, we need to close
    // the handle and reopen it.
    //
    if (dwDispositionFlags == CREATE_ALWAYS)
        {
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;

        if (!MoveFile(pFile, szOriginalFile))
            {
            DWORD dwError = GetLastError();

            DeleteFile(pFile);

            Log( LOG_ERROR, "Unable to move file from %s to %s, error 0x%8.8X", 
                pFile, szOriginalFile, HRESULT_FROM_WIN32( dwError ));

            throw ComError( HRESULT_FROM_WIN32( dwError ) );
            }

        hFile =
            CreateFile(
                szOriginalFile,
                GENERIC_READ | GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                dwAttributes,
                NULL );

        if (hFile == INVALID_HANDLE_VALUE)
            {
            DWORD dwError = GetLastError();

            Log( LOG_ERROR, "Unable to open file %s, error 0x%8.8X", szOriginalFile, HRESULT_FROM_WIN32( dwError ));
            throw ComError( HRESULT_FROM_WIN32( dwError ) );
            }
        }

    return hFile;
}

void
ServerRequest::OpenCacheFile( )
{

    // Open the cache file.

    try
    {
        m_CacheFile = CreateFileWithDestinationAcls( m_RequestFile, FALSE, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED );
    }
    catch (ComError Error)
    {
        DWORD dwError = Error.m_Hr;

        if (dwError == ERROR_PATH_NOT_FOUND)
            {
            throw ServerException( BG_E_SESSION_NOT_FOUND );
            }

        throw ServerException( Error.m_Hr );
    }
}

void
ServerRequest::ReopenCacheFileAsSync()
{

    // reopen the cache file as async so that it can be spooled synchronously over
    // to the backend.

    CloseCacheFile();

    m_CacheFile =
        CreateFile(
            m_RequestFile,
            GENERIC_READ | GENERIC_WRITE,
            0,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL );

    if ( INVALID_HANDLE_VALUE == m_CacheFile )
        {
        Log( LOG_ERROR, "Unable to reopen cache file %s, error 0x%8.8X",
             (const char*)m_RequestFile,
             HRESULT_FROM_WIN32( GetLastError() ) );

        if (GetLastError() == ERROR_PATH_NOT_FOUND)
            {
            throw ServerException( BG_E_SESSION_NOT_FOUND );
            }

        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }
}

void
ServerRequest::CloseCacheFile()
{

    // Close the cache file, if it isn't already closed.

    if ( INVALID_HANDLE_VALUE != m_CacheFile )
        {
        if ( CloseHandle( m_CacheFile ) )
            m_CacheFile = INVALID_HANDLE_VALUE;

        }
}


void
ServerRequest::ForwardComplete(
  LPEXTENSION_CONTROL_BLOCK lpECB,
  PVOID pContext,
  DWORD cbIO,
  DWORD dwError)
{

    // A do nothing callback for forwarding the request.

    ServerRequest *This = (ServerRequest*)pContext;
    This->Release( );
}

void
ServerRequest::ForwardToNextISAPI()
{

    // IIS6 has changed behavior where the limit on * entries are ignored.
    // To work around this problem, it is necessary to send the request back
    // to IIS.


    BOOL Result;

    Result =
        (*m_ExtensionControlBlock->ServerSupportFunction)(
                m_ExtensionControlBlock->ConnID,
                HSE_REQ_IO_COMPLETION,
                (LPVOID)ForwardComplete,
                0,
                (LPDWORD)this );

    if ( !Result )
        {
        Log( LOG_ERROR, "Unable to set callback to ForwardComplete, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }


    HSE_EXEC_URL_INFO ExecInfo;
    memset( &ExecInfo, 0, sizeof( ExecInfo ) );

#define HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR     0x04
    ExecInfo.dwExecUrlFlags = HSE_EXEC_URL_IGNORE_CURRENT_INTERCEPTOR;

    ScheduleAsyncOperation(
        HSE_REQ_EXEC_URL,
        (LPVOID)&ExecInfo,
        NULL,
        NULL );

    return;

}

void
ServerRequest::GetConfig()
{

    // Looks up the configuration to use for this request.  

    StringHandle InstanceMetaPath   = GetServerVariable( "INSTANCE_META_PATH" );
    StringHandle URL                = GetServerVariable( "URL" );

    m_DirectoryConfig = g_ConfigMan->GetConfig( InstanceMetaPath, URL, &m_URLDepth );

}

void
ServerRequest::DispatchRequest()
{

    //
    // The main do it function,  parse what kind of request the client is sending and
    // dispatch it to the appropiate handler routines. 
    //

    // This critical section is needed because IIS callbacks can happen on any time.
    // The lock is needed to prevent a callback from happening while the dispatch
    // routine is still running.

    CriticalSectionLock CSLock( &m_cs );

    try
    {

        if ( _stricmp( m_ExtensionControlBlock->lpszMethod, BITS_COMMAND_VERBA ) != 0 )
            {
            Log( LOG_CALLBEGIN, "Connection %p, Packet-Type: %s, Method: %s, Path %s",
                                m_ExtensionControlBlock->ConnID,
                                (const char*)"UNKNOWN",
                                m_ExtensionControlBlock->lpszMethod,
                                m_ExtensionControlBlock->lpszPathTranslated );

            ForwardToNextISAPI();
            return;
            }

        m_PacketType            = GetServerVariable( "HTTP_BITS-PACKET-TYPE" );

        Log( LOG_CALLBEGIN, "Connection %p, Packet-Type: %s, Method: %s, Path %s",
                            m_ExtensionControlBlock->ConnID,
                            (const char*)m_PacketType,
                            m_ExtensionControlBlock->lpszMethod,
                            m_ExtensionControlBlock->lpszPathTranslated );

        if (! m_ExtensionControlBlock->ServerSupportFunction(
                  m_ExtensionControlBlock->ConnID,
                  HSE_REQ_GET_IMPERSONATION_TOKEN,
                  &m_ImpersonationToken,
                  NULL,
                  NULL ) )
            {
            Log( LOG_ERROR, "Unable to get the impersonation token" );
            throw ServerException( HRESULT_FROM_WIN32( E_INVALIDARG ) );
            }

        GetConfig();

        if ( !m_DirectoryConfig->m_UploadEnabled )
            {
            Log( LOG_ERROR, "BITS uploads are not enabled" );
            throw ServerException( E_ACCESSDENIED, 501 );
            }

        if ( m_DirectoryConfig->m_ExecutePermissions & ( MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT ) )
            {
            Log( LOG_ERROR, "BITS uploads are disable because execute or script access is enabled" );
            LogExecuteEnabled();
            throw ServerException( BG_E_SERVER_EXECUTE_ENABLE, 403 );
            }

        StringHandle ContentLength = GetServerVariable( "HTTP_Content-Length" );
        if ( 1 != sscanf( (const char*)ContentLength, "%I64u", &m_ContentLength ) )
            {
            Log( LOG_ERROR, "The content length is broken" );
            throw ServerException( E_INVALIDARG );
            }


        if ( m_ContentLength < m_ExtensionControlBlock->cbAvailable )
            throw ServerException( E_INVALIDARG );

        m_BytesToDrain = m_ContentLength - m_ExtensionControlBlock->cbAvailable;


        //
        // Dispatch to the correct method
        //
        // Create-session
        // fragment
        // Get-Reply-Url
        // Close-Session
        // Cancel-Session
        // Ping ( Is server alive )

        // keep this list ordered by frequency

        if ( _stricmp( m_PacketType, PACKET_TYPE_FRAGMENT ) == 0 )
            AddFragment();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_PING ) == 0 )
            Ping();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_CREATE_SESSION ) == 0 )
            CreateSession();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_CLOSE_SESSION ) == 0 )
            CloseSession();
        else if ( _stricmp( m_PacketType, PACKET_TYPE_CANCEL_SESSION ) == 0 )
            CancelSession();
        else
            {

            Log( LOG_ERROR, "Received unknown BITS packet type %s",
                 (const char*)m_PacketType );

            throw ServerException( E_INVALIDARG );

            }


    }

    catch( ServerException Exception )
    {
         SendResponse( Exception );
    }
    catch( ComError Exception )
    {
         SendResponse( Exception );
    }

}

//
// IIS Logger functions
//

void IISLogger::LogString( const char *String, int Size )
{
   DWORD StringSize = Size + 1;

   (*m_ExtensionControlBlock->ServerSupportFunction)
   (
       m_ExtensionControlBlock->ConnID,
       HSE_APPEND_LOG_PARAMETER,
       (LPVOID)String,
       &StringSize,
       NULL
   );

}

void IISLogger::LogError( ServerException Error )
{

   char OutputStr[ 255 ];

   StringCbPrintfA( 
        OutputStr,
        sizeof( OutputStr ),
        "(bits_error:,%u,0x%8.8X)", 
        Error.GetHttpCode(),
        Error.GetCode() );

   LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogError( const GUID & SessionID, ServerException Error )
{

   WCHAR GuidStr[ 50 ];
   char OutputStr[ 255 ];

   StringFromGUID2( SessionID, GuidStr, 50 );

   StringCchPrintfA( 
        OutputStr,
        sizeof( OutputStr ),
        "(bits_error:%S,%u,0x%8.8X)",
        GuidStr,
        Error.GetHttpCode(),
        Error.GetCode() );

   LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogNewSession( const GUID & SessionID )
{

    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );
    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_new_session:%S)", 
        GuidStr );

    LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogUploadComplete( const GUID & SessionID, UINT64 FileSize )
{

    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );

    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_upload_complete:%S,%I64u)", 
        GuidStr, 
        FileSize );
    LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogSessionClose( const GUID & SessionID )
{

    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );

    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_close_session:%S)",
        GuidStr );
    LogString( OutputStr, strlen( OutputStr ) );

}

void IISLogger::LogSessionCancel( const GUID & SessionID )
{
    WCHAR GuidStr[ 50 ];
    char OutputStr[ 255 ];

    StringFromGUID2( SessionID, GuidStr, 50 );
    StringCbPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_cancel_session:%S)", 
        GuidStr );
    LogString( OutputStr, strlen( OutputStr ) );
}

void IISLogger::LogExecuteEnabled()
{
    char OutputStr[ 255 ];

    StringCchPrintfA( 
        OutputStr, 
        sizeof( OutputStr ),
        "(bits_execute_enabled)" );

    LogString( OutputStr, strlen( OutputStr ) );
}

ServerRequest *g_LastRequest = NULL;

//
// AsyncReader functions
//

AsyncReader::AsyncReader(
    ServerRequest *Request,
    UINT64 BytesToDrain,
    UINT64 BytesToWrite,
    UINT64 WriteOffset,
    HANDLE WriteHandle,
    char *PrereadBuffer,
    DWORD PrereadSize ) :
m_Request( Request ),
m_BytesToDrain( BytesToDrain ),
m_BytesToWrite( BytesToWrite ),
m_WriteOffset( WriteOffset ),
m_ReadOffset( WriteOffset ),
m_WriteHandle( WriteHandle ),
m_BytesToRead( BytesToWrite ),
m_PrereadBuffer( PrereadBuffer ),
m_PrereadSize( PrereadSize ),
m_OperationsPending( 0 ),
m_ReadBuffer( 0 ),
m_WriteBuffer( 0 ),
m_BuffersToWrite( 0 ),
m_Error( S_OK ),
m_WritePending( false ),
m_ReadPending( false ),
m_TotalBytesRead( 0 ),
m_ThreadToken( NULL ),
m_ErrorValid( false )
{

#if defined CLEARASYNCBUFFERS

    for ( int i = 0; i < NUMBER_OF_IO_BUFFERS; i++ )
        {
        memset( m_IOBuffers + i, i, sizeof( *m_IOBuffers ) );
        }

#endif

    if ( !OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &m_ThreadToken ) )
        {
        Log( LOG_ERROR, "Unable to retrieve the current thread token, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    if ( m_BytesToDrain && m_PrereadSize )
        {
        
        Log( LOG_INFO, "Have both a Preread and bytes to drain, deal with it." );
        Log( LOG_INFO, "BytesToDrain: %I64u, PrereadSize: %u", m_BytesToDrain, m_PrereadSize );

        DWORD DrainBytesInPreread = (DWORD)min( m_BytesToDrain, PrereadSize );
        m_PrereadBuffer += DrainBytesInPreread;
        m_PrereadSize   -= DrainBytesInPreread;
        m_BytesToDrain  -= DrainBytesInPreread;

        Log( LOG_INFO, "Bytes to drain from preread, %u", DrainBytesInPreread );

        }

    ASSERT( !( m_BytesToDrain && m_PrereadSize ) );
    m_BytesToRead = m_BytesToRead + m_BytesToDrain - m_PrereadSize;
    m_ReadOffset  = m_ReadOffset - m_BytesToDrain + m_PrereadSize;

    if ( m_BytesToRead )
        {

        // Setup the read completion callback

        BOOL Result =
            (*m_Request->m_ExtensionControlBlock->ServerSupportFunction)(
                    m_Request->m_ExtensionControlBlock->ConnID,
                    HSE_REQ_IO_COMPLETION,
                    (LPVOID)ReadCompleteWraper,
                    0,
                    (LPDWORD)this );

        if ( !Result )
            {
            Log( LOG_ERROR, "Unable to set callback to ReadCompleteWraper, error %x",
                 HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        }

    if ( INVALID_HANDLE_VALUE != m_WriteHandle )
        {

        BOOL Result =
            BindIoCompletionCallback(
                m_WriteHandle,                                          // handle to file
                (LPOVERLAPPED_COMPLETION_ROUTINE)WriteCompleteWraper,   // callback
                0                                                       // reserved
                );

        if ( !Result )
            {
            Log( LOG_ERROR, "Unable to set write completion routing, error %x",
                 HRESULT_FROM_WIN32( GetLastError() ) );
            throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        }
        
    // Queue the IO to a thread pool work item.

    BOOL bResult =
        QueueUserWorkItem( StartupIOWraper, this, WT_EXECUTEDEFAULT );

    if ( !bResult )
        {
        Log( LOG_ERROR, "QueueUserWorkItem failed, error %x",
             HRESULT_FROM_WIN32( GetLastError() ) );
        throw ServerException( 500, HRESULT_FROM_WIN32( GetLastError() ) );
        }

    m_OperationsPending++;
    Request->m_IsPending = true;
    Request->AddRef();

}

AsyncReader::~AsyncReader()
{
    if ( m_ThreadToken )
        CloseHandle( m_ThreadToken );
}

void
AsyncReader::HandleError( ServerException Error )
{
    m_ErrorValid    = true;
    m_Error         = Error;

    if ( m_OperationsPending )
        return; // Continue to wait for operations to exit.

    m_Request->HandleIOError( this, Error, m_TotalBytesRead );
    return; 
}

void
AsyncReader::CompleteIO()
{
    m_Request->CompleteIO( this, m_TotalBytesRead );
    return; 
}

void
AsyncReader::StartReadRequest()
{
    // start a new IIS read request
    DWORD BytesToRead;
    IOBuffer *Buffer = m_IOBuffers + m_ReadBuffer;

    if ( m_BytesToDrain )
        {
        Buffer->m_BufferWriteOffset = 0;
        Buffer->m_BufferUsed        = 0;
        BytesToRead = (DWORD)min( m_BytesToDrain, sizeof( Buffer->m_Buffer ) );
        }
    else
        {
        Buffer->m_BufferWriteOffset = m_ReadOffset;
        Buffer->m_BufferUsed = 0;
        BytesToRead = (DWORD)min( m_BytesToRead, sizeof( Buffer->m_Buffer ) );
        }


    Log( LOG_INFO, "Start Async Read, Connection %p, Buffer %u, Offset %I64u, Length %u",
         m_Request->m_ExtensionControlBlock->ConnID,
         m_ReadBuffer,
         m_ReadOffset,
         BytesToRead );
    
    DWORD Flags = HSE_IO_ASYNC;
    BOOL Result =
        (*m_Request->m_ExtensionControlBlock->ServerSupportFunction)
        (
            m_Request->m_ExtensionControlBlock->ConnID,
            HSE_REQ_ASYNC_READ_CLIENT,
            Buffer->m_Buffer,
            &BytesToRead,
            &Flags
        );

    if ( !Result )
        {
        DWORD Error = GetLastError();
        Log( LOG_ERROR, "HSE_REQ_ASYNC_READ_CLIENT failed, error 0x%8.8", Error );
        throw ServerException( HRESULT_FROM_WIN32( Error ) );
        }

    m_OperationsPending++;
    m_ReadPending = true;
    m_Request->AddRef();
}

void
AsyncReader::StartWriteRequest()
{
    // Start a new filesystem write request

    OVERLAPPED *OverLapped = (OVERLAPPED*)this;
    memset( OverLapped, 0, sizeof(*OverLapped) );

    LPCVOID WriteBuffer;
    DWORD BytesToWrite;

    if ( m_PrereadSize )
        {

        // IIS preread data is handled seperatly.  Drain it first.

        WriteBuffer             = m_PrereadBuffer;
        BytesToWrite            = m_PrereadSize;
        }
    else
        {
        IOBuffer *Buffer        = m_IOBuffers + m_WriteBuffer;
        ASSERT( m_WriteOffset == Buffer->m_BufferWriteOffset );
        WriteBuffer             = Buffer->m_Buffer;
        BytesToWrite            = Buffer->m_BufferUsed;
        }

    OverLapped->Offset      = (DWORD)(m_WriteOffset & 0xFFFFFFFF);
    OverLapped->OffsetHigh  = (DWORD)((m_WriteOffset >> 32) & 0xFFFFFFFF);

    Log( LOG_INFO, "Start Async Write, Connection %p, Buffer %u, Offset %I64u, Length %u",
         m_Request->m_ExtensionControlBlock->ConnID,
         m_WriteBuffer,
         m_WriteOffset,
         BytesToWrite );

    BOOL Result =
        WriteFile(
            m_WriteHandle,
            WriteBuffer,
            BytesToWrite,
            NULL,
            OverLapped );

    if ( !Result && GetLastError() != ERROR_IO_PENDING )
        {
        DWORD Error = GetLastError();
        Log( LOG_ERROR, "WriteFileEx failed, error 0x%8.8X", GetLastError() );
        throw ServerException( HRESULT_FROM_WIN32( Error ) );
        }

    m_OperationsPending++;
    m_WritePending = true;
    m_Request->AddRef();
}

void
AsyncReader::StartupIO( )
{

    // Startup the necessary IO operations based on the 
    // buffer states. returns true if the upload operation should continue. 

    try
    {
        if ( m_ErrorValid )
            throw ServerException( m_Error );

        bool ScheduledIO = false;

        if ( m_BytesToDrain )
            {
            StartReadRequest();
            ScheduledIO = true;
            }
        else
            {

            if ( !m_BytesToWrite && !m_BytesToDrain )
                return CompleteIO();

            if ( !m_WritePending )
                {
                if ( m_PrereadSize )
                    {
                    StartWriteRequest();
                    ScheduledIO = true;
                    }
                else if ( m_BuffersToWrite )
                    {
                    StartWriteRequest();
                    ScheduledIO = true;
                    }
                }

            if ( !m_ReadPending && m_BytesToRead && ( NUMBER_OF_IO_BUFFERS - m_BuffersToWrite ) )
                {
                StartReadRequest();
                ScheduledIO = true;
                }

            }

        if ( !ScheduledIO )
            Log( LOG_INFO, "No IO scheduled" );
    }
    catch( ServerException Error )
    {
        HandleError( Error );
    }
    catch( ComError Error )
    {
        HandleError( Error );
    }

    return; 

}

void
AsyncReader::WriteComplete( DWORD dwError, DWORD BytesWritten )
{
    // Called when a write is completed.   Determine the next buffer to use and startup the correct IO operations.
    // returns true is more operations are necessary.

    try
    {
        Log( LOG_INFO, "Complete Async Write, Connection %p, Buffer %u, Offset %I64u, Length %u, Error %u",
             m_Request->m_ExtensionControlBlock->ConnID,
             m_WriteBuffer,
             m_WriteOffset,
             BytesWritten,
             dwError );

        if ( m_ErrorValid )
            throw ServerException( m_Error );

        m_WritePending = false;

        if ( dwError )
            throw ServerException( HRESULT_FROM_WIN32( dwError ) );

        m_BytesToWrite -= BytesWritten;

        if ( m_PrereadSize )
            {
            m_PrereadSize -= BytesWritten;
            m_PrereadBuffer += BytesWritten;
            m_WriteOffset += BytesWritten;
            }
        else
            {
            IOBuffer *Buffer        = m_IOBuffers + m_WriteBuffer;
            ASSERT( BytesWritten == Buffer->m_BufferUsed );
            m_WriteOffset += Buffer->m_BufferUsed;
            m_BuffersToWrite--;

#if defined CLEARASYNCBUFFERS
            memset( Buffer, m_WriteBuffer, sizeof(*Buffer) );
#endif
            m_WriteBuffer = (m_WriteBuffer + 1 ) % NUMBER_OF_IO_BUFFERS;

            }

        return StartupIO();
    }
    catch( ServerException Error )
    {
        Log( LOG_ERROR, "Error in write complete" );
        HandleError( Error );
    }
    catch( ComError Error )
    {
        Log( LOG_ERROR, "Error in write complete" );
        HandleError( Error );
    }

}

void
AsyncReader::ReadComplete( DWORD dwError, DWORD BytesRead )
{
    // Called when a read operation is complete. determines if more operations should start or to 
    // complete the operation.
    // returns true if more operations are operations are needed to complete the upload

    try
    {

        Log( LOG_INFO, "Complete Async Read, Connection %p, Buffer %u, Offset %I64u, Length %u, Error %u",
             m_Request->m_ExtensionControlBlock->ConnID,
             m_ReadBuffer,
             m_ReadOffset,
             BytesRead,
             dwError );

        m_TotalBytesRead += BytesRead;

        if ( m_ErrorValid )
            throw ServerException( m_Error );

        m_ReadPending = false;

        if ( dwError )
            throw ServerException( HRESULT_FROM_WIN32( dwError ) );

        IOBuffer *Buffer = m_IOBuffers + m_ReadBuffer;
        Buffer->m_BufferUsed = BytesRead;

        m_BytesToRead   -= BytesRead;
        m_ReadOffset    += BytesRead;

        bool ScheduledIO = false;

        if ( m_BytesToDrain )
            m_BytesToDrain -= BytesRead;
        else
            {
            m_BuffersToWrite++;
            m_ReadBuffer = (m_ReadBuffer + 1 ) % NUMBER_OF_IO_BUFFERS;
            }

        StartupIO(); // Continue IO

    }
    catch( ServerException Error )
    {
        Log( LOG_ERROR, "Error in read complete" );

        HandleError( Error );
    }
    catch( ComError Error )
    {
        Log( LOG_ERROR, "Error in read complete" );

        HandleError( Error );
    }

}

DWORD
AsyncReader::StartupIOWraper( LPVOID Context )
{
    AsyncReader *Reader = (AsyncReader*)Context;
    
    {
        CriticalSectionLock CSLock( &Reader->m_Request->m_cs );
        Reader->m_OperationsPending--;

        // Thread pool threads should start and end with no token

        BITSSetCurrentThreadToken( Reader->m_ThreadToken );
        Reader->StartupIO();
    }
    Reader->m_Request->Release();

    // revert to previous impersonation.

    BITSSetCurrentThreadToken( NULL );

    return 0;
}

void CALLBACK
AsyncReader::WriteCompleteWraper(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped )
{

    // Wrapper around write completions

    Log( LOG_INFO, "WriteCompleteWraper begin" );
    AsyncReader *Reader = (AsyncReader*)lpOverlapped;
    {
        CriticalSectionLock CSLock( &Reader->m_Request->m_cs );
        Reader->m_OperationsPending--;

        // Thread pool threads should start and end with no token

        BITSSetCurrentThreadToken( Reader->m_ThreadToken );
        Reader->WriteComplete( dwErrorCode, dwNumberOfBytesTransfered );
    }
    Reader->m_Request->Release();

    // revert to previous security
    BITSSetCurrentThreadToken( NULL );
}

void WINAPI
AsyncReader::ReadCompleteWraper(
    LPEXTENSION_CONTROL_BLOCK,
    PVOID pContext,
    DWORD cbIO,
    DWORD dwError )
{

    // wrapper around read completions

    Log( LOG_INFO, "ReadCompleteWraper begin" );
    AsyncReader *Reader = (AsyncReader*)pContext;
    
    {
        CriticalSectionLock CSLock( &Reader->m_Request->m_cs );
        Reader->m_OperationsPending--;

    #if defined( DBG )
        {

        HANDLE ThreadToken = NULL;
        ASSERT( OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &ThreadToken ) );

        if ( ThreadToken )
            CloseHandle( ThreadToken );

        }

    #endif

        Reader->ReadComplete( dwError, cbIO );
    }
    
    Reader->m_Request->Release();

}

bool g_ExtensionRunning = false;

class ConfigurationManager *g_ConfigMan = NULL;
class PropertyIDManager *g_PropertyMan = NULL;

BOOL WINAPI
GetExtensionVersion(
    OUT HSE_VERSION_INFO * pVer
    )
{

    // IIS calls this to start everything up.

    HRESULT Hr = S_OK;

    ASSERT( !g_ExtensionRunning );

    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR,
                                         HSE_VERSION_MAJOR );

    StringCbCopyA( 
        pVer->lpszExtensionDesc,
        sizeof( pVer->lpszExtensionDesc ),
        "BITS Server Extensions" );

    if ( g_ExtensionRunning )
        return true;

    Hr = LogInit();

    if ( FAILED( Hr ) )
        {
        SetLastError( Hr );
        return false;
        }

    Log( LOG_INFO, "GetExtensionVersion called,  starting init" );

    try
    {

        Log( LOG_INFO, "Initializing Property Manager..." );

        g_PropertyMan = new PropertyIDManager();
        
        HRESULT Hr2 =
            g_PropertyMan->LoadPropertyInfo();

        if ( FAILED(Hr2) )
            throw ServerException( Hr2 );

        Log( LOG_INFO, "Initializing Configuration Manager..." );

        g_ConfigMan = new ConfigurationManager();

    }
    catch( ComError & Exception )
    {

        Log( LOG_ERROR, "Error during initialization, 0x%8.8X", Exception.m_Hr );

        delete g_ConfigMan;
        delete g_PropertyMan;

        LogClose();

        SetLastError( Exception.m_Hr );

        return false;
    }

    g_ExtensionRunning = true;
    Log( LOG_INFO, "Initialization complete!" );
    return true;
}

BOOL WINAPI
TerminateExtension(
    IN DWORD dwFlags
)
{

    //
    // IIS calls this to shut everything down.
    //

    if ( !g_ExtensionRunning )
        return true;

    Log( LOG_INFO, "Shuting down config manager..." );

    delete g_ConfigMan;
    g_ConfigMan = NULL;

    Log( LOG_INFO, "Shuting down property manager..." );

    delete g_PropertyMan;
    g_PropertyMan = NULL;

    Log( LOG_INFO, "Closing logging, goodbye" );

    LogClose();

    g_ExtensionRunning = false;

    return true;

}

DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK * pECB
)
{

    //
    // IIS calls this function for each request that is forwarded by the filter.
    //

    DWORD Result            = HSE_STATUS_ERROR;
    ServerRequest *Request  = NULL;

    try
    {
       g_LastRequest = Request = new ServerRequest( pECB );
       Request->DispatchRequest();
       Result = Request->IsPending() ? HSE_STATUS_PENDING : HSE_STATUS_SUCCESS;
    }
    catch( ServerException Exception )
    {
       IISLogger Logger( pECB );
       Logger.LogError( Exception );
       Result  = HSE_STATUS_ERROR;
    }
    catch( ComError Exception )
    {
       IISLogger Logger( pECB );
       Logger.LogError( Exception );
       Result  = HSE_STATUS_ERROR;
    }

    if ( Request )
        Request->Release();

    return Result;

}

HMODULE g_hinst;

BOOL WINAPI
DllMain(
    IN HINSTANCE hinstDll,
    IN DWORD dwReason,
    IN LPVOID lpvContext
)
/*++
Function :  DllMain

Description:

    The initialization function for this DLL.

Arguments:

    hinstDll - Instance handle of the DLL
    dwReason - Reason why NT called this DLL
    lpvContext - Reserved parameter for future use

Return Value:

    Returns TRUE if successfull; otherwise FALSE.

--*/
{
    // Note that appropriate initialization and termination code
    // would be written within the switch statement below.  Because
    // this example is very simple, none is currently needed.

    switch( dwReason ) {
    case DLL_PROCESS_ATTACH:
        g_hinst = hinstDll;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);
}


#include "bitssrvcfgimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\about.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    about.cpp

Abstract :

    Handles about information for MMC snapin.

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"

CSnapinAbout::CSnapinAbout()
: m_cref(1),
m_hSmallImage( NULL ),
m_hSmallImageOpen( NULL ),
m_hLargeImage( NULL ),
m_hAppIcon( NULL )
{
    OBJECT_CREATED
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    return LoadStringHelper( lpDescription, IDS_BITSMGR_DESC );
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return LoadStringHelper( lpName, IDS_BITSMGR_PROVIDER );
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return LoadStringHelper( lpVersion, IDS_BITSMGR_VERSION_STR );
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{

    if ( m_hAppIcon )
        {
        *hAppIcon = m_hAppIcon;
        return S_OK;
        }

    *hAppIcon = m_hAppIcon = 
        LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_BITSMGR));

    if ( !m_hAppIcon )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{

    HRESULT Hr = S_OK;

    if ( m_hSmallImage )
        *hSmallImage = m_hSmallImage;
    else
        {

        *hSmallImage = m_hSmallImage =
            (HBITMAP)LoadImage(
                g_hinst,
                MAKEINTRESOURCE(IDB_SMALL),
                IMAGE_BITMAP,
                0,
                0,
                LR_DEFAULTCOLOR
                );

        if ( !m_hSmallImage )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Fail;
            }

        }

    if ( m_hSmallImageOpen )
        *hSmallImageOpen = m_hSmallImageOpen;
    else
        {

        *hSmallImageOpen = m_hSmallImageOpen =
            (HBITMAP)LoadImage(
                g_hinst,
                MAKEINTRESOURCE(IDB_SMALL),
                IMAGE_BITMAP,
                0,
                0,
                LR_DEFAULTCOLOR
                );

        if ( !m_hSmallImageOpen )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Fail;
            }

        }

    
    if ( m_hLargeImage )
        *hLargeImage = m_hLargeImage;
    else
        {

        *hLargeImage = m_hLargeImage =
            (HBITMAP)LoadImage(
                g_hinst,
                MAKEINTRESOURCE(IDB_SMALL),
                IMAGE_BITMAP,
                0,
                0,
                LR_DEFAULTCOLOR
                );

        if ( !m_hLargeImage )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto Fail;
            }

        }

    *cMask = RGB(255,0,255); // purple
    return S_OK;

Fail:
    *hSmallImage = *hSmallImageOpen = *hLargeImage = NULL;
    memset( cMask, 0, sizeof(COLORREF) );
    return Hr;

}

HRESULT	
CSnapinAbout::LoadStringHelper(
    LPOLESTR *lpDest, 
    UINT Id )
{
    *lpDest = (LPOLESTR)CoTaskMemAlloc( sizeof(WCHAR) * MAX_PATH );

    if ( !lpDest )
        return E_OUTOFMEMORY;

    int RetVal =
        LoadString( g_hinst, Id, *lpDest, MAX_PATH - 1 );

    if ( !RetVal )
        {
        HRESULT Hr = HRESULT_FROM_WIN32( GetLastError() );
        CoTaskMemFree( lpDest );
        *lpDest = NULL;
        return Hr;
        }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\thunks.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    thunks.cpp

Abstract:

    This file implements the API thunks for the BITS server extensions

--*/

#include "precomp.h"

// API thunks

UINT64 BITSGetFileSize(
    HANDLE Handle )
{

    LARGE_INTEGER FileSize;

    if (!GetFileSizeEx( Handle, &FileSize ) )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    return (UINT64)FileSize.QuadPart;

}

UINT64 BITSSetFilePointer(
    HANDLE Handle,
    INT64 Distance,
    DWORD MoveMethod )
{
    LARGE_INTEGER DistanceToMove;
    DistanceToMove.QuadPart = (LONGLONG)Distance;

    LARGE_INTEGER NewFilePointer;

    BOOL Result =
        SetFilePointerEx(
            Handle,
            DistanceToMove,
            &NewFilePointer,
            MoveMethod );

    if ( !Result )
        {
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    return (UINT64)NewFilePointer.QuadPart;

}

DWORD
BITSWriteFile(
    HANDLE Handle,
    LPCVOID Buffer,
    DWORD NumberOfBytesToWrite)
{

    DWORD BytesWritten;

    BOOL Result =
        WriteFile(
            Handle,
            Buffer,
            NumberOfBytesToWrite,
            &BytesWritten,
            NULL );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    return BytesWritten;

}

void
BITSCreateDirectory(
    LPCTSTR DirectoryName
    )
{

    BOOL Result =
        CreateDirectory( DirectoryName, NULL );

    if ( Result )
        return;

    DWORD Status = GetLastError();

    // ignore the error if the directory already exists

    if ( ERROR_ALREADY_EXISTS == Status )
        return;

    throw ServerException( HRESULT_FROM_WIN32( Status ) );
}



void
BITSRenameFile(
    LPCTSTR ExistingName,
    LPCTSTR NewName,
    bool AllowOverwrites )
{

    BOOL Result =
        MoveFileEx( ExistingName, NewName, 
                    AllowOverwrites ? MOVEFILE_REPLACE_EXISTING : 0 );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

}

void
BITSDeleteFile(
    LPCTSTR FileName )
{

    BOOL Result =
        DeleteFile( FileName );

    if ( Result )
        return;

    DWORD Status = GetLastError();

    if ( ERROR_FILE_NOT_FOUND == Status ||
         ERROR_PATH_NOT_FOUND == Status )
        return;

    throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

}

GUID
BITSCreateGuid()
{
    GUID guid;
    HRESULT Hr = CoCreateGuid( &guid );

    if ( FAILED( Hr ) )
        throw ServerException( Hr );

    return guid;
}

GUID
BITSGuidFromString( const char *String )
{

   // 38 chars {c200e360-38c5-11ce-ae62-08002b2b79ef} 

   if ( 38 != strlen( String ) )
       throw ServerException( E_INVALIDARG );

   WCHAR StringW[ 80 ];
   StringCchPrintfW(
       StringW,
       ARRAY_ELEMENTS( StringW ),
       L"%S", 
       String );

   GUID Guid;
   HRESULT Hr =
        IIDFromString( StringW, &Guid );

   if ( FAILED( Hr ) )
       throw ServerException( Hr ); 

   return Guid; 
}

StringHandle
BITSStringFromGuid(
    GUID Guid )
{
    WCHAR StringW[ 80 ];
    StringFromGUID2( Guid, StringW, ARRAY_ELEMENTS( StringW ) );

    StringHandle WorkString;
    
    char *WorkBuffer = WorkString.AllocBuffer( ARRAY_ELEMENTS( StringW ) );
    
    StringCchPrintfA( 
        WorkBuffer,
        ARRAY_ELEMENTS( StringW ),
        "%S", 
        StringW );

    WorkString.SetStringSize();
    return WorkString;
}

void
BITSSetCurrentThreadToken(
    HANDLE hToken )
{

    if ( !SetThreadToken( NULL, hToken ) )
        {

        for( unsigned int i = 0; i < 100; i ++ )
            {

            Sleep( 10 );

            if ( SetThreadToken( NULL, hToken ) )
                return;

            }
        
        ASSERT( 0 );
        TerminateProcess( NULL, GetLastError() ); 

        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\setup.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    setup.cpp

Abstract:

    Setup code called from regsvr32 

--*/

#include "precomp.h"
#include <setupapi.h>

const DWORD CONFIG_BUFFER_MAX = 4096;

BSTR g_PropertyBSTR                     = NULL;
BSTR g_SyntaxBSTR                       = NULL;
BSTR g_UserTypeBSTR                     = NULL;
BSTR g_InheritBSTR                      = NULL;
BSTR g_ClassBSTR                        = NULL;
BSTR g_IsapiRestrictionListBSTR         = NULL;
BSTR g_RestrictionListCustomDescBSTR    = NULL;
BSTR g_FilterLoadOrderBSTR              = NULL;
BSTR g_IIsFilterBSTR                    = NULL;
BSTR g_InProcessIsapiAppsBSTR           = NULL;
BSTR g_bitsserverBSTR                   = NULL;
BSTR g_bitserverBSTR                    = NULL;
BSTR g_MetaIDBSTR                       = NULL;
BSTR g_WebSvcExtRestrictionListBSTR     = NULL;

WCHAR g_ISAPIPath[ MAX_PATH ];
WCHAR g_ExtensionNameString[ MAX_PATH ];

void
LogSetup(
    LogSeverity Severity,
    PCTSTR Format,
    ...)
{
    va_list arglist;
    va_start( arglist, Format );

    CHAR Buffer[256];

    StringCchVPrintfA( 
          Buffer, 
          sizeof(Buffer) - 1,
          Format, arglist );
    
    SetupLogError( Buffer, Severity );
}

BOOL g_IsWindowsXP = FALSE;

void 
DetectProductVersion()
{

   OSVERSIONINFO VersionInfo;
   VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );

   LogSetup( LogSevInformation, "[BITSSRV] Detecting product version\r\n" );

   if ( !GetVersionEx( &VersionInfo ) )
       THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

   switch( VersionInfo.dwPlatformId )
       {

       case VER_PLATFORM_WIN32_NT:

           if ( VersionInfo.dwMajorVersion < 5 )
               {
               LogSetup( LogSevFatalError, "[BITSSRV] Unsupported platform\r\n" );
               THROW_COMERROR( E_FAIL );
               }

           if ( VersionInfo.dwMajorVersion > 5 )
               {
               g_IsWindowsXP = TRUE;;
               return;
               }


           g_IsWindowsXP = ( VersionInfo.dwMinorVersion > 0 );
           return;

       default:
           LogSetup( LogSevFatalError, "[BITSSRV] Unsupported platform\r\n" );
           THROW_COMERROR( E_FAIL );

       }
}

void 
InitializeSetup()
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting Initialization of strings\r\n" );

    g_PropertyBSTR                  = SysAllocString( L"Property" );
    g_SyntaxBSTR                    = SysAllocString( L"Syntax" );
    g_UserTypeBSTR                  = SysAllocString( L"UserType" );
    g_InheritBSTR                   = SysAllocString( L"Inherit" );
    g_ClassBSTR                     = SysAllocString( L"Class" );
    g_IsapiRestrictionListBSTR      = SysAllocString( L"IsapiRestrictionList" );
    g_RestrictionListCustomDescBSTR = SysAllocString( L"RestrictionListCustomDesc" );
    g_FilterLoadOrderBSTR           = SysAllocString( L"FilterLoadOrder" );
    g_IIsFilterBSTR                 = SysAllocString( L"IIsFilter" );
    g_InProcessIsapiAppsBSTR        = SysAllocString( L"InProcessIsapiApps" );
    g_bitsserverBSTR                = SysAllocString( L"bitsserver" );
    g_bitserverBSTR                 = SysAllocString( L"bitserver" );
    g_MetaIDBSTR                    = SysAllocString( L"MetaId" );
    g_WebSvcExtRestrictionListBSTR  = SysAllocString( L"WebSvcExtRestrictionList" );

    if ( !g_PropertyBSTR || !g_SyntaxBSTR || !g_UserTypeBSTR || 
         !g_InheritBSTR | !g_ClassBSTR || !g_IsapiRestrictionListBSTR || 
         !g_RestrictionListCustomDescBSTR || !g_FilterLoadOrderBSTR || !g_IIsFilterBSTR ||
         !g_InProcessIsapiAppsBSTR || !g_bitsserverBSTR || !g_bitserverBSTR || !g_MetaIDBSTR ||
         !g_WebSvcExtRestrictionListBSTR )
        {

        SysFreeString( g_PropertyBSTR );
        SysFreeString( g_SyntaxBSTR );
        SysFreeString( g_UserTypeBSTR );
        SysFreeString( g_InheritBSTR );
        SysFreeString( g_ClassBSTR );
        SysFreeString( g_IsapiRestrictionListBSTR );
        SysFreeString( g_RestrictionListCustomDescBSTR );
        SysFreeString( g_FilterLoadOrderBSTR );
        SysFreeString( g_IIsFilterBSTR );
        SysFreeString( g_InProcessIsapiAppsBSTR );
        SysFreeString( g_bitsserverBSTR );
        SysFreeString( g_bitserverBSTR );
        SysFreeString( g_MetaIDBSTR );
        SysFreeString( g_WebSvcExtRestrictionListBSTR );

        g_PropertyBSTR = g_SyntaxBSTR = g_UserTypeBSTR = 
            g_InheritBSTR = g_ClassBSTR = g_IsapiRestrictionListBSTR = 
                g_RestrictionListCustomDescBSTR = g_FilterLoadOrderBSTR = g_IIsFilterBSTR = 
                    g_InProcessIsapiAppsBSTR = g_bitsserverBSTR = g_bitserverBSTR = g_MetaIDBSTR = 
                        g_WebSvcExtRestrictionListBSTR = NULL;

        throw ComError( E_OUTOFMEMORY );

        }


    DWORD dwRet = 
        GetModuleFileNameW(
            g_hinst,
            g_ISAPIPath,
            MAX_PATH );

    if ( !dwRet )
        return THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

    if (! LoadStringW(
            g_hinst,                      
            IDS_EXTENSION_NAME,           
            g_ExtensionNameString,        
            MAX_PATH ) )                  
        return THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

    // ensure termination
    g_ExtensionNameString[ MAX_PATH - 1 ] = g_ISAPIPath[ MAX_PATH - 1 ] = L'\0';

}

void
CleanupSetup()
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting setup cleanup\r\n" );

    SysFreeString( g_PropertyBSTR );
    SysFreeString( g_SyntaxBSTR );
    SysFreeString( g_UserTypeBSTR );
    SysFreeString( g_InheritBSTR );
    SysFreeString( g_ClassBSTR );
    SysFreeString( g_IsapiRestrictionListBSTR );
    SysFreeString( g_RestrictionListCustomDescBSTR );
    SysFreeString( g_FilterLoadOrderBSTR );
    SysFreeString( g_IIsFilterBSTR );
    SysFreeString( g_InProcessIsapiAppsBSTR );
    SysFreeString( g_bitsserverBSTR );
    SysFreeString( g_bitserverBSTR );
    SysFreeString( g_MetaIDBSTR );
    SysFreeString( g_WebSvcExtRestrictionListBSTR );

    g_PropertyBSTR = g_SyntaxBSTR = g_UserTypeBSTR = 
        g_InheritBSTR = g_ClassBSTR = g_IsapiRestrictionListBSTR =
            g_RestrictionListCustomDescBSTR = g_FilterLoadOrderBSTR = g_IIsFilterBSTR = 
                g_InProcessIsapiAppsBSTR = g_bitsserverBSTR = g_MetaIDBSTR = 
                    g_WebSvcExtRestrictionListBSTR = NULL;

}

typedef SmartRefPointer<IADs>       SmartIADsPointer;
typedef SmartRefPointer<IADsClass>  SmartIADsClassPointer;
typedef SmartRefPointer<IADsContainer> SmartIADsContainerPointer;

void RemoveFilterHelper(
    WCHAR * Buffer,
    const WCHAR * const ToRemove )
{

    WCHAR *ToReplace;
    SIZE_T FragmentLength = wcslen( ToRemove );

    while( ToReplace = wcsstr( Buffer, ToRemove ) )
        {
        WCHAR *Next = ToReplace + FragmentLength;
        memmove( ToReplace, Next, sizeof(WCHAR) * ( wcslen( Next ) + 1 ) );  
        Buffer = ToReplace;
        }

}

DWORD
BITSGetStartupInfoFilter(
    DWORD Status )
{

    //
    // The following exceptions are documented 
    // to be thrown by GetStartupInfoA
    //

    switch( Status )
        {

        case STATUS_NO_MEMORY:
        case STATUS_INVALID_PARAMETER_2:
        case STATUS_BUFFER_OVERFLOW:
            return EXCEPTION_EXECUTE_HANDLER;

        default:
            return EXCEPTION_CONTINUE_SEARCH;
        
        }

}

HRESULT
BITSGetStartupInfo( 
    LPSTARTUPINFO lpStartupInfo )
{

    __try
    {
        GetStartupInfoA( lpStartupInfo );
    }
    __except( BITSGetStartupInfoFilter( GetExceptionCode() ) )
    {
        return E_OUTOFMEMORY;
    }
    
    return S_OK;

}

void
RestartIIS()
{

    LogSetup( LogSevInformation, "[BITSSRV] Restarting IIS\r\n" );

    //
    // Restarts IIS by calling "iisreset /restart" at the commandline.
    //

    STARTUPINFO StartupInfo;
    THROW_COMERROR( BITSGetStartupInfo( &StartupInfo ) );

    #define IISRESET_EXE        "iisreset.exe"
    #define IISRESET_CMDLINE    "iisreset /RESTART /NOFORCE"

    PROCESS_INFORMATION ProcessInfo;
    CHAR    sApplicationPath[MAX_PATH];
    CHAR   *pApplicationName = NULL;
    CHAR    sCmdLine[MAX_PATH];
    DWORD   dwLen = MAX_PATH;
    DWORD   dwCount;

    dwCount = SearchPath(NULL,                // Search Path, NULL is PATH
                         IISRESET_EXE,        // Application
                         NULL,                // Extension (already specified)
                         dwLen,               // Length (char's) of sApplicationPath
                         sApplicationPath,    // Path + Name for application
                         &pApplicationName ); // File part of sApplicationPath

    if (dwCount == 0)
        {
        THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    if (dwCount > dwLen)
        {
        THROW_COMERROR( HRESULT_FROM_WIN32( ERROR_BUFFER_OVERFLOW ) );
        }

    StringCbCopyA( sCmdLine, sizeof( sCmdLine ), IISRESET_CMDLINE);

    BOOL RetVal = CreateProcess(
            sApplicationPath,                          // name of executable module
            sCmdLine,                                  // command line string
            NULL,                                      // SD
            NULL,                                      // SD
            FALSE,                                     // handle inheritance option
            CREATE_NO_WINDOW,                          // creation flags
            NULL,                                      // new environment block
            NULL,                                      // current directory name
            &StartupInfo,                              // startup information
            &ProcessInfo                               // process information
        );

    if ( !RetVal )
        THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

    WaitForSingleObject( ProcessInfo.hProcess, INFINITE );
    DWORD Status;
    GetExitCodeProcess( ProcessInfo.hProcess, &Status );

    CloseHandle( ProcessInfo.hProcess );
    CloseHandle( ProcessInfo.hThread );

    THROW_COMERROR( HRESULT_FROM_WIN32( Status ) );
}

#if 0

// Can't enabled for now because IIS6 has a memory
// corruption problem is a property attribute is changed.

void EnsurePropertyInheritance(
    SmartIADsContainerPointer & Container,
    BSTR PropertyNameBSTR )
{
    
    SmartVariant            var;
    SmartIDispatchPointer   Dispatch;
    SmartIADsPointer        MbProperty;

    VariantInit( &var );

    THROW_COMERROR(
        Container->GetObject(
            g_PropertyBSTR,
            PropertyNameBSTR,
            Dispatch.GetRecvPointer() ) );

    THROW_COMERROR( 
        Dispatch->QueryInterface( MbProperty.GetUUID(), 
                                  reinterpret_cast<void**>( MbProperty.GetRecvPointer() ) ) );
    var.boolVal = VARIANT_TRUE;
    var.vt = VT_BOOL;

    THROW_COMERROR( MbProperty->Put( g_InheritBSTR, var ) );

    THROW_COMERROR( MbProperty->SetInfo() );
    
}

#endif

void InstallPropertySchema( )
{

    //
    // Installs the ADSI schema with the new metabase properties. 
    //
    
    LogSetup( LogSevInformation, "[BITSSRV] Installing property schema\r\n" );

    SmartVariant var;
    SmartIADsContainerPointer MbSchemaContainer;

    THROW_COMERROR(
        ADsGetObject( 
             L"IIS://LocalHost/Schema", 
             MbSchemaContainer.GetUUID(), 
             reinterpret_cast<void**>( MbSchemaContainer.GetRecvPointer() ) ) );

    SmartIDispatchPointer   Dispatch;
    SmartIADsPointer        MbProperty;
    SmartIADsClassPointer   MbClass;

    BSTR PropertyNameBSTR   = NULL;
    BSTR PropertyClassBSTR  = NULL;

    try
    {

        for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
        {
            LogSetup( LogSevInformation, "[BITSSRV] Installing property %u\r\n", (UINT32)i );

            PropertyNameBSTR    = SysAllocString( g_Properties[i].PropertyName );
            PropertyClassBSTR   = SysAllocString( g_Properties[i].ClassName );

            if ( !PropertyNameBSTR || !PropertyClassBSTR )
                throw ComError( E_OUTOFMEMORY );

            {

                HRESULT Hr = 
                    MbSchemaContainer->Create(
                        g_PropertyBSTR,
                        PropertyNameBSTR,
                        Dispatch.GetRecvPointer() );

                if ( Hr == E_ADS_OBJECT_EXISTS )
                    {

                    // Ensure property is inheritable
                    // EnsurePropertyInheritance( MbSchemaContainer, PropertyNameBSTR ); 

                    SysFreeString( PropertyNameBSTR );
                    SysFreeString( PropertyClassBSTR );
                    PropertyNameBSTR = PropertyClassBSTR = NULL;
                    continue;
                    }

                THROW_COMERROR( Hr );
            }

            THROW_COMERROR( 
                Dispatch->QueryInterface( MbProperty.GetUUID(), 
                                           reinterpret_cast<void**>( MbProperty.GetRecvPointer() ) ) );

            var.bstrVal = SysAllocString( g_Properties[i].Syntax );
            var.vt = VT_BSTR;

            if ( !var.bstrVal )
                THROW_COMERROR( E_OUTOFMEMORY );

            THROW_COMERROR( MbProperty->Put( g_SyntaxBSTR, var ) );

            VariantClear( &var );
            var.ulVal = g_Properties[i].UserType;
            var.vt = VT_UI4;
            THROW_COMERROR( MbProperty->Put( g_UserTypeBSTR, var ) );

            var.boolVal = VARIANT_TRUE;
            var.vt = VT_BOOL;

            THROW_COMERROR( MbProperty->Put( g_InheritBSTR, var ) );

            THROW_COMERROR( MbProperty->SetInfo() );

            VariantClear( &var );

            if ( i == MD_BITS_UPLOAD_METADATA_VERSION )
                {

                // hack for IIS ID allocation bug

                MbProperty->Get( g_MetaIDBSTR, &var );
                THROW_COMERROR( VariantChangeType( &var, &var, 0, VT_UI4 ) );

                if ( var.ulVal == 130008 )
                    {
                    LogSetup( LogSevWarning, "[BITSSRV] Invoking hack for IIS allocation bug(MD_BITS_UPLOAD_METADATA_VERSION)\r\n" );
                    var.ulVal = 130009;
                    MbProperty->Put( g_MetaIDBSTR, var );
                    MbProperty->SetInfo();
                    }

                }

#if defined( ALLOW_OVERWRITES )

            else if ( i == MD_BITS_ALLOW_OVERWRITES )
                {

                // another hack for IIS ID allocation bug

                MbProperty->Get( g_MetaIDBSTR, &var );
                THROW_COMERROR( VariantChangeType( &var, &var, 0, VT_UI4 ) );

                if ( var.ulVal == 130009 )
                    {
                    LogSetup( LogSevWarning, "[BITSSRV] Invoking hack for IIS allocation bug(MD_BITS_ALLOW_OVERWRITES)\r\n" );
                    var.ulVal = 130010;
                    MbProperty->Put( g_MetaIDBSTR, var );
                    MbProperty->SetInfo();

                    }

                }

#endif

            THROW_COMERROR( 
                MbSchemaContainer->GetObject( g_ClassBSTR, PropertyClassBSTR, 
                                              Dispatch.GetRecvPointer() ) );

            THROW_COMERROR( 
                Dispatch->QueryInterface( MbClass.GetUUID(), 
                                          reinterpret_cast<void**>( MbClass.GetRecvPointer() ) ) );

            THROW_COMERROR( MbClass->get_OptionalProperties( &var ) );

            SAFEARRAY* Array = var.parray;
            long LBound;
            long UBound;

            THROW_COMERROR( SafeArrayGetLBound( Array, 1, &LBound ) );

            THROW_COMERROR( SafeArrayGetUBound( Array, 1, &UBound ) );

            UBound++; // Add one to the upper bound

            SAFEARRAYBOUND SafeBounds;
            SafeBounds.lLbound = LBound;
            SafeBounds.cElements = UBound - LBound + 1;

            THROW_COMERROR( SafeArrayRedim( Array, &SafeBounds ) );

            VARIANT bstrvar;
            VariantInit( &bstrvar );
            bstrvar.vt = VT_BSTR;
            bstrvar.bstrVal = SysAllocString( g_Properties[i].PropertyName );

            if ( !bstrvar.bstrVal )
                THROW_COMERROR( E_OUTOFMEMORY );

            long Dim = (long)UBound;
            THROW_COMERROR( SafeArrayPutElement( Array, &Dim, &bstrvar ) );

            VariantClear( &bstrvar );

            THROW_COMERROR( MbClass->put_OptionalProperties( var ) );

            THROW_COMERROR( MbClass->SetInfo() );

            SysFreeString( PropertyNameBSTR );
            SysFreeString( PropertyClassBSTR );
            PropertyNameBSTR = PropertyClassBSTR = NULL;

        }
    }
    catch( ComError Error )
    {
        LogSetup( LogSevError, "[BITSSRV] Error detected while installing property schema, error %u\r\n" );
        SysFreeString( PropertyNameBSTR );
        SysFreeString( PropertyClassBSTR );
        PropertyNameBSTR = PropertyClassBSTR = NULL;
        throw;
    }

    return;

}


void RemovePropertySchema( )
{

    // Removes our properties from the metabase schema

    LogSetup( LogSevInformation, "[BITSSRV] Starting RemovePropertySchema\r\n" );

    SmartVariant var;
    SmartIADsContainerPointer MbSchemaContainer;

    THROW_COMERROR( 
        ADsGetObject( 
             L"IIS://LocalHost/Schema", 
             MbSchemaContainer.GetUUID(), 
             reinterpret_cast<void**>( MbSchemaContainer.GetRecvPointer() ) ) );

    SmartIDispatchPointer Dispatch;
    SmartIADsClassPointer MbClass;
    SmartIADsPointer Object;
    BSTR        PropertyNameBSTR    = NULL;
    BSTR        PropertyClassBSTR   = NULL;

    for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
    {

        LogSetup( LogSevInformation, "[BITSSRV] Removing property number, %u\r\n", i );

        PropertyNameBSTR    = SysAllocString( g_Properties[i].PropertyName );
        PropertyClassBSTR   = SysAllocString( g_Properties[i].ClassName );

        if ( !PropertyNameBSTR || !PropertyClassBSTR )
            throw ComError( E_OUTOFMEMORY );

        MbSchemaContainer->Delete( g_PropertyBSTR, PropertyNameBSTR );

        THROW_COMERROR(
            MbSchemaContainer->QueryInterface( Object.GetUUID(), 
                                               reinterpret_cast<void**>( Object.GetRecvPointer() ) ) );

        Object->SetInfo();

        THROW_COMERROR( 
             MbSchemaContainer->GetObject( g_ClassBSTR, PropertyClassBSTR, 
                                           Dispatch.GetRecvPointer() ) );
        THROW_COMERROR( 
            Dispatch->QueryInterface( MbClass.GetUUID(), 
                                      reinterpret_cast<void**>( MbClass.GetRecvPointer() ) ) );

        THROW_COMERROR( MbClass->get_OptionalProperties( &var ) );

        SAFEARRAY* Array = var.parray;
        SafeArrayLocker ArrayLock( Array );
        ArrayLock.Lock();

        ULONG  NewSize = 0;
        SIZE_T j = Array->rgsabound[0].lLbound;
        SIZE_T k = Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;

        while( j < k )
            {

            VARIANT & JElem = ((VARIANT*)Array->pvData)[j];

            // This element is fine, keep it
            if ( 0 != _wcsicmp( (WCHAR*)JElem.bstrVal, BSTR( g_Properties[i].PropertyName ) ) )
                {
                NewSize++;
                j++;
                }

            else
                {

                // find a suitable element to replace the bad element with
                while( j < --k )
                    {
                    VARIANT & KElem = ((VARIANT*)Array->pvData)[k];
                    if ( 0 != _wcsicmp( (WCHAR*)KElem.bstrVal, BSTR( g_Properties[i].PropertyName ) ) )
                        {
                        // found element. move it
                        VARIANT temp = JElem;
                        JElem = KElem;
                        KElem = temp;
                        break;
                        }
                    }
                }
            }

        SAFEARRAYBOUND ArrayBounds;
        ArrayBounds = Array->rgsabound[0];
        ArrayBounds.cElements = NewSize;

        ArrayLock.Unlock();

        THROW_COMERROR( SafeArrayRedim( Array, &ArrayBounds ) );
        
        THROW_COMERROR( MbClass->put_OptionalProperties( var ) );
        THROW_COMERROR( MbClass->SetInfo() );

        VariantClear( &var );
    }

}

void InstallDefaultValues( )
{

    //
    // Install default values for the configuration.  Do this at the top and let inheritance deal with it.
    //

    LogSetup( LogSevInformation, "[BITSSRV] Starting InstallDefaultValues\r\n" );

    METADATA_RECORD mdr;
    METADATA_HANDLE mdHandle = NULL;
    DWORD Value;


    PropertyIDManager PropertyMan;
    THROW_COMERROR( PropertyMan.LoadPropertyInfo() );
    
    SmartMetabasePointer IISAdminBase;

    THROW_COMERROR(
         CoCreateInstance(
             GETAdminBaseCLSID(TRUE),
             NULL,
             CLSCTX_SERVER,
             IISAdminBase.GetUUID(),
             (LPVOID*)IISAdminBase.GetRecvPointer() ) );

    THROW_COMERROR(
        IISAdminBase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,
            L"/LM/W3SVC",
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_OPEN_KEY_TIMEOUT, 
            &mdHandle ) );

    try
    {

        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_CONNECTION_DIR );
        mdr.dwMDDataType    = STRING_METADATA;
        mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_CONNECTION_DIR;
        mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_CONNECTION_DIR ) + 1 );
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR( 
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_MAX_FILESIZE );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_MAX_FILESIZE );
        mdr.dwMDDataType    = STRING_METADATA;
        mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_MAX_FILESIZE;
        mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_MAX_FILESIZE ) + 1 );
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR(
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

        Value = MD_DEFAULT_NO_PROGESS_TIMEOUT;
        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_NO_PROGRESS_TIMEOUT );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_NO_PROGRESS_TIMEOUT );
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (PBYTE)&Value;
        mdr.dwMDDataLen     = sizeof(Value);
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR( 
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

        Value = (DWORD)MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE;
        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL_TYPE );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_NOTIFICATION_URL_TYPE );
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (PBYTE)&Value;
        mdr.dwMDDataLen     = sizeof(Value);
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR( 
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_NOTIFICATION_URL );
        mdr.dwMDDataType    = STRING_METADATA;
        mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_NOTIFICATION_URL;
        mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_NOTIFICATION_URL ) + 1 );;
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR(
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_HOSTID );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_HOSTID );
        mdr.dwMDDataType    = STRING_METADATA;
        mdr.pbMDData        = (PBYTE)MD_DEFAULT_BITS_HOSTID;
        mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( MD_DEFAULT_BITS_HOSTID ) + 1 );
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR(
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

        Value = MD_DEFAULT_HOSTID_FALLBACK_TIMEOUT;
        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_HOSTID_FALLBACK_TIMEOUT );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_HOSTID_FALLBACK_TIMEOUT );
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (PBYTE)&Value;
        mdr.dwMDDataLen     = sizeof(Value);
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR( 
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

#if defined( ALLOW_OVERWRITES )

        Value = MD_DEFAULT_BITS_ALLOW_OVERWRITES;
        mdr.dwMDIdentifier  = PropertyMan.GetPropertyMetabaseID( MD_BITS_ALLOW_OVERWRITES );
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = PropertyMan.GetPropertyUserType( MD_BITS_ALLOW_OVERWRITES );
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (PBYTE)&Value;
        mdr.dwMDDataLen     = sizeof(Value);
        mdr.dwMDDataTag     = 0;

        THROW_COMERROR( 
            IISAdminBase->SetData(
                mdHandle,
                NULL,
                &mdr ) );

#endif

        IISAdminBase->CloseKey( mdHandle );

    }
    catch( ComError Error )
    {
        if ( mdHandle )
            IISAdminBase->CloseKey( mdHandle );
    }

}

void
AddDllToIISList(
    SAFEARRAY* Array )
{

    //
    // Add the ISAPI to the IIS list.   
    //

    // Search for the DLL.  If its already in the list, do nothing

    LogSetup( LogSevInformation, "[BITSSRV] Starting AddDllToIISList\r\n" );

    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    for ( unsigned int i = Array->rgsabound[0].lLbound; 
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements; i++ )
        {

        VARIANT & IElem = ((VARIANT*)Array->pvData)[i];

        if ( _wcsicmp( (WCHAR*)IElem.bstrVal, g_ISAPIPath ) == 0 )
            {
            // Dll is already in the list, do nothing
            return;
            }

        }

    // Need to add the DLL

    SAFEARRAYBOUND SafeBounds;
    SafeBounds.lLbound      = Array->rgsabound[0].lLbound;
    SafeBounds.cElements    = Array->rgsabound[0].cElements+1;

    ArrayLocker.Unlock();

    THROW_COMERROR( SafeArrayRedim( Array, &SafeBounds ) );
    
    SmartVariant bstrvar;
    bstrvar.vt = VT_BSTR;
    bstrvar.bstrVal = SysAllocString( g_ISAPIPath );
    if ( !bstrvar.bstrVal )
        THROW_COMERROR( E_OUTOFMEMORY );

    long Index = SafeBounds.lLbound + SafeBounds.cElements - 1;

    THROW_COMERROR( SafeArrayPutElement( Array, &Index, (void*)&bstrvar ) );

}

void
RemoveDllFromIISList(
    SAFEARRAY *Array )
{

    // Remove the DLL from the IIS list
    
    LogSetup( LogSevInformation, "[BITSSRV] Starting RemoveDllFromIISList\r\n" );

    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    ULONG  NewSize = 0;
    SIZE_T j = Array->rgsabound[0].lLbound;
    SIZE_T k = Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
    
    while( j < k )
        {

        VARIANT & JElem = ((VARIANT*)Array->pvData)[j];

        // This element is fine, keep it
        if ( 0 != _wcsicmp( (WCHAR*)JElem.bstrVal, g_ISAPIPath ) )
            {
            NewSize++;
            j++;
            }

        else
            {

            // find a suitable element to replace the bad element with
            while( j < --k )
                {
                VARIANT & KElem = ((VARIANT*)Array->pvData)[k];
                if ( 0 != _wcsicmp( (WCHAR*)KElem.bstrVal,  g_ISAPIPath ) )
                    {
                    // found element. move it
                    VARIANT temp = JElem;
                    JElem = KElem;
                    KElem = temp;
                    break;
                    }
                }
            }
        }

    SAFEARRAYBOUND ArrayBounds;
    ArrayBounds = Array->rgsabound[0];
    ArrayBounds.cElements = NewSize;

    ArrayLocker.Unlock();
    THROW_COMERROR( SafeArrayRedim( Array, &ArrayBounds ) );

}

void
ModifyLockdownList( bool Add )
{

    // Toplevel function to modify the IIS lockdown list.
    // If Add is 1, then the ISAPI is added.  If Add is 0, then the ISAPI is removed.

    LogSetup( LogSevInformation, "[BITSSRV] Starting ModifyLockdownList Add(%u)\r\n", (UINT32)Add );

    SmartIADsPointer    Service;
    SAFEARRAY*          Array    = NULL;
    SmartVariant        var;


    THROW_COMERROR( 
        ADsGetObject( L"IIS://LocalHost/W3SVC", 
                      Service.GetUUID(), (void**)Service.GetRecvPointer() ) );
    
    {
    
        HRESULT Hr = Service->Get( g_IsapiRestrictionListBSTR, &var );
        if ( FAILED(Hr) )
            {
            // This property doesn't exist on IIS5 or IIS5.1 don't install it
            return;
            }

    }
    Array = var.parray;

    {

        SafeArrayLocker ArrayLocker( Array );
        ArrayLocker.Lock();

        if ( !Array->rgsabound[0].cElements )
            {
            // The array has no elements which means no restrictions.
            return;
            }

        VARIANT & FirstElem = ((VARIANT*)Array->pvData)[ Array->rgsabound[0].lLbound ];
        if ( _wcsicmp(L"0", (WCHAR*)FirstElem.bstrVal ) == 0 )
            {

            // 
            // According to the IIS6 spec, a 0 means that all ISAPIs are denied except
            // those that are explicitly listed.  
            // 
            // If installing:   add to the list. 
            // If uninstalling: remove from the list
            //

            ArrayLocker.Unlock();
            
            if ( Add )
                AddDllToIISList( Array );
            else
                RemoveDllFromIISList( Array );

            }
        else if ( _wcsicmp( L"1", (WCHAR*)FirstElem.bstrVal ) == 0 )
            {

            //
            // According to the IIS6 spec, a 1 means that all ISAPIs are allowed except
            // those that are explicitly denied. 
            //
            // If installing:   remove from the list
            // If uninstalling: Do nothing
            //

            ArrayLocker.Unlock();
            
            if ( Add )
                RemoveDllFromIISList( Array );

            }
        else
            {
            LogSetup( LogSevInformation, "[BITSSRV] The old IIS lockdown list is corrupt\r\n" );
            THROW_COMERROR( E_FAIL );
            }

        THROW_COMERROR( Service->Put(  g_IsapiRestrictionListBSTR, var ) );
        THROW_COMERROR( Service->SetInfo() );

    }

}

void
AddToLockdownListDisplayPutString( 
    SAFEARRAY *Array,
    unsigned long Position,
    const WCHAR *String )
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting AddToLockdownListDisplayPutString\r\n" );

    SmartVariant Var;
    Var.vt          =   VT_BSTR;
    Var.bstrVal     =   SysAllocString( String );

    if ( !Var.bstrVal )
        THROW_COMERROR( E_OUTOFMEMORY ); 

    long Index = (unsigned long)Position;
    THROW_COMERROR( SafeArrayPutElement( Array, &Index, (void*)&Var ) );

}

void
AddToLockdownListDisplay( SAFEARRAY *Array )
{

    //
    //  Check to see if the ISAPI is already in the list.  If it is, don't modify 
    //  list.
    //

    LogSetup( LogSevInformation, "[BITSSRV] Starting AddToLockdownListDisplay\r\n" );

    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    for( unsigned long i = Array->rgsabound[0].lLbound;
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
         i++ )
        {

        VARIANT & CurrentElement = ((VARIANT*)Array->pvData)[ i ];
        BSTR BSTRString = CurrentElement.bstrVal;

        if ( _wcsicmp( (WCHAR*)BSTRString, g_ISAPIPath ) == 0 )
            {
            // ISAPI is already in the list, don't do anything
            return;
            }

        }

     
    SAFEARRAYBOUND SafeArrayBound = Array->rgsabound[0];
    unsigned long OldSize = SafeArrayBound.cElements;
    SafeArrayBound.cElements += 3;
    
    ArrayLocker.Unlock();
    THROW_COMERROR( SafeArrayRedim( Array, &SafeArrayBound ) );
    AddToLockdownListDisplayPutString( Array, OldSize, L"1" );
    AddToLockdownListDisplayPutString( Array, OldSize + 1, g_ISAPIPath );
    AddToLockdownListDisplayPutString( Array, OldSize + 2, g_ExtensionNameString );

}

void
SafeArrayRemoveSlice(
    SAFEARRAY *Array,
    unsigned long lBound,
    unsigned long uBound )
{

    // Remove a slice of an array.

    LogSetup( LogSevInformation, "[BITSSRV] Starting SafeArrayRemoveSlice\r\n" );

    SIZE_T ElementsToRemove = uBound - lBound + 1;
    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    if ( uBound + 1 < Array->rgsabound[0].cElements )
        {
        // At least one element exists above this element

        // Step 1, move slice to temp storage

        VARIANT *Temp = (VARIANT*)new BYTE[ sizeof(VARIANT) * ElementsToRemove ];
        memcpy( Temp, &((VARIANT*)Array->pvData)[ lBound ], sizeof(VARIANT)*ElementsToRemove );

		// Step 2, collapse hole left by slice
        memmove( &((VARIANT*)Array->pvData)[ lBound ],
                 &((VARIANT*)Array->pvData)[ uBound + 1 ],
                 sizeof(VARIANT) * ( Array->rgsabound[0].cElements - ( uBound + 1 ) ) );

		// Step 3, move slice to end of array
		memcpy( &((VARIANT*)Array->pvData)[ Array->rgsabound[0].cElements - ElementsToRemove ],
			    Temp,
				sizeof(VARIANT)*ElementsToRemove );
        delete[] Temp;

        }

    SAFEARRAYBOUND SafeArrayBound = Array->rgsabound[0];
    SafeArrayBound.cElements -= (ULONG)ElementsToRemove;

    ArrayLocker.Unlock();
    SafeArrayRedim( Array, &SafeArrayBound );

}

void
RemoveFromLockdownListDisplay(
    SAFEARRAY *Array )
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting RemoveFromLockdownListDisplay\r\n" );

    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    for( unsigned int i = Array->rgsabound[0].lLbound;
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
         i++ )
        {

        VARIANT & CurrentElement = ((VARIANT*)Array->pvData)[ i ];
        BSTR BSTRString = CurrentElement.bstrVal;

        if ( _wcsicmp( (WCHAR*)BSTRString, g_ISAPIPath ) == 0 )
            {
            // ISAPI is in the list, remove it

            ArrayLocker.Unlock();

            SafeArrayRemoveSlice( 
                Array,
                (i == 0) ? 0 : i - 1,
                min( i + 1, Array->rgsabound[0].cElements - 1 ) );
            
            ArrayLocker.Lock();
            }

        }

    // ISAPI wasn't found. Nothing to do.

}

void
ModifyLockdownListDisplay( bool Add )
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting ModifyLockdownListDisplay Add(%u)\r\n", (UINT32)Add );    
    
    SAFEARRAY* Array    = NULL;
    SmartIADsPointer Service;

    SmartVariant var;

    THROW_COMERROR( 
        ADsGetObject( L"IIS://LocalHost/W3SVC", 
                      Service.GetUUID(), (void**)Service.GetRecvPointer() ) );
    
    {
    
    HRESULT Hr = Service->Get( g_RestrictionListCustomDescBSTR, &var );

    if ( FAILED(Hr) )
        {
        // This property doesn't exist on IIS5 or IIS5.1 don't install or uninstall it
        return;
        }
    }

    Array = var.parray;

    if ( Add )
        AddToLockdownListDisplay( Array );
    else 
        RemoveFromLockdownListDisplay( Array );

    THROW_COMERROR( Service->Put( g_RestrictionListCustomDescBSTR, var ) );
    THROW_COMERROR( Service->SetInfo() );
}

void
RemoveFilterIfNeeded()
{
    
    LogSetup( LogSevInformation, "[BITSSRV] Starting RemoveFilterIfNeeded\r\n" );    

    SmartVariant var;

    WCHAR *LoadOrder = NULL;
    MemoryArrayCleaner<WCHAR> LoadOrderCleaner( LoadOrder ); // frees temp memory

    SmartIADsContainerPointer MbFiltersContainer;
    SmartIADsPointer Object;

    THROW_COMERROR(
         ADsGetObject( L"IIS://LocalHost/W3SVC/Filters", 
                       MbFiltersContainer.GetUUID(), (void**)MbFiltersContainer.GetRecvPointer() ) );
    // Remove bits from the load path	

    THROW_COMERROR( MbFiltersContainer->QueryInterface( Object.GetUUID(), (void**)Object.GetRecvPointer() ) );
    THROW_COMERROR( Object->Get( g_FilterLoadOrderBSTR, &var ) );
    THROW_COMERROR( VariantChangeType( &var, &var, 0, VT_BSTR ) );

    SIZE_T LoadOrderLength = wcslen( (WCHAR*)var.bstrVal ) + 1;
    LoadOrder = new WCHAR[ LoadOrderLength ]; // freed on cleanup
    memcpy( LoadOrder, (WCHAR*)var.bstrVal, LoadOrderLength * sizeof( WCHAR ) );
    
    // remove any old bitsserver entries
    RemoveFilterHelper( LoadOrder, L",bitsserver" );
    RemoveFilterHelper( LoadOrder, L"bitsserver," );
    RemoveFilterHelper( LoadOrder, L"bitsserver" );
    RemoveFilterHelper( LoadOrder, L",bitserver" );
    RemoveFilterHelper( LoadOrder, L"bitserver," );
    RemoveFilterHelper( LoadOrder, L"bitserver" );

    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString( LoadOrder );

    if ( !var.bstrVal )
        THROW_COMERROR( E_OUTOFMEMORY );

    THROW_COMERROR( Object->Put( g_FilterLoadOrderBSTR, var ) );
    THROW_COMERROR( Object->SetInfo() );
    
    MbFiltersContainer->Delete( g_IIsFilterBSTR, g_bitsserverBSTR );
    MbFiltersContainer->Delete( g_IIsFilterBSTR, g_bitserverBSTR );

    Object->SetInfo();

}

void
ModifyInProcessList( bool Add )
{

    // Toplevel function to modify the IIS inprocess list.
    // If Add is 1, then the ISAPI is added.  If Add is 0, then the ISAPI is removed.

    LogSetup( LogSevInformation, "[BITSSRV] Starting ModifyInProcessList, Add(%u)\r\n", (UINT32)Add );

    SmartIADsPointer Service;
    SmartVariant var;
    
    THROW_COMERROR( 
        ADsGetObject( L"IIS://LocalHost/W3SVC", 
        Service.GetUUID(), (void**)Service.GetRecvPointer() ) );

    THROW_COMERROR( Service->Get( g_InProcessIsapiAppsBSTR, &var ) );

    if ( Add )
        AddDllToIISList( var.parray );
    else
        RemoveDllFromIISList( var.parray );

    THROW_COMERROR( Service->Put( g_InProcessIsapiAppsBSTR, var ) );
    THROW_COMERROR( Service->SetInfo() );

}

void
RemoveFromWebSvcList(
    SAFEARRAY *Array )
{
  
    LogSetup( LogSevInformation, "[BITSSRV] Starting RemoveFromWebSvcList\r\n" );

    StringHandleW SearchString = L",";
    SearchString += g_ISAPIPath;
    SearchString += L",";

    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    ULONG  NewSize = 0;
    SIZE_T j = Array->rgsabound[0].lLbound;
    SIZE_T k = Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements;
    
    while( j < k )
        {

        VARIANT & JElem = ((VARIANT*)Array->pvData)[j];

        // This element is fine, keep it
        if ( !wcsstr( (WCHAR*)JElem.bstrVal, (const WCHAR*)SearchString ) )
            {
            NewSize++;
            j++;
            }

        else
            {

            // find a suitable element to replace the bad element with
            while( j < --k )
                {
                VARIANT & KElem = ((VARIANT*)Array->pvData)[k];
                if ( !wcsstr( (WCHAR*)KElem.bstrVal,  (const WCHAR*)SearchString ) )
                    {
                    // found element. move it
                    VARIANT temp = JElem;
                    JElem = KElem;
                    KElem = temp;
                    break;
                    }
                }
            }
        }

    SAFEARRAYBOUND ArrayBounds;
    ArrayBounds = Array->rgsabound[0];
    ArrayBounds.cElements = NewSize;

    ArrayLocker.Unlock();
    THROW_COMERROR( SafeArrayRedim( Array, &ArrayBounds ) );

}


void
AddToWebSvcList(
    SAFEARRAY* Array )
{

    //
    // Add the ISAPI to the IIS list.   
    //

    LogSetup( LogSevInformation, "[BITSSRV] Starting AddToWebSvcList\r\n" );

    // Search for the DLL.  If its already in the list, do nothing

    SafeArrayLocker ArrayLocker( Array );
    ArrayLocker.Lock();

    // Enclose the path with commas to decrease chance of a false hit
    StringHandleW ISAPIPath = L",";
    ISAPIPath += g_ISAPIPath;
    ISAPIPath += L",";

    for ( unsigned int i = Array->rgsabound[0].lLbound; 
         i < Array->rgsabound[0].lLbound + Array->rgsabound[0].cElements; i++ )
        {

        VARIANT & IElem = ((VARIANT*)Array->pvData)[i];

        if ( wcsstr( (WCHAR*)IElem.bstrVal, (const WCHAR*)ISAPIPath ) )
            {
            // Dll is already in the list, do nothing
            return;
            }

        }

    // Need to add the DLL

    SAFEARRAYBOUND SafeBounds;
    SafeBounds.lLbound      = Array->rgsabound[0].lLbound;
    SafeBounds.cElements    = Array->rgsabound[0].cElements+1;

    ArrayLocker.Unlock();

    THROW_COMERROR( SafeArrayRedim( Array, &SafeBounds ) );
    
    // build the lockdown string
    StringHandleW  LockdownString;
    LockdownString += L"1,";                        // Is enabled
    LockdownString += g_ISAPIPath;                  // ISAPI path
    LockdownString += L",0," BITS_GROUP_IDW L",";   // not deletable
    LockdownString += g_ExtensionNameString;        // description

    SmartVariant bstrvar;
    bstrvar.vt = VT_BSTR;
    bstrvar.bstrVal = SysAllocString( (const WCHAR*)LockdownString );
    if ( !bstrvar.bstrVal )
        THROW_COMERROR( E_OUTOFMEMORY );

    long Index = SafeBounds.lLbound + SafeBounds.cElements - 1;

    THROW_COMERROR( SafeArrayPutElement( Array, &Index, (void*)&bstrvar ) );

}

void
ModifyWebSvcRestrictionList( bool Add )
{

    // Toplevel function to modify the IIS lockdown list.
    // If Add is 1, then the ISAPI is added.  If Add is 0, then the ISAPI is removed.

    LogSetup( LogSevInformation, "[BITSSRV] Starting ModifyWebSvcRestrictionList, Add(%u)\r\n", (UINT32)Add );

    SmartIADsPointer    Service;
    SAFEARRAY*          Array    = NULL;
    SmartVariant        var;


    THROW_COMERROR( 
        ADsGetObject( L"IIS://LocalHost/W3SVC", 
                      Service.GetUUID(), (void**)Service.GetRecvPointer() ) );
    
    {
    
        HRESULT Hr = Service->Get( g_WebSvcExtRestrictionListBSTR, &var );
        if ( FAILED(Hr) )
            {
            // This property doesn't exist on IIS5 or IIS5.1 don't install it
            return;
            }

    }
    Array = var.parray;

    if ( Add )
        AddToWebSvcList( Array );
    else
        RemoveFromWebSvcList( Array );


    THROW_COMERROR( Service->Put(  g_WebSvcExtRestrictionListBSTR, var ) );
    THROW_COMERROR( Service->SetInfo() );

}


void
StartupMSTask()
{
    
    LogSetup( LogSevInformation, "[BITSSRV] Starting StartMSTask\r\n" );    
    
    SC_HANDLE   hSC     = NULL;
    SC_HANDLE   hSchSvc = NULL;

    BYTE* ConfigBuffer  = NULL;
    MemoryArrayCleaner<BYTE> ConfigBufferCleaner( ConfigBuffer );
    DWORD BytesNeeded   = 0;

    try
        {

        hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
        if (hSC == NULL)
           THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );
        
        hSchSvc = OpenService(hSC,
                              "Schedule",
                              SERVICE_ALL_ACCESS );
        
        if ( !hSchSvc )
            THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );
        
        SERVICE_STATUS SvcStatus;
        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
            THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );
        
        if (SvcStatus.dwCurrentState == SERVICE_RUNNING)
            {
            // Service is already running
            CloseServiceHandle( hSC );
            CloseServiceHandle( hSchSvc );
            return;
            }

        LogSetup( LogSevInformation, "[BITSSRV] MSTask isn't running, need to start it up\r\n" );
        SetLastError( ERROR_SUCCESS );

        ConfigBuffer = new BYTE[CONFIG_BUFFER_MAX];
        if (!ConfigBuffer)
            {
            throw ComError(E_OUTOFMEMORY);
            }

        if ( !QueryServiceConfig(
                hSchSvc,
                (LPQUERY_SERVICE_CONFIG)ConfigBuffer,
                BytesNeeded,
                &BytesNeeded ) )
            {
            THROW_COMERROR(  HRESULT_FROM_WIN32( GetLastError() ) );
            }

        if ( ((LPQUERY_SERVICE_CONFIG)ConfigBuffer)->dwStartType != SERVICE_AUTO_START )
            {
            
            if ( !ChangeServiceConfig(
                     hSchSvc,
                     SERVICE_NO_CHANGE,          // type of service
                     SERVICE_AUTO_START,         // when to start service
                     SERVICE_NO_CHANGE,          // severity of start failure
                     NULL,                       // service binary file name
                     NULL,                       // load ordering group name
                     NULL,                       // tag identifier
                     NULL,                       // array of dependency names
                     NULL,                       // account name
                     NULL,                       // account password
                     NULL                        // display name
                     ) )
                THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

            }

        if ( StartService(hSchSvc, 0, NULL) == FALSE )
            THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

        // Poll for the service to enter the running or error state

        while( 1 )
            {

            if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
                THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );

            if ( SvcStatus.dwCurrentState == SERVICE_STOPPED ||
                 SvcStatus.dwCurrentState == SERVICE_PAUSED )
                throw ComError( HRESULT_FROM_WIN32( SvcStatus.dwCurrentState ) );

            if ( SvcStatus.dwCurrentState == SERVICE_RUNNING )
                break;

            }

        CloseServiceHandle( hSC );
        CloseServiceHandle( hSchSvc );

        }
    catch( ComError Error )
        {
        if ( hSchSvc )
            CloseServiceHandle( hSC );
        
        if ( hSC )
            CloseServiceHandle( hSchSvc );
        }
}

#if 0

void
ProcessVerbsInIniSection(
    WCHAR *Section,
    WCHAR *Verb,
    WCHAR *FileName,
    bool Add )
{
    
    WCHAR *SectionData = (WCHAR*)new WCHAR[ 32768 ];
    MemoryArrayCleaner<WCHAR> SectionDataCleaner( SectionData );
    WCHAR *NewSectionData = (WCHAR*)new WCHAR[ 32768 * 2 ];
    MemoryArrayCleaner<WCHAR> NewSectionDataCleaner( SectionData );

    DWORD Result =
        GetPrivateProfileSectionW(
            Section,                  // section name
            SectionData,              // return buffer
            32768,                    // size of return buffer
            FileName                  // initialization file name
            );


    if ( Result == 32768 - 2 )
        {
        // The buffer is not large enough.  Interestingly,
        // even urlscan is not capable of handing a section this
        // large so just assume the file is corrupt and ignore it.
        return;
        }

    if ( Add )
        {

        // Loop through the list copying it to the new buffer.
        // Stop if the verb has already been added.

        WCHAR *OriginalVerb     = SectionData;
        WCHAR *NewVerb          = NewSectionData;

        while( *OriginalVerb )
            {

            if ( wcscmp( OriginalVerb, Verb ) == 0 )
                {
                // verb already found, no more processing needed
                return;
                }

            SIZE_T VerbSize = wcslen( OriginalVerb ) + 1;
            memcpy( NewVerb, OriginalVerb, sizeof( WCHAR ) * VerbSize );
            OriginalVerb  += VerbSize;
            NewVerb       += VerbSize;
            }

        // add the verb since it hasn't been added
        SIZE_T VerbSize = wcslen( Verb ) + 1;
        memcpy( NewVerb, Verb, sizeof( WCHAR ) * VerbSize );
        NewVerb[ VerbSize ] = '\0'; // end the list

        }
    else
        {

        // Loop though the list copying all nonmatching verbs to the new buffer
        // Keep track if list changes
        
        bool ListChanged = false;
        WCHAR *OriginalVerb     = SectionData;
        WCHAR *NewVerb          = NewSectionData;

        while( *OriginalVerb )
            {

            if ( wcscmp( OriginalVerb, Verb ) == 0 )
                {
                // verb to remove, skip it
                OriginalVerb += wcslen( OriginalVerb ) + 1;
                ListChanged = true;
                }
            else
                {
                // copy the verb
                SIZE_T VerbSize = wcslen( OriginalVerb ) + 1;
                memcpy( NewVerb, OriginalVerb, sizeof( WCHAR ) * VerbSize );
                OriginalVerb  += VerbSize;
                NewVerb       += VerbSize;
                }

            }

        if ( !ListChanged )
            {
            return;
            }

        *NewVerb = '\0'; // end the list

        }

    if ( !WritePrivateProfileSectionW(
            Section,            // section name
            NewSectionData,     // data
            FileName            // file name
            ) )
        {
        THROW_COMERROR( HRESULT_FROM_WIN32( GetLastError() ) );
        }
}

void ModifyURLScanFiles(
    bool Add )
{

    // Loop though the list of filters and find valid copies of urlscan.ini

    SmartIADsContainerPointer MbFiltersContainer;
    SmartIEnumVARIANTPointer  EnumVariant;
    SmartIADsPointer          Filter;
    SmartIUnknownPointer      Unknown;
    SmartVariant Var;

    THROW_COMERROR( 
         ADsGetObject( L"IIS://LocalHost/W3SVC/Filters", 
                       MbFiltersContainer.GetUUID(), (void**)MbFiltersContainer.GetRecvPointer() ) );

    THROW_COMERROR( MbFiltersContainer->get__NewEnum( Unknown.GetRecvPointer() ) );
    THROW_COMERROR( Unknown->QueryInterface( EnumVariant.GetUUID(), 
                                             (void**)EnumVariant.GetRecvPointer() ) );

    while( 1 )
        {

        ULONG NumberFetched;

        THROW_COMERROR( EnumVariant->Next( 1, &Var, &NumberFetched ) ); 

        if ( S_FALSE == Hr )
            {
            // All the filters were looped though.
            return;
            }

        THROW_COMERROR( VariantChangeType( &Var, &Var, 0, VT_UNKNOWN ) );
        THROW_COMERROR( Var.punkVal->QueryInterface( Filter.GetUUID(), 
                                                     (void**)Filter.GetRecvPointer() ) );


        VariantClear( &Var );
        THROW_COMERROR( Filter->Get( (BSTR)L"FilterPath", &Var ) );
        THROW_COMERROR( VariantChangeType( &Var, &Var, 0, VT_BSTR ) );

        // Test if this is UrlScan and bash the filepart 
        WCHAR * FilterPathString     = (WCHAR*)Var.bstrVal;
        SIZE_T FilterPathStringSize  = wcslen( FilterPathString );
        const WCHAR UrlScanDllName[] = L"urlscan.dll";
        const WCHAR UrlScanIniName[] = L"urlscan.ini";
        const SIZE_T UrlScanNameSize = sizeof( UrlScanDllName ) / sizeof( *UrlScanDllName );

        if ( FilterPathStringSize < UrlScanNameSize )
            continue;

        WCHAR * FilterPathStringFilePart = FilterPathString + FilterPathStringSize - UrlScanNameSize;

        if ( _wcsicmp( FilterPathStringFilePart, UrlScanDllName ) != 0 )
            continue;

        // this is an urlscan.dll filter, bash the filename to get the ini file name

        wcscpy( FilterPathStringFilePart, UrlScanIniName );

        WCHAR *IniFileName = FilterPathString;

        UINT AllowVerbs =
            GetPrivateProfileIntW( 
                L"options",
                L"UseAllowVerbs",
                -1,
                IniFileName );

        if ( AllowVerbs != 0 && AllowVerbs != 1 )
            continue; // missing or broken ini file

        if ( AllowVerbs )
            THROW_COMERROR( ProcessVerbsInIniSection( L"AllowVerbs", L"BITS_POST", 
                                                      IniFileName, Add ) );
        else
            THROW_COMERROR( ProcessVerbsInIniSection( L"DenyVerbs", L"BITS_POST", 
                                                      IniFileName, !Add ) );

        }

}

#endif

void UpgradeOrDisableVDirs( bool ShouldUpgrade )
{

    // If ShouldUpgrade is true, then all the BITS virtual directories will be upgraded.
    // If ShouldUpgrade is false, then this is a deinstall then all virtual directories 
    // that are enabled will be disabled. 

    if ( ShouldUpgrade )
        {
        LogSetup( LogSevInformation, "[BITSSRV] Starting upgrade of virtual directories\r\n" );    
        }
    else
        {
        LogSetup( LogSevInformation, "[BITSSRV] Starting disable of virtual directories\r\n" );    
}

    SmartBITSExtensionSetupFactoryPointer   SetupFactory;
    SmartMetabasePointer                    AdminBase;

    {

        HRESULT Hr = 
            CoCreateInstance(
               __uuidof( BITSExtensionSetupFactory ), 
               NULL,
               CLSCTX_INPROC_SERVER,
               __uuidof( IBITSExtensionSetupFactory ),
               (void**)SetupFactory.GetRecvPointer() );

        if ( REGDB_E_CLASSNOTREG == Hr )
            {
            // This must be a new install, or the factory was never registered
            // Nothing to upgrade. Or the factory was removed.
            LogSetup( LogSevInformation, "[BITSSRV] Nothing to upgrade or disable\r\n" );                
            return;
            }

        THROW_COMERROR( Hr );

    }

    THROW_COMERROR(
            CoCreateInstance(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                AdminBase.GetUUID(),
                (LPVOID*)AdminBase.GetRecvPointer() ) );

    PropertyIDManager PropertyMan;
    THROW_COMERROR( PropertyMan.LoadPropertyInfo() );

    WCHAR *PathBuffer      = NULL;
    WCHAR *CurrentPath     = NULL;
    BSTR VDirToModifyBSTR  = NULL;

    try
    {
        PathBuffer  = new WCHAR[ 256 ];
        DWORD RequiredBufferSize = 0;

        {

            HRESULT Hr =
                AdminBase->GetDataPaths(
                    METADATA_MASTER_ROOT_HANDLE,    //metabase handle. 
                    L"\\LM\\W3SVC",                 //path to the key, relative to hMDHandle.
                    PropertyMan.GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED ),  //identifier of the data.
                    DWORD_METADATA,                 //type of data.
                    256,                            //the size, in wchars, of pbBuffe.r.
                    PathBuffer,                     //the buffer that receives the data. 
                    &RequiredBufferSize             //if the method fails, receives 
                    );

            if ( SUCCEEDED( Hr ) )
                goto process_buffer;

            if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
                throw ComError( Hr );

        }

        delete[] PathBuffer;
        PathBuffer = NULL;
        PathBuffer = new WCHAR[ RequiredBufferSize ];

        THROW_COMERROR(
            AdminBase->GetDataPaths(
                METADATA_MASTER_ROOT_HANDLE,    //metabase handle. 
                L"\\LM\\W3SVC",                 //path to the key, relative to hMDHandle.
                PropertyMan.GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED ), //identifier of the data.
                DWORD_METADATA,                 //type of data.
                RequiredBufferSize,             //the size, in wchars, of pbBuffe.r.
                PathBuffer,                     //the buffer that receives the data. 
                &RequiredBufferSize             //if the method fails, receives 
                ) );

process_buffer:
        for( CurrentPath = PathBuffer; *CurrentPath; CurrentPath += wcslen( CurrentPath ) + 1 )
            {

            DWORD BufferRequired;
            METADATA_RECORD MdRecord;
            DWORD IsEnabled = 0;

            MdRecord.dwMDIdentifier = PropertyMan.GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
            MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
            MdRecord.dwMDUserType   = ALL_METADATA;
            MdRecord.dwMDDataType   = DWORD_METADATA;
            MdRecord.dwMDDataLen    = sizeof(IsEnabled);
            MdRecord.pbMDData       = (PBYTE)&IsEnabled;
            MdRecord.dwMDDataTag    = 0;

            THROW_COMERROR( 
                AdminBase->GetData(
                    METADATA_MASTER_ROOT_HANDLE,
                    CurrentPath,
                    &MdRecord,
                    &BufferRequired ) );

            if ( IsEnabled )
                {

                SmartBITSExtensionSetupPointer Setup;

                VDirToModifyBSTR = SysAllocString( CurrentPath );

                LogSetup( LogSevInformation, "[BITSSRV] Handleing upgrade/disable of %S\r\n", (WCHAR*)VDirToModifyBSTR );

                THROW_COMERROR( 
                    SetupFactory->GetObject( VDirToModifyBSTR, Setup.GetRecvPointer() ) );

                if ( ShouldUpgrade ) 
                   THROW_COMERROR( Setup->EnableBITSUploads() );
                else
                   THROW_COMERROR( Setup->DisableBITSUploads() );

                SysFreeString( VDirToModifyBSTR );
                VDirToModifyBSTR = NULL;

                }

            }

    }
    catch( ComError Error )
    {
        if ( PathBuffer )
            delete[] PathBuffer;

        SysFreeString( VDirToModifyBSTR );

        throw Error;
    }

}

void 
RemoveProperty(
    SmartMetabasePointer & AdminBase,
    PropertyIDManager & PropertyMan,
    METADATA_HANDLE RootHandle,
    DWORD PropNumber )
{

    WCHAR *PathBuffer      = NULL;
    WCHAR *CurrentPath     = NULL;

    LogSetup( LogSevInformation, "[BITSSRV] Starting RemoveProperty(PropNumber %u)\r\n", PropNumber );

    try
    {
        PathBuffer  = new WCHAR[ 256 ];
        DWORD RequiredBufferSize = 0;

        {

            HRESULT Hr =
                AdminBase->GetDataPaths(
                    RootHandle,                     //metabase handle. 
                    NULL,                           //path to the key, relative to hMDHandle.
                    PropertyMan.GetPropertyMetabaseID( PropNumber ),  //identifier of the data.
                    ALL_METADATA,                   //type of data.
                    256,                            //the size, in wchars, of pbBuffer.
                    PathBuffer,                     //the buffer that receives the data. 
                    &RequiredBufferSize             //if the method fails, receives 
                    );

            if ( SUCCEEDED( Hr ) )
                goto process_buffer;

            if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
                throw ComError( Hr );

        }

        delete[] PathBuffer;
        PathBuffer = NULL;
        PathBuffer = new WCHAR[ RequiredBufferSize ];

        THROW_COMERROR(
            AdminBase->GetDataPaths(
                RootHandle,                     //metabase handle. 
                NULL,                           //path to the key, relative to hMDHandle.
                PropertyMan.GetPropertyMetabaseID( PropNumber ), //identifier of the data.
                ALL_METADATA,                   //type of data.
                RequiredBufferSize,             //the size, in wchars, of pbBuffe.r.
                PathBuffer,                     //the buffer that receives the data. 
                &RequiredBufferSize             //if the method fails, receives 
                ) );

process_buffer:
        for( CurrentPath = PathBuffer; *CurrentPath; CurrentPath += wcslen( CurrentPath ) + 1 )
            {

            THROW_COMERROR( 
                AdminBase->DeleteData(
                     RootHandle,                                     //metadata handle.
                     CurrentPath,                                    //path to the key relative to hMDHandle.
                     PropertyMan.GetPropertyMetabaseID( PropNumber ),//identifier of the data.
                     ALL_METADATA                                    //type of data to remove.
                     ) );

            }

    }
    catch( ComError Error )
    {
        if ( PathBuffer )
            delete[] PathBuffer;

        throw Error;
    }

}

void RemoveMetabaseProperties()
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting RemoveMetabaseProperties\r\n" );

    SmartMetabasePointer  AdminBase;

    THROW_COMERROR(
        CoCreateInstance(
            GETAdminBaseCLSID(TRUE),
            NULL,
            CLSCTX_SERVER,
            AdminBase.GetUUID(),
            (LPVOID*)AdminBase.GetRecvPointer() ) );

    PropertyIDManager PropertyMan;
    THROW_COMERROR( PropertyMan.LoadPropertyInfo() );

    METADATA_HANDLE RootHandle = NULL; 

    try
        {
         
        THROW_COMERROR( AdminBase->OpenKey(
            METADATA_MASTER_ROOT_HANDLE,  //metabase handle.
            L"\\LM\\W3SVC",               //path to the key, relative to hMDHandle.
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            METABASE_OPEN_KEY_TIMEOUT,
            &RootHandle                   //receives the handle to the opened key.
            ) );

        for ( SIZE_T i = 0; i < g_NumberOfProperties; i++ )
        {
            RemoveProperty( AdminBase, PropertyMan, RootHandle, g_Properties[i].PropertyNumber );
        }
        
        AdminBase->CloseKey( RootHandle );
        RootHandle = NULL;

        }
    catch( ComError )
        {

        if ( RootHandle )
           {
           AdminBase->CloseKey( RootHandle );
           }
        throw;
        }
}

void FlushMetabase()
{

    LogSetup( LogSevInformation, "[BITSSRV] Starting FlushMetabase\r\n" );

    SmartMetabasePointer IISAdminBase;

    THROW_COMERROR(
         CoCreateInstance(
             GETAdminBaseCLSID(TRUE),
             NULL,
             CLSCTX_SERVER,
             IISAdminBase.GetUUID(),
             (LPVOID*)IISAdminBase.GetRecvPointer() ) );

    IISAdminBase->SaveData();

}

STDAPI DllRegisterServer()
{

    try
    {   
        LogSetup( LogSevInformation, "[BITSSRV] Starting regsvr of bitssrv.dll\r\n" );
        
        DetectProductVersion();
        InitializeSetup();
        RemoveFilterIfNeeded();
        StartupMSTask();
        InstallPropertySchema();
        InstallDefaultValues();
        ModifyLockdownList( true );
        ModifyLockdownListDisplay( true );
        ModifyInProcessList( true );
        ModifyWebSvcRestrictionList( true );
#if 0
        ModifyURLScanFiles( true );
#endif
        UpgradeOrDisableVDirs( true ); // this is an upgrade
        FlushMetabase();
        
        // Restart of IIS is not needed on windows xp/.NET server
        // IIS is smart enough to pickup the metabase changes
        if ( !g_IsWindowsXP )
            RestartIIS();

        LogSetup( LogSevInformation, "[BITSSRV] Finishing regsvr of bitssrv.dll\r\n" );

    }
    catch( ComError Error )
    {
        LogSetup( LogSevFatalError, "[BITSSRV] Hit fatal error in regsvr32 of bitssrv.dll, error %u\r\n", Error.m_Hr );
        return Error.m_Hr;
    }

    return S_OK;
}

STDAPI DllUnregisterServer()
{                                   
    //
    // Main entry point for setup unregistration
    //

    try
    {
        LogSetup( LogSevInformation, "[BITSSRV] Starting regsvr /u of bitssrv.dll\r\n" );
        
        DetectProductVersion();
        InitializeSetup();
        UpgradeOrDisableVDirs( false ); // disable all vdirs
        RemoveMetabaseProperties();    // remove all lingering properties
        RemovePropertySchema();
        ModifyLockdownList( false );
        ModifyLockdownListDisplay( false );
        ModifyInProcessList( false );
        ModifyWebSvcRestrictionList( false );
        FlushMetabase();

        // restart IIS to force an unload of the ISAPI
        RestartIIS();
    
        LogSetup( LogSevInformation, "[BITSSRV] Finishing regsvr /u of bitssrv.dll\r\n" );
    }
    catch( ComError Error )
    {   
        LogSetup( LogSevFatalError, "[BITSSRV] Hit fatal error in regsvr32 /u of bitssrv.dll, error %u\r\n", Error.m_Hr );
        return Error.m_Hr;
    }

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\isapi\utils.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    utils.cpp

Abstract:

    Utilities for the BITS server extensions

--*/

#include "precomp.h"

const char *LookupHTTPStatusCodeText(
    DWORD HttpCode
    )
{
    switch( HttpCode )
        {
        case 100:   return "100 Continue";
        case 101:   return "101 Switching Protocols";
        case 200:   return "200 OK";
        case 201:   return "201 Created";
        case 202:   return "202 Accepted";
        case 203:   return "203 Non-Authoritative Information";
        case 204:   return "204 No Content";
        case 205:   return "205 Reset Content";
        case 206:   return "206 Partial Content";
        case 300:   return "300 Multiple Choices";
        case 301:   return "301 Moved Permanently";
        case 302:   return "302 Found";
        case 303:   return "303 See Other";
        case 304:   return "304 Not Modified";
        case 305:   return "305 Use Proxy";
        case 306:   return "306 (Unused)";
        case 307:   return "307 Temporary Redirect";
        case 400:   return "400 Bad Request";
        case 401:   return "401 Unauthorized";
        case 402:   return "402 Payment Required";
        case 403:   return "403 Forbidden";
        case 404:   return "404 Not Found";
        case 405:   return "405 Method Not Allowed";
        case 406:   return "406 Not Acceptable";
        case 407:   return "407 Proxy Authentication Required";
        case 408:   return "408 Request Timeout";
        case 409:   return "409 Conflict";
        case 410:   return "410 Gone";
        case 411:   return "411 Length Required";
        case 412:   return "412 Precondition Failed";
        case 413:   return "413 Request Entity Too Large";
        case 414:   return "414 Request-URI Too Long";
        case 415:   return "415 Unsupported Media Type";
        case 416:   return "416 Requested Range Not Satisfiable";
        case 417:   return "417 Expectation Failed";
        case 500:   return "500 Internal Server Error";
        case 501:   return "501 Not Implemented";
        case 502:   return "502 Bad Gateway";
        case 503:   return "503 Service Unavailable";
        case 504:   return "504 Gateway Timeout";
        case 505:   return "505 HTTP Version Not Supported";

        default:
            return "";

        }

}

void
ServerException::SendErrorResponse(
    EXTENSION_CONTROL_BLOCK * ExtensionControlBlock
    ) const
{

    char Headers[255];
    StringCbPrintfA( 
        Headers,
        sizeof( Headers ),
        "Pragma: no-cache\r\n"
        "BITS-packet-type: Ack\r\n"
        "BITS-Error: 0x%8.8X\r\n"
        "\r\n", 
        m_Hr );

    ExtensionControlBlock->dwHttpStatusCode = m_HttpCode;

    BOOL Result;
    BOOL KeepConnection;

    Result =
        (ExtensionControlBlock->ServerSupportFunction)(
            ExtensionControlBlock->ConnID,
            HSE_REQ_IS_KEEP_CONN,
            &KeepConnection,
            NULL,
            NULL );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    // IIS5.0(Win2k) has a bug where KeepConnect is returned as -1
    // to keep the connection alive.   Apparently, this confuses the
    // HSE_REQ_SEND_RESPONSE_HEADER_EX call.   Bash the value into a real bool.

    KeepConnection = KeepConnection ? 1 : 0;

    HSE_SEND_HEADER_EX_INFO HeaderInfo;
    HeaderInfo.pszStatus = LookupHTTPStatusCodeText( m_HttpCode );
    HeaderInfo.cchStatus = strlen( HeaderInfo.pszStatus );
    HeaderInfo.pszHeader = Headers;
    HeaderInfo.cchHeader = strlen( Headers );
    HeaderInfo.fKeepConn = KeepConnection;

    Result =
        (ExtensionControlBlock->ServerSupportFunction)(
            ExtensionControlBlock->ConnID,
            HSE_REQ_SEND_RESPONSE_HEADER_EX,
            &HeaderInfo,
            NULL,
            NULL );

    if ( !Result )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

}

DWORD
ServerException::MapStatus( HRESULT Hr ) const
{
    switch( Hr )
        {
        case E_INVALIDARG:                                  return 400;
        // case HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ): return 400;
        case HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ):    return 404;
        case HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ):    return 404;
        case HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ):     return 403;
        // case E_ACCESSDENIED:                                return 401;
        default:                                            return 500;
        }
}

void * _cdecl ::operator new( size_t Size )
{
    void *Memory = HeapAlloc( GetProcessHeap(), 0, Size );
    if ( !Memory )
        {
        Log( LOG_ERROR, "Out of memory!\n" ); 
        throw ComError( ERROR_NOT_ENOUGH_MEMORY );        
        }
    return Memory;
}

void _cdecl ::operator delete( void *Memory )
{
    if ( !Memory )
        return;

    HeapFree( GetProcessHeap(), 0, Memory );
}


StringHandle 
GetMetaDataString(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    LPCSTR              DefaultValue )
{
    HRESULT Hr;
    DWORD BufferRequired = 0;

    StringHandleW Data;

    METADATA_RECORD MdRecord;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = ALL_METADATA;
    MdRecord.dwMDDataType   = STRING_METADATA;
    MdRecord.dwMDIdentifier = dwIdentifier;
    MdRecord.dwMDDataLen    = 0;
    MdRecord.pbMDData       = (PBYTE)NULL;
    MdRecord.dwMDDataTag    = 0;

    Hr =
        IISAdminBase->GetData(
            Handle,
            Path,
            &MdRecord,
            &BufferRequired );

    if ( SUCCEEDED( Hr ) )
        return (StringHandle)Data;

    if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
        HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
        return (StringHandle)DefaultValue;

    if ( Hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
        throw ServerException( Hr );

    MdRecord.pbMDData        = (PBYTE)Data.AllocBuffer( BufferRequired / 2 );
    MdRecord.dwMDDataLen     = BufferRequired;

    Hr =
        IISAdminBase->GetData(
            Handle,
            Path,
            &MdRecord,
            &BufferRequired );

    if ( FAILED( Hr ) )
        throw ServerException( Hr );

    Data.SetStringSize();
    return (StringHandle)Data;

}

DWORD 
GetMetaDataDWORD(
    IMSAdminBase        *IISAdminBase,
    METADATA_HANDLE     Handle,
    LPCWSTR             Path,
    DWORD               dwIdentifier,
    DWORD               DefaultValue )
{

    DWORD BufferRequired;
    DWORD MetabaseValue;

    METADATA_RECORD MdRecord;
    memset( &MdRecord, 0, sizeof( MdRecord ) );

    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = ALL_METADATA;
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDIdentifier = dwIdentifier;
    MdRecord.dwMDDataLen    = sizeof(MetabaseValue);
    MdRecord.pbMDData       = (PBYTE)&MetabaseValue;

    HRESULT Hr =
        IISAdminBase->GetData(
            Handle,
            Path,
            &MdRecord,
            &BufferRequired );
    
    if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
         HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
        return DefaultValue;

	if ( FAILED( Hr ) )
		throw ServerException( Hr );

    return MetabaseValue;
}

StringHandle
BITSUnicodeToStringHandle( const WCHAR *pStr )
{

    StringHandle RetValString;

    int RetVal =
        WideCharToMultiByte(
            CP_ACP,
            0,
            pStr,
            -1,
            NULL,
            0,
            NULL,
            NULL );

    if ( !RetVal )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    char *pRetBuffer = RetValString.AllocBuffer( RetVal );

    RetVal =
        WideCharToMultiByte(
                CP_ACP,
                0,
                pStr,
                -1,
                pRetBuffer,
                RetVal,
                NULL,
                NULL );

    if ( !RetVal )
        throw ServerException( HRESULT_FROM_WIN32( GetLastError() ) );

    RetValString.SetStringSize();

    return RetValString;
}

StringHandle
BITSUrlCombine(
    const char *Base,
    const char *Relative,
    DWORD dwFlags )
{

    DWORD dwCombined = 0;

    HRESULT Hr =
        UrlCombine(
            Base,
            Relative,
            NULL,
            &dwCombined,
            dwFlags );

    if ( FAILED(Hr) && ( Hr != E_POINTER ) )
        throw ServerException( Hr );

    StringHandle RetVal;
    char *Buffer = RetVal.AllocBuffer( dwCombined + 1 );

    Hr = 
        UrlCombine(
            Base,
            Relative,
            Buffer,
            &dwCombined,
            dwFlags );

    if ( FAILED(Hr) )
        throw ServerException( Hr );

    RetVal.SetStringSize();

    return RetVal;

}

StringHandle
BITSUrlCanonicalize(
    const char *URL,
    DWORD dwFlags )
{

    return 
        BITSUrlCombine(
            "",
            URL,
            dwFlags );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\bitsext.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    bitsext.cpp

Abstract :

    Main snapin code.

Author :

Revision History :

 ***********************************************************************/


#include "precomp.h"

bool    CPropSheetExtension::s_bStaticInitialized = false;
UINT    CPropSheetExtension::s_cfDisplayName;
UINT    CPropSheetExtension::s_cfSnapInCLSID;
UINT    CPropSheetExtension::s_cfNodeType;
UINT    CPropSheetExtension::s_cfSnapInMetapath;
UINT    CPropSheetExtension::s_cfSnapInMachineName;

const UINT CPropSheetExtension::s_MaxUploadUnits[] =
{
    IDS_BYTES,
    IDS_KILOBYTES,
    IDS_MEGABYTES,
    IDS_GIGABYTES,
    IDS_TERABYTES

};
const UINT CPropSheetExtension::s_NumberOfMaxUploadUnits = 
    sizeof(CPropSheetExtension::s_MaxUploadUnits)/
        sizeof(*CPropSheetExtension::s_MaxUploadUnits);

const UINT64 CPropSheetExtension::s_MaxUploadUnitsScales[] =
{
    1,
    1024,
    1048576,
    1073741824,
    1099511627776
};
const UINT CPropSheetExtension::s_NumberOfMaxUploadUnitsScales =
    sizeof(CPropSheetExtension::s_MaxUploadUnitsScales)/
        sizeof(*CPropSheetExtension::s_MaxUploadUnitsScales);


const UINT64 CPropSheetExtension::s_MaxUploadLimits[] =
{
    18446744073709551615, //bytes
    18014398509481983,    //kilobytes
    17592186044415,       //megabytes
    17179869183,          //gigabytes
    16777215              //terabytes

};

const UINT CPropSheetExtension::s_NumberOfMaxUploadLimits=
    sizeof(CPropSheetExtension::s_MaxUploadLimits)/
        sizeof(*CPropSheetExtension::s_MaxUploadLimits);

const UINT CPropSheetExtension::s_TimeoutUnits[] =
{
    IDS_SECONDS,
    IDS_MINUTES,
    IDS_HOURS,
    IDS_DAYS
};
const UINT CPropSheetExtension::s_NumberOfTimeoutUnits = 
    sizeof(CPropSheetExtension::s_TimeoutUnits)/
        sizeof(*CPropSheetExtension::s_TimeoutUnits);


const DWORD CPropSheetExtension::s_TimeoutUnitsScales[] =
{
    1,
    60,
    60*60,
    24*60*60
};
const UINT CPropSheetExtension::s_NumberOfTimeoutUnitsScales =
    sizeof(CPropSheetExtension::s_TimeoutUnitsScales)/
        sizeof(*CPropSheetExtension::s_TimeoutUnitsScales);
    
const UINT64 CPropSheetExtension::s_TimeoutLimits[] =
{
    4294967295, // seconds
    71582788,   // minutes
    1193046,    // hours
    49710       // days
};
    
const UINT CPropSheetExtension::s_NumberOfTimeoutLimits =
    sizeof(CPropSheetExtension::s_TimeoutLimits)/
        sizeof(*CPropSheetExtension::s_TimeoutLimits);


const UINT CPropSheetExtension::s_NotificationTypes[] =
{
    IDS_BYREF_POST_NOTIFICATION,
    IDS_BYVAL_POST_NOTIFICATION
    
};

const UINT CPropSheetExtension::s_NumberOfNotificationTypes =
    sizeof(CPropSheetExtension::s_NotificationTypes)/
        sizeof(*CPropSheetExtension::s_NotificationTypes);

HRESULT CPropSheetExtension::InitializeStatic()
{

    if ( s_bStaticInitialized )
        return S_OK;

    if ( !( s_cfDisplayName         =   RegisterClipboardFormat(L"CCF_DISPLAY_NAME") )      ||
         !( s_cfNodeType            =   RegisterClipboardFormat(L"CCF_NODETYPE") )          ||
         !( s_cfSnapInCLSID         =   RegisterClipboardFormat(L"CCF_SNAPIN_CLASSID") )    ||
         !( s_cfSnapInMetapath      =   RegisterClipboardFormat(L"ISM_SNAPIN_META_PATH") )  ||
         !( s_cfSnapInMachineName   =   RegisterClipboardFormat(L"ISM_SNAPIN_MACHINE_NAME") ) )
        return HRESULT_FROM_WIN32( GetLastError() );

    s_bStaticInitialized = true;
    return S_OK;
}

CPropSheetExtension::InheritedValues::InheritedValues() :
MaxUploadSize(0),
SessionTimeout(0),
NotificationType( BITS_NOTIFICATION_TYPE_NONE ),
NotificationURL( NULL ),
HostId( NULL ),
FallbackTimeout( 0 )
{
}

CPropSheetExtension::InheritedValues::~InheritedValues()
{
   delete NotificationURL;
   delete HostId;
}

CPropSheetExtension::CPropSheetExtension() : 
m_cref(1),
m_MetabasePath( NULL ),
m_MetabaseParent( NULL ),
m_ComputerName( NULL ),
m_UNCComputerName( NULL ),
m_IISAdminBase( NULL ),
m_IBITSSetup( NULL ),
m_PropertyMan( NULL ),
m_hwnd( NULL ),
m_SettingsChanged( false ),
m_EnabledSettingChanged( false ),
m_CleanupInProgress( false ),
m_CleanupCursor( NULL ),
m_CleanupMinWaitTimerFired( false )
{
    OBJECT_CREATED
}

CPropSheetExtension::~CPropSheetExtension()
{
    CloseCleanupItems(); // Close m_TaskSched and m_CleanupTask

    delete m_MetabasePath;
    delete m_MetabaseParent;
    delete m_ComputerName;
    delete m_UNCComputerName;

    if ( m_IBITSSetup )
        m_IBITSSetup->Release();

    if ( m_IISAdminBase )
        m_IISAdminBase->Release();
    
    delete m_PropertyMan;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CPropSheetExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CPropSheetExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CPropSheetExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}


HRESULT 
CPropSheetExtension::ExtractData( 
    IDataObject* piDataObject,
    CLIPFORMAT   cfClipFormat,
    BYTE*        pbData,
    DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
}



HRESULT 
CPropSheetExtension::ExtractSnapInString( IDataObject * piDataObject,
                                          WCHAR * & String,
                                          UINT Format )
{

    if ( String )
        return S_OK;

    FORMATETC formatetc = {(CLIPFORMAT)Format, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL };
    WCHAR* pRetData = NULL;

    try
    {

        stgmedium.hGlobal = GlobalAlloc( GMEM_MOVEABLE, 0 );
        if ( !stgmedium.hGlobal )
            throw ComError( E_OUTOFMEMORY );

        THROW_COMERROR( piDataObject->GetDataHere(&formatetc, &stgmedium) );

        pRetData = (WCHAR*)GlobalLock( stgmedium.hGlobal );

        SIZE_T StringLength = wcslen( pRetData ) + 1;

        String = new WCHAR[ StringLength ];

        StringCchCopyW( String, StringLength, pRetData );

        GlobalUnlock( pRetData );
        pRetData = NULL;
        
        ReleaseStgMedium( &stgmedium );

        return S_OK;

    }
    catch( ComError Error )
    {
        if ( pRetData )
            GlobalUnlock( pRetData );
    
        ReleaseStgMedium( &stgmedium );
        return Error.m_Hr;    
    }

}

HRESULT 
CPropSheetExtension::ExtractSnapInGUID( 
    IDataObject * piDataObject,
    GUID & Guid,
    UINT Format )
{

    HRESULT Hr = S_OK;

    FORMATETC formatetc = {(CLIPFORMAT)Format, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL };

    stgmedium.hGlobal = GlobalAlloc( GMEM_MOVEABLE, 0 );
    if ( !stgmedium.hGlobal )
        return E_OUTOFMEMORY;

    Hr = piDataObject->GetDataHere(&formatetc, &stgmedium);

    if (FAILED(Hr))
        {
        ReleaseStgMedium(&stgmedium);
        return Hr;
        }

    GUID * pRetData = (GUID*)GlobalLock( stgmedium.hGlobal );

    Guid = *pRetData;
    GlobalUnlock( pRetData );
    ReleaseStgMedium( &stgmedium );

    return S_OK;

}


void 
CPropSheetExtension::AddComboBoxItems( 
    UINT Combo, 
    const UINT *Items, 
    UINT NumberOfItems )
{
    HWND hwndBox = GetDlgItem( m_hwnd, Combo );

    SendMessage( hwndBox, CB_RESETCONTENT, 0, 0 );
    for( unsigned int i = 0; i < NumberOfItems; i++ )
        {

        WCHAR ItemText[MAX_PATH];

        LoadString( g_hinst, Items[i], ItemText, MAX_PATH-1 );
        SendMessage( hwndBox, CB_ADDSTRING, 0, (LPARAM)ItemText );
        }
}


void
CPropSheetExtension::UpdateMaxUploadGroupState(
    bool IsEnabled )
{
    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_MAX_UPLOAD ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS ), SubgroupEnabled );
}

void
CPropSheetExtension::UpdateTimeoutGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_DELETE_FILES ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_DELETE_FILES ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_SESSION_TIMEOUT ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_SESSION_TIMEOUT_UNITS ), SubgroupEnabled );
}

void
CPropSheetExtension::UpdateNotificationsGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_NOTIFICATION_TYPE ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_NOTIFICATION_URL ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_NOTIFICATION_URL ), SubgroupEnabled );
}

void
CPropSheetExtension::UpdateServerFarmFallbackGroupState( 
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_FALLBACK_TIMEOUT ), IsEnabled );
    
    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_FALLBACK_TIMEOUT ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_FALLBACK_TIMEOUT ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_COMBO_FALLBACK_TIMEOUT_UNITS ), SubgroupEnabled );

}

void
CPropSheetExtension::UpdateServerFarmGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_ENABLE_SERVER_FARM ), IsEnabled );

    bool SubgroupEnabled = IsEnabled && ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_ENABLE_SERVER_FARM ) );
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_RECONNECT ), SubgroupEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_EDIT_HOSTID ), SubgroupEnabled );
    UpdateServerFarmFallbackGroupState( SubgroupEnabled );


}

void
CPropSheetExtension::UpdateConfigGroupState(
    bool IsEnabled )
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_RADIO_USE_INHERITED_CONFIG ), IsEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_RADIO_USE_CUSTOM_CONFIG ), IsEnabled );

    bool UseCustomConfig = false;

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_RADIO_USE_CUSTOM_CONFIG ) )
        UseCustomConfig = true;

    bool SubgroupEnabled = IsEnabled && UseCustomConfig;
    EnableWindow( GetDlgItem( m_hwnd, IDC_STATIC_CUSTOM_CONFIG ), SubgroupEnabled );
    UpdateMaxUploadGroupState( SubgroupEnabled );
    UpdateTimeoutGroupState( SubgroupEnabled );
    UpdateServerFarmGroupState( SubgroupEnabled );
    UpdateNotificationsGroupState( SubgroupEnabled );

}

void
CPropSheetExtension::UpdateUploadGroupState()
{

    EnableWindow( GetDlgItem( m_hwnd, IDC_CHECK_BITS_UPLOAD ), true );

    bool IsUploadEnabled = ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD ) );

    UpdateConfigGroupState( IsUploadEnabled );
 
}

void
CPropSheetExtension::UpdateCleanupState()
{
    
    bool IsEnabled = ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD ) );
    HRESULT Hr;

    if ( IsEnabled )
        {
        
        if ( !m_TaskSched.Get() )
            {

            try
            {
                ConnectToTaskScheduler( m_UNCComputerName, &m_TaskSched );
            }
            catch( ComError Error)
            {
                Hr = Error.m_Hr;
                DisplayError( IDS_CANT_CONNECT_TO_TASKSCHED, Hr );
                IsEnabled = false;
                goto setstate;
            }

            }

        if ( !m_CleanupTask.Get() )
            {

            WCHAR KeyPath[ 255 ];
            DWORD BufferDataLength;

            METADATA_RECORD mdr;
            mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
            mdr.dwMDAttributes  = METADATA_NO_ATTRIBUTES;
            mdr.dwMDUserType    = ALL_METADATA;
            mdr.dwMDDataType    = STRING_METADATA;
            mdr.pbMDData        = (PBYTE)KeyPath;
            mdr.dwMDDataLen     = sizeof(KeyPath);
            mdr.dwMDDataTag     = 0;

            Hr = m_IISAdminBase->GetData(
                METADATA_MASTER_ROOT_HANDLE,
                m_MetabasePath,
                &mdr,
                &BufferDataLength );


            if ( FAILED( Hr ) )
                {
                DisplayError( IDS_CANT_CONNECT_TO_TASKSCHED, Hr );
                IsEnabled = false;
                goto setstate;
                }

            try
            {
                FindWorkItemForVDIR(
                    m_TaskSched,
                    KeyPath,
                    &m_CleanupTask,
                    NULL );
            }
            catch( ComError Error )
            {
                DisplayError( IDS_CANT_CONNECT_TO_TASKSCHED, Hr );
                IsEnabled = false;
                goto setstate;
            }
            
            }
        
        }

setstate:

    if ( !IsEnabled )
        CloseCleanupItems();

    EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_SCHEDULE_CLEANUP ), IsEnabled );
    EnableWindow( GetDlgItem( m_hwnd, IDC_BUTTON_CLEANUP_NOW ), IsEnabled );

}

void 
CPropSheetExtension::CloseCleanupItems()
{
    m_TaskSched.Clear();
    m_CleanupTask.Clear();
}

void
CPropSheetExtension::ScheduleCleanup()
{

    //
    // Since the task scheduler caches most of the information,
    // its necessary to close the task item and reopen it to refresh it.
    // Do that now.
    //

    if ( m_CleanupTask.Get() )
        {
        m_CleanupTask.Clear();
        UpdateCleanupState();
        }

    if ( !m_CleanupTask.Get() )
        return;

    HRESULT Hr;
    IProvideTaskPage *PropTaskPage = NULL;

    const int NumberOfPages = 2;
    TASKPAGE PageTypes[2]   = { TASKPAGE_SCHEDULE, TASKPAGE_SETTINGS };
    HPROPSHEETPAGE Pages[2] = { NULL, NULL };

    Hr = m_CleanupTask->QueryInterface(
        __uuidof(*PropTaskPage),
        (void **)&PropTaskPage );

    if ( FAILED( Hr ) )
        goto error;

    for( int i = 0; i < NumberOfPages; i++ )
        {

        Hr = PropTaskPage->GetPage( PageTypes[i], TRUE, Pages + i );

        if ( FAILED( Hr ) )
            goto error;

        }

    PropTaskPage->Release();
    PropTaskPage = NULL;

    // 
    // Build TITLE for property page.
    // 

    WCHAR TitleFormat[ MAX_PATH ];
    WCHAR Title[ METADATA_MAX_NAME_LEN + MAX_PATH ]; 
    const WCHAR *VDirName;

    // Find last component of the metabase path.
    // It should be the virtual directory name.

    for ( VDirName = m_MetabasePath + wcslen( m_MetabasePath );
          VDirName != m_MetabasePath && L'/' != *VDirName && L'\\' != *VDirName;
          VDirName-- );

    if ( VDirName != m_MetabasePath )
        VDirName++;

    LoadString( g_hinst, IDS_WORK_ITEM_PROPERTY_PAGE_TITLE, TitleFormat, MAX_PATH-1 );

    DWORD FormatResult =
        FormatMessage(
            FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            (LPCVOID)TitleFormat,   
            0,  
            0, 
            (LPTSTR)Title,
            ( sizeof(Title) / sizeof(*Title) ) - 1,  
            (va_list*)&VDirName );


    if ( !FormatResult )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }


    PROPSHEETHEADER psh;
    memset( &psh, 0, sizeof( psh ) );
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_DEFAULT | PSH_NOAPPLYNOW;
    psh.phpage      = Pages;
    psh.nPages      = NumberOfPages;
    psh.hwndParent  = GetParent( m_hwnd );
    psh.pszCaption  = Title;

    INT_PTR Result = PropertySheet(&psh);

    if ( -1 == Result )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }

    return;

error:

    for( int i = 0; i < NumberOfPages; i++ )
        {
        DestroyPropertySheetPage( Pages[i] );
        }

    if ( PropTaskPage )
        PropTaskPage->Release();

    DisplayError( IDS_CANT_START_CLEANUP_SCHEDULE, Hr );
    return;

}

void
CPropSheetExtension::CleanupNow()
{

    HRESULT Hr;
    HRESULT Status;

    if (m_CleanupInProgress)
        {
        return;
        }

    //
    // Get the current status for the cleanup task.
    //
    Hr = m_CleanupTask->GetStatus( &Status );

    if (FAILED(Hr))
        {
        goto error;
        }
    
    //
    // See how recently the cleanup task has run.
    //
    SYSTEMTIME MostRecentRunTime;
    memset(&MostRecentRunTime,0,sizeof(MostRecentRunTime));
    Hr = m_CleanupTask->GetMostRecentRunTime( &MostRecentRunTime );

    if ( FAILED(Hr) )
        {
        goto error;
        }

    if (Hr == SCHED_S_TASK_HAS_NOT_RUN)
        {
        // Job Has never been run 
        memset( &m_PrevCleanupStartTime, 0, sizeof(m_PrevCleanupStartTime) );
        }
    else
        {

        if ( !SystemTimeToFileTime( &MostRecentRunTime, &m_PrevCleanupStartTime ) )
            {
            Hr = HRESULT_FROM_WIN32( GetLastError() );
            goto error;
            }

        }

    if (Status != SCHED_S_TASK_RUNNING)
        {
        Hr = m_CleanupTask->Run();

        if ( FAILED(Hr) )
            {
            goto error;
            }
        }

    m_CleanupMinWaitTimerFired = false;
    if ( !SetTimer(m_hwnd, s_CleanupMinWaitTimerID, s_CleanupMinWaitTimerInterval, NULL) )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }
    
    if ( !SetTimer(m_hwnd, s_CleanupPollTimerID, s_CleanupMinWaitTimerInterval, NULL) )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto error;
        }

    m_CleanupInProgress     = true;
    m_CleanupCursor         = LoadCursor( NULL, (LPWSTR)IDC_WAIT );
    SetCursor( m_CleanupCursor );
    return;

error:

    KillTimer( m_hwnd, s_CleanupMinWaitTimerID );
    KillTimer( m_hwnd, s_CleanupPollTimerID );
    SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
    DisplayError( IDS_CANT_START_CLEANUP, Hr );

}

void 
CPropSheetExtension::CleanupTimer( UINT TimerID )
{

    HRESULT Hr;

    if ( s_CleanupMinWaitTimerID != TimerID &&
         s_CleanupPollTimerID != TimerID )
        {
        return;
        }

    if ( s_CleanupMinWaitTimerID )
        {
        m_CleanupMinWaitTimerFired = true;
        KillTimer( m_hwnd, s_CleanupMinWaitTimerID );
        }

    if ( !m_CleanupMinWaitTimerFired )
        {
        return; // keep cursor active for minimum time period
        }

    //
    // Since the task scheduler caches most of the information,
    // its necessary to close the task item and reopen it to refresh it.
    // Do that now.
    //

    if ( m_CleanupTask.Get() )
        {
        m_CleanupTask.Clear();
        UpdateCleanupState();
        }

    if ( !m_CleanupTask.Get() )
        {
        // shut down the polling
        KillTimer( m_hwnd, s_CleanupPollTimerID );
        SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
        m_CleanupInProgress = false;
        return;
        }


    HRESULT Status;
    if ( FAILED( m_CleanupTask->GetStatus( &Status ) ) )
        {
        return;
        }

    if ( Status == SCHED_S_TASK_RUNNING )
        {
        return; // Not done yet, keep checking
        }

    DWORD ExitCode;
    Hr = m_CleanupTask->GetExitCode( &ExitCode );

    if ( Hr == SCHED_S_TASK_HAS_NOT_RUN )
        {
        return; // The task probably hasn't run yet
        }

    if ( FAILED(Hr) )
        {
        // If this API fails it returns the error
        // that MSTASK received when starting the job.

        KillTimer( m_hwnd, s_CleanupPollTimerID );
        SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
        m_CleanupInProgress = false;
        DisplayError( IDS_CANT_START_CLEANUP, Hr );        
        return;
        }

    SYSTEMTIME MostRecentRunTime;
    if ( FAILED( m_CleanupTask->GetMostRecentRunTime( &MostRecentRunTime ) ) )
        return;

    FILETIME MostRecentRunTimeAsFileTime;


    if ( !SystemTimeToFileTime(&MostRecentRunTime, &MostRecentRunTimeAsFileTime ) )
        return; 

    if ( CompareFileTime( &MostRecentRunTimeAsFileTime, &m_PrevCleanupStartTime ) < 0 )
        return; // task may not have scheduled yet, keep checking

    //
    // At this point we know the following:
    // 1. The cursor was help in the wait state for the minimum time
    // 2. The task is not running
    // 3. The task started sometime after our time mark
    //
    // So, cleanup timers and revert back to the original icon
    //

    KillTimer( m_hwnd, s_CleanupPollTimerID );
    SetCursor( (HCURSOR)GetClassLongPtr( m_hwnd, GCLP_HCURSOR ) );
    m_CleanupInProgress = false;
}

bool
CPropSheetExtension::DisplayWarning(
    UINT StringId )
{

    WCHAR ErrorString[ MAX_PATH * 2 ];
    WCHAR BITSSettings[ MAX_PATH ];
    
    LoadString( g_hinst, StringId, ErrorString, MAX_PATH*2-1 );
    LoadString( g_hinst, IDS_BITS_EXT, BITSSettings, MAX_PATH-1 );

    return ( IDOK == MessageBox( m_hwnd, ErrorString, BITSSettings, MB_OKCANCEL | MB_ICONWARNING ) ); 

}

void 
CPropSheetExtension::DisplayError( 
    UINT StringId )
{

    WCHAR ErrorString[ MAX_PATH * 2 ];
    WCHAR BITSSettings[ MAX_PATH ];
    
    LoadString( g_hinst, StringId, ErrorString, MAX_PATH*2-1 );
    LoadString( g_hinst, IDS_BITS_EXT, BITSSettings, MAX_PATH-1 );

    MessageBox( m_hwnd, ErrorString, BITSSettings, MB_OK | MB_ICONWARNING ) ; 

}

void
CPropSheetExtension::DisplayError(
    UINT StringId,
    HRESULT Hr )
{
    WCHAR ErrorString[ MAX_PATH * 2 ];
    WCHAR BITSSettings[ MAX_PATH ];
    
    LoadString( g_hinst, StringId, ErrorString, MAX_PATH*2-1 );
    LoadString( g_hinst, IDS_BITS_EXT, BITSSettings, MAX_PATH-1 );

    WCHAR * SystemMessage = NULL;
    DWORD ReturnValue =
        FormatMessage( 
            FORMAT_MESSAGE_ALLOCATE_BUFFER | 
            FORMAT_MESSAGE_FROM_SYSTEM | 
            FORMAT_MESSAGE_IGNORE_INSERTS,
            NULL,
            (DWORD)Hr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &SystemMessage,
            0,
            NULL 
            );

    if ( !ReturnValue )
        MessageBox( m_hwnd, ErrorString, BITSSettings, MB_OK | MB_ICONWARNING );
    else
        {

        WCHAR CombinedErrorString[ MAX_PATH * 4 ];

        StringCchPrintfW( 
            CombinedErrorString, 
            ARRAY_ELEMENTS( CombinedErrorString ), 
            L"%s\r\n\r\n%s", 
            ErrorString, 
            SystemMessage );

        MessageBox( m_hwnd, CombinedErrorString, BITSSettings, MB_OK | MB_ICONWARNING );

        LocalFree( SystemMessage );

        }

}

bool
CPropSheetExtension::GetDlgItemTextAsInteger(
    UINT Id,
    UINT MaxString,
    UINT64 & Value )
{

    WCHAR *DlgString    = NULL;
    WCHAR *FoldedBuffer = NULL;
    WCHAR *p            = NULL;
    Value = 0;

    try 
    {

        DlgString = new WCHAR[ MaxString + 1 ];

        GetDlgItemText( m_hwnd, Id, DlgString, MaxString );

        if ( L'\0' == *DlgString )
            throw ComError( E_FAIL );;

        int CharsRequired =
            FoldString( 
                MAP_FOLDDIGITS,
                DlgString,
                -1,
                NULL,
                0 );

        if ( !CharsRequired )
            throw ComError( E_FAIL );

        FoldedBuffer = new WCHAR[ CharsRequired + 1 ];

        CharsRequired =
            FoldString(
                MAP_FOLDDIGITS,
                DlgString,
                -1,
                FoldedBuffer,
                CharsRequired );

        if ( !CharsRequired )
            ComError( E_FAIL );

        p = FoldedBuffer;

        // accumulate value
        while(L'\0' != *p )
            {

            UINT64 ExtendedValue = Value * 10;
            if ( ExtendedValue / 10 != Value )
                throw ComError( E_FAIL );

            Value = ExtendedValue;

            if ( *p < L'0' || *p > L'9' )
                throw ComError( E_FAIL );


            UINT64 ValueToAdd = *p - L'0';

            if ( 0xFFFFFFFFFFFFFFFF - ValueToAdd < Value )
                throw ComError( E_FAIL ); //overflow

            Value += ValueToAdd;
            p++;

            }

        delete[] DlgString;
        delete[] FoldedBuffer;

        return true;


    }
    catch( ComError Error )
    {
        delete[] DlgString;
        delete[] p;
        return false;
    }

}

void
CPropSheetExtension::SetDlgItemTextAsInteger( 
    UINT Id, 
    UINT64 Value )
{

    WCHAR RawString[ 25 ]; // 18446744073709551615

    WCHAR *p = RawString + 25 - 1;
    *p-- = L'\0';

	if ( !Value )
	    {
		*p = L'0';
	    }
	else
    	{

        do
            {
            UINT64 Remainder = Value % 10;
            Value = Value / 10;
            *p-- = ( L'0' + (WCHAR)Remainder );
            } while( Value );

    	p++;

    	}

    NUMBERFMT Format;
    memset( &Format, 0, sizeof(Format) );
    Format.lpDecimalSep = L"";
    Format.lpThousandSep = L"";

    int CharsRequired =
        GetNumberFormat(
            NULL,
            0,
            p,
            &Format,  
            NULL,
            0 );

    if ( !CharsRequired )
        return;

    WCHAR *ConvertedString = NULL;

    try
    {
        ConvertedString = new WCHAR[ CharsRequired ];
    }
    catch( ComError Error )
    {
        return;
    }

    CharsRequired =
        GetNumberFormat(
            NULL,
            0,
            p,
            &Format,
            ConvertedString,
            CharsRequired );


    if ( CharsRequired )
        SetDlgItemText( m_hwnd, Id, ConvertedString );

    delete[] ConvertedString;

}

bool
CPropSheetExtension::ValidateValues( )
{

    // Validate the maximum upload

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ) ) 
        {
        
        LRESULT MaxUploadUnit = SendDlgItemMessage( m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_GETCURSEL, 0, 0 );
        
        UINT64 MaxUpload;

        if (!GetDlgItemTextAsInteger( IDC_EDIT_MAX_UPLOAD, MAX_PATH, MaxUpload ) ||
             MaxUpload > s_MaxUploadLimits[MaxUploadUnit] )
            {
            DisplayError( IDS_MAX_UPLOAD_INVALID );
            return false;
            }
        }

    // Validate the session timeout

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_DELETE_FILES ) )
        {

        LRESULT SessionTimeoutUnit =
            SendDlgItemMessage( m_hwnd, IDC_COMBO_SESSION_TIMEOUT_UNITS, CB_GETCURSEL, 0, 0 );

        UINT64 SessionTimeout;

        if ( !GetDlgItemTextAsInteger( IDC_EDIT_SESSION_TIMEOUT, MAX_PATH, SessionTimeout ) ||
             SessionTimeout > s_TimeoutLimits[SessionTimeoutUnit] )
            {
            DisplayError( IDS_SESSION_TIMEOUT_INVALID );
            return false;
            }

        }


    // Validate the server farm settings

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_ENABLE_SERVER_FARM ) )
        {

        LRESULT HostIdLength =
            SendDlgItemMessage( m_hwnd, IDC_EDIT_HOSTID, WM_GETTEXTLENGTH, 0, 0 );

        if ( !HostIdLength )
            {
            DisplayError( IDS_HOST_ID_INVALID );
            return false;
            }

        if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_FALLBACK_TIMEOUT ) )
            {

            LRESULT FallbackTimeoutUnit =
                SendDlgItemMessage( m_hwnd, IDC_COMBO_FALLBACK_TIMEOUT_UNITS, CB_GETCURSEL, 0, 0 );

            UINT64 FallbackTimeout;

            if ( !GetDlgItemTextAsInteger( IDC_EDIT_FALLBACK_TIMEOUT, MAX_PATH, FallbackTimeout ) ||
                 FallbackTimeout > s_TimeoutLimits[ FallbackTimeoutUnit ] )
                {
                DisplayError( IDS_FALLBACK_TIMEOUT_INVALID );
                return false;
                }

            }

        }

    // Validate the notification settings

    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ) )
        {

        LRESULT NotificationURLLength =
            SendDlgItemMessage( m_hwnd, IDC_EDIT_NOTIFICATION_URL, WM_GETTEXTLENGTH, 0, 0 );

        if ( !NotificationURLLength )
            {
            DisplayError( IDS_NOTIFICATION_URL_INVALID );
            return false;
            }

        }


    return WarnAboutAccessFlags();
}

bool 
CPropSheetExtension::WarnAboutAccessFlags()
{
  
    if ( m_EnabledSettingChanged &&
         ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD ) ) )
        {

        HRESULT Hr = S_OK;
        DWORD BufferRequired = 0;
        DWORD AccessFlags = 0;

        METADATA_RECORD mdr;
        mdr.dwMDIdentifier  = MD_ACCESS_PERM;
        mdr.dwMDAttributes  = METADATA_INHERIT;
        mdr.dwMDUserType    = ALL_METADATA;
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (unsigned char*)&AccessFlags;
        mdr.dwMDDataLen     = sizeof( AccessFlags );
        mdr.dwMDDataTag     = 0;

        Hr = m_IISAdminBase->GetData(
            METADATA_MASTER_ROOT_HANDLE,
            m_MetabasePath,
            &mdr,
            &BufferRequired );

        if ( FAILED( Hr ) )
            {
            DisplayError( IDS_CANT_ACCESS_METABASE, Hr );
            return false;
            }

        if ( AccessFlags & ( MD_ACCESS_EXECUTE | MD_ACCESS_SCRIPT ) )
            {
            return DisplayWarning( IDS_ACCESS_PERMISSION_WARNING );
            }

        }
    

    return true;
}


HRESULT
CPropSheetExtension::LoadInheritedDWORD(
    METADATA_HANDLE mdHandle,
    WCHAR * pKeyName,
    DWORD PropId,
    DWORD * pReturn )
{

    METADATA_RECORD mdr;
    DWORD BufferRequired;
    HRESULT Hr;

    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)pReturn;
    mdr.dwMDDataLen     = sizeof(*pReturn);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        mdHandle,
        pKeyName,
        &mdr,
        &BufferRequired );

    return Hr;

}

HRESULT
CPropSheetExtension::LoadInheritedString(
    METADATA_HANDLE mdHandle,
    WCHAR * pKeyName,
    DWORD PropId,
    WCHAR ** pReturn )
{

    *pReturn = NULL;
    METADATA_RECORD mdr;
    DWORD BufferRequired;
    HRESULT Hr;

    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_PARTIAL_PATH;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)NULL;
    mdr.dwMDDataLen     = 0;
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
             mdHandle,
             pKeyName,
             &mdr,
             &BufferRequired );

    if ( FAILED( Hr ) && HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
        return Hr;

    try
    {
        *pReturn = new WCHAR[ BufferRequired ];
    }
    catch( ComError Error )
    {
        Error.m_Hr;
    }


    mdr.dwMDDataLen     = BufferRequired;
    mdr.pbMDData        = (BYTE*)*pReturn;

    Hr = m_IISAdminBase->GetData(
             mdHandle,
             pKeyName,
             &mdr,
             &BufferRequired );

    if ( FAILED( Hr ) )
        {
        delete *pReturn;
        *pReturn = NULL;
        return Hr;
        }

    return Hr;
}

void
CPropSheetExtension::LoadInheritedValues()
{

    HRESULT Hr;
    METADATA_RECORD mdr;
    METADATA_HANDLE mdHandle = NULL;
    DWORD BufferRequired;

    m_InheritedValues.NotificationURL   = NULL;
    m_InheritedValues.HostId            = NULL;

    //
    // A huge trick is used here to obtain the inherited properties.  
    // The idea is to take a key which probably doesn't exit at the same
    // level as the key for the virtual directory.  A guid looks
    // like a good key name to use that probably doesn't exist.
    //

    GUID guid;
    WCHAR unusedkey[50]; 
    
    CoCreateGuid( &guid );
    StringFromGUID2( guid, unusedkey, 49 );

    Hr = m_IISAdminBase->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabaseParent,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        METABASE_OPEN_KEY_TIMEOUT, 
        &mdHandle );

    if ( FAILED( Hr ) )
        goto error;

    // Load the maximum upload size


    {
        WCHAR *MaximumUploadSize = NULL;

        if ( FAILED( 
            Hr = LoadInheritedString(
                mdHandle,
                unusedkey,
                MD_BITS_MAX_FILESIZE,
                &MaximumUploadSize ) ) )
                goto error;
    
        if ( wcscmp( MaximumUploadSize, MD_BITS_UNLIMITED_MAX_FILESIZE) == 0 )
            m_InheritedValues.MaxUploadSize = MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64;
        else
            if ( 1 != swscanf( MaximumUploadSize, L"%I64u", &m_InheritedValues.MaxUploadSize ) )
            {
            delete MaximumUploadSize;
            MaximumUploadSize = NULL;
            goto error;
            }

        delete MaximumUploadSize;


    }


    // Load the session timeout

    if ( FAILED( 
            Hr = LoadInheritedDWORD(
                mdHandle,
                unusedkey,
                MD_BITS_NO_PROGRESS_TIMEOUT,
                &m_InheritedValues.SessionTimeout ) ) )
        goto error;

    // Load the notification settings

    if ( FAILED( 
        Hr = LoadInheritedDWORD(
            mdHandle,
            unusedkey,
            MD_BITS_NOTIFICATION_URL_TYPE,
            (DWORD*)&m_InheritedValues.NotificationType ) ) )
        goto error;

    if ( FAILED( 
        Hr = LoadInheritedString(
            mdHandle,
            unusedkey,
            MD_BITS_NOTIFICATION_URL,
            &m_InheritedValues.NotificationURL ) ) )
        goto error;


    // Load the web farm settings

    if ( FAILED( 
        Hr = LoadInheritedString(
            mdHandle,
            unusedkey,
            MD_BITS_HOSTID,
            &m_InheritedValues.HostId ) ) )
        goto error;

    if ( FAILED( 
        Hr = LoadInheritedDWORD(
            mdHandle,
            unusedkey,
            MD_BITS_HOSTID_FALLBACK_TIMEOUT,
            (DWORD*)&m_InheritedValues.FallbackTimeout ) ) )
        goto error;


    m_IISAdminBase->CloseKey( mdHandle );
    mdHandle = NULL;

    return;

error:

    if ( mdHandle )
        m_IISAdminBase->CloseKey( mdHandle );

    // use default values
    m_InheritedValues.MaxUploadSize     = MD_DEFAULT_BITS_MAX_FILESIZE_AS_INT64;
    m_InheritedValues.SessionTimeout    = MD_DEFAULT_NO_PROGESS_TIMEOUT;
    m_InheritedValues.NotificationType  = MD_DEFAULT_BITS_NOTIFICATION_URL_TYPE;

    delete m_InheritedValues.NotificationURL;
    m_InheritedValues.NotificationURL   = NULL;

    delete m_InheritedValues.HostId;
    m_InheritedValues.HostId            = NULL;

    DisplayError( IDS_CANT_LOAD_INHERITED_VALUES, Hr );

}

void 
CPropSheetExtension::LoadMaxUploadValue( UINT64 MaxValue )
{

    if ( MaxValue == MD_BITS_UNLIMITED_MAX_FILESIZE_AS_INT64 )
        {
        SendDlgItemMessage(m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_SETCURSEL, 0, 0 );
        SetDlgItemText( m_hwnd, IDC_EDIT_MAX_UPLOAD, L"" );
        CheckDlgButton( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD, BST_UNCHECKED );
        return;
        }
    
    int Scale = s_NumberOfMaxUploadUnitsScales-1; 
    while ( MaxValue % s_MaxUploadUnitsScales[Scale] )
        Scale--;


    SendDlgItemMessage(m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_SETCURSEL, Scale, 0 );
    SetDlgItemTextAsInteger( IDC_EDIT_MAX_UPLOAD, MaxValue / s_MaxUploadUnitsScales[Scale] );
    CheckDlgButton( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD, BST_CHECKED );

}

void
CPropSheetExtension::LoadTimeoutValue(
    DWORD CheckId,
    DWORD EditId,
    DWORD UnitId,
    DWORD Value )
{

    if ( MD_BITS_NO_TIMEOUT == Value )
        {
        SendDlgItemMessage( m_hwnd, UnitId, CB_SETCURSEL, 0, 0 );
        SetDlgItemText( m_hwnd, EditId, L"");
        CheckDlgButton( m_hwnd, CheckId, BST_UNCHECKED );
        return;        
        }

    int Scale = s_NumberOfTimeoutUnitsScales-1; 
    while ( Value % s_TimeoutUnitsScales[Scale] )
        Scale--;

    SendDlgItemMessage( m_hwnd, UnitId, CB_SETCURSEL, Scale, 0 );
    SetDlgItemTextAsInteger( EditId, 
                             Value / s_TimeoutUnitsScales[Scale] );
    CheckDlgButton( m_hwnd, CheckId, BST_CHECKED );


}

void
CPropSheetExtension::LoadTimeoutValue( DWORD SessionTimeout )
{

    LoadTimeoutValue(
        IDC_DELETE_FILES,                   // check id
        IDC_EDIT_SESSION_TIMEOUT,           // edit id
        IDC_COMBO_SESSION_TIMEOUT_UNITS,    // unit id
        SessionTimeout );

}

void
CPropSheetExtension::LoadNotificationValues( 
    BITS_SERVER_NOTIFICATION_TYPE NotificationType,
    WCHAR *NotificationURL )
{

    if ( BITS_NOTIFICATION_TYPE_NONE == NotificationType )
        {
        SetDlgItemText( m_hwnd, IDC_EDIT_NOTIFICATION_URL, L"" );
        SendDlgItemMessage( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE, CB_SETCURSEL, 0, 0 );
        CheckDlgButton( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS, BST_UNCHECKED );
        return;
        }

    SendDlgItemMessage( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE, CB_SETCURSEL, 
                        (WPARAM)NotificationType - BITS_NOTIFICATION_TYPE_POST_BYREF, 0 ); 
    SetDlgItemText( m_hwnd, IDC_EDIT_NOTIFICATION_URL, NotificationURL );
    CheckDlgButton( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS, BST_CHECKED );
}

void
CPropSheetExtension::LoadServerFarmSettings( 
    WCHAR *HostId,
    DWORD FallbackTimeout )
{

    if ( !HostId || !*HostId )
        {
        SetDlgItemText( m_hwnd, IDC_EDIT_HOSTID, L"" );
        CheckDlgButton( m_hwnd, IDC_ENABLE_SERVER_FARM, BST_UNCHECKED );

        LoadTimeoutValue(
            IDC_CHECK_FALLBACK_TIMEOUT,
            IDC_EDIT_FALLBACK_TIMEOUT,
            IDC_COMBO_FALLBACK_TIMEOUT_UNITS,
            FallbackTimeout );
        return;
        }

    SetDlgItemText( m_hwnd, IDC_EDIT_HOSTID, HostId );
    CheckDlgButton( m_hwnd, IDC_ENABLE_SERVER_FARM, BST_CHECKED );
    
    LoadTimeoutValue(
        IDC_CHECK_FALLBACK_TIMEOUT,
        IDC_EDIT_FALLBACK_TIMEOUT,
        IDC_COMBO_FALLBACK_TIMEOUT_UNITS,
        FallbackTimeout );

}

void 
CPropSheetExtension::LoadValues( )
{

    HRESULT Hr = S_OK;
    HRESULT LastError = S_OK;
    BOOL IsBitsEnabled = FALSE;

    m_SettingsChanged = m_EnabledSettingChanged = false;

    try
    {
        IsBITSEnabledOnVDir(
            m_PropertyMan,
            m_IISAdminBase,
            m_MetabasePath,
            &IsBitsEnabled );

    }
    catch( ComError Error )
    {
        Hr = Error.m_Hr;
    }

    if ( IsBitsEnabled )
        CheckDlgButton( m_hwnd, IDC_CHECK_BITS_UPLOAD, BST_CHECKED );
    else
        CheckDlgButton( m_hwnd, IDC_CHECK_BITS_UPLOAD, BST_UNCHECKED );

    if ( FAILED(Hr) )
        LastError = Hr;

    bool AllDefaults = true;

    METADATA_RECORD mdr;
    DWORD BufferRequired;

    // Load the maximum upload size
    WCHAR MaximumUploadSize[MAX_PATH];

    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_MAX_FILESIZE );
	mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
	mdr.dwMDUserType    = ALL_METADATA;
	mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)MaximumUploadSize;
	mdr.dwMDDataLen     = sizeof(MaximumUploadSize);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    if ( FAILED( Hr ) )
        {
        LastError = Hr;
        LoadMaxUploadValue( m_InheritedValues.MaxUploadSize );
        }
    else
        {

        UINT64 MaximumUploadSizeInt;
        if ( 1 != swscanf( MaximumUploadSize, L"%I64u", &MaximumUploadSizeInt ) )
            {
            LastError = Hr;
            LoadMaxUploadValue( m_InheritedValues.MaxUploadSize );
            }
        else
            {
                                          
            if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                AllDefaults = false;
 
            LoadMaxUploadValue( MaximumUploadSizeInt );
            } 
        
        }

    // Load the session timeout
    DWORD SessionTimeout = m_InheritedValues.SessionTimeout;
        
    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_NO_PROGRESS_TIMEOUT );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&SessionTimeout;
    mdr.dwMDDataLen     = sizeof(SessionTimeout);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    if ( FAILED( Hr ) )
        { 
        LastError = Hr;
        LoadTimeoutValue( m_InheritedValues.SessionTimeout ); 
        }
    else
        {
        
        if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
            AllDefaults = false;

        LoadTimeoutValue( SessionTimeout );
        }

    // Load the notification settings
    DWORD NotificationType;
    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL_TYPE );
    mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
    mdr.dwMDUserType    = ALL_METADATA;
    mdr.dwMDDataType    = DWORD_METADATA;
    mdr.pbMDData        = (PBYTE)&NotificationType;
    mdr.dwMDDataLen     = sizeof(NotificationType);
    mdr.dwMDDataTag     = 0;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    if ( FAILED( Hr ) )
        {
        LastError = Hr;
        LoadNotificationValues( m_InheritedValues.NotificationType, m_InheritedValues.NotificationURL );
        }
    else 
        {
        
        if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
            AllDefaults = false;

        if ( BITS_NOTIFICATION_TYPE_NONE == NotificationType )
            LoadNotificationValues( BITS_NOTIFICATION_TYPE_NONE, L"" );
        else
            {
            mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_NOTIFICATION_URL );
            mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
            mdr.dwMDUserType    = ALL_METADATA;
            mdr.dwMDDataType    = STRING_METADATA;
            mdr.pbMDData        = (PBYTE)NULL;
            mdr.dwMDDataLen     = 0;
            mdr.dwMDDataTag     = 0;

            Hr = m_IISAdminBase->GetData(
                     METADATA_MASTER_ROOT_HANDLE,
                     m_MetabasePath,
                     &mdr,
                     &BufferRequired );

            if ( FAILED( Hr ) && HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
                {
                LastError = Hr;
                LoadNotificationValues( (BITS_SERVER_NOTIFICATION_TYPE)NotificationType, L"" );
                }

            else
                {

                BYTE *URL = NULL; 
                
                try
                    {
                    URL = new BYTE[ BufferRequired ]; 
                    }
                catch( ComError Error )
                    {
                    Hr = Error.m_Hr;
                    }
                                
                mdr.dwMDDataLen     = BufferRequired;
                mdr.pbMDData        = URL;

                if ( BufferRequired )
                    {
                    
                    Hr = m_IISAdminBase->GetData(
                             METADATA_MASTER_ROOT_HANDLE,
                             m_MetabasePath,
                             &mdr,
                             &BufferRequired );

                    }


                if ( FAILED( Hr ) )
                    {
                    LastError = Hr;
                    LoadNotificationValues( (BITS_SERVER_NOTIFICATION_TYPE)NotificationType, L"" );
                    }
                else
                    {
                    if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                        AllDefaults = false;
                    LoadNotificationValues( (BITS_SERVER_NOTIFICATION_TYPE)NotificationType, (WCHAR*)URL );

                    }

                delete[] URL;

                }
            }
        }

    // Load the HostId
    {

        WCHAR *HostIdString     = m_InheritedValues.HostId;
        DWORD  FallbackTimeout  = m_InheritedValues.FallbackTimeout;

        mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID_FALLBACK_TIMEOUT );
        mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
        mdr.dwMDUserType    = ALL_METADATA;
        mdr.dwMDDataType    = DWORD_METADATA;
        mdr.pbMDData        = (PBYTE)&FallbackTimeout;
        mdr.dwMDDataLen     = sizeof( FallbackTimeout );
        mdr.dwMDDataTag     = 0;

        Hr = m_IISAdminBase->GetData(
                 METADATA_MASTER_ROOT_HANDLE,
                 m_MetabasePath,
                 &mdr,
                 &BufferRequired );

        if ( FAILED( Hr ) )
            FallbackTimeout = m_InheritedValues.FallbackTimeout;
        else
            {

            if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                AllDefaults = false;

            }

        mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( MD_BITS_HOSTID );
        mdr.dwMDAttributes  = METADATA_INHERIT | METADATA_ISINHERITED;
        mdr.dwMDUserType    = ALL_METADATA;
        mdr.dwMDDataType    = STRING_METADATA;
        mdr.pbMDData        = (PBYTE)NULL;
        mdr.dwMDDataLen     = 0;
        mdr.dwMDDataTag     = 0;

        Hr = m_IISAdminBase->GetData(
                 METADATA_MASTER_ROOT_HANDLE,
                 m_MetabasePath,
                 &mdr,
                 &BufferRequired );

        BYTE *HostId = NULL;

        if ( SUCCEEDED( Hr ) || ( Hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) ) )
            {

            try
            {
                HostId				= new BYTE[ BufferRequired ];
                mdr.dwMDDataLen     = BufferRequired;
                mdr.pbMDData        = HostId;
            
                Hr = m_IISAdminBase->GetData(
                         METADATA_MASTER_ROOT_HANDLE,
                         m_MetabasePath,
                         &mdr,
                         &BufferRequired );

            }
            catch( ComError Error )
            {
                Hr = Error.m_Hr;
            }

            if ( SUCCEEDED( Hr ) )
                {

                if ( !( mdr.dwMDAttributes & METADATA_ISINHERITED ) )
                     AllDefaults = false;

                HostIdString = (WCHAR*)HostId;

                }
            }

        LoadServerFarmSettings( HostIdString, FallbackTimeout );
        delete[] HostId;

    }

    CheckDlgButton( m_hwnd, IDC_CHECK_BITS_UPLOAD, IsBitsEnabled ? BST_CHECKED : BST_UNCHECKED );

    CheckRadioButton( m_hwnd, IDC_RADIO_USE_INHERITED_CONFIG, IDC_RADIO_USE_CUSTOM_CONFIG,
                      AllDefaults ? IDC_RADIO_USE_INHERITED_CONFIG : IDC_RADIO_USE_CUSTOM_CONFIG );
    UpdateUploadGroupState( );

    if ( FAILED( LastError ) )
        DisplayError( IDS_CANT_LOAD_VALUES, LastError );

    UpdateCleanupState( );
}
    
HRESULT 
CPropSheetExtension::SaveMetadataString(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    WCHAR *Value )
{

    
    METADATA_RECORD mdr;
    mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
 	mdr.dwMDAttributes  = METADATA_INHERIT;
 	mdr.dwMDUserType    = m_PropertyMan->GetPropertyUserType( PropId );
 	mdr.dwMDDataType    = STRING_METADATA;
    mdr.pbMDData        = (PBYTE)Value;
 	mdr.dwMDDataLen     = sizeof(WCHAR) * ( wcslen( Value ) + 1 );
    mdr.dwMDDataTag     = 0;

    HRESULT Hr = m_IISAdminBase->SetData(
        mdHandle,
        NULL,
        &mdr );

    return Hr;

}

HRESULT
CPropSheetExtension::SaveMetadataDWORD(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    DWORD Value )
{

   METADATA_RECORD mdr;

   mdr.dwMDIdentifier  = m_PropertyMan->GetPropertyMetabaseID( PropId );
   mdr.dwMDAttributes  = METADATA_INHERIT;
   mdr.dwMDUserType    = m_PropertyMan->GetPropertyUserType( PropId );
   mdr.dwMDDataType    = DWORD_METADATA;
   mdr.pbMDData        = (PBYTE)&Value;
   mdr.dwMDDataLen     = sizeof(DWORD);
   mdr.dwMDDataTag     = 0;

   HRESULT Hr = m_IISAdminBase->SetData(
       mdHandle,
       NULL,
       &mdr );

   return Hr;

}

void
CPropSheetExtension::MergeError(
    HRESULT Hr,
    HRESULT * LastHr )
{

    if ( FAILED( Hr ) )
        *LastHr = Hr;

}

HRESULT
CPropSheetExtension::SaveSimpleString(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    DWORD EditId )
{

    LRESULT StringLength = 
        SendDlgItemMessage( m_hwnd, EditId, WM_GETTEXTLENGTH, 0, 0 ); 

    WCHAR *String;
     
    try
        {
        String = new WCHAR[ StringLength + 1 ]; 
        }
    catch( ComError Error )
        {
        return Error.m_Hr;
        }

    GetDlgItemText( m_hwnd, EditId, String, (DWORD)(StringLength + 1));

    HRESULT Hr =   
        SaveMetadataString(
            mdHandle,
            PropId,
            String );

    delete[] String;
    return Hr;

}

HRESULT
CPropSheetExtension::SaveTimeoutValue(
    METADATA_HANDLE mdHandle,
    DWORD PropId,
    DWORD CheckId,
    DWORD EditId,
    DWORD UnitId )
{


    if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, CheckId ) )
        {
    
        return
            SaveMetadataDWORD(
                mdHandle,
                PropId,
                MD_BITS_NO_TIMEOUT );
        
        }

    LRESULT TimeoutUnitsSelect = 
        SendDlgItemMessage( m_hwnd, UnitId, CB_GETCURSEL, 0, 0 );

    UINT64 Timeout64;
    GetDlgItemTextAsInteger( EditId, MAX_PATH, Timeout64 );
    Timeout64 *= s_TimeoutUnitsScales[ TimeoutUnitsSelect ];
    DWORD Timeout = (DWORD)Timeout64;

    return
        SaveMetadataDWORD(
            mdHandle,
            PropId,
            Timeout );

}


void 
CPropSheetExtension::SetValues( )
{ 

    HRESULT Hr;
    HRESULT LastError = S_OK;
    METADATA_HANDLE mdHandle = NULL;
    
    if ( m_EnabledSettingChanged )
        {
        
        UINT BitsUploadButton = IsDlgButtonChecked( m_hwnd, IDC_CHECK_BITS_UPLOAD );

        if ( BST_CHECKED == BitsUploadButton )
            {
            Hr = m_IBITSSetup->EnableBITSUploads();
            }
        else
            {
            Hr = m_IBITSSetup->DisableBITSUploads();
            }
        
        if ( FAILED( Hr ) )
            {
            LastError = Hr;
            goto error;
            }
        }


    Hr = m_IISAdminBase->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        METABASE_OPEN_KEY_TIMEOUT, 
        &mdHandle );

    if ( FAILED( Hr ) )
        {
        LastError = Hr;
        goto error;
        }


    if ( BST_CHECKED == IsDlgButtonChecked( m_hwnd, IDC_RADIO_USE_INHERITED_CONFIG ) )
        {

        // delete all the configuration properties

        DWORD IdsToDelete[] =
        {
            MD_BITS_MAX_FILESIZE,
            MD_BITS_NO_PROGRESS_TIMEOUT,
            MD_BITS_NOTIFICATION_URL_TYPE,
            MD_BITS_NOTIFICATION_URL,
            MD_BITS_HOSTID,
            MD_BITS_HOSTID_FALLBACK_TIMEOUT
        };

        for ( DWORD i=0; i < ( sizeof(IdsToDelete) / sizeof(*IdsToDelete) ); i++ )
            {

            Hr = m_IISAdminBase->DeleteData(
                mdHandle,
                NULL,
                m_PropertyMan->GetPropertyMetabaseID( IdsToDelete[i] ),
                ALL_METADATA );

            if ( FAILED( Hr ) && Hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) && 
                 Hr != MD_ERROR_DATA_NOT_FOUND )
                LastError = Hr;

            }

        }

    else
        {


        {

        // save the maximum upload size
        WCHAR MaxUploadSizeString[ MAX_PATH ];

        LRESULT MaxUploadUnitsSelect =
            SendDlgItemMessage( m_hwnd, IDC_COMBO_MAX_UPLOAD_UNITS, CB_GETCURSEL, 0, 0 );

        if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_LIMIT_MAX_UPLOAD ) )
            {                            
            StringCchCopyW( MaxUploadSizeString, MAX_PATH, MD_BITS_UNLIMITED_MAX_FILESIZE );
            }
        else
            {
            UINT64 MaxUploadSize;
            GetDlgItemTextAsInteger( IDC_EDIT_MAX_UPLOAD, MAX_PATH, MaxUploadSize );            
            MaxUploadSize *= s_MaxUploadUnitsScales[ MaxUploadUnitsSelect ];
            StringCchPrintfW( MaxUploadSizeString, MAX_PATH, L"%I64u", MaxUploadSize );
            }

        MergeError( 
            SaveMetadataString(
                mdHandle,
                MD_BITS_MAX_FILESIZE,
                MaxUploadSizeString ), &LastError );
        }

        MergeError( 
            SaveTimeoutValue(
                mdHandle,
                MD_BITS_NO_PROGRESS_TIMEOUT,
                IDC_DELETE_FILES,
                IDC_EDIT_SESSION_TIMEOUT,
                IDC_COMBO_SESSION_TIMEOUT_UNITS ), &LastError );

        // Save the notification settings

        if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, IDC_CHECK_ENABLE_NOTIFICATIONS ) )
            {

            MergeError( 
                SaveMetadataDWORD(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL_TYPE,
                    BITS_NOTIFICATION_TYPE_NONE ), &LastError );

            MergeError(
                SaveMetadataString(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL,
                    L"" ), &LastError );

            }
        else
            {

            LRESULT NotificationTypeSelect = 
                SendDlgItemMessage( m_hwnd, IDC_COMBO_NOTIFICATION_TYPE, CB_GETCURSEL, 0, 0 );

            BITS_SERVER_NOTIFICATION_TYPE NotificationType = 
                (BITS_SERVER_NOTIFICATION_TYPE)( NotificationTypeSelect + BITS_NOTIFICATION_TYPE_POST_BYREF );

            MergeError( 
                SaveMetadataDWORD(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL_TYPE,
                    NotificationType ), &LastError );

            MergeError(
                SaveSimpleString(
                    mdHandle,
                    MD_BITS_NOTIFICATION_URL,
                    IDC_EDIT_NOTIFICATION_URL ), &LastError );

            }


        // Save the webfarm settings
        if ( BST_UNCHECKED == IsDlgButtonChecked( m_hwnd, IDC_ENABLE_SERVER_FARM ) )
            {

            MergeError(
                SaveMetadataString(
                    mdHandle,
                    MD_BITS_HOSTID,
                    L"" ), &LastError );

            MergeError(
                SaveMetadataDWORD(
                    mdHandle,
                    MD_BITS_HOSTID_FALLBACK_TIMEOUT,
                    MD_BITS_NO_TIMEOUT ), &LastError );

            }
        else
            {

            MergeError(
                SaveSimpleString(
                    mdHandle,
                    MD_BITS_HOSTID,
                    IDC_EDIT_HOSTID ), &LastError );

            MergeError(
                SaveTimeoutValue(
                    mdHandle,
                    MD_BITS_HOSTID_FALLBACK_TIMEOUT,
                    IDC_CHECK_FALLBACK_TIMEOUT,
                    IDC_EDIT_FALLBACK_TIMEOUT,
                    IDC_COMBO_FALLBACK_TIMEOUT_UNITS ), &LastError );

            }

        }

error:

    if ( mdHandle )
        m_IISAdminBase->CloseKey( mdHandle );

    mdHandle = NULL;

    if ( FAILED( LastError ) )
        DisplayError( IDS_CANT_SAVE_VALUES, LastError );    

}

void CPropSheetExtension::DisplayHelp( )
{

    WCHAR HelpTopic[MAX_PATH];
    LoadString( g_hinst, IDS_HELPFILE, HelpTopic, MAX_PATH-1); 

    HtmlHelp( NULL,  
              HelpTopic,
              HH_DISPLAY_TOPIC,
              0 );

}

INT_PTR CPropSheetExtension::DialogProc(
    UINT uMsg,     // message
    WPARAM wParam, // first message parameter
    LPARAM lParam  // second message parameter
    )
{

    switch (uMsg) {
    
    case WM_SETCURSOR:
        if ( m_CleanupInProgress )
            {
            // set the cursor for this dialog and its children.
            SetCursor( m_CleanupCursor );
            SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, TRUE );
            return TRUE;
            }
        break;

    case WM_TIMER:
        CleanupTimer( (UINT)wParam );
        return TRUE;

    case WM_INITDIALOG:

        SendDlgItemMessage( m_hwnd, IDC_EDIT_SESSION_DIRECTORY, EM_LIMITTEXT, MAX_PATH-1, 0 );   
        AddComboBoxItems( IDC_COMBO_MAX_UPLOAD_UNITS,
                          &s_MaxUploadUnits[0], s_NumberOfMaxUploadUnits );
        AddComboBoxItems( IDC_COMBO_SESSION_TIMEOUT_UNITS,
                          &s_TimeoutUnits[0], s_NumberOfTimeoutUnits );
        AddComboBoxItems( IDC_COMBO_NOTIFICATION_TYPE,
                          &s_NotificationTypes[0], s_NumberOfNotificationTypes );
        AddComboBoxItems( IDC_COMBO_FALLBACK_TIMEOUT_UNITS,
                          &s_TimeoutUnits[0], s_NumberOfTimeoutUnits );

        LoadInheritedValues();
        LoadValues( ); 
        break;
        
    case WM_COMMAND:
        if ( HIWORD(wParam) == EN_CHANGE ||
             HIWORD(wParam) == CBN_SELCHANGE )
            {
            m_SettingsChanged = true;
            SendMessage(GetParent(m_hwnd), PSM_CHANGED, (WPARAM)m_hwnd, 0);
            }

        else if ( HIWORD(wParam) == BN_CLICKED )
            {

            WORD ButtonID = LOWORD(wParam);
            
            if ( IDC_BUTTON_SCHEDULE_CLEANUP != ButtonID &&
                 IDC_BUTTON_CLEANUP_NOW != ButtonID )
                {
                m_SettingsChanged = true;
                SendMessage(GetParent(m_hwnd), PSM_CHANGED, (WPARAM)m_hwnd, 0);
                }

            switch( LOWORD(wParam) )
                {
                case IDC_CHECK_BITS_UPLOAD:
                    m_EnabledSettingChanged = true;
                    UpdateUploadGroupState( );
                    break;

                case IDC_RADIO_USE_INHERITED_CONFIG:
                    LoadMaxUploadValue( m_InheritedValues.MaxUploadSize );
                    LoadTimeoutValue( m_InheritedValues.SessionTimeout );
                    LoadServerFarmSettings( m_InheritedValues.HostId, m_InheritedValues.FallbackTimeout );       
                    LoadNotificationValues( m_InheritedValues.NotificationType, 
                                            m_InheritedValues.NotificationURL );
                    
                // Intentional fallthrough
                case IDC_RADIO_USE_CUSTOM_CONFIG:
                    UpdateConfigGroupState( true );
                    break;

                case IDC_CHECK_LIMIT_MAX_UPLOAD:
                    UpdateMaxUploadGroupState( true );
                    break;

                case IDC_DELETE_FILES:
                    UpdateTimeoutGroupState( true );
                    break;

                case IDC_CHECK_ENABLE_NOTIFICATIONS:
                    UpdateNotificationsGroupState( true );
                    break;

                case IDC_ENABLE_SERVER_FARM:
                    UpdateServerFarmGroupState( true );
                    break;

                case IDC_CHECK_FALLBACK_TIMEOUT:
                    UpdateServerFarmFallbackGroupState( true );
                    break;

                case IDC_BUTTON_SCHEDULE_CLEANUP:
                    ScheduleCleanup();
                    break;

                case IDC_BUTTON_CLEANUP_NOW:
                    CleanupNow();
                    break;

                }
            }

        break;
        
    case WM_DESTROY:
        // we don't free the notify handle for property sheets
        // MMCFreeNotifyHandle(pThis->m_ppHandle);
        break;
        
   case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) 
            {
        
            case PSN_KILLACTIVE:
                SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, !ValidateValues( ) );
                return TRUE;

            case PSN_APPLY:
                // don't notify the primary snap-in that Apply
                // has been hit...
                // MMCPropertyChangeNotify(pThis->m_ppHandle, (long)pThis);
                
                if ( m_SettingsChanged )
                    {
                    CloseCleanupItems();
                    SetValues( );
                    UpdateCleanupState( );

                    // all changes are flushed now
                    m_SettingsChanged = m_EnabledSettingChanged = false;
                    }

                SetWindowLongPtr( m_hwnd, DWLP_MSGRESULT, PSNRET_NOERROR );
                return TRUE;

            case PSN_HELP:
                DisplayHelp( );
                return TRUE;
            }
        break;

    case WM_HELP:
        DisplayHelp( );
        return TRUE;

    }
    
    return FALSE;
}

HRESULT
CPropSheetExtension::ComputeMetabaseParent()
{

    //
    // Hack the metabase path to get the key parent  
    //
    
    SIZE_T MetabaseParentSize = wcslen( m_MetabasePath ) + 1;

    try
    {
        m_MetabaseParent = new WCHAR[ MetabaseParentSize ];
    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }
    
    StringCchCopy( m_MetabaseParent, MetabaseParentSize, m_MetabasePath );

    {

        WCHAR *p = m_MetabaseParent + wcslen( m_MetabaseParent );
        while( ( L'/' != *p ) && ( p != m_MetabaseParent ) )
            p--;

        *p = L'\0';
    }

    return S_OK;
}

HRESULT
CPropSheetExtension::ComputeUNCComputerName()
{

    //
    //
    // The task scheduler expects the name of the computer to have
    // double slashes in front of it just like UNC names.  Do the
    // conversion here.
    //
    SIZE_T ComputerNameSize = wcslen( m_ComputerName );

    try
    {
        m_UNCComputerName = new WCHAR[ ComputerNameSize + 3 ]; // add
    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }

    WCHAR *StringDest;

    if ( L'\\' == m_ComputerName[0] )
        {

        if ( L'\\' == m_ComputerName[1] )
            {
            // No slashes are needed
            StringDest = m_UNCComputerName;
            }
        else
            {
            // need one slash
            m_UNCComputerName[0] = L'\\';
            StringDest = m_UNCComputerName + 1;
            }

        }
    else
        {
        // need two slashes
        m_UNCComputerName[0]    = m_UNCComputerName[1]      = L'\\';
        StringDest              = m_UNCComputerName + 2;
        }

    memcpy( StringDest, m_ComputerName, ( ComputerNameSize + 1 ) * sizeof( WCHAR ) );

    return S_OK;

}

HRESULT
CPropSheetExtension::OpenSetupInterface()
{

    HRESULT Hr;
    WCHAR *ADSIPath = NULL;
    WCHAR *ConvertedMetabasePath = m_MetabasePath;

    try
        {

        if ( _wcsnicmp( m_MetabasePath, L"/LM/", wcslen(L"/LM/") ) == 0 ||
             _wcsnicmp( m_MetabasePath, L"LM/", wcslen(L"LM/" ) ) == 0 )
            {

            //
            // Only do the fixup if we're not managing the local computer
            //

            WCHAR ComputerName[ MAX_COMPUTERNAME_LENGTH  + 1 ];

            DWORD BufferLength = MAX_COMPUTERNAME_LENGTH + 1; 
            if ( !GetComputerName( ComputerName, &BufferLength ) )
                return HRESULT_FROM_WIN32( GetLastError() );

            if ( _wcsicmp( m_ComputerName, ComputerName ) != 0 )
                {

                SIZE_T ConvertedPathSize    = wcslen( m_ComputerName ) + wcslen( m_MetabasePath ) + 1;

                try
                {
                    ConvertedMetabasePath       = new WCHAR[ ConvertedPathSize ];
                }
                catch( ComError Error )
                {
                    return Error.m_Hr;
                }

                StringCchCopyW( ConvertedMetabasePath, ConvertedPathSize, L"/" );
                StringCchCatW( ConvertedMetabasePath, ConvertedPathSize, m_ComputerName );
                size_t MetabaseOffset = 
                    m_MetabasePath[0] == L'/' ?
                    wcslen(L"/LM") : wcslen( L"LM" );
                StringCchCatW( ConvertedMetabasePath, ConvertedPathSize, m_MetabasePath + MetabaseOffset );

                }
            }


        ADSIPath = CSimplePropertyReader::ConvertObjectPathToADSI( ConvertedMetabasePath );
        THROW_COMERROR( ADsGetObject( ADSIPath, __uuidof(*m_IBITSSetup), (void**)&m_IBITSSetup ) );
        
        if ( ConvertedMetabasePath != m_MetabasePath)
            delete[] ConvertedMetabasePath;
        
        ConvertedMetabasePath = NULL;
        delete ADSIPath;
        ADSIPath = NULL;

        }
    catch( ComError Error )
        {
        delete ADSIPath;

        if ( ConvertedMetabasePath != m_MetabasePath )
            delete[] ConvertedMetabasePath;

        return Error.m_Hr;
        }
    return S_OK;

}

///////////////////////////////
// Interface IExtendPropertySheet
///////////////////////////////
HRESULT CPropSheetExtension::CreatePropertyPages( 
    /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
    /* [in] */ LONG_PTR handle,
    /* [in] */ LPDATAOBJECT lpIDataObject)
{

    HRESULT Hr = E_FAIL;
   
    Hr = ExtractSnapInString( (IDataObject*)lpIDataObject, m_MetabasePath, s_cfSnapInMetapath );

    if ( FAILED(Hr) )
        return Hr;    

    Hr = ExtractSnapInString( (IDataObject*)lpIDataObject, m_ComputerName, s_cfSnapInMachineName );

    if ( FAILED(Hr) )
        return Hr;

    Hr = ComputeUNCComputerName();

    if ( FAILED(Hr) )
        return Hr;

    Hr = ExtractSnapInGUID( (IDataObject*)lpIDataObject, m_NodeGuid, s_cfNodeType ); 

    if ( FAILED(Hr) )
        return Hr;

    Hr = ComputeMetabaseParent();

    if ( FAILED(Hr) )
        return Hr;

    Hr = OpenSetupInterface();

    if ( FAILED(Hr) )
        return Hr;


    if ( !m_IISAdminBase )
        {
                    
        COSERVERINFO coinfo;
        coinfo.dwReserved1  = 0;
        coinfo.dwReserved2  = 0;
        coinfo.pAuthInfo    = NULL;
        coinfo.pwszName     = m_ComputerName;

        GUID guid = __uuidof( IMSAdminBase );
        MULTI_QI mqi;
        mqi.hr              = S_OK;
        mqi.pIID            = &guid;
        mqi.pItf            = NULL;

        Hr = 
            CoCreateInstanceEx(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                &coinfo,
                1,
                &mqi );

        if ( FAILED( Hr ) )
            return Hr;

        if ( FAILED( mqi.hr ) )
            return mqi.hr;

        m_IISAdminBase = (IMSAdminBase*)mqi.pItf;
            
        }

    METADATA_RECORD mdr;
    DWORD BufferRequired;
    memset( &mdr, 0, sizeof(mdr) );

    mdr.dwMDIdentifier = MD_KEY_TYPE;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = sizeof(m_NodeTypeName);
    mdr.pbMDData = (PBYTE) m_NodeTypeName;

    Hr = m_IISAdminBase->GetData(
        METADATA_MASTER_ROOT_HANDLE,
        m_MetabasePath,
        &mdr,
        &BufferRequired );

    // Out of buffer isn't really an error, its just that the
    // node type is bigger then what we are looking for.
    if ( Hr == HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) )
        return S_FALSE;

    if ( FAILED(Hr) )
        return Hr;

    // Do not display pages for nodes that are not virtual directories
    if ( 0 != wcscmp( L"IIsWebVirtualDir", m_NodeTypeName ) )
        return S_FALSE;

    // Create property manager

    try
    {
        m_PropertyMan = new PropertyIDManager();
    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }

    Hr = m_PropertyMan->LoadPropertyInfo( m_ComputerName );

    if ( FAILED( Hr ) )
        return Hr;

    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    // we don't cache this handle like in a primary snap-in
    // the handle value here is always 0
    // m_ppHandle = handle;
   

    memset( &psp, 0, sizeof(psp) );
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HASHELP;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProcExternal;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_BITS_EXT);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    Hr = lpProvider->AddPage(hPage);
    return Hr;
}

HRESULT CPropSheetExtension::QueryPagesFor( 
                                           /* [in] */ LPDATAOBJECT lpDataObject)
{
    return S_OK;
}


void * _cdecl ::operator new( size_t Size )
{
    void * NewMemory = HeapAlloc( GetProcessHeap(), 0, Size );
    if (!NewMemory )
        throw ComError( E_OUTOFMEMORY );

    return NewMemory;
}

void _cdecl ::operator delete( void *Memory )
{
    if ( !Memory )
        return;

    HeapFree( GetProcessHeap(), 0, Memory );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\basesnap.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    basesnap.cpp

Abstract :

    Handles low level COM functions.

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"

// our globals
HINSTANCE g_hinst;
ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {CONTEXTEXTENSION = 0, ABOUT = 1, ADSI = 2, ADSIFACTORY = 3};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
        DisableThreadLibraryCalls( g_hinst );
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{

    try
    {

        SmartIUnknownPointer pFactory;

        if ((rclsid != CLSID_CPropSheetExtension) && (rclsid != CLSID_CSnapinAbout) && (rclsid != CLSID_CBITSExtensionSetup) && 
            (rclsid != __uuidof(BITSExtensionSetupFactory) ) )
            return CLASS_E_CLASSNOTAVAILABLE;


        if (!ppvObj)
            return E_FAIL;

        *ppvObj = NULL;

        // We can only hand out IUnknown and IClassFactory pointers.  Fail
        // if they ask for anything else.
        if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
            return E_NOINTERFACE;

        // make the factory passing in the creation function for the type of object they want
        if (rclsid == CLSID_CPropSheetExtension)
            *pFactory.GetRecvPointer()  = new CClassFactory(CClassFactory::CONTEXTEXTENSION);
        else if (rclsid == CLSID_CSnapinAbout)
            *pFactory.GetRecvPointer()  = new CClassFactory(CClassFactory::ABOUT);
        else if (rclsid == CLSID_CBITSExtensionSetup)
            *pFactory.GetRecvPointer()  = new CClassFactory(CClassFactory::ADSI);
        else if (rclsid == __uuidof(BITSExtensionSetupFactory) ) 
            *pFactory.GetRecvPointer()  = new CClassFactory( CClassFactory::ADSIFACTORY );

        THROW_COMERROR( pFactory->QueryInterface(riid, ppvObj) );

        return S_OK;
    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }


}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(1), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}


STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj )
{

    try
    {

        if (!ppvObj)
            throw ComError( E_FAIL );

        *ppvObj = NULL;

        SmartIUnknownPointer pObj;

        if ( ADSI == m_factoryType )
            {

            if ( !pUnkOuter )
                throw ComError( E_FAIL );

            if ( pUnkOuter && ( riid != __uuidof(IUnknown) ) )
                throw ComError( CLASS_E_NOAGGREGATION );

            *pObj.GetRecvPointer() = (IBITSExtensionSetup*)new CBITSExtensionSetup( pUnkOuter, NULL );

            if ( pUnkOuter )
                {
                IUnknown *pUnk = pObj.Release();
                *ppvObj = ((CBITSExtensionSetup*)(IBITSExtensionSetup*)pUnk)->GetNonDelegationIUknown();
                return S_OK;
                }

            }
        else
            {

            // Our object does does not support aggregation, so we need to
            // fail if they ask us to do aggregation.
            if (pUnkOuter)
                throw ComError( CLASS_E_NOAGGREGATION );

            if (CONTEXTEXTENSION == m_factoryType ) {

                THROW_COMERROR( CPropSheetExtension::InitializeStatic() );
                *pObj.GetRecvPointer() = new CPropSheetExtension();

            } else if ( ADSIFACTORY == m_factoryType ) 
                {
                *pObj.GetRecvPointer() = new CBITSExtensionSetupFactory();
                }
            else {
                *pObj.GetRecvPointer() = new CSnapinAbout();
            }

            }

        // QueryInterface will do the AddRef() for us, so we do not
        // do it in this function
        return pObj->QueryInterface(riid, ppvObj);
        

    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

HRESULT
RegisterADSIExtension()
{

    HRESULT Hr;
    HKEY hKey = NULL;
    DWORD dwDisposition;

    // Register the class.
    LONG Result = RegCreateKeyEx( 
    HKEY_LOCAL_MACHINE,
     _T("SOFTWARE\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{A55E7D7F-D51C-4859-8D2D-E308625D908E}"),
     0,
     NULL,
     REG_OPTION_NON_VOLATILE,
     KEY_WRITE,
     NULL,
     &hKey,
     &dwDisposition );

    if ( ERROR_SUCCESS != Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    // Register the Interface.
    const TCHAR szIf[] = _T("{29cfbbf7-09e4-4b97-b0bc-f2287e3d8eb3}");
    Result = RegSetValueEx( hKey, _T("Interfaces"), 0, REG_MULTI_SZ, (const BYTE *) szIf, sizeof(szIf) );
    
    if ( ERROR_SUCCESS != Result )
        return HRESULT_FROM_WIN32( GetLastError() );
    
    RegCloseKey(hKey);
    return S_OK;
}
    
HRESULT
UnregisterADSIExtension()
{
    LONG Result =
        RegDeleteKey( 
            HKEY_LOCAL_MACHINE,
            _T("SOFTWARE\\Microsoft\\ADs\\Providers\\IIS\\Extensions\\IIsApp\\{A55E7D7F-D51C-4859-8D2D-E308625D908E}") );

    if ( ERROR_SUCCESS != Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;

}

HRESULT
RegisterEventLog()
{

    HKEY EventLogKey = NULL;
    DWORD Disposition;

    LONG Result =
        RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,                         // handle to open key
            EVENT_LOG_KEY_NAME,                         // subkey name
            0,                                          // reserved
            NULL,                                       // class string
            0,                                          // special options
            KEY_ALL_ACCESS,                             // desired security access
            NULL,                                       // inheritance
            &EventLogKey,                               // key handle 
            &Disposition                                // disposition value buffer
            );

    if ( Result )
        return HRESULT_FROM_WIN32( Result );

    DWORD Value = 1;

    Result =
        RegSetValueEx(
            EventLogKey,            // handle to key
            L"CategoryCount",       // value name
            0,                      // reserved
            REG_DWORD,              // value type
            (BYTE*)&Value,          // value data
            sizeof(Value)           // size of value data
            );

    if ( Result )
        goto error;

    const WCHAR MessageFileName[] = L"%SystemRoot%\\system32\\bitsmgr.dll";
    const DWORD MessageFileNameSize = sizeof( MessageFileName );

    Result =
        RegSetValueEx(
            EventLogKey,                    // handle to key
            L"CategoryMessageFile",         // value name
            0,                              // reserved
            REG_EXPAND_SZ,                  // value type
            (const BYTE*)MessageFileName,   // value data
            MessageFileNameSize             // size of value data
            );

    if ( Result )
        goto error;

    Result =
        RegSetValueEx(
            EventLogKey,                    // handle to key
            L"EventMessageFile",            // value name
            0,                              // reserved
            REG_EXPAND_SZ,                  // value type
            (const BYTE*)MessageFileName,   // value data
            MessageFileNameSize             // size of value data
            );

    if ( Result )
        goto error;

    Value = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
    Result =
        RegSetValueEx(
            EventLogKey,            // handle to key
            L"TypesSupported",      // value name
            0,                      // reserved
            REG_DWORD,              // value type
            (BYTE*)&Value,          // value data
            sizeof(Value)           // size of value data
            );

    if ( Result )
        goto error;

    RegCloseKey( EventLogKey );
    EventLogKey = NULL;
    return S_OK;

error:

    if ( EventLogKey )
        {
        RegCloseKey( EventLogKey );
        EventLogKey = NULL;
        }

    if ( REG_CREATED_NEW_KEY == Disposition )
        {
        RegDeleteKey( 
            HKEY_LOCAL_MACHINE,
            EVENT_LOG_KEY_NAME );
        }

    return HRESULT_FROM_WIN32( Result );

}

HRESULT
UnRegisterEventLog()
{

    RegDeleteKey( 
        HKEY_LOCAL_MACHINE,
        EVENT_LOG_KEY_NAME );

    return S_OK;

}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{

    DWORD Result;
    HRESULT hr = S_OK;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName) / sizeof(*szName) );
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, 
               sizeof(szSnapInName) / sizeof(*szSnapInName) );
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, 
               sizeof(szAboutName) / sizeof(*szAboutName) );
    
    _TCHAR DllName[ MAX_PATH ];    

    Result = 
        GetModuleFileName(
            (HMODULE)g_hinst,
            DllName,
            MAX_PATH - 1 );

    if ( !Result )
        hr = HRESULT_FROM_WIN32( GetLastError() );
    
    ITypeLib*  TypeLib = NULL;

    if (SUCCEEDED(hr))
        hr = LoadTypeLibEx(
            DllName, // DllName,
            REGKIND_REGISTER,
            &TypeLib );

    TypeLib->Release();
    TypeLib = NULL;
    
    // register our CoClasses
    if (SUCCEEDED(hr))
        hr = RegisterServer(g_hinst, 
            CLSID_CPropSheetExtension, 
            szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);

    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst,
        CLSID_CBITSExtensionSetup,
        _T("BITS server setup ADSI extension"),
        _T("Both"));

    if (SUCCEEDED(hr))
        hr = RegisterServer(g_hinst,
        __uuidof(BITSExtensionSetupFactory),
        _T("BITS server setup ADSI extension factory"),
        _T("Apartment"),
        true,
        _T("O:SYG:BAD:(A;;CC;;;SY)(A;;CC;;;BA)S:") );

    if SUCCEEDED(hr)
        hr = RegisterADSIExtension();

    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CPropSheetExtension, szSnapInName, CLSID_CSnapinAbout);
    
    if SUCCEEDED(hr)
        hr = RegisterEventLog();

    return hr;
}

// {B0937B9C-D66D-4d9b-B741-49C6D66A1CD5}
DEFINE_GUID(LIBID_BITSExtensionSetup, 
0xb0937b9c, 0xd66d, 0x4d9b, 0xb7, 0x41, 0x49, 0xc6, 0xd6, 0x6a, 0x1c, 0xd5);


STDAPI DllUnregisterServer()
{
    DWORD Result;

    if ( !( ( UnregisterServer(CLSID_CPropSheetExtension) == S_OK ) &&
            ( UnregisterSnapin(CLSID_CPropSheetExtension) == S_OK ) &&
            ( UnregisterServer(CLSID_CSnapinAbout) == S_OK ) &&
            ( UnregisterServer(CLSID_CBITSExtensionSetup) == S_OK ) &&
            ( UnregisterServer(__uuidof(BITSExtensionSetupFactory)) == S_OK ) &&
            ( UnregisterADSIExtension() == S_OK ) &&
            ( UnRegisterTypeLib( LIBID_BITSExtensionSetup, 1, 0, LANG_NEUTRAL, SYS_WIN32) == S_OK ) && 
            ( UnRegisterEventLog( ) == S_OK ) ) )
        return E_FAIL;
    else
        return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\globals.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    globals.h

Abstract :

    Global variables

Author :

Revision History :

 ***********************************************************************/

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\bitsext.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    bitsext.h

Abstract :

    Main file for snapin.
Author :

Revision History :

 ***********************************************************************/

#ifndef _BITSEXT_H_
#define _BITSEXT_H_

#include <smartptr.h>

typedef SmartRefPointer<ITask>          SmartITaskPointer;
typedef SmartRefPointer<ITaskTrigger>   SmartITaskTriggerPointer;
typedef SmartRefPointer<IEnumWorkItems> SmartIEnumWorkItemsPointer;
typedef SmartRefPointer<ITaskScheduler> SmartITaskSchedulerPointer;
typedef SmartRefPointer<IPersistFile>   SmartIPersistFilePointer;
typedef SmartRefPointer<IMSAdminBase>   SmartIMSAdminBasePointer;
typedef SmartRefPointer<IADs>           SmartIADsPointer;

// Event Log Source
const WCHAR * const EVENT_LOG_SOURCE_NAME=L"BITS Extensions";
const WCHAR * const EVENT_LOG_KEY_NAME=L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\BITS Extensions";

#include "beventlog.h"

// IIS MMC node types
const GUID g_IISInstanceNode = {0xa841b6c7, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};
const GUID g_IISChildNode    = {0xa841b6c8, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}};

class CBITSExtensionSetup;
class CNonDelegatingIUnknown : public IUnknown
{

    ULONG   m_cref;
    CBITSExtensionSetup *m_DelegatingIUnknown;

public:

    CNonDelegatingIUnknown( CBITSExtensionSetup * DelegatingIUnknown );

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void); 
    
};

class CBITSExtensionSetup : public IBITSExtensionSetup, public IADsExtension 
{

private:
    IUnknown*   m_pOuter;
    IDispatch*  m_OuterDispatch;
    ITypeInfo*  m_TypeInfo;
    IUnknown*   m_pObject;
    BSTR        m_ADSIPath;
    IBITSExtensionSetup* m_RemoteInterface;
    WCHAR *     m_Path;

    bool        m_InitComplete;
    CNonDelegatingIUnknown m_DelegationIUnknown;
    PropertyIDManager* m_PropertyMan;
    LONG        m_Lock;

    HRESULT LoadPath();
    HRESULT ConnectToRemoteExtension();
    HRESULT LoadTypeInfo();

public:
    CBITSExtensionSetup( IUnknown *Outer, IUnknown *Object );
    virtual ~CBITSExtensionSetup();
    
    IUnknown *GetNonDelegationIUknown()
    {
        return &m_DelegationIUnknown;
    }

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IADsExtension methods

    STDMETHOD(Operate)(ULONG dwCode, VARIANT varData1, VARIANT varData2, VARIANT varData3);

    STDMETHOD(PrivateGetIDsOfNames)( 
        REFIID riid,  
        OLECHAR FAR* FAR* rgszNames, 
        unsigned int cNames, 
        LCID lcid, 
        DISPID FAR* 
        rgDispId );

    STDMETHOD(PrivateGetTypeInfo)( 
        unsigned int iTInfo, 
        LCID lcid, 
        ITypeInfo FAR* FAR* ppTInfo );

    STDMETHOD(PrivateGetTypeInfoCount)( 
        unsigned int FAR* pctinfo );

    STDMETHOD(PrivateInvoke)( 
        DISPID dispIdMember, 
        REFIID riid, LCID lcid, 
        WORD wFlags, 
        DISPPARAMS FAR* pDispParams, 
        VARIANT FAR* pVarResult, 
        EXCEPINFO FAR* pExcepInfo, 
        unsigned int FAR* puArgErr );

    // IDispatch Methods

    STDMETHOD(GetIDsOfNames)( 
        REFIID riid,  
        OLECHAR FAR* FAR* rgszNames, 
        unsigned int cNames, 
        LCID lcid, 
        DISPID FAR* 
        rgDispId );

    STDMETHOD(GetTypeInfo)( 
        unsigned int iTInfo, 
        LCID lcid, 
        ITypeInfo FAR* FAR* ppTInfo );

    STDMETHOD(GetTypeInfoCount)( 
        unsigned int FAR* pctinfo );

    STDMETHOD(Invoke)( 
        DISPID dispIdMember, 
        REFIID riid, LCID lcid, 
        WORD wFlags, 
        DISPPARAMS FAR* pDispParams, 
        VARIANT FAR* pVarResult, 
        EXCEPINFO FAR* pExcepInfo, 
        unsigned int FAR* puArgErr );

    // IBITSExtensionSetup methods

    STDMETHODIMP EnableBITSUploads();
    STDMETHODIMP DisableBITSUploads();
    STDMETHODIMP GetCleanupTaskName( BSTR *pTaskName );
    STDMETHODIMP GetCleanupTask( REFIID riid, IUnknown **ppUnk );
         
};

class CBITSExtensionSetupFactory : public IBITSExtensionSetupFactory
{

    long m_cref;
    ITypeInfo *m_TypeInfo;

public:
    
    CBITSExtensionSetupFactory();
    virtual ~CBITSExtensionSetupFactory();

    HRESULT LoadTypeInfo();

    STDMETHODIMP GetObject( BSTR Path, IBITSExtensionSetup **ppExtensionSetup );

    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHOD(GetIDsOfNames)( 
        REFIID riid,  
        OLECHAR FAR* FAR* rgszNames, 
        unsigned int cNames, 
        LCID lcid, 
        DISPID FAR* 
        rgDispId );

    STDMETHOD(GetTypeInfo)( 
        unsigned int iTInfo, 
        LCID lcid, 
        ITypeInfo FAR* FAR* ppTInfo );

    STDMETHOD(GetTypeInfoCount)( 
        unsigned int FAR* pctinfo ); 

    STDMETHOD(Invoke)( 
        DISPID dispIdMember, 
        REFIID riid, LCID lcid, 
        WORD wFlags, 
        DISPPARAMS FAR* pDispParams, 
        VARIANT FAR* pVarResult, 
        EXCEPINFO FAR* pExcepInfo, 
        unsigned int FAR* puArgErr );

    STDMETHODIMP EnableBITSUploads();
    STDMETHODIMP DisableBITSUploads();
         
};

class CPropSheetExtension : public IExtendPropertySheet
{
    
private:
    ULONG   m_cref;
    
    // clipboard format
    static bool s_bStaticInitialized;
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    static UINT s_cfSnapInMetapath;
    static UINT s_cfSnapInMachineName;

    static const UINT s_MaxUploadUnits[];
    static const UINT s_NumberOfMaxUploadUnits;
    static const UINT64 s_MaxUploadUnitsScales[];
    static const UINT s_NumberOfMaxUploadUnitsScales;
    static const UINT64 s_MaxUploadLimits[];
    static const UINT s_NumberOfMaxUploadLimits;

    static const UINT s_TimeoutUnits[];
    static const UINT s_NumberOfTimeoutUnits;
    static const DWORD s_TimeoutUnitsScales[];
    static const UINT s_NumberOfTimeoutUnitsScales;
    static const UINT64 s_TimeoutLimits[];
    static const UINT s_NumberOfTimeoutLimits;

    static const UINT s_NotificationTypes[];
    static const UINT s_NumberOfNotificationTypes;

public:
    CPropSheetExtension();
    ~CPropSheetExtension();
    static HRESULT InitializeStatic();    
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
private:
    TCHAR *         m_MetabasePath;
    TCHAR *         m_MetabaseParent;
    TCHAR *         m_ComputerName;
    TCHAR *         m_UNCComputerName;
    GUID            m_NodeGuid;
    IMSAdminBase*   m_IISAdminBase;
    IBITSExtensionSetup* m_IBITSSetup;
    WCHAR           m_NodeTypeName[MAX_PATH];
    PropertyIDManager* m_PropertyMan;

    HWND            m_hwnd;
    bool            m_SettingsChanged;       // true if any settings changed
    bool            m_EnabledSettingChanged; // true if the vdir was enabled or disabled

    struct InheritedValues
    {
        UINT64 MaxUploadSize;
        DWORD  SessionTimeout;
        BITS_SERVER_NOTIFICATION_TYPE NotificationType;
        WCHAR  * NotificationURL;
        WCHAR  * HostId;
        DWORD  FallbackTimeout;

        InheritedValues();
        ~InheritedValues();
    } m_InheritedValues;

    SmartITaskSchedulerPointer m_TaskSched;
    SmartITaskPointer          m_CleanupTask;
    bool            m_CleanupInProgress;
    FILETIME        m_PrevCleanupStartTime;
    HCURSOR         m_CleanupCursor;
    bool            m_CleanupMinWaitTimerFired;

    static const UINT s_CleanupMinWaitTimerID           = 1;
    static const UINT s_CleanupPollTimerID              = 2;
    static const UINT s_CleanupMinWaitTimerInterval     = 2000; // two seconds
    static const UINT s_CleanupPollTimerInterval        = 1000; // one second

    static INT_PTR CALLBACK DialogProcExternal(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        )
    {

        CPropSheetExtension *pThis;
         
        if ( WM_INITDIALOG == uMsg )
            {
            pThis = reinterpret_cast<CPropSheetExtension *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
            SetWindowLongPtr( hwndDlg, DWLP_USER, reinterpret_cast<LONG_PTR>( pThis ) );
            }
        else
            {
            pThis = reinterpret_cast<CPropSheetExtension*>( GetWindowLongPtr( hwndDlg, DWLP_USER ) );
            }

         if ( !pThis )
			return FALSE;       

        pThis->m_hwnd = hwndDlg;

        return pThis->DialogProc(
            uMsg,
            wParam,
            lParam );

    }

    INT_PTR DialogProc(
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );   
    
    HRESULT ComputeMetabaseParent();
    HRESULT ComputeUNCComputerName();
    HRESULT OpenSetupInterface();

    HRESULT LoadInheritedDWORD(
        METADATA_HANDLE mdHandle,
        WCHAR * pKeyName,
        DWORD PropId,
        DWORD * pReturn );

    HRESULT LoadInheritedString(
        METADATA_HANDLE mdHandle,
        WCHAR * pKeyName,
        DWORD PropId,
        WCHAR ** pReturn );

    void LoadInheritedValues( );
    void LoadValues( );

    void MergeError( HRESULT Hr, HRESULT * LastHr );
    HRESULT SaveSimpleString( METADATA_HANDLE mdHandle, DWORD PropId, DWORD EditId );
    HRESULT SaveTimeoutValue(
        METADATA_HANDLE mdHandle,
        DWORD PropId,
        DWORD CheckId,
        DWORD EditId,
        DWORD UnitId );

    void SetValues( );
    bool ValidateValues( );
    bool WarnAboutAccessFlags( );

    void AddComboBoxItems( UINT Combo, const UINT *Items, UINT NumberOfItems );
    void DisplayError( UINT StringId );
    void DisplayError( UINT StringId, HRESULT Hr );
    bool DisplayWarning( UINT StringId );
    void SetDlgItemTextAsInteger( UINT Id, UINT64 Value );
    bool GetDlgItemTextAsInteger( UINT Id, UINT MaxString, UINT64 & Value );
    void DisplayHelp( );

    void UpdateMaxUploadGroupState( bool IsEnabled );
    void UpdateTimeoutGroupState( bool IsEnabled );
    void UpdateNotificationsGroupState( bool IsEnabled );
    void UpdateConfigGroupState( bool IsEnabled );
    void UpdateServerFarmFallbackGroupState( bool IsEnabled );
    void UpdateServerFarmGroupState( bool IsEnabled );
    void UpdateUploadGroupState( );

    void UpdateCleanupState( );
    void CloseCleanupItems();
    void ScheduleCleanup();
    void CleanupNow();
    void CleanupTimer( UINT TimerID );

    void LoadMaxUploadValue( UINT64 MaxValue );
    void LoadTimeoutValue(
        DWORD CheckId,
        DWORD EditId,
        DWORD UnitId,
        DWORD Value );

    void LoadTimeoutValue( DWORD SessionTimeout );
    void LoadNotificationValues( BITS_SERVER_NOTIFICATION_TYPE NotificationType, WCHAR *NotificationURL );
    void LoadServerFarmSettings( WCHAR *HostId, DWORD FallbackTimeout );

    HRESULT ExtractData( 
        IDataObject* piDataObject,
        CLIPFORMAT   cfClipFormat,
        BYTE*        pbData,
        DWORD        cbData );
    
    HRESULT ExtractString( IDataObject *piDataObject,
        CLIPFORMAT   cfClipFormat,
        _TCHAR       *pstr,
        DWORD        cchMaxLength)
    {
        return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
    }
    
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
    {
        return ExtractData( piDataObject, (CLIPFORMAT)s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
    }
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
    {
        return ExtractData( piDataObject, (CLIPFORMAT)s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
    }
    
    HRESULT ExtractSnapInString( IDataObject * piDataObject,
                                 WCHAR * & String,
                                 UINT Format );

    HRESULT ExtractSnapInGUID( IDataObject * piDataObject,
                               GUID & Guid,
                               UINT Format );

    HRESULT SaveMetadataString(
        METADATA_HANDLE mdHandle,
        DWORD PropId,
        WCHAR *Value );

    HRESULT SaveMetadataDWORD(
        METADATA_HANDLE mdHandle,
        DWORD PropId,
        DWORD Value );


};

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
    /* [out] */ LPOLESTR *lpDescription);
    
    STDMETHODIMP GetProvider( 
    /* [out] */ LPOLESTR *lpName);
    
    STDMETHODIMP GetSnapinVersion( 
    /* [out] */ LPOLESTR *lpVersion);
    
    STDMETHODIMP GetSnapinImage( 
    /* [out] */ HICON *hAppIcon);
    
    STDMETHODIMP GetStaticFolderImage( 
    /* [out] */ HBITMAP *hSmallImage,
    /* [out] */ HBITMAP *hSmallImageOpen,
    /* [out] */ HBITMAP *hLargeImage,
    /* [out] */ COLORREF *cMask);
        
    ///////////////////////////////
    // Private Interface 
    ///////////////////////////////
private:
    HRESULT	LoadStringHelper(
        LPOLESTR *lpDest, 
        UINT Id );
};

void
ConnectToTaskScheduler(
    LPWSTR ComputerName, 
    SmartITaskSchedulerPointer * TaskScheduler );

void
FindWorkItemForVDIR( 
    SmartITaskSchedulerPointer TaskScheduler,
    LPCWSTR Key,
    SmartITaskPointer   *ReturnedTask,
    LPWSTR  *ReturnedTaskName );

void 
IsBITSEnabledOnVDir(
    PropertyIDManager *PropertyManager,
    IMSAdminBase *IISAdminBase,
    LPWSTR VirtualDirectory,
    BOOL *IsEnabled );

void
EnableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    SmartIMSAdminBasePointer IISAdminBase,
    LPCWSTR             Path );

void
DisableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    SmartIMSAdminBasePointer IISAdminBase,
    LPCWSTR             Path,
    bool                DisableForRollback,
    bool                DisableForUpgrade );

void CleanupForRemoval( LPCWSTR Path );

#endif _BITSEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\cleanup.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cleanup.cpp

Abstract:

    This file implements the BITS server extensions cleanup worker

--*/

#include "precomp.h"

const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per second

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
};

class PollKillError
{
public:
    HRESULT m_Hr;
    PollKillError( HRESULT Hr ) : 
        m_Hr( Hr )
    {
    }
};

class CleanupWorker
{

public:
    CleanupWorker( BOOL DeleteAll, HWND hwnd, const WCHAR* Path, 
                   const WCHAR *WorkItemName, const WCHAR *GuidString );
    ~CleanupWorker();
    void DoIt();

private:

    BOOL          m_DeleteAll;
    HWND          m_hwnd;
    const WCHAR * m_Path;
    const WCHAR * m_WorkItemName;
    const WCHAR * m_GuidString;
    const WCHAR * m_ADSIPath;
    IADs        * m_VDir;
    BSTR          m_VDirPath;
    BSTR          m_SessionDirectory;
    BSTR          m_UNCUsername;
    BSTR          m_UNCPassword;
    UINT64        m_CleanupThreshold;
    
    StringHandle m_SessionDirPath;
    StringHandle m_RequestsDirPath;
    StringHandle m_RepliesDirPath;

    VARIANT       m_vt;

    HANDLE        m_UserToken;
    HANDLE        m_EventLog;

    BSTR          m_BITSCleanupWorkItemKeyBSTR;
    BSTR          m_BITSUploadEnabledBSTR;
    BSTR          m_BITSSessionTimeoutBSTR;
    BSTR          m_PathBSTR;
    BSTR          m_BITSSessionDirectoryBSTR;
    BSTR          m_UNCUserNameBSTR;
    BSTR          m_UNCPasswordBSTR;

    void PollKill();

    void DeleteDirectoryAndFiles( StringHandle Directory );
    bool DirectoryExists( StringHandle Directory );
    UINT64 LastDirectoryTime( StringHandle Directory );
    void RemoveSession( StringHandle SessionGuid );
    void RemoveSessions( bool SecondPass );

    void RemoveConnectionsFromTree( 
        const WCHAR * DirectoryPath,
        bool IsConnectionDirectory,
        const WCHAR * FileSystemPath = NULL );

    void RemoveConnection( const WCHAR * ConnectionDirectory, const WCHAR *FilesystemPath,
                           const WCHAR * SessionGuid );

    void LogDeletedJob( const WCHAR *SessionGuid );
    void LogUnableToRemoveSession( const WCHAR *SessionGuid, HRESULT Hr );
    void LogUnexpectedError( HRESULT Hr );
    void LogUnableToScanDirectory( const WCHAR *Path, HRESULT Hr );

};

void
BITSSetCurrentThreadToken(
    HANDLE hToken )
{

    if ( !SetThreadToken( NULL, hToken ) )
        {

        for( unsigned int i = 0; i < 100; i ++ )
            {

            Sleep( 10 );

            if ( SetThreadToken( NULL, hToken ) )
                return;

            }
        
        TerminateProcess( NULL, GetLastError() ); 

        }

}

CleanupWorker::CleanupWorker(
    BOOL DeleteAll,
    HWND hwnd, 
    const WCHAR* Path, 
    const WCHAR* WorkItemName,
    const WCHAR* GuidString ) :
m_DeleteAll( DeleteAll ),
m_hwnd( hwnd ),
m_Path( Path ),
m_WorkItemName( WorkItemName ),
m_GuidString( GuidString ),
m_ADSIPath( NULL ),
m_VDir( NULL ),
m_VDirPath( NULL ),
m_SessionDirectory( NULL ),
m_CleanupThreshold( 0 ),
m_UNCUsername( NULL ),
m_UNCPassword( NULL ),
m_UserToken( NULL ),
m_EventLog( NULL ),
m_BITSCleanupWorkItemKeyBSTR( NULL ),
m_BITSUploadEnabledBSTR( NULL ),
m_BITSSessionTimeoutBSTR( NULL ),
m_PathBSTR( NULL ),
m_BITSSessionDirectoryBSTR( NULL ),
m_UNCUserNameBSTR( NULL ),
m_UNCPasswordBSTR( NULL )
{
    VariantInit( &m_vt );

    m_BITSCleanupWorkItemKeyBSTR    = SysAllocString( L"BITSCleanupWorkItemKey" );
    m_BITSUploadEnabledBSTR         = SysAllocString( L"BITSUploadEnabled" );
    m_BITSSessionTimeoutBSTR        = SysAllocString( L"BITSSessionTimeout" );
    m_PathBSTR                      = SysAllocString( L"Path" );
    m_BITSSessionDirectoryBSTR      = SysAllocString( L"BITSSessionDirectory" );
    m_UNCUserNameBSTR               = SysAllocString( L"UNCUserName" );
    m_UNCPasswordBSTR               = SysAllocString( L"UNCPassword" );

    if ( !m_BITSCleanupWorkItemKeyBSTR || !m_BITSUploadEnabledBSTR || !m_BITSSessionTimeoutBSTR ||
         !m_PathBSTR || !m_BITSSessionDirectoryBSTR || !m_UNCUserNameBSTR || !m_UNCPasswordBSTR )
        {
        
        SysFreeString( m_BITSCleanupWorkItemKeyBSTR );
        SysFreeString( m_BITSUploadEnabledBSTR );
        SysFreeString( m_BITSSessionTimeoutBSTR );
        SysFreeString( m_PathBSTR );
        SysFreeString( m_BITSSessionDirectoryBSTR );
        SysFreeString( m_UNCUserNameBSTR );
        SysFreeString( m_UNCPasswordBSTR );
        
        throw ComError( E_OUTOFMEMORY ); 
        }


    m_EventLog = 
        RegisterEventSource(
            NULL,                       // server name
            EVENT_LOG_SOURCE_NAME       // source name
            );

    if ( !m_EventLog )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
    
}

CleanupWorker::~CleanupWorker()
{

    if ( m_EventLog )
        DeregisterEventSource( m_EventLog );

    if ( m_UserToken )
        {
        BITSSetCurrentThreadToken( NULL );
        CloseHandle( m_UserToken );
        }

    delete m_ADSIPath;
    SysFreeString( m_VDirPath );
    SysFreeString( m_SessionDirectory );
    SysFreeString( m_UNCUsername );
    SysFreeString( m_UNCPassword );

    // Free hardcoded strings
    SysFreeString( m_BITSCleanupWorkItemKeyBSTR );
    SysFreeString( m_BITSUploadEnabledBSTR );
    SysFreeString( m_BITSSessionTimeoutBSTR );
    SysFreeString( m_PathBSTR );
    SysFreeString( m_BITSSessionDirectoryBSTR );
    SysFreeString( m_UNCUserNameBSTR );
    SysFreeString( m_UNCPasswordBSTR );

}

//---------------------------------------------------------------------------
//  CleanupWorker::DeleteDirectoryAndFiles()
//
//  This method deletes the specified directory and the files it contains. If
//  the specified directory contains subdirectories, then they will not be 
//  deleted (and the delete of the main directory will fail).
//
//  If the directory is a reparse point, then it will do nothing. If the 
//  specified directory contains reparse points then they will be ignored as
//  well.
//---------------------------------------------------------------------------
void
CleanupWorker::DeleteDirectoryAndFiles( StringHandle Directory )
{

    HANDLE  FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FILE_ATTRIBUTE_DATA  FileAttributes;

    try
    {
       // Check the specified directory. If its not actually a directory, or 
       // it's a reparse point then don't process it.
       if (!GetFileAttributesEx( Directory,
                                 GetFileExInfoStandard,
                                 &FileAttributes))
           {
           throw ComError(HRESULT_FROM_WIN32(GetLastError()));
           }

       if (   (FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
          || !(FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
           {
           return;
           }

       
       StringHandle SearchPath = Directory + StringHandle(L"\\*");
       
       WIN32_FIND_DATA FindData;

       FindHandle = FindFirstFile( SearchPath,
                                   &FindData );

       if ( INVALID_HANDLE_VALUE == FindHandle )
           {
           throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
           }

       do
           {

           if (  (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
              || (FindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) )
               {
               continue;
               }

           StringHandle FileName =  StringHandle( Directory ) + StringHandle( L"\\" ) +
                                    StringHandle( FindData.cFileName );
           DeleteFile( FileName );

           }
       while ( FindNextFile( FindHandle, &FindData ) );

       FindClose( FindHandle );
       FindHandle = INVALID_HANDLE_VALUE;

       if ( !RemoveDirectory( Directory ) )
           {
           throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
           }

    }
    catch( ComError Error )
    {
       if ( INVALID_HANDLE_VALUE != FindHandle )
           {
           FindClose( FindHandle );
           }
       throw;
    }

    if ( INVALID_HANDLE_VALUE != FindHandle )
        {
        FindClose( FindHandle );
        }
}

bool
CleanupWorker::DirectoryExists(
    StringHandle Directory )
{

    DWORD dwAttributes =
        GetFileAttributes( Directory );

    if ( INVALID_FILE_ATTRIBUTES == dwAttributes )
        {

        if ( GetLastError() == ERROR_PATH_NOT_FOUND ||
             GetLastError() == ERROR_FILE_NOT_FOUND )
            return false;

        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        }
    return true;
}

//-------------------------------------------------------------------------
// CleanupWorker::LastDirectoryTime()
//
// Walk a directory and find the most recent "Last Write Time" for it or
// and of its contents.
//
// Note: Ignore reparse points.
//
//-------------------------------------------------------------------------
UINT64
CleanupWorker::LastDirectoryTime(
    StringHandle Directory )
{
    UINT64 LatestTime = 0;
    HANDLE FindHandle = INVALID_HANDLE_VALUE;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributesData;

    if (!GetFileAttributesEx( Directory,
                              GetFileExInfoStandard,
                              &FileAttributesData ) )
        {
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    LatestTime = FILETIMEToUINT64( FileAttributesData.ftCreationTime );

    StringHandle SearchPath = Directory + StringHandle(L"\\*");
       
    WIN32_FIND_DATA FindData;

    FindHandle =
         FindFirstFile(
             SearchPath,
             &FindData
             );

    if ( INVALID_HANDLE_VALUE == FindHandle )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

    try
    {
       
        do
           {

           if (  (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
              || (FindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) )
               {
               continue;
               }

           UINT64 CreationTime      = FILETIMEToUINT64( FindData.ftCreationTime );
           UINT64 LastWriteTime     = FILETIMEToUINT64( FindData.ftLastWriteTime ); 
           LatestTime = max( LatestTime, max( CreationTime, LastWriteTime ) );
           }
       while ( FindNextFile( FindHandle, &FindData ) );

       FindClose( FindHandle );
       FindHandle = INVALID_HANDLE_VALUE;

    }
    catch( ComError Error )
    {
        if ( INVALID_HANDLE_VALUE == FindHandle )
            FindClose( FindHandle );

        throw;
    }

    return LatestTime;

}

void
CleanupWorker::RemoveSession(
    StringHandle SessionGuid )
{

    StringHandle RequestDir             = m_RequestsDirPath + StringHandle("\\") +  SessionGuid;
    StringHandle ReplyDir               = m_RepliesDirPath + StringHandle("\\") + SessionGuid;
    
    bool RequestExists                  = DirectoryExists( RequestDir );
    bool ReplyExists                    = DirectoryExists( ReplyDir );


    UINT64 LastTime = 0;

    if ( RequestExists )
        {
            try
            {
                LastTime = LastDirectoryTime( RequestDir );
            }
            catch( ComError Error )
            {
                LogUnableToScanDirectory( RequestDir, Error.m_Hr );
                return;
            }
        }

    if ( ReplyExists )
        {

            try
            {
                LastTime = max( LastTime, LastDirectoryTime( ReplyDir ) );
            }
            catch( ComError Error )
            {
                LogUnableToScanDirectory( ReplyDir, Error.m_Hr );
                return;
            }
        }

    FILETIME ftCurrentTime;
    GetSystemTimeAsFileTime( &ftCurrentTime );
    UINT64 CurrentTime = FILETIMEToUINT64( ftCurrentTime );

    if ( ( 0xFFFFFFFF - LastTime > m_CleanupThreshold ) && 
         ( LastTime + m_CleanupThreshold < CurrentTime ) )

        {

            try
            {
                if ( RequestExists )
                    {
                    DeleteDirectoryAndFiles( RequestDir );
                    }

                if ( ReplyExists )
                    {
                    DeleteDirectoryAndFiles( ReplyDir );
                    }

                LogDeletedJob( SessionGuid );
            }
            catch( ComError Error )
            {
                LogUnableToRemoveSession( SessionGuid, Error.m_Hr );
            }

        }

}

//--------------------------------------------------------------------------
//  CleanupWorker::RemoveSessions()
//
//  Inspect the current "Replies directory" and "Requests directory" and
//  remove any BITS session directories that are older than the current 
//  cleanup threshold.
//
//  Arguments:
//
//  SecondPass   TRUE: Inspect the Replies Directory Path.
//               FALSE: Inspect the Requests Directory Path.
//--------------------------------------------------------------------------
void
CleanupWorker::RemoveSessions( IN bool SecondPass )
{

    StringHandle SearchDirectory = (SecondPass)? m_RepliesDirPath : m_RequestsDirPath;
    StringHandle SearchString    = SearchDirectory + StringHandle( L"\\*" );
    HANDLE       FindHandle      = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA           FindData;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributes;

    try
    {
        if (!GetFileAttributesEx(SearchDirectory,
                                 GetFileExInfoStandard,
                                 &FileAttributes))
            {
            throw ComError(HRESULT_FROM_WIN32(GetLastError()));
            }

        if (   (FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
           || !(FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
            {
            return;
            }

        FindHandle = FindFirstFile( SearchString, &FindData );

        if ( INVALID_HANDLE_VALUE == FindHandle )
            {
            throw ComError(HRESULT_FROM_WIN32(GetLastError()));    
            }

        do
            {

            PollKill();

            // If its not a directory then ignore it...
            if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                {
                continue;
                }

            // If its a reparse point then ignore it.
            if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                {
                continue;
                }

            // If its this directory or the parent directory reference then
            // ignore it.
            if (  ( _wcsicmp( L".", FindData.cFileName ) == 0 )
               || ( _wcsicmp( L"..", FindData.cFileName ) == 0 ) )
                {
                continue;
                }

            // If the name isn't a GUID then ignore it.
            GUID Guid;
            if ( FAILED( IIDFromString( FindData.cFileName, &Guid ) ) )
                {
                continue;
                }

            try
            {
                RemoveSession( StringHandle( FindData.cFileName ) );
            }
            catch( ComError Error )
            {
                LogUnexpectedError( Error.m_Hr );
            }

            } while( FindNextFile( FindHandle, &FindData ) );

        FindClose( FindHandle );
        FindHandle = INVALID_HANDLE_VALUE;

    }
    catch( const ComError & )
    {
        if ( INVALID_HANDLE_VALUE != FindHandle )
            {
            FindClose( FindHandle );
            }
        throw;
    }
    catch( const PollKillError & )
    {
        if ( INVALID_HANDLE_VALUE != FindHandle )
            {
            FindClose( FindHandle );
            }
    }

}

void 
CleanupWorker::PollKill()
{

    if ( m_hwnd )
        {

        MSG msg;

        while( PeekMessage(
                   &msg,
                   m_hwnd,
                   0,
                   0,
                   PM_REMOVE ) )
            {

            if ( WM_QUIT == msg.message )
                throw PollKillError( (HRESULT)msg.wParam );

            TranslateMessage( &msg );
            DispatchMessage( &msg );

            }

        }
}


void 
CleanupWorker::DoIt()
{

    try
    {

        m_ADSIPath = CSimplePropertyReader::ConvertObjectPathToADSI( m_Path );

        try
        {
            THROW_COMERROR( ADsGetObject( m_ADSIPath, __uuidof(*m_VDir), (void**)&m_VDir ) );

            if ( m_GuidString )
               {

               BSTR BSTRGuid = CSimplePropertyReader::GetADsStringProperty( m_VDir, m_BITSCleanupWorkItemKeyBSTR );
               int Result = wcscmp( (LPWSTR)BSTRGuid, m_GuidString );

               SysFreeString( BSTRGuid );

               if ( Result != 0 )
                  throw ComError( E_ADS_UNKNOWN_OBJECT );

               }

        }
        catch( ComError Error )
        {

            if ( ( Error.m_Hr == E_ADS_UNKNOWN_OBJECT ) ||
                 ( Error.m_Hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) ||
              ( Error.m_Hr == E_ADS_PROPERTY_NOT_FOUND ) )
                {
                // Somehow the virtual directory was deleted, but the 
                // task scheduler work item wasn't.  Try to delete it now.

                if ( m_WorkItemName )
                    {

                    SmartITaskSchedulerPointer TaskScheduler;

                    try
                    {
                        ConnectToTaskScheduler( NULL, &TaskScheduler );
                        TaskScheduler->Delete( m_WorkItemName );
                    }
                    catch( ComError Error )
                    {
                    }

                    }


                }

            // Nothing more to do after deleting the task.
            return;
        }

        THROW_COMERROR( m_VDir->Get( m_BITSUploadEnabledBSTR, &m_vt ) );
        THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BOOL ) );

        if ( !m_vt.boolVal ) // Uploads arn't enabled on this directory
            return;

        if ( !m_DeleteAll )
            {

            THROW_COMERROR( m_VDir->Get( m_BITSSessionTimeoutBSTR, &m_vt ) );
            THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );

            if ( L'-' == *m_vt.bstrVal )
                return; // do not run cleanup in this directory since cleanup has been disabled 

            UINT64 CleanupSeconds;
            if ( 1 != swscanf( (WCHAR*)m_vt.bstrVal, L"%I64u", &CleanupSeconds ) )
                return;

            if (  CleanupSeconds > ( 0xFFFFFFFFFFFFFFFF / NanoSec100PerSec ) )
                m_CleanupThreshold = 0xFFFFFFFFFFFFFFFF; // overflow case
            else
                m_CleanupThreshold = CleanupSeconds * NanoSec100PerSec;

            }
        else 
            m_CleanupThreshold = 0;


        m_VDirPath          = CSimplePropertyReader::GetADsStringProperty( m_VDir, m_PathBSTR );
        m_SessionDirectory  = CSimplePropertyReader::GetADsStringProperty( m_VDir, m_BITSSessionDirectoryBSTR );
        m_UNCUsername       = CSimplePropertyReader::GetADsStringProperty( m_VDir, m_UNCUserNameBSTR );
        m_UNCPassword       = CSimplePropertyReader::GetADsStringProperty( m_VDir, m_UNCPasswordBSTR );
        
        m_SessionDirPath    = StringHandle( (WCHAR*)m_VDirPath) + StringHandle(L"\\") +
                              StringHandle( (WCHAR*)m_SessionDirectory );
        m_RequestsDirPath   = m_SessionDirPath + StringHandle(L"\\") + StringHandle( REQUESTS_DIR_NAMEW );
        m_RepliesDirPath    = m_SessionDirPath + StringHandle(L"\\") + StringHandle( REPLIES_DIR_NAMEW );

        if (CAccessRemoteVDir::IsUNCPath(m_VDirPath))
            {
            CAccessRemoteVDir::ImpersonateUNCUser(m_VDirPath, m_UNCUsername, m_UNCPassword, &m_UserToken);
            }

        RemoveSessions( false );
        RemoveSessions( true );

    }
    catch( PollKillError Error )
    {
        throw;
    }
    catch( ComError Error )
    {
        LogUnexpectedError( Error.m_Hr );
        throw;
    }


}

void
CleanupWorker::LogDeletedJob(  
    const WCHAR *SessionGuid )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { (const WCHAR*)m_SessionDirPath, SessionGuid };

        ReportEvent(
            m_EventLog,                         // handle to event log
            EVENTLOG_INFORMATION_TYPE,          // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,   // event category
            BITSSRV_EVENTLOG_DELETED_SESSION,   // event identifier
            NULL,                               // user security identifier
            2,                                  // number of strings to merge
            0,                                  // size of binary data
            Strings,                            // array of strings to merge
            NULL                                // binary data buffer
            );

        }

}

void
CleanupWorker::LogUnableToRemoveSession(  
    const WCHAR *SessionGuid, 
    HRESULT Hr )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { (const WCHAR*)m_SessionDirPath, SessionGuid };

        ReportEvent(
            m_EventLog,                                 // handle to event log
            EVENTLOG_ERROR_TYPE,                        // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,           // event category
            BITSSRV_EVENTLOG_CANT_REMOVE_SESSION,       // event identifier
            NULL,                                       // user security identifier
            2,                                          // number of strings to merge
            sizeof(Hr),                                 // size of binary data
            Strings,                                    // array of strings to merge
            &Hr                                         // binary data buffer
            );

        }

}

void 
CleanupWorker::
LogUnableToScanDirectory( 
    const WCHAR *Path, 
    HRESULT Hr )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { Path };

        ReportEvent(
            m_EventLog,                                 // handle to event log
            EVENTLOG_ERROR_TYPE,                        // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,           // event category
            BITSSRV_EVENTLOG_CANT_SCAN_DIRECTORY,       // event identifier
            NULL,                                       // user security identifier
            1,                                          // number of strings to merge
            sizeof(Hr),                                 // size of binary data
            Strings,                                    // array of strings to merge
            &Hr                                         // binary data buffer
            );

        }

}


void
CleanupWorker::LogUnexpectedError( 
    HRESULT Hr )
{

    if ( m_EventLog )
        {

        const WCHAR *Strings[] = { m_Path };

        ReportEvent(
            m_EventLog,                         // handle to event log
            EVENTLOG_ERROR_TYPE,                // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,   // event category
            BITSSRV_EVENTLOG_UNEXPECTED_ERROR,  // event identifier
            NULL,                               // user security identifier
            1,                                  // number of strings to merge
            sizeof( Hr ),                       // size of binary data
            Strings,                            // array of strings to merge
            &Hr                                 // binary data buffer
            );

        }

}

void Cleanup_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow )
{
    int NumArgs;

    LPWSTR * CommandArgs =
        CommandLineToArgvW(
            lpszCmdLine,
            &NumArgs );

    if ( !CommandArgs )
        return;


    if ( FAILED( CoInitializeEx( NULL, COINIT_MULTITHREADED ) ) )
        return;

    if ( NumArgs != 2 && NumArgs != 3 )
        return;

    LPWSTR Path         = CommandArgs[0];
    LPWSTR WorkItemName = CommandArgs[1];
    LPWSTR GuidString   = NumArgs == 3 ? CommandArgs[2] : NULL;

    try
    {
        CleanupWorker Worker( FALSE, hwndStub, Path, WorkItemName, GuidString );
        Worker.DoIt();
    }
    catch( PollKillError PollAbort )
    {
    }
    catch( ComError Error )
    {
    }

    CoUninitialize( );
    GlobalFree( CommandArgs );

}

void CleanupForRemoval( LPCWSTR Path )
{

    HANDLE hToken = NULL;

    try
    {
        if (!OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &hToken ) )
            {
            if ( GetLastError() != ERROR_NO_TOKEN )
                return;
            }

        CleanupWorker Worker( TRUE, NULL, Path, NULL, NULL );
        Worker.DoIt();
    }
    catch( ComError Error )
    {
    }
    catch( PollKillError PollAbort )
    {
    }

    if ( hToken )
        BITSSetCurrentThreadToken( hToken );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\config.cpp ===
/************************************************************************

Copyright (c) 2002 Microsoft Corporation

Module Name :

    config.cpp

Abstract :

    Configuration APIs

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"
#include <sddl.h>

#pragma warning( disable : 4355 )

HRESULT 
GetTypeInfo( 
    const GUID & guid, 
    ITypeInfo **TypeInfo )
{

    DWORD Result;
    HRESULT hr;
    WCHAR DllName[ MAX_PATH ];

    

    Result = 
        GetModuleFileName(
            g_hinst,
            DllName,
            MAX_PATH - 1 );

    if ( !Result )
        return HRESULT_FROM_WIN32( GetLastError() );

    ITypeLib *TypeLib;

    hr = LoadTypeLibEx( 
        DllName, 
        REGKIND_NONE,  
        &TypeLib );

    if ( FAILED( hr ) )
        return hr;

    hr = TypeLib->GetTypeInfoOfGuid(
            guid,
            TypeInfo );

    TypeLib->Release();

    return hr;
}

void 
FreeReturnedWorkItems(
    ULONG NamesReturned,
    LPWSTR **ItemNamesPtr )
{

    LPWSTR *ItemNames = *ItemNamesPtr;

    if ( ItemNames )
        {

        for( ULONG i = 0; i < NamesReturned; i++ )
            {
            CoTaskMemFree( ItemNames[i] );
            }

        CoTaskMemFree( ItemNames );

        *ItemNamesPtr = NULL;

        }

}

void
FindWorkItemForVDIR( 
    SmartITaskSchedulerPointer TaskScheduler,
    LPCWSTR             Key,
    SmartITaskPointer*  ReturnedTask,
    LPWSTR*             ReturnedTaskName )
{

    HRESULT Hr;
    SIZE_T KeyLength = sizeof(WCHAR) * ( wcslen( Key ) + 1 );
    WORD DataLength;
    
    if ( ReturnedTask )
        (*ReturnedTask).Clear();

    if ( ReturnedTaskName )
        *ReturnedTaskName = NULL;

    SmartITaskPointer Task;
    SmartIEnumWorkItemsPointer EnumWorkItems;
    LPWSTR *ItemNames = NULL;
    BYTE *ItemData = NULL;
    ULONG NamesReturned = 0;

    try
    {
        THROW_COMERROR( TaskScheduler->Enum( EnumWorkItems.GetRecvPointer() ) );
        
        while( 1 )
            {

            THROW_COMERROR( EnumWorkItems->Next( 255, &ItemNames, &NamesReturned ) );

            if ( !NamesReturned )
                throw ComError( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) );

            for ( ULONG i = 0; i < NamesReturned; i++ )
                {

                THROW_COMERROR( TaskScheduler->Activate( ItemNames[i], Task.GetUUID(), 
                                                         (IUnknown**)Task.GetRecvPointer() ) );
                THROW_COMERROR( Task->GetWorkItemData( &DataLength, &ItemData ) );

                if ( KeyLength == DataLength && 
                     ( wcscmp( Key, (WCHAR*)ItemData ) == 0 ) )
                    {

                    // Found the item, cleanup and return

                    if ( ReturnedTask )
                        *ReturnedTask = Task;

                    if ( ReturnedTaskName )
                        {
                        *ReturnedTaskName = ItemNames[i];
                        ItemNames[i] = NULL;
                        }

                    FreeReturnedWorkItems(
                        NamesReturned,
                        &ItemNames );

                    CoTaskMemFree( ItemData );
                    return;
                    }

                CoTaskMemFree( ItemData );
                ItemData = NULL;

                }

            FreeReturnedWorkItems(
                NamesReturned,
                &ItemNames );
            NamesReturned = 0;


            }
        

    }
    catch( ComError Error )
    {
 
        FreeReturnedWorkItems(
           NamesReturned,
           &ItemNames );
        
        CoTaskMemFree( ItemData );

        throw;
    }

}

WCHAR *BasePathOf( IN WCHAR *pPath )
{
    WCHAR *pBasePath;

    if (!pPath)
        {
        return NULL;
        }

    if (  (pBasePath=wcsrchr(pPath,L'/'))
       || (pBasePath=wcsrchr(pPath,L'\\')) )
        {
        pBasePath++;
        }
    else
        {
        pBasePath = pPath;
        }

    return pBasePath;
}

void CreateWorkItemForVDIR(
    IN SmartITaskSchedulerPointer TaskScheduler,
    IN LPWSTR Path, 
    IN LPWSTR Key )
{
    
    WORD  KeySize = sizeof(WCHAR) * ( wcslen( Key ) + 1 );
    WCHAR ItemName[MAX_PATH];
    WCHAR ItemCommentFormat[MAX_PATH];
    WCHAR ItemComment[2*MAX_PATH];
    WCHAR Parameters[4*MAX_PATH];

    //
    // Use the last part of the path for the item name and description comment.
    //
    const WCHAR *pBasePath = BasePathOf(Path);

    if (!pBasePath || 0==wcslen(pBasePath))
        {
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_NAME) );
        }

    //
    // Construct the description/comment string.
    //
    DWORD Result;
    void* InsertArray[2] = { (void*)pBasePath, (void*)Key };
    
    if ( !LoadString(g_hinst, IDS_WORK_ITEM_COMMENT, ItemCommentFormat, MAX_PATH) )
        {
        throw ComError( HRESULT_FROM_WIN32(GetLastError()) );
        }

    Result = FormatMessage( FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                            (LPCVOID)ItemCommentFormat,
                            0,
                            0,
                            ItemComment,
                            ARRAY_ELEMENTS(ItemComment),
                            (va_list*)InsertArray );

    ItemComment[ ARRAY_ELEMENTS(ItemComment) - 1 ] = L'\0';

    if ( !Result )
        {
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
        }

    //
    // Construct the task scheduler item name. Since StringCchPrintfW() is always
    // defined to return a (possibly trunctated) buffer, we can ignore the error
    // return in this case.
    //
    StringCchPrintfW(
        ItemName,
        ARRAY_ELEMENTS(ItemName),
        L"BITS_%s_%s", pBasePath, Key );

    //
    // Construct the runstring for the task.
    //
    StringCchPrintfW( 
        Parameters, 
        ARRAY_ELEMENTS(Parameters), 
        L"bitsmgr.dll,Cleanup_RunDLL %s \"%s\" %s", Path, ItemName, Key );

    WORD TriggerNumber;
    SmartITaskPointer           Task;
    SmartITaskTriggerPointer    TaskTrigger;
    SmartIPersistFilePointer    PersistFile;

    try
    {
        
        try
        {
            FindWorkItemForVDIR( TaskScheduler, Key, &Task, NULL );
            return; // work item already found
        }
        catch( ComError Error )
        {
            if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) != Error.m_Hr )
                throw;
        }

        // error not found

        THROW_COMERROR( TaskScheduler->NewWorkItem( ItemName, CLSID_CTask, 
                                                    Task.GetUUID(), (IUnknown**)Task.GetRecvPointer() ) );

        // Set basic task data
        THROW_COMERROR( Task->SetApplicationName( L"%SystemRoot%\\system32\\rundll32.exe" ) );
        THROW_COMERROR( Task->SetMaxRunTime( INFINITE ) );
        THROW_COMERROR( Task->SetParameters( Parameters ) );
        THROW_COMERROR( Task->SetPriority( IDLE_PRIORITY_CLASS  ) );
        THROW_COMERROR( Task->SetAccountInformation( L"", NULL ) ); //Run as localsystem
        THROW_COMERROR( Task->SetFlags( TASK_FLAG_RUN_ONLY_IF_LOGGED_ON | TASK_FLAG_HIDDEN  ) );
        THROW_COMERROR( Task->SetWorkItemData( KeySize, (BYTE*)Key ) );
        Task->SetComment( ItemComment ); // Don't fail if this one fails...

        // Set the trigger information.  Set start time to now, with a default
        // interval of once a day.
        THROW_COMERROR( Task->CreateTrigger( &TriggerNumber, TaskTrigger.GetRecvPointer() ) );

        SYSTEMTIME LocalTime;
        GetLocalTime( &LocalTime );
        
        TASK_TRIGGER Trigger;
        memset( &Trigger, 0, sizeof( Trigger ) );
        Trigger.cbTriggerSize               = sizeof(Trigger);
        Trigger.wBeginYear                  = LocalTime.wYear;
        Trigger.wBeginMonth                 = LocalTime.wMonth;
        Trigger.wBeginDay                   = LocalTime.wDay;
        Trigger.wStartHour                  = LocalTime.wHour;
        Trigger.wStartMinute                = LocalTime.wMinute;
        Trigger.TriggerType                 = TASK_TIME_TRIGGER_DAILY;
        Trigger.MinutesDuration             = 24 * 60; // 24 hours per day 
        Trigger.MinutesInterval             = 12 * 60; // twice per day
        Trigger.Type.Daily.DaysInterval     = 1;
        
        THROW_COMERROR( TaskTrigger->SetTrigger( &Trigger ) );

        // Commit the changes to disk.
        THROW_COMERROR( Task->QueryInterface( PersistFile.GetUUID(), 
                                              (void**)PersistFile.GetRecvPointer() ) );
        THROW_COMERROR( PersistFile->Save( NULL, TRUE ) );
    }
    catch( ComError Error )
    {
        TaskScheduler->Delete( ItemName );
        throw;
    }
    
}

void
DeleteWorkItemForVDIR(
    SmartITaskSchedulerPointer TaskScheduler,
    LPWSTR Key )
{
    
    LPWSTR TaskName = NULL;

    try
    {
        FindWorkItemForVDIR( TaskScheduler, Key, NULL, &TaskName );
        THROW_COMERROR( TaskScheduler->Delete( TaskName ) );
    }
    catch( ComError Error )
    {
        CoTaskMemFree( TaskName );
        
        if ( HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == Error.m_Hr )
            return;

        throw;
    }

}

void
ConnectToTaskScheduler(
    LPWSTR ComputerName, 
    SmartITaskSchedulerPointer * TaskScheduler )
{

     THROW_COMERROR( 
         CoCreateInstance(
            CLSID_CTaskScheduler,
            NULL,
            CLSCTX_INPROC_SERVER,
            (*TaskScheduler).GetUUID(),
            (void**)(*TaskScheduler).GetRecvPointer() ) );

     THROW_COMERROR( (*TaskScheduler)->SetTargetComputer( ComputerName ) );

}

void 
IsBITSEnabledOnVDir(
    PropertyIDManager *PropertyManager,
    IMSAdminBase *IISAdminBase,
    LPWSTR VirtualDirectory,
    BOOL *IsEnabled )
{
    DWORD BufferRequired;

    *IsEnabled = false;

    DWORD IsEnabledVal;
    METADATA_RECORD MdRecord;
    memset( &MdRecord, 0, sizeof( MdRecord ) );
    
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
    MdRecord.dwMDDataLen    = sizeof(IsEnabled);
    MdRecord.pbMDData       = (PBYTE)&IsEnabledVal;

    try
    {
        THROW_COMERROR(
            IISAdminBase->GetData(
                METADATA_MASTER_ROOT_HANDLE,
                VirtualDirectory,
                &MdRecord,
                &BufferRequired ) );
    }
    catch( ComError Error )
    {
        if ( MD_ERROR_DATA_NOT_FOUND == Error.m_Hr ||
             HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Error.m_Hr )
            return;

        throw;
    }
    
    *IsEnabled = IsEnabledVal ? true : false;

}

LPWSTR
BITSGetFileOwnerSidString(LPCWSTR szFile)
{
    DWORD                cbSizeNeeded        = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PSID                 pOwnerSid           = NULL;
    BOOL                 fOwnerDefaulted     = FALSE;
    LPWSTR               pszSidString        = NULL;

    try
    {
        //
        // Retrieve the file owner. Call GetFileSecurity twice - first to get
        // the buffer size, then the actual information retrieval.
        //
        if (!GetFileSecurity(szFile, OWNER_SECURITY_INFORMATION, NULL, 0, &cbSizeNeeded))
            {
            DWORD dwError = GetLastError();

            if (dwError != ERROR_INSUFFICIENT_BUFFER)
                {
                throw ComError( HRESULT_FROM_WIN32( dwError ) );
                }
            }
        else
            {
            // we don't expect this to ever succeed 
            throw ComError( E_UNEXPECTED );
            }

        //
        // Allocate the buffer space necessary and retrieve the info.
        //
        pSecurityDescriptor = reinterpret_cast<SECURITY_DESCRIPTOR *>(new BYTE[cbSizeNeeded]);
        THROW_OUTOFMEMORY_IFNULL(pSecurityDescriptor);

        if (!GetFileSecurity(szFile, OWNER_SECURITY_INFORMATION, pSecurityDescriptor, cbSizeNeeded, &cbSizeNeeded))
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        //
        // Retrieve & validate the owner sid.
        //
        if (!GetSecurityDescriptorOwner(pSecurityDescriptor, &pOwnerSid, &fOwnerDefaulted))
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        if (!IsValidSid(pOwnerSid))
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }

        if(!ConvertSidToStringSidW(pOwnerSid, &pszSidString))
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            }
    }
    catch ( ComError Error )
    {
        if (pSecurityDescriptor)
            {
            delete [] reinterpret_cast<BYTE *>(pSecurityDescriptor);
            pSecurityDescriptor = NULL;
            }

        throw;
    }

    //
    // Everthing went fine
    //
    if (pSecurityDescriptor)
        {
        delete [] reinterpret_cast<BYTE *>(pSecurityDescriptor);
        pSecurityDescriptor = NULL;
        }

    // caller should free this memory
    return pszSidString;
}

LPWSTR
BITSAddAclForDirectoryOwner(LPCWSTR szBaseAcl, LPCWSTR szUserPartialAclPrefix, LPCWSTR szDirectory)
{
    LPCWSTR szUserPartialAclSuffix = L")"; 
    LPWSTR  szFullAcl  = NULL;
    DWORD   cchFullAcl = 0;
    LPWSTR  pszUserSID = NULL;

    try
    {
        pszUserSID = BITSGetFileOwnerSidString(szDirectory);
        cchFullAcl = wcslen(szBaseAcl) + wcslen(szUserPartialAclPrefix) + wcslen(pszUserSID) + wcslen(szUserPartialAclSuffix) + 1;

        // ATT: this buffer is being allocated and it should be freed by the caller
        szFullAcl  = new WCHAR[ cchFullAcl ];
        THROW_OUTOFMEMORY_IFNULL(szFullAcl);

        StringCchPrintfW(szFullAcl, cchFullAcl, L"%ws%ws%ws%ws", szBaseAcl, szUserPartialAclPrefix, pszUserSID, szUserPartialAclSuffix);
    }
    catch( ComError Error )
    {
        //
        // Free the String SID obtained by calling ConvertSidToStringSid()
        //
        if (pszUserSID)
            {
            LocalFree(reinterpret_cast<HLOCAL>(pszUserSID));
            pszUserSID = NULL;
            }
    }

    //
    // Free the String SID obtained by calling ConvertSidToStringSid()
    //
    if (pszUserSID)
        {
        LocalFree(reinterpret_cast<HLOCAL>(pszUserSID));
        pszUserSID = NULL;
        }

    // this string should be freed by the caller
    return szFullAcl;
}

void
BITSCreateDirectory(
    const WCHAR *Path,
    const WCHAR *SDString,
    BOOL  fAllowInheritanceFromParent,
    BOOL  fAddOwnerExplicitly )
{
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PACL                 pDacl               = NULL; 
    BOOL                 fDaclPresent        = TRUE;
    BOOL                 fDaclDefaulted      = TRUE;
    DWORD                dwProtectedFlag     = 0;
    DWORD                dwError             = ERROR_SUCCESS;
    LPWSTR               szExpandedAcl       = NULL;

    try
    {
        // 
        //  Note that we are setting the SecurityDescriptor as NULL initially.
        //  We will set the security separately via SetNamedSecurityInfo(), otherwise
        //  the inherited ACLs will not be computed.
        //
        if (!CreateDirectory(Path, NULL))
            {
            dwError = GetLastError();

            // ignore error if directory already exists
            if ( ERROR_ALREADY_EXISTS != dwError )
                {
                throw ComError( HRESULT_FROM_WIN32( dwError ) );
                }
            }

        //
        // If we were given a security descriptor string, use it to set the security permissions
        //
        if ( SDString )
            {
            if (fAddOwnerExplicitly)
                {
                    //
                    // Grab the SID for the Owner of the directory we just created, transform it to string
                    // format and add it to the SDDL string that we were given.
                    // We do this in order to guarantee to the owner of the directory the right to
                    // create subdirectories and files. CO permissions will only last during creation time,
                    // so it doesn't help in our scenario. This behavior was confirmed by the Security team.
                    //
                    szExpandedAcl = BITSAddAclForDirectoryOwner(SDString, BITS_EXPLICITOWNER_PARTIAL_ACL, Path);
                }

            if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(
                (szExpandedAcl? szExpandedAcl : SDString),               // security descriptor string
                SDDL_REVISION_1,                                         // revision level
                &pSecurityDescriptor,                                    // SD
                NULL ) )                                                 // SD size
                {
                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
                }

            SECURITY_ATTRIBUTES SecurityAttributes = 
                { 
                sizeof( SECURITY_ATTRIBUTES ), 
                pSecurityDescriptor,
                FALSE 
                };

            if (!GetSecurityDescriptorDacl(pSecurityDescriptor, &fDaclPresent, &pDacl, &fDaclDefaulted))
                {
                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
                }

            if (!fDaclPresent || !pDacl)
                {
                throw ComError( HRESULT_FROM_WIN32( ERROR_INVALID_DATA ) );
                }

            //
            // Decide if we are going to interrupt the inheritance from the parent or not.
            //
            dwProtectedFlag = (fAllowInheritanceFromParent? UNPROTECTED_DACL_SECURITY_INFORMATION : PROTECTED_DACL_SECURITY_INFORMATION);

            //
            // Set the permissions in the directory
            //
            dwError = SetNamedSecurityInfoW(
                (WCHAR *)Path,                                                       // object name
                SE_FILE_OBJECT,                                                      // object type
                DACL_SECURITY_INFORMATION | dwProtectedFlag,                         // Security info flags
                NULL,                                                                // psidOwner
                NULL,                                                                // psidGroup
                pDacl,                                                               // pDacl
                NULL);                                                               // pSacl

            if (dwError != ERROR_SUCCESS)
                {
                throw ComError( HRESULT_FROM_WIN32( dwError ) );
                }
            }
    }
    catch ( ComError Error )
    {
        if ( szExpandedAcl)
            {
            delete [] szExpandedAcl;
            szExpandedAcl = NULL;
            }

        if ( pSecurityDescriptor )
            {
            LocalFree( pSecurityDescriptor );
            }

        throw;
    }

    //
    // Success! Cleanup...
    //
    if ( szExpandedAcl)
        {
        delete [] szExpandedAcl;
        szExpandedAcl = NULL;
        }

    if ( pSecurityDescriptor )
        {
        LocalFree( pSecurityDescriptor );
        }
}

void
LogDeleteError(
    DWORD Message,
    StringHandle Name,
    HRESULT Hr )
{

    HANDLE EventHandle = 
        RegisterEventSource(
            NULL,                       // server name
            EVENT_LOG_SOURCE_NAME       // source name
            );

    if ( EventHandle )
        {

        const WCHAR *Strings[] = { (const WCHAR*)Name };

        ReportEvent(
            EventHandle,                        // handle to event log
            EVENTLOG_ERROR_TYPE,                // event type
            BITSRV_EVENTLOG_CLEANUP_CATAGORY,   // event category
            Message,                            // event identifier
            NULL,                               // user security identifier
            1,                                  // number of strings to merge
            sizeof( Hr ),                       // size of binary data
            Strings,                            // array of strings to merge
            &Hr                                 // binary data buffer
            );

        DeregisterEventSource( EventHandle );

        }
}

//---------------------------------------------------------------------------
//  DeleteDirectoryTree()
//
//  Recursive delete of a directory tree.
//
//  Note: Do not follow or delete reparse points.
//---------------------------------------------------------------------------
void
DeleteDirectoryTree( IN StringHandle Directory )
{

    StringHandle SearchString = Directory + StringHandle(L"\\*");
    HANDLE       FindHandle   = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA FindData;
    WIN32_FILE_ATTRIBUTE_DATA  FileAttributes;

    try
    {
        if (!GetFileAttributesEx(Directory,
                                 GetFileExInfoStandard,
                                 &FileAttributes))
            {
            throw ComError(HRESULT_FROM_WIN32(GetLastError()));
            }

        // If the specified directory is a reparse point then ignore it.
        if (FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT)
            {
            return;
            }

        FindHandle = FindFirstFile( SearchString, &FindData );

        if ( INVALID_HANDLE_VALUE == FindHandle )
            {
            throw ComError(HRESULT_FROM_WIN32(GetLastError()));    
            }

        do
            {

            // Ignore reparse points.
            if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT )
                {
                continue;
                }

            // Ignore this and parent directory references.
            if (  ( _wcsicmp( L".", FindData.cFileName ) == 0 )
               || ( _wcsicmp( L"..", FindData.cFileName ) == 0 ) )
                {
                continue;
                }

            StringHandle NewItem = Directory 
                                   + StringHandle(L"\\") 
                                   + StringHandle( FindData.cFileName );

            if ( FILE_ATTRIBUTE_DIRECTORY & FindData.dwFileAttributes )
                {
                DeleteDirectoryTree( NewItem );
                }
            else
                {
                if ( !DeleteFile( NewItem ) )
                    {
                    HRESULT DeleteHr = HRESULT_FROM_WIN32( GetLastError() );
                    LogDeleteError( 
                        BITSSRV_EVENTLOG_DELETEFILE_ERROR,
                        NewItem,
                        DeleteHr );
                    }
                }

            } while( FindNextFile( FindHandle, &FindData ) );

        FindClose( FindHandle );
        FindHandle = INVALID_HANDLE_VALUE;

        if ( !RemoveDirectory( Directory ) )
            {
            HRESULT DeleteHr = HRESULT_FROM_WIN32( GetLastError() );
            LogDeleteError( 
                BITSSRV_EVENTLOG_REMOVEDIRECTORY_ERROR,
                Directory,
                DeleteHr );
            }

    }
    catch( const ComError & )
    {
        if ( INVALID_HANDLE_VALUE != FindHandle)
            {
            FindClose( FindHandle );
            }
     
        throw;
    }

}

void
CreateBITSCacheDirectory(
    PropertyIDManager           *PropertyManager,
    SmartIMSAdminBasePointer    IISAdminBase,
    METADATA_HANDLE             MdVDirKey,
    StringHandle                GuidString )
{

    DWORD   BufferRequired;
    WCHAR   VDirPath[ MAX_PATH ];
    WCHAR   VDirSessionDir[ MAX_PATH ];

    METADATA_RECORD MdRecord;
    MdRecord.dwMDIdentifier = MD_VR_PATH;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
    MdRecord.dwMDDataType   = STRING_METADATA;
    MdRecord.dwMDDataLen    = sizeof( VDirPath );
    MdRecord.pbMDData       = (unsigned char*)VDirPath;
    MdRecord.dwMDDataTag    = 0;

    THROW_COMERROR( 
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR );
    MdRecord.dwMDDataLen    = sizeof( VDirSessionDir );
    MdRecord.pbMDData       = (unsigned char*)VDirSessionDir;

    THROW_COMERROR(
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    StringHandle VDirSessionDirPath = StringHandle( VDirPath ) + StringHandle( L"\\" ) +
                                      StringHandle( VDirSessionDir );
    StringHandle CleanupGuids       = VDirSessionDirPath + StringHandle( L"\\" ) +
                                      StringHandle( CLEANUP_GUIDS_NAME );
    StringHandle CleanupGuidFile    = CleanupGuids + StringHandle( L"\\" ) +
                                      GuidString;

    StringHandle VDirRequestsPath   = VDirSessionDirPath + StringHandle( L"\\" ) +
                                      StringHandle( REQUESTS_DIR_NAMEW );
    StringHandle VDirRepliesPath    = VDirSessionDirPath + StringHandle( L"\\" ) + 
                                      StringHandle( REPLIES_DIR_NAMEW );


    //
    //  Start some filesystem work
    //
    // *If* our VDir is located in a remote share, use the IIS
    // connection account info to connect to the share
    //
    CAccessRemoteVDir oVDir;
    oVDir.LoginToUNC( IISAdminBase, MdVDirKey );

    try
    {
        BITSCreateDirectory(
            VDirSessionDirPath,
            BITS_SESSIONS_DIR_ACL,
            FALSE,  // turn on the PROTECTED flag on the ACL, such that inheritance is interupted from the parent
            TRUE ); // explicitly add the SID of the creator owner to the ACL. Note that inheritance will be computed

        BITSCreateDirectory(
            CleanupGuids,
            BITS_CLEANUPGUIDS_DIR_ACL,
            TRUE,   // Let the ACL for this directory inherit from the parent
            FALSE );// don't add the SID for the owner. It will be inherited

        {

            HANDLE GuidFile =
                CreateFile(
                    CleanupGuidFile,
                    GENERIC_ALL,
                    0,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL );

            if ( INVALID_HANDLE_VALUE == GuidFile )
                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

            CloseHandle( GuidFile );

        }

        BITSCreateDirectory(
            VDirRequestsPath,
            BITS_REQUESTS_DIR_ACL,
            TRUE,   // Let the ACL for this directory inherit from the parent
            FALSE );// don't add the SID for the owner. It will be inherited

        BITSCreateDirectory(
            VDirRepliesPath,
            BITS_REPLIES_DIR_ACL,
            TRUE,   // Let the ACL for this directory inherit from the parent
            FALSE );// don't add the SID for the owner. It will be inherited
    }
    catch( ComError Error )
    {
        // don't let this error propagate with the wrong user
        oVDir.RevertFromUNCAccount();
        throw;
    }


    //
    // Done with the filesystem access
    //
    oVDir.RevertFromUNCAccount();


    StringHandle SessionDirKeyPath  = StringHandle( VDirSessionDir );
    StringHandle RequestsDirKeyPath = SessionDirKeyPath + StringHandle( L"\\" ) +
                                      StringHandle( REQUESTS_DIR_NAMEW );
    StringHandle RepliesDirKeyPath  = SessionDirKeyPath + StringHandle( L"\\" ) +
                                      StringHandle( REPLIES_DIR_NAMEW );

    {
        HRESULT Hr = IISAdminBase->AddKey(
            MdVDirKey,
            SessionDirKeyPath );

        if ( FAILED( Hr ) && ( HRESULT_FROM_WIN32( ERROR_DUP_NAME ) != Hr ) )
            throw ComError( Hr );
    }

    {

        HRESULT Hr = IISAdminBase->AddKey(
            MdVDirKey,
            RepliesDirKeyPath );

        if ( FAILED( Hr ) && ( HRESULT_FROM_WIN32( ERROR_DUP_NAME ) != Hr ) )
            throw ComError( Hr );
    
    }
    
    DWORD AccessPermission = 0;

    MdRecord.dwMDIdentifier = MD_ACCESS_PERM;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDDataLen    = sizeof( AccessPermission );
    MdRecord.pbMDData       = (unsigned char*)&AccessPermission;
    MdRecord.dwMDDataTag    = 0;

    THROW_COMERROR( 
        IISAdminBase->SetData(
            MdVDirKey,              //metadata handle..
            SessionDirKeyPath,     //path of the key relative to hMDHandle.
            &MdRecord ) );

    AccessPermission = 1;          // read only permissions

    THROW_COMERROR(
        IISAdminBase->SetData(
            MdVDirKey,              //metadata handle..
            RepliesDirKeyPath,     //path of the key relative to hMDHandle.
            &MdRecord ) );

    //
    // Set BITS-Sessions to disable browse.
    //
    DWORD  BrowsePermission = 0;

    MdRecord.dwMDIdentifier = MD_DIRECTORY_BROWSING;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDDataLen    = sizeof( BrowsePermission );
    MdRecord.pbMDData       = (unsigned char*)&BrowsePermission;
    MdRecord.dwMDDataTag    = 0;

    THROW_COMERROR(
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    BrowsePermission &= ~MD_DIRBROW_ENABLED;
    MdRecord.dwMDAttributes &= ~METADATA_ISINHERITED;

    THROW_COMERROR(  
        IISAdminBase->SetData(
            MdVDirKey,
            SessionDirKeyPath,
            &MdRecord ) );
}


void
DeleteBITSCacheDirectory(
    PropertyIDManager           *PropertyManager,
    SmartIMSAdminBasePointer    IISAdminBase,
    METADATA_HANDLE             MdVDirKey,
    const WCHAR                 *szObjectPath )
{

    DWORD   BufferRequired;
    WCHAR   VDirPath[ MAX_PATH ];
    WCHAR   VDirSessionDir[ MAX_PATH ];

    METADATA_RECORD MdRecord;
    MdRecord.dwMDIdentifier = MD_VR_PATH;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
    MdRecord.dwMDDataType   = STRING_METADATA;
    MdRecord.dwMDDataLen    = sizeof( VDirPath );
    MdRecord.pbMDData       = (unsigned char*)VDirPath;
    MdRecord.dwMDDataTag    = 0;

    THROW_COMERROR( 
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR );
    MdRecord.dwMDDataLen    = sizeof( VDirSessionDir );
    MdRecord.pbMDData       = (unsigned char*)VDirSessionDir;

    THROW_COMERROR(
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    WCHAR GuidString[ 255 ];

    {

        MdRecord.dwMDDataType   = STRING_METADATA;
        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDDataLen    = sizeof( GuidString );
        MdRecord.pbMDData       = (PBYTE)GuidString;
        MdRecord.dwMDDataTag    = 0;


        HRESULT Hr =
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == Hr )
            return; // The cache directory was never created. 

        THROW_COMERROR( Hr );
    }

    StringHandle VDirSessionDirPath = StringHandle( VDirPath ) + StringHandle( L"\\" ) +
                                      StringHandle( VDirSessionDir );
    
    StringHandle CleanupGuids       = VDirSessionDirPath + StringHandle( L"\\" ) +
                                      StringHandle( CLEANUP_GUIDS_NAME );
    StringHandle CleanupGuidFile    = CleanupGuids + StringHandle( L"\\" ) +
                                      GuidString;

    //
    //  Prepare to do some filesystem work
    //
    // *If* our VDir is located in a remote share, use the IIS
    // connection account info to impersonate that user
    CAccessRemoteVDir oVDir;

    oVDir.LoginToUNC( IISAdminBase, MdVDirKey );

    try
    {
        DeleteFile( CleanupGuidFile );

        BOOL RemovedCleanupDirs = RemoveDirectory( CleanupGuids );

        if ( RemovedCleanupDirs ||
             ERROR_PATH_NOT_FOUND == GetLastError() ||
             ERROR_FILE_NOT_FOUND == GetLastError()  )
            {
            // This is the last "enlistment"
            DeleteDirectoryTree( VDirSessionDirPath );
            }
    }
    catch( ComError Error )
    {
        // don't let this error propagate with the wrong user
        oVDir.RevertFromUNCAccount();
        throw;
    }

    //
    // Done with the filesystem access
    //
    oVDir.RevertFromUNCAccount();

    IISAdminBase->DeleteKey( MdVDirKey, VDirSessionDir ); 

}

void
DeleteOldBITSCacheDirectory(
    PropertyIDManager           *PropertyManager,
    SmartIMSAdminBasePointer    IISAdminBase,
    METADATA_HANDLE             MdVDirKey,
    const WCHAR                 *szObjectPath )
{

    DWORD   BufferRequired;
    WCHAR   VDirPath[ MAX_PATH ];
    WCHAR   VDirSessionDir[ MAX_PATH ];

    METADATA_RECORD MdRecord;
    MdRecord.dwMDIdentifier = MD_VR_PATH;
    MdRecord.dwMDAttributes = METADATA_INHERIT;
    MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
    MdRecord.dwMDDataType   = STRING_METADATA;
    MdRecord.dwMDDataLen    = sizeof( VDirPath );
    MdRecord.pbMDData       = (unsigned char*)VDirPath;
    MdRecord.dwMDDataTag    = 0;

    THROW_COMERROR( 
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CONNECTION_DIR );
    MdRecord.dwMDDataLen    = sizeof( VDirSessionDir );
    MdRecord.pbMDData       = (unsigned char*)VDirSessionDir;

    THROW_COMERROR(
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired ) );

    StringHandle VDirSessionDirPath     = StringHandle( VDirPath ) + StringHandle( L"\\" ) +
                                          StringHandle( VDirSessionDir );
    StringHandle VDirSessionDirPath2    = StringHandle( VDirPath ) + StringHandle( L"\\" ) +
                                          StringHandle( VDirSessionDir ) + StringHandle(L".bak");

    StringHandle DirectoryToDelete;

    //
    //  Prepare to do some filesystem work
    //
    // *If* our VDir is located in a remote share, use the IIS
    // connection account info to impersonate that user
    CAccessRemoteVDir oVDir;

    oVDir.LoginToUNC( IISAdminBase, MdVDirKey );

    try
    {
        if ( !MoveFileEx(
                VDirSessionDirPath,
                VDirSessionDirPath2,
                0 ) )
            {

            DWORD dwError = GetLastError();

            if ( ERROR_PATH_NOT_FOUND == dwError ||
                 ERROR_FILE_NOT_FOUND == dwError )
                {
                oVDir.RevertFromUNCAccount();
                return;
                }

            DirectoryToDelete = VDirSessionDirPath;

            }
        else
            {
            DirectoryToDelete = VDirSessionDirPath2;
            }

        DeleteDirectoryTree( DirectoryToDelete );
    }
    catch( ComError Error )
    {
        // don't let this error propagate with the wrong user
        oVDir.RevertFromUNCAccount();
        throw;
    }


    //
    // Done with the filesystem access
    //
    oVDir.RevertFromUNCAccount();
}

void
GetVDirPropertyVersion(
    PropertyIDManager        *PropertyManager,
    SmartIMSAdminBasePointer IISAdminBase,
    METADATA_HANDLE          MdVDirKey,
    bool                     * pIsEnabled,
    DWORD                    * pdwVersion )
{
    *pIsEnabled = false;
    *pdwVersion = 0;

    HRESULT Hr;
    DWORD IsEnabled = 0;
    METADATA_RECORD MdRecord;
    DWORD BufferRequired;

    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
    MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    MdRecord.dwMDUserType   = ALL_METADATA;
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDDataLen    = sizeof(IsEnabled);
    MdRecord.pbMDData       = (PBYTE)&IsEnabled;
    MdRecord.dwMDDataTag    = 0;

    Hr = 
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired );

    if ( FAILED( Hr ) )
        {
        if ( !( MD_ERROR_DATA_NOT_FOUND == Hr ||
                HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr ) )
            throw ComError( Hr );

        }

    *pIsEnabled = !!IsEnabled;

    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_METADATA_VERSION );
    MdRecord.dwMDDataLen    = sizeof(*pdwVersion);
    MdRecord.pbMDData       = (PBYTE)pdwVersion;

    Hr = 
        IISAdminBase->GetData(
            MdVDirKey,
            NULL,
            &MdRecord,
            &BufferRequired );

    if ( FAILED( Hr ) )
        {
        if ( !( MD_ERROR_DATA_NOT_FOUND == Hr ||
                HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr ) )
            throw ComError( Hr );

        }

}

void
SetVDirEnabled(
    PropertyIDManager        *PropertyManager,
    SmartIMSAdminBasePointer IISAdminBase,
    METADATA_HANDLE          MdVDirKey )
{

    METADATA_RECORD         MdRecord;
    DWORD EnableData        = 1;
    DWORD MetadataVersion   = CURRENT_UPLOAD_METADATA_VERSION;
    
    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_METADATA_VERSION );
    MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_UPLOAD_METADATA_VERSION );
    MdRecord.dwMDDataType   = DWORD_METADATA;
    MdRecord.dwMDDataLen    = sizeof(MetadataVersion);
    MdRecord.pbMDData       = (PBYTE)&MetadataVersion;        
    MdRecord.dwMDDataTag    = 0;

    THROW_COMERROR(
        IISAdminBase->SetData(
            MdVDirKey,
            NULL,
            &MdRecord ) );

    MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
    MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_UPLOAD_ENABLED );
    MdRecord.dwMDDataLen    = sizeof(EnableData);
    MdRecord.pbMDData       = (PBYTE)&EnableData;        

    THROW_COMERROR(
        IISAdminBase->SetData(
            MdVDirKey,
            NULL,
            &MdRecord ) );

}

void
EnableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    SmartIMSAdminBasePointer IISAdminBase,
    LPWSTR             Path )
{

    HRESULT Hr;
    METADATA_RECORD MdRecord;
    METADATA_HANDLE MdVDirKey       = NULL;
    LPWSTR NewScriptMapBuffer       = NULL;
    SmartITaskSchedulerPointer TaskScheduler;
    DWORD BufferRequired;

    bool IsEnabled                  = 0;
    DWORD MetadataVersion           = 0;
    
    try
    {

        THROW_COMERROR(
            IISAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                Path,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                METABASE_OPEN_KEY_TIMEOUT,
                &MdVDirKey ) );

        GetVDirPropertyVersion(
            PropertyManager,
            IISAdminBase,
            MdVDirKey,
            &IsEnabled,
            &MetadataVersion );        

        if ( IsEnabled )
            {

            if ( MetadataVersion >= CURRENT_UPLOAD_METADATA_VERSION )
                {
                // Nothing to do, just leave.
                IISAdminBase->CloseKey( MdVDirKey );
                return;
                }

            IISAdminBase->CloseKey( MdVDirKey );
            MdVDirKey = NULL;

            DisableBITSForVDIR(
                PropertyManager,
                IISAdminBase,
                Path,
                false,
                true );

            EnableBITSForVDIR(
                PropertyManager,
                IISAdminBase,
                Path );

            return;
            }         

        // Generate the new GUID string

        WCHAR GuidString[ 255 ];

        // first try looking up the guid

        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDDataType   = STRING_METADATA;
        MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDDataLen    = sizeof( GuidString );
        MdRecord.pbMDData       = (PBYTE)GuidString;
        MdRecord.dwMDDataTag    = 0;
       
        Hr = IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
             HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
            {

            // create a new guid and save it away

            GUID guid;
        
            THROW_COMERROR( CoCreateGuid( &guid ) );
            StringFromGUID2( guid, GuidString, 254 );
            
            MdRecord.dwMDDataLen    = sizeof(WCHAR) * ( wcslen(GuidString) + 1 );
            MdRecord.pbMDData       = (PBYTE)GuidString;

            THROW_COMERROR( 
                IISAdminBase->SetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord ) );

            }

        else if ( FAILED( Hr ) )
            throw ComError( Hr );

        // build the string to add to the scriptmap
        WCHAR SystemDir[ MAX_PATH + 1 ];

        if (!GetSystemDirectoryW( SystemDir, MAX_PATH ) )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        SystemDir[ MAX_PATH ] = L'\0';
        
        WCHAR ScriptMapString[ MAX_PATH * 2 + 1 ];

        StringCchPrintfW( 
            ScriptMapString,
            ARRAY_ELEMENTS( ScriptMapString ),
            L"*,%s\\bitssrv.dll,1," BITS_COMMAND_VERBW,
            SystemDir );

        int RetChars = wcslen( ScriptMapString );
        ScriptMapString[ RetChars ] = L'\0';
        ScriptMapString[ RetChars + 1] = L'\0';

        RetChars += 2;  // ScriptMapScript is now double NULL terminated

        CreateBITSCacheDirectory(
            PropertyManager,
            IISAdminBase,
            MdVDirKey,
            StringHandle( GuidString ) );

        DWORD AccessFlags;
        MdRecord.dwMDIdentifier = MD_ACCESS_PERM;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDDataType   = DWORD_METADATA;
        MdRecord.dwMDDataLen    = sizeof( AccessFlags );
        MdRecord.pbMDData       = (unsigned char*)&AccessFlags;
        MdRecord.dwMDDataTag    = 0;

        try
        {
            THROW_COMERROR( 
                IISAdminBase->GetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord,
                    &BufferRequired ) );
        }
        catch( ComError Error )
        {
            if ( MD_ERROR_DATA_NOT_FOUND == Error.m_Hr ||
                 HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Error.m_Hr )
                {
                AccessFlags = 0;
                }
            else
                throw;
        }

        if ( AccessFlags & ( MD_ACCESS_SCRIPT | MD_ACCESS_EXECUTE ) )
            {
            
            AccessFlags &= ~( MD_ACCESS_SCRIPT | MD_ACCESS_EXECUTE );
            MdRecord.dwMDAttributes &= ~METADATA_ISINHERITED;

            THROW_COMERROR(  
                IISAdminBase->SetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord ) );

            }

        // 
        //  retrieve the current scriptmap adding room to the allocated memory
        //

        memset( &MdRecord, 0, sizeof( MdRecord ) );

        MdRecord.dwMDDataType   = MULTISZ_METADATA;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDIdentifier = MD_SCRIPT_MAPS;
        MdRecord.dwMDDataLen    = 0;
        MdRecord.pbMDData       = (PBYTE)NULL;
        MdRecord.dwMDDataTag    = 0;

        Hr = 
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( MD_ERROR_DATA_NOT_FOUND == Hr ||
             HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) == Hr )
            {
            // The Current key doesn't exist.
            MdRecord.pbMDData       = (PBYTE)ScriptMapString;
            MdRecord.dwMDDataLen    = RetChars * sizeof(WCHAR); 
            }
        else if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) == Hr )
            {

            NewScriptMapBuffer      = new WCHAR[ ( BufferRequired / sizeof(WCHAR) ) + RetChars ];
            MdRecord.pbMDData       = (PBYTE)NewScriptMapBuffer;
            MdRecord.dwMDDataLen    = BufferRequired + ( RetChars * sizeof(WCHAR) );

            THROW_COMERROR( 
                IISAdminBase->GetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord,
                    &BufferRequired ) );

            // append script entry at the end

            for( WCHAR *p = NewScriptMapBuffer; *p != 0; p += ( wcslen( p ) + 1 ) );
            memcpy( p, ScriptMapString, RetChars * sizeof(WCHAR) );

            MdRecord.pbMDData        = (PBYTE)NewScriptMapBuffer;
            MdRecord.dwMDDataLen     = (DWORD)( ( (char*)p - (char*)NewScriptMapBuffer ) +
                                                ( RetChars * sizeof(WCHAR) ) );
            }
        else
            throw ComError( Hr );

        THROW_COMERROR(  
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdRecord ) );
         


        // Create the task scheduler cleanup work item

        ConnectToTaskScheduler( NULL, &TaskScheduler );
        CreateWorkItemForVDIR( TaskScheduler, Path, GuidString );

        delete[] NewScriptMapBuffer;
        NewScriptMapBuffer = NULL;

        SetVDirEnabled(
            PropertyManager,
            IISAdminBase,
            MdVDirKey );

        IISAdminBase->CloseKey( MdVDirKey );
    }
    
    catch( ComError Exception )
    {

        if ( MdVDirKey )
            {
            
            delete[] NewScriptMapBuffer;
            IISAdminBase->CloseKey( MdVDirKey );

            try
            {
                DisableBITSForVDIR(
                    PropertyManager,
                    IISAdminBase,
                    Path,
                    true,
                    false );

            }
            catch( const ComError & )
            {
            }
            
            }
        
        throw;
    }

}

void
DisableBITSForVDIR(
    PropertyIDManager   *PropertyManager,
    SmartIMSAdminBasePointer  IISAdminBase,
    LPCWSTR             Path,
    bool                RollbackCleanup,
    bool                DisableForUpgrade )
{

    METADATA_HANDLE MdVDirKey           = NULL;
    LPWSTR          OriginalScriptMap   = NULL;
    LPWSTR          NewScriptMap        = NULL;
    SmartITaskSchedulerPointer TaskScheduler;

    try
    {

#if 0
        if ( !RollbackCleanup && !DisableForUpgrade )
            CleanupForRemoval( Path );
#endif

        // build the string to add to the scriptmap
        WCHAR SystemDir[ MAX_PATH + 1 ];

        if (!GetSystemDirectoryW( SystemDir, MAX_PATH ) )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        WCHAR ScriptMapString[ MAX_PATH * 2 + 1 ];

        StringCchPrintfW( 
            ScriptMapString,
            MAX_PATH * 2 + 1,
            L"*,%s\\bitssrv.dll,1,BITS_COMMAND",
            SystemDir );

        int RetChars = wcslen( ScriptMapString );
        ScriptMapString[ RetChars ] = L'\0';
        ScriptMapString[ RetChars + 1] = L'\0';

        // ScriptMapScript is now double NULL terminated

        WCHAR ScriptMapString2[ MAX_PATH * 2 + 1];

        StringCchPrintfW( 
            ScriptMapString2,
            ARRAY_ELEMENTS( ScriptMapString2 ),
            L"*,%\\bitsserver.dll,1,BITS_COMMAND",
            SystemDir );

        RetChars = wcslen( ScriptMapString2 );
        ScriptMapString2[ RetChars ] = L'\0';
        ScriptMapString2[ RetChars + 1 ] = L'\0';

        // ScriptMapScript2 is not double NULL terminated


        WCHAR ScriptMapString3[ MAX_PATH * 2 + 1 ];

        StringCchPrintfW( 
            ScriptMapString3,
            ARRAY_ELEMENTS( ScriptMapString3 ),
            L"*,%s\\bitssrv.dll,1," BITS_COMMAND_VERBW,
            SystemDir );
        
        RetChars = wcslen( ScriptMapString3 );
        ScriptMapString3[ RetChars ] = L'\0';
        ScriptMapString3[ RetChars + 1] = L'\0';

        // ScriptMapScript3 is now double NULL terminated

        THROW_COMERROR(
            IISAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                Path,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                METABASE_OPEN_KEY_TIMEOUT,
                &MdVDirKey ) );

        if ( DisableForUpgrade )
            {

            DeleteOldBITSCacheDirectory(
                PropertyManager,
                IISAdminBase,
                MdVDirKey,
                Path );

            }
        else
            {

            DeleteBITSCacheDirectory(
                PropertyManager,
                IISAdminBase,
                MdVDirKey,
                Path );

            }

        
        // 
        //  retrieve the current scriptmap adding room to the allocated memory
        //

        DWORD BufferRequired;

        METADATA_RECORD MdRecord;
        memset( &MdRecord, 0, sizeof( MdRecord ) );

        MdRecord.dwMDDataType   = MULTISZ_METADATA;
        MdRecord.dwMDAttributes = METADATA_INHERIT;
        MdRecord.dwMDUserType   = IIS_MD_UT_FILE;
        MdRecord.dwMDIdentifier = MD_SCRIPT_MAPS;
        MdRecord.dwMDDataLen    = 0;
        MdRecord.pbMDData       = (PBYTE)NULL;

        HRESULT Hr = 
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired );

        if ( HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ) != Hr )
            throw ComError( Hr );

        OriginalScriptMap = new WCHAR[ BufferRequired / 2 + 2 ];
        NewScriptMap      = new WCHAR[ BufferRequired / 2 + 2 ];

        OriginalScriptMap[0] = OriginalScriptMap[1] = L'\0';

        MdRecord.dwMDDataLen    = BufferRequired;
        MdRecord.pbMDData       = (PBYTE)OriginalScriptMap;

        THROW_COMERROR(  
            IISAdminBase->GetData(
                MdVDirKey,
                NULL,
                &MdRecord,
                &BufferRequired ) );

        // Copy the orignal Scriptmap to the new scriptmap
        // removing bits goo in the process.

        LPWSTR CurrentOriginalItem = OriginalScriptMap;
        LPWSTR CurrentNewItem      = NewScriptMap;

        for( ;L'\0' != *CurrentOriginalItem;
             CurrentOriginalItem += ( wcslen( CurrentOriginalItem ) + 1 )  )
            {

            if ( _wcsicmp( CurrentOriginalItem, ScriptMapString ) == 0 )
                continue; //remove this item

            if ( _wcsicmp( CurrentOriginalItem, ScriptMapString2 ) == 0 )
                continue;

            if ( _wcsicmp( CurrentOriginalItem, ScriptMapString3 ) == 0 )
                continue;

            SIZE_T CurrentOriginalItemSize = wcslen( CurrentOriginalItem ) + 1;
            memcpy( CurrentNewItem, CurrentOriginalItem, CurrentOriginalItemSize * sizeof( WCHAR ) );
            CurrentNewItem += CurrentOriginalItemSize;

            }

        // Add the extra 0
        *CurrentNewItem++ = L'\0';

        MdRecord.dwMDDataLen    = (DWORD)( (char*)CurrentNewItem - (char*)NewScriptMap );
        MdRecord.pbMDData       = (PBYTE)NewScriptMap;

        // set the new scriptmap

        THROW_COMERROR(  
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdRecord ) );

        // Set the enabled property first
        DWORD EnableData = 0;
        METADATA_RECORD MdEnabledRecord;

        MdEnabledRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdEnabledRecord.dwMDDataType   = DWORD_METADATA;
        MdEnabledRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_UPLOAD_ENABLED );
        MdEnabledRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_UPLOAD_ENABLED );
        MdEnabledRecord.dwMDDataLen    = sizeof(EnableData);
        MdEnabledRecord.pbMDData       = (PBYTE)&EnableData;
        MdEnabledRecord.dwMDDataTag           = 0;

        THROW_COMERROR( 
            IISAdminBase->SetData(
                MdVDirKey,
                NULL,
                &MdEnabledRecord ) );


        if ( !DisableForUpgrade )
            {

            WCHAR GuidString[ 255 ];
            memset( &MdRecord, 0, sizeof( MdRecord ) );

            MdRecord.dwMDDataType   = STRING_METADATA;
            MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
            MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
            MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
            MdRecord.dwMDDataLen    = sizeof( GuidString );
            MdRecord.pbMDData       = (PBYTE)GuidString;

            Hr =
                IISAdminBase->GetData(
                    MdVDirKey,
                    NULL,
                    &MdRecord,
                    &BufferRequired );

            if ( FAILED( Hr ) && Hr != MD_ERROR_DATA_NOT_FOUND )
                throw ComError( Hr );

            if ( SUCCEEDED( Hr ) )
                {

                try
                {
                    ConnectToTaskScheduler( NULL, &TaskScheduler );
                    DeleteWorkItemForVDIR( TaskScheduler, GuidString );

                    THROW_COMERROR( 
                        IISAdminBase->DeleteData(
                            MdVDirKey,
                            NULL,
                            PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY ),
                            ALL_METADATA ) );

                }
                catch( const ComError & )
                {
                    if ( !RollbackCleanup )
                        throw;
                }

                }

            }

        delete[] OriginalScriptMap;
        delete[] NewScriptMap;

        IISAdminBase->CloseKey( MdVDirKey );
        MdVDirKey = NULL;

    }
    catch( ComError Exception )
    {
        delete[] OriginalScriptMap;
        delete[] NewScriptMap;

        if ( MdVDirKey )
            IISAdminBase->CloseKey( MdVDirKey );
        
        throw;
    }

}

void
FindWorkItemForVDIR( 
    PropertyIDManager   *PropertyManager,
    SmartIMSAdminBasePointer AdminBase,
    LPCWSTR             Path,
    LPWSTR              *ReturnedTaskName )
{

    if ( ReturnedTaskName )
        *ReturnedTaskName = NULL;

    try
    {
        WCHAR GuidString[ 255 ];
        DWORD BufferRequired;
        METADATA_RECORD MdRecord;
        HRESULT Hr;

        MdRecord.dwMDDataType   = STRING_METADATA;
        MdRecord.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        MdRecord.dwMDUserType   = PropertyManager->GetPropertyUserType( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDIdentifier = PropertyManager->GetPropertyMetabaseID( MD_BITS_CLEANUP_WORKITEM_KEY );
        MdRecord.dwMDDataLen    = sizeof( GuidString );
        MdRecord.pbMDData       = (PBYTE)GuidString;
        MdRecord.dwMDDataTag    = 0;

        THROW_COMERROR( 
            AdminBase->GetData(
                METADATA_MASTER_ROOT_HANDLE,
                Path,
                &MdRecord,
                &BufferRequired ) );

        SmartITaskSchedulerPointer TaskScheduler;
        ConnectToTaskScheduler( NULL, &TaskScheduler );

        FindWorkItemForVDIR( TaskScheduler, GuidString, NULL, ReturnedTaskName );
    
    }
    catch( ComError Error )
    {
        // simply return NULL if the task item isn't found.

        if ( MD_ERROR_DATA_NOT_FOUND == Error.m_Hr ||
             HRESULT_FROM_WIN32( ERROR_NOT_FOUND ) == Error.m_Hr )
            throw ComError( S_FALSE );
    }


}

CBITSExtensionSetupFactory::CBITSExtensionSetupFactory() :
m_cref(1),
m_TypeInfo(NULL)
{
    OBJECT_CREATED
}
    
CBITSExtensionSetupFactory::~CBITSExtensionSetupFactory()
{
    if ( m_TypeInfo )
        m_TypeInfo->Release();

    OBJECT_DESTROYED
}

STDMETHODIMP CBITSExtensionSetupFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IUnknown *>(this);
    else if (IsEqualIID(riid, __uuidof(IBITSExtensionSetupFactory)))
        *ppv = static_cast<IBITSExtensionSetupFactory *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CBITSExtensionSetupFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CBITSExtensionSetupFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

HRESULT
CBITSExtensionSetupFactory::LoadTypeInfo()
{

   if ( m_TypeInfo )
       return S_OK;

   return ::GetTypeInfo( __uuidof( IBITSExtensionSetupFactory ), &m_TypeInfo ); 

}

STDMETHODIMP 
CBITSExtensionSetupFactory::GetIDsOfNames( 
    REFIID,  
    OLECHAR FAR* FAR* rgszNames, 
    unsigned int cNames, 
    LCID, 
    DISPID FAR* rgDispId )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;

    return DispGetIDsOfNames( m_TypeInfo, rgszNames, cNames, rgDispId);


}

STDMETHODIMP 
CBITSExtensionSetupFactory::GetTypeInfo( 
    unsigned int iTInfo, 
    LCID lcid, 
    ITypeInfo FAR* FAR* ppTInfo )
{


   *ppTInfo = NULL;

   if(iTInfo != 0)
      return ResultFromScode(DISP_E_BADINDEX);

   HRESULT Hr;
   Hr = LoadTypeInfo();

   if ( FAILED( Hr ) )
       return Hr;

   m_TypeInfo->AddRef();      
   *ppTInfo = m_TypeInfo;

   return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetupFactory::GetTypeInfoCount( 
    unsigned int FAR* pctinfo )
{
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetupFactory::Invoke( 
    DISPID dispIdMember, 
    REFIID, 
    LCID, 
    WORD wFlags, 
    DISPPARAMS FAR* pDispParams, 
    VARIANT FAR* pVarResult, 
    EXCEPINFO FAR* pExcepInfo, 
    unsigned int FAR* puArgErr )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;


   return
       DispInvoke(
           this, 
           m_TypeInfo,
           dispIdMember, 
           wFlags, 
           pDispParams,
           pVarResult, 
           pExcepInfo, 
           puArgErr); 

}


STDMETHODIMP CBITSExtensionSetupFactory::GetObject( 
    BSTR Path, 
    IBITSExtensionSetup **ppExtensionSetup )
{

    WCHAR *ObjectPath = NULL;
    IUnknown *Object = NULL;

    try
    {
        if ( !Path || !ppExtensionSetup )
            throw ComError( E_INVALIDARG );

        *ppExtensionSetup = NULL;
        ObjectPath = CSimplePropertyReader::ConvertObjectPathToADSI( (WCHAR*)Path );

        THROW_COMERROR( ADsGetObject( BSTR( ObjectPath ), __uuidof( IUnknown ), (void**)&Object ) );

        delete ObjectPath;
        ObjectPath = NULL;

        CBITSExtensionSetup *SetupObj = new CBITSExtensionSetup( NULL, Object );

        if ( !SetupObj )
            throw ComError( E_OUTOFMEMORY );

        Object = NULL;
        *ppExtensionSetup = static_cast<IBITSExtensionSetup*>( SetupObj );
        return S_OK;
    }
    catch( ComError Error )
    {
        delete ObjectPath;
        if ( Object )
            Object->Release();
        return Error.m_Hr;
    }

}


STDMETHODIMP CNonDelegatingIUnknown::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;

    if ( riid == __uuidof(IUnknown) )
        *ppv = static_cast<IUnknown *>(this);
    else if ( riid == __uuidof(IDispatch) )
        *ppv = static_cast<IDispatch*>(m_DelegatingIUnknown);
    else if ( riid == __uuidof(IBITSExtensionSetup) )
        *ppv = static_cast<IBITSExtensionSetup *>(m_DelegatingIUnknown);
    else if ( riid == __uuidof(IADsExtension) )
        *ppv = static_cast<IADsExtension *>(m_DelegatingIUnknown);

    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CNonDelegatingIUnknown::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CNonDelegatingIUnknown::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete m_DelegatingIUnknown;
        return 0;
    }
    
    return m_cref;
}

CNonDelegatingIUnknown::CNonDelegatingIUnknown( CBITSExtensionSetup * DelegatingIUnknown ) :
m_DelegatingIUnknown( DelegatingIUnknown ),
m_cref(1)
{
}

CBITSExtensionSetup::CBITSExtensionSetup( IUnknown *Outer, IUnknown *Object ) :
m_pOuter( Outer ),
m_pObject( Object ),
m_OuterDispatch( NULL ),
m_TypeInfo( NULL ),
m_ADSIPath( NULL ),
m_Path( NULL ),
m_PropertyMan( NULL ),
m_DelegationIUnknown( this ),
m_RemoteInterface( NULL ),
m_InitComplete( false ),
m_Lock( 0 )
{

    if ( m_pOuter )
        {

        HRESULT Hr = m_pOuter->QueryInterface( __uuidof( IDispatch ), (void**)&m_OuterDispatch );

        if ( FAILED( Hr ) )
            m_OuterDispatch = NULL;

        }

    OBJECT_CREATED
}

CBITSExtensionSetup::~CBITSExtensionSetup()
{
    if ( m_pObject )
        {
        m_pObject->Release();
        m_pObject = NULL;
        }

    if ( m_OuterDispatch )
        m_OuterDispatch->Release();

    if ( m_TypeInfo )
        m_TypeInfo->Release();

    delete[] m_Path; // Noop on NULL
    m_Path = NULL;

    if ( m_RemoteInterface )
        m_RemoteInterface->Release();

    delete m_PropertyMan;

    SysFreeString( m_ADSIPath );

    OBJECT_DESTROYED
}

STDMETHODIMP CBITSExtensionSetup::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if ( m_pOuter )
        return m_pOuter->QueryInterface( riid, ppv );
    else
        return m_DelegationIUnknown.QueryInterface( riid, ppv );
}

STDMETHODIMP_(ULONG) CBITSExtensionSetup::AddRef()
{
    
    if ( m_pOuter )
        return m_pOuter->AddRef();
    else
        return m_DelegationIUnknown.AddRef();
}

STDMETHODIMP_(ULONG) CBITSExtensionSetup::Release()
{
    if ( m_pOuter )
        return m_pOuter->AddRef();
    else
        return m_DelegationIUnknown.AddRef();
}

HRESULT
CBITSExtensionSetup::LoadTypeInfo()
{

   if ( m_TypeInfo )
       return S_OK;

   // Lock object
   while( InterlockedExchange( &m_Lock, 1 ) )
       Sleep( 0 );

   HRESULT Hr = ::GetTypeInfo( __uuidof( IBITSExtensionSetup ), &m_TypeInfo ); 

   // Unlock the object
   InterlockedExchange( &m_Lock, 0 );
   return Hr;

}

STDMETHODIMP 
CBITSExtensionSetup::Operate(
    ULONG dwCode, 
    VARIANT varData1, 
    VARIANT varData2, 
    VARIANT varData3)
{

   return E_NOTIMPL;         

}

STDMETHODIMP 
CBITSExtensionSetup::PrivateGetIDsOfNames( 
    REFIID,  
    OLECHAR FAR* FAR* rgszNames, 
    unsigned int cNames, 
    LCID, 
    DISPID FAR* rgDispId )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;

    return DispGetIDsOfNames( m_TypeInfo, rgszNames, cNames, rgDispId);


}

STDMETHODIMP 
CBITSExtensionSetup::PrivateGetTypeInfo( 
    unsigned int iTInfo, 
    LCID lcid, 
    ITypeInfo FAR* FAR* ppTInfo )
{


   *ppTInfo = NULL;

   if(iTInfo != 0)
      return ResultFromScode(DISP_E_BADINDEX);

   HRESULT Hr;
   Hr = LoadTypeInfo();

   if ( FAILED( Hr ) )
       return Hr;

   m_TypeInfo->AddRef();      
   *ppTInfo = m_TypeInfo;

   return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetup::PrivateGetTypeInfoCount( 
    unsigned int FAR* pctinfo )
{
    *pctinfo = 1;
    return NOERROR;
}

STDMETHODIMP 
CBITSExtensionSetup::PrivateInvoke( 
    DISPID dispIdMember, 
    REFIID, 
    LCID, 
    WORD wFlags, 
    DISPPARAMS FAR* pDispParams, 
    VARIANT FAR* pVarResult, 
    EXCEPINFO FAR* pExcepInfo, 
    unsigned int FAR* puArgErr )
{

    HRESULT Hr;
    Hr = LoadTypeInfo();

    if ( FAILED( Hr ) )
        return Hr;


   return
       DispInvoke(
           static_cast<IBITSExtensionSetup*>(this), 
           m_TypeInfo,
           dispIdMember, 
           wFlags, 
           pDispParams,
           pVarResult, 
           pExcepInfo, 
           puArgErr); 

}

STDMETHODIMP 
CBITSExtensionSetup::GetIDsOfNames( 
    REFIID riid,  
    OLECHAR FAR* FAR* rgszNames, 
    unsigned int cNames, 
    LCID lcid, 
    DISPID FAR* rgDispId )
{

    if ( m_OuterDispatch )
        return m_OuterDispatch->GetIDsOfNames( 
            riid,
            rgszNames,
            cNames,
            lcid,
            rgDispId );
    
    return PrivateGetIDsOfNames( 
        riid,
        rgszNames,
        cNames,
        lcid,
        rgDispId );


}

STDMETHODIMP 
CBITSExtensionSetup::GetTypeInfo( 
    unsigned int iTInfo, 
    LCID lcid, 
    ITypeInfo FAR* FAR* ppTInfo )
{


   if ( m_OuterDispatch )
       return m_OuterDispatch->GetTypeInfo(
           iTInfo,
           lcid,
           ppTInfo );

   return 
       PrivateGetTypeInfo(
           iTInfo,
           lcid,
           ppTInfo );

}

STDMETHODIMP 
CBITSExtensionSetup::GetTypeInfoCount( 
    unsigned int FAR* pctinfo )
{

    if ( m_OuterDispatch )
        return m_OuterDispatch->GetTypeInfoCount( pctinfo );

    return PrivateGetTypeInfoCount( pctinfo );

}

STDMETHODIMP 
CBITSExtensionSetup::Invoke( 
    DISPID dispIdMember, 
    REFIID riid, 
    LCID lcid, 
    WORD wFlags, 
    DISPPARAMS FAR* pDispParams, 
    VARIANT FAR* pVarResult, 
    EXCEPINFO FAR* pExcepInfo, 
    unsigned int FAR* puArgErr )
{

    if ( m_OuterDispatch )
        return m_OuterDispatch->Invoke( 
            dispIdMember,
            riid,
            lcid,
            wFlags,
            pDispParams,
            pVarResult,
            pExcepInfo,
            puArgErr );


    return 
        PrivateInvoke( 
            dispIdMember,
            riid,
            lcid,
            wFlags,
            pDispParams,
            pVarResult,
            pExcepInfo,
            puArgErr );

}

HRESULT
CBITSExtensionSetup::ConnectToRemoteExtension()
{
    WCHAR *HostName                     = NULL;
    WCHAR *NewPath                      = NULL;
    BSTR NewPathBSTR                    = NULL;
    IBITSExtensionSetupFactory* Factory = NULL;

    try
    {

        // Extract out the host part of the path

        const SIZE_T PrefixSize = sizeof(L"IIS://")/sizeof(WCHAR) - 1;
        if ( _wcsnicmp( (WCHAR*)m_ADSIPath, L"IIS://", PrefixSize ) != 0 ) 
            throw ComError( E_INVALIDARG );

        WCHAR *HostNameStart = ((WCHAR*)m_ADSIPath) + PrefixSize;

        WCHAR *p = HostNameStart;

        while( L'/' != *p )
            {
            if ( L'\0' == *p )
                throw ComError( E_INVALIDARG );

			p++;
            }

        SIZE_T HostNameSize = (char*)p - (char*)HostNameStart + sizeof(L'\0');
        HostName = new WCHAR[ HostNameSize / sizeof(WCHAR) ];
        
        memcpy( HostName, HostNameStart, HostNameSize - sizeof(WCHAR) );
        HostName[ ( HostNameSize - sizeof(WCHAR) ) / sizeof(WCHAR) ] = L'\0';

        if ( L'\0' == *++p )
            throw ComError( E_INVALIDARG );

        SIZE_T NewPathSize = wcslen( L"IIS://LocalHost/" ) + wcslen( p ) + 1;
        NewPath = new WCHAR[ NewPathSize ];

        StringCchCopyW( NewPath, NewPathSize, L"IIS://LocalHost/" );
        StringCchCatW( NewPath, NewPathSize, p );

        NewPathBSTR = SysAllocString( NewPath );

        if ( !NewPathBSTR )
            throw ComError( E_OUTOFMEMORY );

        COSERVERINFO coinfo;
        coinfo.dwReserved1  = 0;
        coinfo.dwReserved2  = 0;
        coinfo.pAuthInfo    = NULL;
        coinfo.pwszName     = HostName;

        GUID guid = __uuidof( IBITSExtensionSetupFactory );
        MULTI_QI mqi;
        mqi.hr              = S_OK;
        mqi.pIID            = &guid;
        mqi.pItf            = NULL;

        THROW_COMERROR( 
            CoCreateInstanceEx(
                __uuidof(BITSExtensionSetupFactory),
                NULL,
                CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
                &coinfo,
                1,
                &mqi ) );
        THROW_COMERROR( mqi.hr );

        Factory     = (IBITSExtensionSetupFactory*)mqi.pItf;
        mqi.pItf    = NULL;

        THROW_COMERROR( Factory->GetObject( NewPathBSTR, &m_RemoteInterface ) );

        Factory->Release();

        SysFreeString( NewPathBSTR );
        delete[] NewPath;
        delete[] HostName;

        return S_OK;
    }
    catch( ComError Error )
    {
        SysFreeString( NewPathBSTR ); 
        delete[] HostName;
        delete[] NewPath;

        if ( Factory )
            Factory->Release();

        return Error.m_Hr;
    }


}

HRESULT CBITSExtensionSetup::LoadPath()
{
    if ( m_InitComplete )
        return S_OK;

    // Lock object
    while( InterlockedExchange( &m_Lock, 1 ) )
        Sleep( 0 );

    try
    {
        if ( !m_PropertyMan )
            {

            m_PropertyMan = new PropertyIDManager();
            HRESULT Hr = m_PropertyMan->LoadPropertyInfo();

            if ( FAILED(Hr) )
                {
                delete m_PropertyMan;
                m_PropertyMan = NULL;
                throw ComError( Hr );
                }

            }

        if ( !m_ADSIPath )
            {

            SmartIADsPointer ObjectADS;

            if ( m_pObject )
                THROW_COMERROR( 
                    m_pObject->QueryInterface( __uuidof(*ObjectADS), 
                                               (void**) ObjectADS.GetRecvPointer() ) );
            else
                THROW_COMERROR( 
                    m_pOuter->QueryInterface( __uuidof(*ObjectADS), 
                                              (void**) ObjectADS.GetRecvPointer() ) );

            THROW_COMERROR( ObjectADS->get_ADsPath( &m_ADSIPath ) );

            }


        if ( !m_Path && !m_RemoteInterface )
            {

            if ( _wcsnicmp( (WCHAR*)m_ADSIPath, L"IIS://LocalHost/", wcslen( L"IIS://LocalHost/" ) ) == 0 )
                {
                SIZE_T PathSize = wcslen( (WCHAR*)m_ADSIPath ) + 1; 
                m_Path = new WCHAR[ PathSize ]; 

                StringCchCopyW( m_Path, PathSize, L"/LM/" );
                StringCchCatW( m_Path, PathSize, reinterpret_cast<WCHAR*>( m_ADSIPath ) + wcslen( L"IIS://LocalHost/" ) );
                }

            else
                {
                THROW_COMERROR( ConnectToRemoteExtension( ) ); 
                }

            }

        m_InitComplete = true;
        // unlock 
        InterlockedExchange( &m_Lock, 0 );
        return S_OK;

    }
    catch( ComError Error )
    {
        InterlockedExchange( &m_Lock, 0 );
        return Error.m_Hr;
    }
}

STDMETHODIMP CBITSExtensionSetup::EnableBITSUploads()
{

    try
    {
        THROW_COMERROR( LoadPath() );

        if ( m_RemoteInterface )
            return m_RemoteInterface->EnableBITSUploads();

        SmartIMSAdminBasePointer AdminBase;

        THROW_COMERROR( 
            CoCreateInstance(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                AdminBase.GetUUID(),
                (LPVOID*)AdminBase.GetRecvPointer() ) );

        
        EnableBITSForVDIR( m_PropertyMan, AdminBase, m_Path );

        return S_OK;
    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }
}

STDMETHODIMP CBITSExtensionSetup::DisableBITSUploads()
{

    try
    {
        THROW_COMERROR( LoadPath() );

        if ( m_RemoteInterface )
            return m_RemoteInterface->DisableBITSUploads();

        SmartIMSAdminBasePointer AdminBase;

        THROW_COMERROR( 
            CoCreateInstance(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                AdminBase.GetUUID(),
                (LPVOID*)AdminBase.GetRecvPointer() ) );

        DisableBITSForVDIR( m_PropertyMan, AdminBase, m_Path, false, false );

        return S_OK;
    }
    catch( ComError Error )
    {
        return Error.m_Hr;
    }

}

STDMETHODIMP 
CBITSExtensionSetup::GetCleanupTaskName( BSTR *pTaskName )
{

    LPWSTR TaskName = NULL;

    try
    {

        *pTaskName = NULL;

        THROW_COMERROR( LoadPath() );

        if ( m_RemoteInterface )
            return m_RemoteInterface->GetCleanupTaskName( pTaskName );

        SmartIMSAdminBasePointer AdminBase;

        THROW_COMERROR( 
            CoCreateInstance(
                GETAdminBaseCLSID(TRUE),
                NULL,
                CLSCTX_SERVER,
                AdminBase.GetUUID(),
                (LPVOID*)AdminBase.GetRecvPointer() ) );

        FindWorkItemForVDIR( m_PropertyMan, AdminBase, m_Path, &TaskName );

        if ( TaskName ) 
            {

            *pTaskName = SysAllocString( TaskName );
            if ( !*pTaskName )
                throw ComError( E_OUTOFMEMORY );

            CoTaskMemFree( TaskName );
            TaskName = NULL;
        }
        return S_OK;

    }
    catch( ComError Error )
    {
        CoTaskMemFree( TaskName );
        return Error.m_Hr;
    }

}


STDMETHODIMP 
CBITSExtensionSetup::GetCleanupTask( 
    [in] REFIID riid, 
    [out,retval] IUnknown **ppUnk )
{

    HRESULT Hr = S_OK;
    SmartITaskSchedulerPointer TaskScheduler;
    BSTR ItemName                 = NULL;
    WCHAR *HostName               = NULL;
    
    if ( ppUnk )
        *ppUnk = NULL;

    try
    {

        THROW_COMERROR( LoadPath() );

        //
        // Build the taskscheduler form of the host name
        //
        
        const SIZE_T PrefixSize = sizeof(L"IIS://")/sizeof(WCHAR) - 1;
        if ( _wcsnicmp( (WCHAR*)m_ADSIPath, L"IIS://", PrefixSize ) != 0 ) 
            throw ComError( E_INVALIDARG );

        WCHAR *HostNameStart = ((WCHAR*)m_ADSIPath) + PrefixSize;
        WCHAR *p = HostNameStart;

        while( L'/' != *p )
            {
            if ( L'\0' == *p )
                throw ComError( E_INVALIDARG );

			p++;
            }

        SIZE_T HostNameSize = (char*)p - (char*)HostNameStart + sizeof(L'\0');
        HostName = new WCHAR[ ( HostNameSize / sizeof(WCHAR) ) + 2 ];

        HostName[0] = HostName[1] = L'\\';
        memcpy( HostName + 2, HostNameStart, HostNameSize - sizeof(WCHAR) );
        HostName[ ( ( HostNameSize - sizeof(WCHAR) ) / sizeof(WCHAR) ) + 2 ] = L'\0';

        if ( _wcsicmp( HostName, L"\\\\LocalHost" ) == 0 )
            {
            delete[] HostName;
            HostName = NULL;
            }

        ConnectToTaskScheduler( HostName, &TaskScheduler );
        THROW_COMERROR( GetCleanupTaskName( &ItemName ) );

        if ( ItemName )
            THROW_COMERROR( TaskScheduler->Activate( (LPCWSTR)ItemName, riid, ppUnk ) );
        else
            Hr = S_FALSE;

    }
    catch( ComError Error )
    {
        Hr = Error.m_Hr;
    }

    SysFreeString( ItemName ); 
    delete[] HostName;

    return Hr;

}


#include "bitssrvcfgimp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\guids.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    guids.h

Abstract :

    GUIDS

Author :

Revision History :

 ***********************************************************************/

// {4589A47E-6EC1-4476-BA77-CC9DD1125933}
DEFINE_GUID(CLSID_CPropSheetExtension, 
           0x4589a47e, 0x6ec1, 0x4476, 0xba, 0x77, 0xcc, 0x9d, 0xd1, 0x12, 0x59, 0x33);
// {210E66FB-B00B-4d16-9DE5-6E9241D58225}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x210e66fb, 0xb00b, 0x4d16, 0x9d, 0xe5, 0x6e, 0x92, 0x41, 0xd5, 0x82, 0x25);

// {A55E7D7F-D51C-4859-8D2D-E308625D908E}
DEFINE_GUID(CLSID_CBITSExtensionSetup, 
            0xa55e7d7f, 0xd51c, 0x4859, 0x8d, 0x2d, 0xe3, 0x8, 0x62, 0x5d, 0x90, 0x8e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\precomp.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Main header for BITS server extensions MMC snapin

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include <tchar.h>
#include <mmc.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include "bitssrvcfg.h"
#include <htmlhelp.h>
#include "bitscfg.h"
#include <activeds.h>
#include <iads.h>
#include <crtdbg.h>
#include <malloc.h>
#include <assert.h>
#include <mstask.h>
#include <shellapi.h>
#include <winnetwk.h>
#include <aclapi.h>

void * _cdecl ::operator new( size_t Size );
void _cdecl ::operator delete( void *Memory );

#include "smartptr.h"
    
typedef StringHandleW StringHandle;

#include "resource.h"
#include "guids.h"
#include "globals.h"
#include "registry.h"
#include "bitsext.h"

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_BITSMGR_DESC                2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  4
#define IDS_ABOUTNAME                   5
#define IDD_PROPPAGE_LARGE              6
#define IDS_BITS_EXT                    7
#define IDS_NEVER                       8
#define IDS_SECONDS                     9
#define IDS_MINUTES                     10
#define IDS_HOURS                       11
#define IDS_DAYS                        12
#define IDS_UNLIMITED                   13
#define IDS_BYTES                       14
#define IDS_KILOBYTES                   15
#define IDS_MEGABYTES                   16
#define IDS_GIGABYTES                   17
#define IDS_TERABYTES                   18
#define IDS_SESSION_TIMEOUT_INVALID     19
#define IDS_MAX_UPLOAD_INVALID          20
#define IDS_BITSMGR_PROVIDER            21
#define IDS_BITSMGR_VERSION_STR         22
#define IDS_NO_NOTIFICATION             23
#define IDS_BYREF_POST_NOTIFICATION     24
#define IDS_BYVAL_POST_NOTIFICATION     25
#define IDS_NOTIFICATION_URL_INVALID    26
#define IDI_BITSMGR                     27
#define IDS_CANT_LOAD_INHERITED_VALUES  27
#define IDB_SMALL                       28
#define IDS_CANT_SAVE_VALUES            28
#define IDB_LARGE                       29
#define IDS_CANT_LOAD_VALUES            29
#define IDC_CHECK_BITS_UPLOAD           30
#define IDS_CANT_CONNECT_TO_TASKSCHED   30
#define IDC_METABASE_PATH               31
#define IDS_CANT_START_CLEANUP          31
#define IDC_STATIC_SESSION_DIRECTORY    32
#define IDS_CANT_START_CLEANUP_SCHEDULE 32
#define IDC_STATIC_MAX_UPLOAD           33
#define IDS_WORK_ITEM_PROPERTY_PAGE_TITLE 33
#define IDC_STATIC_SESSION_TIMEOUT      34
#define IDS_WORK_ITEM_COMMENT           34
#define IDC_CHECK_SESSION_DIRECTORY_DEFAULT 35
#define IDS_HOST_ID_INVALID             35
#define IDC_EDIT_SESSION_DIRECTORY      36
#define IDS_FALLBACK_TIMEOUT_INVALID    36
#define IDC_EDIT_MAX_UPLOAD             37
#define IDS_CANT_ACCESS_METABASE        37
#define IDC_CHECK_MAX_UPLOAD_DEFAULT    38
#define IDS_ACCESS_PERMISSION_WARNING   38
#define IDC_EDIT_SESSION_TIMEOUT        39
#define IDC_CHECK_SESSION_TIMEOUT_DEFAULT 40
#define IDC_EDIT_FALLBACK_TIMEOUT       40
#define IDC_COMBO_SESSION_TIMEOUT_UNITS 41
#define IDC_COMBO_MAX_UPLOAD_UNITS      42
#define IDC_STATIC_NOTIFICATION_TYPE    43
#define IDC_COMBO_NOTIFICATION_TYPE     44
#define IDC_CHECK_NOTIFICATION_TYPE_DEFAULT 45
#define IDC_COMBO_FALLBACK_TIMEOUT_UNITS 45
#define IDC_STATIC_NOTIFICATION_URL     46
#define IDC_EDIT_NOTIFICATION_URL       47
#define IDC_RADIO_USE_INHERITED_CONFIG  48
#define IDC_RADIO_USE_CUSTOM_CONFIG     49
#define IDC_STATIC_NOTIFICATION         50
#define IDC_CHECK_LIMIT_MAX_UPLOAD      51
#define IDC_DELETE_FILES                52
#define IDC_BUTTON_CLEANUP_NOW          53
#define IDC_STATIC_CUSTOM_CONFIG        54
#define IDC_CHECK_ENABLE_NOTIFICATIONS  55
#define IDC_BUTTON_SCHEDULE_CLEANUP     56
#define IDC_EDIT_HOSTID                 57
#define IDC_STATIC_NOTIFICATION2        58
#define IDC_ENABLE_SERVER_FARM          59
#define IDC_STATIC_RECONNECT            60
#define IDC_CHECK_FALL                  61
#define IDC_CHECK_FALLBACK_TIMEOUT      61

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        57
#define _APS_NEXT_COMMAND_VALUE         40032
#define _APS_NEXT_CONTROL_VALUE         63
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server-setup\bitsrvc\bitsrvc.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <objbase.h>
#include <stdio.h>
#include <msiquery.h>

typedef HRESULT (*CallFunc)( void );

UINT RegisterDLL( MSIHANDLE hInstall, const char *DllName )
{

#if 0
    CHAR DbgMessage[ MAX_PATH ];
    sprintf( DbgMessage, "ProcessId %u, ThreadId %u", GetCurrentProcessId(), GetCurrentThreadId() );
    MessageBoxA( NULL, DbgMessage, NULL, MB_OK );
#endif

    ASSERT( MsiGetMode( hInstall, MSIRUNMODE_SCHEDULED ) ||
            MsiGetMode( hInstall, MSIRUNMODE_ROLLBACK ) );

    HRESULT CoInitHr;

    CoInitHr = CoInitialize( NULL );

    if ( FAILED( CoInitHr ) && ( RPC_E_CHANGED_MODE != CoInitHr ) )
        return (UINT)CoInitHr;

    HMODULE hModule     = NULL;
    HRESULT Hr          = S_OK;

    hModule = LoadLibrary( DllName );

    if ( !hModule )
        {
        Hr = HRESULT_FROM_WIN32( GetLastError() );
        goto exit;
        }


    CallFunc RegisterFunc = (CallFunc)GetProcAddress( hModule, "DllRegisterServer" );
    
    Hr = (*RegisterFunc)();

    FreeLibrary( hModule );
    hModule = NULL;

exit:

    if ( RPC_E_CHANGED_MODE != CoInitHr )
        CoUninitialize();
    
    SetLastError( Hr );
    return SUCCEEDED(Hr) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;

}

UINT UnregisterDLL( MSIHANDLE hInstall, char *DllName )
{

    ASSERT( MsiGetMode( hInstall, MSIRUNMODE_SCHEDULED ) ||
            MsiGetMode( hInstall, MSIRUNMODE_ROLLBACK ) );

    HRESULT CoInitHr;

    CoInitHr = CoInitialize( NULL );

    if ( FAILED( CoInitHr ) && ( RPC_E_CHANGED_MODE != CoInitHr ) )
        return (UINT)CoInitHr;

    HMODULE hModule     = NULL;
    HRESULT Hr          = S_OK;


    hModule = LoadLibrary( DllName );

    if ( !hModule )
        {
        DbgPrint( "Unable to load %s, error 0x%8.8X", DllName, GetLastError() );
        }
    else
        {

        CallFunc RegisterFunc = (CallFunc)GetProcAddress( hModule, "DllUnregisterServer" );

        if ( !RegisterFunc )
            {
            DbgPrint( "Unable to load %s!DllRegisterServer, error 0x%8.8X", DllName, GetLastError() );
            }
        else
            {

            Hr = (*RegisterFunc)();

            FreeLibrary( hModule );
            hModule = NULL;

            if ( FAILED( Hr ) )
                goto exit;

            }

        }
    
    FreeLibrary( hModule );
    hModule = NULL;

exit:

    if ( RPC_E_CHANGED_MODE == CoInitHr )
        return Hr;

    CoUninitialize();
    return SUCCEEDED(Hr) ? ERROR_SUCCESS : ERROR_INSTALL_FAILURE;

}

UINT DllInstallBITSMgr( MSIHANDLE hInstall )
{
    return RegisterDLL( hInstall, "bitsmgr.dll" );
}

UINT DllUninstallBITSMgr( MSIHANDLE hInstall )
{
    return UnregisterDLL( hInstall, "bitsmgr.dll" );
}

UINT DllInstallBITSIsapi( MSIHANDLE hInstall )
{
    return RegisterDLL( hInstall, "bitssrv.dll" );
}

UINT DllUninstallBITSIsapi( MSIHANDLE hInstall )
{
    return UnregisterDLL( hInstall, "bitssrv.dll" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\registry.cpp ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    registry.cpp

Abstract :

    Handles registering and unregistering the snapin.

Author :

Revision History :

 ***********************************************************************/

#include "precomp.h"
#include "sddl.h"

// if not standalone comment out next line
//#define STANDALONE

// list all nodes that are extendable here
// List the GUID and then the description
// terminate with a NULL, NULL set.
EXTENSION_NODE _ExtendableNodes[] = {
    {NULL, NULL}
};

// list all of the nodes that we extend
EXTENDER_NODE _NodeExtensions[] = {

    // IIS instance node
    {PropertySheetExtension,
    {0xa841b6c7, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}}, //g_IISInstanceNode,
    {0x4589a47e, 0x6ec1, 0x4476, {0xba, 0x77, 0xcc, 0x9d, 0xd1, 0x12, 0x59, 0x33}},
    _T("BITS server MMC extension")},

    // IIS child node
    {PropertySheetExtension,
    {0xa841b6c8, 0x7577, 0x11d0, {0xbb, 0x1f, 0x00, 0xa0, 0xc9, 0x22, 0xe7, 0x9c}}, // g_IISChildNode,
    {0x4589a47e, 0x6ec1, 0x4476, {0xba, 0x77, 0xcc, 0x9d, 0xd1, 0x12, 0x59, 0x33}},
    _T("BITS server MMC extension")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

BOOL setBinaryValue(
              const _TCHAR* szKey,
              const _TCHAR* szValueName,
              void * Data,
              ULONG DataSize );


BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

#if defined( UNICODE ) || defined( _UNICODE )
const DWORD MAX_GUID_CHARS = 50;
#else
const DWORD MAX_GUID_CHARS = 50 * 8; // worst encoding
#endif

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//

#if defined ( UNICODE ) || defined( _UNICODE )

HRESULT
StringFromGUIDInternal(
    const CLSID& clsid,
    _TCHAR * szGuidString
     )
{

    return StringFromGUID2( clsid, szGuidString, MAX_GUID_CHARS );

}

#else
#error Provide a unicode to DBCS thunk version
#endif

HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName,
                       const _TCHAR* ThreadingModel,
                       bool  Remoteable,
                       const _TCHAR* SecurityString )       //   IDs
{
    // Get server location.
    _TCHAR szModule[512];
    DWORD  dwLen = sizeof(szModule)/sizeof(_TCHAR);

    DWORD dwResult = GetModuleFileName(hModule,
                                       szModule,
                                       dwLen - 1) ;

    if ( !dwResult )
        {
        assert(dwResult != 0) ;
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    szModule[dwLen-1] = 0;

    // Get CLSID
    _TCHAR szCLSID[ MAX_GUID_CHARS ];
    HRESULT Hr = StringFromGUIDInternal( clsid, szCLSID );

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    StringCchCopy(szKey, ARRAY_ELEMENTS( szKey ), _T("CLSID\\")) ;
    StringCchCat(szKey, ARRAY_ELEMENTS(szKey), szCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    if ( Remoteable )
        setValue( szKey, _T("AppID"), szCLSID );

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    StringCchCat(szKey, ARRAY_ELEMENTS(szKey), _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), ThreadingModel);


    if ( Remoteable )
        {
        
        PSECURITY_DESCRIPTOR  SecurityDescriptor = NULL;
        ULONG   DescriptorSize;

        // build the key name  
        StringCchCopy(szKey, ARRAY_ELEMENTS(szKey), _T("AppId\\")) ;
        StringCchCat(szKey, ARRAY_ELEMENTS(szKey), szCLSID) ;

        setKeyAndValue(szKey, NULL, szFriendlyName) ;
        setValue(szKey, _T("DllSurrogate"), _T("") );

        if ( !ConvertStringSecurityDescriptorToSecurityDescriptor(
            SecurityString,
            SDDL_REVISION_1,
            &SecurityDescriptor,
            &DescriptorSize
            ) )
            return HRESULT_FROM_WIN32( GetLastError() );

        setBinaryValue( szKey, _T("LaunchPermission"), SecurityDescriptor, DescriptorSize );
        setBinaryValue( szKey, _T("AccessPermission"), SecurityDescriptor, DescriptorSize );

        LocalFree( (HLOCAL)SecurityDescriptor );

        }

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    _TCHAR szCLSID[ MAX_GUID_CHARS ];
    HRESULT Hr = StringFromGUIDInternal( clsid, szCLSID );

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    StringCchCopy( szKey, ARRAY_ELEMENTS(szKey), _T("CLSID\\") );
    StringCchCat( szKey, ARRAY_ELEMENTS(szKey), szCLSID );

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    StringCchCopy(szKey, ARRAY_ELEMENTS(szKey), _T("AppId\\"));
    StringCchCat(szKey, ARRAY_ELEMENTS(szKey), szCLSID );
    lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey); 

    return S_OK;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout)         // Class Id for About Class

{
    // Get CLSID
    _TCHAR szCLSID[ MAX_GUID_CHARS ];
    _TCHAR szAboutCLSID[ MAX_GUID_CHARS ];

    EXTENSION_NODE *pExtensionNode;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;

    HRESULT Hr = StringFromGUIDInternal(clsid, szCLSID);

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    if (IID_NULL != clsidAbout)
        Hr = StringFromGUIDInternal(clsidAbout, szAboutCLSID);

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    // Add the CLSID to the registry.
    setSnapInKeyAndValue(szCLSID, NULL, _T("NameString"), szNameString) ;

#ifdef STANDALONE
    setSnapInKeyAndValue(szCLSID, _T("StandAlone"), NULL, NULL);
#endif

    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(szCLSID, NULL, _T("About"), szAboutCLSID);

    // register each of the node types in _ExtendableNodes as an extendable node
    for (pExtensionNode = &(_ExtendableNodes[0]);*pExtensionNode->szDescription;pExtensionNode++)
    {
        _TCHAR szExtendCLSID[ MAX_GUID_CHARS ];
        Hr = StringFromGUIDInternal(pExtensionNode->GUID, szExtendCLSID);

        if ( FAILED( Hr ) )
            {
            assert( 0 );
            return Hr;
            }

        setSnapInExtensionNode(szCLSID, szExtendCLSID, pExtensionNode->szDescription);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {

        _TCHAR szExtendCLSID[ MAX_GUID_CHARS ];

        Hr = StringFromGUIDInternal(pNodeExtension->guidNode, szExtendCLSID);

        if ( FAILED( Hr ) )
            {
            assert(0);
            return Hr;
            }

        StringCchCopy(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf), szExtendCLSID);

        switch (pNodeExtension->eType) {
        case NameSpaceExtension:
            StringCchCat( szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\Extensions\\NameSpace") );
            break;
        case ContextMenuExtension:
            StringCchCat( szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\Extensions\\ContextMenu") );
            break;
        case ToolBarExtension:
            StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\Extensions\\ToolBar"));
            break;
        case PropertySheetExtension:
            StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\Extensions\\PropertySheet"));
            break;
        case TaskExtension:
            StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\Extensions\\Task"));
            break;
        case DynamicExtension:
            StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\Dynamic Extensions"));
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        _TCHAR szNodeCLSID[ MAX_GUID_CHARS ];
        Hr = StringFromGUIDInternal(pNodeExtension->guidExtension, szNodeCLSID);
        
        if ( FAILED(Hr) )
            {
            assert( 0 );
            return Hr;
            }
        
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, szNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey);

    }

    return S_OK;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    _TCHAR szCLSID[ MAX_GUID_CHARS ];

    // Get CLSID
    HRESULT Hr = StringFromGUIDInternal(clsid, szCLSID);

    if ( FAILED( Hr ) )
        {
        assert( 0 );
        return Hr;
        }

    // Load the buffer with the Snap-In Location
    StringCchCopy(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\"));
    StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    StringCchCopy(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\")) ;
        StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    StringCchCopy(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setBinaryValue(
              const _TCHAR* szKey,
              const _TCHAR* szValueName,
              void * Data,
              ULONG DataSize )
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    StringCchCopy(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    RegSetValueEx(hKey, szValueName, 0, REG_BINARY,
        (BYTE *)Data,
        DataSize ) ;

    RegCloseKey(hKey) ;
    return TRUE ;
}


//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    StringCchCopy(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\")) ;
    StringCchCat(szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        StringCchCat( szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), _T("\\") ) ;
        StringCchCat( szKeyBuf, ARRAY_ELEMENTS( szKeyBuf ), szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription)
{
    HKEY hKey;
    _TCHAR szSnapNodeKeyBuf[1024] ;
    _TCHAR szMMCNodeKeyBuf[1024];

    // Load the buffer with the Snap-In Location
    StringCchCopy(szSnapNodeKeyBuf, ARRAY_ELEMENTS(szSnapNodeKeyBuf), 
                  _T("SOFTWARE\\Microsoft\\MMC\\SnapIns\\"));
    // add in the clisid into buffer.
    StringCchCat(szSnapNodeKeyBuf, ARRAY_ELEMENTS(szSnapNodeKeyBuf), szSnapID) ;
    StringCchCat(szSnapNodeKeyBuf, ARRAY_ELEMENTS(szSnapNodeKeyBuf), _T("\\NodeTypes\\"));
    StringCchCat(szSnapNodeKeyBuf, ARRAY_ELEMENTS(szSnapNodeKeyBuf), szNodeID) ;

    // Load the buffer with the NodeTypes Location
    StringCchCopy(szMMCNodeKeyBuf, ARRAY_ELEMENTS( szMMCNodeKeyBuf ), 
                  _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
    StringCchCat(szMMCNodeKeyBuf, ARRAY_ELEMENTS( szMMCNodeKeyBuf ), szNodeID) ;

    // Create and open the Snapin Key.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szSnapNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    // Create and open the NodeTypes Key.
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szMMCNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\service\dload.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    dload.c

Abstract:

    This file implements delay-load error handling for QMGR.DLL

--*/

#include "qmgrlib.h"
#include <delayimp.h>
#include "dload.tmh"

FARPROC
WINAPI
BITS_DelayLoadFailureHook(
    UINT unReason,
    PDelayLoadInfo pDelayInfo
    )
/*
        DANGER  DANGER  DANGER


    Normally a delayload handler provides a thunk for each import, each
    of which returns an appropriate error code.

    This implementation DOES NOT provide the usual thunks, because VSSAPI.DLL
    exports mangled C++ functions including an object constructor. There is
    no good way to mimic the member function calling convention using C-style
    pointers to functions.

    We wouldn't even bother with delayload, except that this code must work on Win2000
    which does not have VSSAPI.DLL.  So the manager code must verify that LoadLibrary
    succeeds before making any calls that could result in a call to the delay-loaded
    functions.

*/
{
    // For a failed LoadLibrary, we return a bogus HMODULE of -1 to force
    // DLOAD call again with dliFailGetProc

    LogError("delayload handler called: reason %d", unReason);

    if (dliFailLoadLib == unReason)
        {
        ASSERT( 0 );
        return (FARPROC)-1;
        }

    if (dliFailGetProc == unReason)
        {
        // The loader is asking us to return a pointer to a procedure.

        LogError("DLL: %s, proc: %s", pDelayInfo->szDll, pDelayInfo->dlp.szProcName);

        ASSERT( 0 );
        return NULL;
        }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\service\memory.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    memory.cxx

Abstract:

    This file contains the new and delete routines for memory management in
    the Bits runtime.  Rather than using the memory management provided by the
    C++ system we'll use the system allocator.

Revision History:

    mikemon    ??-??-??    Beginning of time (at least for this file).
    mikemon    12-31-90    Upgraded the comments.
    mariogo    04-24-96    Rewrite to unify platforms, behavior and performance.

--*/

#include <qmgrlib.h>

#if !defined(BITS_V12_ON_NT4)
#include <memory.tmh>
#endif

HANDLE hBitsHeap = 0;
unsigned int DebugFlags = 0;

#define  NO_HEAP_SLOWDOWN


///////////////////////////////////////////////////////////////////////////
//
//  Default allocators
//
///////////////////////////////////////////////////////////////////////////

#if !defined(DBG)

void * _cdecl operator new(size_t nSize)
{
    void *pNewMemory = HeapAlloc( hBitsHeap, 0, nSize );

    if ( !pNewMemory )
        {
        LogError( "Unable to allocate memory block of size, %X\n", nSize );
        throw ComError( E_OUTOFMEMORY );
        }

    return pNewMemory;
}

void _cdecl operator delete(void *pMemory)
{
    if (!pMemory)
        return;

    if (!HeapFree( hBitsHeap, 0, pMemory ))
        {
        LogError( "Error occured freeing memory at %p, error %!winerr!\n",
                  pMemory, GetLastError() );
        }
}

int fHeapInitialized = 0;

int InitializeBitsAllocator(void)
{
#if 1

    if (0 == fHeapInitialized)
        {
        if (0 == hBitsHeap)
            {
            hBitsHeap = RtlCreateHeap(  HEAP_GROWABLE
                                     | HEAP_FREE_CHECKING_ENABLED
                                     | HEAP_CLASS_1,
                                     0,
                                     16 * 1024 - 512,
                                     0,
                                     0,
                                     0
                                     );
            }

        if (hBitsHeap)
            {
            fHeapInitialized = 1;
            }

        if (0 == fHeapInitialized )
            {
            return(ERROR_NOT_ENOUGH_MEMORY);
            }
        }

    return(0);


#else

    hBitsHeap = RtlProcessHeap();

    return(0);

#endif
}

int
BitspCheckHeap (
    void
    )
// Allow some checked compenents to be linked into a free memory.cxx.
{
    return 0;
}


#else // ******************** DEBUG ********************

#ifdef NO_HEAP_SLOWDOWN
int fMemoryCheck = 0;
#else
int fMemoryCheck = 1;
#endif

int fHeapInitialized = 0;

CRITICAL_SECTION BitsHeapLock;

typedef NTSYSAPI
USHORT
(NTAPI RTLCAPTURESTACKBACKTRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash OPTIONAL
   );

typedef RTLCAPTURESTACKBACKTRACE * PRTLCAPTURESTACKBACKTRACE;

PRTLCAPTURESTACKBACKTRACE g_RtlCaptureStackBackTrace;

int InitializeBitsAllocator(void)
/*++

Routine Description:

    Called during Bits initialization. This function must can by one
    thread at a time.  Sets the heap handle for debugging.

    Maybe called more then once if this (or a later step) of Bits
    initialization fails.

--*/
{
    if (0 == fHeapInitialized)
        {
        if (0 == hBitsHeap)
            {
            hBitsHeap = RtlCreateHeap(  HEAP_GROWABLE
                                     | HEAP_TAIL_CHECKING_ENABLED
                                     | HEAP_FREE_CHECKING_ENABLED
                                     | HEAP_CLASS_1,
                                     0,
                                     16 * 1024 - 512,
                                     0,
                                     0,
                                     0
                                     );
            }

        if (hBitsHeap)
            {
            if (0 == RtlInitializeCriticalSection(&BitsHeapLock))
                {
                fHeapInitialized = 1;
                }
            }

        if (0 == fHeapInitialized )
            {
            return(ERROR_NOT_ENOUGH_MEMORY);
            }

        HMODULE hModule = GetModuleHandle( L"kernel32" );
        if (hModule)
            {
            g_RtlCaptureStackBackTrace = (PRTLCAPTURESTACKBACKTRACE) GetProcAddress( hModule, "RtlCaptureStackBacktrace" );

            // ignore error, because it's just a debugging aid and is not available in Win2000
            }
        }

    return(0);
}

#define Bits_GUARD 0xA1

typedef struct _Bits_MEMORY_BLOCK
{
    // First,forward and backward links to other Bits heap allocations.
    // These are first allow easy debugging with the dl command
    struct _Bits_MEMORY_BLOCK *next;
    struct _Bits_MEMORY_BLOCK *previous;

    // Specifies the size of the block of memory in bytes.
    unsigned long size;

    // Thread id of allocator
    unsigned long tid;

    void *          AllocStackTrace[4];

    // (Pad to make header 0 mod 8) 0 when allocated, 0xF0F0F0F0 when freed.
    unsigned long free;

    // Reserve an extra 4 bytes as the front guard of each block.
    unsigned char frontguard[4];

    // Data will appear here.  Note that the header must be 0 mod 8.

    // Reserve an extra 4 bytes as the rear guard of each block.
    unsigned char rearguard[4];

} Bits_MEMORY_BLOCK;

//
// Compile-time test to ensure that Bits_MEMORY_BLOCK.rearguard is aligned on
// natural boundary.
//

#if defined(_WIN64)
C_ASSERT( (FIELD_OFFSET( Bits_MEMORY_BLOCK, rearguard ) % 16) == 0 );
#else
C_ASSERT( (FIELD_OFFSET( Bits_MEMORY_BLOCK, rearguard ) % 8) == 0 );
#endif

Bits_MEMORY_BLOCK * AllocatedBlocks = 0;
unsigned long BlockCount = 0;

int
CheckMemoryBlock (
    Bits_MEMORY_BLOCK * block
    )
{
    if (   block->frontguard[0] != Bits_GUARD
        || block->frontguard[1] != Bits_GUARD
        || block->frontguard[2] != Bits_GUARD
        || block->frontguard[3] != Bits_GUARD )
        {
        LogError("BAD BLOCK (front) @ %p\n", block);
        ASSERT(0);
        return(1);
        }

    if (   block->rearguard[block->size]   != Bits_GUARD
        || block->rearguard[block->size+1] != Bits_GUARD
        || block->rearguard[block->size+2] != Bits_GUARD
        || block->rearguard[block->size+3] != Bits_GUARD )
        {
        LogError("BAD BLOCK (rear) @ %p (%p)\n",block, &block->rearguard[block->size]);
        ASSERT(0);
        return(1);
        }

    ASSERT(block->free == 0);

    if ( block->next != 0)
       {
       ASSERT(block->next->previous == block);
       }

    if ( block->previous != 0)
       {
       ASSERT(block->previous->next == block);
       }

    return(0);
}

int
BitsValidateHeapList(
    void
    )
// Called with BitsHeapLock held.
{
    Bits_MEMORY_BLOCK * block;
    unsigned Blocks = 0;

    // Under stress this check causes performance to drop too much.
    // Compile with -DNO_HEAP_SLOWDOWN or ed the flag in memory
    // to speed things up.

    if (fMemoryCheck == 0)
        {
        return(0);
        }

    block = AllocatedBlocks;

    while (block != 0)
        {
        if (CheckMemoryBlock(block))
            {
            return(1);
            }
        block = block->next;
        Blocks++;
        }

    ASSERT(Blocks == BlockCount);

    return(0);
}

int
BitspCheckHeap (
    void
    )
// Returns 0 if the heap appears to be okay.
{
    if (fMemoryCheck == 0)
        {
        return(0);
        }

    EnterCriticalSection(&BitsHeapLock);

    int ret = BitsValidateHeapList();

    LeaveCriticalSection(&BitsHeapLock);

    return(ret);
}

void * __cdecl
operator new(
    size_t size
    )
{
    Bits_MEMORY_BLOCK * block;

    EnterCriticalSection(&BitsHeapLock);

    ASSERT( ("You allocated a negative amount",
            size < (size + sizeof(Bits_MEMORY_BLOCK))) );

    BitsValidateHeapList();

    block = (Bits_MEMORY_BLOCK *) HeapAlloc( hBitsHeap, 0, size + sizeof(Bits_MEMORY_BLOCK));
    if ( block == 0 )
        {
        LeaveCriticalSection(&BitsHeapLock);

        LogError( "Unable to allocate memory block of size %X\n", size );
        throw ComError( E_OUTOFMEMORY );
        }

    block->size = size;
    block->tid = GetCurrentThreadId();
    block->free = 0;

    if (AllocatedBlocks != 0)
        AllocatedBlocks->previous = block;

    block->next = AllocatedBlocks;
    block->previous = 0;
    AllocatedBlocks = block;
    BlockCount++;

    block->frontguard[0] = Bits_GUARD;
    block->frontguard[1] = Bits_GUARD;
    block->frontguard[2] = Bits_GUARD;
    block->frontguard[3] = Bits_GUARD;

    #if i386

    if (g_RtlCaptureStackBackTrace)
        {
        ULONG ignore;

        g_RtlCaptureStackBackTrace(
                                 2,
                                 4,
                                 (void **) &block->AllocStackTrace,
                                 &ignore);
        }
    #endif


    block->rearguard[size]   = Bits_GUARD;
    block->rearguard[size+1] = Bits_GUARD;
    block->rearguard[size+2] = Bits_GUARD;
    block->rearguard[size+3] = Bits_GUARD;

    LeaveCriticalSection(&BitsHeapLock);

    return(&(block->rearguard[0]));
}

void __cdecl
operator delete (
    IN void * obj
    )
{
    Bits_MEMORY_BLOCK * block;

    if (obj == 0)
        return;

    EnterCriticalSection(&BitsHeapLock);

    block = (Bits_MEMORY_BLOCK *) (((unsigned char *) obj)
                    - FIELD_OFFSET(Bits_MEMORY_BLOCK, rearguard));

    // Validate block being freed.

    CheckMemoryBlock(block);

    if (block->next != 0)
        {
        CheckMemoryBlock(block->next);
        }

    if (block->previous != 0)
        {
        CheckMemoryBlock(block->previous);
        }

    // Remove the block from the list

    if (block == AllocatedBlocks)
        AllocatedBlocks = block->next;

    if (block->next != 0)
        block->next->previous = block->previous;

    if (block->previous != 0)
        block->previous->next = block->next;

    // Mark this block as free
    block->free = 0xF0F0F0F0;

    // Validate other Bits allocations.
    BlockCount-- ;
    BitsValidateHeapList();

    LeaveCriticalSection(&BitsHeapLock);

    if (!HeapFree( hBitsHeap, 0, block ))
        {
        LogError( "Error occured freeing memory at %p, error %!winerr!\n",
                  block, GetLastError() );
        }
}

#endif // not debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\server\mmcexts\registry.h ===
/************************************************************************

Copyright (c) 2001 Microsoft Corporation

Module Name :

    registry.h

Abstract :

    GUIDS

Author :

Revision History :

 ***********************************************************************/


#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
        DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName,
                       const _TCHAR* szThreadingModel = _T("Apartment"),
                       bool Remoteable = false,
                       const _TCHAR* SecurityString = NULL ) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout);		// Class Id for About Class


HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\service\service.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    service.cxx

Abstract:

    Process init and service controller interaction

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo    06-14-95    Cloned RPCSS from the old endpoint mapper.
    jroberts   06-29-00    Cloned BITS from RPCSS
--*/

#include "qmgrlib.h"
#include "trust.h"

#include "service.tmh"

//
// This #define allows BITS to load an unsigned replacement qmgr.dll when the appropriate regkey is set.
// Without the #define, BITS only loads certs signed by a Microsoft root authority.
//
// #define ENABLE_TEST_DLL

#define SERVICE_NAME _T("BITS")
#define DEVICE_PREFIX   _T("\\\\.\\")

VOID WINAPI ServiceMain(DWORD, LPTSTR*);
VOID UpdateState(DWORD dwNewState);

extern BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
);

// Array of service status blocks and pointers to service control
// functions for each component service.

SERVICE_TABLE_ENTRY gaServiceEntryTable[] = {
    { SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
    { NULL, NULL }
    };

HINSTANCE g_hInstance;

SERVICE_STATUS        gServiceStatus;
SERVICE_STATUS_HANDLE ghServiceHandle;

// This event is set when we receive a SERVICE_CONTROL_STOP/SHUTDOWN
HANDLE g_hServiceStopEvent = NULL;

typedef SERVICE_STATUS_HANDLE (*PREGISTER_FUNC)(
    LPCTSTR lpServiceName,
    LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext );

typedef VOID (*PSERVICE_MAIN_FUNC)(
    DWORD argc,
    LPTSTR *lpszArgv,
    PREGISTER_FUNC RegisterFunc );

extern "C"
VOID
BITSServiceMain(
    DWORD argc,
    LPTSTR *argv,
    PREGISTER_FUNC lpRegisterFunc
    );


BOOL
GetModuleVersion64(
    HMODULE hDll,
    ULONG64 * pVer
    );

BOOL
GetFileVersion64(
    LPTSTR      szFullPath,
    ULONG64 *   pVer
    );

LPHANDLER_FUNCTION_EX g_RealHandler = NULL;
HINSTANCE g_RealLibrary = NULL;
LONG g_RealLibraryRefs = 0;

ULONG
ServiceHandlerThunk(
    DWORD dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData )
{
    InterlockedIncrement( &g_RealLibraryRefs );

    ULONG Result =
        g_RealHandler( dwCode, dwEventType, EventData, pData );

    if (!InterlockedDecrement( &g_RealLibraryRefs ) )
        {
        FreeLibrary( g_RealLibrary );
        g_RealLibrary = NULL;
        }

    return Result;
}

SERVICE_STATUS_HANDLE
RegisterServiceHandlerThunk(
    LPCTSTR lpServiceName,
    LPHANDLER_FUNCTION_EX lpHandlerProc,
    LPVOID lpContext )
{
    g_RealHandler = lpHandlerProc;

    return
    RegisterServiceCtrlHandlerEx( lpServiceName,
                                  ServiceHandlerThunk,
                                  lpContext
                                  );
}

bool
JumpToRealDLL(
    DWORD argc,
    LPTSTR *argv )
{
    #define MAX_DLLNAME (MAX_PATH+1)

    HKEY BitsKey = NULL;
    bool bAllowTestBinaries = false;

    LONG Result =
        RegOpenKey( HKEY_LOCAL_MACHINE, C_QMGR_REG_KEY, &BitsKey );

    if ( Result )
        goto noload;

    //
    // Read the key naming an override DLL.
    //
    static TCHAR DLLName[MAX_DLLNAME];
    DWORD Type;
    DWORD NameSize = sizeof(DLLName);

    Result = RegQueryValueEx(
        BitsKey,
        C_QMGR_SERVICEDLL,
        NULL,
        &Type,
        (LPBYTE)DLLName,
        &NameSize );

    if ( Result ||
         (( Type != REG_SZ ) && (Type != REG_EXPAND_SZ)) )
        {
        goto noload;
        }

    if (Type == REG_EXPAND_SZ)
        {
        static TCHAR ExpandedDLLName[MAX_DLLNAME];

        DWORD size = ExpandEnvironmentStrings( DLLName, ExpandedDLLName, MAX_DLLNAME );

        if (size == 0)
            {
            // out of resources
            return true;
            }

        HRESULT hr;
        hr = StringCchCopy( DLLName, RTL_NUMBER_OF(DLLName), ExpandedDLLName );
        if (FAILED(hr))
            {
            // too long; must be badly formatted.  Ignore it.
            goto noload;
            }
        }

#ifdef ENABLE_TEST_DLL

    //
    // Read the key that controls whether to allow test-signed binaries.
    //
    {
    DWORD b;
    DWORD Size = sizeof(b);
    DWORD Type;

    Result = RegQueryValueEx(
        BitsKey,
        C_QMGR_ALLOW_TEST_DLL,
        NULL,
        &Type,
        (LPBYTE)&b,
        &Size );

    if ( (Result ==0) && ( Type == REG_DWORD ) && (b == 1))
        {
        bAllowTestBinaries = true;
        }
    }

#endif

    RegCloseKey( BitsKey );
    BitsKey = NULL;

    //
    // At this point, we know that the registry specifies an alternate DLL.
    // See whether it has a later version than the current one.
    //
    ULONG64 AlternateDllVersion = 0;
    ULONG64 MyDllVersion = 0;

    if (!QMgrFileExists( DLLName ))
        {
        goto noload;
        }

    if (!GetFileVersion64( DLLName, &AlternateDllVersion ))
        {
        // can't ascertain the version.  Don't start the service at all.
        return true;
        }

    if (!GetModuleVersion64( g_hInstance, &MyDllVersion ))
        {
        // can't ascertain the version.  Don't start the service at all.
        return true;
        }

    if (MyDllVersion >= AlternateDllVersion)
        {
        goto noload;
        }

    if (!bAllowTestBinaries)
        {
        //
        // Verify that the file is signed with a Microsoft certificate, using the default cert list and checking the CRL.
        //
        if (FAILED(VerifyFileTrust( DLLName, NULL, TRUE )))
            {
            goto noload;
            }
        }

    //
    // The file appears valid; load it and call BitsServiceMain.
    //
    g_RealLibrary = LoadLibrary( DLLName );

    if ( !g_RealLibrary )
        goto noload;

    PSERVICE_MAIN_FUNC ServiceMainFunc =
        (PSERVICE_MAIN_FUNC)GetProcAddress( g_RealLibrary, "BITSServiceMain" );

    if ( !ServiceMainFunc )
        goto noload;

    g_RealLibraryRefs = 1;

    // Ok to call into real library now.

    ( *ServiceMainFunc ) ( argc, argv, RegisterServiceHandlerThunk );

    if (!InterlockedDecrement( &g_RealLibraryRefs ) )
        {
        FreeLibrary( g_RealLibrary );
        g_RealLibrary = NULL;
        }

    return true;

noload:
    if ( BitsKey )
        RegCloseKey( BitsKey );
    if ( g_RealLibrary )
        FreeLibrary( g_RealLibrary );
    return false;
}

VOID WINAPI
ServiceMain(
    DWORD argc,
    LPTSTR *argv
    )
/*++

Routine Description:

    Callback by the service controller when starting this service.

Arguments:

    argc - number of arguments, usually 1

    argv - argv[0] is the name of the service.
           argv[>0] are arguments passed to the service.

Return Value:

    None

--*/
{

    volatile static LONG ThreadRunning = 0;

    if ( InterlockedCompareExchange( &ThreadRunning, 1, 0 ) == 1 )
        {

        // A thread is already running ServiceMain, just exit.
        // The service controller has a bug where it can create multiple
        // threads to call ServiceMain in high stress conditions.

        return;
        }


    if (!JumpToRealDLL( argc, argv) )
        {

        BITSServiceMain(
            argc,
            argv,
            RegisterServiceCtrlHandlerEx );

        }

    ThreadRunning = 0;

}

DWORD g_LastServiceControl;


ULONG WINAPI
BITSServiceHandler(
    DWORD   dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData
    )
/*++

Routine Description:

    Lowest level callback from the service controller to
    cause this service to change our status.  (stop, start, pause, etc).

Arguments:

    opCode - One of the service "Controls" value.
            SERVICE_CONTROL_{STOP, PAUSE, CONTINUE, INTERROGATE, SHUTDOWN}.

Return Value:

    None

--*/
{
    switch(dwCode)
        {
        case SERVICE_CONTROL_STOP:
            {
            LogService( "STOP request" );

            //
            // only relevant in running state; damaging if we are stopping
            // and g_hServiceStopEvent is deleted.
            //
            if (gServiceStatus.dwCurrentState == SERVICE_RUNNING)
                {
                g_LastServiceControl = dwCode;

                UpdateState( SERVICE_STOP_PENDING );
                SetEvent( g_hServiceStopEvent );
                }

            break;
            }

        case SERVICE_CONTROL_INTERROGATE:
            // Service controller wants us to call SetServiceStatus.

            LogService( "INTERROGATE request" );
            UpdateState(gServiceStatus.dwCurrentState);
            break ;

        case SERVICE_CONTROL_SHUTDOWN:
            // The machine is shutting down.  We'll be killed once we return.

            LogService( "SHUTDOWN request" );

            g_LastServiceControl = dwCode;

            UpdateState( SERVICE_STOP_PENDING );
            SetEvent( g_hServiceStopEvent );

            while (gServiceStatus.dwCurrentState == SERVICE_STOP_PENDING)
                {
                LogService( "service pending; sleeping..." );
                Sleep(100);
                }
            break;

        case SERVICE_CONTROL_DEVICEEVENT:
            {
            if (gServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ||
                gServiceStatus.dwCurrentState == SERVICE_STOPPED)
                {
                LogService("ignoring device event due to service shutdown" );
                break;
                }

            return DeviceEventCallback( dwEventType, EventData );
            }

        case SERVICE_CONTROL_SESSIONCHANGE:
            {
            WTSSESSION_NOTIFICATION* pswtsi = (WTSSESSION_NOTIFICATION*) EventData;
            DWORD dwSessionId = pswtsi->dwSessionId;

            if (gServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ||
                gServiceStatus.dwCurrentState == SERVICE_STOPPED)
                {
                LogService("ignoring session change for session %d due to service shutdown", dwSessionId );
                break;
                }

            switch (dwEventType)
                {
                case WTS_SESSION_LOGON:
                    {
                    LogService("logon at session %d", dwSessionId);

                    SessionLogonCallback( dwSessionId );
                    break;
                    }

                case WTS_SESSION_LOGOFF:
                    {
                    LogService("logoff at session %d", dwSessionId);

                    SessionLogoffCallback( dwSessionId );
                    break;
                    }

                default:    //Is there a default?
                    break;
                }

            break;
            }

        default:
            LogError( "%!ts!: Unexpected service control message %d.\n", SERVICE_NAME, dwCode);
            return ERROR_CALL_NOT_IMPLEMENTED;
        }

    return NO_ERROR;
}

bool
IsServiceShuttingDown()
{
    return (gServiceStatus.dwCurrentState == SERVICE_STOP_PENDING);
}


VOID
UpdateState(
    DWORD dwNewState
    )
/*++

Routine Description:

    Updates this services state with the service controller.

Arguments:

    dwNewState - The next start for this service.  One of
            SERVICE_START_PENDING
            SERVICE_RUNNING

Return Value:

    None

--*/
{
    DWORD status = ERROR_SUCCESS;

    LogService("state change: old %d  new %d", gServiceStatus.dwCurrentState, dwNewState );

    switch (dwNewState)
        {

        case SERVICE_RUNNING:
        case SERVICE_STOPPED:
              gServiceStatus.dwCheckPoint = 0;
              gServiceStatus.dwWaitHint = 0;
              break;

        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
              ++gServiceStatus.dwCheckPoint;
              gServiceStatus.dwWaitHint = 30000L;
              break;

        default:
              ASSERT(0);
              status = ERROR_INVALID_SERVICE_CONTROL;
              break;
        }

   if (status == ERROR_SUCCESS)
       {
       gServiceStatus.dwCurrentState = dwNewState;
       if (!SetServiceStatus(ghServiceHandle, &gServiceStatus))
           {
           status  = GetLastError();
           }
       }

   if (status != ERROR_SUCCESS)
       {
       LogError( "%!ts!: Failed to update service state: %d\n", SERVICE_NAME, status);
       }

   // We could return a status but how would we recover?  Ignore it, the
   // worst thing is that services will kill us and there's nothing
   // we can about it if this call fails.

   LogInfo( "Finished updating service state to %u", dwNewState );

   return;
}


extern "C"
VOID
BITSServiceMain(
    DWORD argc,
    LPTSTR *argv,
    PREGISTER_FUNC lpRegisterFunc
    )
/*++

Routine Description:

    Callback by the service controller when starting this service.

Arguments:

    argc - number of arguments, usually 1

    argv - argv[0] is the name of the service.
           argv[>0] are arguments passed to the service.

Return Value:

    None

--*/
{
    BOOL f = FALSE;
    HRESULT hr = S_OK;

    bool bGlobals = false;
    bool bQmgr = false;

    try
        {
        DWORD status = ERROR_SUCCESS;

        FILETIME ftStartTime;
        GetSystemTimeAsFileTime( &ftStartTime );

        Log_Init();
        Log_StartLogger();

        LogInfo("Service started at %!TIMESTAMP!", FILETIMEToUINT64( ftStartTime ) );

        //
        // Set up for service notifications.
        //
        gServiceStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
        gServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
        gServiceStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

        // The SESSIONCHANGE notification is only available on WindowsXP
        // and the service controller will become confused if this is given on windows 2000

        if ( WINDOWSXP_PLATFORM == g_PlatformVersion )
            gServiceStatus.dwControlsAccepted    |= SERVICE_ACCEPT_SESSIONCHANGE;

        gServiceStatus.dwWin32ExitCode           = 0;
        gServiceStatus.dwServiceSpecificExitCode = 0;
        gServiceStatus.dwCheckPoint              = 0;

        gServiceStatus.dwWaitHint                = 30000L;

        ghServiceHandle = (*lpRegisterFunc)( SERVICE_NAME,
                                             BITSServiceHandler,
                                             0
                                             );
        if (0 == ghServiceHandle)
            {
            status = GetLastError();
            ASSERT(status != ERROR_SUCCESS);

            LogError( "RegisterServiceCtrlHandlerEx failed %!winerr!", status);

            THROW_HRESULT( HRESULT_FROM_WIN32( status ));
            }

        UpdateState(SERVICE_START_PENDING);

        // Set up an event that will be signaled when the service is
        // stopped or shutdown.

        g_hServiceStopEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
        if( NULL == g_hServiceStopEvent )
            {
            status = GetLastError();
            LogError( "CreateEvent failed %!winerr!", status );

            THROW_HRESULT( HRESULT_FROM_WIN32( status ));
            }

        if ( WINDOWS2000_PLATFORM == g_PlatformVersion )
            {

            HRESULT Hr;
            bool CoInitCalled = false;

            Hr = CoInitializeEx( NULL, COINIT_MULTITHREADED );

            if ( FAILED( Hr ) &&
                 ( Hr != RPC_E_CHANGED_MODE  ) )
                THROW_HRESULT( Hr );

            CoInitCalled = true;

            Hr =
                CoInitializeSecurity(
                    NULL,                       // pSecDesc
                    -1,                         // cAuthSvc
                    NULL,                       // asAuthSvc
                    NULL,                       // pReserved
                    RPC_C_AUTHN_LEVEL_PKT,      // dwAuthnLevel
                    RPC_C_IMP_LEVEL_IDENTIFY,   // dwImpLevel
                    NULL,                       // pReserved2
                    EOAC_NO_CUSTOM_MARSHAL |    // dwCapabilities
                    EOAC_DISABLE_AAA |
                    EOAC_STATIC_CLOAKING,
                    NULL );                     // pReserved3

            if ( FAILED( Hr ) &&
                 ( Hr != RPC_E_TOO_LATE ) )
                {
                LogError( "Unable to initialize security on Win2k, error %!winerr!", Hr );

                if ( CoInitCalled )
                    CoUninitialize();

                THROW_HRESULT( Hr );
                }

            }

        LogInfo( "Initializing globalinfo\n" );
        THROW_HRESULT( GlobalInfo::Init() );

        bGlobals = true;

        LogInfo( "Initializing qmgr\n" );
        THROW_HRESULT( InitQmgr() );

        bQmgr = true;

        LogInfo( "Setting service to running.");

        //
        // Allow service controller to resume other duties.
        //
        UpdateState(SERVICE_RUNNING);

        //
        // wait for the stop signal.
        //

        if( WAIT_OBJECT_0 != WaitForSingleObject( g_hServiceStopEvent, INFINITE ))
            {
            status = GetLastError();
            LogError( "ServiceMain failed waiting for stop signal %!winerr!", status);

            hr = HRESULT_FROM_WIN32( status );
            }

        hr = S_OK;
        }
    catch ( ComError exception )
        {
        hr = exception.Error();
        }

    if (bQmgr)
        {
        HRESULT hr2 = UninitQmgr();
        if (FAILED(hr2))
            {
            LogError( "uninit Qmgr failed %!winerr!", hr2);
            }
        }

    if (bGlobals)
        {
        HRESULT hr2 = GlobalInfo::Uninit();
        if (FAILED(hr2))
            {
            LogError( "uninit GlobalInfo failed %!winerr!", hr2);
            }
        }

    if (g_hServiceStopEvent)
        {
        CloseHandle( g_hServiceStopEvent );
        g_hServiceStopEvent = NULL;
        }

    if (FAILED(hr))
        {
        gServiceStatus.dwWin32ExitCode = ERROR_SERVICE_SPECIFIC_ERROR;
        gServiceStatus.dwServiceSpecificExitCode = hr;
        }

    LogService( "ServiceMain returning, hr = %x", hr );
    Log_Close();

    UpdateState(SERVICE_STOPPED);


}

enum
{
    STARTUP_UNKNOWN,
    STARTUP_DEMAND,
    STARTUP_AUTO
}
g_ServiceStartupState = STARTUP_UNKNOWN;

HRESULT
SetServiceStartup( bool bAutoStart )
{

    LogService( "Setting startup to %s", bAutoStart ? ("Auto") : ("Demand") );
    HRESULT Hr = S_OK;

    //
    // Changing the service state is expensive, so avoid it if possible.
    //
    // No need to monitor external changes to the startup state, though:
    //
    //    If the admin changes our state from AUTO to DEMAND or DISABLED, then
    //    the consequent lack of progress is his fault, and admins should know that.
    //
    //    If the admin changes our state from DEMAND to AUTO, then we will
    //    start more often but the result is otherwise harmless.
    //
    if ((g_ServiceStartupState == STARTUP_DEMAND && bAutoStart == FALSE) ||
        (g_ServiceStartupState == STARTUP_AUTO && bAutoStart == TRUE))
        {
        LogService( "startup state is already correct" );
        return S_OK;
        }

    if (gServiceStatus.dwCurrentState != SERVICE_RUNNING)
        {
        LogService("can't change startup state in state %d", gServiceStatus.dwCurrentState);
        return S_OK;
        }

    SC_HANDLE hServiceManager = NULL;
    SC_HANDLE hService = NULL;
    try
    {
        try
        {
            hServiceManager =
                OpenSCManager( NULL,
                               NULL,
                               SC_MANAGER_ALL_ACCESS );

            if ( !hServiceManager ) throw (DWORD)GetLastError();

            hService =
                OpenService( hServiceManager,
                             SERVICE_NAME,
                             SERVICE_CHANGE_CONFIG );
            if ( !hService ) throw (DWORD)GetLastError();

            BOOL bResult =
                ChangeServiceConfig( hService,          // service handle
                                     SERVICE_NO_CHANGE, // dwServiceType
                                     bAutoStart ? SERVICE_AUTO_START : SERVICE_DEMAND_START, // dwStartType
                                     SERVICE_NO_CHANGE, // dwErrorControl
                                     NULL,              // lpBinaryPathName
                                     NULL,              // lpLoadOrderGroup
                                     NULL,              // lpdwTagId
                                     NULL,              // lpDependencies
                                     NULL,              // lpServiceStartName
                                     NULL,              // lpPassword
                                     NULL);             // lpDisplayName

            if ( !bResult ) throw (DWORD)GetLastError();

            if (bAutoStart)
                {
                g_ServiceStartupState = STARTUP_AUTO;
                }
            else
                {
                g_ServiceStartupState = STARTUP_DEMAND;
                }
        }
        catch( DWORD dwException )
        {
            throw (HRESULT)HRESULT_FROM_WIN32( dwException );
        }

    }
    catch (HRESULT HrException)
    {
        Hr = HrException;
        LogError( "An error occurred setting service startup, %!winerr!", Hr );
    }

    if ( hService )
        {
        CloseServiceHandle( hService );
        }

    if ( hServiceManager )
        {
        CloseServiceHandle( hServiceManager );
        }

    LogService( " HR: %!winerr!", Hr );
    return Hr;
}

int InitializeBitsAllocator();

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{

    if (dwReason == DLL_PROCESS_ATTACH)
        {
        g_hInstance = hInstance;
        DisableThreadLibraryCalls(hInstance);

        if (!InitCompilerLibrary())
            {
            return FALSE;
            }

        if ( !DetectProductVersion() )
            {
            UninitCompilerLibrary();
            return FALSE;
            }

        if (0 != InitializeBitsAllocator())
            {
            UninitCompilerLibrary();
            return FALSE;
            }
        }
    else if ( dwReason == DLL_PROCESS_DETACH )
        {
        UninitCompilerLibrary();
        }

    return TRUE;    // ok
}

//
// This ungainly typedef seems to have no global definition.  There are several identical
// definitions in the Windows NT sources, each of which has that bizarre bit-stripping
// on szKey.  I got mine from \nt\base\ntsetup\srvpack\update\splib\common.h.
//
typedef struct tagVERHEAD {
    WORD wTotLen;
    WORD wValLen;
    WORD wType;         /* always 0 */
    WCHAR szKey[(sizeof("VS_VERSION_INFO")+3)&~03];
    VS_FIXEDFILEINFO vsf;
} VERHEAD ;

/*
**  Purpose:
**      Gets the file version values from the given file and sets the
**      given ULONG64 variable.
**  Arguments:
**      szFullPath: a zero terminated character string containing the fully
**          qualified path (including disk drive) to the file.
**  Returns:
**      fTrue if file and file version resource found and retrieved,
**      fFalse if not.
+++
**  Implementation:
**************************************************************************/
BOOL
GetFileVersion64(
    LPTSTR      szFullPath,
    ULONG64 *   pVer
    )
{
    BOOL  fRet = false;
    DWORD dwHandle;
    DWORD InfoSize;

    try
        {
        //
        // Get the file version info size
        //

        if ((InfoSize = GetFileVersionInfoSize( szFullPath, &dwHandle)) == 0)
            {
            return (fRet);
            }

        //
        // Allocate enough size to hold version info
        //
        auto_ptr<TCHAR> lpData ( LPTSTR(new byte[ InfoSize ]));

        //
        // Get the version info
        //
        fRet = GetFileVersionInfo( szFullPath, dwHandle, InfoSize, lpData.get());

        if (fRet)
            {
            UINT dwLen;
            VS_FIXEDFILEINFO *pvsfi;

            fRet = VerQueryValue(
                       lpData.get(),
                       L"\\",
                       (LPVOID *)&pvsfi,
                       &dwLen
                       );

            //
            // Convert two DWORDs into a 64-bit integer.
            //
            if (fRet)
                {
                *pVer = ( ULONG64(pvsfi->dwFileVersionMS) << 32) | (pvsfi->dwFileVersionLS);
                }
            }

        return (fRet);
        }
    catch ( ComError err )
        {
        return false;
        }
}

BOOL
GetModuleVersion64(
    HMODULE hDll,
    ULONG64 * pVer
    )
{
    DWORD* pdwTranslation;
    VS_FIXEDFILEINFO* pFileInfo;
    UINT uiSize;

    HRSRC hrsrcVersion = FindResource(
                                hDll,
                                MAKEINTRESOURCE(VS_VERSION_INFO),
                                RT_VERSION);

    if (!hrsrcVersion) return false;

    HGLOBAL hglobalVersion = LoadResource(hDll, hrsrcVersion);
    if (!hglobalVersion) return false;

    VERHEAD * pVerHead = (VERHEAD *) LockResource(hglobalVersion);
    if (!pVerHead) return false;

    // I stole this code from \nt\com\complus\src\shared\util\svcerr.cpp,
    // and the comment is theirs:
    //
    // VerQueryValue will write to the memory, for some reason.
    // Therefore we must make a writable copy of the version
    // resource info before calling that API.
    auto_ptr<char> pvVersionInfo ( new char[pVerHead->wTotLen + pVerHead->wTotLen/2] );

    memcpy(pvVersionInfo.get(), pVerHead, pVerHead->wTotLen); // SEC: REVIEWED 2002-03-28

    // Retrieve file version info
    BOOL fRet = VerQueryValue( pvVersionInfo.get(),
                               L"\\",
                               (void**)&pFileInfo,
                               &uiSize);
    if (fRet)
        {
        *pVer = (ULONG64(pFileInfo->dwFileVersionMS) << 32) | (pFileInfo->dwFileVersionLS);
        }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\service\register.cpp ===
//--------------------------------------------------------------------------
//  Copyright (c) Microsoft Corporation, 2001
//
//  register.cpp
//
//--------------------------------------------------------------------------

#include "qmgrlib.h"

#include <windows.h>
#include <advpub.h>

#include "register.tmh"
#include "resource.h"

extern   HMODULE  g_hInstance;   // Defined in ..\service\service.cxx

#define  BITS_SERVICE_NAME        TEXT("BITS")
#define  BITS_DISPLAY_NAME        TEXT("Background Intelligent Transfer Service")
#define  BITS_SVCHOST_CMDLINE_W2K TEXT("%SystemRoot%\\system32\\svchost.exe -k BITSgroup")
#define  BITS_SVCHOST_CMDLINE_XP  TEXT("%SystemRoot%\\system32\\svchost.exe -k netsvcs")
#define  BITS_DEPENDENCIES_W2K    TEXT("Rpcss\0SENS\0Wmi\0")
#define  BITS_DEPENDENCIES_XP     TEXT("Rpcss\0")

#define  ADVPACK_DLL              TEXT("advpack.dll")

#define  DEFAULT_INSTALL         "BITS_DefaultInstall"
#define  DEFAULT_UNINSTALL       "BITS_DefaultUninstall"

// Operating system versions.
#define  VER_WINDOWS_2000         500
#define  VER_WINDOWS_XP           501

// Constants used if we need to retry CreateService() because the service
// is marked for delete but not deleted yet.
#define  MAX_RETRIES               10
#define  RETRY_SLEEP_MSEC         200

// Constants for service restart on failure.
#define  FAILURE_COUNT_RESET_SEC  (10*60)
#define  RESTART_DELAY_MSEC       (60*1000)


//--------------------------------------------------------------------------
//  GetOsVersion()
//--------------------------------------------------------------------------
HRESULT GetOsVersion( OUT DWORD *pdwOsVersion )
{
    HRESULT        hr = S_OK;
    OSVERSIONINFO  osVersionInfo;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else
    {
        *pdwOsVersion = 100*osVersionInfo.dwMajorVersion + osVersionInfo.dwMinorVersion;
    }

    LogInfo("Detected OS Version: %d, hr=%x", *pdwOsVersion, hr);

    return hr;
}


//------------------------------------------------------------------------
//  StopAndDeleteService()
//
//  Used to stop and delete the BITS service if it is currently installed.
//------------------------------------------------------------------------
HRESULT StopAndDeleteService( IN SC_HANDLE hSCM,
                              IN BOOL      fStopAndDelete )
{
    HRESULT        hr = S_OK;
    DWORD          dwStatus;
    SC_HANDLE      hService;
    SERVICE_STATUS serviceStatus;

    LogInfo("StopAndDeleteService()");

    hService = OpenService(hSCM, BITS_SERVICE_NAME, SERVICE_ALL_ACCESS);
    if (hService != NULL)
    {
        LogInfo("Attempting to stop the BITS service");
        if (!ControlService(hService,SERVICE_CONTROL_STOP,&serviceStatus))
        {
            dwStatus = GetLastError();
            if (dwStatus != ERROR_SERVICE_NOT_ACTIVE)
            {
                hr = HRESULT_FROM_WIN32(dwStatus);
                LogError("Service could not be stopped. hr=%x", hr);
            }
            else
            {
                LogInfo("Service was not previously active -- unable to stop it. Proceeding");
            }
        }

        if (!fStopAndDelete)
        {
            CloseServiceHandle(hService);
            return hr;
        }

        LogInfo("Attempting to delete current BITS service");
        if (!DeleteService(hService))
        {
            dwStatus = GetLastError();
            if (dwStatus != ERROR_SERVICE_MARKED_FOR_DELETE)
            {
                hr = HRESULT_FROM_WIN32(dwStatus);
                LogError("Failed to delete BITS service. hr=%x", hr);
            }
            else
            {
                LogInfo("Could not delete service -- service is already marked for deletion");
            }
        }

        CloseServiceHandle(hService);
    }
    else
    {
        dwStatus = GetLastError();

        // If the service doesn't exist, then that's Ok...
        if (dwStatus != ERROR_SERVICE_DOES_NOT_EXIST)
        {
            hr = HRESULT_FROM_WIN32(dwStatus);
            LogError("Could not access BITS service. hr=%x", hr);
        }
        else
        {
            LogInfo("BITS Service does not exists. Proceeding.");
        }
    }

    return hr;
}

//----------------------------------------------------------------------
//  CreateBitsService()
//
//----------------------------------------------------------------------
HRESULT CreateBitsService( IN SC_HANDLE hSCM )
{
    HRESULT    hr = S_OK;
    DWORD      i;
    DWORD      dwStatus = 0;
    DWORD      dwOsVersion;
    SC_HANDLE  hService;
    WCHAR     *pwszSvcHostCmdLine;
    WCHAR     *pwszDependencies;
    WCHAR     *pwszString;
    WCHAR      wszString[1024];
    SERVICE_DESCRIPTION     ServiceDescription;
    SERVICE_FAILURE_ACTIONS FailureActions;
    SC_ACTION               saActions[3];

    LogInfo("CreateBitsService()");

    hr = GetOsVersion(&dwOsVersion);
    if (FAILED(hr))
    {
        return hr;
    }

    pwszSvcHostCmdLine = (dwOsVersion == VER_WINDOWS_2000)? BITS_SVCHOST_CMDLINE_W2K : BITS_SVCHOST_CMDLINE_XP;
    LogInfo("Service cmdline: %S", pwszSvcHostCmdLine);

    pwszDependencies = (dwOsVersion == VER_WINDOWS_2000)? BITS_DEPENDENCIES_W2K : BITS_DEPENDENCIES_XP;

    // Setup service failure recovery actions
    memset(&FailureActions,0,sizeof(SERVICE_FAILURE_ACTIONS));
    FailureActions.dwResetPeriod = FAILURE_COUNT_RESET_SEC;
    FailureActions.lpRebootMsg = NULL;
    FailureActions.lpCommand = NULL;
    FailureActions.cActions = sizeof(saActions)/sizeof(saActions[0]);  // Number of array elements.
    FailureActions.lpsaActions = saActions;

    // Wait for 60 seconds (RESTART_DELAY_MSEC), then for the first two failures try to restart the
    // service, after that give up.
    saActions[0].Type = SC_ACTION_RESTART;
    saActions[0].Delay = RESTART_DELAY_MSEC;
    saActions[1].Type = SC_ACTION_RESTART;
    saActions[1].Delay = RESTART_DELAY_MSEC;
    saActions[2].Type = SC_ACTION_NONE;
    saActions[2].Delay = RESTART_DELAY_MSEC;


    if (LoadString(g_hInstance,IDS_SERVICE_NAME,wszString,sizeof(wszString)/sizeof(WCHAR)))
    {
        pwszString = wszString;
    }
    else
    {
        pwszString = BITS_DISPLAY_NAME;
    }

    for (i=0; i<MAX_RETRIES; i++)
    {
        LogInfo("Attemp #%d to create service", (i+1));

        hService = CreateService( hSCM,
                                  BITS_SERVICE_NAME,
                                  pwszString,
                                  SERVICE_ALL_ACCESS,
                                  SERVICE_WIN32_SHARE_PROCESS,
                                  SERVICE_DEMAND_START,
                                  SERVICE_ERROR_NORMAL,
                                  pwszSvcHostCmdLine,
                                  NULL,    // lpLoadOrderGroup
                                  NULL,    // lpdwTagId
                                  pwszDependencies,
                                  NULL,    // lpServiceStartName
                                  NULL );  // lpPassword

        if (hService)
        {
            // Set the service description string.
            if (LoadString(g_hInstance,IDS_SERVICE_DESC,wszString,sizeof(wszString)/sizeof(WCHAR)))
            {
                ServiceDescription.lpDescription = wszString;

                if (!ChangeServiceConfig2(hService,SERVICE_CONFIG_DESCRIPTION,&ServiceDescription))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            // Set the service failure recovery actions.
            if (SUCCEEDED(hr))
            {
                if (!ChangeServiceConfig2(hService,SERVICE_CONFIG_FAILURE_ACTIONS,&FailureActions))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }

            CloseServiceHandle(hService);
            break;
        }
        else
        {
            dwStatus = GetLastError();
            LogError("Failed to create service. Error=%x", dwStatus);


            if (dwStatus == ERROR_SERVICE_MARKED_FOR_DELETE)
            {
                Sleep(RETRY_SLEEP_MSEC);
                continue;
            }

            hr = HRESULT_FROM_WIN32(dwStatus);
            break;
        }
    }

    LogInfo("Exiting CreateBITSService with hr=%x", hr);

    return hr;
}

HRESULT CallRegInstall(HMODULE hModule, LPCSTR pszSection, LPCSTRTABLE pstTable)
{
    HRESULT hr = S_OK;
    HMODULE hAdvPack;

    hAdvPack = LoadLibrary(ADVPACK_DLL);
    if (hAdvPack)
    {
        REGINSTALL pfnRegInstall = (REGINSTALL)GetProcAddress(hAdvPack, achREGINSTALL);
        if (pfnRegInstall)
        {
            hr = pfnRegInstall(hModule, pszSection, pstTable);
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogError("GetProcAddress call failed with hr=%x", hr);
        }

        FreeLibrary(hAdvPack);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        LogError("LoadLibrary call failed with hr=%x", hr);
    }

    return hr;
}

//----------------------------------------------------------------------
//  InfInstall()
//
//  Called durning setup to configure registry and service. This function
//  optionally creates the BITS service, then runs the qmgr_v15.inf INF
//  file (stored as a resouce in CustomActions.dll) to either install or
//  uninstall BITS.
//
//  fInstall       IN - TRUE if this is install, FALSE for uninstall.
//
//----------------------------------------------------------------------
STDAPI InfInstall( IN BOOL fInstall )
{
    HRESULT   hr = S_OK;
    SC_HANDLE hSCM;
    DWORD     dwStatus;
    DWORD     dwOsVersion;

    Log_Init();
    Log_StartLogger();

    LogInfo("InfInstall(%d)", fInstall);


    hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM)
    {
        // Independent if we are on XP or W2k, we are going to try to
        // stop and delete the service
        // If the service is not there, we will fail gracefully.
        hr = StopAndDeleteService(hSCM, TRUE);

        if (fInstall)
        {
            hr = CreateBitsService(hSCM);
        }

        CloseServiceHandle(hSCM);

        if (FAILED(hr))
        {
            return hr;
        }
    }
    else
    {
        dwStatus = GetLastError();
        hr = HRESULT_FROM_WIN32(dwStatus);
        return hr;
    }

    if (fInstall)
    {
        hr = CallRegInstall(g_hInstance, DEFAULT_INSTALL, NULL);
    }
    else
    {
        hr = CallRegInstall(g_hInstance, DEFAULT_UNINSTALL, NULL);
    }

    if (FAILED(hr))
    {
        LogError("InfInstall() failed with hr=%x", hr);
    }
    else
    {
        LogInfo("InfInstall() completed successfully");
    }

    Log_Close();

    return hr;
}

//----------------------------------------------------------------------
//  DllRegisterServer()
//
//----------------------------------------------------------------------
STDAPI DllRegisterServer(void)
{
    return InfInstall(TRUE);
}

//----------------------------------------------------------------------
//  DllUnregisterServer(void)
//
//----------------------------------------------------------------------
STDAPI DllUnregisterServer(void)
{
    return InfInstall(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\service\tasktest.cpp ===
#pragma include_alias("clist.h", "..\newjob\clist.h")

#include "qmgrlib.h"
#include "locks.hxx"
#include "..\newjob\csd.h"
#include "..\newjob\tasksched.h"

//
// Following items are needed to link properly.
//

HINSTANCE g_hInstance;
SERVICE_STATUS_HANDLE ghServiceHandle;
unsigned long g_LastServiceControl;

bool IsServiceShuttingDown()
{
    return false;
}

long SetServiceStartup( bool ignore )
{
    return 0;
}

int InitializeBitsAllocator()
{
    return 0;
}

SidHandle
BITSAllocateAndInitializeSid(
    BYTE nSubAuthorityCount,                        // count of subauthorities
    DWORD dwSubAuthority0,                          // subauthority 0
    DWORD dwSubAuthority1 );                         // subauthority 1


//
// Preceding items are needed to link properly.
//

#define MAX_QUEUED_WORK_ITEMS 30

SidHandle g_NetworkUsersSid;
long g_ThreadCount;
long g_CancelCount;
HANDLE * g_hThreads;
HANDLE g_hWorkItemCreationThread;

TaskScheduler * g_Lock;

class TestWorkItem : public TaskSchedulerWorkItem
{
public:

    TestWorkItem( long index )
    {
        m_index = index;
    }

    virtual SidHandle GetSid() {
        return g_NetworkUsersSid;
    }
    virtual void OnDispatch();

    long m_index;
};

bool TakeAndReleaseLock( bool fWrite, long Delay, bool fComplete );

struct
{
    TestWorkItem * item;
    long    complete;
    long    cancelled;
}
g_PendingWorkItems[ MAX_QUEUED_WORK_ITEMS ];

//------------------------------------------------------------------------

void TestWorkItem::OnDispatch()
{
    static int i;

    bool fWrite;

    if ((i % 7) == 0)
        {
        fWrite = true;
        }
    else
        {
        fWrite = false;
        }

    long Delay = -1;
    long SleepChoice = (i % 10);
    if (SleepChoice == 0)
        {
//            printf("Sleep 10\n");
        Delay = 10;
        }
    else if (SleepChoice == 5)
        {
//            printf("Sleep 0\n");
        Delay = 0;
        }

    bool fCancel;
    if ((i % 3) == 1)
        {
        fCancel = true;
        }
    else
        {
        fCancel = false;
        }

    long PreLockSleep = (i % 5);
    if (PreLockSleep < 3)
        {
        Sleep(10);
        }

    if (!TakeAndReleaseLock( fWrite, Delay, fCancel))
        {
        //
        // The work-item was cancelled.
        //
        g_Lock->AcknowledgeWorkItemCancel();
        InterlockedIncrement( &g_CancelCount );
        }
    else if (!fCancel)
        {
        g_Lock->CompleteWorkItem();
        }

    //
    // Mark the item complete.
    //
    if (m_index >= 0)
        {
        if (g_PendingWorkItems[m_index].item != this)
            {
            printf("error: index mismatch\n");
            exit(1);
            }

//        printf("completing item %p index %d\n", this, m_index);
        g_PendingWorkItems[m_index].complete = 1;
        }

    //

//    if ((i % 100000) == 0)
        {
//        printf("%d work items\n", i);
        }

//    if ((i % 1000) == 0)
        {
//        putchar('W');
        }

    ++i;
}

bool TakeAndReleaseLock( bool fWrite, long Delay, bool fComplete )
{
    if (fWrite)
        {
//            printf("lock writer\n");
        if (g_Lock->LockWriter())
            {
            // cancelled
            return false;
            }
        }
    else
        {
//            printf("lock reader\n");
        if (g_Lock->LockReader())
            {
            // cancelled
            return false;
            }
        }

    if (Delay != -1)
        {
        Sleep(Delay);
        }

    if (fComplete)
        {
        g_Lock->CompleteWorkItem();
        }

    if (fWrite)
        {
//            printf("unlock writer\n");
        g_Lock->UnlockWriter();
        }
    else
        {
//            printf("unlock reader\n");
        g_Lock->UnlockReader();
        }

    return true;
}


DWORD WINAPI ThreadProc( LPVOID arg )
{
    long index = long(arg);
    long i =0;

    do
        {
        bool fWrite;

        if ((i % 9) == index)
            {
            fWrite = true;
            }
        else
            {
            fWrite = false;
            }

        long Delay = -1;
        long SleepChoice = (i % 10);
        if (SleepChoice == 0)
            {
    //            printf("Sleep 10\n");
            Delay = 10;
            }
        else if (SleepChoice == 5)
            {
    //            printf("Sleep 0\n");
            Delay = 0;
            }

        if (!TakeAndReleaseLock( fWrite, Delay, false ))
            {
            printf("thread %d: cancel detected!", DWORD(arg));
            exit(1);
            }

        if ((i % 100000) == 0)
            {
            printf("thread %d: %d iterations\n", DWORD(arg), i);
            }

        if ((i % 1000) == 0)
            {
            putchar('0'+DWORD(arg));
            }

        ++i;
        }
    while ( 1 );
}

DWORD WINAPI WorkItemCreatorProc( LPVOID arg )
{
    int i = 0;

    for (;;)
        {
        int index;

        if ((i % 1000) == 0)
            {
            putchar('w');
            }

        //
        // Clean out completed work items
        //
        for (index = 0; index < RTL_NUMBER_OF( g_PendingWorkItems ); ++index)
            {
            if (g_PendingWorkItems[index].complete)
                {
//                    printf("clearing index %d\n", index);
                delete g_PendingWorkItems[index].item;
                g_PendingWorkItems[index].item = 0;
                g_PendingWorkItems[index].complete = 0;
                g_PendingWorkItems[index].cancelled = 0;
                }
            }

        //
        // Fill up the queue.
        //
        do
            {
            // find a spot

            for (index = 0; index < RTL_NUMBER_OF( g_PendingWorkItems ); ++index)
                {
                if (g_PendingWorkItems[index].item == 0)
                    {
                    break;
                    }
                }

            //
            // A slot is available; create a new workitem for it.
            //
            if (index < RTL_NUMBER_OF( g_PendingWorkItems ))
                {
                TestWorkItem * item = new TestWorkItem( index );

                g_PendingWorkItems[index].item = item;

                g_Lock->InsertWorkItem( item, NULL );
                }
            }
        while ( index < RTL_NUMBER_OF( g_PendingWorkItems ) );

        //
        // let them drain away
        //
        do
            {
            for (index = RTL_NUMBER_OF( g_PendingWorkItems )-1; index >=0; --index)
                {
                if (g_PendingWorkItems[index].item != 0 &&
                    g_PendingWorkItems[index].complete == 0 &&
                    g_PendingWorkItems[index].cancelled == 0)
                    {
                    g_Lock->CancelWorkItem( g_PendingWorkItems[index].item );
                    g_PendingWorkItems[index].cancelled = 1;
                    break;
                    }
                }

             Sleep(1);
            }
        while ( index >= 0 );

        ++i;
        }
}

void __cdecl wmain (int argc, wchar_t *argv[])
{
    if (argc < 2)
        {
        printf("arg1 should be a thread count\n");
        return;
        }

    g_ThreadCount = _wtol( argv[1] );
    g_hThreads = new HANDLE[ g_ThreadCount ];

    if (!InitCompilerLibrary())
        {
        printf("init STL failed");
        return;
        }

    if ( !DetectProductVersion() )
        {
        printf("version detect failed");
        return;
        }

    if (0 != InitializeBitsAllocator())
        {
        printf("allocator init failed");
        return;
        }

    Log_Init();
    Log_StartLogger();

    g_NetworkUsersSid = BITSAllocateAndInitializeSid( 1, SECURITY_NETWORK_RID, 0);

    g_Lock = new TaskScheduler;

    for (int index = 0; index < RTL_NUMBER_OF( g_PendingWorkItems ); ++index)
        {
        g_PendingWorkItems[index].item = 0;
        g_PendingWorkItems[index].complete = 0;
        g_PendingWorkItems[index].cancelled = 0;
        }

    DWORD id;
    for (int i=0; i < g_ThreadCount; ++i)
        {
        g_hThreads[i] = CreateThread( NULL, 0, ThreadProc, LPVOID(i), 0, &id );

        if (0 == g_hThreads[i])
            {
            printf("error %d creating thread\n", GetLastError());
            }
        }

    g_hWorkItemCreationThread = CreateThread( NULL, 0, WorkItemCreatorProc, 0, 0, &id );
    if (0 == g_hWorkItemCreationThread)
        {
        printf("error %d creating thread\n", GetLastError());
        }

    Sleep( 1000 * 1000 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\tests\perf\jeff\perfserv.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <winsock.h>
#include <bits.h>

#define WINSOCK_PORT 4000

BOOL GetBuffer( SOCKET conn, char * buf, size_t size )
{
    int Received = 0;

    do
        {
        int bytes = recv(conn, buf+Received, size-Received, 0);

        if (bytes == 0)
            {
            printf("client closed the socket connection\n");
            return FALSE;
            }

        if (bytes < 0)
            {
            printf("read error %d\n", WSAGetLastError());
            return FALSE;
            }

        Received += bytes;
        }
    while ( Received < int(size) );

//    printf("read %d\n", size );
//    putchar('.');
    return TRUE;
}

void __cdecl wmain (int argc, wchar_t *argv[])
{
    DWORD err;
    WSADATA WsaData = {0};

    if ((err = WSAStartup(0x0101, &WsaData)) != NO_ERROR)
        {
        printf("unable to init winsock: %d\n", err);
        }

    //
    // listen for connections
    //
    struct sockaddr_in dest;

    dest.sin_addr.s_addr = INADDR_ANY;
    dest.sin_family = AF_INET;
    dest.sin_port = WINSOCK_PORT;

    SOCKET s = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if (s == INVALID_SOCKET)
        {
        printf("unable to create socket, %d\n", WSAGetLastError());
        exit(1);
        }

    if (bind( s, (sockaddr *) &dest, sizeof(dest)))
        {
        printf("unable to bind, %d\n", WSAGetLastError());
        exit(1);
        }

    if (listen(s, 5))
        {
        printf("unable to listen, %d\n", WSAGetLastError());
        exit(1);
        }

    printf("listening...\n");

    //
    // accept new connections
    //
    do
        {
        DWORD Sizes[2];

        sockaddr_in client_addr;
        int size = sizeof(client_addr);

        SOCKET conn = accept( s, (sockaddr *) &client_addr, &size );

        printf("new connection\n");

        while (1)
            {
            if (!GetBuffer( conn, (char *) Sizes, sizeof(Sizes)))
                {
                printf("read sizes failed\n");
                break;
                }

            char * buf = (char *) malloc( max(Sizes[0], Sizes[1]));

            if (!GetBuffer( conn, buf, Sizes[0]))
                {
                printf("read failed\n");
                free(buf);
                break;
                }

            if (SOCKET_ERROR == send(conn, buf, Sizes[1], 0))
                {
                printf("unable to send, %d\n", WSAGetLastError());
                free(buf);
                break;
                }

//            printf("sent %d\n", Sizes[1]);
//            putchar('.');
            free(buf);
            }

        closesocket( conn );
        printf("connection closed\n");
        }
    while ( 1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\tests\perf\jeff\perfcli.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <winsock.h>
#include <bits.h>
#include <iphlpapi.h>
#include <iptypes.h>

#define WINSOCK_PORT 4000

struct BITS_INTERNAL_STATS
{
    UINT64 BytesTransferred;
    UINT64 BlocksTransferred;
    DWORD LastBlockSize;
    float LastServerSpeed;
    float AverageServerSpeed;
    float LastInterfaceSpeed;
    float AverageInterfaceSpeed;
    DWORD InterfaceId;
};


long g_PollInterval = 200;
long g_SendSize = 1000;
long g_ReceiveSize = 1000;
long g_Time = 10 * 60;

long g_StartTime;

long g_WinsockBusyTime = 10;
long g_WinsockFreeTime = 30;
TCHAR * g_WinsockServer;
SOCKET g_conn;

long g_TotalSent = 0;
long g_TotalReceived = 0;

TCHAR * g_Url;

BG_JOB_PRIORITY g_Priority = BG_JOB_PRIORITY_NORMAL;
IBackgroundCopyJob * g_job;

HANDLE g_StartEvent;
volatile BOOL g_Halt;

TCHAR * g_OutputFileName;
FILE * g_OutputFile = NULL;

MIB_IFROW g_InitialNetStats;
DWORD g_NetworkAdapterIndex = 0;

HANDLE g_BitsThread;
HANDLE g_WinsockThread;

void CollectWinsockStats();
void CollectBitsStats();

void CleanupWinsock();
void EnumerateAdapters();

//------------------------------------------------------

void Usage()
{
    printf(
        "parameters:\n"
        "    -p <msec>          to poll every <msec> milliseconds\n"
        "    -server <name>   to specify the Winsock server name or IP address\n"
        "    -ss <size>           to send <size> bytes per winsock request\n"
        "    -sr <size>            to receive <size> bytes per winsock request\n"
        "    -wb <sec>           winsock thread's busy time\n"
        "    -wf <sec>            winsock thread's free time\n"
        "    -t <secs>             number of seconds to run test\n"
        "    -netindex <index> network adapter index to monitor\n"
        "    -url <url>             URL to transfer\n"
        );
}

long GetLongArg( int & i, int & argc, TCHAR * argv[], TCHAR * msg )
{
    ++i;
    if (i < argc)
        {
        return _ttol( argv[i] );
        }
    else
        {
        _tprintf(msg);
        exit(1);
        }
}

TCHAR * GetStringArg( int & i, int & argc, TCHAR * argv[], TCHAR * msg )
{
    ++i;
    if (i < argc)
        {
        return argv[i];
        }
    else
        {
        _tprintf(msg);
        exit(1);
        }
}

BG_JOB_PRIORITY GetPriority( int & i, int & argc, TCHAR * argv[], TCHAR * msg )
{
    TCHAR * val = GetStringArg( i, argc, argv, msg );

    if (0 == _tcsicmp( val, _T("low")))
        {
        return BG_JOB_PRIORITY_LOW;
        }
    else if (0 == _tcsicmp( val, _T("normal")))
        {
        return BG_JOB_PRIORITY_NORMAL;
        }
    else if (0 == _tcsicmp( val, _T("high")))
        {
        return BG_JOB_PRIORITY_HIGH;
        }
    else if (0 == _tcsicmp( val, _T("foreground")))
        {
        return BG_JOB_PRIORITY_FOREGROUND;
        }
    else
        {
        _tprintf(msg);
        exit(1);
        }
}

void ParseCmdLine( int argc, wchar_t * argv[] )
{
    int i = 1;

    while (i < argc)
        {
        if (0 == _tcsicmp( argv[i], _T("-p")))
            {
            g_PollInterval = GetLongArg( i, argc, argv, _T("-p must be followed by a number in milliseconds\n") );
            }
        else if (0 == _tcsicmp( argv[i], _T("-server")))
            {
            g_WinsockServer = GetStringArg( i, argc, argv, _T("-server must be followed by a server name \n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-ss")))
            {
            g_SendSize = GetLongArg( i, argc, argv, _T("-ss must be followed by a number of bytes\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-sr")))
            {
            g_ReceiveSize = GetLongArg( i, argc, argv, _T("-sr must be followed by a number of bytes") );
            }
        else if (0 == _tcsicmp( argv[i], _T("-wb")))
            {
            g_WinsockBusyTime = GetLongArg( i, argc, argv, _T("-wb must be followed by a number of seconds\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-wf")))
            {
            g_WinsockFreeTime = GetLongArg( i, argc, argv, _T("-wf must be followed by a number of seconds\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-t")))
            {
            g_Time = GetLongArg( i, argc, argv, _T("-t must be followed by a time in seconds\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-netindex")))
            {
            g_NetworkAdapterIndex = GetLongArg( i, argc, argv, _T("-netindex must be followed by a network adapter index\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-f")))
            {
            g_OutputFileName = GetStringArg( i, argc, argv, _T("-f must be followed by a file name\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-pri")))
            {
            g_Priority = GetPriority( i, argc, argv, _T("-pri must be followed by a priority\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-url")))
            {
            g_Url = GetStringArg( i, argc, argv, _T("-url must be followed by an URL\n"));
            }
        else if (0 == _tcsicmp( argv[i], _T("-enum")))
            {
            EnumerateAdapters();
            }
        else if (0 == _tcsicmp( argv[i], _T("-?")))
            {
            Usage();
            exit(1);
            }
        else
            {
            printf("'%S' is not a recognized option", argv[i]);
            exit(1);
            }

        ++i;
        }
}

void PrepareCommon()
{
    g_StartEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
    if (!g_StartEvent)
        {
        printf("unable to create event\n");
        exit(1);
        }

    g_Halt = FALSE;

    if (g_OutputFileName)
        {
        g_OutputFile = _tfopen( g_OutputFileName, _T("w"));
        if (!g_OutputFile)
            {
            printf("unable to open output file\n");
            exit(1);
            }
        }
    else
        {
        g_OutputFile = stdout;
        }
}

void CleanupCommon()
{
    if (g_OutputFileName)
        {
        fclose( g_OutputFile );
        }
}

DWORD WINAPI BitsThreadProc( PVOID arg );

void PrepareBits()
{
    IBackgroundCopyManager * mgr = NULL;

    HRESULT hr;

    hr = CoInitialize( NULL );
    if (FAILED(hr))
        {
        printf("unable to inti COM %x\n", hr);
        exit(1);
        }


    hr = CoCreateInstance(
        __uuidof(BackgroundCopyManager),
        NULL, // no aggregation
        CLSCTX_ALL,
        __uuidof(IBackgroundCopyManager),
        (LPVOID *) &mgr );

    if (FAILED(hr))
        {
        printf("unable to create BITS manager %x\n", hr);
        exit(1);
        }

    GUID guid;
    hr = mgr->CreateJob( L"perf test", BG_JOB_TYPE_DOWNLOAD, &guid, &g_job );
    if (FAILED(hr))
        {
        printf("unable to create BITS job %x\n", hr);
        exit(1);
        }

    hr = g_job->AddFile( g_Url, L"c:\\temp\\download.dat" );
    if (FAILED(hr))
        {
        printf("unable to create add file to job %x\n", hr);
        exit(1);
        }

    hr = g_job->SetPriority( g_Priority );
    if (FAILED(hr))
        {
        printf("unable to set job priority %x\n", hr);
        exit(1);
        }
}

void CleanupBits()
{
    g_job->Cancel();
}

DWORD WINAPI WinsockThreadProc( PVOID arg );

void PrepareWinsock()
{
    char * AsciiServer = (char *) malloc( 1 +_tcslen( g_WinsockServer ));

    for (int i = _tcslen( g_WinsockServer ); i >= 0; --i)
        {
        AsciiServer[i] = char(g_WinsockServer[i]);
        }

    //
    // Get the IP address of the server.
    //
    ULONG addr = inet_addr( AsciiServer );

    if (addr == -1)
        {
        struct hostent *pHostEntry = gethostbyname( AsciiServer );

        if (pHostEntry == 0)
            {
            printf("unable to resolve the address of %s: %d\n", AsciiServer, WSAGetLastError() );
            exit(1);
            }

        addr = *(unsigned long *)pHostEntry->h_addr;
        }

    struct sockaddr_in dest;
    dest.sin_addr.s_addr = addr;
    dest.sin_family = AF_INET;
    dest.sin_port = WINSOCK_PORT;

    //
    // Connect to the server.
    //
    SOCKET s = socket( AF_INET, SOCK_STREAM, IPPROTO_TCP );
    if (s == INVALID_SOCKET)
        {
        printf("unable to create socket, %d\n", WSAGetLastError());
        exit(1);
        }

    if (SOCKET_ERROR == connect( s, (sockaddr *)&dest, sizeof(dest)))
        {
        printf("unable to connect, %d\n", WSAGetLastError());
        exit(1);
        }

    printf("winsock connected to server\n");

    g_InitialNetStats.dwIndex = g_NetworkAdapterIndex;

    if (g_NetworkAdapterIndex)
        {
        DWORD err = GetIfEntry( &g_InitialNetStats );
        if (err)
            {
            printf("unable to collect stats from network %d: %d\n", g_NetworkAdapterIndex, err);
            exit(1);
            }
        }

    DWORD id;
    HANDLE h = CreateThread( NULL, 0, WinsockThreadProc, PVOID(s), 0, &id);
    if (!h)
        {
        printf("unable to create socket thread %d\n", GetLastError());
        exit(1);
        }
}

DWORD WINAPI WinsockThreadProc( PVOID arg )
{
    SOCKET s = SOCKET(arg);

    char * buf = (char *) malloc( max( g_SendSize, g_ReceiveSize ));

    printf("2: winsock thread ready to start...\n");

    WaitForSingleObject( g_StartEvent, INFINITE );

    //
    // Send and receive data forever, with duty cycle governed by the -wb and -wf parameters.
    //
    DWORD Sizes[2];
    Sizes[0] = g_SendSize;
    Sizes[1] = g_ReceiveSize;
    do
        {
        printf("sending...\n");

        long StartTime = GetTickCount();

        while (long(GetTickCount()) - StartTime < (g_WinsockBusyTime * 1000) && g_Halt == FALSE)
            {
            if (SOCKET_ERROR == send(s, (char *) Sizes, sizeof(Sizes), 0))
                {
                printf("unable to send, %d\n", WSAGetLastError());
                }

            if (SOCKET_ERROR == send(s, buf, g_SendSize, 0))
                {
                printf("unable to send, %d\n", WSAGetLastError());
                }

            g_TotalSent += g_SendSize + sizeof(Sizes);

            long Received = 0;

            do
                {
                int bytes = recv(s, buf, g_ReceiveSize - Received, 0);

                if (bytes == 0)
                    {
                    printf("server closed the socket connection\n");
                    break;
                    }

                Received += bytes;

                g_TotalReceived += bytes;
                }
            while ( Received < g_ReceiveSize );
            }

        printf("2: waiting...\n");
        Sleep( g_WinsockFreeTime * 1000 );
        }
    while ( !g_Halt );

    printf("2: winsock thread exiting\n");

    return 0;
}

void CleanupWinsock()
{
}

char * JobStateStringOf( BG_JOB_STATE state )
{
    switch (state)
        {
        case BG_JOB_STATE_QUEUED : return "queued";
        case BG_JOB_STATE_CONNECTING : return "connecting";
        case BG_JOB_STATE_TRANSFERRING : return "transferring";
        case BG_JOB_STATE_TRANSFERRED : return "FINISHED";
        case BG_JOB_STATE_TRANSIENT_ERROR : return "trans-error";
        case BG_JOB_STATE_ERROR : return "ERROR";
        case BG_JOB_STATE_SUSPENDED : return "SUSPENDED";
        case BG_JOB_STATE_ACKNOWLEDGED : return "ACKNOWLEDGED";
        case BG_JOB_STATE_CANCELLED : return "CANCELLED";
        default: return "(unknown state)";
        }
}

void CollectStats()
{
    HRESULT hr;
    BG_JOB_STATE state;
    BG_JOB_PROGRESS progress;

    hr = g_job->GetState( &state );
    if (hr)
        {
        printf("unable to get job state %x\n", hr);
        return;
        }

    hr = g_job->GetProgress( &progress );
    if (hr)
        {
        printf("unable to get job progress %x\n", hr);
        return;
        }

    //
    // Get net card stats.
    //
    MIB_IFROW net = {0};
    long InOctets = -1, OutOctets = -1;

    if (g_NetworkAdapterIndex != 0)
        {
        net.dwIndex = g_NetworkAdapterIndex;

        if (!GetIfEntry( &net ))
            {
            InOctets = net.dwInOctets - g_InitialNetStats.dwInOctets;
            OutOctets = net.dwOutOctets - g_InitialNetStats.dwOutOctets;
            }
        }

    printf("%d,  BITS, %s, %I64u,  sockets, %d , %d",
           GetTickCount() - g_StartTime,
           JobStateStringOf( state ), progress.BytesTransferred,
           g_TotalSent, g_TotalReceived );

    if (g_NetworkAdapterIndex != 0)
        {
        printf(", net, %d , %d , %d", InOctets, OutOctets, InOctets+OutOctets);
        }

    putchar('\n');
}

void RunTest()
{
    g_job->Resume();

    SetEvent( g_StartEvent );

    g_StartTime = GetTickCount();

    do
        {
        CollectStats();
        Sleep( g_PollInterval );
        }
    while ( long(GetTickCount()) - g_StartTime < (g_Time * 1000 ));

    g_Halt = TRUE;
}

void __cdecl wmain (int argc, wchar_t *argv[])
{
    DWORD err;
    WSADATA WsaData = {0};

    if ((err = WSAStartup(0x0101, &WsaData)) != NO_ERROR)
        {
        printf("unable to init winsock: %d\n", err);
        }

    ParseCmdLine( argc, argv );

    PrepareCommon();
    PrepareWinsock();
    PrepareBits();

    Sleep(1000);

    RunTest();

    CleanupBits();
    CleanupWinsock();
    CleanupCommon();
}

char * AdapterTypeStringOf( DWORD Type )
{
    switch (Type)
        {
        case MIB_IF_TYPE_ETHERNET: return "Ethernet";
        case MIB_IF_TYPE_PPP: return "PPP dial-up";
        case MIB_IF_TYPE_SLIP: return "SLIP dial-up";
        case MIB_IF_TYPE_TOKENRING : return "Token-ring";
        default: return "(unknown type)";
        }
}

void EnumerateAdapters()
{
    PIP_ADAPTER_INFO buf = 0;
    DWORD s;
    DWORD size = 0;

    s = GetAdaptersInfo( NULL, &size );
    if (s != ERROR_BUFFER_OVERFLOW)
        {
        printf("unable to enum adapters: %d\n", s);
        exit(1);
        }

    buf = (PIP_ADAPTER_INFO) malloc( size );
    if (!buf)
        {
        printf("out of memory\n");
        exit(1);
        }

    s = GetAdaptersInfo( buf, &size );
    if (s)
        {
        printf("unable to enum adapters: %d\n", s);
        exit(1);
        }

    while (buf)
        {
        printf("%d: %s %s '%s'  ",
               buf->Index,
               AdapterTypeStringOf( buf->Type),
               buf->IpAddressList.IpAddress.String,
               buf->Description);

        buf = buf->Next;
        }

    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\service\trust.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1998-2000 Microsoft Corporation.  All Rights Reserved.
//
//      No portion of this source code may be reproduced
//      without express written permission of Microsoft Corporation.
//
//      This source code is proprietary and confidential.
//
//  SYSTEM:     Industry Update
//
//  CLASS:      N/A
//  MODULE:     TRUST.LIB
//  FILE:       Trust.CPP
//
/////////////////////////////////////////////////////////////////////
//
//  DESC:   this file implements the functions used to make cabs
//          signed by certain providers trusted.
//
//
//  AUTHOR: Charles Ma, converted from WU CDMLIB
//  DATE:   10/4/2000
//
/////////////////////////////////////////////////////////////////////

//
// This file  is copied from the Windows AutoUpdate sources at \nt\enduser\windows.com\lib\trust\trust.cpp,
// modified to use BITS logging and remove UI.
//

#include "qmgrlib.h"

#include <wintrust.h>
#include <softpub.h>
#include "trust.h"

#if !defined(BITS_V12_ON_NT4)
#include "trust.tmh"
#endif

HMODULE WINAPI LoadLibraryFromSystemDir(LPCTSTR szModule);

/////////////////////////////////////////////////////////////////////////////
//
// typedefs for APIs used in the CheckTrust() function
//
//      Since some of these APIs are new and only available on IE5 we have to
//      try to dynamically use them when available and do without the extra checks
//      when we are on an OS that has not been upgraded to the new crypto code.
//
/////////////////////////////////////////////////////////////////////////////


#define WINTRUST _T("wintrust.dll")
#define CRYPT32  _T("crypt32.dll")

#if !defined(USES_IU_CONVERSION) && defined(USES_CONVERSION)
#define USES_IU_CONVERSION USES_CONVERSION
#endif

//
// declare a global crypt32.dll library handler, so we don't
// need to load the library every time these functions are called.
// NOTE: we do not release the library though. When the process of
// calling this feature exits, the library is released.
// same as wintrust.dll
//
static HINSTANCE shWinTrustDllInst = NULL;
static HINSTANCE shCrypt32DllInst = NULL;


//
// define prototype for function WinVerifyTrust()
// and declare a global variable to point to this function
//
typedef HRESULT
(WINAPI * PFNWinVerifyTrust)(
                        HWND hwnd, GUID *ActionID, LPVOID ActionData);
PFNWinVerifyTrust pfnWinVerifyTrust = NULL;


//
// define prototype for function WTHelperProvDataFromStateData()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_DATA *
(WINAPI * PFNWTHelperProvDataFromStateData)(
                        HANDLE hStateData);
PFNWTHelperProvDataFromStateData pfnWTHelperProvDataFromStateData = NULL;


//
// define prototype for function WTHelperGetProvSignerFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_SGNR *
(WINAPI * PFNWTHelperGetProvSignerFromChain)(
                        CRYPT_PROVIDER_DATA *pProvData,
                        DWORD idxSigner,
                        BOOL fCounterSigner,
                        DWORD idxCounterSigner);
PFNWTHelperGetProvSignerFromChain pfnWTHelperGetProvSignerFromChain = NULL;


//
// define prototype for function PFNWTHelperGetProvCertFromChain()
// and declare a global variable to point to this function
//
typedef CRYPT_PROVIDER_CERT *
(WINAPI * PFNWTHelperGetProvCertFromChain)(
                        CRYPT_PROVIDER_SGNR *pSgnr,
                        DWORD idxCert);
PFNWTHelperGetProvCertFromChain pfnWTHelperGetProvCertFromChain = NULL;


//
// define prototype for function CryptHashPublicKeyInfo()
// and declare a global variable to point to this function
//
typedef BOOL
(WINAPI * PFNCryptHashPublicKeyInfo)(
                        HCRYPTPROV hCryptProv,
                        ALG_ID Algid,
                        DWORD dwFlags,
                        DWORD dwCertEncodingType,
                        PCERT_PUBLIC_KEY_INFO pInfo,
                        BYTE *pbComputedHash,
                        DWORD *pcbComputedHash);
PFNCryptHashPublicKeyInfo pfnCryptHashPublicKeyInfo = NULL;


//
// define prototype for function CertGetCertificateContextProperty()
// and declare a global variable to point to this function
//
typedef BOOL
(WINAPI * PFNCertGetCertificateContextProperty)(
                        PCCERT_CONTEXT pCertContext,
                        DWORD dwPropId,
                        void *pvData,
                        DWORD *pcbData);
PFNCertGetCertificateContextProperty pfnCertGetCertificateContextProperty = NULL;



/////////////////////////////////////////////////////////////////////////////
//
// pre-defined cert data to check against
//
/////////////////////////////////////////////////////////////////////////////

//
// The following are sha1 key identifier for two Microsoft root certificates.
// Note that they are "subject" hashes, not thumbprints or serial numbers.
//
static const BYTE rgbSignerRootKeyIds[40] = {
    0x4A, 0x5C, 0x75, 0x22, 0xAA, 0x46, 0xBF, 0xA4, 0x08, 0x9D,     // the original MS root
    0x39, 0x97, 0x4E, 0xBD, 0xB4, 0xA3, 0x60, 0xF7, 0xA0, 0x1D,     // don't know its validity period

    0x0E, 0xAC, 0x82, 0x60, 0x40, 0x56, 0x27, 0x97, 0xE5, 0x25,     // the new "son of MS root".  For reference,
    0x13, 0xFC, 0x2A, 0xE1, 0x0A, 0x53, 0x95, 0x59, 0xE4, 0xA4      // subject is "Microsoft Root Certificate Authority", valid from May 2001 to May 2021

};


//
// define the size of each hash values in the known id buffer
// for special certs.
//
const size_t ExpectedKnownCertHashSize = 20;

//
// this is the size of buffer to receive the cert hash value
// it must be not less than the largest number in the
// above-defined array
//
const size_t ShaBufSize = 20;

//
// id buffer to store SH1 hashing values of known Microsoft
// certs (signature) that we should recognize.
// Warning: the size of this buffer should match the sum
// of size_t values defined above.
//

// The AutoUpdate code allowed MSNBC and MSN certificates but BITS does not.
//
static const BYTE rgbSpecialCertId[140] = {
    0xB1,0x59,0xA5,0x2E,0x3D,0xD8,0xCE,0xCD,0x3A,0x9A,0x4A,0x7A,0x73,0x92,0xAA,0x8D,0xA7,0xE7,0xD6,0x7F,    // MS cert
//  0xB1,0xC7,0x75,0xE0,0x4A,0x9D,0xFD,0x23,0xB6,0x18,0x97,0x11,0x5E,0xF6,0xEA,0x6B,0x99,0xEC,0x76,0x1D,    // MSN cert
//  0x11,0xC7,0x10,0xF3,0xCB,0x6C,0x43,0xE1,0x66,0xEC,0x64,0x1C,0x7C,0x01,0x17,0xC4,0xB4,0x10,0x35,0x30,    // MSNBC cert
//  0x95,0x25,0x58,0xD4,0x07,0xDE,0x4A,0xFD,0xAE,0xBA,0x13,0x72,0x83,0xC2,0xB3,0x37,0x04,0x90,0xC9,0x8A,    // MSN Europe
    0x72,0x54,0x14,0x91,0x1D,0x6E,0x10,0x84,0x8E,0x0F,0xFA,0xA0,0xB0,0xA1,0x65,0xBF,0x44,0x8F,0x9F,0x6D,    // MS Europe
    0x20,0x5E,0x48,0x43,0xAB,0xAD,0x54,0x77,0x71,0xBD,0x8D,0x1A,0x3C,0xE0,0xE5,0x9D,0xF5,0xBD,0x25,0xF9,    // Old MS cert: 97~98
    0xD6,0xCD,0x01,0x90,0xB3,0x1B,0x31,0x85,0x81,0x12,0x23,0x14,0xB5,0x17,0xA0,0xAA,0xCE,0xF2,0x7B,0xD5,    // Old MS cert: 98~99
    0x8A,0xA1,0x37,0xF5,0x03,0x9F,0xE0,0x28,0xC9,0x26,0xAA,0x55,0x90,0x14,0x19,0x68,0xFA,0xFF,0xE8,0x1A,    // Old MS cert: 99~00
    0xF3,0x25,0xF8,0x67,0x07,0x29,0xE5,0x27,0xF3,0x77,0x52,0x34,0xE0,0x51,0x57,0x69,0x0F,0x40,0xC6,0x1C,    // Old MS Europe cert: 99~00
    0x6A,0x71,0xFE,0x54,0x8A,0x51,0x08,0x70,0xF9,0x8A,0x56,0xCA,0x11,0x55,0xF6,0x76,0x45,0x92,0x02,0x5A     // Old MS Europe cert: 98~99

};




/////////////////////////////////////////////////////////////////////////////
//
// Private Function ULONG CompareMem(PVOID pBlock1, PVOID pBlock2, ULONG Length)
//
//      This function acts in the same way as RtlCompareMemory()
//
//
// Input:   two pointers to two memory blocks, and a byte size to compare
// Return:  the number of bytes that compared as equal.
//          If all bytes compare as equal, the input Length is returned.
//          If any pointer is NULL, 0 is returned.
//
/////////////////////////////////////////////////////////////////////////////
ULONG CompareMem(const BYTE* pBlock1, const BYTE* pBlock2, ULONG Length)
{
    ULONG uLen = 0L;
    if (pBlock1 != NULL && pBlock2 != NULL)
    {
        for (; uLen < Length; uLen++, pBlock1++, pBlock2++)
        {
            if (*pBlock1 != *pBlock2) return uLen;
        }
    }
    return uLen;
}






/////////////////////////////////////////////////////////////////////////////
//
// Private Function VerifyMSRoot()
//
//      This function takes the passed-in certificate as a root cert,
//      and verifies its public key hash value is the same as one of the
//      known "Microsoft Root Authority" cert values.
//
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//          pRootCert - the certificate context of the root cert
//
// Return:  HRESULT - result of execution, S_OK if matched.
//          the result code, in case of error, are code retuned by
//          crypt32.dll, with these the exception of E_INVALIDARG if
//          the passed-in parameters are NULL.
//
/////////////////////////////////////////////////////////////////////////////

HRESULT VerifyMSRoot(
                     HINSTANCE hCrypt32DllInst,         // handle points to loaded crypt32.dll library
                     PCCERT_CONTEXT pRootCert
                     )
{
    HRESULT hr = S_OK;
    BYTE    rgbKeyId[ExpectedKnownCertHashSize];
    DWORD   cbKeyId = sizeof(rgbKeyId);

    LogInfo("VerifyMSRoot()");

    //
    // valid parameter values
    //
    if (NULL == hCrypt32DllInst || NULL == pRootCert)
    {
        hr = E_INVALIDARG;
        goto ErrHandler;
    }

    //
    // get the function we need from the passed in library handle
    // If not available, return error
    //
    if (NULL == (pfnCryptHashPublicKeyInfo = (PFNCryptHashPublicKeyInfo)
        GetProcAddress(hCrypt32DllInst, "CryptHashPublicKeyInfo")))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto ErrHandler;
    }

    //
    // get the public key hash value of this cert
    //
    ZeroMemory(rgbKeyId, sizeof(rgbKeyId));
    if (!pfnCryptHashPublicKeyInfo(
                            0,                      // use default crypto svc provider
                            CALG_SHA1,              // use SHA algorithm
                            0,                      // dwFlags
                            X509_ASN_ENCODING,
                            &pRootCert->pCertInfo->SubjectPublicKeyInfo,
                            rgbKeyId,
                            &cbKeyId
                            ))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto ErrHandler;
    }

    //
    // compare the hash value of public key of this root cert with the known MS root cert values
    //
    if (ExpectedKnownCertHashSize != cbKeyId ||
        (cbKeyId != CompareMem(rgbSignerRootKeyIds, rgbKeyId, cbKeyId) &&
         cbKeyId != CompareMem(rgbSignerRootKeyIds + ExpectedKnownCertHashSize, rgbKeyId, cbKeyId)
        )
       )
    {
        hr = S_FALSE;
    }


ErrHandler:

    if (FAILED(hr))
    {
        LogError("returning %x", hr);
    }
    else
    {
        LogInfo("returning %x", hr);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Private Function VerifySpecialMSCerts()
//
//      This function takes the passed-in certificate as a leaf cert,
//      and verifies its hash value matches the hash value of one of
//      known Microsoft special certs that does not have MS root.
//
//      See definition of rgbSpecialCertId[] for a complete list of certs to match.
//
// Input:   hCrypt32DllInst - handle point to loaded crypt32.dll library
//          pRootCert - the certificate context of the root cert
//          pbSha1HashVal - if not NULL, compare to this one, instead of
//                          hard-coded hash values. this is the case
//                          of working on 3rd party package
//
// Return:  HRESULT - result of execution, S_OK if matched.
//          if not matched, CERT_E_UNTRUSTEDROOT, or
//          E_INVALIDARG if arguments not right, or
//          crypt32.dll error returned by API calls
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyKnownCerts(
                             HINSTANCE hCrypt32DllInst,         // handle point to loaded crypt32.dll librar
                             PCCERT_CONTEXT pLeafCert,
                             pCERT_HASH_ARRAY pKnownCertsData
                             )
{
    HRESULT hr = S_FALSE;
    BYTE    btShaBuffer[ShaBufSize];
    DWORD   dwSize = sizeof(btShaBuffer);
    BYTE const * pId;

    LogInfo("VerifyKnownCerts()");

    //
    // valid parameter values
    //
    if (NULL == hCrypt32DllInst || NULL == pLeafCert)
    {
        hr = E_INVALIDARG;
        goto ErrHandler;
    }

    //
    // get the function we need from the passed in library handle
    // If not available, return error
    //
    if (NULL == (pfnCertGetCertificateContextProperty = (PFNCertGetCertificateContextProperty)
        GetProcAddress(hCrypt32DllInst, "CertGetCertificateContextProperty")))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        goto ErrHandler;
    }

    //
    // find out the id hash of leaf cert
    //
    ZeroMemory(btShaBuffer, dwSize);
    if (!pfnCertGetCertificateContextProperty(
                        pLeafCert,                  // pCertContext
                        CERT_SHA1_HASH_PROP_ID, // dwPropId
                        btShaBuffer,
                        &dwSize
                        ))
    {
        hr = GetLastError();
        goto ErrHandler;
    }


    if (NULL == pKnownCertsData)
    {
        int     i;
        //
        // iterrate through all known id hash values to see if this file is signed
        // with any of these special certs.
        //
        hr = S_FALSE;
        for (i = 0,pId = rgbSpecialCertId;
             i < sizeof(rgbSpecialCertId)/ExpectedKnownCertHashSize;
             i++, pId += ExpectedKnownCertHashSize)
        {
            if (ExpectedKnownCertHashSize == dwSize &&
                dwSize == CompareMem(btShaBuffer, pId, dwSize))
            {
                //
                // found a matching known cert!
                //
                hr = S_OK;
                LogInfo("Found hash matching on #%d of %d MS certs!", i, sizeof(rgbSpecialCertId)/ExpectedKnownCertHashSize);
                break;
            }
        }
    }
    else
    {
        //
        // check if the retrieved hashing value matches the one passed in.
        //
        UINT i;
        LogInfo("Comparing retrieved hash value with passed-in key");
        hr = S_FALSE;
        for (i = 0, pId = pKnownCertsData->pCerts; i < pKnownCertsData->uiCount;
            i++, pId += HASH_VAL_SIZE)
        {
            if (dwSize == HASH_VAL_SIZE &&
                HASH_VAL_SIZE == CompareMem(btShaBuffer, pId, HASH_VAL_SIZE))
            {
                hr = S_OK;
                LogInfo("Found hash matching #%d of %d passed-in certs!",
                            i, pKnownCertsData->uiCount);
                break;
            }
        }
    }

ErrHandler:

    if (FAILED(hr))
    {
        LogError("returning %x", hr);
    }
    else
    {
        LogInfo("returning %x", hr);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// Private Function CheckWinTrust()
//
//      This function will return the HRESULT for the trust state on the
//      specified file. The file can be pointing to any URL or local file.
//      The verification will be done by the wintrust.dll.
//
//      dwCheckRevocation is WTD_REVOKE_NONE (default) or WTD_REVOKE_WHOLE_CHAIN.
//
// Input:   Fully qualified filename, dwCheckRevocation
// Return:  HRESULT - result of execution
//
/////////////////////////////////////////////////////////////////////////////

HRESULT CheckWinTrust(LPCTSTR pszFileName, pCERT_HASH_ARRAY pCertsData, DWORD dwCheckRevocation)
{
    LogInfo("CheckWinTrust()");

    // Now verify the file
    WINTRUST_DATA               winData;
    WINTRUST_FILE_INFO          winFile;
    GUID                        gAction = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    CRYPT_PROVIDER_DATA const   *pProvData = NULL;
    CRYPT_PROVIDER_SGNR         *pProvSigner = NULL;    // recursively call this function if not in test mode so we can show
    // UI for this non-MS but good cert.

    CRYPT_PROVIDER_CERT         *pProvCert = NULL;
    HRESULT                     hr = S_OK;

    //
    // dynamically load the wintrust.dll
    //
    if (NULL == shWinTrustDllInst)
    {
        if (NULL == (shWinTrustDllInst = LoadLibraryFromSystemDir(WINTRUST)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogError("Failed to load library " WINTRUST ", hr %x.", hr);
            goto Done;
        }
    }

    //
    // dynamically load the crypt32.dll, which will be used by the two
    // helper functions to verify the cert is MS cert
    //
    if (NULL == shCrypt32DllInst)
    {
        if (NULL == (shCrypt32DllInst = LoadLibraryFromSystemDir(CRYPT32)))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            LogError("Failed to load library " CRYPT32  ", hr %x.", hr);
            goto Done;
        }
    }
    //
    // find the functions we need
    //
    if (NULL == (pfnWinVerifyTrust = (PFNWinVerifyTrust)
                GetProcAddress(shWinTrustDllInst, "WinVerifyTrust")) ||
        NULL == (pfnWTHelperProvDataFromStateData = (PFNWTHelperProvDataFromStateData)
                GetProcAddress(shWinTrustDllInst, "WTHelperProvDataFromStateData")) ||
        NULL == (pfnWTHelperGetProvSignerFromChain = (PFNWTHelperGetProvSignerFromChain)
                GetProcAddress(shWinTrustDllInst, "WTHelperGetProvSignerFromChain")) ||
        NULL == (pfnWTHelperGetProvCertFromChain = (PFNWTHelperGetProvCertFromChain)
                GetProcAddress(shWinTrustDllInst, "WTHelperGetProvCertFromChain")))
    {
        //
        // at least one function was not found in the loaded cryp32.dll libary.
        // we can not continue, jsut quit.
        // NOTE: this shouldn't happen since we have tried to get
        // the least common denomination of different version of this dll
        // on both IE4 and IE5
        //
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
        LogError("Failed to load procs from " CRYPT32 ", hr %x.", hr);
        goto Done;
    }


    //
    // initialize the data structure used to verify trust
    //
    winFile.cbStruct       = sizeof(WINTRUST_FILE_INFO);
    winFile.hFile          = INVALID_HANDLE_VALUE;
    winFile.pcwszFilePath  = pszFileName;
    winFile.pgKnownSubject = NULL;

    winData.cbStruct            = sizeof(WINTRUST_DATA);
    winData.pPolicyCallbackData = NULL;
    winData.pSIPClientData      = NULL;
    winData.dwUIChoice          = WTD_UI_NONE;
    winData.fdwRevocationChecks = WTD_REVOKE_NONE;
    winData.dwUnionChoice       = WTD_CHOICE_FILE;
    winData.dwStateAction       = WTD_STATEACTION_VERIFY;
    winData.hWVTStateData       = 0;
    winData.dwProvFlags         = WTD_REVOCATION_CHECK_NONE;
    winData.pFile               = &winFile;

    if (dwCheckRevocation == WTD_REVOKE_WHOLECHAIN)
    {
        winData.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;
        winData.dwProvFlags = WTD_REVOCATION_CHECK_CHAIN;
    }

    //
    // verify the signature
    //
    hr = pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

    //
    // Ignore errors when retrieving Cert Revocation List (CRL). This
    // just means the list itself couldn't be retrieved, not that the
    // current cert was invalid or revoked. (KenSh, 2002/01/17)
    //
    if (hr == CERT_E_REVOCATION_FAILURE)
    {
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        //
        // The object isn't signed, so just leave.
        //
        LogError("WinVerifyTrust on '%S' found error 0x%0x.", pszFileName, hr);
        goto Return;
    }

    //
    // if come to here, it means all above verified okay.
    //
    // the rest of code is used to verify the signed cert is a known cert.
    //

    hr = S_FALSE;

    pProvData = pfnWTHelperProvDataFromStateData(winData.hWVTStateData);

    pProvSigner = pfnWTHelperGetProvSignerFromChain(
                                    (PCRYPT_PROVIDER_DATA) pProvData,
                                    0,      // first signer
                                    FALSE,  // not a counter signer
                                    0);

    //
    // check root cert then check leaf (signing) cert if that fails
    //
    // 0 is signing cert, csCertChain-1 is root cert
    //


    if (NULL == pCertsData)
    {
        //
        // if caller does not specify a hash value, then it means we want
        // to verify if this cert is known MS cert. We will first
        // try to find out if it is signed with a cert that has MS as root.
        //
        pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, pProvSigner->csCertChain - 1);
        hr = VerifyMSRoot(shCrypt32DllInst, pProvCert->pCert);
    }

    if (S_OK != hr)
    {
        pProvCert =  pfnWTHelperGetProvCertFromChain(pProvSigner, 0);

        hr = VerifyKnownCerts(shCrypt32DllInst, pProvCert->pCert, pCertsData);
    }

Return:

    //
    // free the wintrust state that was used to get the cert in the chain
    //
    winData.dwStateAction = WTD_STATEACTION_CLOSE;
    pfnWinVerifyTrust( (HWND)0, &gAction, &winData);

    //
    // Only the two functions checking MS cert will return S_FALSE
    //
    if (S_OK != hr)
        {
        LogError("CheckWinTrust() found file not signed by a known cert!");
        LogError("Digital Signatures on file %S are not trusted, hr %x",  pszFileName, hr);
        hr = TRUST_E_SUBJECT_NOT_TRUSTED;
        }
    else
        {
        LogInfo("CheckWinTrust(%S) returns S_OK", pszFileName);
        }

Done:
    if (NULL != shWinTrustDllInst)
    {
        FreeLibrary(shWinTrustDllInst);
        shWinTrustDllInst = NULL;
    }
    if (NULL != shCrypt32DllInst)
    {
        FreeLibrary(shCrypt32DllInst);
        shCrypt32DllInst = NULL;
    }

    return (hr);
}



/////////////////////////////////////////////////////////////////////////////
//
// Public Function VerifyFileTrust()
//
// This is a wrapper function for CheckWinTrust that both Whistler
// and WU classic code should use.
//
// Input:
//      szFileName - the file with complete path
//      pCertsData - hash value of a known good cert, or NULL to use the default list
//      fCheckRevocation - TRUE to check against a CRL, FALSE to skip the CRL check
//
// Return:  HRESULT - S_OK the file is signed with a valid known cert
//                    or error code.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT VerifyFileTrust(
                        IN LPCTSTR szFileName,
                        IN pCERT_HASH_ARRAY pCertsData,
                        BOOL fCheckRevocation /*=FALSE*/
                        )
{
    DWORD dwCheckRevocation = fCheckRevocation ? WTD_REVOKE_WHOLECHAIN : WTD_REVOKE_NONE;

    return CheckWinTrust(szFileName, pCertsData, dwCheckRevocation);
}

// **************************************************************************
static
BOOL UseFullPath(void)
{
    static BOOL s_fUseFullPath = TRUE;
    static BOOL s_fInit        = FALSE;

    OSVERSIONINFO   osvi;

    if (s_fInit)
        return s_fUseFullPath;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);

    if (GetVersionEx(&osvi))
    {
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT &&
            (osvi.dwMajorVersion > 5 ||
             (osvi.dwMajorVersion == 5 && osvi.dwMinorVersion >= 1)))
        {
            s_fUseFullPath = FALSE;
        }

        s_fInit = TRUE;
    }

    return s_fUseFullPath;
}

// **************************************************************************
HMODULE WINAPI LoadLibraryFromSystemDir(LPCTSTR szModule)
/*
        Loads a module in a safe way, immune to fake DLLs placed in the current directory or other
        parts of the default search path.
*/
{
    HRESULT hr = NOERROR;
    HMODULE hmod = NULL;
    TCHAR   szModulePath[MAX_PATH + 1];

    if (szModule == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto done;
    }

    if (UseFullPath())
        {
        DWORD cch;

        // if the function call fails, make the buffer an empty string, so
        //  we will just use the dll name in the append below.
        cch = GetSystemDirectory(szModulePath, RTL_NUMBER_OF(szModulePath));
        if (cch == 0 || cch >= RTL_NUMBER_OF(szModulePath))
            {
            szModulePath[0] = _T('\0');
            }
        else
            {
            hr = StringCchCat( szModulePath, RTL_NUMBER_OF(szModulePath), _T("\\") );
            if (FAILED(hr))
                {
                SetLastError(HRESULT_CODE(hr));
                goto done;
                }
            }
        }
    else
        {
        szModulePath[0] = _T('\0');
        }

    hr = StringCchCat( szModulePath, RTL_NUMBER_OF(szModulePath), szModule );
    if (FAILED(hr))
        {
        SetLastError(HRESULT_CODE(hr));
        goto done;
        }

    hmod = LoadLibraryEx(szModulePath, NULL, 0);
    if (hmod == NULL)
        goto done;

done:
    return hmod;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\tests\misc\https.cpp ===
#define UNICODE
#include "windows.h"
#include "winhttp.h"
#include "stdio.h"

#define INLINE_SET

bool
ApplyCredentials(
    HINTERNET hRequest
    );

bool
ApplyServerCredentials(
    HINTERNET hRequest
    );

void wmain (int argc, wchar_t *argv[])
{
    DWORD dwFlags = 0;
    HINTERNET hInternet = 0;
    HINTERNET hConnect = 0;
    HINTERNET hRequest = 0;

    if (argc < 5 || (0 != wcsicmp(argv[1], L"HEAD") && 0 != wcsicmp(argv[1], L"GET")))
        {
        printf("usage: \n"
                  "    https {GET | HEAD}  <proxy> <proxy-username> <proxy-password>\n"
               );
        return;
        }

    printf("verb: %S,  proxy %S, username %S, password %S\n",
           argv[1], argv[2], argv[3], argv[4] );

    const WCHAR * const C_BITS_USER_AGENT = L"Microsoft BITS/6.5";

    hInternet = WinHttpOpen( C_BITS_USER_AGENT,
                              WINHTTP_ACCESS_TYPE_NO_PROXY,
                              NULL,
                              NULL,
                              0 );

    if (! hInternet )
        {
        printf("internet %d\n", GetLastError());
        }

    if (! (hConnect = WinHttpConnect( hInternet,
                                            L"bitsnet",
                                            INTERNET_DEFAULT_HTTP_PORT,
                                            0)))                //context
        {
        printf("connect %d\n", GetLastError());
        }


    LPCWSTR AcceptTypes[] = {L"*/*", NULL};

    if (! (hRequest = WinHttpOpenRequest(
        hConnect,
        argv[1],
        L"/dload/security/basic/500k.zip",
        L"HTTP/1.1",
        NULL,               //referer
        AcceptTypes,
        dwFlags)))
        {
        printf("open %d\n", GetLastError());
        }

    // security-callback calls go here

    //

    WINHTTP_PROXY_INFO ProxyInfo;

    ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
    ProxyInfo.lpszProxy       = argv[2]; // L"172.26.242.86:8080";  // formerly bitsisa:8080
    ProxyInfo.lpszProxyBypass = NULL;

    if (!WinHttpSetOption( hRequest,
                           WINHTTP_OPTION_PROXY,
                           &ProxyInfo,
                           sizeof(ProxyInfo)
                           ))
        {
        DWORD err = GetLastError();

        printf( "can't set proxy option: %d", err );
        }

    //

    bool done = false;

    do
        {
        BOOL b;

        printf("sending...");

        b = WinHttpSendRequest( hRequest,
                                0,
                                0,
                                0,
                                0,
                                0,
                                0
                                );
        if (!b)
            {
            printf("send %d\n", GetLastError());
            }

        printf("\n");

        b = WinHttpReceiveResponse( hRequest, 0 );
        if (!b)
            {
            printf("receive %d\n", GetLastError());
            }

        // check status
        DWORD dwStatus;
        DWORD dwLength = sizeof(dwStatus);

        if (! WinHttpQueryHeaders( hRequest,
                             WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                             LPCWSTR(&dwStatus),
                             &dwStatus,
                             &dwLength,
                             NULL))
            {
            printf("can't query status %d\n", GetLastError());
            }

        printf("dwStatus %d\n", dwStatus );

        switch (dwStatus)
            {
            case 200: done = true; break;

            case 407:
                {
                printf("setting proxy creds: target 1, scheme 8...");
                if (!WinHttpSetCredentials( hRequest,
                                            1,
                                            0x8,
                                            argv[3], // L"dbitsusr",        // formerly bitsisa\\butsusr
                                            argv[4], //L"Bits1Usr1",
                                            NULL
                                            ))
                    {
                    printf("set-cred failed %d\n", GetLastError());
                    }

                break;
                }

            case 401:
                {
                printf("setting server creds: target 0, scheme 1...\n");
                if (!WinHttpSetCredentials( hRequest,
                                            0,
                                            0x1,
                                            argv[3],
                                            argv[4],
                                            NULL
                                            ))
                    {
                    printf("set-cred failed %d\n", GetLastError());
                    }
#if 0
                printf("setting proxy creds: target 1, scheme 8...\n");
                if (!WinHttpSetCredentials( hRequest,
                                            1,
                                            0x8,
                                            argv[3], // L"dbitsusr",        // formerly bitsisa\\butsusr
                                            argv[4], //L"Bits1Usr1",
                                            NULL
                                            ))
                    {
                    printf("set-cred failed %d\n", GetLastError());
                    }
#endif
                break;
                }

            default:
                {
                done = true;
                }
            }
        }
    while ( !done );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\utils\helpers.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    helpers.cpp

Abstract :

    General helper functions.

Author :

Revision History :

 ***********************************************************************/

#include "qmgrlibp.h"
#include <bitsmsg.h>
#include <sddl.h>
#include <shlwapi.h>

#include "helpers.tmh"

FILETIME GetTimeAfterDelta( UINT64 uDelta )
{
    FILETIME ftCurrentTime;
    GetSystemTimeAsFileTime( &ftCurrentTime );
    UINT64 uCurrentTime = FILETIMEToUINT64( ftCurrentTime );
    uCurrentTime += uDelta;

    return UINT64ToFILETIME( uCurrentTime );
}


//---------------------------------------------------------------------
//  QmgrFileExists
//      Checks if a file exists.
//
//  Returns:  TRUE if false exists, FALSE otherwise
//---------------------------------------------------------------------
BOOL QMgrFileExists(LPCTSTR szFile)
{
    DWORD dwAttr = GetFileAttributes(szFile);

    if (dwAttr == 0xFFFFFFFF)   //failed
        return FALSE;

    return (BOOL)(!(dwAttr & FILE_ATTRIBUTE_DIRECTORY));
}

//
// Class for managing global static data that is different per installation
//

class GlobalInfo *g_GlobalInfo = NULL;

GlobalInfo::GlobalInfo( TCHAR * QmgrDirectory,
                        LARGE_INTEGER PerformanceCounterFrequency,
                        HKEY QmgrRegistryRoot,
                        UINT64 JobInactivityTimeout,
                        UINT64 TimeQuantaLength,
                        UINT32 DefaultNoProgressTimeout,
                        UINT32 DefaultMinimumRetryDelay,
                        SECURITY_DESCRIPTOR *MetadataSecurityDescriptor,
                        DWORD MetadataSecurityDescriptorLength,
                        SidHandle AdministratorsSid,
                        SidHandle LocalSystemSid,
                        SidHandle NetworkUsersSid,
                        SidHandle AnonymousSid
                        ) :
    m_QmgrDirectory( QmgrDirectory ),
    m_PerformanceCounterFrequency( PerformanceCounterFrequency ),
    m_QmgrRegistryRoot( QmgrRegistryRoot ),
    m_JobInactivityTimeout( JobInactivityTimeout ),
    m_TimeQuantaLength( TimeQuantaLength ),
    m_DefaultNoProgressTimeout( DefaultNoProgressTimeout ),
    m_DefaultMinimumRetryDelay( DefaultMinimumRetryDelay ),
    m_MetadataSecurityDescriptor( MetadataSecurityDescriptor ),
    m_MetadataSecurityDescriptorLength( MetadataSecurityDescriptorLength ),
    m_AdministratorsSid( AdministratorsSid ),
    m_LocalSystemSid( LocalSystemSid ),
    m_NetworkUsersSid( NetworkUsersSid ),
    m_AnonymousSid( AnonymousSid )
{
}

GlobalInfo::~GlobalInfo()
{
    delete[] (TCHAR*)m_QmgrDirectory;
    delete (SECURITY_DESCRIPTOR*)m_MetadataSecurityDescriptor;

    if ( m_QmgrRegistryRoot )
       CloseHandle( m_QmgrRegistryRoot );
}

DWORD
GlobalInfo::RegGetDWORD(
    HKEY hKey,
    const TCHAR * pValue,
    DWORD dwDefault )
{
    DWORD dwValue;
    DWORD dwType = REG_DWORD;
    DWORD dwSize = sizeof(dwValue);

    LONG lResult =
        RegQueryValueEx(  //SEC: REVIEWED 2002-03-28
            hKey,
            pValue,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &dwSize );

    if ( ERROR_SUCCESS != lResult ||
         dwType != REG_DWORD ||
         dwSize != sizeof(dwValue)
         )
        {
        LogWarning( "Unable to read the registry value %!ts!, using default value of %u",
                    pValue, dwDefault );
        return dwDefault;
        }

    LogInfo( "Retrieved registry value %u from key value %!ts!",
             dwValue, pValue );
    return dwValue;
}

SidHandle
BITSAllocateAndInitializeSid(
    BYTE nSubAuthorityCount,                        // count of subauthorities
    DWORD dwSubAuthority0,                          // subauthority 0
    DWORD dwSubAuthority1 )                         // subauthority 1
{

    ASSERT( nSubAuthorityCount <= 2 );

    SID_IDENTIFIER_AUTHORITY Authority = SECURITY_NT_AUTHORITY;
    PSID pSid = NULL;

    if(! AllocateAndInitializeSid( //SEC: REVIEWED 2002-03-28
             &Authority,
             nSubAuthorityCount,
             dwSubAuthority0,
             dwSubAuthority1,
             0, 0, 0, 0, 0, 0,
             &pSid) )
        {
        HRESULT hResult = HRESULT_FROM_WIN32(GetLastError());
        LogError( "AllocateAndInitializeSid failed, error %!winerr!\n" , hResult );
        throw ComError( hResult );
        }

    SidHandle NewSid( DuplicateSid( pSid ) );
    FreeSid( pSid );
    pSid = NULL;

    if ( !NewSid.get())
        {
        LogError( "Unable to duplicate sid, error %!winerr!\n" , E_OUTOFMEMORY );
        throw ComError( E_OUTOFMEMORY );
        }

    return NewSid;
}

StringHandle
BITSSHGetFolderPath(
    HWND hwndOwner,
    int nFolder,
    HANDLE hToken,
    DWORD dwFlags )
{

    auto_ptr<WCHAR> Folder( new WCHAR[ MAX_PATH ] );

    HRESULT hResult =
        SHGetFolderPath(
                    hwndOwner,
                    nFolder,
                    hToken,
                    dwFlags,
                    Folder.get() );

    if (FAILED(hResult))
        {
        LogError( "SHGetFolderPathFailed, error %!winerr!", hResult );
        throw ComError( hResult );
        }

    return StringHandle( Folder.get() );
}


HRESULT GlobalInfo::Init()
/*
    Initialize the global info for BITS.
*/

{
    GlobalInfo *pGlobalInfo = NULL;
    HKEY hQmgrKey = NULL;
    HKEY hQmgrPolicyKey = NULL;
    PACL pDacl = NULL;

    LogInfo( "Starting init of global info\n" );

    try
        {
        DWORD dwResult;
        HRESULT hResult = E_FAIL;
        DWORD dwReturnLength;

        LARGE_INTEGER PerformanceCounterFrequency;
        BOOL bResult = QueryPerformanceFrequency( &PerformanceCounterFrequency );
        if ( !bResult )
            throw ComError( E_FAIL );

        SidHandle AdministratorsSid =
            BITSAllocateAndInitializeSid(
                 2,
                 SECURITY_BUILTIN_DOMAIN_RID,
                 DOMAIN_ALIAS_RID_ADMINS );

        SidHandle LocalSystemSid =
            BITSAllocateAndInitializeSid(
                1,
                SECURITY_LOCAL_SYSTEM_RID, 0 );


        SidHandle NetworkUsersSid =
            BITSAllocateAndInitializeSid(
                1,
                SECURITY_NETWORK_RID, 0);

        SidHandle AnonymousSid =
            BITSAllocateAndInitializeSid(
                1,
                SECURITY_ANONYMOUS_LOGON_RID, 0);

        // initialize the metadata's security descriptor.

        auto_ptr<char> TempSDDataPtr( new char[SECURITY_DESCRIPTOR_MIN_LENGTH] );
        PSECURITY_DESCRIPTOR pTempSD = (PSECURITY_DESCRIPTOR)TempSDDataPtr.get();
        InitializeSecurityDescriptor(pTempSD, SECURITY_DESCRIPTOR_REVISION);   //SEC: REVIEWED 2002-03-28

        auto_ptr<EXPLICIT_ACCESS> ExplicitAccessPtr( new EXPLICIT_ACCESS[2] );
        EXPLICIT_ACCESS *ExplicitAccess = ExplicitAccessPtr.get();
        memset( ExplicitAccess, 0, sizeof(EXPLICIT_ACCESS) * 2);  //SEC: REVIEWED 2002-03-28

        ExplicitAccess[0].grfAccessPermissions  = GENERIC_ALL;
        ExplicitAccess[0].grfAccessMode         = SET_ACCESS;
        ExplicitAccess[0].grfInheritance        = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[0].Trustee.TrusteeForm   = TRUSTEE_IS_SID;
        ExplicitAccess[0].Trustee.TrusteeType   = TRUSTEE_IS_GROUP;
        ExplicitAccess[0].Trustee.ptstrName     = (LPTSTR) AdministratorsSid.get();

        ExplicitAccess[1].grfAccessPermissions  = GENERIC_ALL;
        ExplicitAccess[1].grfAccessMode         = SET_ACCESS;
        ExplicitAccess[1].grfInheritance        = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[1].Trustee.TrusteeForm   = TRUSTEE_IS_SID;
        ExplicitAccess[1].Trustee.TrusteeType   = TRUSTEE_IS_USER;
        ExplicitAccess[1].Trustee.ptstrName     = (LPTSTR) LocalSystemSid.get();

        dwResult = SetEntriesInAcl( //SEC: REVIEWED 2002-03-28
            2,
            ExplicitAccess,
            NULL,
            &pDacl );

        if ( ERROR_SUCCESS != dwResult )
            {
            hResult = HRESULT_FROM_WIN32( dwResult );
            LogError( "SetEntiesInAcl, error %!winerr!\n", hResult );
            throw ComError( hResult );
            }

        if (!SetSecurityDescriptorDacl( //SEC: REVIEWED 2002-03-28
            pTempSD,
            TRUE,     // fDaclPresent flag
            pDacl,
            FALSE))   // not a default DACL
        {
            hResult = HRESULT_FROM_WIN32( GetLastError() );
            LogError( "SetSecurityDescriptorDacl, error %!winerr!", hResult );
            throw ComError( hResult );
        }

        DWORD dwRequiredSecurityDescriptorLength = 0;
        MakeSelfRelativeSD( pTempSD, NULL, &dwRequiredSecurityDescriptorLength );

        auto_ptr<SECURITY_DESCRIPTOR> pMetadataSecurityDescriptor(
            (SECURITY_DESCRIPTOR*)new char[dwRequiredSecurityDescriptorLength] );

        if (!pMetadataSecurityDescriptor.get())
            {
            throw ComError( E_OUTOFMEMORY );
            }

        if (!MakeSelfRelativeSD( pTempSD, pMetadataSecurityDescriptor.get(), &dwRequiredSecurityDescriptorLength ) )
        {
           hResult = HRESULT_FROM_WIN32(GetLastError());
           LogError( "MakeSelfRelativeSD, error %!winerr!", hResult );
           throw ComError( hResult );
        }

        LocalFree( pDacl );
        pDacl = NULL;

        SECURITY_ATTRIBUTES MetadataSecurityAttributes;
        MetadataSecurityAttributes.nLength = sizeof(MetadataSecurityAttributes);
        MetadataSecurityAttributes.lpSecurityDescriptor = pMetadataSecurityDescriptor.get();
        MetadataSecurityAttributes.bInheritHandle = FALSE;

        // Build path where the metadata will be stored.

        StringHandle AllUsersDirectory =
            BITSSHGetFolderPath(
                NULL,
                CSIDL_COMMON_APPDATA,
                NULL,
                SHGFP_TYPE_CURRENT );

        size_t Length = lstrlen( AllUsersDirectory ) + lstrlen(C_QMGR_DIRECTORY) + 1; //SEC: REVIEWED 2002-03-28

        auto_ptr<TCHAR> QmgrDirectory( new TCHAR[ Length ] );

        // Create the Application Data\Microsoft\Network directory if needed.
        // Its access permissions should be inherited from the parent.
        //
        THROW_HRESULT( StringCchCopy( QmgrDirectory.get(), Length, AllUsersDirectory ));
        THROW_HRESULT( StringCchCat( QmgrDirectory.get(), Length, C_QMGR_PARENT_DIRECTORY ));

        dwResult = GetFileAttributes( QmgrDirectory.get() );
        if ( (-1 == dwResult) || !(dwResult & FILE_ATTRIBUTE_DIRECTORY))
            {
            LogError( "parent directory doesn't exist, attempt to create %!ts!.\n", QmgrDirectory.get() );

            bResult = CreateDirectory(QmgrDirectory.get(), NULL ); //SEC: REVIEWED 2002-08-16
            if ( !bResult )
                {
                hResult = HRESULT_FROM_WIN32( GetLastError() );
                LogError( "Unable to create parent directory, error %!winerr!\n", hResult );
                throw ComError( hResult );
                }
            }

        // Create the BITS directory if needed.
        // Its permissions should be restrictive because we don't want non-admins to be able to read our files.
        //
        THROW_HRESULT( StringCchCopy( QmgrDirectory.get(), Length, AllUsersDirectory ));
        THROW_HRESULT( StringCchCat( QmgrDirectory.get(), Length, C_QMGR_DIRECTORY ));

        dwResult = GetFileAttributes( QmgrDirectory.get() );
        if ( (-1 == dwResult) || !(dwResult & FILE_ATTRIBUTE_DIRECTORY))
            {
            LogError( "BITS directory doesn't exist, attempt to create %!ts!.\n", QmgrDirectory.get() );

            bResult = CreateDirectory(QmgrDirectory.get(), &MetadataSecurityAttributes); //SEC: REVIEWED 2002-03-28
            if ( !bResult )
                {
                hResult = HRESULT_FROM_WIN32( GetLastError() );
                LogError( "Unable to create BITS directory, error %!winerr!\n", hResult );
                throw ComError( hResult );
                }
            }

        // Open the main policy registry key
        dwResult =
            (DWORD)RegOpenKey(
                HKEY_LOCAL_MACHINE,
                C_QMGR_POLICY_REG_KEY,
                &hQmgrPolicyKey);

        if ( ERROR_SUCCESS != dwResult )
            {
            LogWarning("Unable to open the main policy registry key\n");
            }

        // Open the main qmgr registry key
        dwResult =
            (DWORD)RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,         // root key
                C_QMGR_REG_KEY,             // subkey
                0,                          // reserved
                NULL,                       // class name
                REG_OPTION_NON_VOLATILE,    // option
                KEY_ALL_ACCESS,             // security  // SEC: REVIEWED 2002-03-28
                &MetadataSecurityAttributes,// security attribute
                &hQmgrKey,
                NULL);

        if ( ERROR_SUCCESS != dwResult )
            {
            hResult = HRESULT_FROM_WIN32( dwResult );
            LogError( "Unable to open main BITS key, error %!winerr!\n", hResult );
            throw ComError( hResult );
            }

        UINT64 JobInactivityTimeout;
        // Get the inactivity timeout value for job;
        {
           DWORD dwValue;
           DWORD dwType = REG_DWORD;
           DWORD dwSize = sizeof(dwValue);

           LONG lResult;

           if ( hQmgrPolicyKey )
               {
               lResult =
               RegQueryValueEx(    //SEC: REVIEWED 2002-03-28
                   hQmgrPolicyKey,
                   C_QMGR_JOB_INACTIVITY_TIMEOUT,
                   NULL,
                   &dwType,
                   (LPBYTE)&dwValue,
                   &dwSize );
               }

           if ( !hQmgrPolicyKey ||
                ERROR_SUCCESS != lResult ||
                dwType != REG_DWORD ||
                dwSize != sizeof(dwValue)
                )
               {
               JobInactivityTimeout =
                   RegGetDWORD( hQmgrKey, C_QMGR_JOB_INACTIVITY_TIMEOUT, C_QMGR_JOB_INACTIVITY_TIMEOUT_DEFAULT);
               JobInactivityTimeout *= NanoSec100PerSec;

               }
           else
               {
               LogInfo("Retrieved job inactivity timeout of %u days from policy", dwValue );
               JobInactivityTimeout = dwValue * NanoSec100PerSec * 60/*secs per min*/ * 60/*mins per hour*/ * 24 /* hours per day*/;
               }
        }

        UINT64 TimeQuantaLength =
            RegGetDWORD( hQmgrKey, C_QMGR_TIME_QUANTA_LENGTH, C_QMGR_TIME_QUANTA_LENGTH_DEFAULT );
        TimeQuantaLength *= NanoSec100PerSec;

        UINT32 DefaultNoProgressTimeout = // global data is in seconds.
            RegGetDWORD( hQmgrKey, C_QMGR_NO_PROGRESS_TIMEOUT, C_QMGR_NO_PROGRESS_TIMEOUT_DEFAULT );

        UINT32 DefaultMinimumRetryDelay = // global data is in seconds
            RegGetDWORD( hQmgrKey, C_QMGR_MINIMUM_RETRY_DELAY, C_QMGR_MINIMUM_RETRY_DELAY_DEFAULT );

        pGlobalInfo =
            new GlobalInfo( QmgrDirectory.get(),
                            PerformanceCounterFrequency,
                            hQmgrKey,
                            JobInactivityTimeout,
                            TimeQuantaLength,
                            DefaultNoProgressTimeout,
                            DefaultMinimumRetryDelay,
                            pMetadataSecurityDescriptor.get(),
                            dwRequiredSecurityDescriptorLength,
                            AdministratorsSid,
                            LocalSystemSid,
                            NetworkUsersSid,
                            AnonymousSid
                            );

        if ( !pGlobalInfo )
            throw ComError( E_OUTOFMEMORY );

        QmgrDirectory.release();
        pMetadataSecurityDescriptor.release();
        if ( hQmgrPolicyKey )
            CloseHandle( hQmgrPolicyKey );
        }

    catch( ComError Error )
        {
        LogError( "An exception occured creating global info, error %!winerr!", Error.Error() );

        if ( hQmgrKey )
            CloseHandle( hQmgrKey );
        hQmgrKey = NULL;

        if ( hQmgrPolicyKey )
            CloseHandle( hQmgrPolicyKey );
        hQmgrPolicyKey = NULL;

        // LocalFree has if guard
        LocalFree( pDacl );

        return Error.Error();
        }

    LogInfo( "Finished init of global info" );
    g_GlobalInfo = pGlobalInfo;
    return S_OK;
}

HRESULT GlobalInfo::Uninit()
{
    delete g_GlobalInfo;
    g_GlobalInfo = NULL;
    return S_OK;
}

LONG
ExternalFuncExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    )
{
    // This function is called by the exception filter that wraps external functions.
    // The purpose is to treat unhandled exceptions as unhandled instead of propagating
    // across the network

    // If this exception is a MSVCRT exception, bash the exception code
    // so that MSVCRT won't call ExitProcess.

    if ( ExceptionInfo &&
         ExceptionInfo->ExceptionRecord &&
         ('msc' | 0xE0000000) == ExceptionInfo->ExceptionRecord->ExceptionCode )
    {
        ExceptionInfo->ExceptionRecord->ExceptionCode = ('BIT' | 0xE0000000);
    }

    LONG Result = UnhandledExceptionFilter( ExceptionInfo );

    if ( EXCEPTION_CONTINUE_SEARCH == Result )
        {
        // Need to act like the dispatcher.  Call kernel again specifying second change semantics
        NtRaiseException( ExceptionInfo->ExceptionRecord, ExceptionInfo->ContextRecord, FALSE );
        }
    // exception handler returns RPC_E_SERVERFAULT
    return EXCEPTION_EXECUTE_HANDLER;
}

SidHandle & SidHandle::operator=( const SidHandle & r )
{
    if (m_pValue == r.m_pValue )
        {
        return *this;
        }

    if (InterlockedDecrement(m_pRefs) == 0)
        {
        delete m_pRefs;
        delete m_pValue;
        }

    m_pValue = r.m_pValue;
    m_pRefs  = r.m_pRefs;

    InterlockedIncrement(m_pRefs);

    return *this;
}

StringHandle::StringData StringHandle::s_EmptyString =
    {
        0, 1, { L'\0' }     // Initialize with 1 ref so it is never deleted
    };

bool
CSidSorter::operator()(
    const SidHandle & handle1,
    const SidHandle & handle2
    ) const
{
    const PSID psid1 = handle1.get();
    const PSID psid2 = handle2.get();

    if ( !psid1 || !psid2 )
        return (INT_PTR)psid1 < (INT_PTR)psid2;

    if (*GetSidSubAuthorityCount( psid1 ) < *GetSidSubAuthorityCount( psid2 ))
        {
        return true;
        }

    // at this point, we known psd1 is >= psd2.   // Stop if psid1 is
    // longer so that the preceding for loop doesn't overstep the sid
    // array on psd2.
    if ( *GetSidSubAuthorityCount( psid1 ) > *GetSidSubAuthorityCount( psid2 ) )
        return false;

    // arrays have equal length

    for (UCHAR i=0; i < *GetSidSubAuthorityCount( psid1 ); ++i)
        {
        if (*GetSidSubAuthority( psid1, i ) < *GetSidSubAuthority( psid2, i ))
            return true; // sid1 is less then sid2
        else if ( *GetSidSubAuthority( psid1, i ) > *GetSidSubAuthority( psid2, i ) )
            return false; // sid1 is greater then sid2

        // subauthorities are the same, move on to the next subauthority
        }

    // arrays are identical
    return false;
}

//------------------------------------------------------------------------

PSID DuplicateSid( PSID _Sid )
/*++

Routine Description:

    Clones a SID.  The new SID is allocated using the global operator new.

At entry:

    _Sid is the SID to clone.

At exit:

    the return is NULL if an error occurs, otherwise a pointer to the new SID.

--*/
{
    DWORD Length = GetLengthSid( _Sid );
    SID * psid;

    try
    {
        psid = (SID *) new char[Length];
    }
    catch( ComError Error )
    {
        return NULL;
    }

    if (!CopySid( Length, psid, _Sid )) // SEC: REVIEWED 2002-03-28
        {

        delete[] psid;
        return NULL;
        }

    return psid;
}

LPCWSTR
TruncateString( LPCWSTR String, SIZE_T MaxLength, auto_ptr<WCHAR> & AutoPointer )
{
    if ( wcslen( String ) <= MaxLength ) // SEC: REVIEWED 2002-03-28
        return String;

    AutoPointer = auto_ptr<WCHAR>( new WCHAR[ MaxLength + 1 ] );
    wcsncpy( AutoPointer.get(), String, MaxLength ); // SEC: REVIEWED 2002-03-28
    AutoPointer.get()[ MaxLength ] = L'\0';
    return AutoPointer.get();

}

PLATFORM_PRODUCT_VERSION g_PlatformVersion;
DWORD  g_PlatformMajorVersion;
DWORD  g_PlatformMinorVersion;

bool bIsWin9x;

BOOL DetectProductVersion()
{

   OSVERSIONINFO VersionInfo;
   VersionInfo.dwOSVersionInfoSize = sizeof( VersionInfo );

   if ( !GetVersionEx( &VersionInfo ) )
       return FALSE;

   g_PlatformMajorVersion = VersionInfo.dwMajorVersion;
   g_PlatformMinorVersion = VersionInfo.dwMinorVersion;

   switch( VersionInfo.dwPlatformId )
       {

       case VER_PLATFORM_WIN32_WINDOWS:
           g_PlatformVersion = ( VersionInfo.dwMajorVersion > 0 ) ?
               WIN98_PLATFORM : WIN95_PLATFORM;
           bIsWin9x = true;
           return TRUE;

       case VER_PLATFORM_WIN32_NT:
           bIsWin9x = false;

           if ( VersionInfo.dwMajorVersion < 5 )
              return FALSE;

           if ( VersionInfo.dwMajorVersion > 5 )
               {
               g_PlatformVersion = WINDOWSXP_PLATFORM;
               return TRUE;
               }

           g_PlatformVersion = ( VersionInfo.dwMinorVersion > 0 ) ?
               WINDOWSXP_PLATFORM : WINDOWS2000_PLATFORM;

           return TRUE;

       default:
           return FALSE;

       }
}


StringHandle
CombineUrl(
    LPCWSTR BaseUrl,
    LPCWSTR RelativeUrl,
    DWORD Flags
    )
{
    DWORD Length = 0;
    HRESULT hr;

    hr = UrlCombine( BaseUrl,
                     RelativeUrl,
                     0,
                     &Length,
                     Flags
                     );

    if (hr != E_POINTER)
        {
        ASSERT( FAILED(hr) );

        throw ComError( hr );
        }

    auto_ptr<WCHAR> AbsoluteUrl ( new WCHAR[ Length ] );

    THROW_HRESULT( UrlCombine( BaseUrl,
                               RelativeUrl,
                               AbsoluteUrl.get(),
                               &Length,
                               Flags
                               ));

    //
    // The string handle constructor clones the auto_ptr.
    //
    return AbsoluteUrl.get();
}

bool IsAnyDebuggerPresent()
{
    if (IsDebuggerPresent())
        {
        return true;
        }

    SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo = { 0 };

    NtQuerySystemInformation(
            SystemKernelDebuggerInformation,
            &KdInfo,
            sizeof(KdInfo),
            NULL);

    if (KdInfo.KernelDebuggerEnabled)
        {
        return true;
        }

    return false;
}

LPWSTR MidlCopyString( LPCWSTR source, size_t Length )
{
    if (Length == -1)
        {
        Length = 1+wcslen( source ); // SEC: REVIEWED 2002-03-28
        }

    LPWSTR copy = reinterpret_cast<LPWSTR>( CoTaskMemAlloc( Length * sizeof( wchar_t )));
    if (!copy)
        {
        return NULL;
        }

    if (FAILED(StringCchCopy( copy, Length, source )))
        {
        CoTaskMemFree( copy );
        return NULL;
        }

    return copy;
}

LPWSTR CopyString( LPCWSTR source, size_t Length )
{
    if (Length == -1)
        {
        Length = 1+wcslen( source ); // SEC: REVIEWED 2002-03-28
        }

    CAutoString copy( new wchar_t[ Length ]);

    THROW_HRESULT( StringCchCopy( copy.get(), Length, source ));

    return copy.release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\utils\cfreg.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cfreg.cpp

Abstract :

    Registry wrapper functions.

Author :

Revision History :

 ***********************************************************************/
#include "qmgrlibp.h"

#if !defined(BITS_V12_ON_NT4)
#include "cfreg.tmh"
#endif

////////////////////////////////////////////////////////////////////////////
//
// Public Function  GetRegStringValue()
//                  Read the registry value of timestamp for last detection
// Input:   Name of value
// Output:  SYSTEMTIME structure contains the time
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int iBufferSize)
{
    HKEY        hKey;
    DWORD       dwType = REG_SZ;
    DWORD       dwSize = iBufferSize;
    DWORD       dwRet;

    if (lpszValueName == NULL || lpszBuffer == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // query the last timestamp value
    //
    dwRet = RegQueryValueEx(
                    g_GlobalInfo->m_QmgrRegistryRoot,
                    lpszValueName,
                    NULL,
                    &dwType,
                    (LPBYTE)lpszBuffer,
                    &dwSize);

    if (dwRet == ERROR_SUCCESS && dwType == REG_SZ)
    {
        return S_OK;
    }

    return E_FAIL;

}


////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegStringValue()
//                  Set the registry value of timestamp as current system local time
// Input:   name of the value to set. pointer to the time structure to set time. if null,
//          we use current system time.
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;

    if (lpszValueName == NULL || lpszNewValue == NULL)
    {
        return E_INVALIDARG;
    }


    //
    // set the time to the lasttimestamp value
    //
    hRet = (RegSetValueEx(                                   //SEC: REVIEWED 2002-03-28
                    g_GlobalInfo->m_QmgrRegistryRoot,
                    lpszValueName,
                    0,
                    REG_SZ,
                    (const unsigned char *)lpszNewValue,
                    lstrlen(lpszNewValue) + 1                // SEC: REVIEWED 2002-03-28
                    ) == ERROR_SUCCESS) ? S_OK : E_FAIL;

    return hRet;
}



////////////////////////////////////////////////////////////////////////////
//
// Public Function  DeleteRegStringValue()
//                  Delete the registry value entry
// Input:   name of the value to entry,
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegStringValue(LPCTSTR lpszValueName)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }


    //
    // set the time to the lasttimestamp value
    //
    hRet = (RegDeleteValue(
                    g_GlobalInfo->m_QmgrRegistryRoot,
                    lpszValueName
                    ) == ERROR_SUCCESS) ? S_OK : E_FAIL;

    return hRet;

}

////////////////////////////////////////////////////////////////////////////
//
// Public Function  GetRegDWordValue()
//                  Get a DWORD from specified regustry value name
// Input:   name of the value to retrieve value
// Output:  pointer to the retrieved value
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue)
{
    HKEY        hKey;
    int         iRet;
    DWORD       dwType = REG_DWORD, dwSize = sizeof(DWORD);

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open critical fix key
    //
    iRet = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    C_QMGR_REG_KEY,
                    0,
                    KEY_READ,
                    &hKey);

    if (iRet == ERROR_SUCCESS)
        {

        //
        // query the last timestamp value
        //
        iRet = RegQueryValueEx(          //SEC: REVIEWED 2002-03-28
                        hKey,
                        lpszValueName,
                        NULL,
                        &dwType,
                        (LPBYTE)pdwValue,
                        &dwSize);
        RegCloseKey(hKey);

        if (iRet == ERROR_SUCCESS)
            {
            if (dwType == REG_DWORD)
                {
                return S_OK;
                }

            return E_FAIL;
            }
        }

    return HRESULT_FROM_WIN32( iRet );
}


////////////////////////////////////////////////////////////////////////////
//
// Public Function  SetRegDWordValue()
//                  Set the registry value as a DWORD
// Input:   name of the value to set. value to set
// Output:  None
// Return:  HRESULT flag indicating the success of this function
//
////////////////////////////////////////////////////////////////////////////
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue)
{
    HKEY        hKey;
    HRESULT     hRet = E_FAIL;
    DWORD       dwResult;

    if (lpszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    //
    // open the key
    //
    if (RegCreateKeyEx(                               //SEC: REVIEWED 2002-03-28
                    HKEY_LOCAL_MACHINE,         // root key
                    C_QMGR_REG_KEY,     // subkey
                    0,                          // reserved
                    NULL,                       // class name
                    REG_OPTION_NON_VOLATILE,    // option
                    KEY_WRITE,                  // security
                    NULL,                       // security attribute
                    &hKey,
                    &dwResult) == ERROR_SUCCESS)
    {

        //
        // set the time to the lasttimestamp value
        //
        hRet = (RegSetValueEx(          //SEC: REVIEWED 2002-03-28
                        hKey,
                        lpszValueName,
                        0,
                        REG_DWORD,
                        (LPBYTE)&dwValue,
                        sizeof(DWORD)
                        ) == ERROR_SUCCESS) ? S_OK : E_FAIL;
        RegCloseKey(hKey);
    }
    return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\utils\qmgrlibp.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    qmgrlibp.h

Abstract :

    Private header file for the utils.

Author :

Revision History :

 ***********************************************************************/

#ifndef __QMGRLIBP_H__
#define __QMGRLIBP_H__

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <wchar.h>
#include <limits.h>
#include <ole2.h>
#include <initguid.h>
#include <setupapi.h>
#include <inseng.h>
#include <aclapi.h>
#include <shlobj.h>
#include <shfolder.h>
#include <limits.h>
#include <winsock2.h>
#include <iphlpapi.h>
#include "qmgrlib.h"

#endif // __QMGRLIBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\utils\locks.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    Locks.cxx

Abstract:

    Out of line methods for some of the syncronization classes
    defined in locks.hxx.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-14-95    Moved from misc.cxx.
    MarioGo     01-27-96    Changed from busy (Sleep(0)) wait to event

--*/

#include "qmgrlibp.h"
#include <locks.hxx>

BOOL BITSInitializeCriticalSectionInternal( LPCRITICAL_SECTION lpCriticalSection )
{
   __try
       {
       InitializeCriticalSection( lpCriticalSection ); // SEC: REVIEWED 2002-03-28
       }
   __except( ( GetExceptionCode() == STATUS_NO_MEMORY ) ?
             EXCEPTION_EXECUTE_HANDLER  : EXCEPTION_CONTINUE_SEARCH )
       {
       return FALSE;
       }
   return TRUE;
}

void BITSIntializeCriticalSection( LPCRITICAL_SECTION lpCriticalSection )
{
   if (!BITSInitializeCriticalSectionInternal( lpCriticalSection ) )
       throw ComError( E_OUTOFMEMORY );
}

//
// CShareLock methods
//

CSharedLock::CSharedLock()
{
    exclusive_owner = 0;
    writers = 0;
    hevent = INVALID_HANDLE_VALUE;  // Flag in the d'tor

    BITSIntializeCriticalSection( &lock );

    hevent = CreateEvent(0, FALSE, FALSE, 0); // SEC: REVIEWED 2002-03-28
    if (0 == hevent)
        {
        DeleteCriticalSection(&lock);
        throw ComError( E_OUTOFMEMORY );
        }
}

CSharedLock::~CSharedLock()
{
    if (hevent != INVALID_HANDLE_VALUE)
        {
        DeleteCriticalSection(&lock);

        if (hevent) CloseHandle(hevent);
        }
}

void
CSharedLock::LockShared()
{
    readers++;

    if (writers)
        {
        if ((readers--) == 0)
            {
            SetEvent(hevent);
            }

        EnterCriticalSection(&lock);
        readers++;
        LeaveCriticalSection(&lock);
        }

    exclusive_owner = 0;
}

void
CSharedLock::UnlockShared(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers)
        {
        SetEvent(hevent);
        }
}

void
CSharedLock::LockExclusive(void)
{
    EnterCriticalSection(&lock);

    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}

void
CSharedLock::UnlockExclusive(void)
{
    ASSERT(HeldExclusive());
    ASSERT(writers);
    writers--;
    exclusive_owner = 0;
    LeaveCriticalSection(&lock);
}

void
CSharedLock::Unlock()
{
    // Either the lock is held exclusively by this thread or the thread
    // has a shared lock. (or the caller has a bug).

    if (HeldExclusive())
        {
        UnlockExclusive();
        }
    else
        {
        UnlockShared();
        }
}

void
CSharedLock::ConvertToExclusive(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers )
        SetEvent(hevent);

    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\utils\log.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    log.cpp

Abstract :

    Log controller functions.

Author :

Revision History :

 ***********************************************************************/


#include "qmgrlibp.h"
#include <wmistr.h>
#include <initguid.h>
#include <guiddef.h>
#include <evntrace.h>

#if !defined(BITS_V12_ON_NT4)
#include "log.tmh"
#endif

TRACEHANDLE hTraceSessionHandle = NULL;
EVENT_TRACE_PROPERTIES *pTraceProperties = NULL;

LPCTSTR BITSLoggerName = _T("BITS");
LPCTSTR BITSLogFileName = _T("BITS.log");
LPCTSTR BITSLogFileNameBackup = _T("BITS.bak");
const ULONG MAX_STRLEN = 1024;
ULONG BITSMaxLogSize    = C_QMGR_LOGFILE_SIZE_DEFAULT; // Size in MB
ULONG BITSFlags         = C_QMGR_LOGFILE_FLAGS_DEFAULT;
ULONG BITSLogMinMemory  = C_QMGR_LOGFILE_MINMEMORY_DEFAULT; // Size in MB
const ULONG BITSDefaultLevel = 0;
const ULONG BITSLogFileMode = EVENT_TRACE_FILE_MODE_CIRCULAR |
                                 EVENT_TRACE_USE_LOCAL_SEQUENCE;

#if !defined(BITS_V12_ON_NT4)

// Compatibility wrappers since these arn't in WIN2k

ULONG
BITSStopTrace(
    TRACEHANDLE TraceHandle,
    LPCWSTR InstanceName,
    PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceW(
            TraceHandle,
            InstanceName,
            Properties,
            EVENT_TRACE_CONTROL_STOP
            );
}

ULONG
BITSQueryTrace(
    TRACEHANDLE TraceHandle,
    LPCWSTR InstanceName,
    PEVENT_TRACE_PROPERTIES Properties
    )
{
    return
        ControlTraceW(
            TraceHandle,
            InstanceName,
            Properties,
            EVENT_TRACE_CONTROL_QUERY
            );
}

#endif

bool Log_LoadSetting()
{
    // returns true is a logger should be
    // started if it isn't already started

    HKEY hBITSKey;

    LONG lResult = RegOpenKey( HKEY_LOCAL_MACHINE, C_QMGR_REG_KEY, &hBITSKey );

    if ( ERROR_SUCCESS == lResult )
        {

        BITSMaxLogSize    =
            GlobalInfo::RegGetDWORD( hBITSKey,
                                     C_QMGR_LOGFILE_SIZE,
                                     C_QMGR_LOGFILE_SIZE_DEFAULT );

        BITSFlags         =
            GlobalInfo::RegGetDWORD( hBITSKey,
                                     C_QMGR_LOGFILE_FLAGS,
                                     C_QMGR_LOGFILE_FLAGS_DEFAULT );

        BITSLogMinMemory  =
            GlobalInfo::RegGetDWORD( hBITSKey,
                                     C_QMGR_LOGFILE_MINMEMORY,
                                     C_QMGR_LOGFILE_MINMEMORY_DEFAULT );

        RegCloseKey( hBITSKey );

        }

    // Determine if the settings justify starting the logger

    if ( !BITSMaxLogSize || !BITSFlags)
        return false; // 0 size or no flags

    MEMORYSTATUS MemoryStatus;
    GlobalMemoryStatus( &MemoryStatus );

    SIZE_T MemorySize = MemoryStatus.dwTotalPhys / 0x100000;
    if ( MemorySize < BITSLogMinMemory )
        return false;

    return true; //enable the logger if it isn't already started
}

#if !defined(BITS_V12_ON_NT4)

void Log_StartLogger()
{
    try
        {
        if (!Log_LoadSetting())
            {
            return;
            }

        // Allocate trace properties
        ULONG SizeNeeded =
           sizeof(EVENT_TRACE_PROPERTIES) +
           (2 * MAX_STRLEN * sizeof(TCHAR));

        pTraceProperties = (PEVENT_TRACE_PROPERTIES) new char[SizeNeeded];

        memset( pTraceProperties, 0, SizeNeeded ); // SEC: REVIEWED 2002-03-28
        pTraceProperties->LoggerNameOffset = sizeof(EVENT_TRACE_PROPERTIES);
        pTraceProperties->LogFileNameOffset =
            sizeof(EVENT_TRACE_PROPERTIES) + (MAX_STRLEN * sizeof(TCHAR));
        pTraceProperties->Wnode.BufferSize = SizeNeeded;
        pTraceProperties->Wnode.Flags = WNODE_FLAG_TRACED_GUID;

        // Setup trace session properties
        TCHAR *LoggerName = (LPTSTR)((char*)pTraceProperties + pTraceProperties->LoggerNameOffset);
        TCHAR *LogFileName = (LPTSTR)((char*)pTraceProperties + pTraceProperties->LogFileNameOffset);

        THROW_HRESULT( StringCchCopy( LoggerName, MAX_STRLEN, BITSLoggerName ));

        _tfullpath(LogFileName, BITSLogFileName, MAX_STRLEN);

        pTraceProperties->LogFileMode |= BITSLogFileMode;
        pTraceProperties->MaximumFileSize = BITSMaxLogSize;

        ULONG Status;

        // if an existing session is started, if so just use that
        // session unmodified
        Status =
            BITSQueryTrace(
                NULL,
                LoggerName,
                pTraceProperties);

        if ( ERROR_SUCCESS == Status)
            {
            LogInfo("Using existing BITS logger session");
            return;
            }

        MoveFileEx( BITSLogFileName, BITSLogFileNameBackup, MOVEFILE_REPLACE_EXISTING );

        Status =
            StartTrace(
                &hTraceSessionHandle,
                LoggerName,
                pTraceProperties);

        if ( ERROR_SUCCESS != Status )
            {
            hTraceSessionHandle = NULL;
            return;
            }

        Status = EnableTrace(
            TRUE,
            BITSFlags,
            BITSDefaultLevel,
            &BITSCtrlGuid,
            hTraceSessionHandle);

        LogInfo("Started new logger session");
        LogInfo("Max log size is %u MB", BITSMaxLogSize );
        LogInfo("Log Flags %x", BITSFlags );
        LogInfo("Min Memory settings %u MB", BITSLogMinMemory );
        }
    catch ( ComError err )
        {
        delete[] pTraceProperties;
        pTraceProperties = NULL;
        }
}

void Log_StopLogger()
{
    if ( !pTraceProperties )
        return;

    if ( hTraceSessionHandle )
        {
        BITSStopTrace(
            hTraceSessionHandle,
            NULL,
            pTraceProperties);
        hTraceSessionHandle = NULL;

        }

    delete[] pTraceProperties;
    pTraceProperties = NULL;
}

BOOL
Log_Init(void)
{

    WPP_INIT_TRACING(L"Microsoft\\BITS");
    return TRUE;
}

void
Log_Close()
{
    Log_StopLogger();
    WPP_CLEANUP();
}

#endif

#if defined(BITS_V12_ON_NT4)


#define MAX_LOG_STRING 4000
#define MAX_REPLACED_FORMAT 256

CRITICAL_SECTION g_LogCs;
static HANDLE g_LogFile = INVALID_HANDLE_VALUE;
static bool g_LogInitialized = false;

struct FormatReplaceElement
{
    DWORD SearchSize;
    const char *SearchString;
    DWORD ReplacementSize;
    const char *ReplacementString;
};

// sort table first by size, then by string
FormatReplaceElement g_FormatReplaceElements[] =
{
    { 5,    "%!ts!",        3, "%ls" },
    { 6,    "%!sid!",       2, "%p"  },
    { 7,    "%!guid!",      2, "%p"  },
    { 7,    "%!tstr!",      3, "%ls" },
    { 9,    "%!winerr!",    7, "0x%8.8X" },
    { 10,   "%!netrate!",   2, "%G"  },
    { 12,   "%!timestamp!", 9, "0x%16.16X" }
};

const DWORD NumberOfFormatReplaceElements =
    sizeof( g_FormatReplaceElements ) / sizeof( *g_FormatReplaceElements );

int __cdecl FormatReplaceElementComparison( const void *elem1, const void *elem2 )
{

    const FormatReplaceElement *felem1 = (const FormatReplaceElement*)elem1;
    const FormatReplaceElement *felem2 = (const FormatReplaceElement*)elem2;

    if ( felem1->SearchSize != felem2->SearchSize )
        return felem1->SearchSize - felem2->SearchSize;

    return _stricmp( felem1->SearchString, felem2->SearchString );

}

void
LogGenerateNewFormat(
    char *NewFormat,
    const char *Format,
    DWORD BufferSize )
{

    if ( !BufferSize )
        return;

    BufferSize--; // Dont count the terminating NULL

    while( 1 )
        {

        if ( !BufferSize || !*Format )
            {
            *NewFormat = '\0';
            return;
            }

        if ( '%' == Format[0] &&
             '!' == Format[1] )
            {

            const char *Begin   = Format;
            const char *End     = Format + 2;

            while( *End != '!' )
                {

                if ( '\0' == *End++ )
                    goto NormalChar;

                }

            FormatReplaceElement Key = { (DWORD)(End - Begin) + 1, Begin, (DWORD)(End - Begin) + 1, Begin };

            FormatReplaceElement *Replacement = (FormatReplaceElement*)
                bsearch( &Key,
                         &g_FormatReplaceElements,
                         NumberOfFormatReplaceElements,
                         sizeof( *g_FormatReplaceElements ),
                         &FormatReplaceElementComparison );

            if ( !Replacement )
                goto NormalChar;

            if ( Replacement->ReplacementSize > BufferSize )
                {
                *NewFormat = '\0';
                return;
                }

            memcpy( NewFormat, Replacement->ReplacementString,
                    sizeof( char ) * Replacement->ReplacementSize );
            NewFormat   += Replacement->ReplacementSize;
            BufferSize  -= Replacement->ReplacementSize;
            Format      = End + 1;

            }
        else
            {
NormalChar:
            *NewFormat++ = *Format++;
            BufferSize--;
            }

        }

}


void
Log(const CHAR *Prefix,
    const CHAR *Format,
    va_list ArgList )
{

    if ( !g_LogInitialized)
        return;

    EnterCriticalSection( &g_LogCs );

    if ( !g_LogInitialized)
        return;

    static char OutputString[ MAX_LOG_STRING ];

    DWORD ThreadId = GetCurrentThreadId();
    DWORD ProcessId = GetCurrentProcessId();

    SYSTEMTIME Time;

    GetSystemTime( &Time );

    int CharsWritten =
    _snprintf( OutputString,
               sizeof( OutputString ) - 3,
               "%.2u/%.2u/%.4u-%.2u:%.2u:%.2u.%.3u %X.%X ",
               Time.wMonth,
               Time.wDay,
               Time.wYear,
               Time.wHour,
               Time.wMinute,
               Time.wSecond,
               Time.wMilliseconds,
               ProcessId,
               ThreadId );

    if ( -1 != CharsWritten )
        {

        int CharsWritten2 =
            _snprintf( OutputString + CharsWritten,
                       sizeof( OutputString ) - CharsWritten - 3,
                       "%s",
                       Prefix );


        if ( -1 == CharsWritten2 )
            goto overflow;

        CharsWritten += CharsWritten2;

        char NewFormat[ MAX_REPLACED_FORMAT ];

        LogGenerateNewFormat(
            NewFormat,
            Format,
            MAX_REPLACED_FORMAT );

        int CharsWritten3 =
            _vsnprintf( OutputString + CharsWritten,
                        sizeof( OutputString ) - CharsWritten - 3,
                        NewFormat,
                        ArgList );

        if ( -1 == CharsWritten3 )
            goto overflow;

        CharsWritten += CharsWritten3;
        OutputString[ CharsWritten++ ] = '\r';
        OutputString[ CharsWritten++ ] = '\n';
        OutputString[ CharsWritten++ ] = '\0';

        }
    else
        {
overflow:
        OutputString[ sizeof( OutputString ) - 3 ] = '\r';
        OutputString[ sizeof( OutputString ) - 2 ] = '\n';
        OutputString[ sizeof( OutputString ) - 1 ] = '\0';
        CharsWritten = sizeof( OutputString );
        }

    if ( INVALID_HANDLE_VALUE != g_LogFile )
        {
        DWORD BytesWritten;

        WriteFile(
            g_LogFile,
            OutputString,
            CharsWritten,
            &BytesWritten,
            NULL );

        }

#if defined( DBG )
    OutputDebugStringA( OutputString );
#endif

    LeaveCriticalSection( &g_LogCs );

}

void
Log_StartLogger()
{

    if (!Log_LoadSetting())
        return;

    if ( BITSLogFileName && BITSFlags )
        {

        g_LogFile = CreateFile(
            BITSLogFileName,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,   // overwrite any existing file
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        }

}


void
Log_StopLogger()
{
   if ( g_LogFile )
       {
       CloseHandle( g_LogFile );
       }
   g_LogInitialized = true;
}

BOOL
Log_Init(void)
{
    if ( !InitializeCriticalSectionAndSpinCount( &g_LogCs, 0x80000000 ) )
        return FALSE;

    g_LogInitialized = true;
    return TRUE;
}

void
Log_Close()
{
    EnterCriticalSection( &g_LogCs );
    Log_StopLogger();
    g_LogInitialized = false;
    DeleteCriticalSection( &g_LogCs );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common.inc ===
#+----------------------------------------------------------------------------
#
# Microsoft Windows
# Copyright (C) Microsoft Corporation, 1992 - 1996.
#
# Job Scheduler service common make macros for the NT target binaries
#
# 11/14/95 EricB - created
# 11/14/00 Dgrube - added     $(SDK_LIB_PATH)\mpr.lib \ for WNET apis'
#
#-----------------------------------------------------------------------------

MAJORCOMP=mgt
MINORCOMP=schedule

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE



USE_MSVCRT=1

SCHEDBASE=$(PROJECT_ROOT)\services\sched

INCLUDES=       $(SCHEDBASE)\inc;    \
                $(SCHEDBASE)\pch;    \
                $(SHELL_INC_PATH);   \
                $(WINDOWS_INC_PATH); \
                $(BASE_INC_PATH); \
                $(INCLUDES)


LINKLIBS=\
    $(SDK_LIB_PATH)\mpr.lib \
    $(PROJECT_ROOT)\services\smdebug\$(O)\smdebug.lib

TARGETLIBS=\
    $(SDK_LIB_PATH)\mstask.lib   \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(SDK_LIB_PATH)\shlwapi.lib  \
    $(SHELL_LIB_PATH)\shell32p.lib \
    $(SDK_LIB_PATH)\comctl32.lib \
    $(SDK_LIB_PATH)\uuid.lib     \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\ntdll.lib    \
    $(SDK_LIB_PATH)\user32.lib   \
    $(SDK_LIB_PATH)\rpcrt4.lib   \
    $(SDK_LIB_PATH)\rpcutil.lib  \
    $(SDK_LIB_PATH)\gdi32.lib    \
    $(SDK_LIB_PATH)\comdlg32.lib \
    $(SDK_LIB_PATH)\userenv.lib  \
    $(SDK_LIB_PATH)\version.lib  \
    $(SDK_LIB_PATH)\wtsapi32.lib \
    $(TARGETLIBS)

!ifndef NTNOPCH
PRECOMPILED_INCLUDE=$(SCHEDBASE)\pch\headers.hxx
PRECOMPILED_OPTION=/Fp$(SCHEDBASE)\pch\$(O)\headers.pch
PRECOMPILED_TARGET=$(SCHEDBASE)\pch\$(O)\headers.pch
PRECOMPILED_OBJ=$(SCHEDBASE)\pch\$(O)\headers.obj
PRECOMPILED_CXX=1
!endif

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\drizzle\utils\nt4thunks.cpp ===
/************************************************************************

Copyright (c) 2000 - 2001 Microsoft Corporation

Module Name :

    nt4thunks.cpp

Abstract :

    General helper functions to get BITS to work on NT4

Author :

Revision History :

 ***********************************************************************/

#include "qmgrlibp.h"
#include <bitsmsg.h>
#include <sddl.h>
#include <shlwapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "nt4thunks.tmh"
#endif

#if defined( BITS_V12_ON_NT4 )

BOOL
BITSAltGetFileSizeEx(
   HANDLE hFile,              // handle to file
   PLARGE_INTEGER lpFileSize  // file size
   )
{

    DWORD HighPart;

    DWORD Result =
        GetFileSize( hFile, &HighPart );

    if ( INVALID_FILE_SIZE == Result &&
         GetLastError() != NO_ERROR )
        return FALSE;

    lpFileSize->HighPart = (LONG)HighPart;
    lpFileSize->LowPart  = Result;
    return TRUE;

}

BOOL
BITSAltSetFilePointerEx(
    HANDLE hFile,                    // handle to file
    LARGE_INTEGER liDistanceToMove,  // bytes to move pointer
    PLARGE_INTEGER lpNewFilePointer, // new file pointer
    DWORD dwMoveMethod               // starting point
    )
{


    LONG  DistanceToMoveHigh = liDistanceToMove.HighPart;
    DWORD DistanceToMoveLow  = liDistanceToMove.LowPart;

    DWORD Result =
        SetFilePointer(
            hFile,
            (LONG)DistanceToMoveLow,
            &DistanceToMoveHigh,
            dwMoveMethod );

    if ( INVALID_SET_FILE_POINTER == Result &&
         NO_ERROR != GetLastError() )
        return FALSE;

    if ( lpNewFilePointer )
        {
        lpNewFilePointer->HighPart = DistanceToMoveHigh;
        lpNewFilePointer->LowPart  = (DWORD)DistanceToMoveLow;
        }

    return TRUE;

}

//
// Local macros
//
#define STRING_GUID_LEN 36
#define STRING_GUID_SIZE  ( STRING_GUID_LEN * sizeof( WCHAR ) )
#define SDDL_LEN_TAG( tagdef )  ( sizeof( tagdef ) / sizeof( WCHAR ) - 1 )
#define SDDL_SIZE_TAG( tagdef )  ( wcslen( tagdef ) * sizeof( WCHAR ) )
#define SDDL_SIZE_SEP( sep ) (sizeof( WCHAR ) )

#define SDDL_VALID_DACL  0x00000001
#define SDDL_VALID_SACL  0x00000002

ULONG
BITSAltSetLastNTError(
    IN NTSTATUS Status
    )
{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}


BOOL
BITSAltConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    )
/*++

Routine Description:

    This routine converts a SID into a string representation of a SID, suitable for framing or
    display

Arguments:

    Sid - SID to be converted.

    StringSid - Where the converted SID is returned.  Allocated via LocalAlloc and needs to
        be freed via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

--*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeStringSid;

    if ( NULL == Sid || NULL == StringSid ) {
        //
        // invalid parameter
        //
        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );
    }

    //
    // Convert using the Rtl functions
    //
    Status = RtlConvertSidToUnicodeString( &UnicodeStringSid, Sid, TRUE );

    if ( !NT_SUCCESS( Status ) ) {

        BITSAltSetLastNTError( Status );
        return( FALSE );
    }

    //
    // Convert it to the proper allocator
    //
    *StringSid = (LPWSTR)LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                     UnicodeStringSid.Length + sizeof( WCHAR ) );

    if ( *StringSid == NULL ) {

        RtlFreeUnicodeString( &UnicodeStringSid );

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return( FALSE );

    }

    RtlCopyMemory( *StringSid, UnicodeStringSid.Buffer, UnicodeStringSid.Length );
    RtlFreeUnicodeString( &UnicodeStringSid );

    SetLastError(ERROR_SUCCESS);
    return( TRUE );
}

//
// Private functions
//
BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_INVALID_SID indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub, *StubPtr = NULL;
    ULONG Index;
    INT gBase=10;
    INT lBase=10;
    ULONG Auto;

    if ( NULL == StringSid || NULL == Sid || NULL == End ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );

    }

//    if ( wcslen( StringSid ) < 2 || ( *StringSid != L'S' && *( StringSid + 1 ) != L'-' ) ) {

    //
    // no need to check length because StringSid is NULL
    // and if the first char is NULL, it won't access the second char
    //
    if ( (*StringSid != L'S' && *StringSid != L's') ||
         *( StringSid + 1 ) != L'-' ) {
        //
        // string sid should always start with S-
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }


    Curr = StringSid + 2;

    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        gBase = 16;
    }

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, gBase );

    if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );
/*
    Length = 6 doesn't mean each digit is a id authority value, could be 0x...

    if ( Next != NULL && (Next - Curr == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

//            IDAuth.Value[Index] = (UCHAR)Next[Index];  what is this ???
            IDAuth.Value[Index] = (BYTE) (Curr[Index]-L'0');
        }

        Curr +=6;

    } else {
*/
        if ( (*Curr == L'0') &&
             ( *(Curr+1) == L'x' ||
               *(Curr+1) == L'X' ) ) {

            lBase = 16;
        } else {
            lBase = gBase;
        }

        Auto = wcstoul( Curr, &CurrEnd, lBase );

         if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
             //
             // no revision is provided, or invalid delimeter
             //
             SetLastError( ERROR_INVALID_SID );
             return( FALSE );
         }

         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         IDAuth.Value[5] = ( UCHAR )Auto & 0xFF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         Curr = CurrEnd;
//    }

    //
    // Now, count the number of sub auths, at least one sub auth is required
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //

    while ( Next ) {

        if ( *Next == L'-' && *(Next-1) != L'-') {

            //
            // do not allow two continuous '-'s
            // We've found one!
            //
            Subs++;

            if ( (*(Next+1) == L'0') &&
                 ( *(Next+2) == L'x' ||
                   *(Next+2) == L'X' ) ) {
                //
                // this is hex indicator
                //
                Next += 2;

            }

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' ||
                    *Next == SDDL_ACE_ENDC || *Next == L' ' ||
                    ( *(Next+1) == SDDL_DELIMINATORC &&
                      (*Next == L'G' || *Next == L'O' || *Next == L'S')) ) {
            //
            // space is a terminator too
            //
            if ( *( Next - 1 ) == L'-' ) {
                //
                // shouldn't allow a SID terminated with '-'
                //
                Err = ERROR_INVALID_SID;
                Next--;

            } else {
                Subs++;
            }

            *End = Next;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            Err = ERROR_INVALID_SID;
            *End = Next;
//            Subs++;
            break;

        } else {

            //
            // Note: SID is also used as a owner or group
            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == L'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }

        Next++;

    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) Subs--;

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    if ( (*Curr == L'0') &&
                         ( *(Curr+1) == L'x' ||
                           *(Curr+1) == L'X' ) ) {

                        lBase = 16;
                    } else {
                        lBase = gBase;
                    }

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, lBase );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_INVALID_SID;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            RtlCopyMemory( &( ISid->IdentifierAuthority ), &IDAuth,
                           sizeof( SID_IDENTIFIER_AUTHORITY ) );
            RtlCopyMemory( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) );
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}

BOOL
BITSAltConvertStringSidToSidW(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    )

/*++

Routine Description:

    This routine converts a stringized SID into a valid, functional SID

Arguments:

    StringSid - SID to be converted.

    Sid - Where the converted SID is returned.  Buffer is allocated via LocalAlloc and should
        be free via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL name was given

        ERROR_INVALID_SID - The format of the given sid was incorrect

--*/

{
    PWSTR End = NULL;
    BOOL ReturnValue = FALSE;
    PSID pSASid=NULL;
    ULONG Len=0;
    DWORD SaveCode=0;
    DWORD Err=0;

    if ( StringSid == NULL || Sid == NULL )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    ReturnValue = LocalConvertStringSidToSid( ( PWSTR )StringSid, Sid, &End );

    if ( !ReturnValue )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    if ( ( ULONG )( End - StringSid ) != wcslen( StringSid ) ) {

        SetLastError( ERROR_INVALID_SID );
        LocalFree( *Sid );
        *Sid = FALSE;
        ReturnValue = FALSE;

        } else {
            SetLastError(ERROR_SUCCESS);
        }

    return ReturnValue;

}

BOOL
BITSAltCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    )
/*++

Routine Description:

    This function checks to see whether the specified sid is enabled in
    the specified token.

Arguments:

    TokenHandle - If present, this token is checked for the sid. If not
        present then the current effective token will be used. This must
        be an impersonation token.

    SidToCheck - The sid to check for presence in the token

    IsMember - If the sid is enabled in the token, contains TRUE otherwise
        false.

Return Value:

    TRUE - The API completed successfully. It does not indicate that the
        sid is a member of the token.

    FALSE - The API failed. A more detailed status code can be retrieved
        via GetLastError()


--*/
{
    HANDLE ProcessToken = NULL;
    HANDLE EffectiveToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PISECURITY_DESCRIPTOR SecDesc = NULL;
    ULONG SecurityDescriptorSize;
    GENERIC_MAPPING GenericMapping = {
        STANDARD_RIGHTS_READ,
        STANDARD_RIGHTS_EXECUTE,
        STANDARD_RIGHTS_WRITE,
        STANDARD_RIGHTS_ALL };
    //
    // The size of the privilege set needs to contain the set itself plus
    // any privileges that may be used. The privileges that are used
    // are SeTakeOwnership and SeSecurity, plus one for good measure
    //

    BYTE PrivilegeSetBuffer[sizeof(PRIVILEGE_SET) + 3*sizeof(LUID_AND_ATTRIBUTES)];
    PPRIVILEGE_SET PrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;
    ULONG PrivilegeSetLength = sizeof(PrivilegeSetBuffer);
    ACCESS_MASK AccessGranted = 0;
    NTSTATUS AccessStatus = 0;
    PACL Dacl = NULL;

#define MEMBER_ACCESS 1

    *IsMember = FALSE;

    //
    // Get a handle to the token
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        EffectiveToken = TokenHandle;
    }
    else
    {
        Status = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY,
                    FALSE,              // don't open as self
                    &EffectiveToken
                    );

        //
        // if there is no thread token, try the process token
        //

        if (Status == STATUS_NO_TOKEN)
        {
            Status = NtOpenProcessToken(
                        NtCurrentProcess(),
                        TOKEN_QUERY | TOKEN_DUPLICATE,
                        &ProcessToken
                        );
            //
            // If we have a process token, we need to convert it to an
            // impersonation token
            //

            if (NT_SUCCESS(Status))
            {
                BOOL Result;
                Result = DuplicateToken(
                            ProcessToken,
                            SecurityImpersonation,
                            &EffectiveToken
                            );

                CloseHandle(ProcessToken);
                if (!Result)
                {
                    return(FALSE);
                }
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

    //
    // Construct a security descriptor to pass to access check
    //

    //
    // The size is equal to the size of an SD + twice the length of the SID
    // (for owner and group) + size of the DACL = sizeof ACL + size of the
    // ACE, which is an ACE + length of
    // ths SID.
    //

    SecurityDescriptorSize = sizeof(SECURITY_DESCRIPTOR) +
                                sizeof(ACCESS_ALLOWED_ACE) +
                                sizeof(ACL) +
                                3 * RtlLengthSid(SidToCheck);

    SecDesc = (PISECURITY_DESCRIPTOR) LocalAlloc(LMEM_ZEROINIT, SecurityDescriptorSize );
    if (SecDesc == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Dacl = (PACL) (SecDesc + 1);

    RtlCreateSecurityDescriptor(
        SecDesc,
        SECURITY_DESCRIPTOR_REVISION
        );

    //
    // Fill in fields of security descriptor
    //

    RtlSetOwnerSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );
    RtlSetGroupSecurityDescriptor(
        SecDesc,
        SidToCheck,
        FALSE
        );

    Status = RtlCreateAcl(
                Dacl,
                SecurityDescriptorSize - sizeof(SECURITY_DESCRIPTOR),
                ACL_REVISION
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = RtlAddAccessAllowedAce(
                Dacl,
                ACL_REVISION,
                MEMBER_ACCESS,
                SidToCheck
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the DACL on the security descriptor
    //

    Status = RtlSetDaclSecurityDescriptor(
                SecDesc,
                TRUE,   // DACL present
                Dacl,
                FALSE   // not defaulted
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtAccessCheck(
                SecDesc,
                EffectiveToken,
                MEMBER_ACCESS,
                &GenericMapping,
                PrivilegeSet,
                &PrivilegeSetLength,
                &AccessGranted,
                &AccessStatus
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // if the access check failed, then the sid is not a member of the
    // token
    //

    if ((AccessStatus == STATUS_SUCCESS) && (AccessGranted == MEMBER_ACCESS))
    {
        *IsMember = TRUE;
    }




Cleanup:
    if (!ARGUMENT_PRESENT(TokenHandle) && (EffectiveToken != NULL))
    {
        (VOID) NtClose(EffectiveToken);
    }

    if (SecDesc != NULL)
    {
        LocalFree(SecDesc);
    }

    if (!NT_SUCCESS(Status))
    {
        BITSAltSetLastNTError(Status);
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}

LPHANDLER_FUNCTION_EX g_BITSAltRegisterServiceFunc = NULL;
typedef SERVICE_STATUS_HANDLE (*REGISTER_FUNC_TYPE)(LPCTSTR, LPHANDLER_FUNCTION_EX, LPVOID lpContext);

VOID WINAPI
BITSAltRegisterServiceThunk(
  DWORD dwControl   // requested control code
)
{

    (*g_BITSAltRegisterServiceFunc)( dwControl, 0, NULL, NULL );
    return;

}

SERVICE_STATUS_HANDLE
BITSAltRegisterServiceCtrlHandlerExW(
  LPCTSTR lpServiceName,                // name of service
  LPHANDLER_FUNCTION_EX lpHandlerProc,  // handler function
  LPVOID lpContext                      // user data
)
{

    // First check if RegisterServerCtrlHandlerEx if available and use
    // it, otherwise thunk the call.

    HMODULE AdvapiHandle = LoadLibraryW( L"advapi32.dll" );

    if ( !AdvapiHandle )
        {
        // Something is messed up, every machine should have this DLL.
        return NULL;
        }


    SERVICE_STATUS_HANDLE ReturnValue;
    FARPROC RegisterFunc = GetProcAddress( AdvapiHandle, "RegisterServiceCtrlHandlerExW" );

    if ( RegisterFunc )
        {
        ReturnValue = (*(REGISTER_FUNC_TYPE)RegisterFunc)( lpServiceName, lpHandlerProc, lpContext );
        }
    else
        {

        if ( g_BITSAltRegisterServiceFunc || lpContext )
            {
            ReturnValue = 0;
            SetLastError( ERROR_INVALID_PARAMETER );
            }
        else
            {
            g_BITSAltRegisterServiceFunc = lpHandlerProc;
            ReturnValue = RegisterServiceCtrlHandler( lpServiceName, BITSAltRegisterServiceThunk );

            if ( !ReturnValue)
                g_BITSAltRegisterServiceFunc = NULL;
            }

        }

    DWORD OldError = GetLastError();
    FreeLibrary( AdvapiHandle );
    SetLastError( OldError );

    return ReturnValue;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\at\atacct.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       atacct.cxx
//
//  Classes:    None.
//
//  Functions:  SetNetScheduleAccountInformation
//              GetNetScheduleAccountInformation
//
//  History:    13-Aug-96   MarkBl  Created.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\debug.hxx"
#include "atacct.h"
#include "SASecRPC.h"       // SASetNSAccountInformation RPC definition.
#include <misc.hxx>         // SchedMapRpcError

//+----------------------------------------------------------------------------
//
//  Function:   SetNetScheduleAccountInformation
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
SetNetScheduleAccountInformation(
    LPCWSTR pwszServerName,
    LPCWSTR pwszAccount,
    LPCWSTR pwszPassword)
{
    HRESULT hr;

    RpcTryExcept
    {
        hr = SASetNSAccountInformation(pwszServerName,
                                       pwszAccount,
                                       pwszPassword);
    }
    RpcExcept(1)
    {
        DWORD Status = RpcExceptionCode();
        schDebugOut((DEB_ERROR,
            "SASetNSAccountInformation exception(0x%x)\n",
            Status));
        hr = SchedMapRpcError(Status);
    }
    RpcEndExcept;

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function:   GetNetScheduleAccountInformation
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
GetNetScheduleAccountInformation(
    LPCWSTR pwszServerName,
    DWORD   ccAccount,
    WCHAR   wszAccount[])
{
    HRESULT hr;

    RpcTryExcept
    {
        hr = SAGetNSAccountInformation(pwszServerName, ccAccount, wszAccount);
    }
    RpcExcept(1)
    {
        DWORD Status = RpcExceptionCode();
        schDebugOut((DEB_ERROR,
            "SAGetNSAccountInformation exception(0x%x)\n",
            Status));
        hr = SchedMapRpcError(Status);
    }
    RpcEndExcept;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\at\atacct.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    atacct.h

Abstract:

    Prototypes for the private net scheduler API.

Revision History:

--*/

#ifndef _ATACCT_H_
#define _ATACCT_H_

#ifdef __cplusplus
extern "C" {
#endif

STDAPI
GetNetScheduleAccountInformation(
    IN    LPCWSTR pwszServerName,
    OUT   DWORD ccAccount,
    OUT   WCHAR wszAccount[]
    );

STDAPI
SetNetScheduleAccountInformation(
    IN    LPCWSTR pwszServerName,
    IN    LPCWSTR pwszAccount,
    IN    LPCWSTR pwszPassword
    );

#ifdef __cplusplus
}
#endif

#endif // _ATACCT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\client\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\idl\$(O)\$(@F)
    copy ..\idl\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\clientpublish\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 2002

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE1):
    lib /OUT:$(O)\mstask.lib ..\client\$(O)\mstask.lib ..\types\uuid\$(O)\guids.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\at\atconv.cxx ===
//+----------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       atconv.cxx
//
//  Classes:    None.
//
//  Functions:  ConvertAtJobsToTasks
//
//  History:    13-Jun-96   EricB   Created.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <sch_cls.hxx>
#include <job_cls.hxx>
#include "..\inc\debug.hxx"

//
// The constants and types below taken from net\svcdlls\at\server\at.h
//
#define AT_REGISTRY_PATH    L"System\\CurrentControlSet\\Services\\Schedule"
#define AT_SCHEDULE_NAME    L"Schedule"
#define AT_COMMAND_NAME     L"Command"

#define MAXIMUM_COMMAND_LENGTH  (MAX_PATH - 1)  // == 259, cmd.exe uses this
#define MAXIMUM_JOB_TIME    (24 * 60 * 60 * 1000 - 1)
#define DAYS_OF_WEEK        0x7F                    // 7 bits for 7 days
#define DAYS_OF_MONTH       0x7FFFFFFF              // 31 bits for 31 days

#define AT_KEY_BUF_LEN      20  //  9 would suffice, but this is safer

typedef struct _AT_SCHEDULE {
    DWORD       JobTime;        //  time of day to run, in seconds from midnight
    DWORD       DaysOfMonth;    //  bitmask for days of month to run
    UCHAR       DaysOfWeek;     //  bitmask for days of week to run
    UCHAR       Flags;          //  see lmat.h
    WORD        Reserved;       //  padding, since registry pads them as well
} AT_SCHEDULE;

//+----------------------------------------------------------------------------
//
//  Function:   ConvertAtJobsToTasks
//
//  Synopsis:   At setup time, read the AT service jobs out of the registry
//              and convert them to Scheduling Agent Tasks.
//
//-----------------------------------------------------------------------------
STDAPI_(void)
ConvertAtJobsToTasks(void)
{
    struct KEYNAME {
        KEYNAME *   pNext;
        WCHAR       wszName[AT_KEY_BUF_LEN];
    };

    CSchedule * pSch = new CSchedule;
    if (pSch == NULL)
    {
        ERR_OUT("ConvertAtJobsToTasks, new pSch", E_OUTOFMEMORY);
        return;
    }
    HRESULT hr = pSch->Init();
    if (FAILED(hr))
    {
        pSch->Release();
        ERR_OUT("ConvertAtJobsToTasks, pSch->Init", hr);
        return;
    }

    HKEY        hKeySvc, hKey;
    DWORD       index;
    WCHAR       wszNameBuffer[AT_KEY_BUF_LEN];
    FILETIME    lastWriteTime;
    WCHAR       wszCommand[MAXIMUM_COMMAND_LENGTH + 1];
    AT_SCHEDULE Schedule;
    DWORD       Length;
    DWORD       type;
    DWORD       NameSize;
    DWORD       CommandSize;
    KEYNAME *   pDeleteList = NULL;

    long lRet;

    //
    // Open the AT service registry tree.
    //
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        AT_REGISTRY_PATH,
                        0,
                        KEY_READ,
                        &hKeySvc);
    if (lRet != ERROR_SUCCESS)
    {
        ERR_OUT("ConvertAtJobsToTasks: open hKeySvc", lRet);
        pSch->Release();
        return;
    }

    for (index = 0;  ; index++)
    {
        //
        //  Regedit can sometimes display other keys in addition to keys
        //  found here.  Also, it often fails to display last character in
        //  the Command and after a refresh it may not display some of the
        //  spurious keys.
        //
        Length = sizeof(wszNameBuffer) / sizeof(wszNameBuffer[0]);
        lRet = RegEnumKeyEx(hKeySvc,
                            index,
                            wszNameBuffer,             // lpName
                            &Length,                // lpcbName
                            0,                      // lpReserved
                            NULL,                   // lpClass
                            NULL,                   // lpcbClass
                            &lastWriteTime);
        if (lRet != ERROR_SUCCESS && lRet != ERROR_MORE_DATA)
        {
            if (lRet != ERROR_NO_MORE_ITEMS)
            {
                ERR_OUT("ConvertAtJobsToTasks: RegEnumKeyEx", lRet);
            }
            //
            // The only exit point from this loop
            //
            break;
        }

        //
        //  Length returned is the number of characters in a UNICODE string
        //  representing the key name (not counting the terminating NULL
        //  character which is also supplied).
        //
        NameSize = (Length + 1) * sizeof(WCHAR);
        lRet = RegOpenKeyEx(hKeySvc,
                            wszNameBuffer,
                            0,
                            KEY_READ,
                            &hKey);
        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("ConvertAtJobsToTasks: RegOpenKeyEx", lRet);
            continue;
        }

        Length = sizeof(Schedule);
        lRet = RegQueryValueEx(hKey,
                               AT_SCHEDULE_NAME,
                               NULL,
                               &type,
                               (LPBYTE)&Schedule,
                               &Length);
        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("ConvertAtJobsToTasks: RegQueryValueEx(AT_SCHEDULE_NAME)",
                    lRet);
            RegCloseKey(hKey);
            continue;
        }
        if (type != REG_BINARY                           ||
            Length != sizeof(AT_SCHEDULE)                ||
            (Schedule.DaysOfWeek & ~DAYS_OF_WEEK) != 0   ||
            (Schedule.DaysOfMonth & ~DAYS_OF_MONTH) != 0 ||
            Schedule.JobTime >= MAXIMUM_JOB_TIME )
        {
            schDebugOut((DEB_ERROR,"ConvertAtJobsToTasks: RegQueryValueEx invalid data: "
                         "type=%lu, Length=%lu, DOW=%#x, DOM=%#lx, Time=%lu\n",
                         type, Length, Schedule.DaysOfWeek, Schedule.DaysOfMonth,
                         Schedule.JobTime));
            RegCloseKey(hKey);
            continue;
        }

        Length = sizeof(wszCommand);
        lRet = RegQueryValueEx(hKey,
                               AT_COMMAND_NAME,
                               NULL,
                               &type,
                               (LPBYTE)wszCommand,
                               &Length);

        RegCloseKey(hKey);

        if (lRet != ERROR_SUCCESS)
        {
            ERR_OUT("ConvertAtJobsToTasks: RegQueryValueEx(AT_COMMAND_NAME)",
                    lRet);
            continue;
        }

        if (type != REG_SZ)
        {
            ERR_OUT("ConvertAtJobsToTasks: Command is not of REG_SZ type", 0);
            continue;
        }

        AT_INFO At;

        At.Command     = wszCommand;
        At.JobTime     = Schedule.JobTime;
        At.DaysOfMonth = Schedule.DaysOfMonth;
        At.DaysOfWeek  = Schedule.DaysOfWeek;
        At.Flags       = Schedule.Flags;

        hr = pSch->AddAtJob(At, NULL);

        if (SUCCEEDED(hr))
        {
            //
            // If the job was successfully converted, then add it to the
            // list of jobs to delete from the registry.  Don't delete it
            // right away, because that would mess up the operation of
            // RegEnumKeyEx.
            //
            KEYNAME * pKey = new KEYNAME;
            if (pKey == NULL)
            {
                ERR_OUT("ConvertAtJobsToTasks: new KEYNAME", GetLastError());
                RegDeleteKey(hKeySvc, wszNameBuffer);
                break;
            }

            pKey->pNext = pDeleteList;
            pDeleteList = pKey;

            StringCchCopy(pKey->wszName, AT_KEY_BUF_LEN, wszNameBuffer);
        }
#if DBG == 1
        else
        {
            ERR_OUT("ConvertAtJobsToTasks: AddAtJob", hr);
        }
#endif
    }

    //
    // Delete the reg keys for all jobs that were successfully converted
    //
    KEYNAME * pNext;
    for ( ; pDeleteList != NULL; pDeleteList = pNext)
    {
        RegDeleteKey(hKeySvc, pDeleteList->wszName);
        pNext = pDeleteList->pNext;
        delete pDeleteList;
    }


    RegCloseKey(hKeySvc);
    pSch->Release();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\client\rpc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rpc.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-Nov-95   MarkBl  Created.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "debug.hxx"
#include "atsvc.h"
#include "SASecRPC.h"

typedef HRESULT (* BindFunction)(LPWSTR, RPC_BINDING_HANDLE *);

RPC_STATUS BindNetBIOSOverNetBEUI(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindNetBIOSOverTCP(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindNetBIOSOverIPX(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindNamedPipe(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindSPX(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindTCPIP(LPWSTR, RPC_BINDING_HANDLE *);
RPC_STATUS BindViaProtocol(LPTSTR , LPWSTR , RPC_BINDING_HANDLE * );
extern "C" handle_t GenericBind(LPCWSTR, RPC_IF_HANDLE);
extern "C" void     GenericUnbind(LPCWSTR, RPC_BINDING_HANDLE);

BindFunction grgProtocolBindFuncs[] = {
    BindNamedPipe,
    BindTCPIP,
    BindSPX,
    NULL
};

RPC_BINDING_HANDLE gRpcHandle = NULL;

//+---------------------------------------------------------------------------
//
//  Function:   ATSVC_HANDLE_bind
//
//  Synopsis:   Called from RPC on auto bind.
//
//  Arguments:  [ServerName] -- Server to bind to.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" handle_t
ATSVC_HANDLE_bind(ATSVC_HANDLE ServerName)
{
    return(GenericBind(ServerName, atsvc_ClientIfHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   ATSVC_HANDLE_unbind
//
//  Synopsis:   Unbind. Free the handle.
//
//  Arguments:  [ServerName]    -- Unused.
//              [BindingHandle] -- Binding handle to free.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" void
ATSVC_HANDLE_unbind(ATSVC_HANDLE ServerName, RPC_BINDING_HANDLE BindingHandle)
{
    GenericUnbind(ServerName, BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   SASEC_HANDLE_bind
//
//  Synopsis:   Called from RPC on auto bind.
//
//  Arguments:  [ServerName] -- Server to bind to.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" handle_t
SASEC_HANDLE_bind(SASEC_HANDLE ServerName)
{
    RPC_BINDING_HANDLE BindingHandle;
    RPC_STATUS         RpcStatus;

    if ((BindingHandle = GenericBind(ServerName,
                                     sasec_ClientIfHandle)) != NULL)
    {
        //
        // Set the connection to be authenticated and all arguments encrypted.
        // 

        RPC_SECURITY_QOS qos;
        ZeroMemory(&qos, sizeof(RPC_SECURITY_QOS));
        qos.Version = RPC_C_SECURITY_QOS_VERSION;
        qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

        RpcStatus = RpcBindingSetAuthInfoEx(BindingHandle,
                                            NULL,
                                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                            RPC_C_AUTHN_WINNT,
                                            NULL,
                                            RPC_C_AUTHZ_NONE,
                                            &qos);
                                            

        //
        // Refuse the bind, if the requested authentication failed.
        //

        if (RpcStatus != RPC_S_OK)
        {
            GenericUnbind(ServerName, BindingHandle);
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
            return(NULL);
        }
    }

    return(BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   SASEC_HANDLE_unbind
//
//  Synopsis:   Unbind. Free the handle.
//
//  Arguments:  [ServerName]    -- Unused.
//              [BindingHandle] -- Binding handle to free.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" void
SASEC_HANDLE_unbind(SASEC_HANDLE ServerName, RPC_BINDING_HANDLE BindingHandle)
{
    GenericUnbind(ServerName, BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   GenericBind
//
//  Synopsis:
//
//  Arguments:  [ServerName]     -- Server to bind to.
//              [ClientIfHandle] -- Specific interface.
//  Returns:
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" handle_t
GenericBind(LPCWSTR ServerName, RPC_IF_HANDLE ClientIfHandle)
{
    RPC_BINDING_HANDLE BindingHandle = NULL;
    RPC_STATUS         RpcStatus;

    //
    // If local, use LRPC. Otherwise, try multiple protocols.
    //

    if (ServerName == NULL)
    {
        RpcStatus = BindViaProtocol(TEXT("ncalrpc"), NULL, &BindingHandle);
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));

        if (RpcStatus == RPC_S_OK)
        {
            RpcStatus = RpcEpResolveBinding(BindingHandle, ClientIfHandle);
            CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        }
    }
    else
    {
        BindFunction pBindFunc;

        pBindFunc = grgProtocolBindFuncs[0];

        int i = 0;

        //
        // Iterate through the protocols until we find one that can connect.
        //

        do
        {
            RpcStatus = pBindFunc((LPWSTR)ServerName, &BindingHandle);

            if (RpcStatus == RPC_S_OK)
            {
                //
                // For the named pipes protocol, we use a static endpoint,
                // so the call to RpcEpResolveBinding is not needed.
                //
                // BUGBUG : review the above. Also, should we be specifying
                //          authentication info?
                //

                if (pBindFunc != BindNamedPipe)
                {
                    RpcStatus = RpcEpResolveBinding(BindingHandle,
                                                    ClientIfHandle);
                    CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
                }
            }
            else if (RpcStatus == RPC_S_PROTSEQ_NOT_SUPPORTED)
            {
                //
                // If the protocol is not on this computer, then rearrange
                // the list so it is not tried anymore.
                //

                CopyMemory(&grgProtocolBindFuncs[i],
                           &grgProtocolBindFuncs[i + 1],
                           sizeof(grgProtocolBindFuncs) -
                    (&grgProtocolBindFuncs[i + 1] - &grgProtocolBindFuncs[0]));
                i--;
            }

            //
            // Try the next protocol's connection function.
            //

            if (RpcStatus != RPC_S_OK)
            {
                i++;
                pBindFunc = grgProtocolBindFuncs[i];
            }

        } while (!((RpcStatus == RPC_S_OK) || (pBindFunc == NULL)));
    }

    return(BindingHandle);
}

//+---------------------------------------------------------------------------
//
//  Function:   GenericUnbind
//
//  Synopsis:
//
//  Arguments:  [ServerName] -- Server to bind to.
//
//  Returns:
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
extern "C" void
GenericUnbind(LPCWSTR ServerName, RPC_BINDING_HANDLE BindingHandle)
{
    UNREFERENCED_PARAMETER(ServerName);

    if (BindingHandle != NULL) {
        RPC_STATUS RpcStatus = RpcBindingFree(&BindingHandle);
        schAssert(RpcStatus == RPC_S_OK);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   BindingFromStringBinding
//
//  Synopsis:   Bind then free the string binding passed.
//
//  Arguments:  [StringBinding]  -- Target string binding.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindingFromStringBinding(
    LPTSTR *             StringBinding,
    RPC_BINDING_HANDLE * pBindingHandle)
{
    RPC_STATUS RpcStatus;
    RpcStatus = RpcBindingFromStringBinding(*StringBinding, pBindingHandle);
    RpcStringFree(StringBinding);

    if (RpcStatus != RPC_S_OK)
    {
        *pBindingHandle = NULL;
    }

    return(RpcStatus);
}

//+---------------------------------------------------------------------------
//
//  Function:   BindViaProtocol
//
//  Synopsis:   Bind via the specified protocol.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindViaProtocol(
    LPTSTR               rpc_protocol,
    LPWSTR               ServerName,
    RPC_BINDING_HANDLE * pBindingHandle)
{
    TCHAR      tszServerName[SA_MAX_COMPUTERNAME_LENGTH + 3]; // plus 3 for "\\" and NULL
    RPC_STATUS RpcStatus;
    LPTSTR     StringBinding;
    LPTSTR     PlainServerName;

    *pBindingHandle = NULL;

    schDebugOut((DEB_ITRACE,
        "Attempting RPC bind via protocol \"%ws\"\n",
        rpc_protocol));
    if (ServerName != NULL)
    {
        if (FAILED(StringCchCopy(tszServerName, SA_MAX_COMPUTERNAME_LENGTH + 3, ServerName)))
        {
            return ERROR_INVALID_COMPUTERNAME;
        }
    }

    //
    // Ignore leading "\\"
    //

    if (ServerName != NULL && ServerName[0] == L'\\' &&
                ServerName[1] == L'\\')
    {
        PlainServerName = &tszServerName[2];
    }
    else
    {
        PlainServerName = ServerName != NULL ? tszServerName : NULL;
    }

    RpcStatus = RpcStringBindingCompose(NULL,
                                        rpc_protocol,
                                        PlainServerName,
                                        NULL,               // endpoint
                                        NULL,
                                        &StringBinding);

    if (RpcStatus != RPC_S_OK)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        return(RpcStatus);
    }

    return(BindingFromStringBinding(&StringBinding, pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNetBIOSOverNetBEUI
//
//  Synopsis:   Attempt to bind via netbeui.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNetBIOSOverNetBEUI(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_nb_nb"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNetBIOSOverTCP
//
//  Synopsis:   Attempt to bind via tcp over netbios.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNetBIOSOverTCP(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_nb_tcp"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNetBIOSOverIPX
//
//  Synopsis:   Attempt to bind via ipx over netbios.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNetBIOSOverIPX(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_nb_ipx"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindNamedPipe
//
//  Synopsis:   Attempt to bind via named pipes.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    ERROR_INVALID_COMPUTERNAME
//              RPC_STATUS code
//
//  Notes:      Server side *not* supported in Win95.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindNamedPipe(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    RPC_STATUS  RpcStatus;
    LPTSTR      StringBinding;
    LPWSTR      SlashServerName;
    WCHAR       Buffer[SA_MAX_COMPUTERNAME_LENGTH + 3];       // plus 3 for '\\' and NULL
    int         have_slashes;
    ULONG       NameLen;

    *pBindingHandle = NULL;

    if (ServerName[1] == L'\\')
    {
        have_slashes = 1;
    }
    else
    {
        have_slashes = 0;
    }

    //
    // Be nice and prepend slashes if not supplied.
    //

    NameLen = wcslen(ServerName);

    if ((!have_slashes) && (NameLen > 0))
    {
        if ((NameLen + 2) >= sizeof(Buffer))
        {
            return(ERROR_INVALID_COMPUTERNAME);
        }

        Buffer[0] = L'\\';
        Buffer[1] = L'\\';

        if (FAILED(StringCchCopy(&Buffer[2], SA_MAX_COMPUTERNAME_LENGTH + 1, ServerName))) // this is really SA_MAX_COMPUTERNAME_LENGTH + 3 - 2
        {
            return ERROR_INVALID_COMPUTERNAME;
        }

        SlashServerName = Buffer;
    }
    else
    {
        SlashServerName = ServerName;
    }

    RpcStatus = RpcStringBindingCompose(0,
                                        TEXT("ncacn_np"),
                                        SlashServerName,
                                        TEXT("\\PIPE\\atsvc"),
                                        NULL,
                                        &StringBinding);
    if (RpcStatus != RPC_S_OK)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(RpcStatus));
        return(RpcStatus);
    }

    return(BindingFromStringBinding(&StringBinding, pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindSPX
//
//  Synopsis:   Attempt to bind over SPX.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindSPX(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_spx"),
                           ServerName,
                           pBindingHandle));
}

//+---------------------------------------------------------------------------
//
//  Function:   BindTCPIP
//
//  Synopsis:   Attempt to bind over TCP/IP.
//
//  Arguments:  [ServerName]     -- Server name to bind to.
//              [pBindingHandle] -- Returned binding handle.
//
//  Returns:    RPC_STATUS code
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
RPC_STATUS
BindTCPIP(LPWSTR ServerName, RPC_BINDING_HANDLE * pBindingHandle)
{
    return(BindViaProtocol(TEXT("ncacn_ip_tcp"),
                           ServerName,
                           pBindingHandle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\client\job.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       job.cxx
//
//  Contents:
//
//  Classes:    None.
//
//  Functions:
//
//  History:    14-Mar-96 EricB  created
//              21-Jun-96 MarkBl Renamed from jobedit.cxx since now Save() &
//                               Get/SetAccountInformation members require
//                               client-side rpc. Their implementations must
//                               reside here so we don't have to include the
//                               client-side RPC in the service. Also added
//                               Get/SetAccountInformation members.
//
//  Notes:      Disabled security code completely for Win95. This will be
//              enabled in the next release of the scheduling agent.
//
//              BUGBUG : The classes should be split into a core base class,
//                       then have an OLE-supporting class inherit from it.
//                       The core class would exist in the service. The sub-
//                       class in the dll.
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "network.hxx"
#include "misc.hxx"
#include "job_cls.hxx"
#include "debug.hxx"
#include "defines.hxx"
#include "SASecRPC.h"     // Get/SetAccountInformation RPC definition.
#include <StrSafe.h>

typedef DWORD (WINAPI * PWNETGETUNIVERSALNAMEW)(LPCWSTR, DWORD, LPVOID,
                                                    LPDWORD);

PWNETGETUNIVERSALNAMEW  gpWNetGetUniversalNameW = NULL;

HRESULT DisplayJobProperties(LPTSTR, ITask *);
//
// This operation is not supported locally on Win95, and for the first
// release of the scheduling agent, neither remotely from Win95 to NT.
//

void    ResetAccountInfo(PJOB_ACCOUNT_INFO pAccountInfo);


//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::EditWorkItem
//
//  Synopsis:   Invoke the edit job property sheet.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::EditWorkItem(HWND hParent, DWORD dwReserved)
{
    if (m_ptszFileName != NULL && m_ptszFileName[0] != TEXT('\0'))
    {
        return DisplayJobProperties(m_ptszFileName, (ITask *)this);
    }

    return STG_E_NOTFILEBASEDSTORAGE;
}

//+----------------------------------------------------------------------------
//
//      CJob::IProvideTaskPage::GetPage method
//
//-----------------------------------------------------------------------------

STDMETHODIMP
I_GetTaskPage(
    ITask              * pITask,
    TASKPAGE             tpType,
    BOOL                 fPersistChanges,
    HPROPSHEETPAGE    *  phPage);


STDMETHODIMP
CJob::GetPage(
    TASKPAGE            tpType,
    BOOL                fPersistChanges,
    HPROPSHEETPAGE    * phPage)
{
    return I_GetTaskPage((ITask *)this, tpType, fPersistChanges, phPage);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetAccountInformation
//
//  Synopsis:   Set the name and password of the account to be used for running
//              this job.
//
//  Arguments:  [pwszAccountName] -- Account name.
//              [pwszPassword]    -- Account password.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      Both strings are caller allocated and freed.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetAccountInformation(LPCWSTR pwszAccountName,
                            LPCWSTR pwszPassword)
{
    TRACE(CJob, SetAccountInformation)

	if( NULL == pwszAccountName )
	{
		return E_INVALIDARG;
	}
    //
    // This operation is not supported locally on Win95, and for the first
    // release of the scheduling agent, neither remotely from Win95 to NT.
    //

    HRESULT hr;

    //
    // Need to allocate the private data member structure containing copies
    // of the account arguments.
    //
    // Note, could allocate everything within a single buffer, but since
    // this operation is performed so rarely, it really isn't worth it.
    //

    PJOB_ACCOUNT_INFO pAccountInfo = new JOB_ACCOUNT_INFO;

    if (pAccountInfo == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pAccountInfo->pwszPassword = NULL;
    size_t acctLength = wcslen(pwszAccountName) + 1;
    pAccountInfo->pwszAccount  = new WCHAR[acctLength];

    if (pAccountInfo->pwszAccount != NULL)
    {
        StringCchCopy(pAccountInfo->pwszAccount, acctLength, pwszAccountName);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto ErrorExit;
    }

    if (pwszPassword != NULL)
    {
        size_t pwLength = wcslen(pwszPassword) + 1;
        pAccountInfo->pwszPassword = new WCHAR[pwLength];

        if (pAccountInfo->pwszPassword != NULL)
        {
            StringCchCopy(pAccountInfo->pwszPassword, pwLength, pwszPassword);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            goto ErrorExit;
        }
    }

    if (m_pAccountInfo != NULL)
    {
        ResetAccountInfo(m_pAccountInfo);
        delete m_pAccountInfo;
    }
    m_pAccountInfo = pAccountInfo;

    //
    // Setting this flag will result in the RPC call to set the account
    // information on object save (IPersistFile::Save()).
    //

    this->SetFlag(JOB_I_FLAG_SET_ACCOUNT_INFO);

    return(S_OK);

ErrorExit:
    if (pAccountInfo != NULL)
    {
        ResetAccountInfo(pAccountInfo);
        delete pAccountInfo;
    }

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetAccountInformation
//
//  Synopsis:   Get the name of the account to be used for this job.
//
//  Arguments:  [ppwszAccountName] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetAccountInformation(LPWSTR * ppwszAccountName)
{
    TRACE3(CJob, GetAccountInformation)

    //
    // This operation is not supported locally on Win95, and for the first
    // release of the scheduling agent, neither remotely from Win95 to NT.
    //

    HRESULT hr;

    //
    // Unexpected, but possible should the caller CoCreateInstance a new
    // job, then call this member w/o IPersistFile::Load/Save.
    //

    if (m_ptszFileName == NULL)
    {
        schDebugOut((DEB_ERROR,
                     "GetAccountInformation called with no filename\n"));
        return(E_UNEXPECTED);
    }

    //
    // Return cached account name. If it hasn't been obtained, we'll
    // need to RPC to the server to get it.
    //

    WCHAR   wszAccountName[MAX_USERNAME + 1];
    WCHAR * pwszAccountName = NULL;

    if (m_pAccountInfo == NULL)
    {
        //
        // RPC to the server local to this job to fetch the account name
        // associated with this job.
        //
        // First, figure out if this is a remote job. If so, fetch the server
        // name on which the job resides.
        //

        WCHAR   wszFileName[MAX_PATH + 1] = L"";
        WCHAR   wszUNCPath[MAX_PATH + 1];
        WCHAR * pwszFileName;
        WCHAR * pwszServerName;

        pwszFileName = m_ptszFileName;

        //
        // Fetch the server name associated with the network path. If the path
        // is local, the server name returned will be NULL.
        //

        hr = GetServerNameFromPath(pwszFileName,
                                   (MAX_PATH + 1) * sizeof(WCHAR),
                                   wszUNCPath,
                                   &pwszServerName);

        if (FAILED(hr))
        {
            return(hr);
        }


        //
        // RPC to the service to fetch the account name.
        //
        // First, isolate the relative job name from the remaining path.
        //

        WCHAR * pwszRelativeFileName;

        if (pwszFileName != NULL)
        {
            pwszRelativeFileName = wcsrchr(pwszFileName, L'\\');

            if (pwszRelativeFileName != NULL)
            {
                pwszRelativeFileName++;
            }
            else
            {
                pwszRelativeFileName = pwszFileName;
            }
        }

        DWORD ccAccountName = MAX_USERNAME;

        RpcTryExcept
        {
            hr = SAGetAccountInformation(pwszServerName,
                                         pwszRelativeFileName,
                                         ccAccountName,
                                         wszAccountName);
        }
        RpcExcept(1)
        {
            DWORD Status = RpcExceptionCode();
            schDebugOut((DEB_ERROR,
                "GetAccountInformation exception(0x%x)\n",
                Status));
            hr = SchedMapRpcError(Status);
        }
        RpcEndExcept;

        if (SUCCEEDED(hr))
        {
            pwszAccountName = wszAccountName;
        }
    }
    else
    {
        schAssert(m_pAccountInfo->pwszAccount != NULL);
        pwszAccountName = m_pAccountInfo->pwszAccount;
        hr = S_OK;
    }

    //
    // Allocate returned name.
    //

    if (pwszAccountName != NULL)
    {
        LPWSTR pwszAccountNameCopy;

        size_t pwLength = (wcslen(pwszAccountName) + 1);
        pwszAccountNameCopy = (LPWSTR)CoTaskMemAlloc(
                         pwLength * sizeof(WCHAR));

        if (pwszAccountNameCopy == NULL)
        {
            return(E_OUTOFMEMORY);
        }

        StringCchCopy(pwszAccountNameCopy, pwLength, pwszAccountName);
        *ppwszAccountName = pwszAccountNameCopy;
    }

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::Save
//
//  Synopsis:   Save job properties to the job object. Upon successful save,
//              if account credentials have been specified, set them via
//              RPC to the service.
//
//  Arguments:  [pwszFileName] - if null, save to the previously loaded file.
//              [fRemember]    - if TRUE, the object becomes associated with
//                               the new filename.
//
//  Notes:      This member must now be split into two versions with the
//              addition of security: one for the .dll in
//              sched\client\job.cxx, and for the .exe in
//              sched\svc_core\job.cxx. This was necessary as Save now
//              includes client-side rpc code. A single version of this
//              member would require the client-side rpc code to be included
//              in the service.
//
//              All OLE32 strings are UNICODE, including the filename passed
//              in the IPersistFile methods.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Save(LPCOLESTR pwszFileName, BOOL fRemember)
{
    HRESULT hr = S_OK;


    //
    // Always save fixed and variable length data, but Never alter the running
    // instance count from the COM interface method.
    //

    hr = SaveWithRetry(pwszFileName, fRemember, SAVEP_VARIABLE_LENGTH_DATA);
    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // Now that job changes are completely saved, set security information,
    // if specified. This order is important as the application name is tied
    // to the credentials for security reasons. If the application changes,
    // the existing credentials are invalidated.
    //
    // ** Important ** Maintain file save, security setting order!
    //

    if (IsFlagSet(JOB_I_FLAG_SET_ACCOUNT_INFO))
    {
        //
        // RPC to the server local to this job to fetch the account name
        // associated with this job.
        //
        // First, figure out if this is a remote job. If so, fetch the server
        // name on which the job resides.
        //

        WCHAR   wszUNCPath[MAX_PATH + 1];
        WCHAR * pwszFileNameLocal;
        WCHAR * pwszServerName;

        if (pwszFileName == NULL)
        {
            pwszFileNameLocal = m_ptszFileName;
        }
        else
        {
            pwszFileNameLocal = (WCHAR *)pwszFileName;
        }

        //
        // Fetch the server name associated with the network path. If the path
        // is local, the server name returned will be NULL.
        //

        hr = GetServerNameFromPath(pwszFileNameLocal,
                                   (MAX_PATH + 1) * sizeof(WCHAR),
                                   wszUNCPath,
                                   &pwszServerName);

        if (FAILED(hr))
        {
            return(hr);
        }


        //
        // RPC to the service to set the account information.
        //
        // First, isolate the relative job name from the remaining path.
        //

        WCHAR * pwszRelativeFileName;

        if (pwszFileNameLocal != NULL)
        {
            pwszRelativeFileName = wcsrchr(pwszFileNameLocal, L'\\');

            if (pwszRelativeFileName != NULL)
            {
                pwszRelativeFileName++;
            }
            else
            {
                pwszRelativeFileName = pwszFileNameLocal;
            }
        }

        RpcTryExcept
        {
            //
            // Note:  We pass the flags via RPC in order to let
            // the server side do the access checks for the NULL
            // password case.  These checks could technically be
            // done on the client side, but it's more convenient
            // (and smaller codesize) to do it this way
            //
            hr = SASetAccountInformation(pwszServerName,
                                         pwszRelativeFileName,
                                         m_pAccountInfo->pwszAccount,
                                         m_pAccountInfo->pwszPassword,
                                         m_rgFlags);
        }
        RpcExcept(1)
        {
            DWORD Status = RpcExceptionCode();
            schDebugOut((DEB_ERROR,
                "SetAccountInformation exception(0x%x)\n",
                Status));
            hr = SchedMapRpcError(Status);
        }
        RpcEndExcept;

        this->ClearFlag(JOB_I_FLAG_SET_ACCOUNT_INFO);

        //
        // NB : After successful save of the security information, the
        //      cached values are reset.
        //

        ResetAccountInfo(m_pAccountInfo);
        delete m_pAccountInfo;
        m_pAccountInfo = NULL;
    }

    return hr;
}

//
// This operation is not supported locally on Win95, and for the first
// release of the scheduling agent, neither remotely from Win95 to NT.
//

//+----------------------------------------------------------------------------
//
//  Function:   ResetAccountInfo
//
//  Synopsis:   Simple helper to zero the password and deallocate struct
//              JOB_ACCOUNT_INFO fields.
//
//  Arguments:  [pAccountInfo] -- Account info struct to reset.
//
//  Returns:    None.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
void
ResetAccountInfo(PJOB_ACCOUNT_INFO pAccountInfo)
{
    delete pAccountInfo->pwszAccount;
    pAccountInfo->pwszAccount = NULL;

    if (pAccountInfo->pwszPassword != NULL)
    {
        ZERO_PASSWORD(pAccountInfo->pwszPassword);
        delete pAccountInfo->pwszPassword;
        pAccountInfo->pwszPassword = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\client\dllmisc.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Application Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       dllmisc.cxx
//
//  Contents:   job scheduler class objects handler DLL fcns
//
//  History:    25-Sep-95 EricB created
//              23-Feb-01 JBenton added code to clean up debug crit sections
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL(Sched);

#include <job_cls.hxx>
#include <sch_cls.hxx>
#include <debug.hxx>

//
//  JobFolder related stuff
//

BOOL JFOnProcessAttach(void);
HRESULT JFGetClassObject(REFCLSID cid, REFIID riid, LPVOID *ppvObj);
HRESULT AllocFolderCFs(void);
void FreeFolderCFs(void);

extern HANDLE g_hActCtx;

//+----------------------------------------------------------------------------
//
//      DLL functions
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//
//-----------------------------------------------------------------------------
extern "C" BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            schDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_ATTACH\n"));

            //
            // Get instance handle
            //

            g_hInstance = hInstance;


			// init common controls and get activation context

			InitCommonControls();

			if (!GetCurrentActCtx(&g_hActCtx))
			{
                ERR_OUT("GetCurrentActCtx", 0);
                return FALSE;
			}

            //
            // Disable thread notification from OS
            //

            DisableThreadLibraryCalls(hInstance);

            HRESULT hr;

            //
            // Init the folder class factory objects.
            //

            hr = AllocFolderCFs();
            if (FAILED(hr))
            {
                ERR_OUT("AllocFolderCFs", hr);
                return FALSE;
            }

            //
            // Initialize the global service values.  These are globals that 
            // live in common\globals.cxx, and are used in both the service 
            // (mstask.exe) and client (mstask.dll). 
            //

            hr = InitGlobals();
            if (FAILED(hr))
            {
                ERR_OUT("InitGlobals", hr);
                FreeFolderCFs();
                return FALSE;
            }

            //
            //  Init job folder stuff
            //

            if (JFOnProcessAttach() == FALSE)
            {
                FreeGlobals();
                FreeFolderCFs();
                return FALSE;
            }

            break;

        case DLL_PROCESS_DETACH:
            schDebugOut((DEB_ITRACE, "DllMain: DLL_PROCESS_DETACH\n"));
#if DBG == 1
			CleanUpDebugging();
#endif
            FreeGlobals();
            FreeFolderCFs();
            break;
    }
    return(TRUE);
}

//+----------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Creates a class factory for the requested object.
//
//  Arguments:  [cid]    - the requested class object
//              [iid]    - the requested interface
//              [ppvObj] - returned pointer to class object
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(REFCLSID cid, REFIID iid, void **ppvObj)
{
    IUnknown *pUnk = NULL;
    HRESULT hr = S_OK;

    if (CLSID_CTask == cid)
    {
        pUnk = CJobCF::Create();
        if (pUnk != NULL)
        {
            hr = pUnk->QueryInterface(iid, ppvObj);
            pUnk->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else if (CLSID_CTaskScheduler == cid)
    {
        pUnk = CScheduleCF::Create();
        if (pUnk != NULL)
        {
            hr = pUnk->QueryInterface(iid, ppvObj);
            pUnk->Release();
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return JFGetClassObject(cid, iid, ppvObj);
    }
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Indicates whether the DLL can be removed if there are no
//              objects in existence.
//
//  Returns:    S_OK or S_FALSE
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow(void)
{
    return CDll::CanUnloadNow();
}

//+----------------------------------------------------------------------------
//
//  Function:   AddAtJobWithHash
//
//  Synopsis:   Client-side stub for this API to make things compile.  Only
//              supported/called on the server side
//
//  Returns:    E_NOTIMPL
//
//-----------------------------------------------------------------------------
STDAPI
CSchedule::AddAtJobWithHash(
    const AT_INFO &At,
    DWORD * pID)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\cdlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       cdlink.cxx
//
//  Contents:
//
//  Classes:    CDlink
//
//  History:    16-Oct-91  KevinRo Created
//
//--------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkAfter
//
// Purpose:     Links this after dlPrev and before dlPrev->_dlNext
//
// Returns:     this
//
// Note:        None.
//
//--------------------------------------------------------------------------
VOID CDLink::LinkAfter(CDLink * dlPrev)
{
    _dlPrev = dlPrev;

    if(dlPrev != NULL)
    {
        _dlNext = dlPrev->_dlNext;
        dlPrev->_dlNext = this;

        if(_dlNext != NULL) {
            _dlNext->_dlPrev = this;
        }
    }
    else
    {
        _dlNext = NULL;
    }
}
//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkBefore
//
// Purpose:     Links this Before dlNext and after dlNext->_dlPrev
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::LinkBefore(CDLink * dlNext)
{
    _dlNext = dlNext;

    if(dlNext != NULL)
    {
        _dlPrev = dlNext->_dlPrev;

        dlNext->_dlPrev = this;

        if(_dlPrev != NULL) {
            _dlPrev->_dlNext = this;
        }
    }
    else
    {
        _dlPrev = NULL;
    }
}

//+-------------------------------------------------------------------------
//
// Member:      CDLink::Unlink()
//
// Purpose:     Removes this from double linked list
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::UnLink()
{
    if(_dlNext != NULL) {
        _dlNext->_dlPrev = _dlPrev;
    }
    if(_dlPrev != NULL) {
        _dlPrev->_dlNext = _dlNext;
    }
    _dlNext = _dlPrev = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\foldersecurity.cpp ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       FolderSecurity.cpp
//
//  Contents:   Class to read folder security and perform access checks against it
//
//  History:    5-April-02 HHance created
//
//-----------------------------------------------------------------------------

#include <Windows.h>
#include <FolderSecurity.h>

// disable cilly warning about bools (we'll put it back, later...)
#pragma warning( push )
#pragma warning( disable: 4800)

// returns  S_OK if the folder's DACL allows the requested access
//          E_ACCESSDENIED if not
//          E_NOTFOUND if file/folder cannot be found
//          other error on other error

// HANDLE clientToken                       // handle to client access token
// DWORD desiredAccess                      // requested access rights
//
// NOTE: Do not use the GENERIC_XXX rights, they must already have been mapped
//
//          Suggested rights:
//                              FILE_READ_DATA
//                              FILE_WRITE_DATA
//                              FILE_EXECUTE
//                              FILE_DELETE_CHILD
//
HRESULT FolderAccessCheck(const WCHAR* pFolderName, HANDLE clientToken, DWORD desiredAccess)
{
    if ((desiredAccess == 0) ||
        (pFolderName == NULL))
        return false;

    
    HRESULT hr = E_ACCESSDENIED;

    DWORD dSize = 0;

    // call once to see how big a buffer we need
    if (!GetFileSecurityW(pFolderName, DACL_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION, NULL, 0, &dSize))
    {
        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
            return HRESULT_FROM_WIN32(dwErr);
    }

    PSECURITY_DESCRIPTOR pSD = NULL;

    if ((dSize > 0) && (pSD = new BYTE[dSize + 1]))
    {
        // get it for real (hopefully)
        if (GetFileSecurityW(pFolderName, DACL_SECURITY_INFORMATION  | GROUP_SECURITY_INFORMATION | OWNER_SECURITY_INFORMATION, pSD, dSize, &dSize))
        {
            // all the args access check could ever want
            GENERIC_MAPPING gm;          
            gm.GenericRead    = FILE_GENERIC_READ; 
            gm.GenericWrite   = FILE_GENERIC_WRITE; 
            gm.GenericExecute = FILE_GENERIC_EXECUTE; 
            gm.GenericAll     = FILE_ALL_ACCESS; 
           
            PRIVILEGE_SET ps;
            DWORD psLength = sizeof(PRIVILEGE_SET);

            // guilty until proven innocent
            BOOL accessStatus = FALSE;
            DWORD grantedAccess = 0;

            if (AccessCheck(pSD, clientToken, desiredAccess, &gm, &ps, &psLength, &grantedAccess, &accessStatus))
                if (accessStatus && ((grantedAccess & desiredAccess) == desiredAccess))
                    hr = S_OK;
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

        delete[] pSD;
    }

    return hr;
}

// helper function - uses current thread/process token
// to call AccessCheck
HRESULT FolderAccessCheckOnThreadToken(const WCHAR* pFolderName, DWORD desiredAccess)
{
   	HANDLE hToken = INVALID_HANDLE_VALUE;

    // Use the thread's own token if he's got one.
    HRESULT hr = E_ACCESSDENIED;

    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
        hr = FolderAccessCheck(pFolderName, hToken, desiredAccess);
    else
    // that didn't work, let's see if we can get the process token
    {
        if (ImpersonateSelf(SecurityImpersonation))
        {
            if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
                hr = FolderAccessCheck(pFolderName, hToken, desiredAccess);
            RevertToSelf();
        }
    }
        
    if (hToken != INVALID_HANDLE_VALUE)
        CloseHandle(hToken);

    return hr;
}

// helper function - makes use of RPC Impersonation capabilities
// intended to be called from the task scheduler service process
// if bHandleImpersonation is true, this function calls RPCImpersonateClient and RPCRevertToSelf
HRESULT RPCFolderAccessCheck(const WCHAR* pFolderName, DWORD desiredAccess, bool bHandleImpersonation)
{
    HRESULT hr = E_ACCESSDENIED;

    bool bRet = true;

    if (bHandleImpersonation)
        bRet = (RPC_S_OK == RpcImpersonateClient(NULL));

    if (bRet)
    {        
       	HANDLE hToken = INVALID_HANDLE_VALUE;
    
        bRet = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken);
        
        if (bHandleImpersonation)
            RpcRevertToSelf();

        if (bRet)
            hr = FolderAccessCheck(pFolderName, hToken, desiredAccess);

        if (hToken != INVALID_HANDLE_VALUE)
            CloseHandle(hToken);
    }

    return hr;
};

// helper function - makes use of COM impersonation capabilities
// ** Will Fail if COM hasn't been initialized **
// ** Or we can't imperonate the client        **
HRESULT CoFolderAccessCheck(const WCHAR* pFolderName, DWORD desiredAccess)
{
    bool bAlreadyImpersonated = false;
    IServerSecurity* iSecurity = NULL;
    HRESULT hr = E_ACCESSDENIED;
    
    if (SUCCEEDED(hr = CoGetCallContext(IID_IServerSecurity, (void**)&iSecurity)))
    {
        // We were impersonating when we got here?
        // if not - try to impersonate the client now.
        bool bWeImpersonating = false;
        if (bAlreadyImpersonated = iSecurity->IsImpersonating())
            bWeImpersonating = true;
        else
            bWeImpersonating = SUCCEEDED(iSecurity->ImpersonateClient());

        // if we've got a thread token, let the helper's helper help out
        if (bWeImpersonating)
        {                    
            HANDLE hToken = INVALID_HANDLE_VALUE;
            if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
            {
                if (!bAlreadyImpersonated)
                    iSecurity->RevertToSelf();
                hr = FolderAccessCheck(pFolderName, hToken, desiredAccess);
                CloseHandle(hToken);
            }
            else if (!bAlreadyImpersonated)
                iSecurity->RevertToSelf();
        }

        iSecurity->Release();
    }
    else if ((hr == RPC_E_CALL_COMPLETE) || (hr == CO_E_NOTINITIALIZED))
        hr = FolderAccessCheckOnThreadToken(pFolderName, desiredAccess);

    return hr;
}


#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\globals.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       globals.cxx
//
//  Contents:   Service global data.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    09-Sep-95   EricB   Created.
//              01-Dec-95   MarkBl  Split from util.cxx.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <sddl.h>
#include "..\inc\resource.h"
#include "..\inc\common.hxx"
#include "..\inc\debug.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\security.hxx"

void
GetRootPath(
    LPCWSTR pwszPath,
    WCHAR   wszRootPath[]);

TasksFolderInfo g_TasksFolderInfo            = { NULL, FILESYSTEM_FAT };
TCHAR           g_tszSrvcName[]              = SCHED_SERVICE_NAME;
BOOL            g_fNotifyMiss;               // = 0 by loader
HINSTANCE       g_hInstance;                 // = NULL by loader
HANDLE			g_hActCtx;					 //	= NULL by loader
ULONG           CDll::s_cObjs;               // = 0 by loader
ULONG           CDll::s_cLocks;              // = 0 by loader

WCHAR           g_wszAtJobSearchPath[MAX_PATH + 1];

#define DEFAULT_FOLDER_PATH     TEXT("%WinDir%\\Tasks")
#define TASKS_FOLDER            TEXT("\\Tasks")

//
// BUGBUG: global __int64 initialization is not working without the CRT.
// BUG # 37752.
//
__int64 FILETIMES_PER_DAY;

//+----------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis:   constructs global strings including the folder path strings and,
//              if needed, creates the folders
//
//  Returns:    HRESULTS
//
//  Notes:      This function is called in exactly two places, once for each
//              binary: in dllmisc.cxx for the DLL and in svc_core.cxx for the
//              service.
//-----------------------------------------------------------------------------
HRESULT
InitGlobals(void)
{
    HRESULT hr = S_OK;

    hr = GetTasksFolder(&g_TasksFolderInfo.ptszPath);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // if the Jobs folder doesn't exist, create it and set security
    //
    hr = EnsureTasksFolderExists(g_TasksFolderInfo.ptszPath);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Initialize the file system type global task folder info field.
    //
    hr = GetFileSystemTypeFromPath(g_TasksFolderInfo.ptszPath,
                                   &g_TasksFolderInfo.FileSystemType);
    if (FAILED(hr))
    {
        return hr;
    }

    schDebugOut((DEB_ITRACE,
                 "Path to local sched folder: \"" FMT_TSTR "\"\n",
                 g_TasksFolderInfo.ptszPath));

    //
    // Read the "NotifyOnTaskMiss" value.  Default value is 0.
    //
    hr = GetNotifyOnTaskMiss(&g_fNotifyMiss);
    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Create the AT task FindFirstFile filespec
    //

    ULONG cchAtJobSearchPath;

    cchAtJobSearchPath = lstrlen(g_TasksFolderInfo.ptszPath) +
                         ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1 +
                         ARRAY_LEN(TSZ_DOTJOB) - 1 +
                         3; // backslash, start, and nul terminator

    if (cchAtJobSearchPath > ARRAY_LEN(g_wszAtJobSearchPath))
    {
        schDebugOut((DEB_ERROR,
                    "InitGlobals: At job search path is %u chars but dest buffer is %u\n",
                    cchAtJobSearchPath,
                    ARRAY_LEN(g_wszAtJobSearchPath)));
        return E_FAIL;
    }

    StringCchCopy(g_wszAtJobSearchPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    StringCchCat(g_wszAtJobSearchPath, MAX_PATH + 1, L"\\" TSZ_AT_JOB_PREFIX L"*" TSZ_DOTJOB);

    //
    // BUGBUG: This is temporary until global __int64 initialization is working
    // without the CRT:
    //
    FILETIMES_PER_DAY = (__int64)FILETIMES_PER_MINUTE *
                        (__int64)JOB_MINS_PER_HOUR *
                        (__int64)JOB_HOURS_PER_DAY;
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   FreeGlobals
//
//  Synopsis:   frees dynamically allocated globals
//
//  Notes:      This function is called in exactly two places, once for each
//              binary: in dllmisc.cxx for the DLL and in svc_core.cxx for the
//              service.
//-----------------------------------------------------------------------------
void
FreeGlobals(void)
{
    if (g_TasksFolderInfo.ptszPath != NULL)
    {
        delete g_TasksFolderInfo.ptszPath;
        g_TasksFolderInfo.ptszPath = NULL;
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   ReadLastTaskRun
//
//  Synopsis:   Reads the last task run time from the registry.
//
//  Returns:    TRUE if successful, FALSE if unsuccessful
//
//  Notes:
//
//-----------------------------------------------------------------------------
BOOL
ReadLastTaskRun(SYSTEMTIME * pstLastRun)
{
    HKEY hSchedKey;
    LONG lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ,
                             &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Sched key", lErr);
        return FALSE;
    }

    DWORD cb = sizeof SYSTEMTIME;
    DWORD dwType;
    lErr = RegQueryValueEx(hSchedKey, SCH_LASTRUN_VALUE, NULL, &dwType,
                           (LPBYTE)pstLastRun, &cb);

    RegCloseKey(hSchedKey);

    if (lErr != ERROR_SUCCESS || dwType != REG_BINARY || cb != sizeof SYSTEMTIME)
    {
        schDebugOut((DEB_ERROR, "RegQueryValueEx of LastRunTime value failed, "
                                "error %ld, dwType = %lu, cb = %lu\n",
                                lErr, dwType, cb));
        return FALSE;
    }

    return TRUE;
}


//+----------------------------------------------------------------------------
//
//  Function:   WriteLastTaskRun
//
//  Synopsis:   Writes the last task run time to the registry.
//
//  Returns:    TRUE if successful, FALSE if unsuccessful
//
//  Notes:
//
//-----------------------------------------------------------------------------
void WriteLastTaskRun(const SYSTEMTIME * pstLastRun)
{
    HKEY hSchedKey;
    LONG lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_WRITE,
                             &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Sched key for write", lErr);
        return;
    }

    lErr = RegSetValueEx(hSchedKey, SCH_LASTRUN_VALUE, 0, REG_BINARY,
                         (const BYTE *) pstLastRun, sizeof SYSTEMTIME);

    if (lErr != ERROR_SUCCESS)
    {
        schDebugOut((DEB_ERROR, "RegSetValueEx of LastRunTime value failed %ld\n",
                                lErr));
    }

    RegCloseKey(hSchedKey);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetFileSystemTypeFromPath
//
//  Synopsis:   Determine the file system type, either FAT or NTFS, from
//              the path passed.
//
//  Arguments:  [pwszPath]     -- Input path.
//              [wszRootPath]  -- Returned root path.
//
//  Returns:    S_OK
//              GetVolumeInformation HRESULT error code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetFileSystemTypeFromPath(LPCWSTR pwszPath, FILESYSTEMTYPE * pFileSystemType)
{
#define FS_NTFS             L"NTFS"
#define FS_NAME_BUFFER_SIZE (sizeof(FS_NTFS) * 2)

    //
    // Obtain the root path (eg: "r:\", "\\fido\scratch\", etc.) from the
    // path.
    //

    LPWSTR pwszRootPath = new WCHAR[wcslen(pwszPath) + 2];
    if (pwszRootPath == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return E_OUTOFMEMORY;
    }

    GetRootPath(pwszPath, pwszRootPath);

    //
    // Retrieve the file system name.
    //

    WCHAR wszFileSystemName[FS_NAME_BUFFER_SIZE + 1];
    DWORD dwMaxCompLength, dwFileSystemFlags;

    if (!GetVolumeInformation(pwszRootPath,         // Root path name.
                              NULL,                 // Ignore name.
                              0,
                              NULL,                 // Ignore serial no.
                              &dwMaxCompLength,     // Unused.
                              &dwFileSystemFlags,   // Unused.
                              wszFileSystemName,    // "FAT"/"NTFS".
                              FS_NAME_BUFFER_SIZE)) // name buffer size.
    {
        HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        delete [] pwszRootPath;
        return hr;
    }

    delete [] pwszRootPath;

    //
    // Check if the volume is NTFS.
    // If not NTFS, assume FAT.
    //

    if (_wcsicmp(wszFileSystemName, FS_NTFS) == 0)
    {
        *pFileSystemType = FILESYSTEM_NTFS;
    }
    else
    {
        *pFileSystemType = FILESYSTEM_FAT;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetRootPath
//
//  Synopsis:   Return the root portion of the path indicated. eg: return
//                  "r:\" from "r:\foo\bar"
//                   "\\fido\scratch\", from "\\fido\scratch\bar\foo"
//
//  Arguments:  [pwszPath]     -- Input path.
//              [wszRootPath]  -- Returned root path.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
GetRootPath(LPCWSTR pwszPath, WCHAR wszRootPath[])
{
    LPCWSTR pwsz = pwszPath;

    if (*pwsz == L'\\')
    {
        if (*(++pwsz) == L'\\')
        {
            //
            // UNC path. GetVolumeInformation requires the trailing '\'
            // on the UNC path. eg: \\server\share\.
            //

            DWORD i;
            for (i = 0, pwsz++; *pwsz && i < 2; i++, pwsz++)
            {
                for ( ; *pwsz && *pwsz != L'\\'; pwsz++) ;
            }
            if (i == 2)
            {
                pwsz--;
            }
            else
            {
                goto ErrorExit;
            }
        }
        else
        {
            //
            // Path is "\".  Not an error, but handled the same way
            //
            goto ErrorExit;
        }
    }
    else
    {
        for ( ; *pwsz && *pwsz != L'\\'; pwsz++) ;
    }

    if (*pwsz == L'\\')
    {
        DWORD cbLen = (DWORD)((BYTE *)pwsz - (BYTE *)pwszPath) + sizeof(L'\\');
        CopyMemory((LPWSTR)wszRootPath, (LPWSTR)pwszPath, cbLen);
        wszRootPath[cbLen / sizeof(WCHAR)] = L'\0';
        return;
    }
    else
    {
        //
        // Fall through.
        //
    }

ErrorExit:
    //
    // Return '\' in error cases.
    //

    wszRootPath[0] = L'\\';
    wszRootPath[1] = L'\0';
}

//+---------------------------------------------------------------------------
//
//  Function:   GetTasksFolder
//
//  Synopsis:   Get tasks folder setting from registry
//
//  Arguments:  [ppwszPath] -- pointer to pointer to WCHAR string to receive value
//
//  Returns:    HRESULT
//
//  Notes:      The caller of this function will need to delete the allocated memory.
//
//----------------------------------------------------------------------------

HRESULT GetTasksFolder(WCHAR** ppwszPath)
{
    HRESULT hr = S_OK;

    //
    // Open the schedule agent key
    //
    long lErr;
    HKEY hSchedKey = NULL;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ, &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
    }

    WCHAR wszFolder[MAX_PATH + 1] = L"";

    // Ensure null termination (registry doesn't guarantee this if not string data)
    wszFolder[MAX_PATH] = L'\0';

    if (hSchedKey != NULL)
    {
        //
        // Get the jobs folder location
        //
        DWORD cb = MAX_PATH * sizeof(WCHAR);  // note that this is one less than the actual buffer size

        lErr = RegQueryValueEx(hSchedKey, SCH_FOLDER_VALUE, NULL, NULL, (LPBYTE)wszFolder, &cb);
        if (lErr != ERROR_SUCCESS)
        {
            ERR_OUT("RegQueryValueEx of Scheduler TasksFolder value", lErr);
            //
            // The task folder value is missing, create it.
            //
            // Reopen the key with write access.
            //
            RegCloseKey(hSchedKey);

            lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_SET_VALUE, &hSchedKey);
            if (lErr != ERROR_SUCCESS)
            {
                ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
                hSchedKey = NULL;
            }
            else
            {
                //
                // Default to the windows root.
                //
                lErr = RegSetValueEx(hSchedKey,
                                     SCH_FOLDER_VALUE,
                                     0,
                                     REG_EXPAND_SZ,
                                     (const BYTE *) DEFAULT_FOLDER_PATH,
                                     sizeof(DEFAULT_FOLDER_PATH));

                if (lErr != ERROR_SUCCESS)
                {
                    ERR_OUT("RegSetValueEx of Scheduler TasksFolder value", lErr);
                }
            }
        }

        if (hSchedKey != NULL)
        {
            RegCloseKey(hSchedKey);
        }
    }

    //
    // Use a default if the value is missing.
    //
    if (lstrlen(wszFolder) == 0)
    {
        StringCchCopy(wszFolder, MAX_PATH + 1, DEFAULT_FOLDER_PATH);
    }

    //
    // The ExpandEnvironmentStrings character counts include the terminating null.
    //
    DWORD cch = ExpandEnvironmentStrings(wszFolder, NULL, 0);
    if (!cch)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("ExpandEnvironmentStrings", hr);
        return hr;
    }

    //
    // Caller will need to delete this
    //
    *ppwszPath = new WCHAR[cch];
    if (*ppwszPath == NULL)
    {
        ERR_OUT("Tasks Folder name buffer allocation", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    cch = ExpandEnvironmentStrings(wszFolder, *ppwszPath, cch);
    if (!cch)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("ExpandEnvironmentStrings", hr);
        return hr;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetNotifyOnTaskMiss
//
//  Synopsis:   Get NotifyOnTaskMiss setting from registry
//
//  Arguments:  [pfNotifyOnTaskMiss] -- pointer to boolean flag to receive value
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT GetNotifyOnTaskMiss(BOOL* pfNotifyOnTaskMiss)
{
    HRESULT hr = S_OK;

    if (!pfNotifyOnTaskMiss)
        return E_INVALIDARG;

    //
    // default value in case it can't be retrieved from registry
    //
    *pfNotifyOnTaskMiss = 0;

    //
    // Open the schedule agent key
    //
    long lErr;
    HKEY hSchedKey = NULL;
    lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SCH_AGENT_KEY, 0, KEY_READ, &hSchedKey);
    if (lErr != ERROR_SUCCESS)
    {
        ERR_OUT("RegOpenKeyEx of Scheduler key", lErr);
    }

    if (hSchedKey != NULL)
    {
        //
        // Read the "NotifyOnTaskMiss" value.  Default value is 0.
        //
        DWORD cb = sizeof BOOL; // size of *pfNotifyOnTaskMiss
        lErr = RegQueryValueEx(hSchedKey, SCH_NOTIFYMISS_VALUE, NULL, NULL, (LPBYTE) pfNotifyOnTaskMiss, &cb);
        if (lErr != ERROR_SUCCESS)
        {
            if (lErr != ERROR_FILE_NOT_FOUND)
            {
                ERR_OUT("RegQueryValueEx of NotifyOnTaskMiss value", lErr);
            }
        }
        schDebugOut((DEB_TRACE, "Notification of missed runs is %s\n",
                     *pfNotifyOnTaskMiss ? "enabled" : "disabled"));

        RegCloseKey(hSchedKey);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateDesktopIni
//
//  Synopsis:   Create the desktop.ini file in the Tasks folder.
//
//  Arguments:  [pwszFolderPath]  -- Path to the Tasks folder.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount written isn't what we expected.
//              Create/WriteFile HRESULT status code on failure.
//
//----------------------------------------------------------------------------
HRESULT CreateDesktopIni(LPCWSTR pwszFolderPath)
{
    HRESULT hr = S_OK;
    
    //
    // Create the file
    //
    WCHAR wszDesktopIniPath[MAX_PATH + 1];
    StringCchCopy(wszDesktopIniPath, MAX_PATH + 1, pwszFolderPath);
    StringCchCat(wszDesktopIniPath, MAX_PATH + 1, L"\\desktop.ini");

    HANDLE hFile = CreateFile(wszDesktopIniPath,
                              GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              CREATE_NEW,
                              FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return hr;
    }

    //
    // Write out the contents.
    //
    char szFileContents[66] = "[.ShellClassInfo]\r\nCLSID={d6277990-4c6a-11cf-8d87-00aa0060f5bf}\r\n";
    DWORD cbToWrite = (66 - 1) * sizeof(char);
    DWORD cbWritten;
    if (!WriteFile(hFile, &szFileContents, cbToWrite, &cbWritten, NULL) || cbWritten != cbToWrite)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    CloseHandle(hFile);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnsureTasksFolderExists
//
//  Synopsis:   Check that the folder is there;
//              if not then create it and set security appropriately
//
//  Arguments:  [pwszPath] -- path to tasks folder
//              [bEnableShellExtension] -- indicate whether we are to make this
//              folder use our shell extenstion when viewed via explorer.  Default
//              is TRUE if not specified.  It should be FALSE if this function
//              is being used to recreate a folder only used for logging.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT EnsureTasksFolderExists(LPWSTR pwszPath, BOOL bEnableShellExtension /* = TRUE */)
{
    HRESULT hr = S_OK;

    //
    // check that the folder is there, if not then create it and set security appropriately
    //
    DWORD dwAttribs = GetFileAttributes(pwszPath);
    if (0xFFFFFFFF == dwAttribs)
    {
        PSECURITY_DESCRIPTOR pSD = NULL;
        WCHAR* pwszSDDL = NULL;

        OSVERSIONINFOEX verInfo;
        verInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        if (!GetVersionEx((LPOSVERSIONINFOW)&verInfo))
            return E_FAIL;

        if (verInfo.wProductType == VER_NT_WORKSTATION)
            pwszSDDL = 
                L"D:P(A;OICIIO;FA;;;CO)(A;;0x1200ab;;;AU)(A;OICI;FA;;;BA)(A;OICI;FA;;;SY)"                
                L"S:(AU;SAFAOICI;FWDCSDWDWO;;;WD)(AU;SAFAOICI;FWDCSDWDWO;;;AN)";
        else
            pwszSDDL = 
                L"D:P(A;OICIIO;FA;;;CO)(A;;0x1200ab;;;BO)(A;;0x1200ab;;;SO)(A;OICI;FA;;;BA)(A;OICI;FA;;;SY)"
                L"S:(AU;SAFAOICI;FWDCSDWDWO;;;WD)(AU;SAFAOICI;FWDCSDWDWO;;;AN)";        
        //
        // generate SD to be used for tasks folder
        //
        if (!ConvertStringSecurityDescriptorToSecurityDescriptorW(pwszSDDL, SDDL_REVISION_1, &pSD, NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("ConvertStringSecurityDescriptorToSecurityDescriptorW", hr);
        }

        if (SUCCEEDED(hr))
        {
            //
            // Enable SecurityPrivilege in order to be able to set the SACL
            //
            BOOL bWasEnabled = FALSE;
            DWORD dwErr = EnablePrivilege(SE_SECURITY_NAME, TRUE, &bWasEnabled);
            if (ERROR_SUCCESS != dwErr)
            {
                hr = HRESULT_FROM_WIN32(dwErr);
                ERR_OUT("EnablePrivilege", hr);
            }
    
            if (SUCCEEDED(hr))
            {
                SECURITY_ATTRIBUTES saAttributes;
                saAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
                saAttributes.lpSecurityDescriptor = pSD;
                saAttributes.bInheritHandle = FALSE;
            
                if (!CreateDirectory(pwszPath, &saAttributes))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("CreateDirectory", hr);
                }

                if (bEnableShellExtension)
                {
                    //
                    // Folder must have SYSTEM attribute in order to be treated properly by Explorer
                    //
                    if (SUCCEEDED(hr))
                    {
                        if (!SetFileAttributes(pwszPath, FILE_ATTRIBUTE_SYSTEM))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            ERR_OUT("SetFileAttributes", hr);
                        }
                    }
    
                    //
                    // Create the desktop.ini file that specifies the shell class for our extension
                    //
                    if (SUCCEEDED(hr))
                    {
                        hr = CreateDesktopIni(pwszPath);
                    }
                }

                //
                // UnEnable SecurityPrivilege if it wasn't originally enabled
                //
                if (!bWasEnabled)
                {
                    dwErr = EnablePrivilege(SE_SECURITY_NAME, FALSE, 0);
                    if (ERROR_SUCCESS != dwErr)
                    {
                        if (SUCCEEDED(hr))
                        {
                            // if above calls were successful then we'll report this error; otherwise,
                            // the above failure is more interesting so we skip this and return that one.
                            // either way, an error is going to get returned
                            hr = HRESULT_FROM_WIN32(dwErr);
                            ERR_OUT("EnablePrivilege UnEnable", hr);
                        }
                    }
                }
            }
    
            LocalFree(pSD);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\runobj.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       runobj.cxx
//
//  Contents:   Run instance object class implementations.
//
//  Classes:    CRun and CRunList
//
//  History:    14-Mar-96   EricB   Created.
//              10-Nov-96   AnirudhS Fixed CRunList::AddSorted to discard the
//                  appropriate element if the list is at its maximum size.
//                  Fixed CRunList::MakeSysTimeArray to call CoTaskMemAlloc
//                  once instead of calling CoTaskMemRealloc in a loop.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <job_cls.hxx>
#include <misc.hxx>
#include <debug.hxx>
#include "..\svc_core\svc_core.hxx"
#include <userenv.h>  // UnloadUserProfile

PFNSetThreadExecutionState  pfnSetThreadExecutionState;
DWORD   g_WakeCountSlot = 0xFFFFFFFF;

//+----------------------------------------------------------------------------
//
//  Run instance object class
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor for time-sorted lists.
//
//-----------------------------------------------------------------------------
CRun::CRun(LPFILETIME pft, LPFILETIME pftDeadline, FILETIME ftKill,
           DWORD MaxRunTime, DWORD rgFlags, WORD wIdleWait,
           BOOL fKeepAfterRunning) :
    m_ft(*pft),
    m_ftDeadline(*pftDeadline),
    m_ftKill(ftKill),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(0),
    m_hUserToken(NULL),
    m_ptszDesktop(NULL),
    m_ptszStation(NULL),
    m_hProfile(NULL),
    m_rgFlags(rgFlags),
    m_dwMaxRunTime(MaxRunTime),
    m_wIdleWait(wIdleWait),
    m_fKeepInList(fKeepAfterRunning),
    m_fStarted(FALSE),
    m_bCloseUserHandle(FALSE)
{
    schDebugOut((DEB_TRACE, "CRun::CRun(0x%x)\n", this));
}

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor for non-time-sorted lists.
//
//-----------------------------------------------------------------------------
CRun::CRun(DWORD MaxRunTime, DWORD rgFlags, FILETIME ftDeadline,
           BOOL fKeepAfterRunning) :
    m_ftDeadline(ftDeadline),
    m_ftKill(MAX_FILETIME),
    m_hJob(NULL),
    m_ptszJobName(NULL),

    m_dwProcessId(0),
    m_ptszDesktop(NULL),
    m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
    m_rgFlags(rgFlags),
    m_dwMaxRunTime(MaxRunTime),
    m_wIdleWait(0),
    m_fKeepInList(fKeepAfterRunning),
    m_fStarted(FALSE),
    m_bCloseUserHandle(FALSE)
{
    //schDebugOut((DEB_TRACE, "CRun::CRun(0x%x)\n", this));
    //
    // This ctor is used for non-sorted lists. Set the time elements to
    // non-zero values to distinguish these elements from the head.
    //
    // CODEWORK - Don't use 0,0 to mark the head.  Remove IsNull() method.
    // Instead use a NULL Next pointer to mark the last list element.
    //
    m_ft.dwLowDateTime = 1;
    m_ft.dwHighDateTime = 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor for idle-time-sorted lists.
//
//-----------------------------------------------------------------------------
CRun::CRun(DWORD MaxRunTime, DWORD rgFlags, WORD wIdleWait,
           FILETIME ftDeadline, BOOL fKeepAfterRunning) :
    m_ftDeadline(ftDeadline),
    m_ftKill(MAX_FILETIME),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(0),
    m_ptszDesktop(NULL),
    m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
    m_rgFlags(rgFlags),
    m_dwMaxRunTime(MaxRunTime),
    m_wIdleWait(wIdleWait),
    m_fKeepInList(fKeepAfterRunning),
    m_fStarted(FALSE),
    m_bCloseUserHandle(FALSE)
{
    TRACE3(CRun,CRun);
    //
    // Set the time elements to non-zero values to distinguish
    // these elements from the head.
    // CODEWORK - as above, don't do this.
    //
    m_ft.dwLowDateTime = 1;
    m_ft.dwHighDateTime = 1;
}

//+----------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   copy ctor.
//
//  Notes:      This ctor should not be used to copy running objects, i.e.
//              objects that have valid process, user token, or profile
//              handles.
//
//-----------------------------------------------------------------------------
CRun::CRun(CRun * pRun) :
    m_ft(pRun->m_ft),
    m_ftDeadline(pRun->m_ftDeadline),
    m_ftKill(pRun->m_ftKill),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(pRun->m_dwProcessId),
    m_ptszDesktop(NULL),
    m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
    m_rgFlags(pRun->m_rgFlags),
    m_dwMaxRunTime(pRun->m_dwMaxRunTime),
    m_wIdleWait(pRun->m_wIdleWait),
    m_fKeepInList(pRun->m_fKeepInList),
    m_fStarted(pRun->m_fStarted),
    m_bCloseUserHandle(FALSE)
{
    TRACE3(CRun,CRun(Copy));

    SetName(pRun->m_ptszJobName);
    schAssert(!pRun->m_hJob);
    schAssert(!pRun->m_hUserToken);
    schAssert(!pRun->m_hProfile);
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::CRun
//
//  Synopsis:   ctor
//
//----------------------------------------------------------------------------
CRun::CRun(void) :
    m_ftDeadline(MAX_FILETIME),
    m_ftKill(MAX_FILETIME),
    m_hJob(NULL),
    m_ptszJobName(NULL),
    m_dwProcessId(0),
    m_ptszDesktop(NULL),
    m_ptszStation(NULL),
    m_hUserToken(NULL),
    m_hProfile(NULL),
    m_rgFlags(0),
    m_dwMaxRunTime(RUN_TIME_NO_END),
    m_wIdleWait(0),
    m_fKeepInList(FALSE),
    m_fStarted(FALSE),
    m_bCloseUserHandle(FALSE)
{
    //schDebugOut((DEB_TRACE, "CRun::CRun(0x%x)\n", this));
    //
    // The null arg ctor is used only by CRunList for its head element
    // member. The zero time value for this element marks it as the head
    // when traversing the doubly linked list.
    //
    m_ft.dwLowDateTime = 0;
    m_ft.dwHighDateTime = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::~CRun
//
//  Synopsis:   dtor
//
//----------------------------------------------------------------------------
CRun::~CRun()
{
    BOOL fOk;

    //schDebugOut((DEB_TRACE, "CRun::~CRun(0x%x)\n", this));
    if (m_hJob)
    {
        CloseHandle(m_hJob);
    }
    if (m_ptszJobName)
    {
        delete m_ptszJobName;
    }

    if (m_hProfile)
    {
        fOk = UnloadUserProfile(m_hUserToken, m_hProfile);

        if (!fOk)
        {
            ERR_OUT("~CRun: UnloadUserProfile",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if (m_hUserToken && m_bCloseUserHandle)
    {
        fOk = CloseHandle(m_hUserToken);
        if (!fOk)
        {
            ERR_OUT("~CRun: CloseHandle",
                    HRESULT_FROM_WIN32(GetLastError()));
        }
    }
    if ( m_ptszDesktop )
    {
        delete m_ptszDesktop;
    }
    
    if ( m_ptszStation )
    {
        delete m_ptszStation;
    }
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::SetName
//
//  Synopsis:   Set the job name property. This is the folder-relative name.
//
//----------------------------------------------------------------------------
HRESULT
CRun::SetName(LPCTSTR ptszName)
{
    if (m_ptszJobName)
    {
        delete m_ptszJobName;
        m_ptszJobName = NULL;
    }

    if (!ptszName)
    {
        return S_OK;
    }

    size_t cchBuff = lstrlen(ptszName) + 1;
    m_ptszJobName = new TCHAR[cchBuff];

    if (m_ptszJobName == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    StringCchCopy(m_ptszJobName, cchBuff, ptszName);

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Method:     CRun::SetDesktop
//
//  Synopsis:   Set the Desktop name property. This is the windows station \ desktop.
//
//----------------------------------------------------------------------------
HRESULT
CRun::SetDesktop( LPCTSTR ptszDesktop )
{
    if (m_ptszDesktop)
    {
        delete m_ptszDesktop;
        m_ptszDesktop = NULL;
    }

    if (!ptszDesktop)
    {
        return S_OK;
    }

    size_t cchBuff = lstrlen(ptszDesktop) + 1;
    m_ptszDesktop = new TCHAR[cchBuff];

    if (m_ptszDesktop == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    StringCchCopy(m_ptszDesktop, cchBuff, ptszDesktop);

    return(S_OK);
}
//+---------------------------------------------------------------------------
//
//  Method:     CRun::SetStation
//
//  Synopsis:   Set the Desktop name property. This is the windows station \ desktop.
//
//----------------------------------------------------------------------------
HRESULT
CRun::SetStation( LPCTSTR ptszStation )
{
    if (m_ptszStation)
    {
        delete m_ptszStation;
        m_ptszStation = NULL;
    }

    if (!ptszStation)
    {
        return S_OK;
    }

    size_t cchBuff = lstrlen(ptszStation) + 1;
    m_ptszStation = new TCHAR[cchBuff];

    if (m_ptszStation == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    StringCchCopy(m_ptszStation, cchBuff, ptszStation);

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Method:     CRun::AdjustKillTimeByMaxRunTime
//
//  Synopsis:   If the job has a max run time, advance its kill time to "now"
//              plus the max run time.
//
//----------------------------------------------------------------------------
void
CRun::AdjustKillTimeByMaxRunTime(FILETIME ftNow)
{
    if (m_dwMaxRunTime != INFINITE)
    {
        AdvanceKillTime(FTfrom64(
                 FTto64(ftNow) +
                     (DWORDLONG) m_dwMaxRunTime *
                     FILETIMES_PER_MILLISECOND));
    }
}


//+----------------------------------------------------------------------------
//
//  Run object list class
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CRunList::FreeList
//
//  Synopsis:   Frees the linked list elements, skipping the head.
//
//-----------------------------------------------------------------------------
void
CRunList::FreeList(void)
{
    //
    // Skip the head, it is a placeholder in the circular list with a time
    // value of zero. The zero time value is used as a marker so that we can
    // tell when we have traversed the entire list.
    //
    CRun * pCur = m_RunHead.Next();

    while (!pCur->IsNull())
    {
        CRun * pNext = pCur->Next();
        pCur->UnLink();
        delete pCur;
        pCur = pNext;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CRunList::AddSorted
//
//  Synopsis:   Add to the list in time sorted order.
//
//  Arguments:  [ftRun] -
//              [ftDeadline] -
//              [ftKillTime] -
//              [ptszJobName] -
//              [dwJobFlags] -
//              [dwMaxRunTime] -
//              [wIdleWait] -
//              [pCount] - On entry and on exit, points to the number of
//                  elements in the list.
//              [cLimit] - Limit on the number of elements in the list.
//
//  Returns:    S_OK - new run added to the list.
//              S_FALSE - new run not added to the list because the list has
//                  already reached its size limit and the new job's run time
//                  is later than the last run time in the list.
//
//-----------------------------------------------------------------------------
HRESULT
CTimeRunList::AddSorted(FILETIME ftRun, FILETIME ftDeadline, FILETIME ftKillTime,
                        LPTSTR ptszJobName,
                    DWORD dwJobFlags, DWORD dwMaxRunTime, WORD wIdleWait,
                    WORD * pCount, WORD cLimit)
{
    schAssert(*pCount <= cLimit);

    //
    // The list is monotonically increasing in time. Traverse the list in
    // reverse order since the most common case will be to put the new
    // element at the end. That is, except in the case of overlapping
    // duration intervals, the run times for the same trigger will be
    // discovered in monotonically increasing order.
    //
    // For merging in the run times from separate triggers or jobs, the runs
    // will not be in any predictable order. In this case, it doesn't matter
    // from which end the search starts.
    //
    // CODEWORK  Use IsNull() instead of GetTime().  Make this loop a for loop.
    //
    FILETIME ftCur;
    CRun * pRun = m_RunHead.Prev();
    pRun->GetTime(&ftCur);
    //
    // Note that the head element is merely a marker (since this is a doubly
    // linked, circular list) and has its time value set to zero. Thus if we
    // reach a zero FILETIME, we have reached the head and thus know that
    // there is no list element with a later time, so insert at the tail.
    //
    while (ftCur.dwLowDateTime || ftCur.dwHighDateTime)
    {
        if (CompareFileTime(&ftCur, &ftRun) == 0)
        {
            //
            // Duplicate found, check for job name match. If here as a result
            // of a call to ITask::GetRunTimes, then both will be null. We
            // want duplicates eliminated in this case. Otherwise, compare
            // names.
            //
            if ((pRun->GetName() == NULL && ptszJobName == NULL) ||
                (pRun->GetName() != NULL && ptszJobName != NULL &&
                 lstrcmpi(pRun->GetName(), ptszJobName) == 0))
            {
                // keep the one already in the list but set the kill time
                // to the earlier of the two,
                // set the idle wait time to the lesser (less restrictive)
                // of the two
                // and set the start deadline to the later (less
                // restrictive) of the two.
                //

                pRun->ReduceWaitTo(wIdleWait);

                pRun->AdvanceKillTime(ftKillTime);

                pRun->RelaxDeadline(ftDeadline);

                // (There is no reason for the MaxRunTime to be different)
                schAssert(pRun->GetMaxRunTime() == dwMaxRunTime);
                return S_OK;
            }
        }

        if (CompareFileTime(&ftCur, &ftRun) < 0)
        {
            //
            // The new run is later than the current, so we are at the
            // insertion point.
            //
            break;
        }
        pRun = pRun->Prev();
        pRun->GetTime(&ftCur);
    }

    //
    // If the list is already at its maximum size, discard either the
    // last element or the one we were about to insert, whichever is
    // later.
    //
    if (*pCount >= cLimit)
    {
        CRun * pLast = m_RunHead.Prev();
        if (pLast == pRun)
        {
            //
            // We were about to insert after the last element.
            //
            return S_FALSE;
        }
        else
        {
            //
            // Discard the last element before inserting the new one.
            //
            pLast->UnLink();
            delete pLast;
            (*pCount)--;
        }
    }

    //
    // Create the new element and insert after the current one.
    //
    CRun * pNewRun = new CRun(&ftRun, &ftDeadline, ftKillTime, dwMaxRunTime,
                              dwJobFlags, wIdleWait, FALSE);
    if (!pNewRun)
    {
        ERR_OUT("RunList: Add", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    HRESULT hr = pNewRun->SetName(ptszJobName);
    if (FAILED(hr))
    {
        ERR_OUT("CRunList::AddSorted SetName", hr);
        delete pNewRun;
        return hr;
    }

    pNewRun->SetNext(pRun->Next());
    pNewRun->Next()->SetPrev(pNewRun);
    pRun->SetNext(pNewRun);
    pNewRun->SetPrev(pRun);

    //
    // Increment the count.
    //
    (*pCount)++;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::AddSortedByIdleWait
//
//  Synopsis:   Add to the list in time sorted order.
//
//-----------------------------------------------------------------------------
void
CIdleRunList::AddSortedByIdleWait(CRun * pAdd)
{
    //
    // If the system needs to stay awake to run this task, increment the
    // thread's wake count.  (We know that this is always called by the
    // worker thread.)
    //
    if (pAdd->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
    {
        WrapSetThreadExecutionState(TRUE, "AddSortedByIdleWait");
    }

    if (m_RunHead.Next()->IsNull())
    {
        // List is empty, so add this as the first element.
        //
        pAdd->LinkAfter(&m_RunHead);
        return;
    }

    WORD wAddWait = pAdd->GetWait();
    schAssert(wAddWait > 0);    // We should never put a job in the idle wait
                                // list if its idle wait time is 0

    //
    // Walk the list, comparing idle wait times.
    //
    CRun * pCur = m_RunHead.Next();
    while (!pCur->IsNull())
    {
        if (wAddWait < pCur->GetWait())
        {
            pAdd->LinkBefore(pCur);
            return;
        }
        pCur = pCur->Next();
    }

    //
    // Add to the end of the list.
    //
    pAdd->LinkBefore(pCur);
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::GetFirstWait
//
//  Synopsis:   Finds the lowest idle wait time of the jobs in the list that
//              haven't already been started in this idle period.
//              Returns 0xffff if there is no such job.
//
//-----------------------------------------------------------------------------
WORD
CIdleRunList::GetFirstWait()
{
    for (CRun * pRun = m_RunHead.Next();
         !pRun->IsNull();
         pRun = pRun->Next())
    {
        if (!pRun->m_fStarted)
        {
            // (We should never have inserted a run with zero wait time)
            schAssert(pRun->GetWait() != 0);

            return (pRun->GetWait());
        }
    }

    return 0xffff;
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::MarkNoneStarted
//
//  Synopsis:   Marks all jobs in the idle list as not having been started in
//              the current idle period.
//
//-----------------------------------------------------------------------------
void
CIdleRunList::MarkNoneStarted()
{
    schDebugOut((DEB_IDLE, "Marking idle jobs as not started\n"));
    for (CRun * pRun = GetFirstJob();
         !pRun->IsNull();
         pRun = pRun->Next())
    {
        pRun->m_fStarted = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CRunList::AddCopy
//
//  Synopsis:   Add a copy of the object to the list.
//
//-----------------------------------------------------------------------------
HRESULT
CRunList::AddCopy(CRun * pOriginal)
{
    CRun * pCopy = new CRun(pOriginal);
    if (pCopy == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pCopy->LinkAfter(&m_RunHead);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTimeRunList::Pop
//
//  Synopsis:   Removes the first (earliest) time element from the list and
//              returns it.
//
//-----------------------------------------------------------------------------
CRun *
CTimeRunList::Pop(void)
{
    CRun * pPop = m_RunHead.Next();

    if (pPop->IsNull())
    {
        // List is empty, so return a flag return code.
        //
        return NULL;
    }

    pPop->UnLink();

    return pPop;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTimeRunList::PeekHeadTime
//
//  Synopsis:   Returns the filetime value for the element at the head of the
//              list.
//
//-----------------------------------------------------------------------------
HRESULT
CTimeRunList::PeekHeadTime(LPFILETIME pft)
{
    if (m_RunHead.Next()->IsNull())
    {
        // List is empty, so return a flag return code.
        //
        return S_FALSE;
    }

    m_RunHead.Next()->GetTime(pft);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   CTimeRunList::MakeSysTimeArray
//
//  Synopsis:   returns the run list times as an array of SYSTEMTIME structs.
//
//  Arguments:  [prgst]  - a pointer to the returned array of filetime structs
//                         is stored here.  This function allocates the array
//                         using CoTaskMemAlloc.  It must be freed by the caller.
//              [pCount] - On entry, points to an upper limit on the number of
//                         array elements to return.  On exit, points to the
//                         actual number returned.
//
//  Returns:    E_OUTOFMEMORY, S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CTimeRunList::MakeSysTimeArray(LPSYSTEMTIME * prgst, WORD * pCount)
{
    WORD cLimit = *pCount;
    *pCount = 0;
    *prgst = (LPSYSTEMTIME) CoTaskMemAlloc(cLimit * sizeof(SYSTEMTIME));
    if (*prgst == NULL)
    {
        return E_OUTOFMEMORY;
    }

    //
    // Skip the head, it is a placeholder in the circular list with a time
    // value of zero.
    //
    for (CRun * pCur = m_RunHead.Next();
         (*pCount < cLimit) && (!pCur->IsNull());
         (*pCount)++, pCur = pCur->Next())
    {
        pCur->GetSysTime( &(*prgst)[*pCount] );
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::FreeList
//
//  Synopsis:   Same as CRunList::FreeList except it decrements the thread's
//              wake count for each system-required run in the list.  (We
//              know this method is only called by the worker thread.)
//
//-----------------------------------------------------------------------------
void
CIdleRunList::FreeList()
{
    CRun * pCur = m_RunHead.Next();

    while (!pCur->IsNull())
    {
        CRun * pNext = pCur->Next();
        pCur->UnLink();
        if (pCur->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
        {
            WrapSetThreadExecutionState(FALSE, "CIdleRunList::FreeList");
        }
        delete pCur;
        pCur = pNext;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CIdleRunList::FreeExpiredOrRegenerated
//
//  Synopsis:   This method is called when rebuilding the idle wait list from
//              the data in the tasks folder.
//              Removes runs that have m_fKeepInList set.  (These correspond
//              to jobs with idle triggers.)  Also purges expired runs.
//              Runs that don't have m_fKeepInList set correspond to runs that
//              have been triggered due to some other event, and are waiting
//              for an idle period; these are not removed here.
//
//-----------------------------------------------------------------------------
void
CIdleRunList::FreeExpiredOrRegenerated()
{
    // BUGBUG ftNow should be a parameter
    FILETIME ftNow = GetLocalTimeAsFileTime();

    CRun * pNext;
    for (CRun *pRun = m_RunHead.Next();
         !pRun->IsNull();
         pRun = pNext)
    {
        pNext = pRun->Next();

        if (pRun->IsIdleTriggered() ||
            CompareFileTime(pRun->GetDeadline(), &ftNow) < 0)
        {
            pRun->UnLink();

            //
            // If the system needed to stay awake to run this task, decrement
            // the thread's wake count.  (We know that this is always called
            // by the worker thread.)
            //
            if (pRun->IsFlagSet(TASK_FLAG_SYSTEM_REQUIRED))
            {
                WrapSetThreadExecutionState(FALSE,
                        "CIdleRunList::FreeExpiredOrRegenerated");
            }

            delete pRun;
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   WrapSetThreadExecutionStateFn
//
//  Synopsis:   Wrapper for dynamically loaded function
//
//-----------------------------------------------------------------------------
void WINAPI
WrapSetThreadExecutionStateFn(
    BOOL   fSystemRequired
#if DBG
  , LPCSTR pszDbgMsg    // parameter for debug output message
#endif
    )
{
    DWORD dwCount = (DWORD) (ULONG_PTR)TlsGetValue(g_WakeCountSlot);

    if (fSystemRequired)
    {
        //
        // Increment this thread's keep-awake count.  If it was zero,
        // set the system-required state.
        //
        schDebugOut((DEB_USER5, "INCREMENTING keep-awake count to %ld: %s\n",
                     dwCount + 1, pszDbgMsg));
        schAssert(dwCount != (DWORD) -1);
        dwCount++;
        if (dwCount == 1)
        {
            if (pfnSetThreadExecutionState != NULL)
            {
                schDebugOut((DEB_USER5, "SETTING   sys-required state\n"));
                (pfnSetThreadExecutionState)(ES_CONTINUOUS | ES_SYSTEM_REQUIRED);
            }
        }
    }
    else
    {
        //
        // Decrement this thread's keep-awake count.  If it becomes zero,
        // reset the system-required state.
        //
        schDebugOut((DEB_USER5, "DECREMENTING keep-awake count to %ld: %s\n",
                     dwCount - 1, pszDbgMsg));
        schAssert(dwCount != 0);

        dwCount--;
        if (dwCount == 0)
        {
            if (pfnSetThreadExecutionState != NULL)
            {
                schDebugOut((DEB_USER5, "RESETTING sys-required state\n"));
                (pfnSetThreadExecutionState)(ES_CONTINUOUS);
            }
        }
    }


    if (!TlsSetValue(g_WakeCountSlot, UlongToPtr(dwCount)))
    {
        ERR_OUT("TlsSetValue", GetLastError());
    }
}


//+----------------------------------------------------------------------------
//
//  Function:   InitThreadWakeCount
//
//  Synopsis:   Initialize this thread's keep-awake count.
//
//-----------------------------------------------------------------------------
void
InitThreadWakeCount()
{
    schDebugOut((DEB_USER5, "INITIALIZING keep-awake count to 0\n"));
    if (!TlsSetValue(g_WakeCountSlot, 0))
    {
        ERR_OUT("TlsSetValue", GetLastError());
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\misc.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       misc.cxx
//
//  Contents:   Miscellaneous helper functions
//
//  Classes:    None.
//
//  Functions:  StringFromTrigger, GetDaysOfWeekString, GetExitCodeString
//
//  History:    08-Dec-95   EricB   Created.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <regstr.h> // for app path reg key constant

#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "..\inc\debug.hxx"

const TCHAR PATH_ENV_VAR[] = TEXT("PATH");

static const CHAR gszJobScheduler[] = "SOFTWARE\\Microsoft\\SchedulingAgent";

static LCID sg_lcid = GetUserDefaultLCID();

HRESULT GetMonthsString(WORD rgfMonths, LPTSTR ptszBuf, UINT cchBuf);

//+----------------------------------------------------------------------------
//
//  Function:   StringFromTrigger
//
//  Synopsis:   Returns the string representation of the passed in trigger
//              data structure.
//
//  Arguments:  [pTrigger]     - the TASK_TRIGGER struct
//              [ppwszTrigger] - the returned string
//              [lpDetails]    - the SHELLDETAILS struct
//
//  Returns:    HRESULTS
//
//  Notes:      The string is allocated by this function with CoTaskMemAlloc
//              and is caller freed with CoTaskMemFree.
//
//              A non-event trigger string is composed of three parts: the
//              daily portion (tszDaily) which states when during the day the
//              trigger will fire, a trigger type portion (tszTrigType) which
//              states what days the trigger will fire, and the calendar
//              bracketing portion (tszStartDate and optionally tszEndDate).
//-----------------------------------------------------------------------------
HRESULT
StringFromTrigger(const PTASK_TRIGGER pTrigger, LPWSTR * ppwszTrigger, LPSHELLDETAILS lpDetails)
{
    if (IsBadWritePtr(ppwszTrigger, sizeof(WCHAR *)))
    {
        return E_INVALIDARG;
    }
    *ppwszTrigger = NULL;
    HRESULT hr;
    UINT uStrID = 0;
    DWORD dwDateFlags;

    TCHAR tszNumFmt[] = TEXT("%d");
    TCHAR tszNumber[SCH_SMBUF_LEN];
    TCHAR tszDOW[SCH_BIGBUF_LEN];
    TCHAR tszWhichWeek[SCH_MED0BUF_LEN];
    TCHAR tszMedBuf[SCH_MED0BUF_LEN];
    TCHAR tszBigBuf[SCH_XBIGBUF_LEN];
    TCHAR tszFormat[SCH_BUF_LEN];
    TCHAR tszTrigType[SCH_BIGBUF_LEN];
    LPTSTR rgptsz[5];

    //
    // If the trigger has not been set, return a phrase to that effect.
    //
    if (pTrigger->rgFlags & JOB_TRIGGER_I_FLAG_NOT_SET)
    {
        uStrID = IDS_TRIGGER_NOT_SET;
        goto DoString;
    }

    //
    // Compose the trigger-type string tszTrigType.
    //
    switch (pTrigger->TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        //
        // Nothing to do here, handled below.
        //
        break;

    case TASK_EVENT_TRIGGER_ON_IDLE:
        //
        // Event triggers. Since event triggers don't have a set run time,
        // they load a string from the resource fork that describes the
        // event.
        //
        uStrID = IDS_IDLE_TRIGGER;
        break;

    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
        //
        // Event trigger.
        //
        uStrID = IDS_STARTUP_TRIGGER;
        break;

    case TASK_EVENT_TRIGGER_AT_LOGON:
        //
        // Event trigger.
        //
        uStrID = IDS_LOGON_TRIGGER;
        break;

// Not yet implemented:
//    case TASK_EVENT_TRIGGER_ON_APM_RESUME:
//        //
//        // Event trigger.
//        //
//        uStrID = IDS_RESUME_TRIGGER;
//        break;

    case TASK_TIME_TRIGGER_DAILY:
        //
        // Run every n days.
        //
        if (pTrigger->Type.Daily.DaysInterval == 1)
        {
            //
            // Run every day.
            //
            if (!LoadString(g_hInstance, IDS_EVERY_DAY, tszTrigType,
                            SCH_BIGBUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
        }
        else
        {
            //
            // Run every DaysInterval days: "every %d days"
            //
            if (!LoadString(g_hInstance, IDS_DAILY_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            StringCchPrintf(tszTrigType, SCH_BIGBUF_LEN, tszFormat, pTrigger->Type.Daily.DaysInterval);
        }
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        //
        // Run on mon, tues, etc every n weeks.
        //
        hr = GetDaysOfWeekString(pTrigger->Type.Weekly.rgfDaysOfTheWeek,
                                 tszDOW, SCH_BUF_LEN);
        if (FAILED(hr))
        {
            return hr;
        }

        if (pTrigger->Type.Weekly.WeeksInterval == 1)
        {
            //
            // Run every week: "every %s of every week"
            //
            if (!LoadString(g_hInstance, IDS_EVERY_WEEK_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            StringCchPrintf(tszTrigType, SCH_BIGBUF_LEN, tszFormat, tszDOW);
        }
        else
        {
            //
            // Run every WeeksInterval weeks: "every %s of every %s weeks"
            //
            StringCchPrintf(tszNumber, SCH_SMBUF_LEN, tszNumFmt, pTrigger->Type.Weekly.WeeksInterval);

            rgptsz[0] = tszDOW;
            rgptsz[1] = tszNumber;

            if (!LoadString(g_hInstance, IDS_WEEKLY_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat,
                               0, 0, tszTrigType, SCH_BIGBUF_LEN,
                               (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        //
        // On specific days of specific months.
        //
        //
        // Get the first run day and append etc if more than one.
        //
        WORD wFirstDay, cDays, i;
        cDays = 0;
        for (i = 0; i < JOB_DAYS_PER_MONTHMAX; i++)
        {
            if ((pTrigger->Type.MonthlyDate.rgfDays >> i) & 0x1)
            {
                cDays++;
                if (cDays == 1)
                {
                    wFirstDay = i + 1;
                }
            }
        }
        if (pTrigger->Type.MonthlyDate.rgfMonths == JOB_RGFMONTHS_MAX)
        {
            //
            // Every month: "on day %d(, etc.) of every month"
            //
            if (!LoadString(g_hInstance,
                            (cDays == 1) ? IDS_EVERY_MONTHLYDATE_FORMAT :
                                           IDS_EVERY_MONTHLYDATE_FORMAT_ETC,
                            tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            StringCchPrintf(tszTrigType, SCH_BIGBUF_LEN, tszFormat, wFirstDay);
        }
        else
        {
            //
            // Specific months: "on day %s of %s"
            //
            StringCchPrintf(tszNumber, SCH_SMBUF_LEN, tszNumFmt, wFirstDay);
            hr = GetMonthsString(pTrigger->Type.MonthlyDate.rgfMonths,
                                 tszBigBuf, SCH_XBIGBUF_LEN);
            if (FAILED(hr))
            {
                return hr;
            }

            rgptsz[0] = tszNumber;
            rgptsz[1] = tszBigBuf;

            if (!LoadString(g_hInstance,
                            (cDays == 1) ? IDS_MONTHLYDATE_FORMAT :
                                           IDS_MONTHLYDATE_FORMAT_ETC,
                            tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTrigType, SCH_BIGBUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        //
        // On certain weeks of specific months.
        //

        if (!LoadString(g_hInstance,
                        IDS_FIRST + pTrigger->Type.MonthlyDOW.wWhichWeek - 1,
                        tszWhichWeek, SCH_MED0BUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string: LoadString", hr);
            return hr;
        }

        hr = GetDaysOfWeekString(pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek,
                                 tszDOW, SCH_BUF_LEN);
        if (FAILED(hr))
        {
            return hr;
        }

        if (pTrigger->Type.MonthlyDOW.rgfMonths == JOB_RGFMONTHS_MAX)
        {
            //
            // Runs every month: " on the %s %s of every month"
            //
            rgptsz[0] = tszWhichWeek;
            rgptsz[1] = tszDOW;

            if (!LoadString(g_hInstance, IDS_EVERY_MONTHLYDOW_FORMAT,
                            tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTrigType, SCH_BIGBUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        else
        {
            //
            // Runs on specific months:
            // "on the %s %s of %s"
            //
            hr = GetMonthsString(pTrigger->Type.MonthlyDOW.rgfMonths,
                                 tszBigBuf, SCH_XBIGBUF_LEN);
            if (FAILED(hr))
            {
                return hr;
            }

            rgptsz[0] = tszWhichWeek;
            rgptsz[1] = tszDOW;
            rgptsz[2] = tszBigBuf;

            if (!LoadString(g_hInstance, IDS_MONTHLYDOW_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTrigType, SCH_BIGBUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        break;

    default:
        schDebugOut((DEB_ERROR, "invalid TriggerType value: 0x%x\n",
                     pTrigger->TriggerType));
        return ERROR_INVALID_DATA;
    }

DoString:

    //
    // Event trigger or Daily part.
    //
    TCHAR tszTriggerString[SCH_XBIGBUF_LEN];
    TCHAR tszStartDate[SCH_DATEBUF_LEN];
    TCHAR tszEndDate[SCH_DATEBUF_LEN];
    TCHAR tszDaily[SCH_BUF_LEN];

    switch (uStrID)
    {
    case IDS_RESUME_TRIGGER:
    case IDS_STARTUP_TRIGGER:
    case IDS_LOGON_TRIGGER:
    case IDS_IDLE_TRIGGER:
    case IDS_TRIGGER_NOT_SET:
        //
        // Event-based or invalid trigger, load the description string.
        //
        if (!LoadString(g_hInstance, uStrID, tszTriggerString,
                        SCH_XBIGBUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string, LoadString", hr);
            return hr;
        }
        break;

    case 0:
        //
        // It is a time-based trigger.
        //
        TCHAR tszNum[SCH_SMBUF_LEN];

        //
        // Get the daily run time(s): tszDaily.
        //
        TCHAR tszFromTime[SCH_TIMEBUF_LEN];
        TCHAR tszToTime[SCH_TIMEBUF_LEN];
        SYSTEMTIME st = {0};
        st.wHour = pTrigger->wStartHour;
        st.wMinute = pTrigger->wStartMinute;

        if (!GetTimeFormat(sg_lcid, TIME_NOSECONDS, &st, NULL,
                           tszFromTime, SCH_TIMEBUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string: GetTimeFormat", hr);
            return hr;
        }

        if (pTrigger->MinutesInterval == 0)
        {
            //
            // Runs once a day at a specific time.
            //
            if (!LoadString(g_hInstance, IDS_ONCE_DAY_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }
            StringCchPrintf(tszDaily, SCH_BUF_LEN, tszFormat, tszFromTime);
        }
        else
        {
            //
            // On an interval daily from a starting time for a specified
            // number of minutes.
            //
            UINT uIntTimeStr, uDurTimeStr, uIntStr;
            if (pTrigger->MinutesInterval % JOB_MINS_PER_HOUR)
            {
                //
                // Runs on a minutes schedule.
                //
                StringCchPrintf(tszNum, SCH_SMBUF_LEN, tszNumFmt, pTrigger->MinutesInterval);
                uIntTimeStr = IDS_MINUTES_PAREN;
            }
            else
            {
                //
                // Runs on an hourly schedule.
                //
                StringCchPrintf(tszNum, SCH_SMBUF_LEN, tszNumFmt, pTrigger->MinutesInterval / JOB_MINS_PER_HOUR);
                uIntTimeStr = IDS_HOURS_PAREN;
            }

            TCHAR tszDuration[SCH_SMBUF_LEN];
            TCHAR tszTimePart[SCH_MED0BUF_LEN];

            if (!LoadString(g_hInstance, uIntTimeStr, tszTimePart,
                            SCH_MED0BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (pTrigger->rgFlags & JOB_TRIGGER_I_FLAG_DURATION_AS_TIME)
            {
                WORD wMinutes = pTrigger->wStartHour * JOB_MINS_PER_HOUR
                                + pTrigger->wStartMinute;
                wMinutes += (WORD)pTrigger->MinutesDuration;
                while (wMinutes > JOB_MINS_PER_DAY)
                {
                    wMinutes -= JOB_MINS_PER_DAY;
                }
                st.wHour = wMinutes / JOB_MINS_PER_HOUR;
                st.wMinute = wMinutes % JOB_MINS_PER_HOUR;
                if (!GetTimeFormat(sg_lcid, TIME_NOSECONDS, &st, NULL,
                                   tszToTime, SCH_TIMEBUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: GetTimeFormat", hr);
                    return hr;
                }
                uIntStr = IDS_MULTI_DAILY_FORMAT;

                rgptsz[0] = tszNum;
                rgptsz[1] = tszTimePart;
                rgptsz[2] = tszFromTime;
                rgptsz[3] = tszToTime;
            }
            else
            {
                if (pTrigger->MinutesDuration % JOB_MINS_PER_HOUR)
                {
                    //
                    // Express the duration in minutes.
                    //
                    StringCchPrintf(tszDuration, SCH_SMBUF_LEN, tszNumFmt, pTrigger->MinutesDuration);
                    uDurTimeStr = IDS_MINUTES;
                }
                else
                {
                    //
                    // No remainder, so express the duration in hours.
                    //
                    StringCchPrintf(tszDuration, SCH_SMBUF_LEN, tszNumFmt, pTrigger->MinutesDuration / JOB_MINS_PER_HOUR);
                    uDurTimeStr = IDS_HOURS_PAREN;
                }

                if (!LoadString(g_hInstance, uDurTimeStr, tszToTime,
                                SCH_TIMEBUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: LoadString", hr);
                    return hr;
                }

                uIntStr = IDS_MULTI_DURATION_FORMAT;

                rgptsz[0] = tszNum;
                rgptsz[1] = tszTimePart;
                rgptsz[2] = tszFromTime;
                rgptsz[3] = tszDuration;
                rgptsz[4] = tszToTime;
            }

            if (!LoadString(g_hInstance, uIntStr, tszFormat, SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszDaily, SCH_BUF_LEN, (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }

        //
        // Starting date: tszStartDate.
        //
        st.wYear = pTrigger->wBeginYear;
        st.wMonth = pTrigger->wBeginMonth;
        st.wDay = pTrigger->wBeginDay;
        dwDateFlags =  DATE_SHORTDATE;

        if (lpDetails) {
            if (lpDetails->fmt & LVCFMT_RIGHT_TO_LEFT) {
                dwDateFlags |=  DATE_RTLREADING;
            } else if (lpDetails->fmt & LVCFMT_LEFT_TO_RIGHT) {
                dwDateFlags |=  DATE_LTRREADING;
            }
        }

        if (!GetDateFormat(sg_lcid, dwDateFlags, &st, NULL, tszStartDate,
                           SCH_DATEBUF_LEN))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("Create trigger string: GetDateFormat", hr);
            return hr;
        }

        //
        // Compose the complete trigger string from its parts.
        //
        if (pTrigger->TriggerType == TASK_TIME_TRIGGER_ONCE)
        {
            //
            // Trigger runs just on a single day: "%s on %s"
            //
            rgptsz[0] = tszDaily;
            rgptsz[1] = tszStartDate;

            if (!LoadString(g_hInstance, IDS_RUNS_ONCE_FORMAT, tszFormat,
                            SCH_BUF_LEN))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: LoadString", hr);
                return hr;
            }

            if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                               FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat, 0, 0,
                               tszTriggerString, SCH_XBIGBUF_LEN,
                               (va_list *)rgptsz))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("Create trigger string: FormatMessage", hr);
                return hr;
            }
        }
        else
        {
            if (pTrigger->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
            {
                //
                // Job has an ending date.
                //
                st.wYear = pTrigger->wEndYear;
                st.wMonth = pTrigger->wEndMonth;
                st.wDay = pTrigger->wEndDay;
                dwDateFlags =  DATE_SHORTDATE;

                if (lpDetails) {
                    if (lpDetails->fmt & LVCFMT_RIGHT_TO_LEFT) {
                        dwDateFlags |=  DATE_RTLREADING;
                    } else if (lpDetails->fmt & LVCFMT_LEFT_TO_RIGHT) {
                        dwDateFlags |=  DATE_LTRREADING;
                    }
                }

                if (!GetDateFormat(sg_lcid, dwDateFlags, &st, NULL,
                                   tszEndDate, SCH_DATEBUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string, GetDateFormat", hr);
                    return hr;
                }
                //
                // Compose the trigger string with an end date.
                // "%s %s, starting %s & ending %s"
                //
                rgptsz[0] = tszDaily;
                rgptsz[1] = tszTrigType;
                rgptsz[2] = tszStartDate;
                rgptsz[3] = tszEndDate;

                if (!LoadString(g_hInstance, IDS_HAS_END_DATE_FORMAT,
                                tszFormat, SCH_BUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: LoadString", hr);
                    return hr;
                }

                if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                   FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat,
                                   0, 0, tszTriggerString, SCH_XBIGBUF_LEN,
                                   (va_list *)rgptsz))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: FormatMessage", hr);
                    return hr;
                }
            }
            else
            {
                //
                // Trigger does not have an ending date.
                // "%s %s, starting %s"
                //
                rgptsz[0] = tszDaily;
                rgptsz[1] = tszTrigType;
                rgptsz[2] = tszStartDate;

                if (!LoadString(g_hInstance, IDS_NO_END_DATE_FORMAT,
                                tszFormat, SCH_BUF_LEN))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: LoadString", hr);
                    return hr;
                }

                if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                                   FORMAT_MESSAGE_ARGUMENT_ARRAY, tszFormat,
                                   0, 0, tszTriggerString, SCH_XBIGBUF_LEN,
                                   (va_list *)rgptsz))
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    ERR_OUT("Create trigger string: FormatMessage", hr);
                    return hr;
                }
            }
        }
        break;
    }

    ULONG cch;
    //
    // Get the size to allocate for the returned string.
    //
    cch = wcslen(tszTriggerString) + 1;  // Include the null in the count.

    //
    // Allocate the returned string.
    //

    *ppwszTrigger = (LPWSTR)CoTaskMemAlloc(cch * sizeof(WCHAR));

    if (*ppwszTrigger == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszTrigger, cch, tszTriggerString);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetDaysOfWeekString
//
//  Synopsis:   Builds a string containing the names of the days of the week
//              that correspond to bits set in the bitset array.
//
//  Arguments:  [rgfDaysOfTheWeek] - a bitset array.
//              [pwszBuf]          - return in this string buffer.
//              [cchBuf]           - size of string buffer.
//
//-----------------------------------------------------------------------------
HRESULT
GetDaysOfWeekString(WORD rgfDaysOfTheWeek, LPTSTR ptszBuf, UINT cchBuf)
{
    HRESULT hr;
    LCID lcid = GetSystemDefaultLCID();


    if (rgfDaysOfTheWeek == 0)
    {
        return E_INVALIDARG;
    }
    BOOL fMoreThanOne = FALSE;
    int cch;
    TCHAR tszSep[SCH_SMBUF_LEN];
    if (!LoadString(g_hInstance, IDS_LIST_SEP, tszSep, SCH_SMBUF_LEN))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("GetDaysOfWeekString: LoadString", hr);
        return hr;
    }

    *ptszBuf = TEXT('\0');

    if (rgfDaysOfTheWeek & TASK_MONDAY)
    {
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME1, ptszBuf, cchBuf))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }

    if (rgfDaysOfTheWeek & TASK_TUESDAY)
    {
        if (fMoreThanOne)
        {
            StringCchCat(ptszBuf, cchBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME2, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_WEDNESDAY)
    {
        if (fMoreThanOne)
        {
            StringCchCat(ptszBuf, cchBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME3, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_THURSDAY)
    {
        if (fMoreThanOne)
        {
            StringCchCat(ptszBuf, cchBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME4, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_FRIDAY)
    {
        if (fMoreThanOne)
        {
            StringCchCat(ptszBuf, cchBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME5, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_SATURDAY)
    {
        if (fMoreThanOne)
        {
            StringCchCat(ptszBuf, cchBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME6, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
        fMoreThanOne = TRUE;
    }
    if (rgfDaysOfTheWeek & TASK_SUNDAY)
    {
        if (fMoreThanOne)
        {
            StringCchCat(ptszBuf, cchBuf, tszSep);
        }
        cch = lstrlen(ptszBuf);
        if (!GetLocaleInfo(lcid, LOCALE_SABBREVDAYNAME7, ptszBuf + cch,
                           cchBuf - cch))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("GetLocaleInfo", hr);
            return hr;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetMonthsString
//
//  Synopsis:   Builds a string containing the names of the months
//              that correspond to bits set in the bitset array.
//
//  Arguments:  [rgfMonths] - a bitset array.
//              [pwszBuf]   - return in this string buffer.
//              [cchBuf]    - size of string buffer.
//
//-----------------------------------------------------------------------------
HRESULT
GetMonthsString(WORD rgfMonths, LPTSTR ptszBuf, UINT cchBuf)
{
    if (rgfMonths == 0)
    {
        return E_INVALIDARG;
    }

    LCID lcid = GetSystemDefaultLCID();


    HRESULT hr;

    BOOL fMoreThanOne = FALSE;
    int cch;
    TCHAR tszSep[SCH_SMBUF_LEN];
    if (!LoadString(g_hInstance, IDS_LIST_SEP, tszSep, SCH_SMBUF_LEN))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("GetMonthsString: LoadString", hr);
        return hr;
    }

    *ptszBuf = TEXT('\0');

    for (WORD i = 0; i < JOB_MONTHS_PER_YEAR; i++)
    {
        if ((rgfMonths >> i) & 0x1)
        {
            if (fMoreThanOne)
            {
                StringCchCat(ptszBuf, cchBuf, tszSep);
            }
            cch = lstrlen(ptszBuf);
            if (!GetLocaleInfo(lcid, LOCALE_SABBREVMONTHNAME1 + i,
                               ptszBuf + cch, cchBuf - cch))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ERR_OUT("GetMonthsString: GetLocaleInfo", hr);
                return hr;
            }
            fMoreThanOne = TRUE;
        }
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SchedMapRpcError
//
//  Purpose:    Remap RPC exception codes that are unsuitable for displaying
//              to the user to more comprehensible errors.
//
//  Arguments:  [dwError] - the error returned by RpcExceptionCode().
//
//  Returns:    An HRESULT.
//
//----------------------------------------------------------------------------
HRESULT
SchedMapRpcError(
    DWORD   dwError)
{
    HRESULT hr;

    if (dwError == EPT_S_NOT_REGISTERED)
    {
        hr = SCHED_E_SERVICE_NOT_RUNNING;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ComposeErrorMsg
//
//  Purpose:    Take the two message IDs and the error code and create an
//              error reporting string that can be used by both service
//              logging and UI dialogs.
//
//  Arguments:  same as above.
//
//  Returns:    A string or NULL on failure.
//
//  Notes:      Release the string memory when done using LocalFree.
//
//----------------------------------------------------------------------------
LPTSTR
ComposeErrorMsg(
    UINT  uErrorClassMsgID,
    DWORD dwErrCode,
    UINT  uHelpHintMsgID,
    BOOL  fIndent)
{
    TCHAR szErrClassMsg[SCH_BIGBUF_LEN];

	    if (!LoadString(g_hInstance,
                     uErrorClassMsgID,
                     szErrClassMsg,
                     SCH_BIGBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return NULL;
    }

    BOOL fDelete = FALSE;
    DWORD ccLength = 0;

    TCHAR szErrCode[SCH_MED0BUF_LEN], szGenericErr[SCH_BUF_LEN];
    TCHAR * psz;
	LPTSTR pszErrStr = NULL;
    DWORD dwWinErr = dwErrCode;

    if (dwErrCode != 0)
    {
        //
        // Format the error code as a hex string.
        //

        TCHAR szErrNumFormat[SCH_MED0BUF_LEN];

        if (!LoadString(g_hInstance,
                         IDS_ERROR_NUMBER_FORMAT,
                         szErrNumFormat,
                         SCH_MED0BUF_LEN))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            return NULL;
        }

        StringCchPrintf(szErrCode, SCH_MED0BUF_LEN, szErrNumFormat, dwErrCode);

        //
        // If a Win32 error code, strip the HRESULT stuff.
        //

        if (HRESULT_FACILITY(dwErrCode) == FACILITY_WINDOWS ||
            HRESULT_FACILITY(dwErrCode) == FACILITY_WIN32)
        {
            dwWinErr = HRESULT_CODE(dwErrCode);
        }

        //
        // Try to obtain the error message from the system.
        //
        if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM |
                                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                        NULL,
                                        dwWinErr,
                                        LOCALE_SYSTEM_DEFAULT,
                                        (LPTSTR) &pszErrStr,
                                        1,
                                        NULL)))
        {
			DWORD di = GetLastError( );
            //
            // Well, that didn't work, so try to get it from the service.
            //
            if (!(ccLength = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                               FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            g_hInstance,
                                            dwErrCode,
                                            LOCALE_SYSTEM_DEFAULT,
                                            (LPTSTR) &pszErrStr,
                                            1,
                                            NULL)))
            {
                //
                // That didn't work either, so give a generic message.
                //
                if (!LoadString(g_hInstance,
                                 IDS_GENERIC_ERROR_MSG,
                                 szGenericErr,
                                 SCH_BUF_LEN))
                {
                    CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                    return NULL;
                }
                pszErrStr = szGenericErr;
            }
        }

        if (ccLength != 0)
        {
            fDelete = TRUE;

            //
            // Overwrite \r\n with null characters.
            //
            psz = pszErrStr + ccLength - 2;

            *psz++ = '\0';
            *psz   = '\0';
        }
    }

    TCHAR * pwszLogStr = NULL;

    TCHAR * rgpszInserts[4];

    rgpszInserts[0] = szErrClassMsg;

    UINT uFormatID;

    TCHAR szHelpMsg[SCH_BIGBUF_LEN];

    if (uHelpHintMsgID == 0 && dwWinErr != 0)
    {
        //
        // Caller didn't specify a help hint.  Try to map the error to one.
        //

        switch (dwWinErr)
        {
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
        case ERROR_BAD_PATHNAME:
        case ERROR_DIRECTORY:
        case ERROR_ACCESS_DENIED:
        case ERROR_NO_NET_OR_BAD_PATH:
        case ERROR_INVALID_DRIVE:
        case ERROR_INVALID_COMPUTERNAME:
        case ERROR_INVALID_SHARENAME:
            uHelpHintMsgID = IDS_HELP_HINT_BROWSE;
            break;

        case ERROR_TOO_MANY_OPEN_FILES:
        case ERROR_NOT_ENOUGH_MEMORY:
        case ERROR_OUTOFMEMORY:
        case ERROR_TOO_MANY_NAMES:
        case ERROR_TOO_MANY_SESS:
        case ERROR_OUT_OF_STRUCTURES:
        case ERROR_NO_PROC_SLOTS:
        case ERROR_TOO_MANY_SEMAPHORES:
        case ERROR_NO_MORE_SEARCH_HANDLES:
        case ERROR_TOO_MANY_TCBS:
        case ERROR_MAX_THRDS_REACHED:
        case ERROR_DLL_INIT_FAILED:
        case ERROR_NO_SYSTEM_RESOURCES:
        case ERROR_NONPAGED_SYSTEM_RESOURCES:
        case ERROR_PAGED_SYSTEM_RESOURCES:
        case RPC_S_OUT_OF_RESOURCES:
            uHelpHintMsgID = IDS_HELP_HINT_CLOSE_APPS;
            break;

        case ERROR_NOT_SUPPORTED:
        case ERROR_REM_NOT_LIST:
        case ERROR_DUP_NAME:
        case ERROR_BAD_NETPATH:
        case ERROR_NETWORK_BUSY:
        case ERROR_DEV_NOT_EXIST:
        case ERROR_TOO_MANY_CMDS:
        case ERROR_ADAP_HDW_ERR:
        case ERROR_BAD_NET_RESP:
        case ERROR_UNEXP_NET_ERR:
        case ERROR_BAD_REM_ADAP:
        case ERROR_NETNAME_DELETED:
        case ERROR_NETWORK_ACCESS_DENIED:
        case ERROR_BAD_DEV_TYPE:
        case ERROR_BAD_NET_NAME:
        case ERROR_SHARING_PAUSED:
        case ERROR_REQ_NOT_ACCEP:
        case ERROR_REMOTE_SESSION_LIMIT_EXCEEDED:
        case ERROR_NO_NETWORK:
        case ERROR_NETWORK_UNREACHABLE:
        case ERROR_HOST_UNREACHABLE:
        case ERROR_PROTOCOL_UNREACHABLE:
        case ERROR_PORT_UNREACHABLE:
        case ERROR_CONNECTION_COUNT_LIMIT:
        case ERROR_NO_LOGON_SERVERS:
            uHelpHintMsgID = IDS_HELP_HINT_CALLPSS;
            break;

        case ERROR_BADDB:
        case ERROR_BADKEY:
        case ERROR_CANTOPEN:
        case ERROR_CANTREAD:
        case ERROR_CANTWRITE:
        case ERROR_REGISTRY_CORRUPT:
        case ERROR_REGISTRY_IO_FAILED:
        case ERROR_KEY_DELETED:
        case ERROR_DLL_NOT_FOUND:
            uHelpHintMsgID = IDS_HELP_HINT_REINSTALL;
            break;

        case EPT_S_NOT_REGISTERED:
            uHelpHintMsgID = IDS_HELP_HINT_STARTSVC;
            break;
        }
    }

    if (uHelpHintMsgID != 0)
    {
        //
        // A help hint string has been specified.
        //

        if (!LoadString(g_hInstance,
                         uHelpHintMsgID,
                         szHelpMsg,
                         SCH_BIGBUF_LEN))
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            goto CleanUp;
        }

        if (dwErrCode != 0)
        {
            //
            // An error code has also been given.
            //

            rgpszInserts[1] = szErrCode;
            rgpszInserts[2] = pszErrStr;
            rgpszInserts[3] = szHelpMsg;

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WCODE_WHELP_I :
                            IDS_ERROR_FORMAT_WCODE_WHELP);
        }
        else
        {
            //
            // Help string but no error code.
            //

            rgpszInserts[1] = szHelpMsg;

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WOCODE_WHELP_I :
                            IDS_ERROR_FORMAT_WOCODE_WHELP);
        }
    }
    else
    {
        //
        // No help hint.
        //

        if (dwErrCode != 0)
        {
            //
            // An error code has been given.
            //

            rgpszInserts[1] = szErrCode;
            rgpszInserts[2] = pszErrStr;

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WCODE_WOHELP_I :
                            IDS_ERROR_FORMAT_WCODE_WOHELP);
        }
        else
        {
            //
            // No help string or error code.
            //

            uFormatID = (fIndent ? IDS_ERROR_FORMAT_WOCODE_WOHELP_I :
                            IDS_ERROR_FORMAT_WOCODE_WOHELP);
        }
    }

    TCHAR szFormat[SCH_BIGBUF_LEN];

    if (!LoadString(g_hInstance,
                     uFormatID,
                     szFormat,
                     SCH_BIGBUF_LEN))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto CleanUp;
    }

    if (!FormatMessage(FORMAT_MESSAGE_FROM_STRING         |
                            FORMAT_MESSAGE_ALLOCATE_BUFFER |
                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                        szFormat,
                        0,
                        0,
                        (LPTSTR) &pwszLogStr,
                        1,
                        (va_list *) rgpszInserts))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        goto CleanUp;
    }
	            
CleanUp:
    if (fDelete)
    {
        LocalFree(pszErrStr);
    }
    return pwszLogStr;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetExitCodeString
//
//  Synopsis:   Retrieve the string associated with the exit code from a
//              message file. Algorithm:
//
//              Consult the Software\Microsoft\Job Scheduler subkey.
//
//              Attempt to retrieve the ExitCodeMessageFile string value from
//              a subkey matching the job executable prefix (i.e., minus the
//              extension).
//
//              The ExitCodeMessageFile specifies a binary from which the
//              message string associated with the exit code value is fetched.
//
//  Arguments:  [dwExitCode]        -- Job exit code.
//              [pwszExitCodeValue] -- Job exit code in string form.
//              [pszJobExecutable]  -- Binary name executed with the job.
//
//  Returns:    TCHAR * exit code string
//              NULL on error
//
//  Notes:      FormatMessage allocates the return string. Use LocalFree() to
//              deallocate.
//
//----------------------------------------------------------------------------
TCHAR *
GetExitCodeString(
    DWORD dwExitCode,
    TCHAR * ptszExitCodeValue,
    TCHAR * ptszJobExecutable)
{
    static TCHAR tszExitCodeMsgFile[] = TEXT("ExitCodeMessageFile");
    TCHAR        tszBuffer[MAX_PATH + 1];
    DWORD        cbBufferSize = sizeof(tszBuffer);
    TCHAR *      ptszExt;
    TCHAR *      ptszExitCode = NULL;
    DWORD        dwType;

    // Isolate job app name prefix.
    //
    if ((ptszExt = _tcsrchr(ptszJobExecutable, TEXT('.'))) != NULL)
    {
       *ptszExt = TEXT('\0');
    }

    HKEY hKey;
    HKEY hSubKey;

    // BUGBUG : Cache job scheduler key.

    if (!RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                       gszJobScheduler,
                       0,
                       KEY_READ,
                       &hKey))
    {
        // Open the JobScheduler\<app> subkey and fetch the exit code
        // message file name.
        //
        if (!RegOpenKeyEx(hKey, ptszJobExecutable, 0, KEY_READ, &hSubKey))
        {
            if (!RegQueryValueEx(hSubKey,
                                 tszExitCodeMsgFile,
                                 NULL,
                                 &dwType,
                                 (UCHAR *)tszBuffer,
                                 &cbBufferSize) && dwType == REG_SZ)
            {
                // Load the resource as a data file, so no code executes
                // in our process.
                //
                HINSTANCE hInst = LoadLibraryEx(tszBuffer,
                                                NULL,
                                                LOAD_LIBRARY_AS_DATAFILE);

                if (hInst != NULL)
                {
                    ULONG ccSize;

                    if (ccSize = FormatMessage(
                                            FORMAT_MESSAGE_FROM_HMODULE     |
                                              FORMAT_MESSAGE_IGNORE_INSERTS |
                                              FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                            hInst,
                                            dwExitCode,
                                            LOCALE_SYSTEM_DEFAULT,
                                            (TCHAR *)&ptszExitCode,
                                            1,
                                            NULL))
                    {
                        // Overwrite \r\n with null characters.
                        //
                        TCHAR * ptsz = ptszExitCode + lstrlen(ptszExitCode) - 2;

                        *ptsz++ = TEXT('\0');
                        *ptsz   = TEXT('\0');
                    }
                    else
                    {
                        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
                    }

                    FreeLibrary(hInst);
                }
            }
            RegCloseKey(hSubKey);
        }
        RegCloseKey(hKey);
    }

    if (ptszExt != NULL)                 // Restore '.'
    {
        *ptszExt = '.';
    }

    return(ptszExitCode);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetParentDirectory
//
//  Synopsis:   Return the parent directory of the path indicated.
//
//  Arguments:  [ptszPath]     -- Input path.
//              [tszDirectory] -- Caller-allocated returned directory.
//              [cchBuf] -- size of caller-allocated buffer
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
GetParentDirectory(LPCTSTR ptszPath, TCHAR tszDirectory[], size_t cchBuf)
{
    StringCchCopy(tszDirectory, cchBuf, ptszPath);

    LPTSTR ptsz = _tcsrchr(tszDirectory, _T('\\'));

    if (ptsz == NULL)
    {
        tszDirectory[0] = _T('\\');
    }
    else
    {
        *ptsz = _T('\0');
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   GetAppNameFromPath
//
//  Synopsis:   Copy the filename portion (without double quotes) of full
//              or partial path in [tszAppPathName] into buffer pointed to
//              by [tszCopyTo].
//
//  Arguments:  [tszAppPathName] - full or partial path
//              [tszCopyTo]      - destination buffer
//              [cchMax]         - max size, in chars, of buffer
//
//  Modifies:   *[tszCopyTo]
//
//  History:    09-17-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
GetAppNameFromPath(
        LPCTSTR tszAppPathName,
        LPTSTR  tszCopyTo,
        ULONG   cchMax)
{
    LPCTSTR ptszStart;
    LPCTSTR ptszLastSlash;

    if (tszAppPathName[0] == TEXT('"'))
    {
        ptszStart = &tszAppPathName[1];
    }
    else
    {
        ptszStart = tszAppPathName;
    }

    ptszLastSlash = _tcsrchr(ptszStart, TEXT('\\'));

    if (ptszLastSlash)
    {
        lstrcpyn(tszCopyTo, ptszLastSlash + 1, cchMax);
    }
    else
    {
        lstrcpyn(tszCopyTo, ptszStart, cchMax);
    }

    LPTSTR ptszQuote = _tcschr(tszCopyTo, TEXT('"'));

    if (ptszQuote)
    {
        *ptszQuote = TEXT('\0');
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   SetAppPath
//
//  Synopsis:   If the application in the full or partial path
//              [tszAppPathName] has an app path registry entry, save the
//              current value of the path variable in [pptszSavedPath] and
//              prepend the app path to the current path.
//
//  Arguments:  [tszAppPathName] - full or partial path to application
//              [pptszSavedPath] - filled with ptr to saved path string
//
//  Modifies:   *[pptszSavedPath], PATH environment variable
//
//  Returns:    nonzero - path environment var was set
//              zero    - path environment var not set
//
//  History:    09-17-96   DavidMun   Created
//
//----------------------------------------------------------------------------

BOOL SetAppPath(LPCTSTR tszAppPathName, LPTSTR *pptszSavedPath)
{
    BOOL    fChangedPath = FALSE;
    LPTSTR  tszAppName[MAX_PATH];
    TCHAR   tszAppPathVar[MAX_PATH_VALUE];

    do
    {
        //
        // Init out var
        //

        *pptszSavedPath = NULL;

        //
        // See if there's an app key with a PATH value.  If not we're done.
        //

        GetAppNameFromPath(tszAppPathName, (LPTSTR)tszAppName, MAX_PATH);

        GetAppPathInfo((LPCTSTR)tszAppName,
                       NULL,
                       0,
                       tszAppPathVar,
                       MAX_PATH_VALUE);

        if (!*tszAppPathVar)
        {
            break;
        }

        //
        // Save the original path, if it exists.
        //

        ULONG cchOriginalPath = GetEnvironmentVariable(PATH_ENV_VAR, NULL,0);

        if (0 != cchOriginalPath)
        {
            //
            // It exists, try to alloc mem to save it.  If we can't, we'll try
            // to run the app without setting its app path, but CreateProcess
            // will probably fail anyway due to lack of resources.
            //

            *pptszSavedPath = new TCHAR[cchOriginalPath];

            if (NULL == *pptszSavedPath)
            {
                ERR_OUT("SetAppPath: trying to save path", E_OUTOFMEMORY);
                break;
            }

            GetEnvironmentVariable(PATH_ENV_VAR,
                                   *pptszSavedPath,
                                   cchOriginalPath);
        }

        //
        // Now build the new path by prepending the app's path to the original
        // path.  Note cchNewPath includes 1 for terminating nul, and
        // cchOriginalPath does also, if it isn't 0.  This will give us 1
        // character extra if we are to be concatenating cchOriginalPath.
        // We'll use that extra character for the semicolon separating new and
        // original paths.
        //

        ULONG cchNewPath = lstrlen(tszAppPathVar) + 1;
        LPTSTR ptszNewPath = new TCHAR[cchNewPath + cchOriginalPath];

        if (NULL == ptszNewPath)
        {
            ERR_OUT("SetAppPath: trying to get AppPath", E_OUTOFMEMORY);
            break;
        }

        StringCchCopy(ptszNewPath, cchNewPath, tszAppPathVar);

        if (0 != cchOriginalPath)
        {
            ptszNewPath[cchNewPath - 1] = TEXT(';');
            StringCchCopy(&ptszNewPath[cchNewPath], cchOriginalPath, *pptszSavedPath);
        }

        //
        // Finally ready to set the path environment variable
        //

        fChangedPath = SetEnvironmentVariable(PATH_ENV_VAR, ptszNewPath);
        delete [] ptszNewPath;
    } while (0);

    return fChangedPath;
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadAtJob
//
//  Synopsis:   Load the At job indicated.
//
//  Arguments:  [pJob]              - Job object to use.
//              [pwszAtJobFilename] - Relative path to the target At job.
//
//----------------------------------------------------------------------------
HRESULT
LoadAtJob(CJob * pJob, TCHAR * ptszAtJobFilename)
{
    static ULONG    ccJobFolderPathSize = 0;
    TCHAR           tszPath[MAX_PATH + 1];

    if (ccJobFolderPathSize == 0)
    {
        ccJobFolderPathSize = lstrlen(g_TasksFolderInfo.ptszPath);
    }

    //
    // Compute string size to prevent possible buffer overrun.
    //
    // NB : size + 2 for additional for '\' + NULL character.
    //

    ULONG ccAtJobPathSize = lstrlen(ptszAtJobFilename) +
                            ccJobFolderPathSize + 2;

    if (ccAtJobPathSize > MAX_PATH)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(ERROR_INVALID_NAME));
        return HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
    }

    StringCchCopy(tszPath, MAX_PATH + 1, g_TasksFolderInfo.ptszPath);
    StringCchCat(tszPath, MAX_PATH + 1, TEXT("\\"));
    StringCchCat(tszPath, MAX_PATH + 1, ptszAtJobFilename);

    return pJob->LoadP(tszPath, 0, FALSE, TRUE);
}




//+---------------------------------------------------------------------------
//
//  Function:   IsValidAtFilename
//
//  Synopsis:   Returns TRUE if [wszFilename] is of the form ATn.JOB, where
//              n is 1 or more digits, leading zeros not allowed, n >= 1.
//
//  History:    09-30-96   DavidMun   Created
//
//  Notes:      Assumes [wszFilename] has valid extension.
//
//----------------------------------------------------------------------------

BOOL IsValidAtFilename(LPCWSTR wszFilename)
{
    ULONG cchFilename;
    static ULONG s_cchExtension;

    cchFilename = lstrlen(wszFilename);

    if (!s_cchExtension)
    {
        s_cchExtension = ARRAY_LEN(TSZ_DOTJOB) - 1;
    }

    //
    // The filename must be of the form PREFIXdigitsEXTENSION, with at least
    // one digit.  This means that the min length is the length of PREFIX +
    // EXTENSION + 1.  We get the +1 from the ARRAY_LEN macro.
    //

    if (cchFilename < (ARRAY_LEN(TSZ_AT_JOB_PREFIX) + s_cchExtension))
    {
        return FALSE;
    }

    //
    // After the prefix there must be only digits up to the extension.
    // Leading zeros are not allowed.
    //

    ULONG i;
    BOOL fZerosAreLeading = TRUE;

    for (i = ARRAY_LEN(TSZ_AT_JOB_PREFIX) - 1; i < cchFilename; i++)
    {
        if (L'0' == wszFilename[i])
        {
            if (fZerosAreLeading)
            {
                return FALSE;
            }
        }
        else if (wszFilename[i] < L'0' || wszFilename[i] > L'9')
        {
            break;  // should've just hit .job
        }
        else
        {
            fZerosAreLeading = FALSE;
        }
    }

    //
    // We stopped at a non-digit.  We should now be at a bogus character or
    // the start of the extension.  Since the findfirst/next routines wouldn't
    // have returned a filename that didn't have the appropriate extension,
    // it's not necessary to do a string compare, we can just require that the
    // number of characters remaining is the same as the length of the
    // extension.
    //

    if (cchFilename - i != s_cchExtension)
    {
        return FALSE;
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:	TranslateAccount
//
//  Synopsis:	Translates local system accounts between internal and external representations.
//			Passes other accounts through unaltered.  
//
//			If translating a local system account into the internal representation, if the password
//			passed in was empty, then it sets the pointer to NULL for use with the local system account,
//			since the user has no way of setting it to NULL themselves.  The password isn't touched
//			otherwise.
//
//  Arguments:
//			IN		TRANSLATION_DIRECTION tdDirection	-- which way is translation being performed
//			IN		LPCWSTR pwszAccountIn			-- account to be translated
//			IN OUT	LPWSTR pwszAccountOut			-- translated account
//			IN		DWORD cchAccountOut				-- size of buffer for translated account
//			IN OUT	LPWSTR* ppwszPassword			-- pointer to pointer to password
//
//  Returns:	HRESULT indicating success or failure
//
//----------------------------------------------------------------------------

HRESULT
TranslateAccount(
	TRANSLATION_DIRECTION tdDirection, 
	LPCWSTR pwszAccountIn,
	LPWSTR pwszAccountOut,
	DWORD cchAccountOut,
	LPWSTR* ppwszPassword)
{
	if (!pwszAccountIn || !pwszAccountOut)
		return E_FAIL;
	
	const WCHAR DISPLAY_LOCAL_SYSTEM[] = L"NT AUTHORITY\\SYSTEM";
	const WCHAR* pwszDisplaySystem = DISPLAY_LOCAL_SYSTEM + 13;	// points to "SYSTEM" substring in string above
	
	if (tdDirection == TRANSLATE_FOR_DISPLAY)
	{
		if (pwszAccountIn[0] == L'\0')		// internal representation of local system
		{
			lstrcpynW(pwszAccountOut, DISPLAY_LOCAL_SYSTEM, cchAccountOut);
		}
		else
		{
			lstrcpynW(pwszAccountOut, pwszAccountIn, cchAccountOut);
		}
	}
	else				// translating for internal use
	{
		if (lstrcmpiW(pwszAccountIn, DISPLAY_LOCAL_SYSTEM) == 0 || lstrcmpiW(pwszAccountIn, pwszDisplaySystem) == 0)
		{
			pwszAccountOut[0] = L'\0';	// internal representation of local system

			if (ppwszPassword && (*ppwszPassword[0] == L'\0'))
				*ppwszPassword = NULL;
		}
		else
		{
			lstrcpynW(pwszAccountOut, pwszAccountIn, cchAccountOut);
		}
	}
	
	return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   OpenFileWithRetry
//
//  Synopsis:   Attempt to open file with access and share mode supplied.
//              If open fails due to sharing violation, try again, up to two times.
//
//  Arguments:  [ptszFileName]
//              [dwDesiredAccess]
//              [dwDesiredShareMode]
//              [hFile]
//
//  Returns:    HRESULT
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
OpenFileWithRetry(LPCTSTR ptszFileName, DWORD dwDesiredAccess, DWORD dwDesiredShareMode, HANDLE* phFile)
{
    DWORD   Status = 0;
    HANDLE  hFile;

    //
    // Retry open if it is in use by another process, up to two more times
    //
    for (DWORD i = 3; i; i--)
    {
        hFile = CreateFile(ptszFileName,
                           dwDesiredAccess,
                           dwDesiredShareMode,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_SEQUENTIAL_SCAN,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            Status = GetLastError();

            if (Status == ERROR_SHARING_VIOLATION)
            {
                //
                // Wait semi-pseudo-random amount of time before trying again.
                //
                Sleep(250 + (rand() % 250));
                continue;
            }
        }
        else
        {
            Status = 0;
        }

        break;
    }

    if (Status)
    {
        schDebugOut((DEB_ERROR, "Open of task file '%ws' failed with error %u\n", ptszFileName, Status));
        return HRESULT_FROM_WIN32(Status);
    }

    *phFile = hFile;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\network.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       network.cxx
//
//  Contents:   Network-related helper routines.
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    08-Jul-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "..\inc\debug.hxx"
#include "..\inc\network.hxx"

typedef DWORD (WINAPI * PWNETGETUNIVERSALNAMEW)(
                                    LPCWSTR,
                                    DWORD,
                                    LPVOID,
                                    LPDWORD);


//+----------------------------------------------------------------------------
//
//  Function:   GetServerNameFromPath
//
//  Synopsis:   Return the server name, in UNC form, to which the path
//              resolves. If the path resolves locally, the server name
//              returned is NULL.
//
//  Arguments:  [pwszPath]        -- Drive-based or UNC path.
//              [cbUNCPath]       -- Caller allocated buffer size.
//              [wszUNCPath]      -- Caller allocated buffer to temporarilly
//                                   store the full UNC path. A terminating
//                                   character will be written following the
//                                   server name, so don't expect to use
//                                   the UNC path afterward.
//              [ppwszServerName] -- Server name ptr. If non-NULL, it indexes
//                                   wszBuffer.
//
//  Returns:    S_OK - The path was local or the server name was obtained
//                  sucessfully from the remote path.
//              E_FAIL - Something unexpected occurred (should never happen).
//              WNetGetUniversalName error (HRESULT) - When the path is a
//                  remote path and this call fails for some reason.
//
//-----------------------------------------------------------------------------
HRESULT
GetServerNameFromPath(
    LPCWSTR  pwszPath,
    DWORD    cbBufferSize,
    WCHAR    wszBuffer[],
    WCHAR ** ppwszServerName)
{
#define MPR_DLL             TEXT("MPR.DLL")
#define WNET_GET_UNIVERSAL  "WNetGetUniversalNameW"

    schAssert(pwszPath != NULL);

    static TCHAR            wszDoubleBackslash[] = TEXT("\\\\");
    PWNETGETUNIVERSALNAMEW  pWNetGetUniversalNameW = NULL;
    WCHAR *                 pwszServerName;
    DWORD                   cbBufferSizeLocal = cbBufferSize;
    DWORD                   Status;
    HMODULE                 hMod;

    //
    // Is the path provided already a UNC path?
    //

    if (pwszPath[1] == L'\\')
    {
        StringCbCopy(wszBuffer, cbBufferSize, pwszPath);
        goto ParseServerName;
    }

    //
    // Dynamically load/unload mpr.dll to save memory in Win95. Yes, we'll
    // take a time hit, but we don't want mpr.dll loaded long-term.
    //

    hMod = LoadLibrary(MPR_DLL);

    if (hMod == NULL)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return(HRESULT_FROM_WIN32(GetLastError()));
    }
    else
    {
        pWNetGetUniversalNameW = (PWNETGETUNIVERSALNAMEW)
                                            GetProcAddress(
                                                        hMod,
                                                        WNET_GET_UNIVERSAL);

        if (pWNetGetUniversalNameW == NULL)
        {
            FreeLibrary(hMod);
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
            return(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    Status = pWNetGetUniversalNameW(pwszPath,
                                    UNIVERSAL_NAME_INFO_LEVEL,
                                    wszBuffer,
                                    &cbBufferSizeLocal);

    FreeLibrary(hMod);

    if (Status == NO_ERROR)
    {
ParseServerName:

        pwszServerName = wszBuffer;

        if (cbBufferSizeLocal > sizeof(wszDoubleBackslash))
        {
            //
            // Isolate server name from full UNC resource path.
            //

            pwszServerName += (sizeof(wszDoubleBackslash) /
                                                    sizeof(WCHAR)) - 1;

            for (WCHAR * pwsz = pwszServerName; *pwsz; pwsz++)
            {
                if (*pwsz == L'\\')
                {
                    *pwsz = L'\0';
                    break;
                }
            }

            *ppwszServerName = pwszServerName;
        }
        else
        {
            //
            // This should *never* occur.
            //

            schAssert(cbBufferSizeLocal > sizeof(wszDoubleBackslash));
            return(E_FAIL);
        }
    }
    else if (Status == ERROR_NOT_CONNECTED)
    {
        *ppwszServerName = NULL;
    }
    else
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(Status));
        return(HRESULT_FROM_WIN32(Status));
    }

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\path.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
// 
//  File:       path.cxx
//
//  Contents:   Common routines for processing file and pathnames.
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <regstr.h> // for app path reg key constant
#include "..\inc\common.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\debug.hxx"



//
// Forward references
//

LPCTSTR 
FindFirstTrailingSpace(LPCTSTR ptsz);

BOOL 
FileExistsInPath(
        LPTSTR  ptszFilename,
        LPCTSTR ptszPath, 
        LPTSTR  ptszFoundFile, 
        ULONG   cchFoundBuf);


//+--------------------------------------------------------------------------
//
//  Function:   ProcessApplicationName
//
//  Synopsis:   Canonicalize and search for [ptszFilename].
//
//  Arguments:  [ptszFilename]  - must be at least MAX_PATH chars long
//              [tszWorkingDir] - "" or a directory not ending in slash
//
//  Returns:    TRUE - a filename was found
//              FALSE - no filename found
//
//  Modifies:   *[ptszFilename]
//
//  History:    11-21-1996   DavidMun   Created
//              06-03-1997   DavidMun   Expand environment vars
//
//  Notes:      This function should only be called to process filenames 
//              on the local machine.
//
//---------------------------------------------------------------------------

BOOL 
ProcessApplicationName(LPTSTR ptszFilename, size_t cchBuff, LPCTSTR tszWorkingDir)
{
    BOOL  fFound = FALSE;
    TCHAR tszFilenameWithExe[MAX_PATH + 1];
 
    //
    // Use tszFilenameWithExe as a temporary buffer for preparing the string 
    // in ptszFilename.  Get rid of lead/trail spaces and double quotes, then
    // expand environment strings. 
    // 

    StringCchCopy(tszFilenameWithExe, MAX_PATH + 1, ptszFilename);
    StripLeadTrailSpace(tszFilenameWithExe);
    DeleteQuotes(tszFilenameWithExe);
    ExpandEnvironmentStrings(tszFilenameWithExe, ptszFilename, MAX_PATH + 1);
    tszFilenameWithExe[0] = TEXT('\0');

    ULONG cchFilename = lstrlen(ptszFilename) + 1;

    //
    // If the filename doesn't end with .exe, and the resulting string
    // wouldn't be greater than MAX_PATH + 1 (including NULL),
    // create a version of the filename with .exe appended.
    //
    // Note this will prevent us from finding foo.exe.exe when we're given
    // foo.exe, but the performance gained by excluding this case outweighs
    // the value of completeness, since it's unlikely anyone would create
    // such a filename.
    //

    if (cchFilename < MAX_PATH + 1 - 4)
    {
        LPTSTR ptszLastDot = _tcsrchr(ptszFilename, TEXT('.'));

        if (!ptszLastDot || lstrcmpi(ptszLastDot, DOTEXE))
        {
            StringCchCopy(tszFilenameWithExe, MAX_PATH + 1, ptszFilename);
            StringCchCopy(&tszFilenameWithExe[cchFilename], MAX_PATH + 1 - cchFilename, DOTEXE);
        }
    }
 
    do
    {
        //
        // If the user specified path information (if there is a colon or
        // backslash anywhere in the string), look for the file as
        // specified or with .exe appended, but look nowhere else.
        //

        if (_tcspbrk(ptszFilename, TEXT(":\\")))
        {
            if (*tszFilenameWithExe)
            {
                fFound = FileExists(tszFilenameWithExe, MAX_PATH + 1);
 
                if (fFound)
                {
                    StringCchCopy(ptszFilename, cchBuff, tszFilenameWithExe);
                }
            }
 
            if (!fFound)
            {
                fFound = FileExists(ptszFilename, cchBuff);
            }
            break;
        }

        //
        // First try the working directory
        //

        TCHAR tszFoundFile[MAX_PATH + 1] = TEXT("");

        if (*tszWorkingDir)
        {
            if (*tszFilenameWithExe)
            {
                fFound = FileExistsInPath(tszFilenameWithExe, 
                                          tszWorkingDir, 
                                          tszFoundFile, 
                                          MAX_PATH + 1);
            }
 
            if (!fFound)
            {
                fFound = FileExistsInPath(ptszFilename,
                                          tszWorkingDir, 
                                          tszFoundFile, 
                                          MAX_PATH + 1);
            }
 
            if (fFound)
            {
                StringCchCopy(ptszFilename, cchBuff, tszFoundFile);
                break;
            }
        }

        //
        // Next try using the app paths key
        //

        TCHAR tszAppPathVar[MAX_PATH_VALUE] = TEXT("");
        TCHAR tszAppPathDefault[MAX_PATH + 1]   = TEXT("");

        if (*tszFilenameWithExe)
        {
            GetAppPathInfo(tszFilenameWithExe, 
                           tszAppPathDefault, 
                           MAX_PATH + 1, 
                           tszAppPathVar,
                           MAX_PATH_VALUE);
        }

        if (!*tszAppPathDefault && !*tszAppPathVar)
        {
            GetAppPathInfo(ptszFilename, 
                           tszAppPathDefault, 
                           MAX_PATH + 1, 
                           tszAppPathVar,
                           MAX_PATH_VALUE);
        }

        //
        // If there was a default value, try that
        // 

        if (*tszAppPathDefault)
        {
            fFound = FileExists(tszAppPathDefault, MAX_PATH + 1);

            if (fFound)
            {
                StringCchCopy(ptszFilename, cchBuff, tszAppPathDefault);
                break;
            }

            //
            // If there's room, concat .exe to the default and look for 
            // that
            //

            ULONG cchDefault = lstrlen(tszAppPathDefault) + 1;
            if (cchDefault < MAX_PATH + 1 - 4)
            {
                StringCchCat(tszAppPathDefault, MAX_PATH + 1, DOTEXE);
                fFound = FileExists(tszAppPathDefault, MAX_PATH + 1);
                if (fFound)
                {
                    StringCchCopy(ptszFilename, cchBuff, tszAppPathDefault);
                    break;
                }
            }
        }

        //
        // If the app path key specified a value for the PATH variable,
        // try looking in all the directories it specifies 
        //

        if (*tszAppPathVar)
        {
            if (*tszFilenameWithExe)
            {
                fFound = FileExistsInPath(tszFilenameWithExe, 
                                          tszAppPathVar, 
                                          tszFoundFile, 
                                          MAX_PATH + 1);
            }

            if (!fFound)
            {
                fFound = FileExistsInPath(ptszFilename, 
                                          tszAppPathVar, 
                                          tszFoundFile, 
                                          MAX_PATH + 1);
            }

            if (fFound)
            {
                StringCchCopy(ptszFilename, cchBuff, tszFoundFile);
                break;
            }
        }

        //
        // Try looking along the system PATH variable
        //

        ULONG cchPath;
        TCHAR tszSystemPath[MAX_PATH_VALUE] = TEXT("");

        cchPath = GetEnvironmentVariable(TEXT("Path"), 
                                         tszSystemPath,
                                         MAX_PATH_VALUE);

        if (!cchPath || cchPath > MAX_PATH_VALUE)
        {
            break;
        }

        if (*tszFilenameWithExe)
        {
            fFound = FileExistsInPath(tszFilenameWithExe, 
                                      tszSystemPath, 
                                      tszFoundFile, 
                                      MAX_PATH + 1);
        }

        if (!fFound)
        {
            fFound = FileExistsInPath(ptszFilename, 
                                      tszSystemPath, 
                                      tszFoundFile, 
                                      MAX_PATH + 1);
        }

        if (fFound)
        {
            StringCchCopy(ptszFilename, cchBuff, tszFoundFile);
        }
    } while (0);
 
    return fFound;
}



//+--------------------------------------------------------------------------
//
//  Function:   IsLocalFilename
//
//  Synopsis:   Return TRUE if [tszFilename] represents a file on the local
//              machine, FALSE otherwise.
//
//  History:    1-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsLocalFilename(LPCTSTR tszFilename)
{
    if (!tszFilename || !*tszFilename)
    {
        return FALSE;
    }

    if (tszFilename[0] == TEXT('\\') && tszFilename[1] == TEXT('\\'))
    {
        //
        // Find the length of the portion of the name belonging to the machine name
        //
        LPCTSTR ptszNextSlash = _tcschr(tszFilename + 2, TEXT('\\'));
        if (!ptszNextSlash)
        {
            return FALSE;
        }
        DWORD cchMachineName = (DWORD)(ptszNextSlash - tszFilename - 2);
    
        //
        // Get the local machine name (both NetBIOS and FQDN) to compare with that passed in.
        //
        TCHAR tszLocalName[SA_MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchLocalName = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerName(tszLocalName, &cchLocalName))
        {
            ERR_OUT("IsLocalFilename: GetComputerName", HRESULT_FROM_WIN32(GetLastError()));
            return FALSE;
        }

        TCHAR tszFQDN[SA_MAX_COMPUTERNAME_LENGTH + 1];
        DWORD cchFQDN = SA_MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, tszFQDN, &cchFQDN))
        {
            ERR_OUT("IsLocalFilename: GetComputerNameEx", HRESULT_FROM_WIN32(GetLastError()));
            return FALSE;
        }

        //
        // Return whether we have a match on the machine name portion.
        // I'm assuming that we won't have a case where the NetBIOS name
        // and the FQDN are the same length but different.
        //
        if (cchMachineName == cchLocalName)
        {
            return lstrcmpi(tszFilename + 2, tszLocalName) == 0;
        }
        else if (cchMachineName == cchFQDN)
        {
            return lstrcmpi(tszFilename + 2, tszFQDN) == 0;
        }
        else
        {
            // if the lengths didn't match, there's no need
            // to even bother with a string comparison
            return FALSE;
        }
    }

    if (s_isDriveLetter(tszFilename[0]) && tszFilename[1] == TEXT(':'))
    {
        TCHAR tszRoot[] = TEXT("x:\\");
        tszRoot[0] = tszFilename[0];
        UINT uiType = GetDriveType(tszRoot);
        if (uiType == DRIVE_REMOTE || uiType == 0 || uiType == 1)
        {
            return FALSE;
        }
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   StripLeadTrailSpace
//
//  Synopsis:   Delete leading and trailing spaces from [ptsz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
StripLeadTrailSpace(LPTSTR ptsz)
{
    ULONG cchLeadingSpace = _tcsspn(ptsz, TEXT(" \t"));
    ULONG cch = lstrlen(ptsz);

    //
    // If there are any leading spaces or tabs, move the string
    // (including its nul terminator) left to delete them.
    //

    if (cchLeadingSpace)
    {
        MoveMemory(ptsz, 
                   ptsz + cchLeadingSpace, 
                   (cch - cchLeadingSpace + 1) * sizeof(TCHAR));
        cch -= cchLeadingSpace;
    }

    //
    // Concatenate at the first trailing space
    //

    LPTSTR ptszTrailingSpace = (LPTSTR) FindFirstTrailingSpace(ptsz);

    if (ptszTrailingSpace)
    {
        *ptszTrailingSpace = TEXT('\0');
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   FindFirstTrailingSpace
//
//  Synopsis:   Return a pointer to the first trailing space in [ptsz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCTSTR 
FindFirstTrailingSpace(LPCTSTR ptsz)
{
    LPCTSTR ptszFirstTrailingSpace = NULL;
    LPCTSTR ptszCur;

    for (ptszCur = ptsz; *ptszCur; ptszCur= NextChar(ptszCur))
    {
        if (*ptszCur == ' ' || *ptszCur == '\t')
        {
            if (!ptszFirstTrailingSpace)
            {
                ptszFirstTrailingSpace = ptszCur;
            }
        }
        else if (ptszFirstTrailingSpace)
        {
            ptszFirstTrailingSpace = NULL;
        }
    }
    return ptszFirstTrailingSpace;
}


//+--------------------------------------------------------------------------
//
//  Function:   DeleteQuotes
//
//  Synopsis:   Delete all instances of the double quote character from
//              [ptsz].
//
//  Arguments:  [ptsz] - nul terminated string
//
//  Modifies:   *[ptsz]
//
//  History:    11-21-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
DeleteQuotes(LPTSTR ptsz)
{
    TCHAR *ptszLead;
    TCHAR *ptszTrail;

    //
    // Move a lead and trail pointer through the buffer, copying from the lead 
    // to the trail whenever the character isn't one we're deleting (a double 
    // quote). 
    // 
    // Note: the "Lead" and "Trail" in ptszLead and ptszTrail do not refer
    // to DBCS lead/trail bytes, rather that the ptszLead pointer can move
    // ahead of ptszTrail when it is advanced past a double quote.
    // 

    for (ptszTrail = ptszLead = ptsz;
         *ptszLead;
         ptszLead = NextChar(ptszLead))
    {
        //
        // If the current char is a double quote, we want it deleted, so don't 
        // copy it and go on to the next char. 
        // 

        if (*ptszLead == TEXT('"'))
        {
            continue;
        }

        //
        // ptszLead is pointing to a 'normal' character, i.e.  not a double 
        // quote. 
        // 
        *ptszTrail++ = ptszLead[0];
    }
    *ptszTrail = TEXT('\0');
}


//+--------------------------------------------------------------------------
//
//  Function:   AddQuotes
//
//  Synopsis:   If there's room in the buffer, insert a quote as the first
//              character and concat a quote as the last character.
//
//  Arguments:  [ptsz]   - string to modify
//              [cchBuf] - size of string's buffer, in chars
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
AddQuotes(LPTSTR ptsz, ULONG cchBuf)
{
    ULONG cch = lstrlen(ptsz);

    if (cch < cchBuf - 2)
    {
        MoveMemory(ptsz + 1, ptsz, cch * sizeof(TCHAR));
        *ptsz = ptsz[cch + 1] = TEXT('"');
        ptsz[cch + 2] = TEXT('\0');
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FileExists
//
//  Synopsis:   Return TRUE if the specified file exists and is not a 
//              directory.
//
//  Arguments:  [ptszFileName] - filename to search for & modify
//              [cchBuff] - size of buffer
//
//  Modifies:   Filename portion of [ptszFileName].
//
//  Returns:    TRUE  - file found
//              FALSE - file not found or error
//
//  History:    11-21-96   DavidMun   Created
//
//----------------------------------------------------------------------------

BOOL
FileExists(LPTSTR ptszFileName, size_t cchBuff)
{
    TCHAR tszFullPath[MAX_PATH + 1];
    LPTSTR ptszFilePart;

    ULONG cchFullPath = GetFullPathName(ptszFileName,
                                        MAX_PATH + 1,
                                        tszFullPath,
                                        &ptszFilePart) + 1;

    if (cchFullPath && cchFullPath <= MAX_PATH + 1)
    {
        if (FAILED(StringCchCopy(ptszFileName, cchBuff, tszFullPath)))
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

    ULONG flAttributes; 
 
    flAttributes = GetFileAttributes(ptszFileName);

    // If we couldn't determine file's attributes, don't consider it found

    if (flAttributes == 0xFFFFFFFF)
    {
        return FALSE;
    }

    // if file is actually a directory, it's unsuitable as a task, so fail

    if (flAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        return FALSE;
    }

    // Get the filename sans trailing spaces

    WIN32_FIND_DATA FindFileData;
    HANDLE hFile = FindFirstFile(ptszFileName, &FindFileData);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    FindClose(hFile);

    LPTSTR ptszLastSlash = _tcsrchr((LPTSTR)ptszFileName, TEXT('\\'));
    if (ptszLastSlash)
    {
        StringCchCopy(ptszLastSlash + 1, cchBuff - (ptszLastSlash + 1 - ptszFileName), FindFileData.cFileName);
    }

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Function:   FileExistsInPath
//
//  Synopsis:   Return TRUE if [ptszFilename] exists in path [ptszPath].
//
//  Arguments:  [ptszFilename]  - file to look for
//              [ptszPath]      - semicolon delimited list of dirs
//              [ptszFoundFile] - if found, [ptszDir]\[ptszFilename]
//              [cchFoundBuf]   - size in chars of [ptszFoundFile] buffer
//
//  Returns:    TRUE if file found in dir, FALSE otherwise
//
//  Modifies:   *[ptszFoundFile]
//
//  History:    11-22-1996   DavidMun   Created
//
//  Notes:      Note that by calling FileExists we ensure the found file
//              is a file, not a directory.
//
//---------------------------------------------------------------------------

BOOL
FileExistsInPath(
        LPTSTR  ptszFilename, 
        LPCTSTR ptszPath, 
        LPTSTR  ptszFoundFile, 
        ULONG   cchFoundBuf)
{
    ULONG  cchCopied;
    LPTSTR ptszFilePart;

    cchCopied = SearchPath(ptszPath,
                           ptszFilename,
                           NULL,
                           cchFoundBuf,
                           ptszFoundFile,
                           &ptszFilePart);

    if (cchCopied && cchCopied <= cchFoundBuf)
    {
        return FileExists(ptszFoundFile, cchFoundBuf);
    }
    return FALSE;
}


#define MAX_KEY_LEN     (ARRAY_LEN(REGSTR_PATH_APPPATHS) + MAX_PATH)

//+--------------------------------------------------------------------------
//
//  Function:   GetAppPathInfo
//
//  Synopsis:   Fill [ptszAppPathDefault] with the default value and
//              [ptszAppPathVar] with the Path value in the
//              [ptszFilename] application's key under the APPPATHS regkey.
//
//  Arguments:  [ptszFilename]       - application name
//              [ptszAppPathDefault] - if not NULL, filled with default value
//              [cchDefaultBuf]      - size of [ptszAppPathDefault] buffer
//              [ptszAppPathVar]     - if not NULL, filled with Path value
//              [cchPathVarBuf]      - size of [cchPathVarBuf] buffer
//
//  Modifies:   *[ptszAppPathDefault], *[ptszAppPathVar]
//
//  History:    11-22-1996   DavidMun   Created
//
//  Notes:      Both values are optional on the registry key, so if a 
//              requested value isn't found, it is set to "".
//
//---------------------------------------------------------------------------

VOID
GetAppPathInfo(
        LPCTSTR ptszFilename, 
        LPTSTR  ptszAppPathDefault, 
        ULONG   cchDefaultBuf,
        LPTSTR  ptszAppPathVar, 
        ULONG   cchPathVarBuf)
{
    HKEY    hkey = NULL;
    TCHAR   tszAppPathKey[MAX_KEY_LEN];

    //
    // Initialize out vars
    //

    if (ptszAppPathDefault)
    {
        ptszAppPathDefault[0] = TEXT('\0');
    }

    if (ptszAppPathVar)
    {
        ptszAppPathVar[0] = TEXT('\0');
    }

    //
    // Build registry key name for this app
    //

    StringCchCopy(tszAppPathKey, MAX_KEY_LEN, REGSTR_PATH_APPPATHS);
    StringCchCat(tszAppPathKey, MAX_KEY_LEN, TEXT("\\"));
    StringCchCat(tszAppPathKey, MAX_KEY_LEN, ptszFilename);

    do
    {
        LRESULT lr;
        lr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          tszAppPathKey,
                          0,
                          KEY_QUERY_VALUE,
                          &hkey);

        if (lr != ERROR_SUCCESS)
        {
            break;
        }

        //
        // If the key could be opened, attempt to read requested values. 
        // Both are optional, so ignore errors.
        //

        DWORD cb;
        DWORD dwType;


        if (ptszAppPathDefault)
        {
            cb = cchDefaultBuf * sizeof(TCHAR);
            lr = RegQueryValueEx(hkey, 
                                 NULL, // value name
                                 NULL, // reserved
                                 &dwType,
                                 (LPBYTE) ptszAppPathDefault, 
                                 &cb);
 
            if (lr == ERROR_SUCCESS)
            {
                schAssert(dwType == REG_SZ);
            }
        }

        if (ptszAppPathVar)
        {
            cb = cchPathVarBuf * sizeof(TCHAR);
 
            lr = RegQueryValueEx(hkey, 
                                 TEXT("Path"),  // value name
                                 NULL,          // reserved
                                 &dwType,
                                 (LPBYTE) ptszAppPathVar, 
                                 &cb);
 
            if (lr == ERROR_SUCCESS)
            {
                schAssert(dwType == REG_SZ);
            }
        }
    } while (0);

    if (hkey)
    {
        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\sadat.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       sadat.cxx
//
//  Contents:   Routines which manipulate the SA.DAT file in the Tasks
//              folder. This file is used by both the service and the UI
//              to determine service state, OS info, etc.
//
//  Classes:    None.
//
//  Functions:  SADatGetData
//              SADatPath
//              SADatCreate
//              SADatSetData
//              SADatSetSecurity
//
//  History:    08-Jul-96   MarkBl  Created
//              22-May-01   drbeck, jbenton  Added SADatSetSecurity
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "..\inc\debug.hxx"
#include "..\inc\sadat.hxx"

//Required for adding ACE to sa.dat file
#include <Accctrl.h>
#include <Aclapi.h>

DWORD 
SADatSetSecurity(
    HANDLE hFile);   // handle to file to add ACE

HRESULT
SADatGetData(
    HANDLE  hFile,
    DWORD   cbData,
    BYTE    rgbData[]);

void
SADatPath(
    LPCTSTR ptszFolderPath,
    LPTSTR  ptszSADatPath,
    size_t cchBuff);

//+---------------------------------------------------------------------------
//
//  Function:   SADatGetData
//
//  Synopsis:   Retrieve and validate data from the file, SA.DAT, located
//              in the folder path specified.
//
//  Arguments:  [ptszFolderPath] -- SA.DAT path location.
//              [cbData]         -- Data buffer size.
//              [rgbData]        -- Data buffer.
//              [phFile]         -- Optional return handle.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount read isn't what we expected or the
//                data is invalid.
//              Create/ReadFile HRESULT status code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatGetData(
    LPCTSTR  ptszFolderPath,
    DWORD    cbData,
    BYTE     rgbData[],
    HANDLE * phFile)
{
    schAssert(cbData >= SA_DAT_VERSION_ONE_SIZE);

    //
    // Open SA.DAT in the folder path indicated. Fail if it doesn't exist.
    //

    TCHAR tszSADatPath[MAX_PATH + 1];
    SADatPath(ptszFolderPath, tszSADatPath, MAX_PATH + 1);

    HANDLE hFile = CreateFile(tszSADatPath,
                              GENERIC_READ |
                                (phFile != NULL ? GENERIC_WRITE : 0),
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_HIDDEN,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Read & validate file content.
    //

    HRESULT hr = SADatGetData(hFile, cbData,  rgbData);

    if (SUCCEEDED(hr))
    {
        //
        // No need to verify the size or the service flags. We've read at
        // least the amount expected, and for this version, only the LSB
        // of the service flags is used. Future versions may wish to do
        // further flag checks.
        //

        BYTE bPlatform;
        CopyMemory(&bPlatform, rgbData + SA_DAT_PLATFORM_OFFSET,
                        sizeof(bPlatform));

        if (bPlatform != VER_PLATFORM_WIN32_NT &&
            bPlatform != VER_PLATFORM_WIN32_WINDOWS)
        {
            hr = E_UNEXPECTED;
            CHECK_HRESULT(hr);
        }
        else
        {
            if (phFile != NULL)     // Optional return handle.
            {
                //
                // Reset the file pointer to the beginning for the returned
                // handle.
                //

                if (SetFilePointer(hFile,
                                    0,
                                    NULL,
                                    FILE_BEGIN) != -1)
                {
                    *phFile = hFile;
                    hFile   = NULL;
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CHECK_HRESULT(hr);
                }
            }
        }
    }

    if (hFile != NULL) CloseHandle(hFile);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatGetData
//
//  Synopsis:   A more refined version of the overloaded function above.
//              Return individual fields instead of raw data.
//
//  Arguments:  [ptszFolderPath] -- SA.DAT path location.
//              [pdwVersion]     -- Returned version.
//              [pbPlatform]     -- Returned platform id.
//              [prgSvcFlags]    -- Returned service flags.
//
//  Returns:    SADatGetData return code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatGetData(
    LPCTSTR  ptszFolderPath,
    DWORD *  pdwVersion,
    BYTE *   pbPlatform,
    BYTE *   prgSvcFlags)
{
    BYTE    rgbData[SA_DAT_VERSION_ONE_SIZE];
    HRESULT hr;

    hr = SADatGetData(ptszFolderPath, SA_DAT_VERSION_ONE_SIZE, rgbData);

    if (SUCCEEDED(hr))
    {
        *pdwVersion = (DWORD)*rgbData;
        CopyMemory(pbPlatform, rgbData + SA_DAT_PLATFORM_OFFSET,
                        sizeof(*pbPlatform));
        CopyMemory(prgSvcFlags, rgbData + SA_DAT_SVCFLAGS_OFFSET,
                        sizeof(*prgSvcFlags));
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatCreate
//
//  Synopsis:   Create & initialize the binary file, SA.DAT, in the Tasks
//              folder. The platform id is set to indicate which OS we're
//              currently running under; the service flag is set to 1
//              to indicate the service is running.
//
//  Arguments:  [ptszFolderPath]  -- Path to the Tasks folder.
//              [fServiceRunning] -- Flag indicating running service.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount written isn't what we expected.
//              Create/WriteFile HRESULT status code on failure.
//
//  Notes:      This is to be called by the service only with service start.
//
//----------------------------------------------------------------------------
HRESULT
SADatCreate(
    LPCTSTR  ptszFolderPath,
    BOOL     fServiceRunning)
{
    BYTE rgbData[SA_DAT_VERSION_ONE_SIZE];
    DWORD dwResult;

    //
    // Set size.
    //

    DWORD dwSize = SA_DAT_VERSION_ONE_SIZE;
    CopyMemory(rgbData, &dwSize, sizeof(dwSize));


    //
    // Set the platform id.
    //

    OSVERSIONINFO osverinfo;
    osverinfo.dwOSVersionInfoSize = sizeof(osverinfo);

    if (!GetVersionEx(&osverinfo))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BYTE bPlatform;
    if (osverinfo.dwPlatformId == VER_PLATFORM_WIN32_NT)    // NT
    {
        bPlatform = VER_PLATFORM_WIN32_NT;
    }
    else                                                    // Assume windows
    {
        bPlatform = VER_PLATFORM_WIN32_WINDOWS;
    }

    CopyMemory(rgbData + SA_DAT_PLATFORM_OFFSET, &bPlatform,
                    sizeof(bPlatform));

    //
    // Set the service flags to indicate the service is running.
    //

    BYTE rgfServiceFlags = (fServiceRunning ? SA_DAT_SVCFLAG_SVC_RUNNING : 0);

    //
    // Determine whether the machine supports wakeup timers.
    //
    if (ResumeTimersSupported())
    {
        rgfServiceFlags |= SA_DAT_SVCFLAG_RESUME_TIMERS;
    }

    rgbData[SA_DAT_SVCFLAGS_OFFSET] = rgfServiceFlags;

    //
    // Create the file. Overwrite, if it exists.
    //

    TCHAR tszSADatPath[MAX_PATH + 1];
    SADatPath(ptszFolderPath, tszSADatPath, MAX_PATH + 1);

    //
    // First clear any extraneous attribute bits that were added by
    // somebody else that would cause the CreateFile to fail
    //

    if (!SetFileAttributes(tszSADatPath, FILE_ATTRIBUTE_HIDDEN))
    {

#if DBG == 1

        //
        // Not a problem if the file doesn't exist
        //

        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        }

#endif  // DBG == 1

    }

    HANDLE hFile = CreateFile(tszSADatPath,
                              GENERIC_READ | GENERIC_WRITE | WRITE_DAC,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_HIDDEN,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Add read ACE for authenticated users
    dwResult = SADatSetSecurity(hFile);

    if( ERROR_SUCCESS != dwResult )
    {
       CloseHandle(hFile);

       CHECK_HRESULT(HRESULT_FROM_WIN32(dwResult));
       return HRESULT_FROM_WIN32(dwResult);
    }

    //
    // Write out the contents.
    //

    HRESULT hr = SADatSetData(hFile, sizeof(rgbData), rgbData);

    CloseHandle(hFile);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatGetData
//
//  Synopsis:   Nothing SA.DAT-specific here. Just a helper to read a blob
//              of bytes from the file indicated, and ensure we read the
//              amount expected.
//
//  Arguments:  [hFile]   -- Destination file.
//              [cbData]  -- Amount of data to read.
//              [rgbData] -- Read data.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount read isn't what we expected.
//              ReadFile HRESULT status code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatGetData(
    HANDLE  hFile,
    DWORD   cbData,
    BYTE    rgbData[])
{
    DWORD cbRead;
    if (!ReadFile(hFile,
                  rgbData,
                  cbData,
                  &cbRead,
                  NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (cbRead != cbData)
    {
        CHECK_HRESULT(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatSetData
//
//  Synopsis:   Nothing SA.DAT-specific here. Just a helper to write a blob
//              of bytes to the file indicated, and ensure we wrote the
//              amount expected.
//
//  Arguments:  [hFile]   -- Destination file.
//              [cbData]  -- Amount of data to write.
//              [rgbData] -- Actual data.
//
//  Returns:    S_OK
//              E_UNEXPECTED if the amount written isn't what we expected.
//              WriteFile HRESULT status code on failure.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SADatSetData(
    HANDLE     hFile,
    DWORD      cbData,
    const BYTE rgbData[])
{
    DWORD cbWritten;
    if (!WriteFile(hFile,
                   rgbData,
                   cbData,
                   &cbWritten,
                   NULL))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }

    if (cbWritten != cbData)
    {
        CHECK_HRESULT(E_UNEXPECTED);
        return E_UNEXPECTED;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatPath
//
//  Synopsis:   Return a concatenation the folder path and "\SA.DAT".
//
//  Arguments:  [ptszFolderPath] -- Folder path.
//              [ptszSADatPath]  -- New path.
//              [cchBuff] -- buffer size
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
SADatPath(
    LPCTSTR ptszFolderPath,
    LPTSTR  ptszSADatPath,
    size_t  cchBuff)
{
    TCHAR tszSADat[] = TEXT("\\SA.DAT");

#if (DBG == 1)

    //
    // Assert that the folder path:
    //  is not NULL
    //  is not an empty string
    //  does not end in a backslash
    //

    schAssert(ptszFolderPath != NULL);
    schAssert(*ptszFolderPath);
    LPCTSTR ptszLastSlash = _tcsrchr(ptszFolderPath, TEXT('\\'));
    schAssert(!ptszLastSlash || ptszLastSlash[1]);

#endif // (DBG == 1)

    StringCchCopy(ptszSADatPath, cchBuff, ptszFolderPath);
    StringCchCat(ptszSADatPath, cchBuff, tszSADat);
}

//+---------------------------------------------------------------------------
//
//  Function:   ResumeTimersSupported
//
//  Synopsis:   Jumps through hoops to determine whether the machine supports
//              resume timers (aka wakeup timers)
//
//  Arguments:  None.
//
//  Returns:    TRUE - Resume timers are supported
//              FALSE - Resume timers are not supported
//
//----------------------------------------------------------------------------
BOOL
ResumeTimersSupported()
{
    HANDLE  hTimer;
    hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

    if (hTimer == NULL)
    {
        ERR_OUT("CreateWaitableTimer", GetLastError());
        return FALSE;
    }

    LARGE_INTEGER li = { 0xFFFFFFFF, 0xFFFFFFFF };
    BOOL    fResult = FALSE;

    if (SetWaitableTimer(hTimer, &li, 0, NULL, 0, TRUE))
    {
        //
        // By design, this call to SetWaitableTimer will succeed even on
        // machines that do NOT support resume timers.  GetLastError must
        // be used to determine if, indeed, the machine supports resume
        // timers.
        //
        if (GetLastError() == ERROR_NOT_SUPPORTED)
        {
            // This machine does not support resume timers
            DBG_OUT("Machine does not support resume timers");
        }
        else
        {
            DBG_OUT("Machine supports resume timers");
            fResult = TRUE;
        }
    }
    else
    {
        ERR_OUT("SetWaitableTimer", GetLastError());
    }

    CancelWaitableTimer(hTimer);
    CloseHandle(hTimer);

    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   SADatSetSecurity
//
//  Synopsis:   Add an ACE to the file that allows authenticated users to
//              read the file. We cannot rely on inheriting the necessary 
//              permissions of the containing folder.
//
//  Arguments:  [hFile]   -- Destination file.
//
//  Returns:    ERROR_SUCCESS upon success
//              Non zero value upon failure
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD SADatSetSecurity (
    HANDLE hFile             // handle to file
) 
{
   DWORD                dwRes = ERROR_SUCCESS;
   PSID                 pSid     = NULL;
   PACL                 pOldDACL = NULL;
   PACL                 pNewDACL = NULL;
   PSECURITY_DESCRIPTOR pSD      = NULL;
   EXPLICIT_ACCESS      ExplicAcc;
   
   schAssert(hFile != NULL);
   
   // Create the SID for "NTAUTH\Athenticated Users"
   SID_IDENTIFIER_AUTHORITY NtAuth = SECURITY_NT_AUTHORITY;
   
   if (  !AllocateAndInitializeSid(
            &NtAuth,
            1,
            SECURITY_AUTHENTICATED_USER_RID, 
            0, 0, 0, 0, 0, 0, 0,
            &pSid
            )
      )
   {
      dwRes = GetLastError();
      goto Cleanup;
   }
   
   
   // Get a pointer to the existing DACL.
   dwRes = GetSecurityInfo(
      hFile, 
      SE_FILE_OBJECT, 
      DACL_SECURITY_INFORMATION,
      NULL, 
      NULL, 
      &pOldDACL, 
      NULL, 
      &pSD
      );
   
   if (ERROR_SUCCESS != dwRes)
   {
      goto Cleanup; 
   }  
   
   // Initialize an EXPLICIT_ACCESS structure for the new ACE. 
   
   SecureZeroMemory(&ExplicAcc, sizeof(EXPLICIT_ACCESS));
   
   ExplicAcc.grfAccessPermissions = GENERIC_READ;
   ExplicAcc.grfAccessMode        = GRANT_ACCESS;
   ExplicAcc.grfInheritance       = NO_INHERITANCE;
   ExplicAcc.Trustee.TrusteeForm  = TRUSTEE_IS_SID;
   ExplicAcc.Trustee.ptstrName    = (LPTSTR)pSid;
   
   // Create a new ACL that merges the new ACE
   // into the existing DACL.
   
   dwRes = SetEntriesInAcl(1, &ExplicAcc, pOldDACL, &pNewDACL);
   if (ERROR_SUCCESS != dwRes)
   {
      goto Cleanup; 
   }  
   
   // Attach the new ACL as the file's DACL.
   
   dwRes = SetSecurityInfo(
      hFile, 
      SE_FILE_OBJECT, 
      DACL_SECURITY_INFORMATION,
      NULL, 
      NULL, 
      pNewDACL, 
      NULL
      );
   
   if (ERROR_SUCCESS != dwRes)
   {
      goto Cleanup; 
   }  
   
   Cleanup:
   
   if(pSD != NULL) 
   {
      LocalFree((HLOCAL) pSD); 
   }
   
   if(pNewDACL != NULL) 
   {
      LocalFree((HLOCAL) pNewDACL); 
   }
   
   if( pSid != NULL )
   {
      FreeSid(pSid);
   }

   return dwRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\security.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    26-Jun-96   MarkBl  Created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <common.hxx>   // MAX_SID_SIZE
#include "..\inc\debug.hxx"
#include "..\inc\security.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CreateSecurityDescriptor
//
//  Synopsis:   Create a security descriptor with the ACE information
//              specified.
//
//  Arguments:  [AceCount] -- ACE count (no. of rgMyAce and rgAce elements).
//              [rgMyAce]  -- ACE specification array.
//              [rgAce]    -- Caller allocated array of ptrs to ACEs so
//                            this function doesn't have to allocate it.
//
//  Returns:    TRUE  -- Function succeeded,
//              FALSE -- Otherwise.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    DWORD               AceCount,
    MYACE               rgMyAce[],
    PACCESS_ALLOWED_ACE rgAce[],
    DWORD *             pStatus)
{
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PACL  pAcl                               = NULL;
    DWORD LengthAces                         = 0;
    DWORD LengthAcl;
    DWORD i;
    DWORD Status;

    for (i = 0; i < AceCount; i++)
    {
        rgAce[i] = CreateAccessAllowedAce(rgMyAce[i].pSid,
                                          rgMyAce[i].AccessMask,
                                          0,
                                          rgMyAce[i].InheritFlags,
                                          &Status);

        if (rgAce[i] == NULL)
        {
            goto ErrorExit;
        }

        LengthAces += rgAce[i]->Header.AceSize;
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl  = sizeof(ACL) + LengthAces;

    //
    // Create the ACL.
    //

    pAcl = (PACL)LocalAlloc(LMEM_FIXED, LengthAcl);

    if (pAcl == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, ACL allocation failed\n"));
        goto ErrorExit;
    }

    if (!InitializeAcl(pAcl, LengthAcl, ACL_REVISION))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, InitializeAcl failed, " \
            "status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    for (i = 0; i < AceCount; i++)
    {
        if (!AddAce(pAcl,
                    ACL_REVISION,
                    0,
                    rgAce[i],
                    rgAce[i]->Header.AceSize))
        {
            Status = GetLastError();
            schDebugOut((DEB_ERROR,
                "CreateSecurityDescriptor, AddAce[%l] failed, " \
                "status = 0x%lx\n", i, Status));
            goto ErrorExit;
        }

        LocalFree(rgAce[i]);
        rgAce[i] = NULL;
    }

    //
    // Create the security descriptor.
    //

    pSecurityDescriptor = LocalAlloc(LMEM_FIXED,
                                     SECURITY_DESCRIPTOR_MIN_LENGTH);

    if (pSecurityDescriptor == NULL)
    {
        Status = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, SECURITY_DESCRIPTOR allocation " \
            "failed\n"));
        goto ErrorExit;
    }

    if (!InitializeSecurityDescriptor(pSecurityDescriptor,
                                      SECURITY_DESCRIPTOR_REVISION))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, InitializeSecurityDescriptor " \
            "failed, status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    if (!SetSecurityDescriptorDacl(pSecurityDescriptor,
                                   TRUE,
                                   pAcl,
                                   FALSE))
    {
        Status = GetLastError();
        schDebugOut((DEB_ERROR,
            "CreateSecurityDescriptor, SetSecurityDescriptorDacl " \
            "failed, status = 0x%lx\n",
            Status));
        goto ErrorExit;
    }

    if (pStatus != NULL) *pStatus = ERROR_SUCCESS;

    return(pSecurityDescriptor);

ErrorExit:
    for (i = 0; i < AceCount; i++)
    {
        if (rgAce[i] != NULL)
        {
            LocalFree(rgAce[i]);
            rgAce[i] = NULL;
        }
    }
    if (pAcl != NULL) LocalFree(pAcl);
    if (pSecurityDescriptor != NULL) LocalFree(pSecurityDescriptor);

    if (pStatus != NULL) *pStatus = Status;

    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   DeleteSecurityDescriptor
//
//  Synopsis:   Deallocate the security descriptor allocated in
//              CreateSecurityDescriptor.
//
//  Arguments:  [pSecurityDescriptor] -- SD returned from
//                                       CreateSecurityDescriptor.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
DeleteSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor)
{
    BOOL fPresent;
    BOOL fDefaulted;
    PACL pAcl;

    schAssert(pSecurityDescriptor != NULL);

    if (GetSecurityDescriptorDacl(pSecurityDescriptor,
                                  &fPresent,
                                  &pAcl,
                                  &fDefaulted))
    {
        if (fPresent && pAcl != NULL)
        {
            LocalFree(pAcl);
        }
    }
    else
    {
        schDebugOut((DEB_ERROR,
            "DeleteSecurityDescriptor, GetSecurityDescriptorDacl failed, " \
            "status = 0x%lx\n",
            GetLastError()));
    }

    LocalFree(pSecurityDescriptor);
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAccessAllowedAce
//
//  Synopsis:   Scavenged code from winlogon to create an access allowed ACE.
//              Modified a bit to use Win32 vs. Rtl.
//
//  Arguments:  [pSid]         -- Sid to which this ACE is applied.
//              [AccessMask]   -- ACE access mask value.
//              [AceFlags]     -- ACE flags value.
//              [InheritFlags] -- ACE inherit flags value.
//
//  Returns:    Created ACE if successful.
//              NULL on error.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
PACCESS_ALLOWED_ACE
CreateAccessAllowedAce(
    PSID        pSid,
    ACCESS_MASK AccessMask,
    UCHAR       AceFlags,
    UCHAR       InheritFlags,
    DWORD *     pStatus)
{
    ULONG   LengthSid = GetLengthSid(pSid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)LocalAlloc(LMEM_FIXED, LengthACE);

    if (Ace == NULL)
    {
        if (pStatus != NULL) *pStatus = ERROR_NOT_ENOUGH_MEMORY;
        schDebugOut((DEB_ERROR,
            "CreateAccessAllowedAce, ACE allocation failed\n"));
        return(NULL);
    }

    Ace->Header.AceType  = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize  = (UCHAR)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask            = AccessMask;
    CopySid(LengthSid, (PSID)(&(Ace->SidStart)), pSid);

    if (pStatus != NULL) *pStatus = ERROR_SUCCESS;

    return(Ace);
}


//+---------------------------------------------------------------------------
//
//  Function:   IsThreadCallerAnAdmin
//
//  Synopsis:   Determine if the user represented by the specified token is a
//              member of the administrators group.
//
//  Arguments:  [hThreadToken] -- Token to check.  If NULL, the current
//                  thread's token is used if there is one, or else the
//                  current process' token.
//
//  Returns:    TRUE  -- Match
//              FALSE -- Thread caller not an admin or an error occurred.
//
//----------------------------------------------------------------------------
BOOL
IsThreadCallerAnAdmin(HANDLE hThreadToken)
{
    //
    // Create an admin SID to compare against.
    //
#if 1
    //
    // Efficient way - relies on the format of the SID structure (which is
    // published in winnt.h) - valid for at least NT 4 and NT 5
    //

    schAssert(sizeof SID == 12);

    const struct
    {
        SID     Sid;
        DWORD   SubAuthority1;
    } AdminSid =
        {
          { SID_REVISION,                   // Revision
            2,                              // SubAuthorityCount
            SECURITY_NT_AUTHORITY,          // IdentifierAuthority
            SECURITY_BUILTIN_DOMAIN_RID },  // SubAuthority[0]
            DOMAIN_ALIAS_RID_ADMINS         // SubAuthority[1]
        };
#else
/*
#error  SID structure has changed!
    //
    // Inefficient way, initialize at run time
    //
    BYTE    AdminSid[MAX_SID_SIZE];
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority = SECURITY_NT_AUTHORITY;

    if (! InitializeSid(rgbAdminSid, &IdentifierAuthority, 2))
    {
        schAssert(0);
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    *GetSidSubAuthority(rgbAdminSid, 0) = SECURITY_BUILTIN_DOMAIN_RID;
    *GetSidSubAuthority(rgbAdminSid, 1) = DOMAIN_ALIAS_RID_ADMINS;
*/
#endif

    //
    // See if the token is a member.
    //
    BOOL    fIsCallerAdmin;
    if (!CheckTokenMembership(hThreadToken,
                              (PSID) &AdminSid,
                              &fIsCallerAdmin))
    {
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return FALSE;
    }

    return fIsCallerAdmin;
}

//+---------------------------------------------------------------------------
//
//  Function:   EnablePrivilege
//
//  Synopsis:   Tries to enable / disable a privilege for the current process.
//
//  Arguments:  [pszPrivName]  - name of privilege to enable / disable.
//              [bEnable]      - enable / disable switch.
//              [pbWasEnabled] - optional pointer to receive the previous
//                               state of the privilege.
//
//  Returns:    win32 error code.
//
//----------------------------------------------------------------------------
DWORD 
EnablePrivilege(
    IN  PCWSTR                  pszPrivName,
    IN  BOOL                    bEnable,
    OUT PBOOL                   pbWasEnabled    OPTIONAL
    )
{
    DWORD                   dwError         = ERROR_SUCCESS;
    BOOL                    bSuccess;
    HANDLE                  hToken          = 0;
    DWORD                   dwSize;
    TOKEN_PRIVILEGES        privNew;
    TOKEN_PRIVILEGES        privOld;

    bSuccess = OpenProcessToken(
                   GetCurrentProcess(),
                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                   &hToken);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    bSuccess = LookupPrivilegeValue(
                   0,
                   pszPrivName,
                   &privNew.Privileges[0].Luid);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    privNew.PrivilegeCount = 1;
    privNew.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED : 0;

    bSuccess = AdjustTokenPrivileges(
                   hToken,
                   FALSE,
                   &privNew,
                   sizeof(privOld),
                   &privOld,
                   &dwSize);

    if (!bSuccess)
    {
        dwError = GetLastError();
        goto Cleanup;
    }

    if (pbWasEnabled)
    {
        *pbWasEnabled = (privOld.Privileges[0].Attributes & SE_PRIVILEGE_ENABLED)
                            ? TRUE : FALSE;
    }

Cleanup:

    if (hToken)
    {
        CloseHandle(hToken);
    }

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\common\time.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       time.cxx
//
//  Contents:
//
//  Classes:    None.
//
//  Functions:  None.
//
//  History:    09-Sep-95   EricB   Created.
//              01-Dec-95   MarkBl  Split from util.cxx.
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\debug.hxx"
#include "..\inc\time.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   IsLeapYear
//
//  Synopsis:   Determines if a given year is a leap year.
//
//  Arguments:  [wYear]  - the year
//
//  Returns:    boolean value: TRUE == leap year
//
//  History:    05-05-93 EricB
//
//--------------------------------------------------------------------------
BOOL
IsLeapYear(WORD wYear)
{
    return wYear % 4 == 0 && wYear % 100 != 0 || wYear % 400 == 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   IsValidDate
//
//  Synopsis:   Checks for valid values.
//
//-----------------------------------------------------------------------------
BOOL
IsValidDate(WORD wMonth, WORD wDay, WORD wYear)
{
    if (wMonth < JOB_MIN_MONTH || wMonth > JOB_MAX_MONTH ||
                wDay < JOB_MIN_DAY)
    {
        return FALSE;
    }
    if (wMonth == JOB_MONTH_FEBRUARY && IsLeapYear(wYear))
    {
        if (wDay > (g_rgMonthDays[JOB_MONTH_FEBRUARY] + 1))
        {
            return FALSE;
        }
    }
    else
    {
        if (wDay > g_rgMonthDays[wMonth])
        {
            return FALSE;
        }
    }
    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   MonthDays
//
//  Synopsis:   Returns the number of days in the indicated month.
//
//  Arguments:  [wMonth] - Index of the month in question where January = 1
//                         through December equalling 12.
//              [yYear]  - If non-zero, then leap year adjustment for February
//                         will be applied.
//              [pwDays] - The place to return the number of days in the
//                         indicated month.
//
//  Returns:    S_OK or E_INVALIDARG
//
//  History:    10-29-93 EricB
//
//-----------------------------------------------------------------------------
HRESULT
MonthDays(WORD wMonth, WORD wYear, WORD *pwDays)
{
    if (wMonth < JOB_MIN_MONTH || wMonth > JOB_MAX_MONTH)
    {
        return E_INVALIDARG;
    }
    *pwDays = g_rgMonthDays[wMonth];
    //
    // If February, adjust for leap years
    //
    if (wMonth == 2 && wYear != 0)
    {
        if (IsLeapYear(wYear))
        {
            (*pwDays)++;
        }
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Function:   IncrementDay
//
//  Synopsis:   increases the SYSTEMTIME day value by one and corrects for
//              overflow
//
//  Arguments:  [pst] - the date to increment
//
//-----------------------------------------------------------------------------
void
IncrementDay(LPSYSTEMTIME pst)
{
    pst->wDay++;

    WORD wLastDay;
    HRESULT hr = MonthDays(pst->wMonth, pst->wYear, &wLastDay);
    if (FAILED(hr))
    {
        schAssert(!"Bad systemtime");
    }
    else
    {
        if (pst->wDay > wLastDay)
        {
            //
            // Wrap to the next month.
            //
            pst->wDay = 1;
            IncrementMonth(pst);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\dataobj.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       dataobj.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/17/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "jobidl.hxx"
#include <StrSafe.h>

extern "C" UINT g_cfJobIDList;
extern "C" UINT g_cfShellIDList;
extern "C" UINT g_cfPreferredDropEffect;

//____________________________________________________________________________
//
//  Class:      CObjFormats
//
//  Purpose:    Impements IEnumFORMATETC for job objects.
//____________________________________________________________________________


class CObjFormats : public IEnumFORMATETC
{
    friend HRESULT JFGetObjFormats(UINT cfmt, FORMATETC *afmt, LPVOID *ppvObj);

public:
    ~CObjFormats() { if (m_aFmt) delete [] m_aFmt; }

    //  IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    //  IEnumFORMATETC methods
    STDMETHODIMP Next(ULONG celt, FORMATETC *rgelt, ULONG *pceltFethed);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumFORMATETC ** ppenum);

private:
    CObjFormats(UINT cfmt, FORMATETC * afmt)
            : m_iFmt(0), m_cFmt(cfmt), m_aFmt(afmt), m_ulRefs(1) {}

    UINT            m_iFmt;
    UINT            m_cFmt;
    FORMATETC     * m_aFmt;
};


//____________________________________________________________________________
//
//  Members:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CObjFormats);

STDMETHODIMP
CObjFormats::QueryInterface(
   REFIID riid,
   LPVOID FAR* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IEnumFORMATETC, riid))
    {
        *ppvObj = (IUnknown*)(IEnumFORMATETC*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Members:     IEnumFORMATETC methods
//____________________________________________________________________________


STDMETHODIMP
CObjFormats::Next(
    ULONG celt,
    FORMATETC *rgelt,
    ULONG *pceltFethed)
{
    UINT    cfetch = 0;
    HRESULT hr = S_FALSE;

    if (m_iFmt < m_cFmt)
    {
        cfetch = m_cFmt - m_iFmt;

        if (cfetch >= celt)
        {
            cfetch = celt;
            hr = S_OK;
        }

        CopyMemory(rgelt, &m_aFmt[m_iFmt], cfetch * sizeof(FORMATETC));
        m_iFmt += cfetch;
    }

    if (pceltFethed)
    {
        *pceltFethed = cfetch;
    }

    return hr;
}


STDMETHODIMP
CObjFormats::Skip(
    ULONG celt)
{
    m_iFmt += celt;

    if (m_iFmt > m_cFmt)
    {
        m_iFmt = m_cFmt;
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP
CObjFormats::Reset()
{
    m_iFmt = 0;
    return S_OK;
}

STDMETHODIMP
CObjFormats::Clone(
    IEnumFORMATETC ** ppenum)
{
    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Function:     Function to obtain the IEnumFORMATETC interface for jobs.
//____________________________________________________________________________

HRESULT
JFGetObjFormats(
    UINT        cfmt,
    FORMATETC * afmt,
    LPVOID    * ppvObj)
{
    TRACE_FUNCTION(JFGetObjFormats);

    FORMATETC * pFmt = new FORMATETC[cfmt];

    if (pFmt == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CopyMemory(pFmt, afmt, cfmt * sizeof(FORMATETC));

    CObjFormats * pObjFormats = new CObjFormats(cfmt, pFmt);

    if (pObjFormats == NULL)
    {
        delete [] pFmt;
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObjFormats->QueryInterface(IID_IEnumFORMATETC, ppvObj);
    pObjFormats->Release();

    DEBUG_OUT((DEB_TRACE, "RETURNING CObjFormats<%x, %d>\n",
                                        pObjFormats, pObjFormats->m_ulRefs));
    return hr;
}



//____________________________________________________________________________
//____________________________________________________________________________
//________________                     _______________________________________
//________________  class CJobObject  _______________________________________
//________________                     _______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CJobObject : public IDataObject
{
public:

    CJobObject(
        LPCTSTR         pszFolderPath,
        LPITEMIDLIST    pidlFolder,
        UINT            cidl,
        LPITEMIDLIST   *apidl,
        BOOL            fCut);

    ~CJobObject()
    {
        ILA_Free(m_cidl, m_apidl);
        ILFree(m_pidlFolder);
        DEBUG_ASSERT(m_ulRefs == 0);
    }


    //  Iunknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHODIMP QueryGetData(FORMATETC *pformatetc);
    STDMETHODIMP GetCanonicalFormatEtc(FORMATETC *pformatectIn,
                                       FORMATETC *pformatetcOut);
    STDMETHODIMP SetData(FORMATETC *pformatetc, STGMEDIUM *pmedium,
                         BOOL fRelease);
    STDMETHODIMP EnumFormatEtc(DWORD dwDirection,
                               IEnumFORMATETC **ppenumFormatEtc);
    STDMETHODIMP DAdvise(FORMATETC *pformatetc, DWORD advf,
                         IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHODIMP DUnadvise(DWORD dwConnection);
    STDMETHODIMP EnumDAdvise(IEnumSTATDATA **ppenumAdvise);

private:
    LPCTSTR         m_pszFolderPath;
    LPITEMIDLIST    m_pidlFolder;
    UINT            m_cidl;
    LPITEMIDLIST  * m_apidl;

    BOOL            m_fCut;     // this is for a cut operation
};

inline
CJobObject::CJobObject(
    LPCTSTR         pszFolderPath,
    LPITEMIDLIST    pidlFolder,
    UINT            cidl,
    LPITEMIDLIST   *apidl,
    BOOL            fCut):
        m_cidl(cidl),
        m_pszFolderPath(pszFolderPath),
        m_pidlFolder(pidlFolder),
        m_apidl(apidl),
        m_ulRefs(1),
        m_fCut(fCut)
{
}

//____________________________________________________________________________
//
//  Members:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobObject);

STDMETHODIMP
CJobObject::QueryInterface(
   REFIID riid,
   LPVOID FAR* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IDataObject, riid))
    {
        *ppvObj = (IUnknown*)((IDataObject*)this);
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

//____________________________________________________________________________
//
//  Function:   DbgPrintFmt
//
//  Synopsis:   Function to print out the format name.
//____________________________________________________________________________

#if DBG==1
void
DbgPrintFmt(
    UINT  format)
{
#undef  DEB_USEREX
#define DEB_USEREX DEB_USER15

    TCHAR szFmtName[550];
    int cchFmtName = 550;

    if (format == g_cfJobIDList)
    {
        DEBUG_OUT((DEB_USEREX, "\t\t<Format=Job IDList Array>\n"));
        return;
    }
    else if (format == g_cfPreferredDropEffect)
    {
        DEBUG_OUT((DEB_USEREX, "\t\t<Format=Preferred DropEffect>\n"));
        return;
    }

    int iRet = GetClipboardFormatName(format, szFmtName, cchFmtName);

    if (iRet == 0)
        if (GetLastError() == 0)
            DEBUG_OUT((DEB_USEREX, "\t\t<Predefined format=%d>\n", format));
        else
            DEBUG_OUT((DEB_USEREX, "\t\t<Unknown Format=%d>\n", format));
    else
        DEBUG_OUT((DEB_USEREX, "\t\t<Format=%ws>\n", szFmtName));
}
#define DBG_PRINT_FMT(fmt) DbgPrintFmt(fmt)
#else
#define DBG_PRINT_FMT(fmt)
#endif

//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::GetData
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobObject::GetData(
    FORMATETC *pfmt,
    STGMEDIUM *pmedium)
{
    TRACE(CJobObject, GetData);
    DBG_PRINT_FMT(pfmt->cfFormat);

    Win4Assert(g_cfJobIDList != 0);

    if (pfmt->tymed & TYMED_HGLOBAL)
    {
        if (pfmt->cfFormat == CF_HDROP)
        {
            pmedium->hGlobal = HDROPFromJobIDList(m_pszFolderPath,
                                            m_cidl, (PJOBID *)m_apidl);
        }
        else if (pfmt->cfFormat == g_cfShellIDList)
        {
            pmedium->hGlobal = CreateIDListArray(m_pidlFolder,
                                                 m_cidl,
                                                 (PJOBID *)m_apidl);
        }
        else if (pfmt->cfFormat == g_cfJobIDList)
        {
            // Note Ole32's GetHGlobalFromILockBytes uses this

            pmedium->hGlobal = HJOBIDA_Create(m_cidl, (PJOBID *)m_apidl);
        }
        else if (pfmt->cfFormat == g_cfPreferredDropEffect)
        {
            DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));

            if (pdw)
            {
                *pdw = m_fCut ? DROPEFFECT_MOVE : DROPEFFECT_COPY;
                pmedium->hGlobal = (HGLOBAL)pdw;
            }
        }
        else
        {
            pmedium->tymed = TYMED_NULL;
            pmedium->hGlobal = NULL;
            pmedium->pUnkForRelease = NULL;

            return DATA_E_FORMATETC;
        }

        if (pmedium->hGlobal != NULL)
        {
            pmedium->tymed          = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;

            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return DV_E_TYMED;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::GetDataHere
//____________________________________________________________________________

STDMETHODIMP
CJobObject::GetDataHere(
    FORMATETC *pfmt,
    STGMEDIUM *pmedium)
{
    TRACE(CJobObject, GetDataHere);
    DBG_PRINT_FMT(pfmt->cfFormat);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::QueryGetData
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobObject::QueryGetData(
    FORMATETC *pfmt)
{
    TRACE(CJobObject, QueryGetData);
    DBG_PRINT_FMT(pfmt->cfFormat);

    //
    //  Check the aspects we support.
    //

    if (!(DVASPECT_CONTENT & pfmt->dwAspect))
    {
        return DATA_E_FORMATETC;
    }

    Win4Assert(g_cfJobIDList != 0);

    if (pfmt->cfFormat == CF_HDROP ||
        pfmt->cfFormat == g_cfJobIDList ||
        pfmt->cfFormat == g_cfShellIDList ||
        pfmt->cfFormat == g_cfPreferredDropEffect)
    {
        return S_OK;
    }

    return S_FALSE;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::GetCanonicalFormatEtc
//____________________________________________________________________________

STDMETHODIMP
CJobObject::GetCanonicalFormatEtc(
    FORMATETC *pfmtIn,
    FORMATETC *pfmtOut)
{
    TRACE(CJobObject, GetCanonicalFormatEtc);

    *pfmtOut = *pfmtIn;

    pfmtOut->ptd = NULL;

    return DATA_S_SAMEFORMATETC;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::SetData
//____________________________________________________________________________

STDMETHODIMP
CJobObject::SetData(
    FORMATETC *pfmt,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE(CJobObject, SetData);
    DBG_PRINT_FMT(pfmt->cfFormat);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::EnumFormatEtc
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE(CJobObject, EnumFormatEtc);

    if (dwDirection == DATADIR_SET)
    {
        return E_FAIL;
    }

    FORMATETC fmte[] = {
        {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(CLIPFORMAT)g_cfJobIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(CLIPFORMAT)g_cfShellIDList, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        {(CLIPFORMAT)g_cfPreferredDropEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    HRESULT hr = JFGetObjFormats(ARRAYLEN(fmte), fmte, (void**)ppenumFormatEtc);

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::DAdvise
//____________________________________________________________________________

STDMETHODIMP
CJobObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE(CJobObject, DAdvise);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::DUnadvise
//____________________________________________________________________________

STDMETHODIMP
CJobObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE(CJobObject, DUnadvise);

    return E_NOTIMPL;
}

//____________________________________________________________________________
//
//  Member:     CJobObject::IDataObject::EnumDAdvise
//____________________________________________________________________________

STDMETHODIMP
CJobObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE(CJobObject, EnumDAdvise);

    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Function:   JFGetDataObject
//
//  Synopsis:   Function to create a data object for jobs in the job folder.
//
//  Arguments:  [pszFolderPath] - full path to tasks folder
//              [pidlFolder]    - pidl to that folder, supplied by shell's
//                                 call to IPersistFolder::Initialize.
//              [cidl]          - number elements in array
//              [apidl]         - array of idls, each naming a .job object
//              [fCut]          - TRUE if this is created for cut operation
//              [ppvObj]        - filled with pointer to new data object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppvObj]
//
//  History:    01/31/1996   RaviR      Created
//              05-30-1997   DavidMun   Pass copy of [pidlFolder]
//
//---------------------------------------------------------------------------

HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj)
{
    TRACE_FUNCTION(JFGetDataObject);

    LPITEMIDLIST  * apidlTemp = ILA_Clone(cidl, apidl);

    if (NULL == apidlTemp)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    LPITEMIDLIST pidlFolderCopy = ILClone(pidlFolder);

    if (!pidlFolderCopy)
    {
        ILA_Free(cidl, apidlTemp);
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CJobObject * pJobObjects = new CJobObject(pszFolderPath,
                                              pidlFolderCopy,
                                              cidl,
                                              apidlTemp,
                                              fCut);
    if (pJobObjects == NULL)
    {
        ILA_Free(cidl, apidlTemp);

        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pJobObjects->QueryInterface(IID_IDataObject, ppvObj);

    pJobObjects->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\dllutil.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       dllutil.cxx
//
//  Contents:   DLL related stuff
//
//  Classes:
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <locale.h>

#include "dbg.h"
#include "macros.h"
#include "common.hxx"

//
//  Debug stuff
//

DECLARE_INFOLEVEL(Job);
DECLARE_HEAPCHECKING;

//
//  Clipboard formats
//

#define CFSTR_JOBIDLIST             TEXT("Job IDList Array")
#define CFSTR_PREFERREDDROPEFFECT   TEXT("Preferred DropEffect")

extern "C" UINT g_cfJobIDList = 0;
extern "C" UINT g_cfShellIDList = 0;
extern "C" UINT g_cfPreferredDropEffect = 0;

#if (DBG == 1)
extern BOOL fInfoLevelInit;
#endif // (DBG == 1)

BOOL
JFOnProcessAttach(void)
{
    //
    //  Init debugging stuff.
    //

    #if DBG == 1
    {
        InitializeDebugging();

        JobInfoLevel = DEB_ERROR | DEB_WARN;

        fInfoLevelInit = FALSE;
        CheckInit(JobInfoLevelString, &JobInfoLevel);
        //SetSmAssertLevel(ASSRT_BREAK | ASSRT_MESSAGE);
        SetSmAssertLevel(ASSRT_POPUP | ASSRT_MESSAGE);
    }
    #endif // DBG == 1

    TRACE_FUNCTION(JFOnProcessAttach);

    //
    // Get the clipboard formats used by the data object.
    //

    g_cfJobIDList = RegisterClipboardFormat(CFSTR_JOBIDLIST);

    g_cfShellIDList = RegisterClipboardFormat(CFSTR_SHELLIDLIST);

    g_cfPreferredDropEffect = RegisterClipboardFormat(
                                    CFSTR_PREFERREDDROPEFFECT);

    if ((g_cfJobIDList == 0)  ||
        (g_cfShellIDList == 0) ||
        (g_cfPreferredDropEffect == 0))
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    //
    // Get common controls
    //

    InitCommonControls();

    INITCOMMONCONTROLSEX icce;

    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_DATE_CLASSES;
    InitCommonControlsEx(&icce);

    //
    // Set the C runtime library locale, for string operations
    //

    setlocale(LC_CTYPE, "");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\guids.cxx ===
#include "..\pch\headers.hxx"
#pragma hdrstop

#include <initguid.h>

#include "guids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\enum.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       enum.cxx
//
//  Contents:   Implementation of IEnumIDList
//
//  Classes:
//
//  Functions:
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\common.hxx"
#include "..\inc\policy.hxx"

#include "dll.hxx"
#include "jobidl.hxx"
#include "util.hxx"
#include "bitflag.hxx"

#include <StrSafe.h>

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1

//
// Private flags
//

#define JE_LOCAL                0x0001
#define JE_ENUMERATED_TEMPLATE  0x0002

//____________________________________________________________________________
//
//  Class:      CJobsEnum
//
//  Purpose:    Enumerates jobs in a folder.
//
//  History:    1/25/1996   RaviR   Created
//____________________________________________________________________________

class CJobsEnum : public IEnumIDList,
                  public CBitFlag
{
public:
    CJobsEnum(ULONG uFlags, LPCTSTR pszFolderPath, IEnumWorkItems *pEnumJobs);
    ~CJobsEnum(void);

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IEnumIDList methods
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST* rgelt, ULONG* pceltFetched);
    STDMETHOD(Skip)(ULONG celt);
    STDMETHOD(Reset)(void);
    STDMETHOD(Clone)(IEnumIDList** ppenum);

private:
    ULONG            m_uShellFlags;   // SHCONTF flags passed in by shell 
    IEnumWorkItems * m_pEnumJobs;
    LPCTSTR          m_pszFolderPath;
    CDllRef          m_DllRef;
};



//____________________________________________________________________________
//
//  Member:     CJobsEnum::CJobsEnum, Constructor
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

inline
CJobsEnum::CJobsEnum(
    ULONG            uFlags,
    LPCTSTR          pszFolderPath,
    IEnumWorkItems * pEnumJobs)
        :
        m_ulRefs(1),
        m_uShellFlags(uFlags),
        m_pEnumJobs(pEnumJobs),
        m_pszFolderPath(pszFolderPath)
{
    TRACE(CJobsEnum, CJobsEnum);

    DEBUG_OUT((DEB_USER1, "FolderPath = %ws\n", pszFolderPath));

    if (IsLocalFilename(pszFolderPath))
    {
        _SetFlag(JE_LOCAL);
    }
    Win4Assert(m_pEnumJobs != NULL);

    m_pEnumJobs->AddRef();

    //
    // Policy - do not allow the template item if we are not
    // allowing job creation
    //  -- Later, we prevent this flag from being cleared
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK active - no template wizard\n"));
		
        //
        // This next flag means that we have ALREADY shown the template.
        // Setting it will force us never to enumerate it
        //

        _SetFlag(JE_ENUMERATED_TEMPLATE);
    }
	
}


//____________________________________________________________________________
//
//  Member:     CJobsEnum::~CJobsEnum, Destructor
//____________________________________________________________________________

inline
CJobsEnum::~CJobsEnum()
{
    TRACE(CJobsEnum, ~CJobsEnum);

    if (m_pEnumJobs != NULL)
    {
        m_pEnumJobs->Release();
    }

    // Note: No need to free m_pszFolderPath.
}

//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsEnum);


STDMETHODIMP
CJobsEnum::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IEnumIDList, riid))
    {
        *ppvObj = (IUnknown*)(IEnumIDList*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsEnum::IEnumIDList::Next
//
//  Arguments:  [celt] -- IN
//              [ppidlOut] -- IN
//              [pceltFetched] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//              2-12-1997   DavidMun   Handle NULL pceltFetched
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Next(
    ULONG celt,
    LPITEMIDLIST* ppidlOut,
    ULONG* pceltFetched)
{
    TRACE(CJobsEnum, Next);

    HRESULT hr = S_OK;
    CJobID   jid;

    if (!(m_uShellFlags & SHCONTF_NONFOLDERS))
    {
        return S_FALSE;
    }

    if (m_pEnumJobs == NULL)
    {
        return E_FAIL;
    }

    if (pceltFetched == NULL && celt != 1)
    {
        return E_INVALIDARG;
    }

    if (pceltFetched)
    {
        *pceltFetched = 0;
    }

    ULONG    curr = 0;
    LPWSTR * ppwszJob = NULL;
    ULONG    ulTemp;

    if (_IsFlagSet(JE_LOCAL) && 
        !_IsFlagSet(JE_ENUMERATED_TEMPLATE) &&
        celt)
    {
        jid.InitToTemplate();
        ppidlOut[curr] = ILClone((LPCITEMIDLIST)(&jid));

        if (!ppidlOut[curr])
        {
            return E_OUTOFMEMORY;
        }
        DEBUG_OUT((DEB_ITRACE, "Created template\n"));
        curr++;
        _SetFlag(JE_ENUMERATED_TEMPLATE);
    }

    while (curr < celt)
    {
        hr = m_pEnumJobs->Next(1, &ppwszJob, &ulTemp);

        CHECK_HRESULT(hr);

        if (FAILED(hr))
        {
            break;
        }
        else if (ulTemp == 0)
        {
            hr = S_FALSE;
            break;
        }

        LPTSTR pszJob = (LPTSTR)*ppwszJob;

        hr = jid.Load(m_pszFolderPath, pszJob);

        CoTaskMemFree(*ppwszJob);
        CoTaskMemFree(ppwszJob);

        if (S_OK == hr)
        {
            ppidlOut[curr] = ILClone((LPCITEMIDLIST)(&jid));

            if (NULL != ppidlOut[curr])
            {
                ++curr;
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (hr == E_OUTOFMEMORY)
        {
            break;
        }
    }

    if (curr > 0 && curr < celt)
    {
        hr = S_FALSE;
    }

    if (pceltFetched)
    {
        *pceltFetched = curr;
    }
    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsEnum::Skip
//
//  Arguments:  [celt] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Skip(
    ULONG celt)
{
    TRACE(CJobsEnum, Skip);

    if (!celt)
    {
        return E_INVALIDARG;
    }

    if (_IsFlagSet(JE_LOCAL) && !_IsFlagSet(JE_ENUMERATED_TEMPLATE))
    {
        celt--;
        _SetFlag(JE_ENUMERATED_TEMPLATE);

        if (!celt)
        {
            return S_OK;
        }
    }
    return m_pEnumJobs->Skip(celt);
}

//____________________________________________________________________________
//
//  Member:     CJobsEnum::Reset
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Reset(void)
{
    TRACE(CJobsEnum, Reset);
	
    //
    // Policy - don't clear flag if we are not allowing job creation
    //

    if (! RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK active - prevent template wiz\n"));
	
        //
        // Not clearing this flag maintains that we will have enumerated
        // the template on the next go around
        //

        _ClearFlag(JE_ENUMERATED_TEMPLATE);
    }
    return m_pEnumJobs->Reset();
}

//____________________________________________________________________________
//
//  Member:     CJobsEnum::Clone
//
//  Arguments:  [ppenum] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEnum::Clone(
    IEnumIDList** ppenum)
{
    TRACE(CJobsEnum, Clone);

    return E_FAIL;  // not supported
}


//____________________________________________________________________________
//
//  Function:   JFGetEnumIDList
//
//  Synopsis:   Function to create the object to enumearte the JobIDList
//
//  Arguments:  [uFlags] -- IN
//              [pszFolderPath] -- IN
//              [pEnumJobs] -- IN
//              [riid] -- IN
//              [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetEnumIDList(
    ULONG            uFlags,
    LPCTSTR          pszFolderPath,
    IEnumWorkItems * pEnumJobs,
    LPVOID    *      ppvObj)
{
    CJobsEnum * pEnum = new CJobsEnum(uFlags, pszFolderPath, pEnumJobs);

    if (NULL == pEnum)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    pEnumJobs->Reset();

    HRESULT hr = pEnum->QueryInterface(IID_IEnumIDList, ppvObj);

    pEnum->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\dbg.h ===
#ifndef __DBG_HXX__
#define __DBG_HXX__


#define DEBUG_OUT(x)
#define DECLARE_HEAPCHECKING
#define DEBUGCHECK
#define TRACE(ClassName,MethodName)
#define TRACE_FUNCTION(FunctionName)
#define CHECK_HRESULT(hr)
#define CHECK_LASTERROR(lr)
#define VERIFY(x)   x
#define DEBUG_OUT_LASTERROR
#define DEBUG_ASSERT(e)

#if DBG==1

DECLARE_DEBUG(Job)

#undef  DEBUG_OUT
#define DEBUG_OUT(x) JobInlineDebugOut x

extern DWORD dwHeapChecking;
#undef  DECLARE_HEAPCHECKING
#define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

#undef  DEBUGCHECK
#define DEBUGCHECK \
    if ( (dwHeapChecking & 0x1) == 0x1 ) \
        HeapValidate(GetProcessHeap(),0,NULL)

#undef  TRACE
#define TRACE(ClassName,MethodName) \
    DEBUGCHECK; \
    DEBUG_OUT((DEB_TRACE, #ClassName"::"#MethodName"(%x)\n", this));

#undef  TRACE_FUNCTION
#define TRACE_FUNCTION(FunctionName) \
    DEBUGCHECK; \
    DEBUG_OUT((DEB_TRACE, #FunctionName"\n"));

#undef  CHECK_HRESULT
#define CHECK_HRESULT(hr) \
    if ( FAILED(hr) ) \
    { \
        DEBUG_OUT((DEB_ERROR, \
            "**** ERROR RETURN <%s @line %d> -> %08lx\n", \
            __FILE__, \
            __LINE__, \
            hr)); \
    }

#undef  CHECK_LASTERROR
#define CHECK_LASTERROR(lr) \
    if ( lr != ERROR_SUCCESS ) \
    { \
        DEBUG_OUT((DEB_ERROR, \
            "**** ERROR RETURN <%s @line %d> -> %dL\n", \
            __FILE__, \
            __LINE__, \
            lr)); \
    }

#undef  VERIFY
#define VERIFY(x)   Win4Assert(x)

#undef  DEBUG_OUT_LASTERROR
#define DEBUG_OUT_LASTERROR \
    DEBUG_OUT((DEB_ERROR, \
        "**** ERROR RETURN <%s @line %d> -> %dL\n", \
        __FILE__, \
        __LINE__, \
        GetLastError()));

#undef  DEBUG_ASSERT
#define DEBUG_ASSERT(e) \
    if ((e) == FALSE) \
    { \
        DEBUG_OUT((DEB_ERROR, \
            "**** ASSERTION <%s> FAILED <%s @line %d>\n", \
            #e, \
            __FILE__, \
            __LINE__)); \
    }

#endif // DBG==1

#endif // __DBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\guids.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       guids.h
//
//  Contents:   All GUIDs
//
//  History:    Jan-05-96    RaviR     Created
//
//----------------------------------------------------------------------------

// {d6277990-4c6a-11cf-8d87-00aa0060f5bf}
DEFINE_GUID(CLSID_CJobFolder, 0xd6277990, 0x4c6a, 0x11cf, 0x8d, 0x87, 0x00,0xaa,0x00,0x60,0xf5,0xbf);

// {797F1E90-9EDD-11cf-8D8E-00AA0060F5BF}
DEFINE_GUID(CLSID_CSchedObjExt, 0x797f1e90, 0x9edd, 0x11cf, 0x8d, 0x8e, 0x0, 0xaa, 0x0, 0x60, 0xf5, 0xbf);

// {DD2110F0-9EEF-11cf-8D8E-00AA0060F5BF}
DEFINE_GUID(CLSID_CTaskIconExt, 0xdd2110f0, 0x9eef, 0x11cf, 0x8d, 0x8e, 0x0, 0xaa, 0x0, 0x60, 0xf5, 0xbf);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\hsort.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       HSort.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    5/3/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "macros.h"
#include "jobidl.hxx"
#include <strSafe.h>

void PercolateUp(PJOBID *ppjid, UINT iMaxLevel);
void PercolateDown(PJOBID *ppjid, UINT iMaxLevel);

//
// HeapSort:  HeapSort (also called TreeSort) works by calling
// PercolateUp and PercolateDown. PercolateUp organizes the elements
// into a "heap" or "tree," which has the properties shown below:
//
//                            element[1]
//                          /            \
//               element[2]                element[3]
//              /          \              /          \
//        element[4]     element[5]   element[6]    element[7]
//        /        \     /        \   /        \    /        \
//       ...      ...   ...      ... ...      ...  ...      ...
//
//
//  Each "parent node" is greater than each of its "child nodes"; for
//  example, element[1] is greater than element[2] or element[3];
//  element[2] is greater than element[4] or element[5], and so forth.
//  Therefore, once the first loop in HeapSort is finished, the
//  largest element is in element[1].
//
//  The second loop rebuilds the heap (with PercolateDown), but starts
//  at the top and works down, moving the largest elements to the bottom.
//  This has the effect of moving the smallest elements to the top and
//  sorting the heap.
//

void hsort(PJOBID *ppjid, UINT cObjs)
{
    //
    // First build a "heap" with the largest element at the top
    //

    for (UINT i = 1; i < cObjs; i++)
    {
        PercolateUp(ppjid, i);
    }

    //
    //  The next loop rebuilds the heap (with PercolateDown), but starts
    //  at the top and works down, moving the largest elements to the bottom.
    //  This has the effect of moving the smallest elements to the top and
    //  sorting the heap.
    //

    PJOBID pjid;

    for (i = cObjs - 1; i > 0; i--)
    {
        // Swap ppjid[0] & ppjid[i]
        pjid = ppjid[0];
        ppjid[0] = ppjid[i];
        ppjid[i] = pjid;

        PercolateDown(ppjid, i - 1);
    }
}

inline int CompareJobIDs(PJOBID pjid1, PJOBID pjid2)
{
    return lstrcmpi(pjid1->GetName(), pjid2->GetName());
}


// PercolateUp: Converts elements into a "heap" with the largest
// element at the top (see the diagram above).

void PercolateUp(PJOBID *ppjid, UINT iMaxLevel)
{
    UINT    i = iMaxLevel;
    UINT    iParent;
    PJOBID  pjid;

    // Move the value in ppjid[iMaxLevel] up the heap until it has
    // reached its proper node (that is, until it is greater than either
    // of its child nodes, or until it has reached 1, the top of the heap).

    while (i)
    {
        iParent = i / 2;    // Get the subscript for the parent node

        if (CompareJobIDs(ppjid[i], ppjid[iParent]) > 0)
        {
            // The value at the current node is bigger than the value at
            // its parent node, so swap these two array elements.

            // Swap ppjid[iParent], ppjid[i]
            pjid = ppjid[iParent];
            ppjid[iParent] = ppjid[i];
            ppjid[i] = pjid;


            i = iParent;
        }
        else
        {
            // Otherwise, the element has reached its proper place in the
            // heap, so exit this procedure.

            break;
        }
    }
}


// PercolateDown: Converts elements to a "heap" with the largest elements
// at the bottom. When this is done to a reversed heap (largest elements
// at top), it has the effect of sorting the elements.
//
void PercolateDown(PJOBID *ppjid, UINT iMaxLevel)
{
    UINT    iChild;
    UINT    i = 0;
    PJOBID  pjid;

    // Move the value in ppjid[0] down the heap until it has reached
    // its proper node (that is, until it is less than its parent node
    // or until it has reached iMaxLevel, the bottom of the current heap).

    while (1)
    {
        // Get the subscript for the child node.
        iChild = 2 * i;

        // Reached the bottom of the heap, so exit this procedure.
        if (iChild > iMaxLevel)
        {
            break;
        }

        // If there are two child nodes, find out which one is bigger.
        if (iChild + 1 <= iMaxLevel)
        {
            if (CompareJobIDs(ppjid[iChild + 1], ppjid[iChild]) > 0)
            {
                iChild++;
            }
        }

        if (CompareJobIDs(ppjid[i], ppjid[iChild]) < 0)
        {
            // Move the value down since it is still not bigger than
            // either one of its children.

            // Swaps ppjid[i], ppjid[iChild]
            pjid = ppjid[iChild];
            ppjid[iChild] = ppjid[i];
            ppjid[i] = pjid;


            i = iChild;
        }
        else
        {
            // Otherwise, ppjid has been restored to a heap from 1 to
            // iMaxLevel, so exit.

            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\jobfldr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       jobfldr.cxx
//
//  Contents:   Implementation of COM object CJobFolder
//
//  Classes:    CJobFolder
//
//  History:    1/4/1996   RaviR   Created
//              1-23-1997   DavidMun   Add m_hwndNotify
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"
#include "resource.h"

#include "sch_cls.hxx"  // sched\inc
#include "job_cls.hxx"  // sched\inc
#include "misc.hxx"     // sched\inc
#include "policy.hxx"   // sched\inc

#include "jobidl.hxx"
#include "jobfldr.hxx"
#include "common.hxx"
#include "guids.h"
#include "util.hxx"

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

HRESULT
PromptForServiceStart(
    HWND hwnd);

BOOL
IsMsNetwork( LPTSTR ptszMachine );


//____________________________________________________________________________
//
//  Member:     CJobFolder::~CJobFolder, Destructor
//____________________________________________________________________________

CJobFolder::~CJobFolder()
{
    TRACE(CJobFolder, ~CJobFolder);

    if (m_uRegister)
    {
        DEBUG_OUT((DEB_ERROR,
                   "CJobFolder::~CJobFolder: m_uRegister = %uL but should be 0\n",
                   m_uRegister));
        SHChangeNotifyDeregister(m_uRegister);
        m_uRegister = 0;
        CDll::LockServer(FALSE);
    }

    if (m_hwndNotify)
    {
        DEBUG_OUT((DEB_ERROR,
                   "CJobFolder::~CJobFolder: m_hwndNotify = 0x%x but should be NULL\n",
                   m_hwndNotify));

        BOOL fOk = DestroyWindow(m_hwndNotify);

        if (!fOk)
        {
            DEBUG_OUT_LASTERROR;
        }
    }

    delete m_pszMachine;

    if (m_pUpdateDirData)
    {
        GlobalFree(m_pUpdateDirData);
    }

    if (m_pidlFldr)
    {
        ILFree(m_pidlFldr);
    }

    //  No need to Release m_pShellView since we never addrefed it.
    //  See CreateViewObject in sfolder.cxx for more info.

    if (m_pScheduler != NULL)
    {
        DEBUG_OUT((DEB_USER1, "m_pScheduler->Release\n"));
        m_pScheduler->Release();
    }

    OleUninitialize();
}




HRESULT
CJobFolder::_AddObject(
    PJOBID pjid,
    LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;
    INT_PTR iRet = -1;

    LPITEMIDLIST pidl = ILClone((LPCITEMIDLIST)pjid);

    if (pidl == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

#if (DBG == 1)
    ((PJOBID) pidl)->Validate();
#endif // (DBG == 1)

    iRet = ShellFolderView_AddObject(m_hwndOwner, pidl);

    if (iRet < 0)
    {
        ILFree(pidl);
        pidl = NULL;

        hr = E_FAIL;
        CHECK_HRESULT(hr);
    }

    if (ppidl)
    {
        *ppidl = pidl;
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::_UpdateObject
//
//  Synopsis:   Notify the shell defview that the object with pidl [pjidOld]
//              has been updated and now should look like pidl [pjidNew].
//
//  Arguments:  [pjidOld] - pidl of object as it appears in defview
//              [pjidNew] - pidl of object as it should now appear
//              [ppidl]   - filled with pidl of updated object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppidl]
//
//  History:    7-07-1999   davidmun   Commented
//
//  Notes:      Do not free returned pidl in *[ppidl].
//
//---------------------------------------------------------------------------

HRESULT
CJobFolder::_UpdateObject(
    PJOBID pjidOld,
    PJOBID pjidNew,
    LPITEMIDLIST *ppidl)
{
    TRACE(CJobFolder, _UpdateObject);

    HRESULT hr = S_OK;
    INT_PTR iRet = -1;

#if (DBG == 1)
    DEBUG_OUT((DEB_TRACE,
               "CJobFolder::_UpdateObject Validating pjidNew %x\n",
               pjidNew));
    pjidNew->Validate();
#endif // (DBG == 1)

    LPITEMIDLIST pidlCopyOfNew = ILClone((LPCITEMIDLIST)pjidNew);

    if (pidlCopyOfNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

#if (DBG == 1)
    DEBUG_OUT((DEB_TRACE,
               "CJobFolder::_UpdateObject Validating pidlCopyOfNew %x\n",
               pidlCopyOfNew));
    ((PJOBID) pidlCopyOfNew)->Validate();

    DEBUG_OUT((DEB_TRACE,
               "CJobFolder::_UpdateObject Validating pjidOld %x\n",
               pjidOld));
    pjidOld->Validate();
#endif // (DBG == 1)

    LPITEMIDLIST apidl[2] = {(LPITEMIDLIST)pjidOld, pidlCopyOfNew};

    iRet = ShellFolderView_UpdateObject(m_hwndOwner, apidl);

    if (iRet < 0)
    {
        //
        // The object to update couldn't be found, so the shell won't
        // take ownership of the new object, and we have to free it now.
        //

        ILFree(pidlCopyOfNew);
        pidlCopyOfNew = NULL;
    }

    if (ppidl)
    {
        *ppidl = (LPITEMIDLIST)ShellFolderView_GetObject(m_hwndOwner, iRet);
#if (DBG == 1)
        if (*ppidl)
        {
            DEBUG_OUT((DEB_TRACE,
                       "CJobFolder::_UpdateObject Validating *ppidl %x\n",
                       *ppidl));
            ((PJOBID) *ppidl)->Validate();
        }
        else
        {
            DEBUG_OUT((DEB_TRACE, "CJobFolder::_UpdateObject *ppidl is NULL\n"));
        }
#endif // (DBG == 1)
    }

    DEBUG_OUT((DEB_TRACE, "<CJobFolder::_UpdateObject\n"));
    return hr;
}



//____________________________________________________________________________
//
//  Function:   JFGetJobFolder
//
//  Synopsis:   Create an instance of CJobFolder and return the requested
//              interface.
//
//  Arguments:  [riid] -- IN interface needed.
//              [ppvObj] -- OUT place to store the interface.
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetJobFolder(
    REFIID riid,
    LPVOID* ppvObj)
{
    CJobFolder * pJobFolder = NULL;

    HRESULT hr = CJobFolder::Create(&pJobFolder);

    if (SUCCEEDED(hr))
    {
        hr = pJobFolder->QueryInterface(riid, ppvObj);

        pJobFolder->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::Create
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::Create(
    CJobFolder ** ppJobFolder)
{
    TRACE_FUNCTION(CJobFolder::Create);

    HRESULT hr = OleInitialize(NULL);

    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        CJobFolder *pJobFolder;

        pJobFolder = new CJobFolder();

        if (pJobFolder != NULL)
        {
            *ppJobFolder = pJobFolder;
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);

            OleUninitialize();
        }
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::IUnknown methods
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________


IMPLEMENT_STANDARD_IUNKNOWN(CJobFolder);


STDMETHODIMP
CJobFolder::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    LPUNKNOWN punk = NULL;

    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IShellFolder, riid))
    {
        punk = (IUnknown*) (IShellFolder*) this;
    }
    else if (IsEqualIID(IID_IShellFolder2, riid))
    {
        punk = (IUnknown*)(IShellFolder2*) this;
    }    
    else if (IsEqualIID(IID_IPersistFolder, riid))
    {
        punk = (IUnknown*) (IPersistFolder*) this;
    }
#if (_WIN32_IE >= 0x0400)
    else if (IsEqualIID(IID_IPersistFolder2, riid))
    {
        punk = (IUnknown*) (IPersistFolder2*) this;
    }
#endif (_WIN32_IE >= 0x0400)
    else if (IsEqualIID(IID_IDropTarget, riid))
    {
        punk = (IUnknown*) (IDropTarget*) this;
    }
    else if (IsEqualIID(IID_IRemoteComputer, riid))
    {
        punk = (IUnknown*) (IRemoteComputer*) this;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    *ppvObj = punk;
    punk->AddRef();

    return S_OK;
}




//____________________________________________________________________________
//
//  Member:     CJobFolder::IRemoteComputer::Initialize
//
//  Synopsis:   This method is called when the explorer is initializing or
//              enumerating the name space extension. If failure is returned
//              during enumeration, the extension won't appear for this
//              computer. Otherwise, the extension will appear, and should
//              target the given machine.
//
//  Arguments:  [pwszMachine]  -- IN Specifies the name of the machine to target.
//              [bEnumerating] -- IN
//
//  Returns:    HRESULT.
//
//  History:    2/21/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::Initialize(
    LPCWSTR  pwszMachine,
    BOOL    bEnumerating)
{
    DEBUG_OUT((DEB_USER12,
               "CJobFolder::IRemoteComputer::Initialize<%ws>\n",
               pwszMachine));

    HRESULT hr = S_OK;
    LPTSTR ptszMachine = NULL;

    do
    {
        if (!pwszMachine)
        {
            hr = E_INVALIDARG;
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Make a copy of the machine name.
        //
        ptszMachine = NewDupString(pwszMachine);
        if (!ptszMachine)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

	//
	// The first thing about showing a remote folder is it must be
	// a MS network or else the RegConnectregistry time out will 
	// take at least 20 seconds and there won't even be a MSTask
	// on the machine.

        if( !IsMsNetwork( ptszMachine ) )
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
            break;
        }

        //
        // We only want to show the remote jobs folder if the user has
        // administrative access to that machine, and the task scheduler
        // is installed there.
        //
        // Test both at once by trying to get a full access handle to
        // the remote machine's task scheduler reg key.
        //

        if (bEnumerating)
        {
            //
            // Check if the schedule service is registered on pwszMachine.
            //

            long    lr = ERROR_SUCCESS;
            HKEY    hRemoteKey = NULL;
            HKEY    hSchedKey = NULL;

            lr = RegConnectRegistry(ptszMachine,
                                    HKEY_LOCAL_MACHINE,
                                    &hRemoteKey);
            CHECK_LASTERROR(lr);

            if (lr == ERROR_SUCCESS)
            {
                lr = RegOpenKeyEx(hRemoteKey,
                                  SCH_AGENT_KEY,
                                  0,
                                  KEY_READ,
                                  &hSchedKey);
                CHECK_LASTERROR(lr);

                if (hRemoteKey != NULL)
                {
                    RegCloseKey(hRemoteKey);
                }

                if (lr == ERROR_SUCCESS)
                {
                    if (hSchedKey != NULL)
                    {
                        RegCloseKey(hSchedKey);
                    }
                }
                else
                {
                    hr = HRESULT_FROM_WIN32(lr);
                    break;
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(lr);
                break;
            }
        }

        //
        // Success; remember the machine name.
        //

        m_pszMachine = ptszMachine;
    } while (0);

    if (FAILED(hr))
    {
        delete [] ptszMachine;
    }

    return hr;
}

//____________________________________________________________________________
//
//
//	Support function:	MsNetwork
//
//	Synopsis:			Resolves whether or not we're attempting to connect to
//						a MS network
//
//	History:			11/12/00	DGrube	Created
//
//
//____________________________________________________________________________

BOOL IsMsNetwork( LPTSTR ptszMachine )
{
    DWORD          dwError;
    NETRESOURCE    nr;
    NETRESOURCE    nrOut;
    LPTSTR         pszSystem = NULL;          // pointer to variable-length strings
    NETRESOURCE*   lpBuffer = &nrOut;        // buffer
    DWORD          cbResult  = sizeof(nrOut); // buffer size
	BOOL		   bReturn = TRUE;

    //
    // Fill a block of memory with zeroes; then 
    //  initialize the NETRESOURCE structure. 
    //
    SecureZeroMemory(&nr, sizeof(nr));

    nr.dwScope       = RESOURCE_GLOBALNET;
    nr.dwType        = RESOURCETYPE_ANY;
    nr.lpRemoteName  = ptszMachine;

    //
    // First call the WNetGetResourceInformation function with 
    //  memory allocated to hold only a NETRESOURCE structure. This 
    //  method can succeed if all the NETRESOURCE pointers are NULL.
    //
    dwError = WNetGetResourceInformation(&nr, lpBuffer, &cbResult, &pszSystem);

    //
    // If the call fails because the buffer is too small, 
    //   call the LocalAlloc function to allocate a larger buffer.
    //
    if (dwError == ERROR_MORE_DATA)
    {
        lpBuffer = (NETRESOURCE*) LocalAlloc(LMEM_FIXED, cbResult);

        if (lpBuffer == NULL)
        {
			CHECK_LASTERROR(GetLastError());
			return FALSE;
        }
    }


    //
    // Call WNetGetResourceInformation again
    //  with the larger buffer.
    //

    dwError = WNetGetResourceInformation(&nr, lpBuffer, &cbResult, &pszSystem);

    if (dwError == NO_ERROR)
    {
        // If the call succeeds, process the contents of the 
        //  returned NETRESOURCE structure and the variable-length
        //  strings in lpBuffer. Then free the memory.
        //
        if ( NULL != lpBuffer->lpProvider )
        {
			NETINFOSTRUCT NetInfo;

			NetInfo.cbStructure = sizeof( NetInfo );
			DWORD dwReturn = WNetGetNetworkInformation( lpBuffer->lpProvider, &NetInfo );

			//
			// Need to shift 16 bits for masks below because their a DWORD starting at the
			// 16th bit and wNetType is a word starting at 0
			//
			if ( !( ( NetInfo.wNetType == ( WNNC_NET_MSNET >> 16)) || 
				( NetInfo.wNetType == ( WNNC_NET_LANMAN >>16) ) ) )
			{
				bReturn = FALSE;
			}
	    }
		else
		{
			CHECK_LASTERROR(GetLastError());
			bReturn = FALSE;
		}
    }
	else
	{
		CHECK_LASTERROR(GetLastError());
		bReturn = FALSE;
	}

	if ((NULL != lpBuffer ) && 
        (&nrOut != lpBuffer)) // let's not free a stack variable, eh?
	{
		LocalFree( lpBuffer );
	}

    return bReturn;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::IPersistFolder::Initialize
//
//  Synopsis:   same as IPersistFolder::Initialize
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::Initialize(
    LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    
    TRACE(CJobFolder, IPersistFolder::Initialize);

    m_pidlFldr = ILClone(pidl);

    if (NULL == m_pidlFldr)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    // determine whether we're local or remote
    // for a remote case, the path is always prepended with
    // "\\machinename" 
    WCHAR folderPath[MAX_PATH +1];

    // if IRemoteComputer::Initialize hasn't been called yet, we'll init now
    // we might have \\machinename\c:\windows\tasks
    // or we might have \\machinename::{ugly guid looking thingie}
    if ((m_pszMachine == NULL) && SHGetPathFromIDList(pidl, folderPath) && (0 == wcsncmp(L"\\\\", folderPath,2)))
    {
        WCHAR* p = NULL;
        if (p = wcspbrk(&folderPath[2], L"\\:"))
        {
            *p = L'\0';
            hr = Initialize(folderPath, TRUE);
        }
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::GetClassID
//
//  Synopsis:   same as IPersistFolder::GetClassID
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetClassID(
    LPCLSID lpClassID)
{
    TRACE(CJobFolder, GetClassID);

    *lpClassID = CLSID_CJobFolder;

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::IPersistFolder2::GetCurFolder
//
//  Synopsis:   Return a copy of the item id list for the current folder.
//
//  Arguments:  [ppidl] - filled with copy of pidl, or NULL on error.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppidl]
//
//  History:    12-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CJobFolder::GetCurFolder(
    LPITEMIDLIST *ppidl)
{
    TRACE(CJobFolder, GetCurFolder);

    *ppidl = ILClone(m_pidlFldr);

    if (NULL == *ppidl)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);

        return E_OUTOFMEMORY;
    }

    // NOTE: if this is being invoked remotely, we assume that IRemoteComputer
    // is invoked *before* IPersistFolder2.

    return S_OK;
}


//____________________________________________________________________________
//____________________________________________________________________________
//________________                         ___________________________________
//________________  Interface IDropTarget  ___________________________________
//________________                         ___________________________________
//____________________________________________________________________________
//____________________________________________________________________________

//____________________________________________________________________________
//
//  Member:     CJobFolder::DragEnter
//
//  Synopsis:   same as IDropTarget::DragEnter
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::DragEnter(
    LPDATAOBJECT pdtobj,
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect)
{
    DEBUG_OUT((DEB_TRACE, "CJobFolder::DragEnter<%x, dwEffect=%x>\n",
                                                        this, *pdwEffect));
    m_grfKeyStateLast = grfKeyState;

    *pdwEffect = DROPEFFECT_NONE;

    //
    // Policy - if key TS_KEYPOLICY_DENY_DRAGDROP or DENY_CREATE_TASK
    // then we won't allow this
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP) ||
        RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK or DRAGDROP active - no copy operations\n"));

        return S_OK;
    }

    if (pdtobj != NULL)
    {
        LPENUMFORMATETC penum;
        HRESULT         hr;

        pdtobj->AddRef();

        hr = pdtobj->EnumFormatEtc(DATADIR_GET, &penum);

        if (SUCCEEDED(hr))
        {
            FORMATETC fmte;
            ULONG     celt;

            while (penum->Next(1, &fmte, &celt) == S_OK)
            {
                if (fmte.cfFormat == CF_HDROP && (fmte.tymed & TYMED_HGLOBAL))
                {
                    // The default action is to MOVE the object. If the user
                    // has the CONTROL key pressed, then the operation
                    // becomes a copy

                    *pdwEffect = DROPEFFECT_MOVE;

                    if (grfKeyState & MK_CONTROL)
                    {
                        *pdwEffect = DROPEFFECT_COPY;
                    }

                    break;
                }
            }

            penum->Release();
        }

        pdtobj->Release();
    }

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::DragOver
//
//  Synopsis:   same as IDropTarget::DragOver
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::DragOver(
    DWORD grfKeyState,
    POINTL pt,
    DWORD *pdwEffect)
{
    DEBUG_OUT((DEB_TRACE, "CJobFolder::DragOver<%x, dwEffect=%d>\n",
                                                        this, *pdwEffect));


    *pdwEffect = DROPEFFECT_NONE;

    //
    // Policy - if we cannot create a task, or have no drag-drop, deny
    // the request
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP) ||
        RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK or DRAGDROP active - no copy operations\n"));

        return S_OK;
    }

    *pdwEffect = DROPEFFECT_MOVE;

    if (grfKeyState & MK_CONTROL)
    {
        *pdwEffect = DROPEFFECT_COPY;
    }

    return S_OK;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::DragLeave
//
//  Synopsis:   same as IDropTarget::DragLeave
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::DragLeave(void)
{
    TRACE(CJobFolder, DragLeave);

    return S_OK;    // Don't need to do anything here...
}



//____________________________________________________________________________
//
//  Member:     CJobFolder::CopyToFolder
//
//  Synopsis:   Performs copy of a job obect passed in to this folder
//
//  Notes:      If policy prevents a copy into this folder, this will
//              return E_FAIL.  Callers should check this if necessary.
//
//  History:    1/31/1996   RaviR     Created
//              4/23/1998   CameronE  Modified for policy
//____________________________________________________________________________

HRESULT
CJobFolder::CopyToFolder(
    LPDATAOBJECT    pdtobj,
    BOOL            fMove,
    BOOL            fDragDrop,  // TRUE if called as a result of a dd op.
    POINTL        * pPtl)        // Valid for a dd op.
{
    DEBUG_OUT((DEB_USER12, "CJobFolder::CopyToFolder <<----\n"));

    //
    // Policy - no copying into the folder if DENY_CREATE_TASK is on
    //        - no copying via dragdrop, either, if DENY_DRAGDROP is on
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK) ||
        (fDragDrop && RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP)))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK or DRAGDROP active - no copy operations\n"));
        return E_FAIL;
    }

    BOOL fIsDropOnSrc = ShellFolderView_IsDropOnSource(m_hwndOwner,
                                                       (IDropTarget*)this);

    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    HRESULT hr = pdtobj->GetData(&fmte, &medium);

    if (FAILED(hr))
    {
        return hr;
    }

    HDROP   hdrop = (HDROP)medium.hGlobal;
    UINT    cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);
    BYTE  * rglen = NULL;
    LPTSTR  pFrom = NULL;
    UINT    i;
    BOOL    fCreatedJob = FALSE;

    do
    {
        TCHAR   szFileFrom[MAX_PATH+1];
        UINT    cchFileFrom = ARRAYSIZE(szFileFrom);
        BOOL    fHasASchedObj = fIsDropOnSrc;

        if (fHasASchedObj == FALSE)
        {
            for (i = 0; i < cFiles; i++)
            {
                DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

                if (IsAScheduleObject(szFileFrom) == TRUE)
                {
                    fHasASchedObj = TRUE;
                    break;
                }
            }
        }

        if ((fDragDrop == TRUE) &&
            (m_grfKeyStateLast & MK_RBUTTON) &&
            (fHasASchedObj == TRUE))
        {
            if (_PopupRBMoveCtx(pPtl->x, pPtl->y, &fMove) == FALSE)
            {
                hr = S_FALSE;
                break;
            }
        }

        if ((fIsDropOnSrc == TRUE) && (fMove == TRUE))
        {
            // We don't handle positioning in the jobs folder.
            hr = S_FALSE;
            break;
        }

        //
        //  Prepare to copy jobs.
        //

        if (fHasASchedObj == TRUE)
        {
            rglen = new BYTE[cFiles];

            if (rglen == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }

            SecureZeroMemory(rglen, cFiles * sizeof(BYTE));
        }

        UINT cchReqd = 1; // for an extra null char

        for (i = 0; i < cFiles; i++)
        {
            DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

            if ((fIsDropOnSrc == FALSE) &&
                (IsAScheduleObject(szFileFrom) == FALSE))
            {
                hr = CreateAJobForApp(szFileFrom);
                CHECK_HRESULT(hr);

                if (SUCCEEDED(hr))
                {
                    fCreatedJob = TRUE;
                }

                // continue even if an error occurs
                continue;
            }

            if (fHasASchedObj == TRUE)
            {
                rglen[i] = lstrlen(szFileFrom) + 1;
                cchReqd += rglen[i];
            }
        }

        hr = S_OK; // reset CreateAJobForApp might have failed

        if (fHasASchedObj == FALSE)
        {
            break;
        }

        pFrom = new TCHAR[cchReqd];

        if (pFrom == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        LPTSTR pszTemp = pFrom;

        for (i = 0; i < cFiles; i++)
        {
            if (rglen[i])
            {
                DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

                CopyMemory(pszTemp, szFileFrom, rglen[i] * sizeof(TCHAR));

                pszTemp += rglen[i];
            }
        }

        // add extra null char
        *pszTemp = TEXT('\0');

        SHFILEOPSTRUCT fo = {m_hwndOwner, (fMove ? FO_MOVE : FO_COPY),
                pFrom, m_pszFolderPath,
                FOF_ALLOWUNDO | (fIsDropOnSrc ? FOF_RENAMEONCOLLISION : 0),
                FALSE, NULL, NULL};

        if (SHFileOperation(&fo) || fo.fAnyOperationsAborted)
        {
            hr = E_FAIL;
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }

        fCreatedJob = TRUE;

        //
        //  If the drop was on the job folder shortcut, there is nothing
        //  else to do here.
        //

        if (m_hwndOwner == NULL || m_pShellView == NULL)
        {
            break;
        }

        //
        // If fIsDropOnSource then this was a copy operation from the source
        // (if it was a move operation we would've already returned), the
        // SHFileOperation has done the rename work for us and will
        // create the files.
        //
        // That will produce a SHCNE_CREATE message for each dropped renamed &
        // copied file.  CJobFolder::HandleFsNotify will then do an _AddObject
        // to put them in the UI.
        //
        // So in this case we need to leave before adding a bogus copy
        // ourselves.
        //

        if (fIsDropOnSrc == TRUE)
        {
            break;
        }

        //
        //  Add these items to the foldr & select them.
        //

        LPITEMIDLIST pidl;
        CJobID jid;

        // First deselect any selected items

        LPITEMIDLIST * ppidl;

        hr = (HRESULT)ShellFolderView_GetSelectedObjects(m_hwndOwner, &ppidl);

        if (SUCCEEDED(hr))
        {
            i = ShortFromResult(hr);

            while (i--)
            {
                m_pShellView->SelectItem(ppidl[i], SVSI_DESELECT);
            }

            LocalFree(ppidl);
        }


        for (i = 0; i < cFiles; i++)
        {
            if (rglen[i])
            {
                DragQueryFile(hdrop, i, szFileFrom, cchFileFrom);

                LPTSTR pszName = PathFindFileName(szFileFrom);

                //
                // If a move or copy operation includes objects which collide
                // with objects already in the folder, we need to avoid
                // creating a bogus duplicate in the UI for those objects.
                //

                if (_ObjectAlreadyPresent(pszName))
                {
                    continue;
                }

                hr = jid.Load(m_pszFolderPath, pszName);

                BREAK_ON_FAIL(hr);

                hr = _AddObject(&jid, &pidl);

                BREAK_ON_FAIL(hr);

                m_pShellView->SelectItem(pidl, SVSI_SELECT);
            }
        }

        BREAK_ON_FAIL(hr);

    } while (0);

    if (FAILED(hr))
    {
        MessageBeep(MB_ICONHAND);
    }
    else if (fCreatedJob)
    {
        //
        // If the drag/drop operation resulted in a new task being added
        // to the tasks folder, prompt the user to start the service
        // if it isn't already running.
        //

        if (UserCanChangeService(m_pszMachine))
        {
            PromptForServiceStart(m_hwndOwner);
        }
    }

    // clean up
    delete pFrom;
    delete rglen;
    ReleaseStgMedium(&medium);

    return S_OK;    // Don't need to do anything here...
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::Drop
//
//  Synopsis:   same as IDropTarget::Drop
//
//  History:    1/31/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
CJobFolder::Drop(
    LPDATAOBJECT pdtobj,
    DWORD grfKeyState,
    POINTL ptl,
    DWORD *pdwEffect)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::Drop <<----\n"));

    *pdwEffect = DROPEFFECT_NONE;

    //
    // Policy - we should never get here, since we disabled
    // it in DragEnter and DragOver, but just in case
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK) ||
        RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP))
    {
        return S_OK;
    }

    BOOL fMove = !(grfKeyState & MK_CONTROL);

    DEBUG_OUT((DEB_USER12, "CJobFolder::Drop <%s>\n", fMove ? "Move" : "Copy"));

    return CopyToFolder(pdtobj, fMove, TRUE, &ptl);
}



BOOL
CJobFolder::_PopupRBMoveCtx(
    LONG    x,
    LONG    y,
    BOOL  * pfMove)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::_PopupRBMoveCtx\n"));

    const TCHAR c_szStatic[] = TEXT("Static");
    int iRet = FALSE;

    HWND hwndDummy = CreateWindow(c_szStatic, NULL, 0, x, y, 1, 1,
                                m_hwndOwner, // HWND_DESKTOP,
                                NULL, g_hInstance, NULL);
    if (hwndDummy)
    {
        HWND hwndPrev = GetForegroundWindow();  // to restore
        UINT uFlags = TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN;

        HMENU   popup;
        HMENU   subpopup;

        if (popup = LoadMenu(g_hInstance, MAKEINTRESOURCE(POPUP_RBUTTON_MOVE)))
        {
            subpopup = GetSubMenu(popup, 0);

            SetForegroundWindow(hwndDummy);
            SetFocus(hwndDummy);
            iRet = TrackPopupMenu(subpopup, uFlags, x, y, 0, hwndDummy, NULL);

            DestroyMenu(popup);
        }
        else
            return FALSE;

        if (iRet)
        {
            // non-cancel item is selected. Make the hwndOwner foreground.
            SetForegroundWindow(m_hwndOwner);
            SetFocus(m_hwndOwner);
        }
        else
        {
            //
            // The user canceled the menu. Restore the previous foreground
            // window (before destroying hwndDummy).
            //

            if (hwndPrev)
            {
                SetForegroundWindow(hwndPrev);
            }
        }

        DestroyWindow(hwndDummy);
    }

    switch (iRet)
    {
    case DDIDM_MOVE:
        *pfMove = TRUE;
        return TRUE;

    case DDIDM_COPY:
        *pfMove = FALSE;
        return TRUE;

    case 0:
    default:
        return FALSE;
    }
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::CreateAJobForApp
//
//  Synopsis:   Creates a job for the given app.
//              If (pszApp != 0) job name <- app name with ext changed to job
//              Else job name <- "New Job.job", with rename.
//
//  Arguments:  [pszApp] -- IN
//
//  Returns:    HRESULT
//              --- E_FAIL if policy is on preventing creation.  Callers
//                  should check this if are contingent on a job being made.
//
//  History:    4/4/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobFolder::CreateAJobForApp(
    LPCTSTR pszApp)
{
    HRESULT     hr = S_OK;

    //
    // Policy - if we have the regkey DENY_CREATE_TASK active
    // we cannot permit new jobs to be created via the ui
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy CREATE_TASK active - no drag-drop or copy/cut/paste\n"));
        return E_FAIL;
    }

    CJob * pCJob = CJob::Create();

    if (pCJob == NULL)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

    do
    {
        DWORD dwAddFlags = TASK_FLAG_DONT_START_IF_ON_BATTERIES |
                           TASK_FLAG_KILL_IF_GOING_ON_BATTERIES;

        hr = pCJob->SetFlags(dwAddFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        //
        // Create and set a default trigger for ever day at 9:00 AM, with
        // no repetition.
        //

        TASK_TRIGGER jt;
        SYSTEMTIME   stNow;

        GetSystemTime(&stNow);

        SecureZeroMemory(&jt, sizeof(jt));

        jt.cbTriggerSize = sizeof(jt);
        jt.wBeginYear = stNow.wYear;
        jt.wBeginMonth = stNow.wMonth;
        jt.wBeginDay = stNow.wDay;
        jt.TriggerType = TASK_TIME_TRIGGER_DAILY;
        jt.Type.Daily.DaysInterval = 1;
        jt.wStartHour = 9;
        jt.wStartMinute = 0;
        jt.rgFlags = 0;

        ITaskTrigger  * pTrigger = NULL;
        WORD            iTrigger = (WORD)-1;

        hr = pCJob->CreateTrigger(&iTrigger, &pTrigger);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = pTrigger->SetTrigger((const PTASK_TRIGGER)&jt);

        pTrigger->Release();

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);


        TCHAR szJob[MAX_PATH+12];

        StringCchCopy(szJob, MAX_PATH+12, m_pszFolderPath);
        StringCchCat(szJob, MAX_PATH+12, TEXT("\\"));

        if (pszApp != NULL)
        {
            // set the app name

            hr = pCJob->SetApplicationName(pszApp);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            // the job name ...

            StringCchCat(szJob, MAX_PATH+12, PathFindFileName(pszApp));

            LPTSTR pszExt = PathFindExtension(szJob);
            StringCchCopy(pszExt, MAX_PATH+12 - (pszExt - szJob), TSZ_DOTJOB);
        }
        else
        {
            UINT len = lstrlen(szJob);

            static int s_nLengthOK = -1;

            if (s_nLengthOK == -1)
            {
                UINT uiTemp = (UINT)LoadString(g_hInstance, IDS_NEW_JOB,
                                         &szJob[len], (MAX_PATH + 12 - len));

                uiTemp += len;

                if (uiTemp <= MAX_PATH)
                {
                    s_nLengthOK = 1;
                }
                else
                {
                    s_nLengthOK = 0;
                }
            }

            if (s_nLengthOK == 0)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                CHECK_HRESULT(hr);
                break;
            }

            LoadString(g_hInstance, IDS_NEW_JOB,
                                        &szJob[len], (MAX_PATH - len));

            EnsureUniquenessOfFileName(szJob, MAX_PATH+12);

            if (lstrlen(szJob) > MAX_PATH)
            {
                hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
                CHECK_HRESULT(hr);
                break;
            }
        }

        hr = pCJob->Save(szJob, FALSE);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        //
        //  If the drop was on the job folder shortcut, there is nothing
        //  else to do here.
        //

        if (m_hwndOwner == NULL || m_pShellView == NULL)
        {
            break;
        }

        //
        // Add the job to the job folder
        //

        CJobID jid;

        LPTSTR pszJobName = &szJob[lstrlen(m_pszFolderPath)+1];

        //*(pszJobName - 1) = TEXT('\0');

        hr = jid.Load(m_pszFolderPath, pszJobName);
        BREAK_ON_FAIL(hr);

        hr = _AddObject(&jid);
        BREAK_ON_FAIL(hr);

        //
        //  If this is a new task prompt the user for rename
        //

        if (pszApp == NULL)
        {
            //
            // Prompt the user to rename the new job.
            //

            if (m_pShellView != NULL)
            {
                hr = m_pShellView->SelectItem(((LPCITEMIDLIST)&jid), SVSI_EDIT);

                CHECK_HRESULT(hr);
            }
        }

        //BREAK_ON_FAIL(hr);

    } while (0);

    if (pCJob != NULL)
    {
        pCJob->Release();
    }

    return hr;
}


int
CJobFolder::_GetJobIDForTask(
    PJOBID *ppjid,
    int     count,
    LPTSTR  pszTask)
{
    LPTSTR pszExt = PathFindExtension(pszTask);
    TCHAR tcSave;

    if (pszExt)
    {
        tcSave = *pszExt;
        *pszExt = TEXT('\0');
    }

    //
    // If the folder is empty, count is 0, so initialize iCmp to -1
    // to force the return statement to indicate there was no match.
    //

    int iCmp = -1;

    for (int i=0; i < count; i++)
    {
#if (DBG == 1)
        ppjid[i]->Validate();
#endif // (DBG == 1)

        //
        // Don't compare template (virtual) objects against real files.
        //

        if (ppjid[i]->IsTemplate())
        {
            continue;
        }

        iCmp = lstrcmpi(ppjid[i]->GetName(), pszTask);

        if (iCmp >= 0)
        {
            break;
        }
    }

    if (pszExt)
    {
        *pszExt = tcSave;
    }

    return (iCmp == 0) ? i : -1;
}


void hsort(PJOBID *ppjid, UINT cObjs);

void I_Sort(PJOBID * ppjid, UINT cObjs)
{
    UINT i;

#if (DBG == 1)
    for (i=0; i < cObjs; i++)
    {
        ppjid[i]->Validate();
    }
#endif // (DBG == 1)

    if (cObjs < 10)
    {
        UINT k = 0;
        PJOBID pjid;

        for (i=1; i < cObjs; i++)
        {
            for (k=i;
             k && (lstrcmpi(ppjid[k]->GetName(), ppjid[k-1]->GetName()) < 0);
                 --k)
            {
                pjid = ppjid[k];
                ppjid[k] = ppjid[k-1];
                ppjid[k-1] = pjid;
            }
        }
    }
    else
    {
        // Heap sort
        hsort(ppjid, cObjs);
    }

#if (DBG == 1)
    for (i=0; i < cObjs; i++)
    {
        ppjid[i]->Validate();
    }
#endif // (DBG == 1)
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::OnUpdateDir
//
//  Synopsis:   S
//
//  Returns:    void
//
//  History:    2/20/1996   RaviR   Created
//
//____________________________________________________________________________

void
CJobFolder::OnUpdateDir(void)
{
    DEBUG_OUT((DEB_USER1, "CJobFolder::OnUpdateDir <<--\n"));

    HRESULT hr = S_OK;

    //
    // First collect all the itemids from the LPSHELLVIEW
    //

    int cObjs = (int) ShellFolderView_GetObjectCount(m_hwndOwner);

    if (m_cObjsAlloced < cObjs)
    {
        // 40 so that it is DWORD aligned

        m_cObjsAlloced = ((cObjs / 40) + 1) * 40;

        //
        // Allocate an extra byte per jobid to use with pbPresent flag
        // array.  (See below.)
        //

        DWORD dwBytes = m_cObjsAlloced * (sizeof(PJOBID) + 1);

        if (m_pUpdateDirData == NULL)
        {
            m_pUpdateDirData = (BYTE *)GlobalAlloc(GPTR, dwBytes);
        }
        else
        {

            BYTE * pbTemp = (BYTE *)GlobalReAlloc(m_pUpdateDirData,
                                                     dwBytes, GHND);

            if (pbTemp)
            {
                m_pUpdateDirData = pbTemp;
            }
            else
            {
                GlobalFree(m_pUpdateDirData);
                m_pUpdateDirData = NULL;
            }
        }

        if (m_pUpdateDirData == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);

            m_cObjsAlloced = 0;

            return;
        }
    }

    PPJOBID ppjid = (PPJOBID)m_pUpdateDirData;
    PBYTE   pbPresent = m_pUpdateDirData + m_cObjsAlloced * sizeof(PJOBID);

    SecureZeroMemory(pbPresent, m_cObjsAlloced * sizeof(BYTE));

    for (int i=0; i < cObjs; i++)
    {
        ppjid[i] = (PJOBID)ShellFolderView_GetObject(m_hwndOwner, i);
#if (DBG == 1)
        ppjid[i]->Validate();
#endif
    }

    I_Sort(ppjid, cObjs);

    //
    //
    //

    TCHAR szSearchPath[MAX_PATH +1] = TEXT("");

    StringCchCopy(szSearchPath, MAX_PATH +1, m_pszFolderPath);    
    StringCchCat(szSearchPath, MAX_PATH +1, TEXT("\\*") TSZ_DOTJOB);

    WIN32_FIND_DATA fd;
    HANDLE hFind = FindFirstFile(szSearchPath, &fd);

    int index;

    if (hFind != INVALID_HANDLE_VALUE)
    {
        CJobID jid;

        while (1)
        {
            index = _GetJobIDForTask(ppjid, cObjs, fd.cFileName);

            if (index < 0)
            {
                // Add item

                hr = jid.Load(m_pszFolderPath, fd.cFileName);

                if (hr == S_OK)
                {
                    hr = _AddObject(&jid);
                }
            }
            else
            {
                FILETIME ftCreate = ppjid[index]->_ftCreation;
                FILETIME ftLastWrite = ppjid[index]->_ftLastWrite; 
                if (CompareFileTime(&fd.ftCreationTime,
                                    &ftCreate) ||
                    CompareFileTime(&fd.ftLastWriteTime,
                                    &ftLastWrite))
                {
                    // update job
                    DEBUG_OUT((DEB_USER12, "OnUpdateDir::UPDATE_ITEM<%ws>\n",
                                                        fd.cFileName));

                    hr = jid.Load(m_pszFolderPath, fd.cFileName);

                    if (hr == S_OK)
                    {
                        LPITEMIDLIST pidl;

                        hr = _UpdateObject(&jid, &jid, &pidl);

                        if (SUCCEEDED(hr))
                        {
                            ppjid[index] = (PJOBID)pidl;
                        }

                        // mark as present
                        pbPresent[index] = 1;
                    }
                }
                else
                {
                    // mark as present
                    pbPresent[index] = 1;
                }
            }

            //
            // Let us continue even on failure unless it is a memory error
            //

            if (hr == E_OUTOFMEMORY)
            {
                break;
            }

            //
            //  Get the next file.
            //

            if (FindNextFile(hFind, &fd) == FALSE)
            {
                if (GetLastError() != ERROR_NO_MORE_FILES)
                {
                    CHECK_LASTERROR(GetLastError());
                }

                break;
            }
        }

        FindClose(hFind);

        //
        // Let us continue even on failure unless it is a memory error
        //

        if (hr != E_OUTOFMEMORY)
        {
            //
            // Now delete any old items that are no longer valid, making
            // sure to ignore the template object.
            //

            for (i=0; i < cObjs; i++)
            {
                if (!pbPresent[i] && !ppjid[i]->IsTemplate())
                {
                    // Delete object
                    _RemoveObject(ppjid[i]);
                }
            }
        }
    }
    else
    {
        if (GetLastError() != ERROR_FILE_NOT_FOUND)
        {
            CHECK_LASTERROR(GetLastError());
        }
        else if (GetLastError() != ERROR_NO_MORE_FILES)
        {
            // delete everything but template objects

            for (i=0; i < cObjs; i++)
            {
                if (!ppjid[i]->IsTemplate())
                {
                    _RemoveObject(ppjid[i]);
                }
            }
        }
    }

    if (hr == E_OUTOFMEMORY)
    {
        // Display error message
    }

    DEBUG_OUT((DEB_USER1, "CJobFolder::OnUpdateDir -->>\n"));

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\macros.h ===
#define ARRAYLEN(a) (sizeof(a) / sizeof((a)[0]))

#define BREAK_ON_FAIL(hr) if (FAILED(hr)) { break; } else 1;

#define BREAK_ON_ERROR(lr) if ((lr) != ERROR_SUCCESS) { break; } else 1;

#ifndef offsetof
#define offsetof(type,field) ((size_t)&(((type*)0)->field))
#endif



//---------------------------------------------------------------
//  IUnknown
//---------------------------------------------------------------

//
//  This declares the set of IUnknown methods and is for general-purpose
//  use inside classes that inherit from IUnknown
//

#define DECLARE_IUNKNOWN_METHODS                                    \
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);    \
    STDMETHOD_(ULONG,AddRef) (void);                                \
    STDMETHOD_(ULONG,Release) (void)

//
// This is for use in declaring non-aggregatable objects.  It declares the
// IUnknown methods and reference counter, m_ulRefs.
// m_ulRefs should be initialized to 1 in the constructor of the object
//

#define DECLARE_STANDARD_IUNKNOWN           \
    DECLARE_IUNKNOWN_METHODS;               \
    ULONG m_ulRefs

//
// NOTE:    this does NOT implement QueryInterface, which must be
//          implemented by each object
//

#define IMPLEMENT_STANDARD_IUNKNOWN(cls)                        \
    STDMETHODIMP_(ULONG) cls##::AddRef()                        \
        { return InterlockedIncrement((LONG*)&m_ulRefs); }      \
    STDMETHODIMP_(ULONG) cls##::Release()                       \
        { ULONG ulRet = InterlockedDecrement((LONG*)&m_ulRefs); \
          if (0 == ulRet) { delete this; }                      \
          return ulRet; }



//-----------------------------------------------------------------------------
//  IClassFactory
//-----------------------------------------------------------------------------

#define JF_IMPLEMENT_CLASSFACTORY(cls)                          \
    class cls##CF : public IClassFactory                        \
    {                                                           \
    public:                                                     \
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID *ppvObj); \
        STDMETHOD_(ULONG,AddRef)(void);                         \
        STDMETHOD_(ULONG,Release)(void);                        \
                                                                \
        STDMETHOD(CreateInstance)(IUnknown* pUnkOuter,          \
                            REFIID riid, LPVOID* ppvObj);       \
        STDMETHOD(LockServer)(BOOL fLock);                      \
    };                                                          \
                                                                \
    STDMETHODIMP                                                \
    cls##CF::QueryInterface(REFIID riid, LPVOID* ppvObj)        \
    {                                                           \
        if (IsEqualIID(IID_IUnknown, riid) ||                   \
            IsEqualIID(IID_IClassFactory, riid))                \
        {                                                       \
            *ppvObj = (IUnknown*)(IClassFactory*) this;         \
            this->AddRef();                                     \
            return S_OK;                                        \
        }                                                       \
                                                                \
        *ppvObj = NULL;                                         \
        return E_NOINTERFACE;                                   \
    }                                                           \
                                                                \
    STDMETHODIMP_(ULONG)                                        \
    cls##CF::AddRef()                                           \
    {                                                           \
        return CDll::AddRef();                                  \
    }                                                           \
                                                                \
    STDMETHODIMP_(ULONG)                                        \
    cls##CF::Release()                                          \
    {                                                           \
        return CDll::Release();                                 \
    }                                                           \
                                                                \
    STDMETHODIMP                                                \
    cls##CF::LockServer(BOOL fLock)                             \
    {                                                           \
        CDll::LockServer(fLock);                                \
                                                                \
        return S_OK;                                            \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\jobicons.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       icon.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    4/5/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"
#include "resource.h"
#include "jobicons.hxx"

extern HINSTANCE g_hInstance;

CJobIcon::CJobIcon(void)
{
    m_himlSmall = NULL;    // init so that if anything fails before any list
    m_himlLarge = NULL;    // gets created, the destructor will not fault.
    m_himlXLarge = NULL;
                        
    //
    //  Load and setup the small overlay imagelist
    //
    //  if (!LoadImageList(&m_himlSmall, BMP_JOBSTATES, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON)))
    if (!LoadImageList(&m_himlSmall, BMP_JOBSTATES, 16, 16))
    {
        DEBUG_OUT((DEB_ERROR, "Small image list failed to load.\n"));
        return;
    }
    
    //
    //  Load and setup the large overlay imagelist
    //
    //  if (!LoadImageList(&m_himlLarge, BMP_JOBSTATEL, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON)))
    if (!LoadImageList(&m_himlLarge, BMP_JOBSTATEL, 32, 32))
    {
        DEBUG_OUT((DEB_ERROR, "Large image list failed to load.\n"));
        return;
    }
    
    //
    //  Load and setup the Xtralarge overlay imagelist
    //  extra large icons are 48x48
    //
    if (!LoadImageList(&m_himlXLarge, BMP_JOBSTATEXL, 48, 48))
    {
        DEBUG_OUT((DEB_ERROR, "XLarge image list failed to load.\n"));
        return;
    }
}

bool CJobIcon::LoadImageList(HIMAGELIST* phiml, UINT nBmpToLoad, int cx, int cy)
{
	//
	//  Load and setup the overlay imagelist
	//
	*phiml = ImageList_Create(cx, cy, ILC_COLOR32 | ILC_MASK, 1, 1);
	if (!phiml)
	{
		DEBUG_OUT((DEB_ERROR, "ImageList_Create returned NULL.\n"));
		return false;
	}

	HBITMAP hBmp = (HBITMAP)LoadImage(g_hInstance, MAKEINTRESOURCE(nBmpToLoad), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR);
	if (!hBmp)
	{
		DEBUG_OUT((DEB_ERROR, "LoadImage returned NULL.\n"));
		return false;
	}

	int i = ImageList_AddMasked(*phiml, hBmp, RGB(0, 255, 0));

	// delete this here regardless of whether above call failed so that it won't get leaked by an early return
	DeleteObject(hBmp);

	if (i == -1)
	{
		DEBUG_OUT((DEB_ERROR, "ImageList_AddMasked returned -1.\n"));
		return false;
	}

	if (	!ImageList_SetOverlayImage(*phiml, 0, 1) ||
		!ImageList_SetOverlayImage(*phiml, 1, 2))
	{
		DEBUG_OUT((DEB_ERROR, "ImageList_SetOverlayImage returned 0.\n"));
		return false;
	}

	return true;
}


HICON GetDefaultAppIcon(UINT nIconSize)
{
    TRACE_FUNCTION(GetDefaultAppIcon);
    return (HICON)LoadImage(g_hInstance, (LPCTSTR)IDI_GENERIC, IMAGE_ICON, nIconSize, nIconSize, LR_CREATEDIBSECTION);
}

void
CJobIcon::GetIcons(
    LPCTSTR pszApp,
    BOOL    fEnabled,
    HICON * phiconLarge,
    HICON * phiconSmall,
	UINT	nIconSize)
{
    TRACE(CJobIcon, GetIcons);

	UINT nLargeSize = nIconSize & 0x0000ffff;
	UINT nSmallSize = (nIconSize & 0xffff0000) >> 16;

	if (nLargeSize && phiconLarge)
	{
		TS_ExtractIconEx(pszApp, 0, phiconLarge, 1, nLargeSize);
	    _OverlayIcons(phiconLarge, fEnabled, nLargeSize);
	}

	if (nSmallSize && phiconSmall)
	{
		TS_ExtractIconEx(pszApp, 0, phiconSmall, 1, nSmallSize);
	    _OverlayIcons(phiconSmall, fEnabled, nSmallSize);
	}
}



//+--------------------------------------------------------------------------
//
//  Member:     CJobIcon::GetTemplateIcons
//
//  Synopsis:   Fill out pointers with large and small template icons
//
//  Arguments:  [phiconLarge] - NULL or ptr to icon handle to fill
//              [phiconSmall] - ditto
//
//  History:    5-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CJobIcon::GetTemplateIcons(
    HICON * phiconLarge,
    HICON * phiconSmall,
	UINT	nIconSize)
{
    TRACE(CJobIcon, GetTemplateIcons);

	UINT nLargeSize = nIconSize & 0x0000ffff;			// nIconSize contains the large size in the low word
	UINT nSmallSize = (nIconSize & 0xffff0000) >> 16;	// nIconSize contains the small size in the high word

    if (nLargeSize && phiconLarge)
    {
        *phiconLarge = (HICON) LoadImage(g_hInstance, 
                                         MAKEINTRESOURCE(IDI_TEMPLATE), 
                                         IMAGE_ICON,
                                         nLargeSize, 
                                         nLargeSize, 
                                         LR_CREATEDIBSECTION);
    
        if (!*phiconLarge)
        {
            DEBUG_OUT_LASTERROR;
        }
    }

    if (nSmallSize && phiconSmall)
    {
        *phiconSmall = (HICON) LoadImage(g_hInstance, 
                                         MAKEINTRESOURCE(IDI_TEMPLATE), 
                                         IMAGE_ICON,
                                         nSmallSize, 
                                         nSmallSize, 
                                         LR_CREATEDIBSECTION);
        if (!*phiconSmall)
        {
            DEBUG_OUT_LASTERROR;
        }
    }
}


void
CJobIcon::_OverlayIcons(
    HICON * phicon,
    BOOL    fEnabled,
	UINT	nIconSize)
{
    HICON hiconTemp;

    if (phicon != NULL)
    {
        if (*phicon == NULL)
        {
            *phicon = GetDefaultAppIcon(nIconSize);
        }

		hiconTemp = OverlayStateIcon(*phicon, fEnabled, nIconSize);

		DestroyIcon(*phicon);
		*phicon = hiconTemp;
    }
}

HICON
CJobIcon::OverlayStateIcon(
    HICON   hicon,
    BOOL    fEnabled,
	UINT	nIconSize)
{
    TRACE(CJobIcon, OverlayStateIcon);

    HICON hiconOut;
	UINT nLargeSize = GetSystemMetrics(SM_CXICON);
	UINT nSmallSize = GetSystemMetrics(SM_CXSMICON);

    // dont destroy rhiml !!
    HIMAGELIST &rhiml = (nIconSize > nLargeSize) ? m_himlXLarge : ((nIconSize > nSmallSize) ? m_himlLarge : m_himlSmall);

    int i = ImageList_AddIcon(rhiml, hicon);
	hiconOut = ImageList_GetIcon(rhiml, i, INDEXTOOVERLAYMASK((fEnabled ? 1 : 2)));
    ImageList_Remove(rhiml, i);

    return hiconOut;
}


//+--------------------------------------------------------------------------
//
//  Function:	TS_ExtractIconEx
//
//  Synopsis:	Extract the desired icons from an executable.  The file is pre-
//				processed to avoid NULL and empty files, and files which are
//				actually links (they weren't resolved to their exes because they
//				are MSI apps -- e.g. Office apps) get resolved to the actual
//				executable so that an icon can be obtained.
//
//  Arguments:  Same as for ExtractIconEx:
//
//				LPCTSTR	lpszFile,		// file name
//				int		nIconIndex,		// icon index
//				HICON*	phiconLarge,	// large icon array
//				HICON*	phiconSmall,	// small icon array
//				UINT	nIcons,			// number of icons to extract
//				UINT	nIconSize		// large (low word) and small (high word) sizes
//
//  History:	08-28-2001	ShBrown	Created in response to bug #446344
//
//---------------------------------------------------------------------------

UINT TS_ExtractIconEx(
	LPCTSTR	lpszFile,		// file name
	int		nIconIndex,		// icon index
	HICON*	phicon,			// icon array
	UINT	nIcons,			// number of icons to extract
	UINT	nIconSize		// width or height (they're the same)
)
{
    if (lpszFile != NULL && *lpszFile != TEXT('\0'))
    {
		LPTSTR ptszExt = PathFindExtension(lpszFile);
		if (ptszExt && !_tcsicmp(ptszExt, TEXT(".LNK")))
		{
			TCHAR szLnkPath[MAX_PATH];
			ResolveLnk(lpszFile, szLnkPath);
			return SHExtractIconsW(szLnkPath, nIconIndex, nIconSize, nIconSize, phicon, NULL, nIcons, LR_CREATEDIBSECTION);
		}
		else
			return SHExtractIconsW(lpszFile, nIconIndex, nIconSize, nIconSize, phicon, NULL, nIcons, LR_CREATEDIBSECTION);
    }

	return 0;
}


//+--------------------------------------------------------------------------
//
//  Function:	ResolveLnk
//
//  Synopsis:	Helper for TS_ExtractIconEx.  Take a link and find its exe.
//
//  Arguments:  LPCTSTR	lpszLnkPath,	// path to link
//				LPTSTR	lpszExePath		// path to exe
//
//  History:	08-28-2001	ShBrown	Created in response to bug #446344
//
//				Mainly stolen from wizard\walklib.cxx and modified
//
//---------------------------------------------------------------------------

void ResolveLnk(
	LPCTSTR	lpszLnkPath,	// path to link
	LPTSTR	lpszExePath		// path to exe
)
{
	// Get a pointer to the IShellLink interface.
	IShellLink* psl;
	HRESULT hres = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_IShellLink, (void **)&psl);
	if (SUCCEEDED(hres))
	{
		// Get a pointer to the IPersistFile interface.
		IPersistFile* ppf;
		hres = psl->QueryInterface(IID_IPersistFile, (void **)&ppf);
		if (SUCCEEDED(hres))
		{
			WCHAR wsz[MAX_PATH];
			lstrcpyn(wsz, lpszLnkPath, ARRAYLEN(wsz));

			// Load the shell link.
			hres = ppf->Load(wsz, STGM_READ);
			if (SUCCEEDED(hres))
			{
				TCHAR szGotPath[MAX_PATH];
				lstrcpyn(szGotPath, lpszLnkPath, MAX_PATH);

				// Get the path to the link target.
				WIN32_FIND_DATA wfdExeData;
				hres = psl->GetPath(szGotPath, MAX_PATH, &wfdExeData, SLGP_SHORTPATH );
				if (SUCCEEDED(hres))
				{
					if (lstrlen(szGotPath) > 0)
					{
						lstrcpyn(lpszExePath, szGotPath, MAX_PATH);
					}
				}
			}
			// Release pointer to IPersistFile interface.
			ppf->Release();
		}
		// Release pointer to IShellLink interface.
		psl->Release();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\menubg.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       menubg.cxx
//
//  Contents:   IContextMenu implementaion.
//
//  Classes:    CJobsCMBG, implementing IContextMenu for the background
//
//  Functions:
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "..\inc\resource.h"
#include "resource.h"
#include "jobidl.hxx"
#include "sch_cls.hxx"  // sched\inc
#include "job_cls.hxx"  // sched\inc
#include "misc.hxx"     // sched\inc
#include "policy.hxx"   // sched\inc

#include "jobfldr.hxx"
#include "util.hxx"
#include <StrSafe.h>

//
// extern
//

extern HINSTANCE g_hInstance;

HRESULT
PromptForServiceStart(
    HWND hwnd);

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

//
//  Forward declaration of local functions
//

HRESULT
JFCreateNewQueue(
    HWND    hwnd);


extern "C" UINT g_cfPreferredDropEffect;


//____________________________________________________________________________
//
//  Class:      CJobsCMBG
//
//  Purpose:    Provide IContextMenu interface to Job Folder (background).
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsCMBG : public IContextMenu
{
public:
    CJobsCMBG(HWND hwnd, CJobFolder * pCJobFolder)
        : m_ulRefs(1), m_hwnd(hwnd), m_pCJobFolder(pCJobFolder) {}

    ~CJobsCMBG() {}

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                            UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT * pwReserved,
                            LPSTR pszName, UINT cchMax);

private:
    HWND            m_hwnd;
    CJobFolder    * m_pCJobFolder;
};



//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsCMBG);


STDMETHODIMP
CJobsCMBG::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IContextMenu, riid))
    {
        *ppvObj = (IUnknown*)(IContextMenu*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsCMBG::QueryContextMenu
//
//  Arguments:  [hmenu] -- IN
//              [indexMenu] -- IN
//              [idCmdFirst] -- IN
//              [idCmdLast] -- IN
//              [uFlags] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCMBG::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
{
    TRACE(CJobsCMBG, QueryContextMenu);

    QCMINFO qcm = { hmenu, indexMenu, idCmdFirst, idCmdLast };

    UtMergeMenu(g_hInstance, POPUP_JOBSBG_MERGE,
                             POPUP_JOBSBG_POPUPMERGE, (LPQCMINFO)&qcm);

    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}


HRESULT
DataObj_GetDWORD(
    IDataObject   * pdtobj,
    UINT            cf,
    DWORD         * pdwOut)
{
    STGMEDIUM medium;
    FORMATETC fmte = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT hr;

    medium.pUnkForRelease = NULL;
    medium.hGlobal = NULL;

    hr = pdtobj->GetData(&fmte, &medium);

    if (SUCCEEDED(hr))
    {
        DWORD *pdw = (DWORD *)GlobalLock(medium.hGlobal);

        if (pdw)
        {
            *pdwOut = *pdw;
            GlobalUnlock(medium.hGlobal);
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        ReleaseStgMedium(&medium);
    }

    return hr;
}



//____________________________________________________________________________
//
//  Member:     CJobsCMBG::InvokeCommand
//
//  Arguments:  [lpici] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCMBG::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    TRACE(CJobsCMBG, InvokeCommand);

#define SORT_BY(X)  \
    case FSIDM_SORTBY##X: ShellFolderView_ReArrange(m_hwnd, COLUMN_##X); break

    UINT    idCmd;
    HRESULT hr = S_OK;

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        if (0 == lstrcmpA(pszCmd, "paste"))
        {
            idCmd = CMIDM_PASTE;
        }
        else
        {
            DEBUG_OUT((DEB_ERROR, "Unprocessed InvokeCommandBG<%s>\n", pszCmd));
            return E_INVALIDARG;
        }
    }
    else
    {
        idCmd = LOWORD(lpici->lpVerb);
    }


    switch (idCmd)
    {
    SORT_BY(NAME);
    SORT_BY(NEXTRUNTIME);
    SORT_BY(LASTRUNTIME);
    SORT_BY(SCHEDULE);
    SORT_BY(LASTEXITCODE);
    SORT_BY(CREATOR);

    case FSIDM_NEWJOB:
        if (UserCanChangeService(m_pCJobFolder->GetMachine()))
        {
            PromptForServiceStart(m_hwnd);
        }
        hr = m_pCJobFolder->CreateAJobForApp(NULL);
        break;

    case CMIDM_PASTE:
    {
            //
            // Policy - if cannot create a job, then
            // paste is not allowed
            //

            if (! RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
            {
                LPDATAOBJECT pdtobj = NULL;
                hr = OleGetClipboard(&pdtobj);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);

                // GetPreferred drop effect

                DWORD dw;
                hr = DataObj_GetDWORD(pdtobj, g_cfPreferredDropEffect, &dw);

                CHECK_HRESULT(hr);

                if (FAILED(hr))
	        {
                    dw = DROPEFFECT_COPY;
	        }

	            hr = m_pCJobFolder->CopyToFolder(pdtobj,
	                                (dw & DROPEFFECT_MOVE) ? TRUE : FALSE,
                                        FALSE, NULL);
                    pdtobj->Release();
            }
		
        break;
    }
    default:
        return E_INVALIDARG;
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsCMBG::GetCommandString
//
//  Arguments:  [idCmd] -- IN
//              [uType] -- IN
//              [pwReserved] -- IN
//              [pszName] -- IN
//              [cchMax] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCMBG::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax)
{
    TRACE(CJobsCMBG, GetCommandString);

#if DBG==1
    char * aType[] = {"GCS_VERBA", "GCS_HELPTEXTA", "GCS_VALIDATEA", "Unused",
                    "GCS_VERBW", "GCS_HELPTEXTW", "GCS_VALIDATEW", "UNICODE"};

    DEBUG_OUT((DEB_USER5, "GetCommandString <id,type> = <%d, %d, %s>\n",
               idCmd, uType, aType[uType]));
#endif // DBG==1

    *((LPTSTR)pszName) = TEXT('\0');

    if (uType == GCS_HELPTEXT)
    {
        LoadString(g_hInstance, (UINT)idCmd + IDS_MH_FSIDM_FIRST,
                                        (LPTSTR)pszName, cchMax);
        return S_OK;
    }

    return E_FAIL;
}



//____________________________________________________________________________
//
//  Function:   JFCreateNewQueue
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//
//  Returns:    HRESULT
//
//  History:    3/26/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFCreateNewQueue(
    HWND    hwnd)
{
    MessageBoxA(hwnd, "Creating a New Queue is NOTIMPL", "Job Folder", MB_OK);
    return S_FALSE;
}



//____________________________________________________________________________
//
//  Function:   JFGetFolderContextMenu
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//              [riid] -- IN
//              [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetFolderContextMenu(
    HWND            hwnd,
    CJobFolder    * pCJobFolder,
    LPVOID        * ppvObj)
{
    CJobsCMBG* pObj = new CJobsCMBG(hwnd, pCJobFolder);

    if (NULL == pObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IContextMenu, ppvObj);

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\menu.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       menu.hxx
//
//  Contents:   Declaration of CJobsCM, implementing IContextMenu
//
//  Classes:
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include <misc.hxx>     // ARRAY_LEN
#include "policy.hxx"

#include "resource.h"
#include "jobidl.hxx"
#include "util.hxx"
#include "dll.hxx"
#include "..\schedui\schedui.hxx"
#include "..\schedui\dlg.hxx"
#include "..\wizard\wizpage.hxx"
#include "..\wizard\taskwiz.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;


HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj);


HRESULT
JFOpenPropSheet(
    LPDATAOBJECT pdtobj,
    LPTSTR       pszCaption);


HRESULT
GetSchSvcState(
    DWORD &dwCurrState);


HRESULT
StartScheduler(void);


HRESULT
PauseScheduler(
    BOOL fPause);

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

HRESULT
PromptForServiceStart(
    HWND hwnd);


//____________________________________________________________________________
//
//  Class:      CJobsCM
//
//  Purpose:    Provide IContextMenu interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsCM : public IContextMenu
{
public:
    CJobsCM(
        HWND hwnd,
        ITaskScheduler *pScheduler,
        LPCTSTR ptszMachine);

    HRESULT
    InitInstance(
        LPCTSTR pszFolderPath,
        LPCITEMIDLIST pidlFolder,
        UINT cidl,
        LPCITEMIDLIST* apidl);

    ~CJobsCM();

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IContextMenu methods
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst,
                            UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pwReserved,
                            LPSTR pszName, UINT cchMax);
private:
    HRESULT _RunJob(CJobID & jid);
    HRESULT _AbortJob(CJobID & jid);
    HRESULT _DeleteJobs(void);
    HRESULT _DisplayJobProperties(HWND hwnd, CJobID & jid);

    LPCTSTR            m_pszFolderPath;
    LPITEMIDLIST       m_pidlFolder;
    UINT               m_cidl;
    LPITEMIDLIST  *    m_apidl;
    HWND               m_hwnd;
    ITaskScheduler *   m_pScheduler;
    LPCTSTR            m_ptszMachine;
};



inline
CJobsCM::CJobsCM(
    HWND hwnd,
    ITaskScheduler *pScheduler,
    LPCTSTR ptszMachine):
        m_ulRefs(1),
        m_hwnd(hwnd),
        m_cidl(0),
        m_apidl(NULL),
        m_pScheduler(pScheduler),
        m_ptszMachine(ptszMachine),
        m_pidlFolder(NULL),
        m_pszFolderPath(NULL)
{
    TRACE(CJobsCM, CJobsCM);
}




//____________________________________________________________________________
//
//  Member:     CJobsCM::~CJobsCM, Destructor
//
//  History:    1/8/1996   RaviR   Created
//____________________________________________________________________________

CJobsCM::~CJobsCM()
{
    TRACE(CJobsCM, ~CJobsCM);

    ILA_Free(m_cidl, m_apidl);
    ILFree(m_pidlFolder);

    m_cidl = 0;
    m_apidl = NULL;

    // Don't do a release on pScheduler, since this object never
    // increased its ref count.
}


//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsCM);


STDMETHODIMP
CJobsCM::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IContextMenu, riid))
    {
        *ppvObj = (IUnknown*)(IContextMenu*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}




//____________________________________________________________________________
//
//  Member:     CJobsCM::InitInstance
//
//  Synopsis:   S
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::InitInstance(
    LPCTSTR pszFolderPath,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST* apidl)
{
    TRACE(CJobsCM, InitInstance);

    HRESULT     hr = S_OK;

    m_pszFolderPath = pszFolderPath;
    m_cidl = cidl;
    m_apidl = ILA_Clone(cidl, apidl);

    if (!m_apidl)
    {
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }

    m_pidlFolder = ILClone(pidlFolder);

    if (!m_pidlFolder)
    {
        ILA_Free(m_cidl, m_apidl);
        m_cidl = 0;
        m_apidl = NULL;
        hr = E_OUTOFMEMORY;
        CHECK_HRESULT(hr);
        return hr;
    }
    return S_OK;
}



//____________________________________________________________________________
//
//  Member:     CJobsCM::QueryContextMenu
//
//  Synopsis:   Same as IContextMenu::QueryContextMenu
//
//  Arguments:  [hmenu] -- IN
//              [indexMenu] -- IN
//              [idCmdFirst] -- IN
//              [idCmdLast] -- IN
//              [uFlags] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCM::QueryContextMenu(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
{
    TRACE(CJobsCM, QueryContextMenu);
    DEBUG_OUT((DEB_TRACE, "QueryContextMenu<uFlags=%d>\n", uFlags));

    QCMINFO qcm = {hmenu, indexMenu, idCmdFirst, idCmdLast};
    BOOL fRunning = FALSE; // selected objects include running object
    BOOL fTemplate = FALSE; // selected objects include template object
    UINT i;

    for (i=0; i < m_cidl; i++)
    {
        PJOBID pjid = (PJOBID)m_apidl[i];

        if (pjid->IsTemplate())
        {
            fTemplate = TRUE;
        }

        if (pjid->IsRunning())
        {
            fRunning = TRUE;
        }
    }

    if (fTemplate)
    {
        UtMergeMenu(g_hInstance,
                    POPUP_JOB_TEMPLATE,
                    0,
                    (LPQCMINFO)&qcm);
        SetMenuDefaultItem(hmenu, idCmdFirst + CMIDM_OPEN, FALSE);
    }
    else
    {
        UtMergeMenu(g_hInstance,
                    (uFlags & CMF_DVFILE) ? POPUP_JOB_VERBS_ONLY : POPUP_JOB,
                    0,
                    (LPQCMINFO)&qcm);

        UINT uEnable = (m_cidl > 1) ? (MF_GRAYED | MF_BYCOMMAND)
                                    : (MF_ENABLED | MF_BYCOMMAND);

        EnableMenuItem(hmenu, idCmdFirst + CMIDM_PROPERTIES, uEnable);


        uEnable = (fRunning == TRUE) ? (MF_ENABLED | MF_BYCOMMAND)
                                     : (MF_GRAYED | MF_BYCOMMAND);

        EnableMenuItem(hmenu, idCmdFirst + CMIDM_ABORT, uEnable);

        //
        // We are trying to prevent the "RUN" command
        // from being available if the job is already running
        //  -- okay b/c we only permit one running instance at a time
        //
        // Note, that as in the above (abort enable) we have about
        // a second's worth of delay between when we fire off the
        // run command and when the service actually updates the
        // state of the job object itself, permitting us to make the
        // right choice.  We've always had this with "End Task" and
        // it has so far been okay.
        //

        uEnable = (fRunning == FALSE) ? (MF_ENABLED | MF_BYCOMMAND)
                                      : (MF_GRAYED | MF_BYCOMMAND);

        EnableMenuItem(hmenu, idCmdFirst + CMIDM_RUN, uEnable);

        //
        // Policy - user can control the ui
        //

        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE))
        {
            // Do not permit the removal of tasks

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_DELETE,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_CUT,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RENAME,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
            if (RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
        {
            // Do not allow tasks to be created (new name)

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RENAME,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP))
        {
            // Prevent any drag-drop type operations/clipboard stuff

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_CUT,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_COPY,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RENAME,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_PROPERTIES))
        {
            // Do not allow access to property pages

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_PROPERTIES,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }
        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_EXECUTION))
        {
            // Do not allow users to run or stop a job

            EnableMenuItem(hmenu, idCmdFirst + CMIDM_RUN,
                                    (MF_GRAYED | MF_BYCOMMAND));
            EnableMenuItem(hmenu, idCmdFirst + CMIDM_ABORT,
                                    (MF_GRAYED | MF_BYCOMMAND));
        }

        SetMenuDefaultItem(hmenu, idCmdFirst + CMIDM_PROPERTIES, FALSE);
    }


    return ResultFromShort(qcm.idCmdFirst - idCmdFirst);
}

//____________________________________________________________________________
//
//  Member:     CJobsCM::InvokeCommand
//
//  Synopsis:   Same as IContextMenu::InvokeCommand
//
//  Arguments:  [lpici] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCM::InvokeCommand(
    LPCMINVOKECOMMANDINFO lpici)
{
    TRACE(CJobsCM, InvokeCommand);

    HRESULT hr = S_OK;
    UINT i;
    UINT idCmd;

    if (HIWORD(lpici->lpVerb))
    {
        // Deal with string commands
        PSTR pszCmd = (PSTR)lpici->lpVerb;

        if (0 == lstrcmpA(pszCmd, "delete"))
        {
            idCmd = CMIDM_DELETE;
        }
        else if (0 == lstrcmpA(pszCmd, "properties"))
        {
            idCmd = CMIDM_PROPERTIES;
        }
        else if (0 == lstrcmpA(pszCmd, "cut"))
        {
            idCmd = CMIDM_CUT;
        }
        else if (0 == lstrcmpA(pszCmd, "copy"))
        {
            idCmd = CMIDM_COPY;
        }
        else if (0 == lstrcmpA(pszCmd, "rename"))
        {
            idCmd = CMIDM_RENAME;
        }
        else
        {
            DEBUG_OUT((DEB_ERROR, "Unprocessed InvokeCommand<%s>\n", pszCmd));
            return E_INVALIDARG;
        }
    }
    else
    {
        idCmd = LOWORD(lpici->lpVerb);
    }

    switch(idCmd)
    {
    case CMIDM_DELETE:
    {
        hr = _DeleteJobs();
        break;
    }

    case CMIDM_PROPERTIES:
        Win4Assert(m_cidl == 1);
        hr = _DisplayJobProperties(m_hwnd, *((PJOBID)m_apidl[0]));
        break;

    case CMIDM_CUT:
    case CMIDM_COPY:
    {
        LPDATAOBJECT pdobj = NULL;

        hr = JFGetDataObject(m_pszFolderPath,
                             m_pidlFolder,
                             m_cidl,
                             (LPCITEMIDLIST *)m_apidl,
                             (idCmd == CMIDM_CUT),
                             (void **)&pdobj);
        if (SUCCEEDED(hr))
        {
            hr = OleSetClipboard(pdobj);

            CHECK_HRESULT(hr);
        }

        pdobj->Release();

        if (idCmd == CMIDM_CUT)
        {
            ShellFolderView_SetClipboard(m_hwnd, DFM_CMD_MOVE);
        }

        break;
    }
    case CMIDM_RUN:
    {
        if (UserCanChangeService(m_ptszMachine))
        {
            hr = PromptForServiceStart(m_hwnd);
        }

        if (hr != S_OK)
        {
            break;
        }

        for (i=0; i < m_cidl; i++)
        {
            hr = _RunJob(*((PJOBID)m_apidl[i]));
        }

        break;
    }
    case CMIDM_ABORT:
    {
        for (i=0; i < m_cidl; i++)
        {
            PJOBID pjid = (PJOBID)m_apidl[i];

            if (pjid->IsRunning() == TRUE)
            {
                hr = _AbortJob(*((PJOBID)m_apidl[i]));
            }
        }

        break;
    }
    case CMIDM_OPEN:
        (void) CTaskWizard::Launch(m_pszFolderPath, m_pidlFolder);
        break;

    default:
        return E_FAIL;
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::GetCommandString
//
//  Synopsis:   Same as IContextMenu::GetCommandString
//
//  Arguments:  [idCmd] -- IN
//              [uType] -- IN
//              [pwReserved] -- IN
//              [pszName] -- IN
//              [cchMax] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsCM::GetCommandString(
    UINT_PTR    idCmd,
    UINT        uType,
    UINT      * pwReserved,
    LPSTR       pszName,
    UINT        cchMax)
{
    TRACE(CJobsCM, GetCommandString);

#if DBG==1
    char * aType[] = {"GCS_VERBA", "GCS_HELPTEXTA", "GCS_VALIDATEA", "Unused",
                    "GCS_VERBW", "GCS_HELPTEXTW", "GCS_VALIDATEW", "UNICODE"};

    DEBUG_OUT((DEB_TRACE, "GetCommandString<id,type,name> = <%d, %d, %s>\n",
               idCmd, uType, aType[uType]));
#endif // DBG==1


    *((LPTSTR)pszName) = TEXT('\0');

    if (uType == GCS_HELPTEXT)
    {
        LoadString(g_hInstance, (UINT)idCmd + IDS_MH_FSIDM_FIRST, (LPTSTR)pszName,
                                                                      cchMax);
        return S_OK;
    }
    if (uType == GCS_VERB && idCmd == CMIDM_RENAME)
    {
        // "rename" is language independent
        StringCchCopy((LPTSTR)pszName, cchMax, TEXT("rename"));

        return S_OK;
    }

    return E_FAIL;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::_RunJob
//
//  Arguments:  [hwnd] -- IN
//              [jid] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/12/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_RunJob(
    CJobID & jid)
{
    TRACE(CJobsCM, _RunJob);

    ITask  * pJob = NULL;

    TCHAR tcJob[MAX_PATH +1];

    StringCchCopy(tcJob, MAX_PATH +1, jid.GetPath());
    StringCchCat(tcJob, MAX_PATH +1, TSZ_DOTJOB);

    HRESULT hr = ::JFCreateAndLoadTask(m_pszFolderPath, tcJob, &pJob);

    if (SUCCEEDED(hr))
    {
        hr = pJob->Run();

        CHECK_HRESULT(hr);

        pJob->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobsCM::_AbortJob
//
//  Arguments:  [hwnd] -- IN
//              [jid] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/12/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_AbortJob(
    CJobID & jid)
{
    TRACE(CJobsCM, _AbortJob);

    ITask  * pJob = NULL;

    TCHAR tcJob[MAX_PATH +1];

    StringCchCopy(tcJob, MAX_PATH +1, jid.GetPath());
    StringCchCat(tcJob,MAX_PATH +1, TSZ_DOTJOB);

    HRESULT hr = ::JFCreateAndLoadTask(m_pszFolderPath, tcJob, &pJob);

    if (SUCCEEDED(hr))
    {
        hr = pJob->Terminate();

        CHECK_HRESULT(hr);

        pJob->Release();
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::_DeleteJobs
//
//  Arguments:  [hwnd] -- IN
//              [pwszJob] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/11/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_DeleteJobs(void)
{
    TRACE(CJobsCM, _DeleteJobs);

    PJOBID pjid = NULL;
    UINT   cchReqd = 0;


    //
    // Policy - if DELETE flag set, cannot remove jobs
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE))
    {
        return E_FAIL;
    }

    //
    // First compute buffer size for pFrom.
    //

    // Each file full path is composed as:
    //       FolderPath + \ + job path rel to fldr + extn + null
    //
    // Only <job path rel to fldr> differs for each. (Assuming extension
    //       length is always 4 <.job, .que>)

    for (UINT i=0; i < m_cidl; i++)
    {
        pjid = (PJOBID)m_apidl[i];

        cchReqd += lstrlen(pjid->GetPath());
    }

    cchReqd += (lstrlen(m_pszFolderPath) + 1 + ARRAY_LEN(TSZ_DOTJOB)) *
                                                                    m_cidl;
    // one for the extra null at the end
    ++cchReqd;

    LPTSTR pFrom = new TCHAR[cchReqd];

    if (pFrom == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    UINT ufldrPathLen = lstrlen(m_pszFolderPath);
    LPTSTR pCur = pFrom;

    for (i=0; i < m_cidl; i++)
    {
        pjid = (PJOBID)m_apidl[i];

        StringCchCopy(pCur, cchReqd - (pCur -pFrom), m_pszFolderPath);
        pCur += ufldrPathLen;

        *pCur++ = TEXT('\\');

        StringCchCopy(pCur, cchReqd - (pCur -pFrom), pjid->GetPath());
        StringCchCat(pCur, cchReqd - (pCur -pFrom), pjid->GetExtension());
        
        pCur += lstrlen(pCur) + 1;
    }

    // Make sure we have double trailing NULL!
    *pCur = TEXT('\0');

    SHFILEOPSTRUCT fo;

    fo.hwnd = m_hwnd;
    fo.wFunc = FO_DELETE;
    fo.pFrom = pFrom;
    fo.pTo = NULL;
    fo.fFlags = FOF_ALLOWUNDO;
    fo.fAnyOperationsAborted = FALSE;
    fo.hNameMappings = NULL;
    fo.lpszProgressTitle = NULL;

    HRESULT hr = S_OK;

    if ((SHFileOperation(&fo) !=0) || fo.fAnyOperationsAborted == TRUE)
    {
        hr = E_FAIL;
        CHECK_HRESULT(hr);
    }

    delete pFrom;

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
//
//  Display properties
//


// from ..\ps\jobpages.cxx
HRESULT
DisplayJobProperties(
    LPDATAOBJECT    pdtobj);


DWORD
__stdcall
JFPropertiesThread(
    LPVOID pvData)
{
    LPDATAOBJECT pdtobj = (LPDATAOBJECT)pvData;

    HRESULT hrOle = OleInitialize(NULL);

    __try
    {
        if (SUCCEEDED(hrOle))
        {
            ::DisplayJobProperties(pdtobj);
        }
    }
    __finally
    {
        pdtobj->Release();

        if (SUCCEEDED(hrOle))
        {
            OleUninitialize();
        }

        ExitThread(0);
    }

    return 0;
}


//____________________________________________________________________________
//
//  Member:     CJobsCM::_DisplayJobProperties
//
//  Arguments:  [hwnd] -- IN
//              [pwszJob] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/11/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobsCM::_DisplayJobProperties(
    HWND    hwnd,
    CJobID & jid)
{
    TRACE(CJobsCM, _DisplayJobProperties);

    Win4Assert(m_cidl == 1);

    HRESULT         hr = S_OK;
    LPDATAOBJECT    pdtobj = NULL;

    do
    {
        hr = JFGetDataObject(m_pszFolderPath,
                             m_pidlFolder,
                             m_cidl,
                             (LPCITEMIDLIST *)m_apidl,
                             FALSE,
                             (LPVOID *)&pdtobj);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        HANDLE  hThread;
        DWORD   idThread;

        hThread = CreateThread(NULL, 0, JFPropertiesThread,
                                                pdtobj, 0, &idThread);

        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            pdtobj->Release();
        }

    } while (0);

    return hr;
}


//____________________________________________________________________________
//
//  Function:   JFGetItemContextMenu
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//              [pScheduler] -- IN
//              [cidl] -- IN
//              [apidl] -- IN
//              [ppvOut] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/25/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetItemContextMenu(
    HWND hwnd,
    ITaskScheduler * pScheduler,
    LPCTSTR ptszMachine,
    LPCTSTR pszFolderPath,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    LPVOID * ppvOut)
{
    CJobsCM* pObj = new CJobsCM(hwnd, pScheduler, ptszMachine);

    if (NULL == pObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->InitInstance(pszFolderPath, pidlFolder, cidl, apidl);

    if (SUCCEEDED(hr))
    {
        hr = pObj->QueryInterface(IID_IContextMenu, ppvOut);
    }

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\jobidl.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       jobidl.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    1/24/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"
#include "resource.h"
#include "..\wizard\resource.h"
#include "..\inc\common.hxx"

#include "jobidl.hxx"
#include "sch_cls.hxx"  // sched\inc
#include "job_cls.hxx"  // sched\inc
#include "misc.hxx"     // sched\inc
#include "util.hxx"
#include "..\schedui\schedui.hxx"

void
SecurityErrorDialog(
    HWND    hWndOwner,
    HRESULT hr);


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    CJobID class implementation
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//+--------------------------------------------------------------------------
//
//  Member:     CJobID::InitToTemplate
//
//  Synopsis:   Inititialize this to represent a template object in the
//              folder.
//
//  History:    05-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CJobID::InitToTemplate()
{
    _id = ID_TEMPLATE;

    //
    // Name offset is at 1 so the first char can serve to make empty app
    // name, creator, and path strings.
    //

    _oCreator = 0;
    _oPath = 0;
    _oName = 1;

    LoadString(g_hInstance,
               IDS_TEMPLATE_NAME,
               &_cBuf[_oName],
               IDJOB_BUFFER_SIZE - 3);
    _cb = offsetof(CJobID, _cBuf) +
              (_oName + lstrlen(&_cBuf[_oName]) + 1) * sizeof(TCHAR);
             // ^^^ pidl size has to include offset into _cBuf

    _NullTerminate();
}


//____________________________________________________________________________
//
//  Member:     CJobID::Load
//
//  Arguments:  [pszFolderPath] -- IN
//              [pszJob] -- IN
//
//  Returns:    HRESULT.
//____________________________________________________________________________

HRESULT
CJobID::Load(
    LPCTSTR     pszFolderPath,
    LPTSTR      pszJob) // job path relative to Jobs folder with .job extension
{
    DEBUG_OUT((DEB_USER12,
              "[CJobID::Load] <%ws, %ws>\n",
              pszFolderPath ? (LPWSTR)pszFolderPath : L"NULL FolderPath",
              pszJob));

#if DBG==1
TCHAR * pExt = PathFindExtension(pszJob);
Win4Assert(lstrcmpi(pExt, TSZ_DOTJOB) == 0);
#endif

    HRESULT     hr = S_OK;
    CJob       *pJob = NULL;

    SecureZeroMemory(this, sizeof(CJobID));

    do
    {
        //
        //  Set creation & last write times
        //

        WCHAR   tcFile[MAX_PATH+1];
        LPTSTR  pFile = tcFile;

        if (pszFolderPath != NULL)
        {
            StringCchCopy(tcFile, MAX_PATH+1, pszFolderPath);
            StringCchCat(tcFile, MAX_PATH+1, TEXT("\\"));
            StringCchCat(tcFile, MAX_PATH+1, pszJob);
        }
        else
        {
            pFile = pszJob;
        }

        //
        // Skip hidden jobs.
        //

        if (GetFileAttributes(pFile) & FILE_ATTRIBUTE_HIDDEN)
        {
            return S_FALSE;
        }

        HANDLE  hFile = NULL;
        HRESULT hr = OpenFileWithRetry(pFile, GENERIC_READ, FILE_SHARE_READ, &hFile);
        if (FAILED(hr))
        {
            break;
        }

        if (GetFileTime(hFile, &_ftCreation, NULL, &_ftLastWrite) == FALSE)
        {
            CloseHandle(hFile);

            DEBUG_OUT_LASTERROR;
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        CloseHandle(hFile);

        //
        // Create & load the job
        //

        hr = ::JFCreateAndLoadCJob(pszFolderPath, pszJob, &pJob);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        _id = ID_JOB;

        ////////////////////////////////////////////////////////////
        //
        //  Extract the properties
        //

        //
        // Get last exit code
        //
        // The return value from this call is the task's last start error.
        //

        HRESULT hrLastStart = pJob->GetExitCode(&_dwExitCode);

        //
        //  Get a code to tell what to display in the "Status" column.
        //  For the purposes of this column the job can be:
        //      a. missed
        //      b. failed to start
        //      c. running
        //      d. other
        //

        ULONG ulAllFlags;

        pJob->GetAllFlags(&ulAllFlags);

        if (ulAllFlags & JOB_I_FLAG_MISSED)
        {
            _status = ejsMissed;
        }
        else if (FAILED(hrLastStart))
        {
           switch(hrLastStart)
           {
           case HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE):
              _status = ejsBadAcct;
              break;

           case HRESULT_FROM_WIN32(ERROR_ACCOUNT_RESTRICTION):
              _status = ejsResAcct;
              break;

           default:
              _status = ejsWouldNotStart;
           }

        }
        else
        {
            HRESULT hrStatus = 0;

            hr = pJob->GetStatus(&hrStatus);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            switch (hrStatus)
            {
            case SCHED_S_TASK_RUNNING:
                _status = ejsRunning;
                break;

            case SCHED_S_TASK_NOT_SCHEDULED:
                _status = ejsNotScheduled;
                break;
            }
        }

        //
        // Get last run time
        //

        hr = pJob->GetMostRecentRunTime(&_stLastRunTime);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        // ensure wDayOfWeek is 0, else memcmp fails.
        _stLastRunTime.wDayOfWeek = 0;

        //
        // Get next run time
        //

        hr = pJob->GetNextRunTime(&_stNextRunTime);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        // ensure wDayOfWeek is 0, else memcmp fails.
        _stNextRunTime.wDayOfWeek = 0;

        //
        //  Get the job flags
        //

        hr = pJob->GetFlags(&_ulJobFlags);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        //
        // Get the first job trigger if any
        //

        hr = pJob->GetTriggerCount(&_cTriggers);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (_cTriggers > 0)
        {
            ITaskTrigger * pIJobTrigger = NULL;

            hr = pJob->GetTrigger(0, &pIJobTrigger);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            _sJobTrigger.cbTriggerSize = sizeof(TASK_TRIGGER);

            hr = pIJobTrigger->GetTrigger(&_sJobTrigger);

            pIJobTrigger->Release();

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }
        else
        {
            _sJobTrigger.cbTriggerSize = 0;
        }


        ///////////////////////////////////////////////////////////////////
        //
        //  Fill up the buffer cBuf
        //

        USHORT cchCurr = 0;

        //
        //  Get the command
        //

        LPWSTR  pwszCommand = NULL;

        hr = pJob->GetApplicationName(&pwszCommand);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        StringCchCopy(_cBuf, IDJOB_BUFFER_SIZE, pwszCommand);
        CoTaskMemFree(pwszCommand);

        DEBUG_OUT((DEB_USER12, "Command = %ws\n", _cBuf));

        // update size
        cchCurr += lstrlen(_cBuf) + 1;


        //
        //  Get the account name
        //

        _oCreator = cchCurr;

        LPWSTR pwszCreator = NULL;

        hr = pJob->GetCreator(&pwszCreator);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        StringCchCopy(&_cBuf[_oCreator], IDJOB_BUFFER_SIZE - _oCreator, pwszCreator);
        CoTaskMemFree(pwszCreator);


        //  update size
        cchCurr += lstrlen(&_cBuf[_oCreator]) + 1;

        //
        //  Copy the job path
        //

        _oPath = cchCurr;

        if (pszFolderPath == NULL)
        {
            pszJob = PathFindFileName(pszJob);
        }

        StringCchCopy(&_cBuf[_oPath], IDJOB_BUFFER_SIZE - _oPath, pszJob);

        TCHAR * ptcPath = &_cBuf[_oPath];
        TCHAR * ptcName = PathFindFileName(ptcPath);
        TCHAR * ptcExtn = PathFindExtension(ptcName);

        if (ptcExtn)
        {
            *ptcExtn = TEXT('\0');
        }

        _oName = _oPath + (USHORT)(ptcName - ptcPath) * sizeof(TCHAR);

        // update buff size
        cchCurr += lstrlen(ptcPath) + 1;

        //
        //  Finaly set the size
        //

        _cb = offsetof(CJobID, _cBuf) + cchCurr * sizeof(TCHAR);

        //
        //  Ensure that the DWORD at the end is zero, used by ILClone, etc.
        //

        _NullTerminate();

    } while (0);

    if (pJob != NULL)
    {
        pJob->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobID::Rename
//
//  Synopsis:   Loads this object with data from jidIn, except for
//              the name which is set to lpszName.
//
//  Arguments:  [jidIn] -- IN
//              [lpszName] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
CJobID::Rename(
    CJobID &  jidIn,
    LPCOLESTR lpszNameIn)
{
    SecureZeroMemory(this, sizeof(CJobID));
    CopyMemory(this, &jidIn, jidIn.GetSize());

    LPTSTR lpszName = (LPTSTR)lpszNameIn;

    StringCchCopy(&_cBuf[_oName], IDJOB_BUFFER_SIZE - _oName, lpszName);

    _cb = offsetof(CJobID, _cBuf) +
             (_oName + lstrlen(lpszName) + 1) * sizeof(TCHAR);

    _NullTerminate();
    return S_OK;
}

//____________________________________________________________________________
//
//  Member:     CJobID::Clone
//
//  Returns:    CJobID *
//____________________________________________________________________________

CJobID *
CJobID::Clone(void)
{
    CJobID * pjid = (CJobID *) SHAlloc(_cb + sizeof(_cb));

    if (pjid)
    {
        CopyMemory(pjid, this, _cb);
        pjid->_NullTerminate();
    }

    return pjid;
}




#if (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Member:     CJobID::Validate
//
//  Synopsis:   Assert if this job idlist object is invalid
//
//  History:    12-04-1997   DavidMun   Created
//
//  Notes:      For debugging only.
//
//---------------------------------------------------------------------------

VOID
CJobID::Validate()
{
    //
    // Expect _cb to have been set to nonzero value
    //

    Win4Assert(_cb);
    Win4Assert(_cb < sizeof(CJobID));

    //
    // Expect all jobids to have a name.  Offset should be nonzero because
    // name is not the first string.
    //

    Win4Assert(_oName < IDJOB_BUFFER_SIZE);

    //
    // Expect that name is null terminated before the end of the buffer.
    //

    Win4Assert(_oName + lstrlen(GetName()) < IDJOB_BUFFER_SIZE);

    //
    // Expect the jobid itself to be null terminated
    //

    UNALIGNED USHORT *pusNextCB = (UNALIGNED USHORT *)(((BYTE *)this) + _cb);
    Win4Assert(_cb + sizeof(USHORT) <= sizeof(CJobID));
    Win4Assert(!*pusNextCB);
}

#endif // (DBG == 1)



BOOL
GetLocaleDateTimeString(
    SYSTEMTIME*     pst,
    DWORD           dwDateFlags,
    DWORD           dwTimeFlags,
    TCHAR           szBuff[],
    int             cchBuffLen,
    LPSHELLDETAILS  lpDetails);
//____________________________________________________________________________
//
//  Member:     CJobID::GetNextRunTimeString
//
//  Synopsis:   S
//
//  Arguments:  [tcBuff] -- IN
//              [cchBuff] -- IN
//              [fForComparison] -- IN
//
//  Returns:    HRESULT.
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

LPTSTR
CJobID::GetNextRunTimeString(
    TCHAR           tcBuff[],
    UINT            cchBuff,
    BOOL            fForComparison,
    LPSHELLDETAILS  lpDetails)
{
    if (this->IsJobNotScheduled() == TRUE)
    {
        LoadString(g_hInstance, IDS_NEVER, tcBuff, cchBuff);
    }
    else if (this->IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
    {
        LoadString(g_hInstance, IDS_DISABLED, tcBuff, cchBuff);
    }
    else if (this->IsTriggerFlagOn(TASK_TRIGGER_FLAG_DISABLED))
    {
        LoadString(g_hInstance, IDS_TRIGGER_DISABLED, tcBuff, cchBuff);
    }
    else if (this->GetTriggerType() == TASK_EVENT_TRIGGER_AT_SYSTEMSTART)
    {
        LoadString(g_hInstance, IDS_ON_STARTUP, tcBuff, cchBuff);
    }
    else if (this->GetTriggerType() == TASK_EVENT_TRIGGER_AT_LOGON)
    {
        LoadString(g_hInstance, IDS_ON_LOGON, tcBuff, cchBuff);
    }
    else if (this->GetTriggerType() == TASK_EVENT_TRIGGER_ON_IDLE)
    {
        LoadString(g_hInstance, IDS_WHEN_IDLE, tcBuff, cchBuff);
    }
    else
    {
        SYSTEMTIME &st = this->GetNextRunTime();

        if (st.wYear == 0 || st.wMonth == 0 || st.wDay == 0)
        {
            LoadString(g_hInstance, IDS_NEVER, tcBuff, cchBuff);
        }
        else
        {
            if (fForComparison == TRUE)
            {
                return NULL;
            }

            GetLocaleDateTimeString(&st, DATE_SHORTDATE, 0, tcBuff, cchBuff, lpDetails);
        }
    }

    return tcBuff;
}

//____________________________________________________________________________
//
//  Function:   HDROPFromJobIDList
//
//  Synopsis:   Create an HDROP for the files in the apjid array.
//              Used for CF_HDROP format.
//
//  Arguments:  [cidl] -- IN
//              [apjidl] -- IN
//
//  Returns:    HDROP
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HDROP
HDROPFromJobIDList(
    LPCTSTR     pszFolderPath,
    UINT        cidl,
    PJOBID    * apjidl)
{
    HDROP            hMem = 0;
    LPDROPFILESTRUCT lpDrop;
    DWORD            dwSize = 0;

    if (cidl == 0)
    {
        return NULL;
    }

    TCHAR tcFolder[MAX_PATH +1];
    StringCchCopy(tcFolder, MAX_PATH +1, pszFolderPath);
    StringCchCat(tcFolder, MAX_PATH +1, TEXT("\\"));

    USHORT cbFolderPathLen = (USHORT)(lstrlen(tcFolder) * sizeof(TCHAR));

    //
    //  Walk the list and find out how much space we need.
    //

    dwSize = sizeof(DROPFILESTRUCT) + sizeof(TCHAR);  // size + terminal nul


    USHORT * pusPathLen = new USHORT[cidl * 2];

    if (pusPathLen == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    USHORT * pusExtLen = &pusPathLen[cidl];

    for (UINT i=0; i < cidl; i++)
    {
        pusPathLen[i] = (USHORT)(lstrlen(apjidl[i]->GetPath()) * sizeof(TCHAR));

        pusExtLen[i]  = (USHORT)((lstrlen(apjidl[i]->GetExtension()) + 1) * sizeof(TCHAR));

        dwSize += cbFolderPathLen + pusPathLen[i] + pusExtLen[i];
    }

    //
    //  If it's bigger than the struct can hold, then bail.
    //  TODO: Return an error?
    //

    if (dwSize > 0x0000ffff)
    {
        delete [] pusPathLen;
        return NULL;
    }

    //
    //  Allocate the buffer and fill it in.
    //

    hMem = (HDROP)GlobalAlloc(GHND, dwSize);

    if (hMem == NULL)
    {
        delete [] pusPathLen;
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    lpDrop = (LPDROPFILESTRUCT) GlobalLock(hMem);

    lpDrop->pFiles = (DWORD)(sizeof(DROPFILESTRUCT));
    lpDrop->pt.x   = 0;
    lpDrop->pt.y   = 0;
    lpDrop->fNC    = FALSE;
    lpDrop->fWide  = TRUE;

    //
    //  Fill in the path names.
    //

    LPBYTE pbTemp = (LPBYTE) ((LPBYTE) lpDrop + lpDrop->pFiles);

    for (i=0; i < cidl; i++)
    {
        CopyMemory(pbTemp, tcFolder, cbFolderPathLen);
        pbTemp += cbFolderPathLen;

        CopyMemory(pbTemp, apjidl[i]->GetPath(), pusPathLen[i]);
        pbTemp += pusPathLen[i];

        CopyMemory(pbTemp, apjidl[i]->GetExtension(), pusExtLen[i]);
        pbTemp += pusExtLen[i];
    }

    *((LPTSTR)pbTemp) = TEXT('\0');  // Extra Nul terminate

    //
    //  Unlock the buffer and return it.
    //

    GlobalUnlock(hMem);

    delete [] pusPathLen;

    return hMem;
}




//+--------------------------------------------------------------------------
//
//  Function:   CreateIDListArray
//
//  Synopsis:   Create shell idlist array in the format required by the
//              CFSTR_SHELLIDLIST clipboard format.
//
//  Arguments:  [pidlFolder] - pidl of tasks folder
//              [cidl]       - number of elements in [apjidl]
//              [apjidl]     - array of pointers to idls, each idl
//                             specifies a .job object.
//
//  Returns:    Handle to created array, or NULL on error.
//
//  History:    05-30-1997   DavidMun   Created
//
//  Notes:      For this format, the first element in the array is an
//              absolute idl to a container (the tasks folder), and the
//              remainder (each a single .job object) are relative to the
//              first.
//
//---------------------------------------------------------------------------

HGLOBAL
CreateIDListArray(
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    PJOBID         *apjidl)
{
    TRACE_FUNCTION(CreateIDListArray);

    Win4Assert(cidl);
    if (cidl == 0)
    {
        return NULL;
    }

    HJOBIDA hJobIDA = NULL;
    DWORD   offset = sizeof(CJobIDA) + sizeof(UINT) * cidl;
    DWORD   dwSize = offset;

    for (UINT i=0; i < cidl ; i++)
    {
        dwSize += apjidl[i]->GetSize() + 2; // +2 for null list terminator
    }

    dwSize += ILGetSize(pidlFolder);

    hJobIDA = GlobalAlloc(GPTR, dwSize);  // This MUST be GlobalAlloc!!!

    if (hJobIDA == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    PJOBIDA pJobIDA = (PJOBIDA)hJobIDA;       // no need to lock

    pJobIDA->cidl = cidl;           // count doesn't include idl at offset 0,
    pJobIDA->aoffset[0] = offset;   // which is container

    CopyMemory(((LPBYTE)pJobIDA)+offset, pidlFolder, ILGetSize(pidlFolder));
    offset += ILGetSize(pidlFolder);

    for (i=0; i < cidl ; i++)
    {
        UINT cbSize = apjidl[i]->GetSize();

        pJobIDA->aoffset[i+1] = offset;

        CopyMemory(((LPBYTE)pJobIDA)+offset, apjidl[i], cbSize);

        offset += cbSize + 2; // +2 to leave null after copied in idl
    }

    Win4Assert(offset == dwSize);
    return hJobIDA;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    CJobIDA related functions.
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   HJOBIDA_Create
//
//  Synopsis:   Create an HJOBIDA for the files in the apjid array.
//              Used for CF_JOBIDLIST data format.
//
//  Arguments:  [cidl] -- IN
//              [apjidl] -- IN
//
//  Returns:    HJOBIDA
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HJOBIDA
HJOBIDA_Create(
    UINT        cidl,
    PJOBID    * apjidl)
{
    if (cidl == 0)
    {
        return NULL;
    }

    HJOBIDA hJobIDA = NULL;
    DWORD   offset = sizeof(CJobIDA) + sizeof(UINT) * (cidl - 1);
    DWORD   dwSize = offset;

    for (UINT i=0; i < cidl ; i++)
    {
        dwSize += apjidl[i]->GetSize() + 2;  // +2 for null list terminator
    }

    hJobIDA = GlobalAlloc(GPTR, dwSize);  // This MUST be GlobalAlloc with
                                          // GPTR!

    if (hJobIDA == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return NULL;
    }

    PJOBIDA pJobIDA = (PJOBIDA)hJobIDA;       // no need to lock

    pJobIDA->cidl = cidl;

    //
    // Note that apjidl[i] reports its true size, which doesn't include the
    // extra 0 ulong following it.  That null terminator is required, and
    // isn't copied into pJobIDA by the CopyMemory, which is using
    // apjidl[i]'s reported size.
    //
    // Since the GPTR ensures zero-initialized memory, and the extra 2
    // bytes per jobid has been accounted for in computing dwSize, we can
    // get the terminator just by increasing offset by the terminator size
    // on each iteration.
    //

    for (i=0; i < cidl ; i++)
    {
        UINT cbSize = apjidl[i]->GetSize();

        pJobIDA->aoffset[i] = offset;

        CopyMemory(((LPBYTE)pJobIDA)+offset, apjidl[i], cbSize);

        offset += cbSize + 2;
    }

    Win4Assert(offset == dwSize);

    return hJobIDA;
}

void
HJOBIDA_Free(
    HJOBIDA hJobIDA)
{
    GlobalFree(hJobIDA);           // This MUST be GlobalFree
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    Functions to clone and free a LPCITEMIDLIST array.
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   ILA_Clone
//
//  Synopsis:   S
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//
//  Returns:    LPITEMIDLIST
//
//  History:    1/9/1996   RaviR   Created
//
//____________________________________________________________________________

LPITEMIDLIST*
ILA_Clone(
    UINT            cidl,
    LPCITEMIDLIST * apidl)
{
    TRACE_FUNCTION(ILA_Clone);

    LPITEMIDLIST* aNewPidl = new LPITEMIDLIST[cidl];

    if (NULL == aNewPidl)
    {
        return NULL;
    }

    for (UINT i = 0; i < cidl; i++)
    {
        aNewPidl[i] = ILClone(apidl[i]);

        if (NULL == aNewPidl[i])
        {
            // delete what we've allocated so far
            for (UINT j = 0; j < i; j++)
            {
                ILFree(aNewPidl[i]);
            }

            delete[] aNewPidl;

            return NULL;
        }
    }

    return aNewPidl;
}



//____________________________________________________________________________
//
//  Function:   ILA_Free
//
//  Synopsis:   S
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//
//  Returns:    VOID
//
//  History:    1/9/1996   RaviR   Created
//
//____________________________________________________________________________

VOID
ILA_Free(
    UINT            cidl,
    LPITEMIDLIST  * apidl)
{
    TRACE_FUNCTION(ILA_Free);

    for (UINT i = 0; i < cidl; i++)
    {
        ILFree(apidl[i]);
    }

    delete [] apidl;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    Functions to access the CJob & CSchedule
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//____________________________________________________________________________
//
//  Function:   JFGetJobScheduler
//
//  Synopsis:   S
//
//  Arguments:  [ppJobScheduler] -- IN
//              [ppwszFolderPath] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetJobScheduler(
    LPTSTR             pszMachine,
    ITaskScheduler **  ppJobScheduler,
    LPCTSTR           *ppszFolderPath)
{
    HRESULT     hr = S_OK;
    CSchedule * pCSchedule = NULL;

    do
    {
        pCSchedule = new CSchedule;

        if (pCSchedule == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        hr = pCSchedule->Init();

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (pszMachine != NULL)
        {
            hr = pCSchedule->SetTargetComputer(pszMachine);
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }

        *ppszFolderPath = pCSchedule->GetFolderPath();

        *ppJobScheduler = (ITaskScheduler *)pCSchedule;

    } while (0);

    if (FAILED(hr) && pCSchedule != NULL)
    {
        pCSchedule->Release();
    }

    return hr;
}



//____________________________________________________________________________
//
//  Member:     CreateAndLoadCJob
//
//  Arguments:  [pszJob] -- IN
//              [ppJob] -- OUT
//
//  Returns:    HRESULT.
//____________________________________________________________________________

HRESULT
JFCreateAndLoadCJob(
    LPCTSTR     pszFolderPath,
    LPTSTR      pszJob,  // job path relative to the folder
    CJob     ** ppJob)
{
    TRACE_FUNCTION(CreateAndLoadCJob);

    *ppJob = NULL; // init for failure

    CJob  *pJob = CJob::Create();

    if (pJob == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    TCHAR   buff[MAX_PATH +1];
    LPTSTR  pszJobPathTemp = pszJob;

    if (pszFolderPath != NULL)
    {
        StringCchCopy(buff, MAX_PATH +1, pszFolderPath);
        StringCchCat(buff, MAX_PATH +1, TEXT("\\"));
        StringCchCat(buff, MAX_PATH +1, pszJob);

        pszJobPathTemp = buff;
    }

    HRESULT hr = S_OK;

    LPWSTR pwszJobPath = pszJobPathTemp;

    DEBUG_OUT((DEB_USER1, "Load Job <%ws>\n", pwszJobPath));

    hr = pJob->Load(pwszJobPath, STGM_READWRITE | STGM_SHARE_EXCLUSIVE);

    if (FAILED(hr))
    {
        pJob->Release();
        CHECK_HRESULT(hr);
        return hr;
    }

    //
    // Success, return the object
    //

    *ppJob = pJob;
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   JFCreateAndLoadTask
//
//  Synopsis:   Create an in-memory task object and initialize it from
//              [pszJob], returning the ITask interface on the object.
//
//  Arguments:  [pszFolderPath] - path to tasks folder
//              [pszJob]        - filename of job
//              [ppITask]       - filled with ITask interface ptr
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppITask]
//
//  History:    10-07-1997   DavidMun   Created
//
//  Notes:      Caller must Release returned interface.
//
//---------------------------------------------------------------------------

HRESULT
JFCreateAndLoadTask(
    LPCTSTR     pszFolderPath,
    LPTSTR      pszJob,  // job path relative to the folder
    ITask    ** ppITask)
{
    TRACE_FUNCTION(CreateAndLoadTask);
    HRESULT hr;
    CJob *pJob;

    hr = JFCreateAndLoadCJob(pszFolderPath, pszJob, &pJob);

    if (SUCCEEDED(hr))
    {
        hr = pJob->QueryInterface(IID_ITask, (void **)ppITask);
        pJob->Release();
    }

    return hr;
}

//____________________________________________________________________________
//
//  Function:   JFSaveJob
//
//  Synopsis:   Save task settings to storage via the task's IPersistFile
//              interface. Also, if applicable, prompt the user for security
//              account information.
//
//  Arguments:  [hwndOwner]                          -- Owner window.
//              [pIJob]                              -- Target task object.
//              [fSecuritySupported]                 -- Flag indicating if
//                                                      security-specific code
//                                                      should be invoked.
//              [fTaskAccountChange]                 -- TRUE, the task account
//                                                      information has
//                                                      changed.
//              [fTaskApplicationChange]             -- TRUE, the task
//                                                      application has
//                                                      changed.
//              [fSuppressAccountInformationRequest] -- TRUE, do not prompt
//                                                      the user for account
//                                                      information.
//
//  Returns:    HRESULT
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFSaveJob(
    HWND    hwndOwner,
    ITask * pITask,
    BOOL    fSecuritySupported,
    BOOL    fTaskAccountChange,
    BOOL    fTaskApplicationChange,
    BOOL    fSuppressAccountInformationRequest)
{
    AccountInfo    AcctInfo;
    HRESULT        hr;
    IPersistFile * pipfTask;
    WCHAR *        pwszAccountName = NULL;
    BOOL           fChangesSaved   = FALSE;

    hr = pITask->QueryInterface(IID_IPersistFile, (void **)&pipfTask);

    if (FAILED(hr))
    {
        return hr;
    }

    if (fSecuritySupported)
    {
        InitializeAccountInfo(&AcctInfo);

        //
        // Application change but no corresponding account information change.
        // Launch the set account information dialog in this case.
        //

        if (fTaskApplicationChange && !fTaskAccountChange)
        {
            //
            // Attempt to retreive account information for the set account
            // information dialog. Ignore failures, we would just like to
            // have something to fill in the account name control.
            //

            if (SUCCEEDED(pITask->GetAccountInformation(&pwszAccountName)))
            {
                AcctInfo.pwszAccountName = pwszAccountName;
            }

            goto SetAccountInformationDlg;
        }
    }

    //
    // Go ahead and save the changes.
    //

    hr = pipfTask->Save(NULL, FALSE);
    fChangesSaved = TRUE;

    if (fSecuritySupported)
    {
        if (FAILED(hr))
        {
            if (pipfTask->IsDirty() == S_FALSE)
            {
                //
                // If Save failed, yet the job is no longer dirty, the
                // error is due to a failure setting security information.
                //
                // Let the user know there was a problem. Remap the return
                // code so we don't get further error dialogs.
                //

                CHECK_HRESULT(hr);
                SecurityErrorDialog(hwndOwner, hr);
                hr = S_OK;
            }
#if DBG == 1
            else
            {
                //
                // Standard persist code failure. Calling page code will
                // put up an error dialog.
                //

                CHECK_HRESULT(hr);
            }
#endif // DBG == 1

            goto CleanExit;
        }

        if (!fTaskAccountChange)
        {
            //
            // No account information changes. Verify that this job does
            // indeed have account information associated with it.
            //

            hr = pITask->GetAccountInformation(&pwszAccountName);

            if (hr == SCHED_E_ACCOUNT_INFORMATION_NOT_SET)
            {
                //
                // No account information. Launch the set account information
                // dialog.
                //

                hr = S_OK;
                goto SetAccountInformationDlg;
            }
            else if (SUCCEEDED(hr))
            {
                //
                // Done.
                //

                goto CleanExit;
            }
            else
            {
                //
                // In error cases, silently fail. There's nothing we can do
                // about it other than confuse the user. Remapping the return
                // code so the calling page code doesn't put up an error
                // dialog.
                //

                CHECK_HRESULT(hr);
                hr = S_OK;
                goto CleanExit;
            }
        }
        else if (fTaskApplicationChange && fTaskAccountChange)
        {
            //
            // Fetch cached account information from the job object for
            // the pending set account information dialog. Silently fail
            // in an error case.
            //

            hr = pITask->GetAccountInformation(&pwszAccountName);

            Win4Assert(hr != SCHED_E_ACCOUNT_INFORMATION_NOT_SET);

            if (FAILED(hr) || hr == S_FALSE)
            {
                //
                // The information is cached. This would fail for no
                // reason other than insufficient memory.
                //
                // Though, did we goof?
                //

                CHECK_HRESULT(hr);
                hr = S_OK;
                goto CleanExit;
            }

            AcctInfo.pwszAccountName = pwszAccountName;
        }
        else
        {
            //
            // Done.
            //

            goto CleanExit;
        }
    }
    else
    {
        CHECK_HRESULT(hr);
        goto CleanExit;
    }

SetAccountInformationDlg:

    //
    // Should've arrived here only for security reasons.
    //

    Win4Assert(fSecuritySupported);

    //
    // Can only arrive at this point if the user must specify security
    // account information.
    //
    // Launch the set account information dialog.
    //

    if (!fSuppressAccountInformationRequest)
    {
        LaunchSetAccountInformationDlg(hwndOwner, &AcctInfo);

        //
        // Check if the data is dirty. On dialog entry, the password is set
        // to the global empty string. If the password ptr still equals this,
        // then the user didn't change the password (e.g. the user canceled
        // the dialog).
        //

        if (AcctInfo.pwszAccountName != NULL &&
            AcctInfo.pwszPassword != tszEmpty)
        {
            //
            // Reset the account information and persist the changes.
            //

            hr = pITask->SetAccountInformation(AcctInfo.pwszAccountName,
                                               AcctInfo.pwszPassword);

            fChangesSaved = FALSE;

            if (FAILED(hr))
            {
                goto CleanExit;
            }
        }
    }

    if (!fChangesSaved)
    {
        CWaitCursor WaitCursor;
        hr = pipfTask->Save(NULL, FALSE);

        if (FAILED(hr) && pipfTask->IsDirty() == S_FALSE)
        {
            //
            // Similar check as above. General save succeeded but the attempt
            // to set security information failed. Let the user know there
            // was a problem and remap the return code so we don't get
            // further dialogs.
            //

            SecurityErrorDialog(hwndOwner, hr);
            hr = S_OK;
        }
#if DBG == 1
        else
        {
            CHECK_HRESULT(hr);
        }
#endif // DBG == 1
    }

CleanExit:
    pipfTask->Release();
    if (fSecuritySupported)
    {
        ResetAccountInfo(&AcctInfo);
    }

    return hr;
}

//____________________________________________________________________________
//
//  Function:   SecurityErrorDialog
//
//  Synopsis:   Map the error to a hopefully friendly & informative dialog.
//
//  Arguments:  [hWndOwner] -- Parent window handle.
//              [hr]        -- Security error to map.
//
//  Returns:    None.
//
//  Notes:      None.
//
//____________________________________________________________________________
void
SecurityErrorDialog(
    HWND    hWndOwner,
    HRESULT hr)
{
    int  idsErrorMessage;
    UINT idsHelpHint;

    idsErrorMessage = IERR_SECURITY_WRITE_ERROR;

    if (hr == SCHED_E_ACCOUNT_NAME_NOT_FOUND)
    {
        idsHelpHint = IDS_HELP_HINT_INVALID_ACCT;
    }
    else if (hr == SCHED_E_ACCOUNT_DBASE_CORRUPT)
    {
        idsHelpHint = IDS_HELP_HINT_DBASE_CORRUPT;
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
    {
        idsHelpHint = IDS_HELP_HINT_ACCESS_DENIED;
    }
    else if (hr == SCHED_E_SERVICE_NOT_RUNNING ||
             HRESULT_FACILITY(hr) == FACILITY_RPC)
    {
        idsHelpHint = IDS_HELP_HINT_SEC_GENERAL;
    }
    else
    {
        //
        // No help hint for unexpected errors.
        //

        idsHelpHint = 0;
    }

    //
    // Put up the error dialog.
    //

    SchedUIErrorDialog(hWndOwner, idsErrorMessage, hr, idsHelpHint);
}


//____________________________________________________________________________
//
//  Function:   JFGetAppNameForTask
//
//  Synopsis:   S
//
//  Arguments:  [path] -- IN
//              [pszAppName] -- IN
//              [cchAppName] -- IN
//
//  Returns:    HRESULT
//
//  History:    4/25/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetAppNameForTask(
    LPCTSTR     pszTask,        // Full path
    LPTSTR      pszAppName,
    UINT        cchAppName)
{
    TRACE_FUNCTION(JFGetAppNameForTask);

    HRESULT hr = S_OK;

    CJob  *pJob = CJob::Create();

    if (pJob == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    hr = pJob->LoadP(pszTask, 0, FALSE, FALSE);

    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        LPWSTR pwszCommand = NULL;

        hr = pJob->GetApplicationName(&pwszCommand);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            StringCchCopy(pszAppName, cchAppName, pwszCommand);
            DEBUG_OUT((DEB_USER1, "JFGetAppNameForTask -> %ws\n", pszAppName));

            CoTaskMemFree(pwszCommand);
        }
    }

    pJob->Release();

    return hr;
}





BOOL
IsAScheduleObject(
    TCHAR szFile[])
{
	if( NULL == szFile )
	{
		return FALSE;
	}

    LPTSTR  pszName = PathFindFileName(szFile);
    LPTSTR  pszExt = PathFindExtension(pszName);

    if (lstrcmpi(pszExt, TSZ_DOTJOB) != 0)
        // && (lstrcmpi(pszExt, g_szDotQue) != 0)
    {
        return FALSE;
    }

    return TRUE;
}



//____________________________________________________________________________
//
//  Function:   JFCopyJob
//
//  Synopsis:   S
//
//  Arguments:  [hwndOwner] -- IN
//              [szFileFrom] -- IN
//              [pszFolderPath] -- IN
//              [fMove] -- IN
//
//  Returns:    HRESULT
//
//  History:    2/2/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFCopyJob(
    HWND        hwndOwner,
    TCHAR       szFileFrom[],
    LPCTSTR     pszFolderPath,
    BOOL        fMove)
{
    HRESULT hr = S_OK;
    ITask * pJob = NULL;

    LPTSTR  pszName = PathFindFileName(szFileFrom);

    hr = JFCreateAndLoadTask(NULL, szFileFrom, &pJob);

    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_DATA))
        {
            SchedUIErrorDialog(hwndOwner, IERR_INVALID_DATA, pszName);
        }

        return hr;
    }
    else
    {
        pJob->Release();
    }

    TCHAR   szFileTo[MAX_PATH+1];
    StringCchCopy(szFileTo, MAX_PATH +1, pszFolderPath);

    SHFILEOPSTRUCT fo = {hwndOwner, (fMove ? FO_MOVE : FO_COPY), szFileFrom,
                         szFileTo, FOF_ALLOWUNDO, FALSE, NULL, NULL};

    // Make sure we have double trailing NULL!
    *(szFileFrom + lstrlen(szFileFrom) + 1) = TEXT('\0');

    if ((SHFileOperation(&fo) !=0) || fo.fAnyOperationsAborted == TRUE)
    {
        hr = E_FAIL;
        CHECK_HRESULT(hr);
        return hr;
    }

    //SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATH, szFileFrom, szFileTo);

    return hr;
}


//____________________________________________________________________________
//
//  Function:   GetTriggerStringFromTrigger
//
//  Synopsis:   S
//
//  Arguments:  [pJobTrigger] -- IN
//              [psTrigger] -- IN
//              [cchTrigger] -- IN
//
//  Returns:    HRESULT
//____________________________________________________________________________

HRESULT
GetTriggerStringFromTrigger(
    TASK_TRIGGER  * pJobTrigger,
    LPTSTR          psTrigger,
    UINT            cchTrigger,
    LPSHELLDETAILS  lpDetails)
{
    HRESULT     hr = S_OK;
    LPWSTR      pwsz = NULL;

    if (pJobTrigger->cbTriggerSize > 0)
    {
        hr = ::StringFromTrigger(pJobTrigger, &pwsz, lpDetails);

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            if (pwsz)
            {
                StringCchCopy(psTrigger, cchTrigger, pwsz);
                CoTaskMemFree(pwsz);
            }
            else
                return E_FAIL;
        }
    }
    else
    {
        LoadString(g_hInstance, IDS_JOB_NOT_SCHEDULED, psTrigger, cchTrigger);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
////////
////////    Misc functions.
////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

LPITEMIDLIST *
SHIDLFromJobIDL(
    UINT        cidl,
    PJOBID    * apjidl)
{
    LPITEMIDLIST * apidlOut = (LPITEMIDLIST *)SHAlloc(
                                            sizeof(LPITEMIDLIST) * cidl);

    if (apidlOut)
    {
        for (UINT i=0; i < cidl; i++)
        {
            apidlOut[i] = ILCreateFromPath(apjidl[i]->GetPath());

            if (apidlOut[i] == NULL)
            {
                break;
            }
        }

        if (i < cidl) // => memory error
        {
            while (i--)
            {
                ILFree(apidlOut[i]);
            }

            SHFree(apidlOut);

            apidlOut = NULL;
        }
    }

#if DBG==1
    if (apidlOut == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
    }
#endif

    return apidlOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\policy.cxx ===
//+---------------------------------------------------------------------------
//
//  Scheduling Agent Service
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       policy.cxx
//
//  Contents:   Functions for implementing policy checking
//
//  Classes:    None.
//
//  Functions:  RegReadPolicyKey
//
//  History:    04/23/98   CameronE   created
//
//----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "..\inc\policy.hxx"
#include "..\inc\debug.hxx"
#include <StrSafe.h>

//+---------------------------------------------------------------------------
//
//  Function:   RegReadPolicyKey
//
//  Synopsis:   Determine whether a specified policy value is in the registry
//              and is on (exists, value > 0x0).  Policy on means deny
//              the user permission to do a particular action in the UI only.
//
//  Arguments:  [lpszValue]     -- value name, appended to the base key
//
//  Returns:    BOOL - true for value > 0 (policy active)
//
//  Notes:      None.
//
//  History:    4/14/98  CameronE - created
//
//----------------------------------------------------------------------------
BOOL
RegReadPolicyKey(
                 LPCTSTR lpszValue)
{
    // TRACE_FUNCTION(RegReadPolicyKey) is too verbose
    schDebugOut((DEB_USER6, "RegReadPolicyKey\n"));
    // CODEWORK:  This function is called way too often.  See if we can cache
    // the results, or at least keep the key handle open.

    HKEY keyPolicy;
    BOOL fPolicy = FALSE;
    DWORD dwType;
    DWORD dwData;
    DWORD dwDataSize = sizeof(DWORD);

    //
    // It is possible to have a policy key under HKLM and/or HKCU
    // We assume that HKCU can shutoff what HKLM enables, but not vice
    // versa.
    //

    LONG lerr = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              TS_KEYPOLICY_BASE,
                              0,
                              KEY_READ,
                              &keyPolicy);
	
    if (lerr == ERROR_SUCCESS)
    {
        lerr = RegQueryValueEx( keyPolicy,
                                lpszValue,
                                NULL,
                                &dwType,
                                (BYTE *) &dwData,
                                &dwDataSize);
		
        if (lerr == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                fPolicy = (dwData > 0);
            }
            else
            {
                schDebugOut((DEB_ITRACE, "HKLM Policy value not a DWORD!\n"));
            }
        }

        RegCloseKey(keyPolicy);
    }
	
    //
    // If HKLM policy value has shut off part of the UI on this machine,
    // return it now, so that HKCU cannot override a stricter machine policy.
    //

    if (fPolicy)
    {
        return fPolicy;
    }

	
    //
    // Otherwise, see if maybe it's just this user that can't do this task
    //
	
    lerr = RegOpenKeyEx( HKEY_CURRENT_USER,
                         TS_KEYPOLICY_BASE,
                         0,
                         KEY_READ,
                         &keyPolicy);

    dwDataSize = sizeof(DWORD);
	
    if (lerr == ERROR_SUCCESS)
    {
        lerr = RegQueryValueEx( keyPolicy,
                                lpszValue,
                                NULL,
                                &dwType,
                                (BYTE *) &dwData,
                                &dwDataSize);
		
        if (lerr == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
            {
                fPolicy = (dwData > 0);
            }
            else
            {
                schDebugOut((DEB_ITRACE, "HKCU Policy value not a DWORD!\n"));
            }
        }

        RegCloseKey(keyPolicy);
    }
	
    return fPolicy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\ole.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1995.
//
//  File:       ole.cxx
//
//  Contents:   IUnknown & IClassFactory for all OLE objects
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "guids.h"
#include "dll.hxx"
#include <mstask.h>     // Necessary for util.hxx/schedui.hxx inclusion.
#include "util.hxx"
#include "..\schedui\schedui.hxx"
#include <StrSafe.h>


//____________________________________________________________________________
//
//  Class:      CJobFolderCF
//
//  Purpose:    Class factory to create CJobFolder.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________


class CJobFolderCF : public IClassFactory
{
public:
    // IUnknown methods
    DECLARE_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);
};

STDMETHODIMP
CJobFolderCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObj = (IUnknown*)(IClassFactory*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CJobFolderCF::AddRef()
{
    return CDll::AddRef();
}

STDMETHODIMP_(ULONG)
CJobFolderCF::Release()
{
    return CDll::Release();
}

STDMETHODIMP
CJobFolderCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        return E_NOTIMPL;  // don't support aggregation
    }

    return JFGetJobFolder(riid, ppvObj);
}

STDMETHODIMP
CJobFolderCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);

    return S_OK;
}



//____________________________________________________________________________
//
//  Class:      CSchedObjExtCF
//
//  Purpose:    Class factory to create CSchedObjExt.
//
//  History:    4/25/1996   RaviR   Created
//____________________________________________________________________________


class CSchedObjExtCF : public IClassFactory
{
public:
    // IUnknown methods
    DECLARE_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);
};

STDMETHODIMP
CSchedObjExtCF::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObj = (IUnknown*)(IClassFactory*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CSchedObjExtCF::AddRef()
{
    return CDll::AddRef();
}

STDMETHODIMP_(ULONG)
CSchedObjExtCF::Release()
{
    return CDll::Release();
}

STDMETHODIMP
CSchedObjExtCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        return E_NOTIMPL;  // don't support aggregation
    }

    return JFGetSchedObjExt(riid, ppvObj);
}

STDMETHODIMP
CSchedObjExtCF::LockServer(BOOL fLock)
{
    CDll::LockServer(fLock);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////


JF_IMPLEMENT_CLASSFACTORY(CTaskIconExt);

STDMETHODIMP
CTaskIconExtCF::CreateInstance(IUnknown* pUnkOuter, REFIID riid, LPVOID* ppvObj)
{
    if (pUnkOuter != NULL)
    {
        return E_NOTIMPL;  // don't support aggregation
    }

    return JFGetTaskIconExt(riid, ppvObj);
}



//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////

CJobFolderCF   * pcfJobFolder   = NULL;
CSchedObjExtCF * pcfSchedObjExt = NULL;
CTaskIconExtCF * pcfTaskIconExt = NULL;

HRESULT
JFGetClassObject(
    REFCLSID cid,
    REFIID   riid,
    LPVOID * ppvObj)
{
    CDllRef DllRef;   // don't nuke me now!

    if (IsEqualCLSID(cid, CLSID_CJobFolder))
    {
        if (pcfJobFolder != NULL)
        {
            return pcfJobFolder->QueryInterface(riid, ppvObj);
        }
        else
        {
            return E_FAIL;
        }
    }
    else if (IsEqualCLSID(cid, CLSID_CSchedObjExt))
    {
        if (pcfSchedObjExt != NULL)
        {
            return pcfSchedObjExt->QueryInterface(riid, ppvObj);
        }
        else
        {
            return E_FAIL;
        }
    }
    else if (IsEqualCLSID(cid, CLSID_CTaskIconExt))
    {
        if (pcfTaskIconExt != NULL)
        {
            return pcfTaskIconExt->QueryInterface(riid, ppvObj);
        }
        else
        {
            return E_FAIL;
        }
    }

    return E_NOINTERFACE;
}

HRESULT
AllocFolderCFs(void)
{
    pcfJobFolder = new CJobFolderCF;
    if (pcfJobFolder == NULL)
    {
        return E_OUTOFMEMORY;
    }
    pcfSchedObjExt = new CSchedObjExtCF;
    if (pcfSchedObjExt == NULL)
    {
        delete pcfJobFolder;
        pcfJobFolder = NULL;
        return E_OUTOFMEMORY;
    }
    pcfTaskIconExt = new CTaskIconExtCF;
    if (pcfTaskIconExt == NULL)
    {
        delete pcfJobFolder;
        pcfJobFolder = NULL;
        delete pcfSchedObjExt;
        pcfSchedObjExt = NULL;
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

void
FreeFolderCFs(void)
{
    if (pcfJobFolder != NULL)
    {
        delete pcfJobFolder;
        pcfJobFolder = NULL;
    }
    if (pcfSchedObjExt != NULL)
    {
        delete pcfSchedObjExt;
        pcfSchedObjExt = NULL;
    }
    if (pcfTaskIconExt != NULL)
    {
        delete pcfTaskIconExt;
        pcfTaskIconExt = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\resource.h ===
//
//  Bitmaps & icons
//

#define BMP_JOBSTATES                   271
#define BMP_JOBSTATEL                   272
#define BMP_JOBSTATEXL                  275

#define IDI_GENERIC                     273
#define IDI_TEMPLATE                    274

//
//  Menus
//

#define POPUP_JOB                       300
#define POPUP_JOB_VERBS_ONLY            301
#define POPUP_JOBSBG_MERGE              302
#define POPUP_JOBSBG_POPUPMERGE         303
#define POPUP_JOBS_MAIN_POPUPMERGE      304
#define POPUP_ADVANCED                  305
#define POPUP_RBUTTON_MOVE              306
#define POPUP_JOB_TEMPLATE              307

//
//  Strings in string table
//

#define IDS_NAME                        100
#define IDS_NEXTRUNTIME                 101
#define IDS_LASTRUNTIME                 102
#define IDS_LASTEXITCODE                103
#define IDS_SCHEDULE                    104
#define IDS_STATUS                      105
#define IDS_CREATOR                     106
#define IDS_MI_STOP                     107
#define IDS_MI_START                    108
#define IDS_MI_PAUSE                    109
#define IDS_MI_CONTINUE                 110

#define IDS_JOB_PSH_CAPTION             151
#define IDS_NOPAGE                      152
#define IDS_JOBFOLDER                   153
#define IDS_RUNNING                     154
#define IDS_JOB_NOT_SCHEDULED           155
#define IDS_NEVER                       156
#define IDS_DISABLED                    157
#define IDS_ON_STARTUP                  158
#define IDS_ON_LOGON                    159
#define IDS_TRIGGER_DISABLED            160
#define IDS_COPY_OF                     161
#define IDS_START_SERVICE               162
#define IDS_CONTINUE_SERVICE            163
#define IDS_START_PENDING               164
#define IDS_MULTIPLE_TRIGGERS           165
#define IDS_MISSED                      166
#define IDS_START_FAILED                167
#define IDS_BAD_ACCT                    168
#define IDS_REST_ACCT                   169

//
//  Others
//

#define CMIDM_FIRST                     0x0000
#define CMIDM_RUN                       (CMIDM_FIRST + 0x0001)
#define CMIDM_ABORT                     (CMIDM_FIRST + 0x0002)
#define CMIDM_CUT                       (CMIDM_FIRST + 0x0003)
#define CMIDM_COPY                      (CMIDM_FIRST + 0x0004)
#define CMIDM_PASTE                     (CMIDM_FIRST + 0x0005)
#define CMIDM_DELETE                    (CMIDM_FIRST + 0x0006)
#define CMIDM_RENAME                    (CMIDM_FIRST + 0x0007)
#define CMIDM_PROPERTIES                (CMIDM_FIRST + 0x0008)
#define CMIDM_OPEN                      (CMIDM_FIRST + 0x0009)

#define FSIDM_SORT_FIRST                0x0030
#define FSIDM_SORTBYNAME                (FSIDM_SORT_FIRST + 0x0000)
#define FSIDM_SORTBYSCHEDULE            (FSIDM_SORT_FIRST + 0x0001)
#define FSIDM_SORTBYNEXTRUNTIME         (FSIDM_SORT_FIRST + 0x0002)
#define FSIDM_SORTBYLASTRUNTIME         (FSIDM_SORT_FIRST + 0x0003)
#define FSIDM_SORTBYLASTEXITCODE        (FSIDM_SORT_FIRST + 0x0004)
#define FSIDM_SORTBYSTATUS              (FSIDM_SORT_FIRST + 0x0005)
#define FSIDM_SORTBYCREATOR             (FSIDM_SORT_FIRST + 0x0006)

#define FSIDM_MENU_NEW                  0x0060
#define FSIDM_NEWJOB                    (FSIDM_MENU_NEW + 0x0001)
#define FSIDM_NEWQUEUE                  (FSIDM_MENU_NEW + 0x0002)

#define FSIDM_MENU_ADVANCED             0x0090
#define FSIDM_STOP_SCHED                (FSIDM_MENU_ADVANCED + 0x0001)
#define FSIDM_PAUSE_SCHED               (FSIDM_MENU_ADVANCED + 0x0002)
#define FSIDM_VIEW_LOG                  (FSIDM_MENU_ADVANCED + 0x0003)
#define FSIDM_DBG_BUILD_NUM             (FSIDM_MENU_ADVANCED + 0x0004)
#define FSIDM_AT_ACCOUNT                (FSIDM_MENU_ADVANCED + 0x0005)
#define FSIDM_NOTIFY_MISSED             (FSIDM_MENU_ADVANCED + 0x0006)

#define DIDM_RBUTTON_MOVE_START         0x00c0
#define DDIDM_MOVE                      (DIDM_RBUTTON_MOVE_START + 0x0001)
#define DDIDM_COPY                      (DIDM_RBUTTON_MOVE_START + 0x0002)
#define DDIDM_CREATEAJOB                (DIDM_RBUTTON_MOVE_START + 0x0003)


#define IDS_MH_FSIDM_FIRST              2000
#define IDS_MH_FSIDM_LAST               2999

#define IDS_MH_SORTBYNAME               (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYNAME)
#define IDS_MH_SORTBYNEXTRUNTIME        (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYNEXTRUNTIME)
#define IDS_MH_SORTBYLASTRUNTIME        (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYLASTRUNTIME)
#define IDS_MH_SORTBYLASTEXITCODE       (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYLASTEXITCODE)
#define IDS_MH_SORTBYSCHEDULE           (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYSCHEDULE)
#define IDS_MH_SORTBYCREATOR            (IDS_MH_FSIDM_FIRST + FSIDM_SORTBYCREATOR)
#define IDS_MH_MENU_NEW                 (IDS_MH_FSIDM_FIRST + FSIDM_MENU_NEW)
#define IDS_MH_NEWJOB                   (IDS_MH_FSIDM_FIRST + FSIDM_NEWJOB)
#define IDS_MH_NEWQUEUE                 (IDS_MH_FSIDM_FIRST + FSIDM_NEWQUEUE)
#define IDS_MH_MENU_ADVANCED            (IDS_MH_FSIDM_FIRST + FSIDM_MENU_ADVANCED)
#define IDS_MH_STOP_SCHED               (IDS_MH_FSIDM_FIRST + FSIDM_STOP_SCHED)
#define IDS_MH_PAUSE_SCHED              (IDS_MH_FSIDM_FIRST + FSIDM_PAUSE_SCHED)
#define IDS_MH_NOTIFY_OF_MISSED         (IDS_MH_FSIDM_FIRST + FSIDM_NOTIFY_MISSED)
#define IDS_MH_VIEW_LOG                 (IDS_MH_FSIDM_FIRST + FSIDM_VIEW_LOG)
#define IDS_MH_AT_ACCOUNT               (IDS_MH_FSIDM_FIRST + FSIDM_AT_ACCOUNT)
#define IDS_MH_ABOUT                    (IDS_MH_FSIDM_FIRST + FSIDM_DBG_BUILD_NUM)
#define MH_TEXT_TOGGLE                  20
#define IDS_MH_START_SCHED              (IDS_MH_FSIDM_FIRST + FSIDM_STOP_SCHED + MH_TEXT_TOGGLE)
#define IDS_MH_CONTINUE_SCHED           (IDS_MH_FSIDM_FIRST + FSIDM_PAUSE_SCHED + MH_TEXT_TOGGLE)

#define IDS_MH_RUN                      (IDS_MH_FSIDM_FIRST + CMIDM_RUN)
#define IDS_MH_ABORT                    (IDS_MH_FSIDM_FIRST + CMIDM_ABORT)
#define IDS_MH_CUT                      (IDS_MH_FSIDM_FIRST + CMIDM_CUT)
#define IDS_MH_COPY                     (IDS_MH_FSIDM_FIRST + CMIDM_COPY)
#define IDS_MH_PASTE                    (IDS_MH_FSIDM_FIRST + CMIDM_PASTE)
#define IDS_MH_DELETE                   (IDS_MH_FSIDM_FIRST + CMIDM_DELETE)
#define IDS_MH_RENAME                   (IDS_MH_FSIDM_FIRST + CMIDM_RENAME)
#define IDS_MH_PROPERTIES               (IDS_MH_FSIDM_FIRST + CMIDM_PROPERTIES)
#define IDS_MH_OPEN                     (IDS_MH_FSIDM_FIRST + CMIDM_OPEN)

#ifndef SFVIDM_MENU_ARRANGE
#define SFVIDM_MENU_ARRANGE             0x7001
#endif // SFVIDM_MENU_ARRANGE


#define IERR_START                      3800
#define IERR_CANT_FIND_VIEWER           (IERR_START + 0x0001)
#define IERR_GETSVCSTATE                (IERR_START + 0x0002)
#define IERR_STOPSVC                    (IERR_START + 0x0003)
#define IERR_PAUSESVC                   (IERR_START + 0x0004)
#define IERR_CONTINUESVC                (IERR_START + 0x0005)
#define IERR_SCHEDSVC                   (IERR_START + 0x0006)
#define IERR_EXT_NOT_VALID              (IERR_START + 0X0007)
#define IERR_INVALID_DATA               (IERR_START + 0X0008)
#define IERR_STARTSVC                   (IERR_START + 0X0009)
#define IERR_GETATACCOUNT               (IERR_START + 0X000A)


#define IDS_BUILD_NUM                   4000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\sdetails.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       sdetails.cxx
//
//  Contents:   implementation of IShellDetails
//
//  Classes:    CJobsSD
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "resource.h"

#include "dll.hxx"
#include "jobidl.hxx"
#include "util.hxx"
#include "common.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;



//////////////////////////////////////////////////////////////////////////////
//  Forward declaration of local functions
//

BOOL
GetLocaleDateTimeString(
    SYSTEMTIME*     pst,
    DWORD           dwDateFlags,
    DWORD           dwTimeFlags,
    TCHAR           szBuff[],
    int             cchBuffLen,
    LPSHELLDETAILS  lpDetails);


//////////////////////////////////////////////////////////////////////////////
//
//  Define the columns (used by CJobsSD::GetDetailsOf)
//

struct COL_INFO
{
    UINT idString;
    int  fmt;
    UINT cxChar;
};

const COL_INFO c_ColumnHeaders[] =
{                                      
    {IDS_NAME,         LVCFMT_LEFT,  30},
    {IDS_SCHEDULE,     LVCFMT_LEFT,  20},
    {IDS_NEXTRUNTIME,  LVCFMT_LEFT,  15},
    {IDS_LASTRUNTIME,  LVCFMT_LEFT,  15},
    {IDS_STATUS,       LVCFMT_LEFT,  25},
    {IDS_LASTEXITCODE, LVCFMT_RIGHT, 15},
    {IDS_CREATOR,      LVCFMT_LEFT,  15}
};


//____________________________________________________________________________
//
//  Class:      CJobsSD
//
//  Purpose:    Provide IShellDetails interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsSD : public IShellDetails
{
public:
    CJobsSD(HWND hwnd) : m_ulRefs(1), m_hwnd(hwnd) {}
    ~CJobsSD() {}

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IShellDetails methods
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn,
                            LPSHELLDETAILS pDetails);
    STDMETHOD(ColumnClick)(UINT iColumn);

private:
    HWND    m_hwnd;
    CDllRef m_DllRef;
};


//____________________________________________________________________________
//
//  Member:     CJobsSD::IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsSD)

STDMETHODIMP
CJobsSD::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IShellDetails, riid))
    {
        *ppvObj = (IUnknown*)(IShellDetails*) this;
        this->AddRef();
        return S_OK;
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
}


inline
HRESULT
CopyToSTRRET(STRRET &str, LPTSTR pszIn)
{
    UINT uiByteLen = (lstrlen(pszIn) + 1) * sizeof(TCHAR);

    str.uType = STRRET_WSTR;

    str.pOleStr = (LPWSTR) SHAlloc(uiByteLen);

    if (str.pOleStr == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CopyMemory(str.pOleStr, pszIn, uiByteLen);

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobsSD::GetDetailsOf
//
//  Arguments:  [pidl] -- IN
//              [iColumn] -- IN
//              [lpDetails] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsSD::GetDetailsOf(
    LPCITEMIDLIST pidl,
    UINT iColumn,
    LPSHELLDETAILS lpDetails)
{
    // TRACE(CJobsSD, GetDetailsOf);

    HRESULT hr = S_OK;
    TCHAR   tcBuff[SCH_XBIGBUF_LEN] = TEXT("");

    if (iColumn >= COLUMN_COUNT)
    {
        return E_FAIL;
    }

    if (NULL == pidl)
    {
        // 
        // Caller wants strings for the column headers
        //

        LoadString(g_hInstance,
                        c_ColumnHeaders[iColumn].idString,
                        tcBuff,
                        SCH_XBIGBUF_LEN);

        lpDetails->fmt    = c_ColumnHeaders[iColumn].fmt;
        lpDetails->cxChar = c_ColumnHeaders[iColumn].cxChar;
    }
    else
    {
        CJobID & jid = *(PJOBID)pidl;

        //
        // Fill tcBuff with the string describing column iColumn of
        // object jid.  If jid represents a template object, only the
        // name column is not blank.
        //

        if (!jid.IsTemplate() || iColumn == COLUMN_NAME)
        {
            switch (iColumn)
            {
            case COLUMN_NAME:
            {
                StringCchCopy(tcBuff, SCH_XBIGBUF_LEN, jid.GetName());
    
                break;
            }
            case COLUMN_SCHEDULE:
            {
                if (jid.IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
                {
                    LoadString(g_hInstance,
                               IDS_DISABLED,
                               tcBuff,
                               SCH_XBIGBUF_LEN);
                }
                else if (jid.GetTriggerCount() > 1)
                {
                    LoadString(g_hInstance,
                               IDS_MULTIPLE_TRIGGERS, 
                               tcBuff, 
                               SCH_XBIGBUF_LEN);
                }
                else
                {
                    hr = GetTriggerStringFromTrigger(&jid.GetTrigger(),
                                                     tcBuff,
                                                     SCH_XBIGBUF_LEN,
                                                     lpDetails);
                }
    
                break;
            }
            case COLUMN_LASTRUNTIME:
            {
                SYSTEMTIME &st = jid.GetLastRunTime();
    
                if (st.wYear == 0 || st.wMonth == 0 || st.wDay == 0)
                {
                    LoadString(g_hInstance,
                               IDS_NEVER,
                               tcBuff,
                               SCH_XBIGBUF_LEN);
                }
                else
                {
                    GetLocaleDateTimeString(&st,
                                            DATE_SHORTDATE,
                                            0,
                                            tcBuff,
                                            SCH_XBIGBUF_LEN, lpDetails);
                }
    
                break;
            }

            case COLUMN_NEXTRUNTIME:
                jid.GetNextRunTimeString(tcBuff, SCH_XBIGBUF_LEN, FALSE, lpDetails);
                break;
    
            case COLUMN_STATUS:
            {
                ULONG ids = 0;

                if (jid.IsRunning())
                {
                    ids = IDS_RUNNING;
                }
                else if (jid.WasRunMissed())
                {
                    ids = IDS_MISSED;
                }
                else if (jid.DidJobStartFail())
                {
                    ids = IDS_START_FAILED;
                }
                else if(jid.DidJobBadAcct())
                {
                    ids = IDS_BAD_ACCT;
                }
                else if(jid.DidJobRestAcct())
                {
                    ids = IDS_REST_ACCT;
                }

                if (ids)
                {
                    LoadString(g_hInstance, ids, tcBuff, SCH_XBIGBUF_LEN);
                }
                break;
            }

            case COLUMN_LASTEXITCODE:
                StringCchPrintf(tcBuff, SCH_XBIGBUF_LEN, TEXT("0x%x"), jid.GetExitCode());
                break;
    
            case COLUMN_CREATOR:
                StringCchCopy(tcBuff, SCH_XBIGBUF_LEN, jid.GetCreator());
                break;
            }
        }
    }

    hr = CopyToSTRRET(lpDetails->str, tcBuff);

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobsSD::ColumnClick
//
//  Arguments:  [iColumn] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/8/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsSD::ColumnClick(
    UINT iColumn)
{
    TRACE(CJobsSD, ColumnClick);

    ShellFolderView_ReArrange(m_hwnd, iColumn);

    return S_OK;
}

//
//Define the UNICODE RLM control character.
//
#define RLM TEXT("\x200f")

//+-------------------------------------------------------------------------
//
//  Function:   GetLocaleDateTimeString, public
//
//  Synopsis:   Use the proper locale-formatted time and date
//
//  History:    07/09/95   RaviR Created.
//
//--------------------------------------------------------------------------

BOOL
GetLocaleDateTimeString(
    SYSTEMTIME*     pst,
    DWORD           dwDateFlags,
    DWORD           dwTimeFlags,
    TCHAR           szBuff[],
    int             cchBuffLen,
    LPSHELLDETAILS  lpDetails)
{
    if (pst->wYear == 0 || pst->wMonth == 0 || pst->wDay == 0)
    {
        szBuff = TEXT('\0');
        return TRUE;
    }

    LCID  lcid = GetUserDefaultLCID();
    TCHAR Time[150] = TEXT("");
    TCHAR Date[150] = TEXT("");

    if (0 == GetTimeFormat(lcid, dwTimeFlags, pst, NULL, Time, 150))
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    if (lpDetails) {
        if (lpDetails->fmt & LVCFMT_RIGHT_TO_LEFT) {
            dwDateFlags |=  DATE_RTLREADING;
        } else if (lpDetails->fmt & LVCFMT_LEFT_TO_RIGHT) {
            dwDateFlags |=  DATE_LTRREADING;
        }
    }

    if (0 == GetDateFormat(lcid, dwDateFlags, pst, NULL, Date, 150))
    {
        DEBUG_OUT_LASTERROR;
        return FALSE;
    }

    //
    //Force the time to appears as if it is preceded by BiDi character.
    //
    if (dwDateFlags & DATE_RTLREADING) 
    {
        StringCchCopy(szBuff, cchBuffLen, RLM);
        StringCchCat(szBuff, cchBuffLen, Time);

    } 
    else 
        StringCchCopy(szBuff,cchBuffLen, Time);

    StringCchCat(szBuff, cchBuffLen, TEXT("  "));
    StringCchCat(szBuff, cchBuffLen, Date);

    return TRUE;
}



//____________________________________________________________________________
//
//  Function:   CJobsShellDetails_Create
//
//  Synopsis:   S
//
//  Arguments:  [hwnd] -- IN
//              [riid] -- IN
//              [ppvObj] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

HRESULT
JFGetShellDetails(
    HWND    hwnd,
    LPVOID* ppvObj)
{
    CJobsSD* pObj = new CJobsSD(hwnd);

    if (NULL == pObj)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IShellDetails, ppvObj);

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\sfolder.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       sfolder.cxx
//
//  Contents:   Implementation of IShellFolder for Job Folders
//
//  Classes:    CJobFolder::IShellFolder members
//
//  Functions:
//
//  History:    1/4/1996    RaviR      Created
//              1-23-1997   DavidMun   Destroy notify window upon receiving
//                                      DVM_WINDOWDESTROY
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "resource.h"
#include "..\schedui\rc.h"
#include "jobidl.hxx"
#include "jobfldr.hxx"
#include "policy.hxx"
#include "..\schedui\timeutil.hxx"
#include "..\schedui\schedui.hxx"
#include "util.hxx"
#include "..\inc\defines.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\common.hxx"
#include "..\inc\sch_cls.hxx"
#include "atacct.h"

#define JF_FSNOTIFY     (WM_USER + 0xA1)
#define STUBM_SETDATA   (WM_USER + 0xb1)
#define STUBM_GETDATA   (WM_USER + 0xb2)


#define VIEW_ICON_MENU_ID           28713
#define VIEW_SMALLICON_MENU_ID      28714
#define VIEW_LIST_MENU_ID           28715
#define VIEW_DETAILS_MENU_ID        28716

//
// extern
//

extern HINSTANCE g_hInstance;
extern "C" UINT      g_cfJobIDList;
extern HANDLE	g_hActCtx;

HRESULT
JFGetShellDetails(
    HWND    hwnd,
    LPVOID* ppvObj);

HRESULT
JFGetFolderContextMenu(
    HWND            hwnd,
    CJobFolder    * pCJobFolder,
    LPVOID        * ppvObj);

HRESULT
JFGetDataObject(
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidlFolder,
    UINT            cidl,
    LPCITEMIDLIST * apidl,
    BOOL            fCut,
    LPVOID        * ppvObj);

HRESULT
JFGetItemContextMenu(
    HWND hwnd,
    ITaskScheduler * pScheduler,
    LPCTSTR ptszMachine,
    LPCTSTR pszFolderPath,
    LPCITEMIDLIST pidlFolder,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    LPVOID * ppvOut);

HRESULT
JFGetExtractIcon(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl);

HRESULT
JFGetExtractIconA(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl);

HRESULT
JFGetEnumIDList(
    ULONG            uFlags,
    LPCTSTR          pszFolderPath,
    IEnumWorkItems * pEnumJobs,
    LPVOID    *      ppvObj);


HRESULT
JFCreateNewQueue(
    HWND    hwnd);


void
OnViewLog(
    LPTSTR  lpMachineName,
    HWND    hwndOwner);


HRESULT
GetSchSvcState(
    DWORD &dwCurrState);


HRESULT
StopScheduler(void);


HRESULT
StartScheduler(void);

BOOL
UserCanChangeService(
    LPCTSTR ptszServer);

HRESULT
PromptForServiceStart(
    HWND hwnd);

HRESULT
PauseScheduler(
    BOOL fPause);

VOID
SecurityErrorDialog(
    HWND    hWndOwner,
    HRESULT hr);

VOID
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf);

//
// local funcs
//

HWND
I_CreateNotifyWnd(void);

int
LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2);


//____________________________________________________________________________
//
//  Member:     CJobFolder::ParseDisplayName
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::ParseDisplayName(
    HWND            hwndOwner,
    LPBC            pbcReserved,
    LPOLESTR        lpszDisplayName,
    ULONG         * pchEaten,
    LPITEMIDLIST  * ppidl,
    ULONG         * pdwAttributes)
{
    TRACE(CJobFolder, ParseDisplayName);

    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::EnumObjects
//
//  Arguments:  [hwndOwner] -- IN
//              [grfFlags] -- IN
//              [ppenumIDList] -- OUT
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::EnumObjects(
    HWND hwndOwner,
    DWORD grfFlags,
    LPENUMIDLIST* ppenumUnknown)
{
    DEBUG_OUT((DEB_USER12, "CJobFolder::EnumObjects<%x>\n", this));

    *ppenumUnknown = NULL;

    //
    //  We dont support folders.
    //

    if (!(grfFlags & SHCONTF_NONFOLDERS))
    {
        return E_FAIL;
    }

    //
    //  Get the IDList enumerator
    //

    HRESULT hr = S_OK;

    if (m_pScheduler == NULL)
    {
        hr = _InitRest();

        CHECK_HRESULT(hr);
    }

    IEnumWorkItems * pEnumJobs = NULL;

    if (SUCCEEDED(hr))
    {
        // m_pScheduler is not actually a COM object
        // it was created via new, and is an instance of CSchedule
        CSchedule* pScheduler;
        pScheduler = (CSchedule*)m_pScheduler;

        hr = pScheduler->EnumInternal(&pEnumJobs);

        if ((hr == E_ACCESSDENIED) && (NULL != hwndOwner))
        {
            WCHAR* pMessage;
            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
                          E_ACCESSDENIED, 0, (LPWSTR)&pMessage, 0, NULL))
            {
                MessageBox(hwndOwner, pMessage, NULL, MB_OK);
                LocalFree(pMessage);
            }
        }
        

        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            hr = JFGetEnumIDList(grfFlags, m_pszFolderPath,
                                 pEnumJobs, (LPVOID*)ppenumUnknown);
            CHECK_HRESULT(hr);

            pEnumJobs->Release();
        }
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::BindToObject
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::BindToObject(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvOut)
{
    TRACE(CJobFolder, BindToObject);

    // Job folder doesn't contain sub-folders
    return E_NOTIMPL;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::BindToStorage
//
//  Note:       not used in Win95
//____________________________________________________________________________


STDMETHODIMP
CJobFolder::BindToStorage(
    LPCITEMIDLIST pidl,
    LPBC pbcReserved,
    REFIID riid,
    LPVOID* ppvObj)
{
    TRACE(CJobFolder, BindToStorage);

    *ppvObj = NULL;
    return E_NOTIMPL;
}




//____________________________________________________________________________
//
//  Member:     CJobFolder::CompareIDs
//
//  Arguments:  [lParam] -- IN
//              [pidl1] -- IN
//              [pidl2] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::CompareIDs(
    LPARAM lCol,
    LPCITEMIDLIST pidl1,
    LPCITEMIDLIST pidl2)
{
    DEBUG_OUT((DEB_USER12, "CJobFolder::CompareIDs<%d>\n", lCol));

    HRESULT hr = S_OK;
    int     iCmp;

    if (JF_IsValidID(pidl1) == FALSE || JF_IsValidID(pidl2) == FALSE)
    {
        return E_INVALIDARG;
    }

    PJOBID pjid1 = (PJOBID)pidl1;
    PJOBID pjid2 = (PJOBID)pidl2;

    //
    // Ensure that the template object is always first
    //

    if (pjid1->IsTemplate() && pjid2->IsTemplate())
    {
        return S_OK; // equal
    }

    if (pjid1->IsTemplate())
    {
        return ResultFromShort(-1);
    }

    if (pjid2->IsTemplate())
    {
        return ResultFromShort(1);
    }

    switch (lCol)
    {
    case COLUMN_LASTRUNTIME:
        iCmp = CompareSystemTime(pjid1->GetLastRunTime(),
                                 pjid2->GetLastRunTime());
        break;

    case COLUMN_NEXTRUNTIME:
    {
        TCHAR  buff1[MAX_PATH];
        TCHAR  buff2[MAX_PATH];
        LPTSTR psz1, psz2;

        psz1 = pjid1->GetNextRunTimeString(buff1, MAX_PATH, TRUE);
        psz2 = pjid2->GetNextRunTimeString(buff2, MAX_PATH, TRUE);

        if (psz1 != NULL)
        {
            if (psz2 != NULL)
            {
                iCmp = LocaleStrCmp(psz1, psz2);
            }
            else
            {
                iCmp = 1;
            }
        }
        else
        {
            if (psz2 != NULL)
            {
                iCmp = -1;
            }
            else
            {
                iCmp = CompareSystemTime(pjid1->GetNextRunTime(),
                                         pjid2->GetNextRunTime());
            }
        }
        break;
    }

    case COLUMN_SCHEDULE:
    {
        TCHAR tszTrig1[SCH_XBIGBUF_LEN];
        TCHAR tszTrig2[SCH_XBIGBUF_LEN];

        if (pjid1->IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
        {
            LoadString(g_hInstance, IDS_DISABLED, tszTrig1, SCH_XBIGBUF_LEN);
        }
        else
        {
            hr = GetTriggerStringFromTrigger(&pjid1->GetTrigger(),
                                                tszTrig1, SCH_XBIGBUF_LEN, NULL);
            BREAK_ON_FAIL(hr);
        }

        if (pjid2->IsJobFlagOn(TASK_FLAG_DISABLED) == TRUE)
        {
            LoadString(g_hInstance, IDS_DISABLED, tszTrig2, SCH_XBIGBUF_LEN);
        }
        else
        {
            hr = GetTriggerStringFromTrigger(&pjid2->GetTrigger(),
                                                tszTrig2, SCH_XBIGBUF_LEN, NULL);
            BREAK_ON_FAIL(hr);
        }

        iCmp = LocaleStrCmp(tszTrig1, tszTrig2);

        break;
    }

    case COLUMN_STATUS:
    {
        iCmp = pjid1->_status - pjid2->_status;
        break;
    }

    case COLUMN_NAME:
        // Fall through

    default:
        DEBUG_OUT((DEB_USER12, "CompareIDs<%ws, %ws>\n", pjid1->GetName(),
                                                         pjid2->GetName()));

        iCmp = LocaleStrCmp(pjid1->GetName(), pjid2->GetName());

        break;

    case COLUMN_LASTEXITCODE:
        iCmp = pjid1->GetExitCode() - pjid2->GetExitCode();
        break;

    case COLUMN_CREATOR:
        iCmp = LocaleStrCmp(pjid1->GetCreator(), pjid2->GetCreator());
        break;
    }

    if (SUCCEEDED(hr))
    {
        hr = ResultFromShort(iCmp);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   LocaleStrCmp
//
//  Synopsis:   Do a case insensitive string compare that is safe for any
//              locale.
//
//  Arguments:  [ptsz1] - strings to compare
//              [ptsz2]
//
//  Returns:    -1, 0, or 1 just like lstrcmpi
//
//  History:    10-28-96   DavidMun   Created
//
//  Notes:      This is slower than lstrcmpi, but will work when sorting
//              strings even in Japanese.
//
//----------------------------------------------------------------------------

int
LocaleStrCmp(LPCTSTR ptsz1, LPCTSTR ptsz2)
{
    int iRet;

    iRet = CompareString(LOCALE_USER_DEFAULT,
                         NORM_IGNORECASE        |
                           NORM_IGNOREKANATYPE  |
                           NORM_IGNOREWIDTH,
                         ptsz1,
                         -1,
                         ptsz2,
                         -1);

    if (iRet)
    {
        iRet -= 2;  // convert to lstrcmpi-style return -1, 0, or 1
    }
    else
    {
        DEBUG_OUT_LASTERROR;
    }
    return iRet;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::CreateViewObject
//
//  Arguments:  [hwndOwner] -- IN
//              [riid] -- IN
//              [ppvOut] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________


STDMETHODIMP
CJobFolder::CreateViewObject(
    HWND hwndOwner,
    REFIID riid,
    LPVOID* ppvOut)
{
    TRACE(CJobFolder, CreateViewObject);

    HRESULT hr = S_OK;

	//
	// Only update m_hwndOwner the first time.
	// This function gets called each time the view mode gets changed,
	// but subsequent calls after initial window creation seem to have bogus
	// values for hwndOwner.  We don't want to clobber our initial good value.
	//
	if (!m_hwndOwner)
		m_hwndOwner = hwndOwner;

    *ppvOut = NULL;

    if (m_pszFolderPath == NULL)
    {
        hr = _InitRest();

        CHECK_HRESULT(hr);

        if (FAILED(hr))
        {
            return hr;
        }
    }

    if (IsEqualIID(riid, IID_IShellView))
    {
        CSFV csfv =
        {
            sizeof(CSFV),           // cbSize
            (IShellFolder*)this,    // pshf
            NULL,                   // psvOuter
            m_pidlFldr,             // pidl to monitor
            0,                      // events
            s_JobsFVCallBack,       // pfnCallback
            FVM_DETAILS
        };

        IShellView * pShellView;

        if (SUCCEEDED(hr))
        {
            hr = SHCreateShellFolderViewEx(&csfv, &pShellView);

            CHECK_HRESULT(hr);
        }

        if (SUCCEEDED(hr))
        {
            m_pShellView = pShellView;
            // WARNING: Do not AddRef m_pShellView this will cause
            // a cyclic addref. Use DVM_RELEASE in callback to know
            // whem m_pShellView is destroyed.
        }

        *ppvOut = (LPVOID)m_pShellView;
    }
    else if (IsEqualIID(riid, IID_IShellDetails))
    {
        hr = JFGetShellDetails(hwndOwner, ppvOut);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = JFGetFolderContextMenu(hwndOwner, this, ppvOut);
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = this->QueryInterface(IID_IDropTarget, ppvOut);
    }
    else
    {
        hr = E_NOINTERFACE;
        CHECK_HRESULT(hr);
    }

    return hr;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::GetAttributesOf
//
//  Arguments:  [cidl] -- IN
//              [apidl] -- IN
//              [rgfInOut] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//              5-09-1997   DavidMun   handle template object
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetAttributesOf(
    UINT cidl,
    LPCITEMIDLIST* apidl,
    ULONG* rgfInOut)
{
    // TRACE(CJobFolder, GetAttributesOf);

    //
    // Three cases:
    //
    // a. list contains only non-template object(s)
    // b. list contains only a template object
    // c. list contains template object plus non-template object(s)
    //
    // For cases b and c, no operations are allowed, since the
    // template object is not a real object.
    //

    ULONG rgfMask;

    if (ContainsTemplateObject(cidl, apidl))
    {
        rgfMask = 0;
    }
    else
    {
        //
        // Policy - creation, deletion are regulated
        //

        rgfMask = 0;

        //
        // If no DRAG and DROP restriction, then it ok to copy.
        // read it once, for efficiency's sake.
        //

        BOOL fDragDropRestricted = RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP);
        BOOL fDeleteRestricted = RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE);

        if (! fDragDropRestricted)
        {
            rgfMask |= SFGAO_CANCOPY;
        }

        if ((! fDeleteRestricted) && (! fDragDropRestricted))
        {
            // If allowed deletion, then move or delete is okay
            rgfMask |= SFGAO_CANMOVE;

            if (! RegReadPolicyKey(TS_KEYPOLICY_DENY_CREATE_TASK))
            {
                //
                // If allowed creation, as well, then rename is okay
                // Note we consider a RENAME both a create and a delete
                //

                rgfMask |= SFGAO_CANRENAME;
            }
        }

        if (! fDeleteRestricted)
        {
            rgfMask |= SFGAO_CANDELETE;
        }

        if ((cidl == 1) && (! RegReadPolicyKey(TS_KEYPOLICY_DENY_PROPERTIES)))
        {
            // no multi-select property sheets
            rgfMask |= SFGAO_HASPROPSHEET|SFGAO_FILESYSTEM ;
        }
    }

    *rgfInOut &= rgfMask;

    return S_OK;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::GetUIObjectOf
//
//  Arguments:  [hwndOwner] -- IN
//              [cidl] -- IN
//              [apidl] -- IN
//              [riid] -- IN
//              [prgfInOut] -- IN
//              [ppvOut] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetUIObjectOf(
    HWND hwndOwner,
    UINT cidl,
    LPCITEMIDLIST* apidl,
    REFIID riid,
    UINT* prgfInOut,
    LPVOID* ppvOut)
{
    TRACE(CJobFolder, GetUIObjectOf);

    if( NULL == apidl )
    {
        return E_INVALIDARG;
    }

    PJOBID pjid = (PJOBID)apidl[0];

    if (cidl < 1)
    {
        return E_INVALIDARG;
    }

    if (JF_IsValidID(apidl[0]) == FALSE)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = E_NOINTERFACE;

    *ppvOut = NULL;

    if (cidl == 1 && IsEqualIID(riid, IID_IExtractIcon))
    {
        hr = JFGetExtractIcon(ppvOut, m_pszFolderPath, apidl[0]);
    }
    else if (cidl == 1 && IsEqualIID(riid, IID_IExtractIconA))
    {
        hr = JFGetExtractIconA(ppvOut, m_pszFolderPath, apidl[0]);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        if (m_pszFolderPath == NULL)
        {
            hr = _InitRest();
            CHECK_HRESULT(hr);

            if (FAILED(hr))
            {
                return hr;
            }
        }

        hr = JFGetItemContextMenu(hwndOwner,
                                  m_pScheduler,
                                  m_pszMachine,
                                  m_pszFolderPath,
                                  m_pidlFldr,
                                  cidl,
                                  apidl,
                                  ppvOut);
    }
    else if (cidl > 0 && IsEqualIID(riid, IID_IDataObject))
    {
        DEBUG_OUT((DEB_USER1, "[GetUIObjectOf] IDataObject \n"));

        BOOL fCut = (GetKeyState(VK_CONTROL) >= 0);

        //
        // Policy - if DRAGDROP or DELETE and we are here,
        // we must be doing a cut or copy op and cannot allow it
        //

        if (RegReadPolicyKey(TS_KEYPOLICY_DENY_DRAGDROP) ||
            (fCut && RegReadPolicyKey(TS_KEYPOLICY_DENY_DELETE)))
        {
            return E_NOINTERFACE;
        }

        DEBUG_OUT((DEB_USER12, "fCut<%d>\n", fCut));

        hr = JFGetDataObject(m_pszFolderPath,
                             m_pidlFldr,
                             cidl,
                             apidl,
                             fCut,
                             ppvOut);
    }

    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobFolder::GetDisplayNameOf
//
//  Arguments:  [pidl] -- IN
//              [uFlags] -- IN
//              [lpName] -- IN
//
//  Returns:    HRESULT.
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::GetDisplayNameOf(
    LPCITEMIDLIST pidl,
    DWORD uFlags,
    LPSTRRET lpName)
{
    TRACE(CJobFolder, GetDisplayNameOf);
    DEBUG_OUT((DEB_USER12, "CJobFolder::GetDisplayNameOf<uFlags = %d>\n", uFlags));

    if (JF_IsValidID(pidl) == FALSE)
    {
        return E_INVALIDARG;
    }

    PJOBID pjid_unaligned = (PJOBID)pidl;
    DWORD SizeForAlignment = pjid_unaligned->_cb + sizeof(ULONG_PTR);
    CJobID * pjid = (CJobID *)LocalAlloc(LPTR,SizeForAlignment);
    if (NULL == pjid)
    {
        return E_OUTOFMEMORY;
    };
    class CFreeMe { void * _p; public: CFreeMe(void * p):_p(p){}; ~CFreeMe(){ LocalFree(_p);};} FreeMe(pjid);

    memcpy(pjid, pjid_unaligned, pjid_unaligned->_cb);

    LPTSTR ptszToReturn;
    TCHAR  tszFullPath[MAX_PATH + 1];

    //
    // If the display name is to be used for parsing, return the full path to
    // the file.  This is used by rshx32.dll when we request that it add the
    // security page for a file.
    //

    if (uFlags & SHGDN_FORPARSING)
    {
        //
        // If we don't have the folder path, complete the initialization to
        // get it.
        //

        if (m_pszFolderPath == NULL)
        {
            HRESULT hr = _InitRest();
            CHECK_HRESULT(hr);

            if (FAILED(hr))
            {
                return hr;
            }
        }

        StringCchPrintf(tszFullPath,
                        MAX_PATH + 1, 
                        TEXT("%s\\%s.") TSZ_JOB,
                        m_pszFolderPath,
                        pjid->GetName());


        ptszToReturn = tszFullPath;
        DEBUG_OUT((DEB_TRACE,
                   "CJobFolder::GetDisplayNameOf: Returning path '%S'\n",
                   ptszToReturn));
    }
    else
    {
        ptszToReturn = pjid->GetName();
    }

    UINT uiByteLen = (lstrlen(ptszToReturn) + 1) * sizeof(TCHAR);

    lpName->uType = STRRET_WSTR;

    lpName->pOleStr = (LPWSTR) SHAlloc(uiByteLen);

    if (NULL == lpName->pOleStr)
    {
        return E_OUTOFMEMORY;
    }

    CopyMemory(lpName->pOleStr, ptszToReturn, uiByteLen);

    return NOERROR;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::SetNameOf
//
//  Arguments:  [hwndOwner] -- IN
//              [pidl] -- IN
//              [lpszName] -- IN
//              [uFlags] -- IN
//              [ppidlOut] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobFolder::SetNameOf(
    HWND hwndOwner,
    LPCITEMIDLIST pidl,
    LPCOLESTR lpszName,
    DWORD uFlags,
    LPITEMIDLIST* ppidlOut)
{
    TRACE(CJobFolder, SetNameOf);

    HRESULT     hr = S_OK;

    if (JF_IsValidID(pidl) == FALSE)
    {
        return E_INVALIDARG;
    }

    PJOBID pjidOld = (PJOBID)pidl;

    DEBUG_ASSERT(!pjidOld->IsTemplate());

    if (ppidlOut != NULL)
    {
        *ppidlOut = NULL;
    }

    CJobID jidNew;

    jidNew.Rename(*pjidOld, lpszName);

    //
    // Change the file name
    //

    TCHAR szOldFile[MAX_PATH + 2];
    TCHAR szNewFile[MAX_PATH + 2];
    BOOL  fRet;

    StringCchCopy(szOldFile, MAX_PATH + 2, m_pszFolderPath);
    StringCchCat(szOldFile, MAX_PATH + 2, TEXT("\\"));
    StringCchCat(szOldFile, MAX_PATH + 2, pjidOld->GetPath());
    StringCchCat(szOldFile, MAX_PATH + 2, TSZ_DOTJOB);

    StringCchCopy(szNewFile, MAX_PATH + 2, m_pszFolderPath);
    StringCchCat(szNewFile, MAX_PATH + 2, TEXT("\\"));
    StringCchCat(szNewFile, MAX_PATH + 2, jidNew.GetName());
    StringCchCat(szNewFile, MAX_PATH + 2, TSZ_DOTJOB);

    DEBUG_OUT((DEB_USER1, "Rename %ws to %ws\n", szOldFile, szNewFile));

    SHFILEOPSTRUCT fo;

    fo.hwnd = m_hwndOwner;
    fo.wFunc = FO_RENAME;
    fo.pFrom = szOldFile;
    fo.pTo = szNewFile;
    fo.fFlags = FOF_ALLOWUNDO;
    fo.fAnyOperationsAborted = FALSE;
    fo.hNameMappings = NULL;
    fo.lpszProgressTitle = NULL;

    // Make sure we have double trailing NULL!
    *(szOldFile + lstrlen(szOldFile) + 1) = TEXT('\0');
    *(szNewFile + lstrlen(szNewFile) + 1) = TEXT('\0');

    if ((SHFileOperation(&fo) !=0) || fo.fAnyOperationsAborted == TRUE)
    {
        hr = E_FAIL;
        CHECK_HRESULT(hr);
        return hr;
    }

    return hr;
}

//  IShellFolder2

STDMETHODIMP
CJobFolder::GetDefaultSearchGUID(GUID *pguid)
{
    return E_NOTIMPL;
};
        
STDMETHODIMP
CJobFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    return E_NOTIMPL;    
};
        
STDMETHODIMP
CJobFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    if (NULL == pSort || NULL == pDisplay)
    {
        return E_POINTER;
    }    	
    *pSort = COLUMN_NEXTRUNTIME;
    *pDisplay = COLUMN_NAME;
    return S_OK;
};
        
STDMETHODIMP
CJobFolder::GetDefaultColumnState( UINT iColumn, SHCOLSTATEF *pcsFlags)
{
    if (NULL == pcsFlags)
    {
        return E_POINTER;
    }
    if (iColumn >= COLUMN_COUNT)
    {
        return E_FAIL;
    }
    switch(iColumn)
    {
    case COLUMN_NAME:
    case COLUMN_SCHEDULE:
        *pcsFlags = SHCOLSTATE_ONBYDEFAULT |SHCOLSTATE_TYPE_STR;
      	break;
    case COLUMN_NEXTRUNTIME:
    case COLUMN_LASTRUNTIME:
    	*pcsFlags = SHCOLSTATE_ONBYDEFAULT |SHCOLSTATE_TYPE_DATE;
    	break;
    case COLUMN_STATUS:
    case COLUMN_COUNT:
    	*pcsFlags = SHCOLSTATE_ONBYDEFAULT |SHCOLSTATE_TYPE_INT;
    	break;    	
    default:
        *pcsFlags = SHCOLSTATE_ONBYDEFAULT;
    };

    return S_OK;
};
        
STDMETHODIMP
CJobFolder::GetDetailsEx( LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    return E_NOTIMPL;    
};
        
STDMETHODIMP
CJobFolder::GetDetailsOf( LPCITEMIDLIST pidl,UINT iColumn,SHELLDETAILS *psd)
{
    return E_NOTIMPL;
};
        
STDMETHODIMP
CJobFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    return E_NOTIMPL;
};



#if DBG==1
void JFDbgOutCallbackMsg(UINT uMsg);
#endif // DBG==1

//____________________________________________________________________________
//
//  Member:     CJobFolder::s_JobsFVCallBack, static
//
//  Arguments:  [psvOuter] -- IN
//              [psf] -- IN
//              [hwndOwner] -- IN
//              [uMsg] -- IN
//              [wParam] -- IN
//              [lParam] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT CALLBACK
CJobFolder::s_JobsFVCallBack(
    LPSHELLVIEW psvOuter,
    LPSHELLFOLDER psf,
    HWND hwndOwner,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CJobFolder *pCJobFolder = (CJobFolder *)psf;

    return pCJobFolder->_JobsFVCallBack(psvOuter, psf, hwndOwner,
                                        uMsg, wParam, lParam);
}


//+---------------------------------------------------------------------------
//
//  Function:   EnableAtAccountControls
//
//  Synopsis:   Enable or disable the account and password controls in the
//              at account dialog.
//
//  Arguments:  [hDlg]    - handle to dialog
//              [fEnable] - TRUE = enable, FALSE = disable
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
EnableAtAccountControls(HWND hDlg, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hDlg, IDD_AT_CUSTOM_ACCT_NAME), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDD_AT_PASSWORD), fEnable);
    EnableWindow(GetDlgItem(hDlg, IDD_AT_CONFIRM_PASSWORD), fEnable);
}




//+---------------------------------------------------------------------------
//
//  Function:   InitAtAccountDlg
//
//  Synopsis:   Initialize the controls in the at account dialog
//
//  Arguments:  [hDlg] - handle to dialog
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
InitAtAccountDlg(HWND hDlg)
{
    HRESULT hr;
    WCHAR wszAccount[MAX_USERNAME + 1];
    DWORD cchAccount = MAX_USERNAME + 1;

    //
    // Limit the length of account and password edit controls, and init the
    // password controls to stars just like the task account dialog does.
    //

    SendDlgItemMessage(hDlg,
                       IDD_AT_CUSTOM_ACCT_NAME,
                       EM_LIMITTEXT,
                       MAX_USERNAME,
                       0);

    SendDlgItemMessage(hDlg,
                       IDD_AT_PASSWORD,
                       EM_LIMITTEXT,
                       MAX_PASSWORD,
                       0);

    SendDlgItemMessage(hDlg,
                       IDD_AT_CONFIRM_PASSWORD,
                       EM_LIMITTEXT,
                       MAX_PASSWORD,
                       0);

    //
    // Ask the service for the current at account information.  Menu item for
    // this dialog should be disabled if service isn't running, so this should
    // succeed.  If this fails, we can't expect the Set api to work, so
    // complain and bail.
    //

    hr = GetNetScheduleAccountInformation(NULL, cchAccount, wszAccount);

    if (SUCCEEDED(hr))
    {
        if (hr == S_FALSE)
        {
            // running as local system
            CheckDlgButton(hDlg, IDD_AT_USE_SYSTEM, BST_CHECKED);
            EnableAtAccountControls(hDlg, FALSE);
        }
        else
        {
            CheckDlgButton(hDlg, IDD_AT_USE_CUSTOM, BST_CHECKED);
            SetDlgItemText(hDlg, IDD_AT_CUSTOM_ACCT_NAME, wszAccount);
            EnableAtAccountControls(hDlg, TRUE);
        }
    }
    else
    {
        SchedUIMessageDialog(hDlg,
                             IERR_GETATACCOUNT,
                             MB_OK | MB_ICONEXCLAMATION | MB_TASKMODAL,
                             NULL);
        EndDialog(hDlg, 0);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   HandleAtAccountChange
//
//  Synopsis:   Make the At account reflect the current settings in the
//              dialog, and end the dialog if successful.
//
//  Arguments:  [hDlg] - handle to dialog
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

VOID
HandleAtAccountChange(HWND hDlg)
{
    HRESULT hr = S_OK;
    WCHAR  wszAccountName[MAX_USERNAME + 1]       = TEXT("");
    WCHAR  wszPassword[MAX_PASSWORD + 1]          = TEXT("");
    WCHAR  wszConfirmedPassword[MAX_PASSWORD + 1] = TEXT("");

    do
    {
        //
        // See if user just wants at jobs to run as localsystem
        //

        if (IsDlgButtonChecked(hDlg, IDD_AT_USE_SYSTEM) == BST_CHECKED)
        {
            hr = SetNetScheduleAccountInformation(NULL, NULL, wszPassword);

            if (FAILED(hr))
            {
                SecurityErrorDialog(hDlg, hr);
            }
            else
            {
                EndDialog(hDlg, 0);
            }
            break;
        }

        //
        // No, we have to validate account and password controls.  Get the
        // account name and fail if it's empty.
        //

        GetDlgItemText(hDlg,
                       IDD_AT_CUSTOM_ACCT_NAME,
                       wszAccountName,
                       MAX_USERNAME + 1);

        if (wszAccountName[0] == L'\0')
        {
            SchedUIErrorDialog(hDlg, IERR_ACCOUNTNAME, (LPTSTR)NULL);
            break;
        }

        //
        // Get the passwords and fail if they haven't been changed, or if
        // they don't match eachother.
        //

        GetDlgItemText(hDlg,
                       IDD_AT_PASSWORD,
                       wszPassword,
                       MAX_PASSWORD + 1);

        GetDlgItemText(hDlg,
                       IDD_AT_CONFIRM_PASSWORD,
                       wszConfirmedPassword,
                       MAX_PASSWORD + 1);

        if (lstrcmp(wszPassword, wszConfirmedPassword) != 0)
        {
            SchedUIErrorDialog(hDlg, IERR_PASSWORD, (LPTSTR)NULL);
            break;
        }

        //
        // Account name and passwords valid (as far as we can tell). Make
        // the change to the account.
        //

        hr = SetNetScheduleAccountInformation(NULL, // local machine
                                              wszAccountName,
                                              wszPassword);

        if (FAILED(hr))
        {
            SecurityErrorDialog(hDlg, hr);
        }
        else
        {
            EndDialog(hDlg, 0);
        }
    } while (0);

    SecureZeroMemory(wszPassword, sizeof wszPassword);
    SecureZeroMemory(wszConfirmedPassword, sizeof wszPassword);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetAtAccountDlgProc
//
//  Synopsis:   Allow the user to specify which account to run AT jobs under
//
//  Arguments:  standard dialog proc
//
//  Returns:    standard dialog proc
//
//  History:    09-19-96   DavidMun   Created
//
//----------------------------------------------------------------------------

INT_PTR APIENTRY
SetAtAccountDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL  fHandled = TRUE;

    //
    // Note: the DWLP_USER long is used as a dirty flag.  If the user hits OK
    // without having modified the edit controls or hit the radio buttons,
    // then we'll just treat it as a Cancel if the dirty flag is FALSE.
    //

    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitAtAccountDlg(hDlg);
        SetWindowLongPtr(hDlg, DWLP_USER, FALSE);
        break;  // return TRUE so windows will set focus

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDD_AT_USE_SYSTEM:
            EnableAtAccountControls(hDlg, FALSE);
            SetWindowLongPtr(hDlg, DWLP_USER, TRUE);
            break;

        case IDD_AT_USE_CUSTOM:
        {
            WCHAR wszUserName[MAX_USERNAME + 1];
            DWORD cchUserName = MAX_USERNAME + 1;

            SetWindowLongPtr(hDlg, DWLP_USER, TRUE);

            //
            // If there's nothing in the user account field, make it default
            // to the logged-on user.
            //

            if (!GetDlgItemText(hDlg,
                                IDD_AT_CUSTOM_ACCT_NAME,
                                wszUserName,
                                cchUserName))
            {
                GetDefaultDomainAndUserName(wszUserName, cchUserName);
                SetDlgItemText(hDlg, IDD_AT_CUSTOM_ACCT_NAME, wszUserName);
            }

            EnableAtAccountControls(hDlg, TRUE);
            break;
        }

        case IDD_AT_CUSTOM_ACCT_NAME:
        case IDD_AT_PASSWORD:
        case IDD_AT_CONFIRM_PASSWORD:
            if (EN_CHANGE == HIWORD(wParam))
            {
                SetWindowLongPtr(hDlg, DWLP_USER, TRUE);
            }
            else
            {
                fHandled = FALSE;
            }
            break;

        case IDOK:
            if (GetWindowLongPtr(hDlg, DWLP_USER))
            {
                //
                // Do NOT clear the dirty flag here--if HandleAtAccountChange
                // is successful, the dialog will end, but if not we need to
                // retain the dirty state.
                //

                CWaitCursor WaitCursor;
                HandleAtAccountChange(hDlg);
                break;
            }
            // else FALL THROUGH

        case IDCANCEL:
            EndDialog(hDlg, wParam);
            break;

        default:
            fHandled = FALSE;
            break;
        }
        break;

    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}


//____________________________________________________________________________
//
//  Member:     CJobFolder::_JobsFVCallBack
//
//  Arguments:  [psvOuter] -- IN
//              [psf] -- IN
//              [hwndOwner] -- IN
//              [uMsg] -- IN
//              [wParam] -- IN
//              [lParam] -- IN
//
//  Returns:    HRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT CALLBACK
CJobFolder::_JobsFVCallBack(
    LPSHELLVIEW psvOuter,
    LPSHELLFOLDER psf,
    HWND hwndOwner,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    DEBUG_OUT((DEB_USER12, "_JobsFVCallBack<uMsg=%d>\n", uMsg));

    HRESULT     hr = S_OK;
    LRESULT     lr = ERROR_SUCCESS;

    switch(uMsg)
    {
    case DVM_GETCCHMAX:
    {
        UINT * pcchMax = (UINT *)lParam;

        // <folder path> + '\' + cchMax + '.job' + null  <= MAX_PATH

        *pcchMax = MAX_PATH - (lstrlen(m_pszFolderPath) + 6);

        break;
    }
    case DVM_DEFITEMCOUNT:
        //
        // If DefView times out enumerating items, let it know we probably only
        // have about 20 items
        //

        *(int *)lParam = 20;
        break;

    case DVM_MERGEMENU:
    {
        m_qcm = *((LPQCMINFO)lParam);

        UtMergeMenu(g_hInstance, POPUP_ADVANCED, POPUP_JOBS_MAIN_POPUPMERGE,
                                                        (LPQCMINFO)lParam);
        break;
    }
    case DVM_INITMENUPOPUP:
    {
        UINT idCmdFirst = LOWORD(wParam);
        UINT nIndex = HIWORD(wParam);
        HMENU hmenu = (HMENU)lParam;
        UINT idCmd = GetMenuItemID(hmenu, 0) - idCmdFirst;

        if (idCmd == FSIDM_STOP_SCHED)
        {
            if (!UserCanChangeService(m_pszMachine))
            {
                //
                // The job folder is on a remote machine, or we're on NT
                // and the user is not an administrator.  Disable stop,
                // pause, and at account options and get out.
                //

                EnableMenuItem(hmenu, FSIDM_STOP_SCHED+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);

                EnableMenuItem(hmenu, FSIDM_PAUSE_SCHED+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);

                EnableMenuItem(hmenu, FSIDM_NOTIFY_MISSED+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);
                EnableMenuItem(hmenu, FSIDM_AT_ACCOUNT+idCmdFirst,
                                            MF_DISABLED | MF_GRAYED);
                break;
            }

            DWORD dwState;

            hr = GetSchSvcState(dwState);

            DEBUG_OUT((DEB_USER1, "Service state = %d\n", dwState));

            if (FAILED(hr))
            {
                dwState = SERVICE_STOPPED;
            }

            UINT uiStartID = IDS_MI_STOP;
            UINT uiPauseID = IDS_MI_PAUSE;
            UINT uiPauseEnable = MFS_ENABLED;
#define CCH_MENU_TEXT 80
            TCHAR tszStart[CCH_MENU_TEXT];
            TCHAR tszPause[CCH_MENU_TEXT];

            if (dwState == SERVICE_STOPPED ||
                dwState == SERVICE_STOP_PENDING)
            {
                uiStartID = IDS_MI_START;
                uiPauseEnable = MFS_DISABLED;
            }
            else if (dwState == SERVICE_PAUSED ||
                     dwState == SERVICE_PAUSE_PENDING)
            {
                uiPauseID = IDS_MI_CONTINUE;
            }

            if (dwState == SERVICE_START_PENDING)
            {
                uiPauseEnable = MFS_DISABLED;
            }

            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(MENUITEMINFO);

            mii.fMask = MIIM_TYPE;

            LoadString(g_hInstance, uiStartID, tszStart, CCH_MENU_TEXT);
            mii.dwTypeData = tszStart;

            SetMenuItemInfo(hmenu, FSIDM_STOP_SCHED+idCmdFirst, FALSE,
                            &mii);

            mii.fMask = MIIM_TYPE | MIIM_STATE;

            LoadString(g_hInstance, uiPauseID, tszPause, CCH_MENU_TEXT);
            mii.dwTypeData = tszPause;
            mii.fState = uiPauseEnable;

            SetMenuItemInfo(hmenu, FSIDM_PAUSE_SCHED+idCmdFirst, FALSE,
                            &mii);

            CheckMenuItem(hmenu,
                          FSIDM_NOTIFY_MISSED+idCmdFirst,
                          g_fNotifyMiss ? MF_CHECKED : MF_UNCHECKED);

            EnableMenuItem(hmenu,
                           FSIDM_AT_ACCOUNT+idCmdFirst,
                           MFS_ENABLED == uiPauseEnable ?
                            MF_ENABLED : MF_DISABLED | MF_GRAYED);
        }

        break;
    }
    case DVM_INVOKECOMMAND:
    {
        HMENU &hmenu = m_qcm.hmenu;
        UINT  id = (UINT)wParam + m_qcm.idCmdFirst;
        DWORD dwState;

        hr = GetSchSvcState(dwState);

        if (FAILED(hr))
        {
            dwState = SERVICE_STOPPED;
        }

        switch (wParam)
        {
        case FSIDM_SORTBYNAME:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_NAME);
            break;

        case FSIDM_SORTBYSCHEDULE:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_SCHEDULE);
            break;

        case FSIDM_SORTBYNEXTRUNTIME:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_NEXTRUNTIME);
            break;

        case FSIDM_SORTBYLASTRUNTIME:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_LASTRUNTIME);
            break;

        case FSIDM_SORTBYSTATUS:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_STATUS);
            break;

        case FSIDM_SORTBYLASTEXITCODE:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_LASTEXITCODE);
            break;

        case FSIDM_SORTBYCREATOR:
            ShellFolderView_ReArrange(hwndOwner, COLUMN_CREATOR);
            break;

        case FSIDM_NEWJOB:
            if (UserCanChangeService(m_pszMachine))
            {
                PromptForServiceStart(hwndOwner);
            }
            hr = CreateAJobForApp(NULL);
            break;

        case FSIDM_STOP_SCHED:
            if (dwState == SERVICE_STOPPED ||
                dwState == SERVICE_STOP_PENDING)
            {
                hr = StartScheduler();

                if (FAILED(hr))
                {
                    SchedUIErrorDialog(hwndOwner, IERR_STARTSVC, (LPTSTR) NULL);
                }
            }
            else
            {
                hr = StopScheduler();

                if (FAILED(hr))
                {
                    SchedUIErrorDialog(hwndOwner, IERR_STOPSVC, (LPTSTR) NULL);
                }
            }

            break;

        case FSIDM_PAUSE_SCHED:
            hr = PauseScheduler(dwState != SERVICE_PAUSED &&
                                dwState != SERVICE_PAUSE_PENDING);
            break;

        case FSIDM_AT_ACCOUNT:
			{
				ULONG_PTR lpCookie = NULL;
				if (ActivateActCtx(g_hActCtx, &lpCookie))
				{
		            DialogBox(g_hInstance,
		                      MAKEINTRESOURCE(IDD_AT_ACCOUNT_DLG),
		                      hwndOwner,
		                      SetAtAccountDlgProc);

					DeactivateActCtx(0, lpCookie);
				}
				else
				{
		            DialogBox(g_hInstance,
		                      MAKEINTRESOURCE(IDD_AT_ACCOUNT_DLG),
		                      hwndOwner,
		                      SetAtAccountDlgProc);
				}
			}
            break;

        case FSIDM_NOTIFY_MISSED:
        {
            LONG lErr;
            HKEY hSchedKey = NULL;

            lErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              SCH_AGENT_KEY,
                              0,
                              KEY_SET_VALUE,
                              &hSchedKey);

            if (lErr != ERROR_SUCCESS)
            {
                DEBUG_OUT((DEB_ERROR, "RegOpenKeyEx of Scheduler key %uL\n", lErr));
                break;
            }

            // Toggle the global var state

            g_fNotifyMiss = !g_fNotifyMiss;

            // Persist the change in the registry

            ULONG cbData = sizeof(g_fNotifyMiss);

            lErr = RegSetValueEx(hSchedKey,
                                 SCH_NOTIFYMISS_VALUE,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE) &g_fNotifyMiss,
                                 cbData);
            RegCloseKey(hSchedKey);

            // If the change couldn't be persisted, undo it.

            if (lErr != ERROR_SUCCESS)
            {
                DEBUG_OUT((DEB_ERROR, "RegSetValueEx of notify miss %uL\n", lErr));
                g_fNotifyMiss = !g_fNotifyMiss;
            }
            break;
        }

        case FSIDM_VIEW_LOG:
            OnViewLog(m_pszMachine, hwndOwner);
            break;

        default:
            DEBUG_OUT((DEB_ERROR, "Unknown DVM_INVOKECOMMAND<%u>\n",wParam));
            hr = E_FAIL;
        }

        break;
    }
    case DVM_GETTOOLTIPTEXT:
    case DVM_GETHELPTEXT:
    {
        UINT idCmd = (UINT)LOWORD(wParam);
        UINT cchMax = (UINT)HIWORD(wParam);
        UINT uiToggle = 0;

        LPSTR pszText = (LPSTR)lParam;

        if (idCmd == FSIDM_STOP_SCHED || idCmd == FSIDM_PAUSE_SCHED)
        {
            DWORD dwState;

            hr = GetSchSvcState(dwState);

            if (FAILED(hr))
            {
                dwState = SERVICE_STOPPED;
            }

            if ((dwState == SERVICE_STOPPED ||
                 dwState == SERVICE_STOP_PENDING) &&
                idCmd == FSIDM_STOP_SCHED)
            {
                uiToggle = MH_TEXT_TOGGLE;
            }
            else
            {
                if ((dwState == SERVICE_PAUSED ||
                     dwState == SERVICE_PAUSE_PENDING) &&
                    idCmd == FSIDM_PAUSE_SCHED)
                {
                    uiToggle = MH_TEXT_TOGGLE;
                }
            }
        }

        LoadString(g_hInstance, idCmd + IDS_MH_FSIDM_FIRST + uiToggle,
                                            (LPTSTR)pszText, cchMax);

        break;
    }

    case DVM_DIDDRAGDROP:
    {
        DEBUG_OUT((DEB_USER12, "DVM_DIDDRAGDROP\n"));

//      DWORD dwEffect = wParam;
//      IDataObject * pdtobj = (IDataObject *)lParam;
//
//      if (!(dwEffect & DROPEFFECT_MOVE))
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DIDDRAGDROP<Copy>\n"));
//      }
//      else
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DIDDRAGDROP<Move>\n"));
//      }

        break;
    }
    case DVM_GETWORKINGDIR:
    {
        UINT    uMax = (UINT)wParam;
        LPTSTR  pszDir = (LPTSTR)lParam;

        StringCchCopy(pszDir, uMax, m_pszFolderPath);
        break;
    }

    //
    // DVM_INSERTITEM and DVM_DELETEITEM are not processed because the
    // directory change notifications already provide this information.
    //

//  case DVM_INSERTITEM:
//  {
//      PJOBID pjid = (PJOBID)wParam;
//      if (JF_IsValidID((LPCITEMIDLIST)pjid) == TRUE)
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_INSERTITEM <%ws>\n", pjid->GetName()));
//      }
//      break;
//  }
//  case DVM_DELETEITEM:
//  {
//      PDVSELCHANGEINFO psci = (PDVSELCHANGEINFO)lParam;
//
//      PJOBID pjid = (PJOBID)psci->lParamItem;
//
//      if (pjid == NULL)
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DELETEITEM delete all items.\n"));
//      }
//      else if (JF_IsValidID((LPCITEMIDLIST)pjid) == TRUE)
//      {
//          DEBUG_OUT((DEB_USER1, "DVM_DELETEITEM <%ws>\n", pjid->GetName()));
//      }
//      break;
//  }
    case DVM_RELEASE:
    {
        DEBUG_OUT((DEB_USER1, "\tDVM_RELEASE\n"));
        m_pShellView = NULL;
        break;
    }
    case DVM_WINDOWCREATED:
    {
        //
        // If we're opening on the local machine, make sure the sa.dat
        // file is up to date.
        //

        if (!m_pszMachine)
        {
            CheckSaDat(m_pszFolderPath);
        }

        // Save current listview mode

        m_ulListViewModeOnEntry = _GetChildListViewMode(hwndOwner);

        // Register change notifications for the pidl of the Tasks dir

        DEBUG_ASSERT(!m_hwndNotify);
        m_hwndNotify = I_CreateNotifyWnd();

        if (m_hwndNotify == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        SendMessage(m_hwndNotify, STUBM_SETDATA, (WPARAM)this, 0);

        if (m_pszFolderPath == NULL)
        {
            hr = _InitRest();

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
        }

        LPITEMIDLIST pidl;
        hr = SHILCreateFromPath(m_pszFolderPath, &pidl, NULL);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        SHChangeNotifyEntry fsne;
        fsne.pidl       = pidl;
        fsne.fRecursive = FALSE;

        int fSources = SHCNRF_ShellLevel | SHCNRF_InterruptLevel;
                                         //| SHCNRF_NewDelivery;

        LONG fEvents = SHCNE_DISKEVENTS | SHCNE_RENAMEITEM | SHCNE_CREATE |
                       SHCNE_UPDATEITEM | SHCNE_ATTRIBUTES | SHCNE_DELETE;

        CDll::LockServer(TRUE);
        m_uRegister = SHChangeNotifyRegister(m_hwndNotify, fSources, fEvents,
                                                    JF_FSNOTIFY, 1, &fsne);

        if (!m_uRegister)
        {
            CDll::LockServer(FALSE);
            DEBUG_OUT_LASTERROR;
        }

        break;
    }
    case DVM_WINDOWDESTROY:
    {
        //
        // Restore the listview mode that we found on entry, unless the
        // user has changed away from report mode.
        //

        if (m_ulListViewModeOnEntry != INVALID_LISTVIEW_STYLE &&
            _GetChildListViewMode(hwndOwner) == LVS_REPORT)
        {
           _SetViewMode(hwndOwner, m_ulListViewModeOnEntry);
        }

        if (m_uRegister)
        {
            SHChangeNotifyDeregister(m_uRegister);
            CDll::LockServer(FALSE);
            m_uRegister = 0;
        }

        if (m_hwndNotify)
        {
            BOOL fOk = DestroyWindow(m_hwndNotify);

            m_hwndNotify = NULL;

            if (!fOk)
            {
                DEBUG_OUT_LASTERROR;
            }
        }
        break;
    }
    case SFVM_GETHELPTOPIC:
    {
        SFVM_HELPTOPIC_DATA * phtd = (SFVM_HELPTOPIC_DATA*)lParam;
        StringCchCopy(phtd->wszHelpFile, MAX_PATH, L"mstask.chm");
        break;
    }

    default:
        hr = E_FAIL;

        #if DBG==1
            JFDbgOutCallbackMsg(uMsg);
        #endif // DBG==1
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::_SetViewMode
//
//  Synopsis:   Select the listview mode specified by [ulListViewStyle].
//
//  Arguments:  [hwndOwner]       - explorer window handle
//              [ulListViewStyle] - LVS_* in LVS_TYPEMASK.
//
//  History:    07-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CJobFolder::_SetViewMode(
    HWND hwndOwner,
    ULONG ulListViewStyle)
{
    switch (ulListViewStyle)
    {
    case LVS_ICON:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_ICON_MENU_ID, 0);
        break;

    case LVS_REPORT:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_DETAILS_MENU_ID, 0);
        break;

    case LVS_SMALLICON:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_SMALLICON_MENU_ID, 0);
        break;

    case LVS_LIST:
        PostMessage(hwndOwner, WM_COMMAND, VIEW_LIST_MENU_ID, 0);
        break;

    default:
        DEBUG_OUT((DEB_ERROR,
                   "CJobFolder::_SetViewMode: invalid view mode 0x%x\n",
                   ulListViewStyle));
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   EnumChildWindowCallback
//
//  Synopsis:   Fill hwnd pointed to by [lParam] with [hwnd] if [hwnd] has
//              class WC_LISTVIEW.
//
//
//  Arguments:  [hwnd]   - window to check
//              [lParam] - pointer to HWND
//
//  Returns:    TRUE  - continue enumeration
//              FALSE - [hwnd] is listview, *(HWND*)[lParam] = [hwnd], stop
//                       enumerating
//
//  Modifies:   *(HWND*)[lParam]
//
//  History:    07-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL CALLBACK
EnumChildWindowCallback(
    HWND hwnd,
    LPARAM lParam)
{
    TCHAR tszClassName[80];

    GetClassName(hwnd, tszClassName, ARRAYLEN(tszClassName));

    if (!lstrcmpi(tszClassName, WC_LISTVIEW))
    {
        *(HWND *)lParam = hwnd;
        return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CJobFolder::_GetChildListViewMode
//
//  Synopsis:   Return the LVS_* value representing the mode of the first
//              child listview control found for [hwndOwner].
//
//  Arguments:  [hwndOwner] -
//
//  Returns:    LVS_ICON, LVS_SMALLICON, LVS_REPORT, LVS_LIST, or
//              INVALID_LISTVIEW_STYLE.
//
//  History:    07-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CJobFolder::_GetChildListViewMode(
    HWND hwndOwner)
{
    HWND hwnd = NULL;

    EnumChildWindows(hwndOwner,
                     EnumChildWindowCallback,
                     (LPARAM)&hwnd);

    if (!hwnd)
    {
        DEBUG_OUT((DEB_ERROR,
                   "_GetChildListViewMode: can't find child listview\n"));
        return INVALID_LISTVIEW_STYLE;
    }

    LONG lStyle = GetWindowLong(hwnd, GWL_STYLE);

    return lStyle & LVS_TYPEMASK;
}




BOOL
CJobFolder::_ObjectAlreadyPresent(
    LPTSTR pszObj)
{
    BOOL fPresent = FALSE;

    PJOBID  pjid;
    LPTSTR  pszName = PathFindFileName(pszObj);
    LPTSTR  pszExt = PathFindExtension(pszName);
    TCHAR   tcSave;

    if (pszExt)
    {
        tcSave = *pszExt;
        *pszExt = TEXT('\0');
    }

    int cObjs = (int) ShellFolderView_GetObjectCount(m_hwndOwner);

    for (int i=0; i < cObjs; i++)
    {
        pjid = (PJOBID)ShellFolderView_GetObject(m_hwndOwner, i);

        if (lstrcmpi(pjid->GetName(), pszName) == 0)
        {
            fPresent = TRUE;
            break;
        }
    }

    if (pszExt)
    {
        *pszExt = tcSave;
    }

    return fPresent;
}

LRESULT
CJobFolder::HandleFsNotify(
    LONG lNotification,
    LPCITEMIDLIST* ppidl)
{
    HRESULT hr = S_OK;
    CJobID jid;
    LRESULT lr;
    TCHAR from[MAX_PATH];
    TCHAR to[MAX_PATH];

    SHGetPathFromIDList(ppidl[0], from);
    DEBUG_OUT((DEB_USER1, "First pidl<%ws>\n", from));

    switch (lNotification)
    {
    case SHCNE_RENAMEITEM:
    {
        DEBUG_OUT((DEB_USER1, "SHCNE_RENAMEITEM\n"));

        LPTSTR psFrom = PathFindFileName(from) - 1;
        *psFrom = TEXT('\0');

        SHGetPathFromIDList(ppidl[1], to);
        DEBUG_OUT((DEB_USER1, "Second pidl<%ws>\n", to));
        LPTSTR psTo = PathFindFileName(to) - 1;
        *psTo = TEXT('\0');

        BOOL fFromJF = (lstrcmpi(m_pszFolderPath, from) == 0);
        BOOL fToJF = (lstrcmpi(m_pszFolderPath, to) == 0);

        *psFrom = TEXT('\\');
        *psTo = TEXT('\\');

        if (fFromJF == FALSE)
        {
            if (fToJF == FALSE)
            {
                break; // Nothing to do with job folder
            }

            //
            // ADD object
            //

            // First check if this object doesn't already exist in the UI

            if (_ObjectAlreadyPresent(to) == FALSE)
            {
                hr = jid.Load(NULL, to);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);

                _AddObject(&jid);
            }
        }
        else
        {
            if (fToJF == TRUE)
            {
                // Rename

                hr = jid.Load(NULL, to);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);

                CJobID jidOld;

                jidOld.LoadDummy(PathFindFileName(from));

                hr = _UpdateObject(&jidOld, &jid);
            }
            else
            {
                // Delete

                // Need to create a dummy jobid

                jid.LoadDummy(PathFindFileName(from));

                _RemoveObject(&jid);
            }
        }

        break;
    }
    case SHCNE_CREATE:
    {
        DEBUG_OUT((DEB_USER1, "SHCNE_CREATE\n"));

        if (_ObjectAlreadyPresent(from) == FALSE)
        {
            //
            // Not present, so add it.
            //

            hr = jid.Load(NULL, from);

            if (hr == S_FALSE)
            {
                //
                // Task is hidden. Don't display it.
                //
                break;
            }

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = _AddObject(&jid);
        }

        break;
    }
    case SHCNE_DELETE:
        DEBUG_OUT((DEB_USER1, "SHCNE_DELETE\n"));

        jid.LoadDummy(from);

        _RemoveObject(&jid);

        break;

    case SHCNE_UPDATEDIR:
        DEBUG_OUT((DEB_USER1, "SHCNE_UPDATEDIR\n"));

        this->OnUpdateDir();

        break;

    case SHCNE_UPDATEITEM:
        DEBUG_OUT((DEB_USER1, "SHCNE_UPDATEITEM\n"));

        hr = jid.Load(NULL, from);

        if (hr == S_FALSE)
        {
            //
            // Task is hidden. Don't display it. Always remove from the ID list
            // to take care of the case where this notification was due to the
            // task being hidden.
            //
            _RemoveObject(&jid);
            break;
        }

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = _UpdateObject(&jid, &jid);

        break;

    default:
     DEBUG_OUT((DEB_USER1, "JF_FSNOTIFY unprocessed <0x%x>\n", lNotification));
    }

    return 0L;
}



LRESULT
CALLBACK
NotifyWndProc(
    HWND    hWnd,
    UINT    iMessage,
    WPARAM  wParam,
    LPARAM  lParam)
{
    DEBUG_OUT((DEB_USER12, "NWP<0x%x>\n", iMessage));

    switch (iMessage)
    {
    case STUBM_SETDATA:
        SetWindowLongPtr(hWnd, 0, wParam);
        return TRUE;

    case STUBM_GETDATA:
        return GetWindowLongPtr(hWnd, 0);

    case JF_FSNOTIFY:
    {
        CJobFolder * pjf = (CJobFolder*)GetWindowLongPtr(hWnd, 0);

        if (pjf == NULL)
        {
            DEBUG_OUT((DEB_ERROR, "NotifyWndProc: NULL CJobFolder pointer\n"));
            return FALSE;
        }

        pjf->HandleFsNotify((LONG)lParam, (LPCITEMIDLIST*)wParam);

        return TRUE;
    }
    default:
        return DefWindowProc(hWnd, iMessage, wParam, lParam);
    }
}

TCHAR const c_szNotifyWindowClass[] = TEXT("JF Notify Window Class");
TCHAR const c_szNULL[] = TEXT("");

HWND
I_CreateNotifyWnd(void)
{
    WNDCLASS wndclass;

    if (!GetClassInfo(g_hInstance, c_szNotifyWindowClass, &wndclass))
    {
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = NotifyWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(PVOID) * 2;
        wndclass.hInstance     = g_hInstance;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = c_szNotifyWindowClass;

        if (!RegisterClass(&wndclass))
            return NULL;
    }

    return CreateWindowEx(WS_EX_TOOLWINDOW, c_szNotifyWindowClass, c_szNULL,
                      WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
                      NULL, NULL, g_hInstance, NULL);
}





#if DBG==1
void
JFDbgOutCallbackMsg(
    UINT    uMsg)
{
#define PROCESS_MSG(M) \
    case M: DEBUG_OUT((DEB_USER12, "UNPROCESSED msg<%s, %d>\n", #M, M)); break;

#define DONT_PROCESS_MSG(M) \
    case M: break;

    switch (uMsg)
    {
    DONT_PROCESS_MSG(DVM_GETHELPTEXT)
    DONT_PROCESS_MSG(DVM_GETTOOLTIPTEXT)
    DONT_PROCESS_MSG(DVM_GETBUTTONINFO)
    DONT_PROCESS_MSG(DVM_GETBUTTONS)
    DONT_PROCESS_MSG(DVM_INITMENUPOPUP)

    DONT_PROCESS_MSG(DVM_SELCHANGE)
    PROCESS_MSG(DVM_DRAWITEM)

    DONT_PROCESS_MSG(DVM_MEASUREITEM)
    DONT_PROCESS_MSG(DVM_EXITMENULOOP)

    PROCESS_MSG(DVM_RELEASE)

    DONT_PROCESS_MSG(DVM_GETCCHMAX)

    PROCESS_MSG(DVM_FSNOTIFY)

    DONT_PROCESS_MSG(DVM_WINDOWCREATED)
    DONT_PROCESS_MSG(DVM_WINDOWDESTROY)

    PROCESS_MSG(DVM_REFRESH)

    DONT_PROCESS_MSG(DVM_SETFOCUS)
    DONT_PROCESS_MSG(DVM_KILLFOCUS)

    PROCESS_MSG(DVM_QUERYCOPYHOOK)
    PROCESS_MSG(DVM_NOTIFYCOPYHOOK)

    DONT_PROCESS_MSG(DVM_GETDETAILSOF)
    DONT_PROCESS_MSG(DVM_COLUMNCLICK)

    PROCESS_MSG(DVM_QUERYFSNOTIFY)
    PROCESS_MSG(DVM_DEFITEMCOUNT)
    PROCESS_MSG(DVM_DEFVIEWMODE)
    PROCESS_MSG(DVM_UNMERGEMENU)
    PROCESS_MSG(DVM_INSERTITEM)
    PROCESS_MSG(DVM_DELETEITEM)

    DONT_PROCESS_MSG(DVM_UPDATESTATUSBAR)
    DONT_PROCESS_MSG(DVM_BACKGROUNDENUM)

    PROCESS_MSG(DVM_GETWORKINGDIR)

    DONT_PROCESS_MSG(DVM_GETCOLSAVESTREAM)
    DONT_PROCESS_MSG(DVM_SELECTALL)

    PROCESS_MSG(DVM_DIDDRAGDROP)
    PROCESS_MSG(DVM_FOLDERISPARENT)

    default:
        DEBUG_OUT((DEB_USER12, "UNKNOWN message <%d> !!!!\n", uMsg));
    }
}
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\schstate.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SchState.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/27/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "..\inc\common.hxx"
#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "resource.h"
#include "..\schedui\schedui.hxx"
#include <StrSafe.h>

#define MAX_MSGLEN 300
#define MAX_SCHED_START_WAIT    60  // seconds

//____________________________________________________________________________
//
//  Function:   GetSchSvcState
//
//  Synopsis:   returns the schedul service status
//
//  Arguments:  [dwState] -- IN
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
GetSchSvcState(
    DWORD &dwState)
{
    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(SERVICE_QUERY_STATUS);
        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        dwState = SvcStatus.dwCurrentState;

    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;
}

//____________________________________________________________________________
//
//  Function:   StartScheduler
//
//  Synopsis:   Start the schedule service
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
StartScheduler(void)
{
    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(
                              SERVICE_CHANGE_CONFIG | SERVICE_START |
                              SERVICE_QUERY_STATUS);
        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (SvcStatus.dwCurrentState == SERVICE_RUNNING)
        {
            // The service is already running.
            break;
        }

        if (StartService(hSchSvc, 0, NULL) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }
    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;
}

//____________________________________________________________________________
//
//  Function:   StopScheduler
//
//  Synopsis:   Stops the schedule service
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
StopScheduler(void)
{
    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(
                              SERVICE_CHANGE_CONFIG | SERVICE_STOP |
                              SERVICE_QUERY_STATUS);
        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (SvcStatus.dwCurrentState == SERVICE_STOPPED)
        {
            // The service is already stopped.
            break;
        }

        if (ControlService(hSchSvc, SERVICE_CONTROL_STOP, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }
    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;
}

//____________________________________________________________________________
//
//  Function:   PauseScheduler
//
//  Synopsis:   If fPause==TRUE requests the schedule service to pauses,
//              else to continue.
//
//  Arguments:  [fPause] -- IN
//
//  Returns:    HRESULT
//
//  History:    3/29/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
PauseScheduler(
    BOOL fPause)
{
    SC_HANDLE   hSchSvc = NULL;
    HRESULT     hr = S_OK;

    do
    {
        hSchSvc = OpenScheduleService(
                            SERVICE_PAUSE_CONTINUE | SERVICE_QUERY_STATUS);

        if (hSchSvc == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &SvcStatus) == FALSE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DEBUG_OUT_LASTERROR;
            break;
        }

        if (fPause == TRUE)
        {
            if ((SvcStatus.dwCurrentState == SERVICE_PAUSED) ||
                (SvcStatus.dwCurrentState == SERVICE_PAUSE_PENDING))
            {
                // Nothing to do here.
                break;
            }
            else if ((SvcStatus.dwCurrentState == SERVICE_STOPPED) ||
                     (SvcStatus.dwCurrentState == SERVICE_STOP_PENDING))
            {
                Win4Assert(0 && "Unexpected");
                hr = E_UNEXPECTED;
                CHECK_HRESULT(hr);
                break;
            }
            else
            {
                if (ControlService(hSchSvc, SERVICE_CONTROL_PAUSE, &SvcStatus)
                    == FALSE)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DEBUG_OUT_LASTERROR;
                    break;
                }
            }
        }
        else // continue
        {
            if ((SvcStatus.dwCurrentState == SERVICE_RUNNING) ||
                (SvcStatus.dwCurrentState == SERVICE_CONTINUE_PENDING))
            {
                // Nothing to do here.
                break;
            }
            else if ((SvcStatus.dwCurrentState == SERVICE_STOPPED) ||
                     (SvcStatus.dwCurrentState == SERVICE_STOP_PENDING))
            {
                Win4Assert(0 && "Unexpected");
                hr = E_UNEXPECTED;
                CHECK_HRESULT(hr);
                break;
            }
            else
            {
                if (ControlService(hSchSvc, SERVICE_CONTROL_CONTINUE,
                                                            &SvcStatus)
                    == FALSE)
                {
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    DEBUG_OUT_LASTERROR;
                    break;
                }
            }
        }

    } while (0);

    if (hSchSvc != NULL)
    {
        CloseServiceHandle(hSchSvc);
    }

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   UserCanChangeService
//
//  Synopsis:   Returns TRUE if the UI should allow the user to invoke
//              service start, stop, pause/continue, or at account options.
//
//  Returns:    TRUE if focus is local machine and OS is win95 or it is NT
//              and the user is an admin.
//
//  History:    4-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
UserCanChangeService(
    LPCTSTR pszServerFocus)
{
    if (pszServerFocus)
    {
        return FALSE;
    }

    //
    // Determine if user is an admin.  If not, some items under the
    // advanced menu will be disabled.
    // BUGBUG  A more accurate way to do this would be to attempt to open
    // the relevant registry keys and service handle.
    //
    return IsThreadCallerAnAdmin(NULL);
}


//+--------------------------------------------------------------------------
//
//  Function:   PromptForServiceStart
//
//  Synopsis:   If the service is not started or is paused, prompt the user
//              to allow us to start/continue it.
//
//  Returns:    S_OK    - service was already running, or was successfully
//                          started or continued.
//              S_FALSE - user elected not to start/continue service
//              E_*     - error starting/continuing service
//
//  History:    4-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
PromptForServiceStart(
    HWND hwnd)
{
    HRESULT hr = S_OK;

    do
    {
        //
        // Get the current service state
        //

        DWORD dwState = SERVICE_STOPPED;

        hr = GetSchSvcState(dwState);

        if (FAILED(hr))
        {
            dwState = SERVICE_STOPPED;
            hr = S_OK; // reset
        }

        //
        // Determine the required action
        //

        UINT uMsg = 0;

        if (dwState == SERVICE_STOPPED ||
            dwState == SERVICE_STOP_PENDING)
        {
            uMsg = IDS_START_SERVICE;
        }
        else if (dwState == SERVICE_PAUSED ||
                 dwState == SERVICE_PAUSE_PENDING)
        {
            uMsg = IDS_CONTINUE_SERVICE;
        }
        else if (dwState == SERVICE_START_PENDING)
        {
            uMsg = IDS_START_PENDING;
        }

        //
        // If the service is running, there's nothing to do.
        //

        if (!uMsg)
        {
            hr = S_OK;
            break;
        }

        if (uMsg == IDS_START_PENDING)
        {
            SchedUIMessageDialog(hwnd,
                                 uMsg,
                                 MB_SETFOREGROUND      |
                                    MB_TASKMODAL       |
                                    MB_ICONINFORMATION |
                                    MB_OK,
                                 NULL);
        }
        else
        {
            if (SchedUIMessageDialog(hwnd, uMsg,
                        MB_SETFOREGROUND |
                        MB_TASKMODAL |
                        MB_ICONQUESTION |
                        MB_YESNO,
                        NULL)
                == IDNO)
            {
                hr = S_FALSE;
                break;
            }
        }

        CWaitCursor waitCursor;

        if (uMsg == IDS_START_SERVICE)
        {
            hr = StartScheduler();

            if (FAILED(hr))
            {
                SchedUIErrorDialog(hwnd, IERR_STARTSVC, (LPTSTR)NULL);
                break;
            }

            // Give the schedule service time to start up.
            Sleep(2000);
        }
        else if (uMsg == IDS_CONTINUE_SERVICE)
        {
            PauseScheduler(FALSE);
        }

        for (int count=0; count < 60; count++)
        {
            GetSchSvcState(dwState);

            if (dwState == SERVICE_RUNNING)
            {
                break;
            }

            Sleep(1000); // Sleep for 1 seconds.
        }

        if (dwState != SERVICE_RUNNING)
        {
            //
            // unable to start/continue the service.
            //

            SchedUIErrorDialog(hwnd,
                (uMsg == IDS_START_SERVICE) ? IERR_STARTSVC
                                                : IERR_CONTINUESVC,
                (LPTSTR)NULL);
            hr = E_FAIL;
            break;
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   QuietStartContinueService
//
//  Synopsis:   Start or continue the service without requiring user
//              interaction.
//
//  Returns:    S_OK   - service running
//              E_FAIL - timeout or failure
//
//  History:    5-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
QuietStartContinueService()
{
    HRESULT hr = S_OK;
    DWORD dwState = SERVICE_STOPPED;

    do
    {
        hr = GetSchSvcState(dwState);

        if (FAILED(hr))
        {
            dwState = SERVICE_STOPPED;
            hr = S_OK; // reset
        }

        //
        // If the service is running, there's nothing to do.
        //

        if (dwState == SERVICE_RUNNING)
        {
            break;
        }

        //
        // If it's stopped, request a start.  If it's paused, request
        // continue.
        //

        CWaitCursor waitCursor;

        switch (dwState)
        {
        case SERVICE_STOPPED:
        case SERVICE_STOP_PENDING:
            hr = StartScheduler();
            break;

        case SERVICE_PAUSED:
        case SERVICE_PAUSE_PENDING:
            hr = PauseScheduler(FALSE);
            break;
        }

        if (FAILED(hr))
        {
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Wait for its state to change to running
        //

        for (int count=0; count < MAX_SCHED_START_WAIT; count++)
        {
            GetSchSvcState(dwState);

            if (dwState == SERVICE_RUNNING)
            {
                break;
            }

            Sleep(1000); // Sleep for 1 seconds.
        }

        if (dwState != SERVICE_RUNNING)
        {
            //
            // unable to start/continue the service.
            //

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    } while (0);

    return hr;
}




//____________________________________________________________________________
//
//  Function:   OpenScheduleService
//
//  Synopsis:   Opens a handle to the "Schedule" service
//
//  Arguments:  [dwDesiredAccess] -- desired access
//
//  Returns:    Handle; if NULL, use GetLastError()
//
//  History:    15-Nov-1996 AnirudhS  Created
//
//____________________________________________________________________________

SC_HANDLE
OpenScheduleService(DWORD dwDesiredAccess)
{
    SC_HANDLE hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSC == NULL)
    {
        DEBUG_OUT_LASTERROR;
        return NULL;
    }

    SC_HANDLE hSchSvc = OpenService(hSC, SCHED_SERVICE_NAME, dwDesiredAccess);

    CloseServiceHandle(hSC);

    if (hSchSvc == NULL)
    {
        DEBUG_OUT_LASTERROR;
    }

    return hSchSvc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\viewlog.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       viewlog.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/25/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"

#include "..\inc\common.hxx"
#include "..\inc\resource.h"
#include "..\inc\misc.hxx"
#include "resource.h"

extern HINSTANCE g_hInstance;


LRESULT
OnViewLog_RegGetValue(
    HKEY    hKeyMachine,
    LPCTSTR pszValueName,
    LPTSTR  pszValueStr);


#define SUBKEY_LOGPATH      TEXT("LogPath")
#define FMT_TSTR    "%S"

//____________________________________________________________________________
//
//  Function:   OnViewLog
//
//  Synopsis:   Open the job sheduler log.
//
//  Arguments:  [hwndOwner] -- IN
//
//  Returns:    void
//
//  History:    3/25/1996   RaviR   Created
//
//____________________________________________________________________________

void
OnViewLog(
    LPTSTR  lpMachineName,
    HWND    hwndOwner)
{
    TCHAR   tszLogPath[MAX_PATH + 1];
    ULONG   ulTemp;
    HKEY    hKeyMachine = HKEY_LOCAL_MACHINE;
    LRESULT lr = 0;

    if (lpMachineName != NULL)
    {
        lr = RegConnectRegistry(lpMachineName, HKEY_LOCAL_MACHINE,
                                                        &hKeyMachine);
        if (lr != ERROR_SUCCESS)
        {
            CHECK_LASTERROR(lr);
            return;
        }
    }

    //
    //  Get the log file name.
    //

    lr = OnViewLog_RegGetValue(hKeyMachine, SUBKEY_LOGPATH, tszLogPath);

    RegCloseKey(hKeyMachine);

    if (lr == ERROR_SUCCESS)
    {
        if (lpMachineName != NULL)
        {
            // If path is drive based convert it to share based.
            if (s_isDriveLetter(tszLogPath[0]) && tszLogPath[1] == TEXT(':'))
            {
                TCHAR tszBuf[MAX_PATH + 1];
                StringCchCopy(tszBuf, MAX_PATH + 1, tszLogPath);
                tszBuf[1] = TEXT('$');

                if (lpMachineName[0] == TEXT('\\'))
                {
                    Win4Assert(lpMachineName[1] == TEXT('\\'));
                    tszLogPath[0] = TEXT('\0');
                }
                else
                {
                    StringCchCopy(tszLogPath, MAX_PATH + 1, TEXT("\\\\"));
                }

                StringCchCat(tszLogPath, MAX_PATH + 1, lpMachineName);
                StringCchCat(tszLogPath, MAX_PATH + 1, TEXT("\\"));
                StringCchCat(tszLogPath, MAX_PATH + 1, tszBuf);

                DEBUG_OUT((DEB_USER1, "Viewing log -> " FMT_TSTR "\n", tszLogPath));
            }
        }
    }
    else
    {
        if (lpMachineName == NULL)
        {
            CHECK_LASTERROR(lr);
            return;
        }

        ulTemp = ExpandEnvironmentStrings(TSZ_LOG_NAME_DEFAULT,
                                            tszLogPath, MAX_PATH);

        if (ulTemp == 0)
        {
            DEBUG_OUT_LASTERROR;
            return;
        }

        if (ulTemp > MAX_PATH)
        {
            CHECK_LASTERROR(ERROR_INSUFFICIENT_BUFFER);
            return;
        }
    }

    //
    //  Create a process to open the log.
    //

    HINSTANCE hinst = ShellExecute(0, TEXT("open"), tszLogPath, 0, 0, SW_SHOW);

    if ((INT_PTR)hinst <= 32)
    {
        DEBUG_OUT((DEB_ERROR, " returned %dL\n", hinst));
    }
}


//____________________________________________________________________________
//
//  Function:   OnViewLog_RegGetValue
//
//  Synopsis:   S
//
//  Arguments:  [pszValueName] -- IN
//              [pszValueStr] -- IN
//
//  Returns:    LRESULT
//
//  History:    3/25/1996   RaviR   Created
//
//____________________________________________________________________________

LRESULT
OnViewLog_RegGetValue(
    HKEY    hKeyMachine,
    LPCTSTR pszValueName,
    LPTSTR  pszValueStr)
{
    HKEY    hKey = NULL;
    LRESULT lr = ERROR_SUCCESS;

    //
    // Read the log path and maximum size from the registry.
    //

    lr = RegOpenKeyEx(hKeyMachine, SCH_AGENT_KEY, 0, KEY_READ, &hKey);

    if (lr == ERROR_SUCCESS)
    {
        TCHAR szBuff[MAX_PATH];
        DWORD dwTemp = MAX_PATH * sizeof(TCHAR);
        DWORD dwType;

        lr = RegQueryValueEx(hKey, pszValueName, 0, &dwType,
                            (UCHAR *)szBuff, &dwTemp);

        if (lr == ERROR_SUCCESS)
        {
            switch (dwType)
            {
            case REG_SZ:
                CopyMemory(pszValueStr, szBuff, dwTemp);
                break;

            case REG_EXPAND_SZ:
                dwTemp = ExpandEnvironmentStrings(szBuff, pszValueStr,
                                                              MAX_PATH);
                if (dwTemp > MAX_PATH)
                {
                    lr = ERROR_INSUFFICIENT_BUFFER;
                }
                break;
            }
        }

        RegCloseKey(hKey);
    }

    return lr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idl\atsvcinc.h ===
/*++

Copyright (c) 1991 - 2002 Microsoft Corporation

Module Name:

    AtSvcInc.h

Abstract:

    This file allows us to include standard system header files in the AtSvc.idl file.
    The main AtSvc.idl file imports a file called AtSvcInc.idl.  This allows the .idl
    file to use the types defined in these header files.  It also causes the following
    line to be added in the MIDL generated header file:

    #include "AtSvcInc.h"

    Thus these types are available to the RPC stub routines as well.

--*/

#include <windef.h>
#include <lmcons.h>
#include <lmat.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\xicon.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       xicon.cxx
//
//  Contents:   implementation of CJobsEI & CJobsEIA classes.
//
//  Classes:
//
//  Functions:
//
//  History:    1/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include "macros.h"
#include "..\inc\resource.h"

#include "dll.hxx"
#include "jobidl.hxx"
#include "util.hxx"
#include "jobicons.hxx"

//
// extern
//

extern HINSTANCE g_hInstance;

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1


const TCHAR c_szTask[] = TEXT("task!");
extern const TCHAR TEMPLATE_STR[] = TEXT("wizard:");

//____________________________________________________________________________
//
//  Class:      CJobsEI
//
//  Purpose:    Provide IExtractIcon interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsEI : public IExtractIcon
{
public:
    CJobsEI(LPCTSTR pszFolderPath, LPITEMIDLIST pidl)
        : m_pszFolderPath(pszFolderPath), m_pidl(pidl),
          m_JobIcon(), m_ulRefs(1) {}

    ~CJobsEI() { ILFree(m_pidl); }

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IExtractIcon methods
    STDMETHOD(GetIconLocation)(UINT uFlags, LPTSTR szIconFile, UINT cchMax,
                                int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                HICON *phiconSmall, UINT nIconSize);
private:
    CDllRef         m_DllRef;
    LPCTSTR         m_pszFolderPath;
    LPITEMIDLIST    m_pidl;
    CJobIcon        m_JobIcon;
};

//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsEI);

STDMETHODIMP
CJobsEI::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IExtractIcon, riid))
    {
        *ppvObj = (IUnknown*)(IExtractIcon*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsEI::IExtractIcon::GetIconLocation
//
//  Arguments:  [uFlags] -- IN
//              [szIconFile] -- IN
//              [cchMax] -- IN
//              [piIndex] -- IN
//              [pwFlags] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEI::GetIconLocation(
    UINT    uFlags,
    LPTSTR  szIconFile,
    UINT    cchMax,
    int   * piIndex,
    UINT  * pwFlags)
{
    TRACE(CJobsEI, GetIconLocation);

    szIconFile[0] = '\0'; // init

    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;

    PJOBID pjid = (PJOBID)m_pidl;

    if (cchMax <= (UINT)(lstrlen(c_szTask) + lstrlen(pjid->GetAppName())))
    {
        DEBUG_OUT((DEB_ERROR, 
                   "CJobsEI::GetIconLocation: insufficient buffer\n"));
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    StringCchCopy(szIconFile, cchMax, c_szTask);

    if (pjid->IsTemplate())
    {
        StringCchCat(szIconFile, cchMax, TEMPLATE_STR);
        *piIndex = 0;
    }
    else 
    {
        StringCchCat(szIconFile, cchMax, pjid->GetAppName());
        *piIndex = ! pjid->IsJobFlagOn(TASK_FLAG_DISABLED);
    }

    return S_OK;
}



//____________________________________________________________________________
//
//  Member:     CJobsEI::Extract
//
//  Arguments:  [pszFile] -- IN
//              [nIconIndex] -- IN
//              [phiconLarge] -- IN
//              [phiconSmall] -- IN
//              [nIconSize] -- IN
//
//  Returns:    STDMETHODIMP
//
//  History:    1/5/1996   RaviR   Created
//____________________________________________________________________________

STDMETHODIMP
CJobsEI::Extract(
    LPCTSTR pszFile,
    UINT    nIconIndex,
    HICON * phiconLarge,
    HICON * phiconSmall,
    UINT    nIconSize)
{
    TRACE(CJobsEI, Extract);

    if (((PJOBID)m_pidl)->IsTemplate())
    {
        m_JobIcon.GetTemplateIcons(phiconLarge, phiconSmall, nIconSize);
    }
    else
    {
        m_JobIcon.GetIcons(((PJOBID)m_pidl)->GetAppName(), nIconIndex, phiconLarge, phiconSmall, nIconSize);
    }

    return S_OK;
}


//____________________________________________________________________________
//
//  Function:   JFGetExtractIcon
//
//  Synopsis:   Function to create IExtractIcon
//
//  Arguments:  [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetExtractIcon(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl)
{
    Win4Assert(pidl != NULL);

    LPITEMIDLIST pidlClone = ILClone(pidl);

    if (pidlClone == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CJobsEI* pObj = new CJobsEI(pszFolderPath, pidlClone);

    if (NULL == pObj)
    {
        ILFree(pidlClone);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IExtractIcon, ppvObj);

    pObj->Release();

    return hr;
}




////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//////////////////// CJobsEIA //////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsi
//
//  Synopsis:   Convert unicode string [pwsz] to multibyte in buffer [sz].
//
//  Arguments:  [szTo]     - destination buffer
//              [pwszFrom] - source string
//              [cbTo]     - size of destination buffer, in bytes
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - WideCharToMultiByte failed
//
//  Modifies:   *[szTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [szTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
UnicodeToAnsi(
    LPSTR   szTo,
    LPCWSTR pwszFrom,
    ULONG   cbTo)
{
    HRESULT hr = S_OK;
    ULONG   cbWritten;

    cbWritten = WideCharToMultiByte(CP_ACP,
                                    0,
                                    pwszFrom,
                                    -1,
                                    szTo,
                                    cbTo,
                                    NULL,
                                    NULL);

    if (!cbWritten)
    {
        szTo[cbTo - 1] = '\0'; // ensure NULL termination
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}


//____________________________________________________________________________
//
//  Class:      CJobsEIA
//
//  Purpose:    Provide IExtractIconA interface to Job Folder objects.
//
//  History:    1/24/1996   RaviR   Created
//____________________________________________________________________________

class CJobsEIA : public IExtractIconA
{
public:
    CJobsEIA(LPCTSTR pszFolderPath, LPITEMIDLIST pidl)
        : m_pszFolderPath(pszFolderPath), m_pidl(pidl),
          m_JobIcon(), m_ulRefs(1) {}

    ~CJobsEIA() { ILFree(m_pidl); }

    // IUnknown methods
    DECLARE_STANDARD_IUNKNOWN;

    // IExtractIcon methods
    STDMETHOD(GetIconLocation)(UINT uFlags, LPSTR szIconFile, UINT cchMax,
                                int *piIndex, UINT *pwFlags);
    STDMETHOD(Extract)(LPCSTR pszFile, UINT nIconIndex, HICON *phiconLarge,
                                HICON *phiconSmall, UINT nIconSize);
private:
    CDllRef         m_DllRef;
    LPCTSTR         m_pszFolderPath;
    LPITEMIDLIST    m_pidl;
    CJobIcon        m_JobIcon;
};


//____________________________________________________________________________
//
//  Member:     IUnknown methods
//____________________________________________________________________________

IMPLEMENT_STANDARD_IUNKNOWN(CJobsEIA);

STDMETHODIMP
CJobsEIA::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if (IsEqualIID(IID_IUnknown, riid) ||
        IsEqualIID(IID_IExtractIconA, riid))
    {
        *ppvObj = (IUnknown*)(IExtractIconA*) this;
        this->AddRef();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}


//____________________________________________________________________________
//
//  Member:     CJobsEIA::GetIconLocation
//
//  Arguments:  [uFlags] -- IN
//              [szIconFile] -- IN
//              [cchMax] -- IN
//              [piIndex] -- IN
//              [pwFlags] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEIA::GetIconLocation(
    UINT    uFlags,
    LPSTR   szIconFile,
    UINT    cchMax,
    int   * piIndex,
    UINT  * pwFlags)
{
    TRACE(CJobsEIA, GetIconLocation);
    HRESULT hr = S_OK;

    szIconFile[0] = '\0'; // init

    if (uFlags & GIL_OPENICON)
    {
        return S_FALSE;
    }

    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE;

    WCHAR wcBuff[MAX_PATH +1];

    PJOBID pjid = (PJOBID)m_pidl;

    StringCchCopy(wcBuff, MAX_PATH+1,  c_szTask);

    if (pjid->IsTemplate())
    {
        StringCchCat(wcBuff, MAX_PATH+1, TEMPLATE_STR);
        *piIndex = 0;
    }
    else 
    {
        StringCchCat(wcBuff, MAX_PATH+1, pjid->GetAppName());
        *piIndex = ! pjid->IsJobFlagOn(TASK_FLAG_DISABLED);
    }

    hr = UnicodeToAnsi(szIconFile, wcBuff, cchMax);


    return hr;
}

//____________________________________________________________________________
//
//  Member:     CJobsEIA::Extract
//
//  Arguments:  [pszFile] -- IN
//              [nIconIndex] -- IN
//              [phiconLarge] -- IN
//              [phiconSmall] -- IN
//              [nIconSize] -- IN
//
//  Returns:    HTRESULT
//
//  History:    1/5/1996   RaviR   Created
//
//____________________________________________________________________________

STDMETHODIMP
CJobsEIA::Extract(
    LPCSTR pszFile,
    UINT   nIconIndex,
    HICON* phiconLarge,
    HICON* phiconSmall,
    UINT   nIconSize)
{
    TRACE(CJobsEIA, Extract);

    if (((PJOBID)m_pidl)->IsTemplate())
    {
        m_JobIcon.GetTemplateIcons(phiconLarge, phiconSmall, nIconSize);
    }
    else
    {
        m_JobIcon.GetIcons(((PJOBID)m_pidl)->GetAppName(), nIconIndex, phiconLarge, phiconSmall, nIconSize);
    }

    return S_OK;
}


//____________________________________________________________________________
//
//  Function:   JFGetExtractIconA
//
//  Synopsis:   Function to create IExtractIconA
//
//  Arguments:  [ppvObj] -- OUT
//
//  Returns:    HRESULT
//
//  History:    1/31/1996   RaviR   Created
//
//____________________________________________________________________________

HRESULT
JFGetExtractIconA(
    LPVOID        * ppvObj,
    LPCTSTR         pszFolderPath,
    LPCITEMIDLIST   pidl)
{
    Win4Assert(pidl != NULL);

    LPITEMIDLIST pidlClone = ILClone(pidl);

    if (pidlClone == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CJobsEIA* pObj = new CJobsEIA(pszFolderPath, pidlClone);

    if (NULL == pObj)
    {
        ILFree(pidlClone);
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pObj->QueryInterface(IID_IExtractIcon, ppvObj);

    pObj->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\folderui\util.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       util.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1/8/1996   RaviR   Created (Copied from BruceFo's lmshare)
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "dbg.h"
#include <mstask.h>     // Necessary for util.hxx
#include "jobidl.hxx"
#include "util.hxx"
#include "resource.h"
#include "commdlg.h"
#include "..\inc\sadat.hxx"

extern HINSTANCE g_hInstance;

HRESULT
GetSchSvcState(
    DWORD &dwCurrState);

//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________
//
//  Menu merging routines
//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________
//___________________________________________________________________________


HMENU
LoadPopupMenu(
    HINSTANCE hinst,
    UINT id)
{
    HMENU hmParent = LoadMenu(hinst, MAKEINTRESOURCE(id));

    if (NULL == hmParent)
    {
        return NULL;
    }

    HMENU hmPopup = GetSubMenu(hmParent, 0);
    RemoveMenu(hmParent, 0, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}


HMENU
UtGetMenuFromID(
    HMENU hmMain,
    UINT uID
    )
{
    MENUITEMINFO mii;

    mii.cbSize = sizeof(mii);
    mii.fMask  = MIIM_SUBMENU;
    mii.cch    = 0;     // just in case

    if (!GetMenuItemInfo(hmMain, uID, FALSE, &mii))
    {
        return NULL;
    }

    return mii.hSubMenu;
}


int
UtMergePopupMenus(
    HMENU hmMain,
    HMENU hmMerge,
    int   idCmdFirst,
    int   idCmdLast)
{
    int i;
    int idTemp;
    int idMax = idCmdFirst;

    for (i = GetMenuItemCount(hmMerge) - 1; i >= 0; --i)
    {
        MENUITEMINFO mii;

        mii.cbSize = sizeof(mii);
        mii.fMask  = MIIM_ID | MIIM_SUBMENU;
        mii.cch    = 0;     // just in case

        if (!GetMenuItemInfo(hmMerge, i, TRUE, &mii))
        {
            continue;
        }

        idTemp = Shell_MergeMenus(
                    UtGetMenuFromID(hmMain, mii.wID),
                    mii.hSubMenu,
                    0,
                    idCmdFirst,
                    idCmdLast,
                    MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);

        if (idMax < idTemp)
        {
            idMax = idTemp;
        }
    }

    return idMax;
}


void
UtMergeMenu(
    HINSTANCE hinst,
    UINT idMainMerge,
    UINT idPopupMerge,
    LPQCMINFO pqcm)
{
    HMENU hmMerge;
    UINT  idMax = pqcm->idCmdFirst;
    UINT  idTemp;

    if (idMainMerge
        && (hmMerge = LoadPopupMenu(hinst, idMainMerge)) != NULL)
    {
        idMax = Shell_MergeMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->indexMenu,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast,
                        MM_SUBMENUSHAVEIDS);

        DestroyMenu(hmMerge);
    }

    if (idPopupMerge
        && (hmMerge = LoadMenu(hinst, MAKEINTRESOURCE(idPopupMerge))) != NULL)
    {
        idTemp = UtMergePopupMenus(
                        pqcm->hmenu,
                        hmMerge,
                        pqcm->idCmdFirst,
                        pqcm->idCmdLast);

        if (idMax < idTemp)
        {
            idMax = idTemp;
        }

        DestroyMenu(hmMerge);
    }

    pqcm->idCmdFirst = idMax;
}




//+--------------------------------------------------------------------------
//
//  Function:   ContainsTemplateObject
//
//  Synopsis:   Return TRUE if [apidl] contains a CJobID object which is
//              marked as a template object.
//
//  Arguments:  [cidl]  - number of item id lists in [apidl]
//              [apidl] - array of item id lists, each of which can contain
//                          only one itemid.
//
//  History:    5-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
ContainsTemplateObject(
    UINT cidl,
    LPCITEMIDLIST *apidl)
{
    UINT i;

    for (i = 0; i < cidl; i++)
    {
        if (JF_IsValidID(apidl[i]))
        {
            if (ID_TEMPLATE == ((PJOBID) apidl[i])->_id )
            {
                return TRUE;
            }
        }
        else
        {
            DEBUG_OUT((DEB_WARN, "ContainsTemplateObject: item %u not jobid\n", i));
        }
    }
    return FALSE;
}


//____________________________________________________________________________
//
//  Function:   EnsureUniquenessOfFileName
//
//  Synopsis:   Internal function. pszFile's buffer size assumed to be
//              greater than MAX_PATH.
//
//  Arguments:  [pszFile] -- IN, OUT
//
//  Returns:    void
//
//  History:    2/8/1996   RaviR   Created
//
//____________________________________________________________________________

void
EnsureUniquenessOfFileName(
    LPTSTR  pszFile,
    size_t bufLen)
{
	Win4Assert( NULL != pszFile );

    int     iPostFix = 2;

    LPTSTR  pszName = PathFindFileName(pszFile);
    LPTSTR  pszExt = PathFindExtension(pszName);

    TCHAR szBufExt[10];
    StringCchCopy(szBufExt, 10, pszExt);

    int lenUpToExt = (int)(pszExt - pszFile); // lstrlen(pszFile) - lstrlen(pszExt)

    Win4Assert(lenUpToExt >= 0);

    //
    //  Ensure uniqueness of the file
    //

    while (1)
    {
        HANDLE hFile = CreateFile(pszFile, GENERIC_READ,
                                FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                FILE_FLAG_SEQUENTIAL_SCAN, NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            DWORD dwErr = GetLastError();
            if (dwErr == ERROR_FILE_NOT_FOUND)
            {
                //
                // No file with this name exists. So this name is unique.
                //
                break;
            }
        }
        else
        {
            CloseHandle(hFile);
        }

        // post fix a number to make the file name unique
        TCHAR szBufPostFix[10];
        StringCchPrintf(szBufPostFix, 10, TEXT(" %d"), iPostFix++);
        StringCchCopy(&pszFile[lenUpToExt], (bufLen - lenUpToExt), szBufPostFix);
        StringCchCat(&pszFile[lenUpToExt], (bufLen - lenUpToExt), szBufExt);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   CheckSaDat
//
//  Synopsis:   Update or create the sa.dat file if it is missing or its
//              waitable timer support flag disagrees with what the system
//              reports.
//
//  Arguments:  [tszFolderPath] - path to tasks folder
//
//  History:    11-12-1997   DavidMun   Created
//
//  Notes:      Call only with [tszFolderPath] a path on the local machine.
//
//---------------------------------------------------------------------------

VOID
CheckSaDat(
    LPCTSTR tszFolderPath)
{
    HRESULT hr;
    DWORD dwVersion;
    BYTE  bSvcFlags;
    BYTE  bPlatformId;

    hr = SADatGetData(tszFolderPath,
                      &dwVersion,
                      &bPlatformId,
                      &bSvcFlags);

    BOOL fNeedUpdate = FALSE;

    if (SUCCEEDED(hr))
    {
        BOOL fSaDatTimersFlag = bSvcFlags & SA_DAT_SVCFLAG_RESUME_TIMERS;
        BOOL fTimers = ResumeTimersSupported();

        if (fSaDatTimersFlag && !fTimers || !fSaDatTimersFlag && fTimers)
        {
            fNeedUpdate = TRUE;
        }
    }
    else
    {
        fNeedUpdate = TRUE;
    }

    if (fNeedUpdate)
    {
        DWORD dwState;

        hr = GetSchSvcState(dwState);

        if (SUCCEEDED(hr))
        {

            BOOL fRunning = (dwState != SERVICE_STOPPED &&
                             dwState != SERVICE_STOP_PENDING);

            SADatCreate(tszFolderPath, fRunning);
        }
    }
}




#if DBG==1

LPTSTR DbgGetTimeStr(FILETIME &ft)
{
    SYSTEMTIME st;
    FileTimeToSystemTime(&ft, &st);
    return DbgGetTimeStr(st);
}

LPTSTR DbgGetTimeStr(SYSTEMTIME &st)
{
    static WCHAR s_szTimeStamp[20];  // space for time & date in format below

    StringCchPrintf(s_szTimeStamp,
                    20,
                    TEXT("%02d:%02d:%02d %d/%02d/%d"),
                    st.wHour,
                    st.wMinute,
                    st.wSecond,
                    st.wMonth,
                    st.wDay,
                    st.wYear);

    return s_szTimeStamp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\client\idletskc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idletskc.h

Abstract:

    This module contains private declarations to support idle tasks.
    Note that client does not stand for the users of the idle task
    API, but the code in the users process that implements these APIs.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETSKC_H_
#define _IDLETSKC_H_

//
// Include common definitions.
//

#include "idlrpc.h"
#include "idlecomn.h"

//
// Client function declarations.
//

DWORD
ItCliInitialize(
    VOID
    );

VOID
ItCliUninitialize(
    VOID
    );

DWORD
ItCliRegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

VOID
ItCliUnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent   
    );

#endif // _IDLETSKC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\client\idlrpc_client.c ===
#include <idlrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\inc\idlesrv.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idlesrv.h

Abstract:

    This module contains declarations for the idle detection server
    host.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLESRV_H_
#define _IDLESRV_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Functions to initialize / uninitialize the server.
//

DWORD
ItSrvInitialize (
    VOID
    );

VOID
ItSrvUninitialize (
    VOID
    );

#ifdef __cplusplus
}
#endif

#endif // _IDLESRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\client\idletskc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    idletskc.c

Abstract:

    This module implements the idle task client APIs.

Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

//
// Define this to note that we are being built as a part of advapi32 and the
// routines we'll call from advapi32 should not be marked as "dll imports".
//

#define _ADVAPI32_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "idletskc.h"

//
// Implementation of client side exposed functions.
//

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    )

/*++

Routine Description:

    This function is a stub to ItCliRegisterIdleTask. Please see that
    function for comments.

Arguments:

    See ItCliRegisterIdleTask.

Return Value:

    See ItCliRegisterIdleTask.

--*/

{
    // FUTURE-2002/03/26-ScottMa -- The extra layer of calls can be safely
    //   removed to reduce clutter and improve clarity.

    return ItCliRegisterIdleTask(IdleTaskId,
                                 ItHandle,
                                 StartEvent,
                                 StopEvent);
}

DWORD
ItCliRegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    )

/*++

Routine Description:

    Registers an idle task in the current process with the server and
    returns handles to two events that will be used by the server to
    signal the idle task to start/stop running.

    When the task gets to run and is completed, or not needed anymore,
    UnregisterIdleTask should be called with the same Id and returned
    event handles.

    The caller should not set and reset the events. It should just
    wait on them.
    
    An idle task should not run indefinitely as this may prevent the
    system from signaling other idle tasks. There is no guarantee that
    the StartEvent will be signaled, as the system could be always
    active/in use. If your task really has to run at least once every
    so often you can also queue a timer-queue timer.

Arguments:

    IdleTaskId - Which idle task this is. There can be only a single
      task registered from a process with this id.

    ItHandle - Handle to registered idle task is returned here.

    StartEvent - Handle to a manual reset event that is set when the
      task should start running is returned here.

    StopEvent - Handle to a manual reset event that is set when the
      task should stop running is returned here.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    BOOLEAN CreatedStartEvent;
    BOOLEAN CreatedStopEvent;
    IT_IDLE_TASK_PROPERTIES IdleTask;
    DWORD ProcessId;

    //
    // Initialize locals.
    //
    
    CreatedStartEvent = FALSE;
    CreatedStopEvent = FALSE;
    ProcessId = GetCurrentProcessId();

    DBGPR((ITID,ITTRC,"IDLE: CliRegisterIdleTask(%d,%d)\n",IdleTaskId,ProcessId));

    //
    // Setup IdleTask fields.
    //

    IdleTask.Size = sizeof(IdleTask);
    IdleTask.IdleTaskId = IdleTaskId;
    IdleTask.ProcessId = ProcessId;

    //
    // Create events for start/stop. Start event is initially
    // nonsignalled.
    //

    (*StartEvent) = CreateEvent(NULL, TRUE, FALSE, NULL);
    
    if (!(*StartEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    IdleTask.StartEventHandle = (ULONG_PTR) (*StartEvent);
    
    CreatedStartEvent = TRUE;

    //
    // Stop event is initially signaled.
    //

    (*StopEvent) = CreateEvent(NULL, TRUE, TRUE, NULL);
    
    if (!(*StopEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    IdleTask.StopEventHandle = (ULONG_PTR) (*StopEvent);

    CreatedStopEvent = TRUE;
    
    //
    // Call the server.
    //

    RpcTryExcept {

        ErrorCode = ItSrvRegisterIdleTask(NULL, (IT_HANDLE *) ItHandle, &IdleTask);
    } 
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept
    
 cleanup:

    if (ErrorCode != ERROR_SUCCESS) 
    {

        // FUTURE-2002/03/26-ScottMa -- For safety, the event parameters
        //   should be set to NULL after closing the handles on failure.
        //   Also, the ItHandle parameter should be cleared.

        if (CreatedStartEvent) 
        {
            CloseHandle(*StartEvent);
            *StartEvent = NULL;
        }

        if (CreatedStopEvent) 
        {
            CloseHandle(*StopEvent);
            *StopEvent = NULL;
        }
    }

    DBGPR((ITID,ITTRC,"IDLE: CliRegisterIdleTask(%d,%d,%p)=%x\n",IdleTaskId,ProcessId,*ItHandle,ErrorCode));

    return ErrorCode;
}

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    )

/*++

Routine Description:

    This function is a stub to ItCliUnregisterIdleTask. Please see
    that function for comments.

Arguments:

    See ItCliUnregisterIdleTask.

Return Value:

    Win32 error code.

--*/

{
    // FUTURE-2002/03/26-ScottMa -- The extra layer of calls can be safely
    //   removed to reduce clutter and improve clarity.  Also, the underlying
    //   function probably *should* have returned its error code instead of
    //   having this layer always declare success.

    ItCliUnregisterIdleTask(ItHandle,
                            StartEvent,
                            StopEvent);

    return ERROR_SUCCESS;
}

VOID
ItCliUnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent   
    )

/*++

Routine Description:

    Unregisters an idle task in the current process with the server
    and cleans up any allocated resources. This function should be
    called when the idle task is completed, or not needed anymore
    (e.g. the process is exiting).

Arguments:

    ItHandle - Registration RPC context handle.

    StartEvent - Handle returned from RegisterIdleTask.

    StopEvent - Handle returned from RegisterIdleTask.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    DBGPR((ITID,ITTRC,"IDLE: CliUnregisterIdleTask(%p)\n", ItHandle));

    //
    // Call server to unregister the idle task. 
    //

    RpcTryExcept {

        ItSrvUnregisterIdleTask(NULL, (IT_HANDLE *)&ItHandle);
        ErrorCode = ERROR_SUCCESS;

    } 
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept

    //
    // Close handles to the start/stop events.
    //
                                        
    // NOTICE-2002/03/26-ScottMa -- It is assumed that the two event params
    //   are the same ones that were returned during registration.

    if (StartEvent)
        CloseHandle(StartEvent);

    if (StopEvent)
        CloseHandle(StopEvent);

    DBGPR((ITID,ITTRC,"IDLE: CliUnregisterIdleTask(%p)=0\n",ItHandle));

    return;
}

DWORD
ProcessIdleTasks (
    VOID
    )

/*++

Routine Description:

    This routine forces all queued tasks (if there are any) to be processed 
    right away.
    
Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;

    DBGPR((ITID,ITTRC,"IDLE: ProcessIdleTasks()\n"));

    //
    // Call the server. 
    //

    RpcTryExcept {

        ErrorCode = ItSrvProcessIdleTasks(NULL);

    } 
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept

    DBGPR((ITID,ITTRC,"IDLE: ProcessIdleTasks()=%x\n",ErrorCode));

    return ErrorCode;
}

//
// These are the custom binding functions that are called by RPC stubs
// when we call interface functions:
//

handle_t
__RPC_USER
ITRPC_HANDLE_bind(
    ITRPC_HANDLE Reserved
    )

/*++

Routine Description:

    Typical RPC custom binding routine. It is called to get a binding
    for the RPC interface functions that require explicit_binding.

Arguments:

    Reserved - Ignored.

Return Value:

    RPC binding handle or NULL if there was an error.

--*/

{
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    RPC_BINDING_HANDLE BindingHandle;
    RPC_SECURITY_QOS SecurityQOS;
    PSID LocalSystemSid;
    WCHAR *StringBinding;
    SID_NAME_USE AccountType;
    WCHAR AccountName[128];
    DWORD AccountNameSize = sizeof(AccountName) / sizeof(AccountName[0]);
    WCHAR DomainName[128];
    DWORD DomainNameSize = sizeof(DomainName) / sizeof(DomainName[0]);
    DWORD ErrorCode;
    
    //
    // Initialize locals.
    //
    
    LocalSystemSid = NULL;
    BindingHandle = NULL;
    StringBinding = NULL;

    ErrorCode = RpcStringBindingCompose(NULL,
                                        IT_RPC_PROTSEQ,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &StringBinding);
    
    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    ErrorCode = RpcBindingFromStringBinding(StringBinding,
                                            &BindingHandle);


    if (ErrorCode != RPC_S_OK) {
        IT_ASSERT(BindingHandle == NULL);
        goto cleanup;
    }

    //
    // Set security information.
    //

    SecurityQOS.Version = RPC_C_SECURITY_QOS_VERSION;
    SecurityQOS.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    SecurityQOS.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    SecurityQOS.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    //
    // Get the security principal name for LocalSystem: we'll only allow an
    // RPC server running as LocalSystem to impersonate us.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0,
                                  &LocalSystemSid)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }
       
    if (LookupAccountSid(NULL,
                         LocalSystemSid,
                         AccountName,
                         &AccountNameSize,
                         DomainName,
                         &DomainNameSize,
                         &AccountType) == 0) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Set mutual authentication requirements on the binding handle.
    //

    ErrorCode = RpcBindingSetAuthInfoEx(BindingHandle, 
                                        AccountName, 
                                        RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                        RPC_C_AUTHN_WINNT, 
                                        NULL, 
                                        0, 
                                        &SecurityQOS);

    if (ErrorCode!= RPC_S_OK) {
        goto cleanup;
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (StringBinding) {
        RpcStringFree(&StringBinding);
    }

    if (LocalSystemSid) {
        FreeSid(LocalSystemSid);
    }

    return BindingHandle;
}

VOID
__RPC_USER
ITRPC_HANDLE_unbind(
    ITRPC_HANDLE Reserved,
    RPC_BINDING_HANDLE BindingHandle
    )

/*++

Routine Description:

    Typical RPC custom unbinding routine. It is called to close a
    binding established for an RPC interface function that required
    explicit_binding.

Arguments:

    Reserved - Ignored.

    BindingHandle - Primitive binding handle.

Return Value:

    None.

--*/

{
    RPC_STATUS Status;
    
    Status = RpcBindingFree(&BindingHandle);

    IT_ASSERT(Status == RPC_S_OK);
    IT_ASSERT(BindingHandle == NULL);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\inc\idlecomn.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idlecomn.h

Abstract:

    This module contains common private declarations to support idle tasks.
    Note that client does not stand for the users of the idle task
    API, but the code in the users process that implements these APIs.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLECOMN_H_
#define _IDLECOMN_H_

//
// This exception handler is prefered because it does not mask
// exceptions that can be raised from the heap etc. during an RPC
// call.
//

#define IT_RPC_EXCEPTION_HANDLER()                                      \
    (((RpcExceptionCode() != STATUS_ACCESS_VIOLATION)                && \
      (RpcExceptionCode() != STATUS_POSSIBLE_DEADLOCK)               && \
      (RpcExceptionCode() != STATUS_INSTRUCTION_MISALIGNMENT)        && \
      (RpcExceptionCode() != STATUS_DATATYPE_MISALIGNMENT)           && \
      (RpcExceptionCode() != STATUS_PRIVILEGED_INSTRUCTION)          && \
      (RpcExceptionCode() != STATUS_ILLEGAL_INSTRUCTION)             && \
      (RpcExceptionCode() != STATUS_BREAKPOINT)                         \
     ) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)

//
// Debug definitions:
//

#if DBG
#ifndef IT_DBG
#define IT_DBG
#endif // !IT_DBG
#endif // DBG

#ifdef IT_DBG

//
// Define the component ID we use.
//

#define ITID       DPFLTR_IDLETASK_ID

//
// Define DbgPrintEx levels.
//

#define ITERR      DPFLTR_ERROR_LEVEL
#define ITWARN     DPFLTR_WARNING_LEVEL
#define ITTRC      DPFLTR_TRACE_LEVEL
#define ITINFO     DPFLTR_INFO_LEVEL

#define ITCLID     4
#define ITSRVD     5
#define ITSRVDD    6
#define ITTSTD     7
#define ITSNAP     8

//
//  This may help you determine what to set the DbgPrintEx mask.
//
//  3 3 2 2  2 2 2 2  2 2 2 2  1 1 1 1   1 1 1 1  1 1 0 0  0 0 0 0  0 0 0 0
//  1 0 9 8  7 6 5 4  3 2 1 0  9 8 7 6   5 4 3 2  1 0 9 8  7 6 5 4  3 2 1 0
//  _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _   _ _ _ _  _ _ _ _  _ _ _ _  _ _ _ _
//

#define IT_ASSERT(x) if (!(x)) RtlAssert(#x, __FILE__, __LINE__, NULL )
#define DBGPR(x) DbgPrintEx x

#else // IT_DBG

#define IT_ASSERT(x)
#define DBGPR(x)

#endif // IT_DBG

#endif // _IDLECOMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\server\idlrpc_server.c ===
#include <idlrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\server\idletsks.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    idletsks.c

Abstract:

    This module implements the idle detection / task server.

Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "idletsks.h"

//
// Define WMI Guids, e.g. DiskPerfGuid.
//

#ifndef INITGUID
#define INITGUID 1
#endif

#include <wmiguid.h>

//
// Global variables.
//

//
// This is the idle detection global context. It is declared as a
// single element array so that ItSrvGlobalContext can be used as a
// pointer (allowing us to switch to allocating it from heap etc. in
// the future).
//

ITSRV_GLOBAL_CONTEXT ItSrvGlobalContext[1] = {0};

//
// Implementation of server side exposed functions.
//

DWORD
ItSrvInitialize (
    VOID
    )

/*++

Routine Description:

    Initializes the global idle detection context. This function
    should be called after at least one ncalrpc binding has been
    registered.

Arguments:

    None.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    PIT_IDLE_DETECTION_PARAMETERS Parameters;
    ULONG StatusIdx;
    BOOLEAN StartedServer;
    BOOLEAN AcquiredLock;

    //
    // Initialize locals.
    //
    
    GlobalContext = ItSrvGlobalContext;
    StartedServer = FALSE;
    AcquiredLock = FALSE;

    DBGPR((ITID,ITTRC,"IDLE: SrvInitialize(%p)\n",GlobalContext));

    //
    // Initialize the server context structure. Before we do anything
    // that can fail we initialize fields to reasonable values so we
    // know what to cleanup. The following fields really have to be
    // initialized to zero:
    //
    //   StatusVersion
    //   GlobalLock
    //   IdleDetectionTimerHandle
    //   StopIdleDetection
    //   IdleDetectionStopped
    //   RemovedRunningIdleTask
    //   DiskPerfWmiHandle
    //   WmiQueryBuffer
    //   WmiQueryBufferSize
    //   NumProcessors
    //   IsIdleDetectionCallbackRunning
    //   Parameters
    //   ProcessIdleTasksNotifyRoutine
    //   RpcBindingVector
    //   RegisteredRPCInterface
    //   RegisteredRPCEndpoint
    //
    
    RtlZeroMemory(GlobalContext, sizeof(ITSRV_GLOBAL_CONTEXT));

    //
    // Initialize the idle tasks list.
    //

    InitializeListHead(&GlobalContext->IdleTasksList);

    //
    // Initialize the status now (so cleanup does not complain). From
    // this point on, UpdateStatus should be called to set the status.
    //

    GlobalContext->Status = ItSrvStatusInitializing;
    for (StatusIdx = 0; StatusIdx < ITSRV_GLOBAL_STATUS_HISTORY_SIZE; StatusIdx++) {
        GlobalContext->LastStatus[StatusIdx] = ItSrvStatusInitializing;
    }   

    //
    // Initialize the system snapshot buffer.
    //

    ItSpInitializeSystemSnapshot(&GlobalContext->LastSystemSnapshot);

    //
    // Initialize the server global context lock. We need at least a
    // lock to protect the idle task list. Since nearly all operations
    // will involve the list, to make the code simple, we just have a
    // single lock for the list and for other operations on the global
    // context (e.g. uninitialization etc).
    //

    GlobalContext->GlobalLock = CreateMutex(NULL, FALSE, NULL);

    if (GlobalContext->GlobalLock == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the event that will be set when we should not be
    // doing idle detection anymore (e.g. due to server shutdown, or
    // no more idle tasks remaining). It is set by default, since
    // there are no idle tasks to start with. It signals a running
    // idle detection callback to quickly exit.
    //

    GlobalContext->StopIdleDetection = CreateEvent(NULL,
                                                   TRUE,
                                                   TRUE,
                                                   NULL);
    
    if (GlobalContext->StopIdleDetection == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the event that gets set when idle detection is fully
    // stopped and it is OK to start a new callback. It is set by
    // default.
    //

    GlobalContext->IdleDetectionStopped = CreateEvent(NULL,
                                                      TRUE,
                                                      TRUE,
                                                      NULL);
    
    if (GlobalContext->IdleDetectionStopped == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Initialize the event that gets set when a currently running
    // idle task is removed/unregistered to signal the idle detection
    // callback to move on to other idle tasks.
    //

    GlobalContext->RemovedRunningIdleTask = CreateEvent(NULL,
                                                        TRUE,
                                                        FALSE,
                                                        NULL);
    
    if (GlobalContext->RemovedRunningIdleTask == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Set the default parameters.
    //

    Parameters = &GlobalContext->Parameters;

    Parameters->IdleDetectionPeriod = IT_DEFAULT_IDLE_DETECTION_PERIOD;
    Parameters->IdleVerificationPeriod = IT_DEFAULT_IDLE_VERIFICATION_PERIOD;
    Parameters->NumVerifications = IT_DEFAULT_NUM_IDLE_VERIFICATIONS;
    Parameters->IdleInputCheckPeriod = IT_DEFAULT_IDLE_USER_INPUT_CHECK_PERIOD;
    Parameters->IdleTaskRunningCheckPeriod = IT_DEFAULT_IDLE_TASK_RUNNING_CHECK_PERIOD;
    Parameters->MinCpuIdlePercentage = IT_DEFAULT_MIN_CPU_IDLE_PERCENTAGE;
    Parameters->MinDiskIdlePercentage = IT_DEFAULT_MIN_DISK_IDLE_PERCENTAGE;
    Parameters->MaxNumRegisteredTasks = IT_DEFAULT_MAX_REGISTERED_TASKS;
    
    //
    // Acquire the lock to avoid any race conditions after we mark the
    // server started.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;   

    //
    // We are done until an idle task that we can run gets
    // registered. We will start idle detection (e.g. get initial
    // snapshot, queue a timer etc) then.
    //

    ItSpUpdateStatus(GlobalContext, ItSrvStatusWaitingForIdleTasks);

    //
    // After this point, if we fail, we cannot just cleanup: we have
    // to stop the server.
    //

    StartedServer = TRUE;

    //
    // We have to start up the RPC server only after we have
    // initialized everything else, so when RPC calls come the server
    // is ready. 
    //

    //
    // We don't want to register any well known end points because
    // each LPC endpoint will cause another thread to be spawned to
    // listen on it. We try to bind through only the existing
    // bindings.
    //

    ErrorCode = RpcServerInqBindings(&GlobalContext->RpcBindingVector);
    
    if (ErrorCode != RPC_S_OK) {

        //
        // At least one binding should have been registered before we
        // got called. It would be cool if we could check to see if
        // there is an ncalrpc binding registered.
        //

        IT_ASSERT(ErrorCode != RPC_S_NO_BINDINGS);

        goto cleanup;
    }

    ErrorCode = RpcEpRegister(idletask_ServerIfHandle,
                              GlobalContext->RpcBindingVector,
                              NULL,
                              NULL);
    
    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    GlobalContext->RegisteredRPCEndpoint = TRUE;

    //
    // Register an auto-listen interface so we are not dependant on
    // others calling RpcMgmtStart/Stop listening.
    //

    ErrorCode = RpcServerRegisterIfEx(idletask_ServerIfHandle,
                                      NULL,
                                      NULL,
                                      RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY,
                                      RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                      ItSpRpcSecurityCallback);
    
    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    //
    // Register default security principal name for this process, e.g.
    // NT Authority\LocalSystem.
    //

    ErrorCode = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    GlobalContext->RegisteredRPCInterface = TRUE;

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    if (ErrorCode != ERROR_SUCCESS) {
        if (StartedServer) {
            ItSrvUninitialize();
        } else {
            ItSpCleanupGlobalContext(GlobalContext);
        }
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvInitialize(%p)=%x\n",GlobalContext,ErrorCode));

    return ErrorCode;
}

VOID
ItSrvUninitialize (
    VOID
    )

/*++

Routine Description:

    Winds down and uninitializes the server global context.

    Do not call this from the idle detection timer callback function
    thread, because there will be a deadlock when we try to delete the
    timer.

    This function should not be called before ItSrvInitialize
    completes. It should be called only once per ItSrvInitialize.

Arguments:

    None.

Return Value:

    None.

--*/

{   
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    BOOLEAN AcquiredLock;
    DWORD ErrorCode;

    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;
    AcquiredLock = FALSE;

    DBGPR((ITID,ITTRC,"IDLE: SrvUninitialize(%p)\n",GlobalContext));

    // NOTICE-2002/03/26-ScottMa -- It is assumed that initialization was
    //   successful prior to calling Uninitialize, or the acquire below
    //   might not be safe.

    //
    // Acquire the global lock and update status.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // Make sure we get uninitialized only once.
    //

    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitializing);
    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitialized);
    
    ItSpUpdateStatus(GlobalContext, ItSrvStatusUninitializing);

    //
    // If idle detection is alive, we need to stop it before we tell
    // RPCs to go away. We need to do this even if there are
    // registered idle tasks. Since we have set the state to
    // ItSrvStatusUninitializing, new "register idle task"s
    // won't get stuck.
    //
    
    if (GlobalContext->IdleDetectionTimerHandle) {
        ItSpStopIdleDetection(GlobalContext);
    }
    
    //
    // Release the lock so rpc call-ins can grab the lock to
    // uninitialize/exit as necessary.
    //

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = FALSE;

    //
    // Make sure incoming client register/unregister calls are stopped.
    //
    
    if (GlobalContext->RegisteredRPCInterface) {

        //
        // If we registered an interface, we should have registered
        // our endpoint in the local database too.
        //

        IT_ASSERT(GlobalContext->RegisteredRPCEndpoint);

        //
        // Calling UnregisterIfEx makes sure all the context handles
        // are run down so we don't get rundown calls after we have
        // uninitialized.
        //

        RpcServerUnregisterIfEx(idletask_ServerIfHandle, NULL, TRUE);
    }

    if (GlobalContext->RegisteredRPCEndpoint) {

        //
        // We could have registered an endpoint only if we
        // successfully queried bindings.
        //

        IT_ASSERT(GlobalContext->RpcBindingVector);

        RpcEpUnregister(idletask_ServerIfHandle, 
                        GlobalContext->RpcBindingVector, 
                        NULL);
    }

    //
    // Wait until idle detection is fully stopped (e.g. the callback
    // exits, the timer is dequeued etc.)
    //

    WaitForSingleObject(GlobalContext->IdleDetectionStopped, INFINITE);

    //
    // At this point no workers should be active and no new requests
    // should be coming. Now we will be breaking down the global state
    // structure (e.g. freeing memory, closing events etc.)  they
    // would be using.
    //

    ItSpCleanupGlobalContext(GlobalContext);

    DBGPR((ITID,ITTRC,"IDLE: SrvUninitialize(%p)=0\n",GlobalContext));

    return;
}

DWORD
ItSrvRegisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    )

/*++

Routine Description:

    Adds a new idle task to be run when the system is idle.

Arguments:

    Reserved - Ignored.

    ItHandle - Context handle returned to the client.

    IdleTaskProperties - Pointer to properties for the idle task.

Return Value:

    Status.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    HANDLE ClientProcess;
    ULONG FailedCheckId;
    DWORD ErrorCode;
    DWORD WaitResult;
    LONG StatusVersion;
    ULONG NumLoops;
    BOOL Result;
    BOOLEAN AcquiredLock;
    BOOLEAN ImpersonatingClient;

    //
    // Initialize locals.
    //

    IdleTask = NULL;
    AcquiredLock = FALSE;
    ImpersonatingClient = FALSE;
    ClientProcess = NULL;
    GlobalContext = ItSrvGlobalContext;

    //
    // Initialize parameters.
    //

    *ItHandle = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvRegisterTask(%p)\n",IdleTaskProperties));

    //
    // Allocate a new idle task context.
    //
    
    IdleTask = IT_ALLOC(sizeof(ITSRV_IDLE_TASK_CONTEXT));

    if (!IdleTask) {
        ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    //
    // Initialize the fields to safe values so we know what to
    // cleanup.
    //

    IdleTask->Status = ItIdleTaskInitializing;
    IdleTask->StartEvent = NULL;
    IdleTask->StopEvent = NULL;   

    //
    // Copy and verify input buffer.
    //

    IdleTask->Properties = *IdleTaskProperties;

    FailedCheckId = ItpVerifyIdleTaskProperties(&IdleTask->Properties);
    
    if (FailedCheckId != 0) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Impersonate the client to open the start/stop events. They
    // should have been created by the client.
    //

    ErrorCode = RpcImpersonateClient(NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    ImpersonatingClient = TRUE;

    //
    // Open the client process. Since we impersonated the client, it
    // is safe to use the client id it specifies.
    //

    // ISSUE-2002/03/26-ScottMa -- If possible, change PROCESS_ALL_ACCESS to
    //   PROCESS_DUP_HANDLE to follow principle of least priveledge.

    ClientProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                FALSE,
                                IdleTaskProperties->ProcessId);
    
    if (!ClientProcess) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get handle to the start event.
    //

    // ISSUE-2002/03/26-ScottMa -- If possible, change EVENT_ALL_ACCESS to
    //   EVENT_MODIFY_STATE to follow principle of least priveledge.

    Result = DuplicateHandle(ClientProcess,
                             (HANDLE) IdleTaskProperties->StartEventHandle,
                             GetCurrentProcess(),
                             &IdleTask->StartEvent,
                             EVENT_ALL_ACCESS,
                             FALSE,
                             0);

    if (!Result) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Get handle to the stop event.
    //

    // ISSUE-2002/03/26-ScottMa -- If possible, change EVENT_ALL_ACCESS to
    //   EVENT_MODIFY_STATE to follow principle of least priveledge.

    Result = DuplicateHandle(ClientProcess,
                             (HANDLE) IdleTaskProperties->StopEventHandle,
                             GetCurrentProcess(),
                             &IdleTask->StopEvent,
                             EVENT_ALL_ACCESS,
                             FALSE,
                             0);

    if (!Result) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // No need to impersonate any longer.
    //

    RpcRevertToSelf();
    ImpersonatingClient = FALSE;

    //
    // Make sure the handle is for an event and it is in the right
    // state.
    //

    if (!ResetEvent(IdleTask->StartEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    if (!SetEvent(IdleTask->StopEvent)) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Acquire the server lock to check the status and insert new task
    // into the list.
    //
    
    NumLoops = 0;

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;
    
    do {
        
        //
        // We should be holding the GlobalLock when we come here the
        // first time or after looping. Inside the loop we may let go
        // of the lock, but we have to reacquire it before we loop.
        //

        IT_ASSERT(AcquiredLock);

        //
        // If there are already too many idle tasks registered, bail
        // out.
        //

        if (GlobalContext->NumIdleTasks >= 
            GlobalContext->Parameters.MaxNumRegisteredTasks) {
            ErrorCode = ERROR_TOO_MANY_OPEN_FILES;
            goto cleanup;
        }

        switch (GlobalContext->Status) {

        case ItSrvStatusInitializing:
            
            //
            // We should not have gotten called if the server is still
            // initializing!
            //
        
            IT_ASSERT(FALSE);
            ErrorCode = ERROR_NOT_READY;
            goto cleanup;

        case ItSrvStatusUninitializing:
            
            //
            // If the server is uninitializing, we should not add a
            // new idle task.
            //

            ErrorCode = ERROR_NOT_READY;
            goto cleanup;

            break;

        case ItSrvStatusUninitialized:  

            //
            // The server should not have uninitialized while we could be
            // running.
            //
        
            IT_ASSERT(FALSE);
            ErrorCode = ERROR_NOT_READY;
            goto cleanup;

        case ItSrvStatusStoppingIdleDetection:

            //
            // The idle task list should be empty if we are stopping
            // idle detection. There should not be a
            // IdleDetectionTimerHandle either.
            //

            IT_ASSERT(IsListEmpty(&GlobalContext->IdleTasksList));
            IT_ASSERT(GlobalContext->IdleDetectionTimerHandle == NULL);

            //
            // We must wait until idle detection is fully stopped. We
            // need to release our lock to do so. But note the status
            // version first.
            //

            StatusVersion = GlobalContext->StatusVersion;

            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;
            
            WaitResult = WaitForSingleObject(GlobalContext->IdleDetectionStopped, 
                                             INFINITE);
        
            if (WaitResult != WAIT_OBJECT_0) {
                DBGPR((ITID,ITERR,"IDLE: SrvRegisterTask-FailedWaitStop\n"));
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

            //
            // Reacquire the lock.
            //

            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;

            //
            // If nobody woke before us and updated the status, update
            // it now.
            //

            if (StatusVersion == GlobalContext->StatusVersion) {
                IT_ASSERT(GlobalContext->Status == ItSrvStatusStoppingIdleDetection);
                ItSpUpdateStatus(GlobalContext, ItSrvStatusWaitingForIdleTasks);
            }

            //
            // Loop to do what is necessary next.
            //

            break;

        case ItSrvStatusWaitingForIdleTasks:

            //
            // The idle task list should be empty if we are waiting
            // for idle tasks.
            //
            
            IT_ASSERT(IsListEmpty(&GlobalContext->IdleTasksList));
            
            //
            // If we are waiting for idle tasks, start idle detection
            // so we can add our task.
            //
            
            ErrorCode = ItSpStartIdleDetection(GlobalContext);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
            
            //
            // Update the status.
            //
            
            ItSpUpdateStatus(GlobalContext, ItSrvStatusDetectingIdle);
            
            //
            // Loop and insert our idle task into the list. Note that
            // we are not releasing the lock, so we will not be in a
            // state where the status is ItSrvStatusDetectingIdle but
            // there are no idle tasks in the list.
            //
            
            break;
            
        case ItSrvStatusDetectingIdle:
        case ItSrvStatusRunningIdleTasks:
            
            //
            // If we are detecting idle, we just need to insert our
            // task into the list and break out.
            //
    
            //
            // This operation currently does not fail. If in the
            // future it may, make sure to handle the case we started
            // idle detection for this task. It is not an acceptable
            // state to have idle detection but no tasks in the list.
            //

            //
            // Insert the task into the list. We do not check for
            // duplicates and such as RPC helps us maintain context
            // per registration.
            //

            GlobalContext->NumIdleTasks++;

            InsertTailList(&GlobalContext->IdleTasksList, 
                           &IdleTask->IdleTaskLink);
            
            IdleTask->Status = ItIdleTaskQueued;

            break;


        default:

            //
            // We should be handling all valid cases above.
            //

            IT_ASSERT(FALSE);
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

        //
        // We should be still holding the global lock.
        //

        IT_ASSERT(AcquiredLock);

        //
        // Break out if we could queue our task.
        //

        if (IdleTask->Status == ItIdleTaskQueued) {
            break;
        }

        //
        // We should not loop too many times.
        //

        NumLoops++;

        // FUTURE-2002/03/26-ScottMa -- This value for the maximum loop
        //   count seems rather large...  Does this function even need to
        //   be written as a loop (it seems very sequential)?

        if (NumLoops > 128) {
            DBGPR((ITID,ITERR,"IDLE: SrvRegisterTask-LoopTooMuch\n"));
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

    } while (TRUE);

    //
    // We should be still holding the lock.
    //

    IT_ASSERT(AcquiredLock);

    //
    // If we came here, we successfully inserted the task into the
    // list.
    //

    IT_ASSERT(!IsListEmpty(&GlobalContext->IdleTasksList));
    IT_ASSERT(IdleTask->Status == ItIdleTaskQueued);

    //
    // Release the lock.
    //

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = FALSE;

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ClientProcess) {
        CloseHandle(ClientProcess);
    }

    if (ImpersonatingClient) {
        RpcRevertToSelf();
    }
    
    if (ErrorCode != ERROR_SUCCESS) {

        if (IdleTask) {
            ItSpCleanupIdleTask(IdleTask);
            IT_FREE(IdleTask);
        }

    } else {
        
        *ItHandle = (IT_HANDLE)IdleTask;
    }

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvRegisterTask(%p)=%x\n",IdleTaskProperties,ErrorCode));

    return ErrorCode;
}
   
VOID
ItSrvUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle
    )

/*++

Routine Description:

    This function is a stub for ItSpUnregisterIdleTask that does the
    real work. Please see that function for comments.

Arguments:

    See ItSpUnregisterIdleTask.

Return Value:

    See ItSpUnregisterIdleTask.

--*/

{
    ItSpUnregisterIdleTask(Reserved, ItHandle, FALSE);
}

DWORD
ItSrvSetDetectionParameters (
    ITRPC_HANDLE Reserved,
    PIT_IDLE_DETECTION_PARAMETERS Parameters
    )

/*++

Routine Description:

    This debug routine is used by test programs to set the idle detection
    parameters. It will return ERROR_INVALID_FUNCTION on retail build.

Arguments:

    Reserved - Ignored.

    Parameters - New idle detection parameters.

Return Value:

    Win32 error code.

--*/

{

    DWORD ErrorCode;
    PITSRV_GLOBAL_CONTEXT GlobalContext;

    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;

    DBGPR((ITID,ITTRC,"IDLE: SrvSetParameters(%p)\n",Parameters));

#ifndef IT_DBG

    //
    // This is a debug only API.
    //

    ErrorCode = ERROR_INVALID_FUNCTION;

#else // !IT_DBG

    //
    // Acquire the lock and copy the new parameters.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    
    // NOTICE-2002/03/26-ScottMa -- The supplied parameters are unchecked.

    GlobalContext->Parameters = *Parameters;

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);    

    ErrorCode = ERROR_SUCCESS;

#endif // !IT_DBG

    DBGPR((ITID,ITTRC,"IDLE: SrvSetParameters(%p)=%d\n",Parameters,ErrorCode));

    return ErrorCode;
}

DWORD
ItSrvProcessIdleTasks (
    ITRPC_HANDLE Reserved
    )

/*++

Routine Description:

    This routine forces all queued tasks (if there are any) to be processed 
    right away.

Arguments:

    Reserved - Ignored.

Return Value:

    Win32 error code.

--*/

{
    // ISSUE-2002/03/26-ScottMa -- Is this function safe to be re-entrant?

    PITSRV_GLOBAL_CONTEXT GlobalContext;
    ITSRV_IDLE_DETECTION_OVERRIDE Overrides;
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOLEAN AcquiredLock;
    
    //
    // Initialize locals.
    //

    AcquiredLock = FALSE;
    GlobalContext = ItSrvGlobalContext;

    DBGPR((ITID,ITTRC,"IDLE: SrvProcessAll()\n"));

    //
    // If a notification routine was specified, call it.
    //

    if (GlobalContext->ProcessIdleTasksNotifyRoutine) {
        GlobalContext->ProcessIdleTasksNotifyRoutine();
    }

    //
    // Acquire the server lock.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // The server should not have shutdown while we could be called.
    //
    
    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitialized);

    //
    // If the server is shutting down, we should not do anything.
    //

    if (GlobalContext->Status == ItSrvStatusUninitializing) {
        ErrorCode = ERROR_NOT_READY;
        goto cleanup;
    }

    //
    // If there are no tasks queued, we are done.
    //

    if (IsListEmpty(&GlobalContext->IdleTasksList)) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // There should be a timer queued if the list is not empty.
    //

    IT_ASSERT(GlobalContext->IdleDetectionTimerHandle);

    //
    // Set idle detection overrides:
    //

    Overrides = 0;
    Overrides |= ItSrvOverrideIdleDetection;
    Overrides |= ItSrvOverrideIdleVerification;
    Overrides |= ItSrvOverrideUserInputCheckToStopTask;
    Overrides |= ItSrvOverridePostTaskIdleCheck;
    Overrides |= ItSrvOverrideLongRequeueTime;
    Overrides |= ItSrvOverrideBatteryCheckToStopTask;
    Overrides |= ItSrvOverrideAutoPowerCheckToStopTask;

    GlobalContext->IdleDetectionOverride = Overrides;

    //
    // If an idle detection callback is not running, try to start the next one 
    // sooner (e.g. after 50ms).
    //

    if (!GlobalContext->IsIdleDetectionCallbackRunning) {

        if (!ChangeTimerQueueTimer(NULL,
                                   GlobalContext->IdleDetectionTimerHandle,
                                   50,
                                   IT_VERYLONG_TIMER_PERIOD)) {


            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    //
    // Release the lock.
    //

    IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = FALSE;

    //
    // Wait for all tasks to be processed: i.e. when StopIdleDetection event is set.
    //

    WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection, INFINITE);

    if (WaitResult != WAIT_OBJECT_0) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;

cleanup:

    GlobalContext->IdleDetectionOverride = 0;

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvProcessAll()=%x\n",ErrorCode));

    return ErrorCode;
 
}


VOID 
__RPC_USER 
IT_HANDLE_rundown (
    IT_HANDLE ItHandle
    )

/*++

Routine Description:

    This routine gets called by RPC when a client dies without
    unregistering.

Arguments:

    ItHandle - Context handle for the client.

Return Value:

    None.

--*/

{
    DWORD ErrorCode;

    //
    // Unregister the registered task.
    //

    ItSpUnregisterIdleTask(NULL, &ItHandle, TRUE);

    DBGPR((ITID,ITTRC,"IDLE: SrvHandleRundown(%p)\n",ItHandle));   

    return;
}

//
// Implementation of server side support functions.
//

RPC_STATUS 
RPC_ENTRY 
ItSpRpcSecurityCallback (
    IN RPC_IF_HANDLE *Interface,
    IN PVOID Context
    )

/*++

Routine Description:


Arguments:


Return Value:

    Win32 error code.

--*/

{
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsSid;
    HANDLE ThreadToken;
    WCHAR *BindingString;
    WCHAR *ProtocolSequence;
    DWORD ErrorCode;
    BOOL ClientIsAdmin;
    BOOLEAN ImpersonatingClient;
    BOOLEAN OpenedThreadToken;

    //
    // Initialize locals.
    //

    BindingString = NULL;
    ProtocolSequence = NULL;
    ImpersonatingClient = FALSE;
    OpenedThreadToken = FALSE;
    AdministratorsSid = NULL;
    
    //
    // Make sure that the caller is calling over LRPC. We do this by 
    // determining the protocol sequence used from the string binding.
    //

    ErrorCode = RpcBindingToStringBinding(Context, &BindingString);

    if (ErrorCode != RPC_S_OK) {
        ErrorCode = RPC_S_ACCESS_DENIED;
        goto cleanup;
    }

    ErrorCode = RpcStringBindingParse(BindingString,
                                      NULL,
                                      &ProtocolSequence,
                                      NULL,
                                      NULL,
                                      NULL);

    if (ErrorCode != RPC_S_OK) {
        ErrorCode = RPC_S_ACCESS_DENIED;
        goto cleanup;
    }

    if (_wcsicmp(ProtocolSequence, L"ncalrpc") != 0) {
        ErrorCode = RPC_S_ACCESS_DENIED;
        goto cleanup;
    }

    //
    // Make sure the caller has admin priviliges:
    //

    //
    // Build the Administrators group SID so we can check if the
    // caller is has administrator priviliges.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0, 0, 0, 0, 0, 0,
                                  &AdministratorsSid)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Impersonate the client to check for membership/privilige.
    //

    ErrorCode = RpcImpersonateClient(NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    ImpersonatingClient = TRUE;

    //
    // Get the thread token and check to see if the client has admin
    // priviliges.
    //

    if (!OpenThreadToken(GetCurrentThread(),
                         TOKEN_READ,
                         FALSE,
                         &ThreadToken)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    OpenedThreadToken = TRUE;

    if (!CheckTokenMembership(ThreadToken,
                              AdministratorsSid,
                              &ClientIsAdmin)) {
        
        ErrorCode = GetLastError();
        goto cleanup;
    }
    
    if (!ClientIsAdmin) {
        ErrorCode = ERROR_ACCESS_DENIED;
        goto cleanup;
    } 

    //
    // Everything looks good: allow this call to proceed.
    //

    ErrorCode = RPC_S_OK;

  cleanup:

    if (BindingString) {
        RpcStringFree(&BindingString);
    }

    if (ProtocolSequence) {
        RpcStringFree(&ProtocolSequence);
    }

    if (OpenedThreadToken) {
        CloseHandle(ThreadToken);
    }

    if (AdministratorsSid) {
        FreeSid (AdministratorsSid);
    }

    if (ImpersonatingClient) {
        RpcRevertToSelf();
    }

    return ErrorCode;
};
 
VOID
ItSpUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    BOOLEAN CalledInternally
    )

/*++

Routine Description:

    Removes the specified idle task from the idle tasks list.

    As well as from a client RPC, this function can also be called
    from the idle detection callback to unregister an unresponsive
    idle task etc.

Arguments:

    Reserved - Ignored.

    ItHandle - Registration RPC Context handle. NULL on return.

    CalledInternally - Whether this function was called internally and
      not from an RPC client.

Return Value:

    None.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    HANDLE ClientProcess;
    DWORD ErrorCode;   
    BOOLEAN AcquiredLock;
    BOOLEAN ImpersonatingClient;

    //
    // Initialize locals.
    //

    GlobalContext = ItSrvGlobalContext;
    AcquiredLock = FALSE;
    ImpersonatingClient = FALSE;
    ClientProcess = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvUnregisterTask(%p)\n",(ItHandle)?*ItHandle:0));

    //
    // Grab the lock to walk through the list.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // The server should not have shutdown while we could be called.
    //
    
    IT_ASSERT(GlobalContext->Status != ItSrvStatusUninitialized);

    //
    // If the server is shutting down, we should not do anything.
    //

    if (GlobalContext->Status == ItSrvStatusUninitializing) {
        ErrorCode = ERROR_NOT_READY;
        goto cleanup;
    }
    
    //
    // Find the task.
    //

    IdleTask = ItSpFindIdleTask(GlobalContext, *ItHandle);
            
    if (!IdleTask) {
        ErrorCode = ERROR_NOT_FOUND;
        goto cleanup;
    }

    if (!CalledInternally) {

        //
        // To check security, impersonate the client and try to open the
        // client process for this idle task.
        //

        ErrorCode = RpcImpersonateClient(NULL);

        if (ErrorCode != RPC_S_OK) {
            goto cleanup;
        }

        ImpersonatingClient = TRUE;

        ClientProcess = OpenProcess(PROCESS_ALL_ACCESS,
                                    FALSE,
                                    IdleTask->Properties.ProcessId);
    
        if (!ClientProcess) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    
        //
        // If we could open the client process for this task, it is safe
        // to go on with unregistration. Now revert back to ourselves.
        //

        CloseHandle(ClientProcess);
        ClientProcess = NULL;
    
        RpcRevertToSelf();
        ImpersonatingClient = FALSE;
    }

    //
    // Remove it from the list, cleanup its fields and free
    // the memory allocated for it.
    //

    GlobalContext->NumIdleTasks--;
    RemoveEntryList(&IdleTask->IdleTaskLink);

    //
    // As a safety feature, to prevent from holding back
    // someone from running, set the run event and clear the
    // stop event from the task to be removed.
    //

    ResetEvent(IdleTask->StopEvent);
    SetEvent(IdleTask->StartEvent);

    //
    // If this is a running task, set the event that signals
    // we are removing the running idle task. This way some
    // other idle task may be started if the system is still
    // idle.
    //
    
    if (IdleTask->Status == ItIdleTaskRunning) {
        SetEvent(GlobalContext->RemovedRunningIdleTask);
    }

    ItSpCleanupIdleTask(IdleTask);
    
    IT_FREE(IdleTask);
    
    //
    // Check if the list is empty.
    //

    if (IsListEmpty(&GlobalContext->IdleTasksList)) {

        //
        // If we removed the task and the list became empty, we have
        // to update the status.
        //

        //
        // The current status should not be "waiting for idle
        // tasks" or "stopping idle detection", since the list was
        // NOT empty.
        //
        
        IT_ASSERT(GlobalContext->Status != ItSrvStatusWaitingForIdleTasks);
        IT_ASSERT(GlobalContext->Status != ItSrvStatusStoppingIdleDetection);
        
        //
        // Update the status.
        //

        ItSpUpdateStatus(GlobalContext, ItSrvStatusStoppingIdleDetection);
        
        //
        // Stop idle detection (e.g. close the timer handle, set event
        // etc.)
        //

        ItSpStopIdleDetection(GlobalContext);

    } else {

        //
        // The status should not be waiting for idle tasks or stopping
        // idle detection if the list is not empty.
        //

        IT_ASSERT(GlobalContext->Status != ItSrvStatusWaitingForIdleTasks &&
                  GlobalContext->Status != ItSrvStatusStoppingIdleDetection);
        
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (ClientProcess) {
        CloseHandle(ClientProcess);
    }

    if (ImpersonatingClient) {
        RpcRevertToSelf();
    }

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    //
    // NULL the context handle, so RPC stubs know to end the
    // connection.
    //

    *ItHandle = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvUnregisterTask(%p)=%x\n",(ItHandle)?*ItHandle:0,ErrorCode));

    return;
}

VOID
ItSpUpdateStatus (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    ITSRV_GLOBAL_CONTEXT_STATUS NewStatus
    )

/*++

Routine Description:

    This routine updates the current status and status history on the
    global context. Global contexts GlobalLock should be held while
    calling this function.

Arguments:

    GlobalContext - Pointer to server context structure.

    NewStatus - New status.

Return Value:

    None.

--*/

{
    LONG StatusIdx;

    DBGPR((ITID,ITTRC,"IDLE: SrvUpdateStatus(%p,%x)\n",GlobalContext,NewStatus));

    //
    // Verify new status.
    //

    IT_ASSERT(NewStatus > ItSrvStatusMinStatus);
    IT_ASSERT(NewStatus < ItSrvStatusMaxStatus);   

    //
    // Update history.
    //

    IT_ASSERT(ITSRV_GLOBAL_STATUS_HISTORY_SIZE >= 1);
    
    for (StatusIdx = ITSRV_GLOBAL_STATUS_HISTORY_SIZE - 1; 
         StatusIdx > 0;
         StatusIdx--) {

        IT_ASSERT(GlobalContext->LastStatus[StatusIdx - 1] > ItSrvStatusMinStatus);
        IT_ASSERT(GlobalContext->LastStatus[StatusIdx - 1] < ItSrvStatusMaxStatus);
        
        GlobalContext->LastStatus[StatusIdx] =  GlobalContext->LastStatus[StatusIdx - 1];
    }
   
    //
    // Verify current status and save it.
    //

    IT_ASSERT(GlobalContext->Status > ItSrvStatusMinStatus);
    IT_ASSERT(GlobalContext->Status < ItSrvStatusMaxStatus);
   
    GlobalContext->LastStatus[0] = GlobalContext->Status;

    //
    // Update current status.
    //

    GlobalContext->Status = NewStatus;

    //
    // Update status version.
    //
    
    GlobalContext->StatusVersion++;

    DBGPR((ITID,ITTRC,"IDLE: SrvUpdateStatus(%p,%x)=%d\n",
           GlobalContext, NewStatus,GlobalContext->StatusVersion));

    return;
}

VOID
ItSpCleanupGlobalContext (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    This function cleans up the various fields of the ITSRV_GLOBAL_CONTEXT
    structure passed in. It does not free the structure itself.

    You should not be holding the global lock when calling this
    function, as it will be freed too. No workers etc. should be
    active. The idle detection timer should have already been
    removed. The structure should not be used after cleanup until it
    is initialized again.

    The current status of the global context should either be
    initializing or uninitializing. It will be set to uninitialized.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    None.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PLIST_ENTRY ListHead;
    HANDLE EventHandle;

    DBGPR((ITID,ITSRVD,"IDLE: SrvCleanupContext(%p)\n",GlobalContext));

    //
    // Make sure there is no active idle detection timer.
    //

    if (GlobalContext->IdleDetectionTimerHandle) {
        IT_ASSERT(FALSE);
        return;
    }

    //
    // Verify the status of the global context.
    //

    if (GlobalContext->Status != ItSrvStatusInitializing &&
        GlobalContext->Status != ItSrvStatusUninitializing) {
        IT_ASSERT(FALSE);
        return;
    }

    //
    // Close the handle to global lock.
    //

    if (GlobalContext->GlobalLock) {
        CloseHandle(GlobalContext->GlobalLock);
    }

    //
    // Close the handle to the various events.
    //

    if (GlobalContext->StopIdleDetection) {
        CloseHandle(GlobalContext->StopIdleDetection);
    }

    if (GlobalContext->IdleDetectionStopped) {
        CloseHandle(GlobalContext->IdleDetectionStopped);
    }

    if (GlobalContext->RemovedRunningIdleTask) {
        CloseHandle(GlobalContext->RemovedRunningIdleTask);
    }

    //
    // Close WMI DiskPerf handle.
    //
    
    if (GlobalContext->DiskPerfWmiHandle) {
        WmiCloseBlock(GlobalContext->DiskPerfWmiHandle);
    }
    
    //
    // Free WMI query buffer.
    //

    if (GlobalContext->WmiQueryBuffer) {
        IT_FREE(GlobalContext->WmiQueryBuffer);
    }

    //
    // Cleanup the snapshot buffer.
    //

    ItSpCleanupSystemSnapshot(&GlobalContext->LastSystemSnapshot);

    //
    // Walk through the list of registered idle tasks.
    //
    
    while (!IsListEmpty(&GlobalContext->IdleTasksList)) {

        GlobalContext->NumIdleTasks--;
        ListHead = RemoveHeadList(&GlobalContext->IdleTasksList);
        
        IdleTask = CONTAINING_RECORD(ListHead,
                                     ITSRV_IDLE_TASK_CONTEXT,
                                     IdleTaskLink);

        //
        // Cleanup and free the idle task structure.
        //
        
        ItSpCleanupIdleTask(IdleTask);

        IT_FREE(IdleTask);
    }

    //
    // Free the RPC binding vector.
    //

    if (GlobalContext->RpcBindingVector) {
        RpcBindingVectorFree(&GlobalContext->RpcBindingVector);
    }

    //
    // Update status.
    //

    ItSpUpdateStatus(GlobalContext, ItSrvStatusUninitialized);

    DBGPR((ITID,ITSRVD,"IDLE: SrvCleanupContext(%p)=0\n",GlobalContext));

    return;
}

VOID
ItSpCleanupIdleTask (
    PITSRV_IDLE_TASK_CONTEXT IdleTask
    )

/*++

Routine Description:

    This function cleans up the various fields of the ITSRV_IDLE_TASK_CONTEXT 
    structure. It does not free the structure itself.

Arguments:

    IdleTask - Pointer to idle task server context.

Return Value:

    None.

--*/

{

    DBGPR((ITID,ITSRVD,"IDLE: SrvCleanupTask(%p)\n",IdleTask));

    //
    // Close handles to start/stop events.
    //

    if (IdleTask->StartEvent) 
    {
        CloseHandle(IdleTask->StartEvent);
        IdleTask->StartEvent = NULL;
    }

    if (IdleTask->StopEvent) 
    {
        CloseHandle(IdleTask->StopEvent);
        IdleTask->StopEvent = NULL;
    }
}

ULONG
ItpVerifyIdleTaskProperties (
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    )

/*++

Routine Description:

    Verifies the specified structure.

Arguments:

    IdleTaskProperties - Pointer to properties for the idle task.

Return Value:

    0 - Verification passed.

    FailedCheckId - Id of the check that failed.

--*/

{
    ULONG FailedCheckId;

    //
    // Initialize locals.
    //

    FailedCheckId = 1;

    //
    // Verify the structure size/version.
    //

    if (IdleTaskProperties->Size != sizeof(*IdleTaskProperties)) {
        FailedCheckId = 10;
        goto cleanup;
    }

    //
    // Verify that the idle task ID is valid.
    //

    if (IdleTaskProperties->IdleTaskId < 0 ||
        IdleTaskProperties->IdleTaskId >= ItMaxIdleTaskId) {
        FailedCheckId = 20;
        goto cleanup;
    }

    // FUTURE-2002/03/26-ScottMa -- Should the handles and ProcessId fields
    //   also be validated?
    
    //
    // We passed all the checks.
    //

    FailedCheckId = 0;

 cleanup:

    DBGPR((ITID,ITSRVD,"IDLE: SrvVerifyTaskProp(%p)=%d\n",
           IdleTaskProperties, FailedCheckId));
    
    return FailedCheckId;
}

DWORD
ItSpStartIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    This function is called to start idle detection. 

    GlobalContext's GlobalLock should be held while calling this
    function.

    The current state should be ItSrvStatusWaitingForIdleTasks when
    calling this function. The caller should ensure that stopping
    previous idle detection has been completed. 

    The caller should update the state to "detecting idle" etc, if
    this function returns success.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    DWORD TimerPeriod;

    DBGPR((ITID,ITTRC,"IDLE: SrvStartIdleDetection(%p)\n",GlobalContext));

    //
    // Make sure the current status is ItSrvStatusWaitingForIdleTasks.
    //

    IT_ASSERT(GlobalContext->Status == ItSrvStatusWaitingForIdleTasks);

    //
    // If we do not already have a diskperf wmi handle, try to get
    // one.
    //

    if (!GlobalContext->DiskPerfWmiHandle) {

        //
        // Get WMI context so we can query disk performance.
        //
        
        ErrorCode = WmiOpenBlock((GUID *)&DiskPerfGuid,
                                 GENERIC_READ,
                                 &GlobalContext->DiskPerfWmiHandle);
        
        if (ErrorCode != ERROR_SUCCESS) {
            
            //
            // Disk counters may not be initiated. We'll have to do
            // without them.
            //
            
            GlobalContext->DiskPerfWmiHandle = NULL;
        }
    }
        
    //
    // Determine the number of processors on the system.
    //
    
    if (!GlobalContext->NumProcessors) {
    
        Status = NtQuerySystemInformation(SystemBasicInformation,
                                          &BasicInfo,
                                          sizeof(BasicInfo),
                                          NULL);

        if (!NT_SUCCESS(Status)) {
            ErrorCode = RtlNtStatusToDosError(Status);
            goto cleanup;
        }
        
        GlobalContext->NumProcessors = BasicInfo.NumberOfProcessors;
    }

    //
    // Get initial snapshot only when this is the very first time we
    // are starting idle detection. Otherwise we'll keep the last
    // snapshot we got.
    //

    IT_ASSERT(ITSRV_GLOBAL_STATUS_HISTORY_SIZE >= 1);

    if (GlobalContext->LastStatus[0] == ItSrvStatusInitializing) {

        ErrorCode = ItSpGetSystemSnapshot(GlobalContext,
                                          &GlobalContext->LastSystemSnapshot);
        
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    //
    // Make sure the StopIdleDetection event is cleared.
    //
    
    ResetEvent(GlobalContext->StopIdleDetection);

    //
    // There should not be a timer-queue timer. We'll create one.
    //

    IT_ASSERT(!GlobalContext->IdleDetectionTimerHandle);
    
    //
    // Set the default timer period.
    //

    TimerPeriod = GlobalContext->Parameters.IdleDetectionPeriod;

    //
    // Adjust timer period to something small if we were idling when
    // idle detection was stopped. 
    //
    
    IT_ASSERT(ITSRV_GLOBAL_STATUS_HISTORY_SIZE >= 2);

    if (GlobalContext->LastStatus[0] == ItSrvStatusStoppingIdleDetection &&
        GlobalContext->LastStatus[1] == ItSrvStatusRunningIdleTasks) {
        
        //
        // Set small wake up time in ms. We'll still check if we were idle
        // since the last snapshot and verify it over small periods.
        //

        if (TimerPeriod > (60 * 1000)) {
            TimerPeriod = 60 * 1000; // 1 minute.
        }
    }

    DBGPR((ITID,ITTRC,"IDLE: SrvStartIdleDetection(%p)-TimerPeriod=%d\n",GlobalContext,TimerPeriod));

    if (!CreateTimerQueueTimer(&GlobalContext->IdleDetectionTimerHandle,
                               NULL,
                               ItSpIdleDetectionCallbackRoutine,
                               GlobalContext,
                               TimerPeriod,
                               IT_VERYLONG_TIMER_PERIOD,
                               WT_EXECUTELONGFUNCTION)) {
        
        GlobalContext->IdleDetectionTimerHandle = NULL;
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // We are done.
    //
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:

    DBGPR((ITID,ITTRC,"IDLE: SrvStartIdleDetection(%p)=%x\n",GlobalContext,ErrorCode));

    return ErrorCode;
}

VOID
ItSpStopIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    This function is called to stop idle detection. Even though it
    returns immediately, idle detection may not have stopped
    completely (i.e. the callback may be running). The
    IdleDetectionStopped event on the GlobalContext will be set when
    the idle detection will be fully stopped.

    GlobalContext's GlobalLock should be held while calling this
    function.

    The status before calling this function should be set to
    ItSrvStatusStoppingIdleDetection or ItSrvStatusUninitializing.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    None.

--*/

{
    DBGPR((ITID,ITTRC,"IDLE: SrvStopIdleDetection(%p)\n",GlobalContext));

    //
    // Make sure the status is set right.
    //

    IT_ASSERT(GlobalContext->Status == ItSrvStatusStoppingIdleDetection ||
              GlobalContext->Status == ItSrvStatusUninitializing);

    //
    // Clear the event that will be set when idle detection has been
    // fully stoped.
    //

    ResetEvent(GlobalContext->IdleDetectionStopped);

    //
    // Signal the event that signals the idle detection callback to go
    // away asap.
    //

    if (GlobalContext->StopIdleDetection) {
        SetEvent(GlobalContext->StopIdleDetection);
    }

    //
    // Close the handle to the timer-queue timer.
    //

    IT_ASSERT(GlobalContext->IdleDetectionTimerHandle);

    DeleteTimerQueueTimer(NULL, 
                          GlobalContext->IdleDetectionTimerHandle,
                          GlobalContext->IdleDetectionStopped);
        
    GlobalContext->IdleDetectionTimerHandle = NULL;

    DBGPR((ITID,ITTRC,"IDLE: SrvStopIdleDetection(%p)=0\n",GlobalContext));

    return;
}

PITSRV_IDLE_TASK_CONTEXT
ItSpFindRunningIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    )

/*++

Routine Description:

    If there is an idle task marked "running" this routine finds and
    returns it. GlobalContext's GlobalLock should be held while
    calling this function.

Arguments:

    GlobalContext - Pointer to server context structure.

Return Value:

    Pointer to running idle task or NULL if no idle tasks are marked
    running.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_IDLE_TASK_CONTEXT RunningIdleTask;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;

    //
    // Initialize locals.
    //
    
    RunningIdleTask = NULL;

    HeadEntry = &GlobalContext->IdleTasksList;
    NextEntry = HeadEntry->Flink;
    
    while (NextEntry != HeadEntry) {
        
        IdleTask = CONTAINING_RECORD(NextEntry,
                                      ITSRV_IDLE_TASK_CONTEXT,
                                      IdleTaskLink);
        
        NextEntry = NextEntry->Flink;

        if (IdleTask->Status == ItIdleTaskRunning) {

            //
            // There should be a single running task.
            //

            IT_ASSERT(RunningIdleTask == NULL);

            //
            // We found it. Loop through the remaining entries to make
            // sure there is really only one if not debugging.
            //

            RunningIdleTask = IdleTask;

#ifndef IT_DBG
            
            break;

#endif // !IT_DBG

        }
    }

    //
    // Fall through with RunningIdleTask found when walking the list
    // or NULL as initialized at the top.
    //

    DBGPR((ITID,ITSRVD,"IDLE: SrvFindRunningTask(%p)=%p\n",GlobalContext,RunningIdleTask));

    return RunningIdleTask;
}

PITSRV_IDLE_TASK_CONTEXT
ItSpFindIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    IT_HANDLE ItHandle
    )

/*++

Routine Description:

    If there is an idle task registered with ItHandle, this routine
    finds and returns it. GlobalContext's GlobalLock should be held
    while calling this function.

Arguments:

    GlobalContext - Pointer to server context structure.

    ItHandle - Registration handle.

Return Value:

    Pointer to found idle task or NULL if no matching idle tasks were
    found.

--*/

{
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    PITSRV_IDLE_TASK_CONTEXT FoundIdleTask;
    PLIST_ENTRY HeadEntry;
    PLIST_ENTRY NextEntry;

    //
    // Initialize locals.
    //
    
    FoundIdleTask = NULL;

    HeadEntry = &GlobalContext->IdleTasksList;
    NextEntry = HeadEntry->Flink;
    
    while (NextEntry != HeadEntry) {
        
        IdleTask = CONTAINING_RECORD(NextEntry,
                                      ITSRV_IDLE_TASK_CONTEXT,
                                      IdleTaskLink);
        
        NextEntry = NextEntry->Flink;

        if ((IT_HANDLE) IdleTask == ItHandle) {
            FoundIdleTask = IdleTask;
            break;
        }
    }

    //
    // Fall through with FoundIdleTask found when walking the list or
    // NULL as initialized at the top.
    //

    DBGPR((ITID,ITSRVD,"IDLE: SrvFindTask(%p,%p)=%p\n",GlobalContext,ItHandle,FoundIdleTask));

    return FoundIdleTask;
}

VOID 
CALLBACK
ItSpIdleDetectionCallbackRoutine (
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    )

/*++

Routine Description:

    While there are idle tasks to run, this function is called every
    IdleDetectionPeriod to determine if the system is idle. It uses
    the last system snapshot saved in the global context. If it
    determines that the system was idle in the time it was called, it
    samples system activity for smaller intervals, to make sure system
    activity that started as the (possible very long) idle detection
    period expired, is not ignored.

    As long as we are not told to go away (checked by the macro
    ITSP_SHOULD_STOP_IDLE_DETECTION) this function always tries to
    queue a timer to get called back in IdleDetectionPeriod. This
    macro should be called each time the lock is acquired in this
    function. Also, we should not sleep blindly when we need to let
    time pass, but wait on an event that will get signaled when we are
    asked to stop.

Arguments:

    Parameter - Pointer to an idle detection context.
    
    TimerOrWaitFired - Reason why we were called. This should be TRUE
      (i.e. our timer expired)

Return Value:

    None.

--*/

{
    DWORD ErrorCode;
    PITSRV_GLOBAL_CONTEXT GlobalContext;
    // FUTURE-2002/03/26-ScottMa -- Adding the CurrentSystemSnapshot to the
    //   global context would remove the need to repeatedly initialize and
    //   cleanup the stack variable in the ItSpIdleDetectionCallbackRoutine.
    //   Since the calls to that function are already protected against
    //   re-entrancy issues, adding it to the global context is safe.
    ITSRV_SYSTEM_SNAPSHOT CurrentSystemSnapshot;
    SYSTEM_POWER_STATUS SystemPowerStatus;
    LASTINPUTINFO LastUserInput;
    LASTINPUTINFO CurrentLastUserInput;
    BOOLEAN SystemIsIdle;
    BOOLEAN AcquiredLock;
    BOOLEAN MarkedIdleTaskRunning;
    BOOLEAN OrderedToStop;
    ULONG VerificationIdx;
    DWORD WaitResult;
    PITSRV_IDLE_TASK_CONTEXT IdleTask;
    ULONG NumTasksRun;
    ULONG DuePeriod;
    BOOLEAN NotIdleBecauseOfUserInput;
    BOOLEAN MisfiredCallback;
    NTSTATUS Status;
    SYSTEM_POWER_INFORMATION PowerInfo;
    
    //
    // Initialize locals.
    //
    
    GlobalContext = Parameter;
    AcquiredLock = FALSE;
    MarkedIdleTaskRunning = FALSE;
    ItSpInitializeSystemSnapshot(&CurrentSystemSnapshot);
    LastUserInput.cbSize = sizeof(LASTINPUTINFO);
    CurrentLastUserInput.cbSize = sizeof(LASTINPUTINFO);
    NumTasksRun = 0;
    SystemIsIdle = FALSE;
    MisfiredCallback = FALSE;
    NotIdleBecauseOfUserInput = FALSE;

    DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback(%p)\n",GlobalContext));

    //
    // We should not be called without an idle detection context.
    //

    IT_ASSERT(GlobalContext);

    //
    // We should be called only because IdleDetectionPeriod passed and
    // our timer expired.
    //

    IT_ASSERT(TimerOrWaitFired);

    //
    // Get the server lock.
    //

    IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
    AcquiredLock = TRUE;

    //
    // If there is an idle detection callback already running simply
    // exit without doing anything.
    //

    // FUTURE-2002/03/26-ScottMa -- Consider changing this method of setting
    //   a flag and then going to cleanup, only to skip several pages of code
    //   within a single conditional, with a cleaner solution.  One such
    //   method would be to make this case "goto misfiredcallback", setting
    //   that label in the correct location.

    if (GlobalContext->IsIdleDetectionCallbackRunning) {
        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Misfired!\n"));
        MisfiredCallback = TRUE;
        ErrorCode = ERROR_ALREADY_EXISTS;
        goto cleanup;
    }

    GlobalContext->IsIdleDetectionCallbackRunning = TRUE;

    //
    // Make sure the current state is feasible if we are running.
    //

    // FUTURE-2002/03/26-ScottMa -- This assert is overactive:
    //   Since the status is updated to ItSrvStatusDetectingIdle AFTER the
    //   callback is queued via ItSpStartIdleDetection, it is possible --
    //   albeit extremely unlikely -- that this assert could fire prematurely.

    IT_ASSERT(GlobalContext->Status == ItSrvStatusDetectingIdle ||
              GlobalContext->Status == ItSrvStatusUninitializing ||
              GlobalContext->Status == ItSrvStatusStoppingIdleDetection); 

    //
    // If we are told to go away, do so.
    //

    if (ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }
    
    //
    // Get initial last input time that will be used later if we
    // decide to run idle tasks.
    //
        
    ErrorCode = ItSpGetLastInputInfo(&LastUserInput);

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    //
    // Perform idle detection over the period we've been sleeping (if
    // it is not overriden.)
    //
    
    if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideIdleDetection)) {

        //
        // Get current system snapshot.
        //

        ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                          &CurrentSystemSnapshot);
    
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // See if system looks idle since the last snapshot.
        //

        SystemIsIdle = ItSpIsSystemIdle(GlobalContext,
                                        &CurrentSystemSnapshot,
                                        &GlobalContext->LastSystemSnapshot,
                                        ItSrvInitialIdleCheck);

        //
        // If the last input times don't match and that's why we are not
        // idle, make a note.
        //

        if ((CurrentSystemSnapshot.GotLastInputInfo &&
             GlobalContext->LastSystemSnapshot.GotLastInputInfo) &&
            (CurrentSystemSnapshot.LastInputInfo.dwTime !=
             GlobalContext->LastSystemSnapshot.LastInputInfo.dwTime)) {

            NotIdleBecauseOfUserInput = TRUE;
            ASSERT(!SystemIsIdle);
        }

        //
        // Save snapshot.
        //

        ErrorCode = ItSpCopySystemSnapshot(&GlobalContext->LastSystemSnapshot,
                                           &CurrentSystemSnapshot);
    
        if (ErrorCode != ERROR_SUCCESS) {
            goto cleanup;
        }

        //
        // If the system does not look idle over the detection period
        // we'll poll again later.
        //

        if (!SystemIsIdle) {
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    //
    // If we were not asked to override idle verification, verify that
    // the system is idle for a while.
    //

    if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideIdleVerification)) {

        //
        // Loop for a while getting system snapshots over shorter
        // durations. This helps us catch recent significant system
        // activity that seemed insignificant when viewed over the whole
        // IdleDetectionPeriod.
        //

        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Verifying\n"));

        for (VerificationIdx = 0; 
             VerificationIdx < GlobalContext->Parameters.NumVerifications;
             VerificationIdx ++) {

            // FUTURE-2002/03/26-ScottMa -- The following block of code is
            //   almost 100% identical to the verification code that occurs
            //   below [search for identical].  Consider breaking it into
            //   a function for better maintainability and readability.

            //
            // Release the lock.
            //
        
            IT_ASSERT(AcquiredLock);
            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;
        
            //
            // Sleep for the verification period.
            //

            WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection,
                                             GlobalContext->Parameters.IdleVerificationPeriod);

            if (WaitResult != WAIT_TIMEOUT) {
            
                if (WaitResult == WAIT_OBJECT_0) {
                    ErrorCode = ERROR_SUCCESS;
                } else {
                    ErrorCode = GetLastError();
                }

                goto cleanup;
            }

            //
            // Acquire the lock.
            //
        
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;

            //
            // Are we told to go away (this may happen from the time the
            // wait returns till we acquire the lock.)
            //

            if (ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
            
            //
            // Get the new snapshot.
            //

            ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                              &CurrentSystemSnapshot);
        
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // See if system looks idle since the last snapshot.
            //
        
            SystemIsIdle = ItSpIsSystemIdle(GlobalContext,
                                            &CurrentSystemSnapshot,
                                            &GlobalContext->LastSystemSnapshot,
                                            ItSrvIdleVerificationCheck);
        
            //
            // Save snapshot.
            //
        
            ErrorCode = ItSpCopySystemSnapshot(&GlobalContext->LastSystemSnapshot,
                                               &CurrentSystemSnapshot);
        
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        
            //
            // If the system was not idle over the detection period we'll
            // try again later.
            //
        
            if (!SystemIsIdle) {
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }
    }

    //
    // The system has become idle. Update the status.
    //

    DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-RunningIdleTasks\n"));
        
    IT_ASSERT(GlobalContext->Status == ItSrvStatusDetectingIdle);
    ItSpUpdateStatus(GlobalContext, ItSrvStatusRunningIdleTasks);   

    //
    // While we are not told to go away...
    //

    while (!ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {

        //
        // We should be holding the lock when we are making the above
        // check and whenever we come here.
        //
        
        IT_ASSERT(AcquiredLock);
        
        //
        // The list should not be empty.
        //
        
        IT_ASSERT(!IsListEmpty(&GlobalContext->IdleTasksList));
        
        if (IsListEmpty(&GlobalContext->IdleTasksList)) {
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

        //
        // Mark the first idle task in the list running and signal its
        // event.
        //

        IdleTask = CONTAINING_RECORD(GlobalContext->IdleTasksList.Flink,
                                     ITSRV_IDLE_TASK_CONTEXT,
                                     IdleTaskLink);
    
        //
        // It should not be uninitialized or already running!
        //
        
        IT_ASSERT(IdleTask->Status == ItIdleTaskQueued);
        IdleTask->Status = ItIdleTaskRunning;
        MarkedIdleTaskRunning = TRUE;

        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Running %d\n",IdleTask->Properties.IdleTaskId));

        NumTasksRun++;
        
        //
        // Signal its events.
        //

        ResetEvent(IdleTask->StopEvent);
        SetEvent(IdleTask->StartEvent);

        //
        // Reset the event that will get set when the idle task we
        // mark running gets unregistered.
        //

        ResetEvent(GlobalContext->RemovedRunningIdleTask);

        //
        // Release the lock.
        //

        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
        AcquiredLock = FALSE;

        //
        // Poll frequently for user input while system background
        // activity should be taking place. We cannot poll for
        // anything else because the running idle task is supposed to
        // be using CPU, issuing I/Os etc. As soon as user input comes
        // we want to signal background threads to stop their
        // activity. We will do this until the running idle task is
        // completed and unregistered.
        //

        do {

            //
            // We should not be holding the lock while polling.
            //
            
            IT_ASSERT(!AcquiredLock);

            //
            // Note that since we set MarkedIdleTaskRunning, going to
            // "cleanup" will end up marking this idle task not
            // running and setting the stop event.
            //

            // FUTURE-2002/03/26-ScottMa -- The following block of code and
            //   the related block that occurs after the wait [search for
            //   related] should be converted into a single call to the
            //   ItIsSystemIdle function to reduce code duplication and
            //   improve both maintainability and readability.

            if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideUserInputCheckToStopTask)) {

                //
                // Get last user input.
                //
                
                ErrorCode = ItSpGetLastInputInfo(&CurrentLastUserInput);

                if (ErrorCode != ERROR_SUCCESS) {
                    goto cleanup;
                }

                if (LastUserInput.dwTime != CurrentLastUserInput.dwTime) {

                    //
                    // There is new input.
                    //

                    DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-NewUserInput\n"));
                    
                    SystemIsIdle = FALSE;
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }

                //
                // We don't need to update last input since it should
                // be same as current.
                //
            }

            //
            // Wait for a while to poll for user input again. We
            // should not be holding the lock while waiting.
            //

            IT_ASSERT(!AcquiredLock);

            WaitResult = WaitForSingleObject(GlobalContext->RemovedRunningIdleTask,
                                         GlobalContext->Parameters.IdleInputCheckPeriod);
            
            if (WaitResult == WAIT_OBJECT_0) {
                
                //
                // Break out of this loop to pick up a new idle
                // task to run.
                //
                
                MarkedIdleTaskRunning = FALSE;

                DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-TaskRemoved\n"));
                
                break;
            }
            
            if (WaitResult != WAIT_TIMEOUT) {
                
                //
                // Something went wrong...
                //
                
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }

            // FUTURE-2002/03/26-ScottMa -- The following block of code and
            //   the related block that occurs before the wait [search for
            //   related] should be converted into a single call to the
            //   ItIsSystemIdle function to reduce code duplication and
            //   improve both maintainability and readability.

            //
            // Check to see if the system has started running from battery.
            //

            if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideBatteryCheckToStopTask)) {
                if (GetSystemPowerStatus(&SystemPowerStatus)) {
                    if (SystemPowerStatus.ACLineStatus == 0) {

                        DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-SystemOnBattery\n"));
                        
                        SystemIsIdle = FALSE;
                        ErrorCode = ERROR_SUCCESS;
                        goto cleanup;
                    }
                }
            }

            //
            // If the kernel is about to enter standby or hibernate because
            // it has also detected the system idle, stop this task.
            //

            if (!(GlobalContext->IdleDetectionOverride & ItSrvOverrideAutoPowerCheckToStopTask)) {

                Status = NtPowerInformation(SystemPowerInformation,
                                            NULL,
                                            0,
                                            &PowerInfo,
                                            sizeof(PowerInfo));
            
                if (NT_SUCCESS(Status)) {
                    if (PowerInfo.TimeRemaining < IT_DEFAULT_MAX_TIME_REMAINING_TO_SLEEP) {
                        SystemIsIdle = FALSE;
                        ErrorCode = ERROR_SUCCESS;
                        goto cleanup;
                    }
                }
            }

            //
            // Are we stopping the service?
            //

            if (ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
                SystemIsIdle = TRUE;
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }

            //
            // The idle task is still running. Loop to check for user
            // input.
            //

        } while (TRUE);

        // FUTURE-2002/03/26-ScottMa -- This conditional is a tautology:
        //   The lock could not have been acquired through any codepath
        //   ending here, it should be an assert instead.

        if (!AcquiredLock) {
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;
        }

        if (!(GlobalContext->IdleDetectionOverride & ItSrvOverridePostTaskIdleCheck)) {
        
            //
            // Get the latest snapshot of the system. This snapshot will
            // be used to determine if the system is still idle before
            // picking up a new task.
            //
            
            ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                              &GlobalContext->LastSystemSnapshot);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            // FUTURE-2002/03/26-ScottMa -- The following block of code is
            //   almost 100% identical to the verification code that occurs
            //   above [search for identical].  Consider breaking it into
            //   a function for better maintainability and readability.

            //
            // Release the lock.
            //

            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;

            //
            // Wait for the verification period.
            //

            WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection,
                                             GlobalContext->Parameters.IdleVerificationPeriod);

            if (WaitResult != WAIT_TIMEOUT) {
                
                if (WaitResult == WAIT_OBJECT_0) {
                    ErrorCode = ERROR_SUCCESS;
                } else {
                    ErrorCode = GetLastError();
                }
                
                goto cleanup;
            }

            //
            // Acquire the lock and get new snapshot.
            //

            IT_ASSERT(!AcquiredLock);
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;

            ErrorCode = ItSpGetSystemSnapshot(GlobalContext, 
                                              &CurrentSystemSnapshot);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // See if system looks idle since the last snapshot.
            //
            
            SystemIsIdle = ItSpIsSystemIdle(GlobalContext,
                                            &CurrentSystemSnapshot,
                                            &GlobalContext->LastSystemSnapshot,
                                            ItSrvIdleVerificationCheck);
            
            //
            // Save snapshot.
            //
            
            ErrorCode = ItSpCopySystemSnapshot(&GlobalContext->LastSystemSnapshot,
                                               &CurrentSystemSnapshot);
            
            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            //
            // If the system is no longer idle, we should not start a new task.
            //
            
            if (!SystemIsIdle) {
                ErrorCode = ERROR_SUCCESS;
                goto cleanup;
            }
        }

        //
        // Loop to try to run more idle tasks. The lock should be acquired.
        //

        IT_ASSERT(AcquiredLock);
    }
    
    //
    // We should come here only if we were asked to stop, i.e. the
    // check in while() causes us to break from looping.
    //
    
    IT_ASSERT(AcquiredLock);
    IT_ASSERT(ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext));

 cleanup:

    //
    // Simply cleanup and exit if this is a misfired callback.
    //

    if (!MisfiredCallback) {
    
        //
        // We'll have to check status to see if we have to requeue
        // ourselves. Make sure we have the lock.
        //

        if (AcquiredLock == FALSE) {
            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;
        }

        //
        // If we marked an idle task running, make sure we reset its state
        // back to queued.
        //

        if (MarkedIdleTaskRunning) {

            //
            // We may have gone to cleanup after the idle task we were
            // running was removed, but before we realized it. See if
            // the running idle task was removed. We are not waiting,
            // we are just checking if the event has been signaled.
            //

            WaitResult = WaitForSingleObject(GlobalContext->RemovedRunningIdleTask,
                                             0);
            
            if (WaitResult != WAIT_OBJECT_0) {

                //
                // The running idle was not removed. Reset its state.
                //

                IdleTask = ItSpFindRunningIdleTask(GlobalContext);
                
                //
                // To be safe, we try to cleanup even if the above
                // check fails with another result. We don't want the
                // assert to fire then, but only if the event is
                // really not set.
                //

                if (WaitResult == WAIT_TIMEOUT) {
                    IT_ASSERT(IdleTask);
                }
                
                if (IdleTask) {
                    ResetEvent(IdleTask->StartEvent);
                    SetEvent(IdleTask->StopEvent);
                    IdleTask->Status = ItIdleTaskQueued;

                    //
                    // Put this task to the end of the list. If a single task
                    // is taking too long to run, this gives more chance to other
                    // tasks.
                    //

                    RemoveEntryList(&IdleTask->IdleTaskLink);
                    InsertTailList(&GlobalContext->IdleTasksList, &IdleTask->IdleTaskLink);                    
                }
            }
        }

        //
        // If we set the status to running idle tasks, revert it to
        // detecting idle.
        //

        if (GlobalContext->Status == ItSrvStatusRunningIdleTasks) {
            ItSpUpdateStatus(GlobalContext, ItSrvStatusDetectingIdle);
        }

        //
        // Queue ourselves to fire up after another idle detection
        // period. We'll try every once a while until we get it or we
        // are ordered to stop.
        //
    
        // ISSUE-2002/03/26-ScottMa -- This should not be a loop.  Looking
        //   at the codepath, it appears as though it will be broken out of
        //   as soon as the timer is requeued.  Otherwise, it appears that
        //   bad things might happen.  The IsIdleDetectionCallbackRunning
        //   flag should be set to FALSE here, before trying to requeue
        //   the timer, so that a new call can progress.  Further, the
        //   OrderedToStop variable should be moved to an else clause
        //   (assuming that the below while is converted to an if).

        while (!ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)) {
    
            IT_ASSERT(GlobalContext->IdleDetectionTimerHandle);

            DuePeriod = GlobalContext->Parameters.IdleDetectionPeriod;

            //
            // Try to detect idle quicker for the case when the last user 
            // input was just seconds after the last snapshot. In that case
            // instead of waiting for another full "DetectionPeriod", we'll 
            // wait up to "DetectionPeriod" after the last user input. Note
            // that we'll attempt this optimization only if the reason we
            // say the system is not idle is recent user input. E.g. We don't 
            // want to poll more often if we are on battery and that's why
            // we say that the system is not idle.
            //

            // ISSUE-2002/03/26-ScottMa -- This test will catch any time that
            //   the system was marked as not idle EVEN if it is also on
            //   battery or had some OTHER reason for being considered idle.
            //   If this codepath is taken out of the loop, the cost of
            //   doing this adjustment once is probably acceptable to perform
            //   *any* time the input changed, ignoring the NotIdleBecause...
            //   flag altogether, and just checking LastInputInfo.

            if (NotIdleBecauseOfUserInput && 
                (ERROR_SUCCESS == ItSpGetLastInputInfo(&LastUserInput))) {

                ULONG DuePeriod2;
                ULONG TimeSinceLastInput;

                //
                // Calculate how long it's been since last user input.
                //

                TimeSinceLastInput = GetTickCount() - LastUserInput.dwTime;

                //
                // Subtract this time from the idle detection period to account
                // for time that has already past since last input.
                //

                DuePeriod2 = 0;
                
                if (TimeSinceLastInput < GlobalContext->Parameters.IdleDetectionPeriod) {           
                    DuePeriod2 = GlobalContext->Parameters.IdleDetectionPeriod - TimeSinceLastInput;
                }

                //
                // The last user input we check gets updated only every so
                // often (e.g. every minute). Add a fudge factor for this and to 
                // protect us from scheduling the next idle check too soon.
                //

#ifdef IT_DBG
                if (ItSrvGlobalContext->Parameters.IdleDetectionPeriod >= 60*1000) {
#endif // IT_DBG

                    DuePeriod2 += 65 * 1000;

#ifdef IT_DBG
                }
#endif // IT_DBG

                if (DuePeriod > DuePeriod2) {
                    DuePeriod = DuePeriod2;
                }
            }

            //
            // If we are forcing all tasks to be processed, requeue ourself to
            // run again in a short time.
            //

            if (GlobalContext->IdleDetectionOverride & ItSrvOverrideLongRequeueTime) {
                DuePeriod = 50;
            }

            if (ChangeTimerQueueTimer(NULL,
                                      GlobalContext->IdleDetectionTimerHandle,
                                      DuePeriod,
                                      IT_VERYLONG_TIMER_PERIOD)) {

                DBGPR((ITID,ITTRC,"IDLE: SrvIdleDetectionCallback-Requeued: DuePeriod=%d\n", DuePeriod));

                break;
            }

            //
            // Release the lock.
            //
            
            IT_ASSERT(AcquiredLock);
            IT_RELEASE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = FALSE;

            //
            // Sleep for sometime and try again.
            //
            
            WaitResult = WaitForSingleObject(GlobalContext->StopIdleDetection, 
                                             GlobalContext->Parameters.IdleDetectionPeriod); 

            //
            // Get the lock again.
            //

            IT_ACQUIRE_LOCK(GlobalContext->GlobalLock);
            AcquiredLock = TRUE;       
            
            //
            // Now check the result of the wait.
            //
            
            if (WaitResult != WAIT_OBJECT_0 && 
                WaitResult != WAIT_TIMEOUT) {

                //
                // This is an error too! The world is going down on us,
                // let us get carried away... This will make it easier for
                // the server to shutdown (i.e. no callback running).
                //
                
                break;
            }
        }
    
        IT_ASSERT(AcquiredLock);

        //
        // Check if we were ordered to stop.
        //

        OrderedToStop = ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext);
        
        //
        // Mark us not running anymore.
        //

        GlobalContext->IsIdleDetectionCallbackRunning = FALSE;
    }

    //
    // Release the lock if we are holding it.
    //

    if (AcquiredLock) {
        IT_RELEASE_LOCK(GlobalContext->GlobalLock);
    }

    //
    // Cleanup intermediate snapshot structure if necessary.
    //
    
    ItSpCleanupSystemSnapshot(&CurrentSystemSnapshot);

    DBGPR((ITID,ITSRVD,"IDLE: SrvIdleDetectionCallback(%p)=%d,%d,%d,%d\n",
           GlobalContext,ErrorCode,OrderedToStop,SystemIsIdle,NumTasksRun));

    return;
}

VOID
ItSpInitializeSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    )

/*++

Routine Description:

    This routine initializes a system snapshot structure.

Arguments:

    SystemSnapshot - Pointer to structure.

Return Value:

    None.

--*/

{
    //
    // Initialize the disk performance data array.
    //

    SystemSnapshot->NumPhysicalDisks = 0;
    SystemSnapshot->DiskPerfData = NULL;

    //
    // We don't have any valid data.
    //

    SystemSnapshot->GotLastInputInfo = 0;
    SystemSnapshot->GotSystemPerformanceInfo = 0;
    SystemSnapshot->GotDiskPerformanceInfo = 0;
    SystemSnapshot->GotSystemPowerStatus = 0;
    SystemSnapshot->GotSystemPowerInfo = 0;
    SystemSnapshot->GotSystemExecutionState = 0;
    SystemSnapshot->GotDisplayPowerStatus = 0;

    SystemSnapshot->SnapshotTime = -1;
}

VOID
ItSpCleanupSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    )

/*++

Routine Description:

    This routine cleans up fields of a system snapshot structure. It
    does not free the structure itself. The structure should have been
    initialized with a call to ItSpCleanupSystemSnapshot.

Arguments:

    SystemSnapshot - Pointer to structure.

Return Value:

    None.

--*/

{
    //
    // If a disk performance data array is allocated free it.
    //
    
    if (SystemSnapshot->DiskPerfData) {
        IT_ASSERT(SystemSnapshot->NumPhysicalDisks);
        IT_FREE(SystemSnapshot->DiskPerfData);
    }
}

DWORD
ItSpCopySystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT DestSnapshot,
    PITSRV_SYSTEM_SNAPSHOT SourceSnapshot
    )

/*++

Routine Description:

    This routine attempts to copy SourceSnapshot to DestSnapshot. If
    the copy fails, DestSnapshot remains intact.

Arguments:

    DestSnapshot - Pointer to snapshot to be updated.
    
    SourceSnapshot - Pointer to snapshot to copy.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    ULONG OrgNumDisks;
    PITSRV_DISK_PERFORMANCE_DATA OrgDiskPerfData;
    PITSRV_DISK_PERFORMANCE_DATA NewDiskPerfData;
    ULONG AllocationSize;
    ULONG CopySize;

    //
    // Initialize locals.
    //

    NewDiskPerfData = NULL;

    //
    // Do we have to copy disk performance data?
    //

    if (SourceSnapshot->GotDiskPerformanceInfo) {
        
        //
        // Allocate a new array if the disk performance data won't fit.
        //

        if (SourceSnapshot->NumPhysicalDisks > DestSnapshot->NumPhysicalDisks) {
            
            AllocationSize = SourceSnapshot->NumPhysicalDisks * 
                sizeof(ITSRV_DISK_PERFORMANCE_DATA);

            NewDiskPerfData = IT_ALLOC(AllocationSize);
            
            if (!NewDiskPerfData) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        }    
    }
    
    //
    // Beyond this point we should not fail because we modify
    // DestSnapshot.
    //

    //
    // Save original disk performance data array.
    //

    OrgDiskPerfData = DestSnapshot->DiskPerfData;
    OrgNumDisks = DestSnapshot->NumPhysicalDisks;

    //
    // Copy the whole structure over and put back original disk
    // performance data array.
    //

    RtlCopyMemory(DestSnapshot,
                  SourceSnapshot,
                  sizeof(ITSRV_SYSTEM_SNAPSHOT));

    DestSnapshot->DiskPerfData = OrgDiskPerfData;
    DestSnapshot->NumPhysicalDisks = OrgNumDisks;

    //
    // Determine if/how we will copy over disk performance data.
    //
    
    if (SourceSnapshot->GotDiskPerformanceInfo) {

        if (SourceSnapshot->NumPhysicalDisks > DestSnapshot->NumPhysicalDisks) {
            
            //
            // Free old array and use the new one we allocated above.
            //
            
            if (DestSnapshot->DiskPerfData) {
                IT_FREE(DestSnapshot->DiskPerfData);
            }

            DestSnapshot->DiskPerfData = NewDiskPerfData;
            NewDiskPerfData = NULL;
        } 
        
        if (SourceSnapshot->NumPhysicalDisks == 0) {
            
            //
            // This does not make sense... (They got disk data and
            // there are 0 physical disks in the system?) Yet we go
            // with it and to be consistent, free our data array.
            //
            
            if (DestSnapshot->DiskPerfData) {
                IT_FREE(DestSnapshot->DiskPerfData);
            }
            
            DestSnapshot->DiskPerfData = NULL;

        } else {

            //
            // Copy over their disk data and update NumPhysicalDisks.
            //

            CopySize = SourceSnapshot->NumPhysicalDisks * 
                sizeof(ITSRV_DISK_PERFORMANCE_DATA);

            RtlCopyMemory(DestSnapshot->DiskPerfData,
                          SourceSnapshot->DiskPerfData,
                          CopySize);

        }
        
        DestSnapshot->NumPhysicalDisks = SourceSnapshot->NumPhysicalDisks;
    }

    //
    // Done.
    //
    
    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    if (NewDiskPerfData) {
        IT_FREE(NewDiskPerfData);
    }

    DBGPR((ITID,ITSRVDD,"IDLE: SrvCopySnapshot()=%d\n",ErrorCode));

    return ErrorCode;
}

DWORD
ItSpGetSystemSnapshot (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    )

/*++

Routine Description:

    This routine fills input system snapshot with data queried from
    various sources. The snapshot structure should have been
    initialized by ItSpInitializeSystemSnapshot. The output
    SystemSnapshot can be passed back in.

Arguments:

    GlobalContext - Pointer to idle detection context.

    SystemSnapshot - Pointer to structure to fill.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    NTSTATUS Status;

    //
    // Query disk performance counters.
    //

    if (GlobalContext->DiskPerfWmiHandle) {

        ErrorCode = ItSpGetWmiDiskPerformanceData(GlobalContext->DiskPerfWmiHandle,
                                                  &SystemSnapshot->DiskPerfData,
                                                  &SystemSnapshot->NumPhysicalDisks,
                                                  &GlobalContext->WmiQueryBuffer,
                                                  &GlobalContext->WmiQueryBufferSize);
        
        if (ErrorCode == ERROR_SUCCESS) {

            SystemSnapshot->GotDiskPerformanceInfo = TRUE;

        } else {
            
            SystemSnapshot->GotDiskPerformanceInfo = FALSE;
        }

    } else {
        
        SystemSnapshot->GotDiskPerformanceInfo = FALSE;
    }

    //
    // Get system performance information.
    //

    Status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &SystemSnapshot->SystemPerformanceInfo,
                                      sizeof(SYSTEM_PERFORMANCE_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status)) {
        
        SystemSnapshot->GotSystemPerformanceInfo = TRUE;

    } else {

        SystemSnapshot->GotSystemPerformanceInfo = FALSE;
    }

    //
    // Get last input time.
    //

    SystemSnapshot->LastInputInfo.cbSize = sizeof(LASTINPUTINFO);

    ErrorCode = ItSpGetLastInputInfo(&SystemSnapshot->LastInputInfo);

    if (ErrorCode == ERROR_SUCCESS) {

        SystemSnapshot->GotLastInputInfo = TRUE;

    } else {
        
        SystemSnapshot->GotLastInputInfo = FALSE;
    }

    //
    // Get system power status to determine if we are running on
    // battery etc.
    //

    if (GetSystemPowerStatus(&SystemSnapshot->SystemPowerStatus)) {
        
        SystemSnapshot->GotSystemPowerStatus = TRUE;
        
    } else {

        SystemSnapshot->GotSystemPowerStatus = FALSE;
    }   

    //
    // Get system power information to see if the system is close to
    // entering standby or hibernate automatically.
    //   

    Status = NtPowerInformation(SystemPowerInformation,
                                NULL,
                                0,
                                &SystemSnapshot->PowerInfo,
                                sizeof(SYSTEM_POWER_INFORMATION));

    if (NT_SUCCESS(Status)) {

        SystemSnapshot->GotSystemPowerInfo = TRUE;

    } else {

        SystemSnapshot->GotSystemPowerInfo = FALSE;
    }

    //
    // Get system execution state to determine if somebody's running a
    // presentation, burning a cd etc.
    //

    Status = NtPowerInformation(SystemExecutionState,
                                NULL,                
                                0,                   
                                &SystemSnapshot->ExecutionState,              
                                sizeof(EXECUTION_STATE));  
    
    if (NT_SUCCESS(Status)) {
        
        SystemSnapshot->GotSystemExecutionState = TRUE;

    } else {

        SystemSnapshot->GotSystemExecutionState = FALSE; 
    }

    //
    // Get display power status.
    //

    ErrorCode = ItSpGetDisplayPowerStatus(&SystemSnapshot->ScreenSaverIsRunning);
    
    if (ErrorCode == ERROR_SUCCESS) {

        SystemSnapshot->GotDisplayPowerStatus = TRUE;

    } else {

        SystemSnapshot->GotDisplayPowerStatus = FALSE;

    }

    //
    // Fill in the time when this snapshot was taken as the last thing
    // to be conservative. This function may have taken long, and the
    // values we snapshoted may have changed by now.
    //
    
    SystemSnapshot->SnapshotTime = GetTickCount();

    DBGPR((ITID,ITSRVDD,"IDLE: SrvGetSnapshot()=%d,%d,%d\n",
           (ULONG) SystemSnapshot->GotLastInputInfo,
           (ULONG) SystemSnapshot->GotSystemPerformanceInfo,
           (ULONG) SystemSnapshot->GotDiskPerformanceInfo));

    return ERROR_SUCCESS;
}

// FUTURE-2002/03/26-ScottMa -- If the CurrentSystemSnapshot is added to the
//   global context, both parameters no longer need to be passed to this
//   function.  It is only called from within ItSpIdleDetectionCallbackRoutine,
//   and always uses the same values for current & last snapshot.

BOOLEAN
ItSpIsSystemIdle (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT CurrentSnapshot,
    PITSRV_SYSTEM_SNAPSHOT LastSnapshot,
    ITSRV_IDLE_CHECK_REASON IdleCheckReason
    )

/*++

Routine Description:

    This routine compares two snapshots to determine if the system has
    been idle between them.

    This function acts very conservatively in saying that the system
    is idle.

Arguments:

    GlobalContext - Pointer to server context structure.

    CurrentSnapshot - Pointer to system snapshot.
    
    LastSnapshot - Pointer to system snapshot taken before
      CurrentSnapshot.
      
    IdleCheckReason - Where this function is being called from. We may
      do things differently when we get called to do the initial check
      to see if the system idle, or to verify it is really idle, or to
      make sure the idle task we started is still running and is not
      stuck.

Return Value:

    TRUE - System was idle between the two snapshots.
    
    FALSE - The system was not idle between two snapshots.

--*/

{
    DWORD SnapshotTimeDifference;
    BOOLEAN SystemIsIdle;
    LARGE_INTEGER IdleProcessRunTime;
    ULONG CpuIdlePercentage;
    ULONG DiskIdx;
    ULONG DiskIdleTimeDifference;
    ULONG DiskIdlePercentage;
    PIT_IDLE_DETECTION_PARAMETERS Parameters;

    //
    // Initialize locals.
    //
    
    Parameters = &GlobalContext->Parameters;
    SystemIsIdle = FALSE;
    SnapshotTimeDifference = CurrentSnapshot->SnapshotTime - 
                             LastSnapshot->SnapshotTime;
    
    //
    // Verify parameters.
    //
    
    IT_ASSERT(IdleCheckReason < ItSrvMaxIdleCheckReason);

    //
    // If system tick count wrapped or they are passing in bogus
    // times, or the snapshots seem to be taken nearly at the same
    // time, say the system is not idle to avoid any weird issues.
    //
    
    if (CurrentSnapshot->SnapshotTime <= LastSnapshot->SnapshotTime) {
        goto cleanup;
    }

    IT_ASSERT(SnapshotTimeDifference);

    //
    // If either snapshot does not have last user input (mouse or
    // keyboard) info, we cannot reliably say the system was idle.
    //

    if (!CurrentSnapshot->GotLastInputInfo ||
        !LastSnapshot->GotLastInputInfo) {
        goto cleanup;
    }

    //
    // If there has been user input between the two snapshots, the
    // system was not idle. We don't care when the user input
    // happened (e.g. right after the last snapshot).
    //

    DBGPR((ITID,ITSNAP,"IDLE: UserInput: Last %u Current %u\n", 
           LastSnapshot->LastInputInfo.dwTime,
           CurrentSnapshot->LastInputInfo.dwTime));

    if (LastSnapshot->LastInputInfo.dwTime != 
        CurrentSnapshot->LastInputInfo.dwTime) {
        goto cleanup;
    }

    //
    // If we are running on battery, don't run idle tasks.
    //
    
    if (CurrentSnapshot->GotSystemPowerStatus) {
        if (CurrentSnapshot->SystemPowerStatus.ACLineStatus == 0) {
            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: Running on battery\n"));
            goto cleanup;
        }
    }

    //
    // If system will automatically enter standby or hibernate soon
    // it is too late for us to run our tasks.
    //

    if (CurrentSnapshot->GotSystemPowerInfo) {
        // FUTURE-2002/03/26-ScottMa -- This constant doesn't have a
        //   corresponding parameter in the IT_IDLE_DETECTION_PARAMETERS
        //   structure.  Should it be added to the structure like the others?

        if (CurrentSnapshot->PowerInfo.TimeRemaining < IT_DEFAULT_MAX_TIME_REMAINING_TO_SLEEP) {
            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: System will standby / hibernate soon\n"));
            goto cleanup;
        }
    }

    //
    // If the screen saver is running, assume the system is
    // idle. Otherwise, if a heavy-weight OpenGL screen saver is
    // running our CPU checks may bail us out of realizing that the
    // system is idle. We skip this check when trying to determine an
    // idle task is stuck or if it is really running. Note that the
    // screen saver activity may make us think the idle task is still
    // running, even if it is stuck.
    //

    if (IdleCheckReason != ItSrvIdleTaskRunningCheck) {
        if (CurrentSnapshot->GotDisplayPowerStatus) {
            if (CurrentSnapshot->ScreenSaverIsRunning) {
                
                DBGPR((ITID,ITSNAP,"IDLE: Snapshot: ScreenSaverRunning\n"));
                SystemIsIdle = TRUE;
                goto cleanup;
            }
        }
    }

    //
    // If system may look idle but somebody's running a powerpoint
    // presentation, watching hardware-decoded DVD etc don't run idle
    // tasks. Note that we do not check for ES_SYSTEM_REQUIRED, since
    // it is set by fax servers, answering machines and such as well.
    // ES_DISPLAY_REQUIRED is the one supposed to be used by
    // multimedia/presentation applications.
    //

    if (CurrentSnapshot->GotSystemExecutionState) {
        if ((CurrentSnapshot->ExecutionState & ES_DISPLAY_REQUIRED)) {

            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: Execution state:%x\n",CurrentSnapshot->ExecutionState));
            goto cleanup;
        }
    }

    //
    // We definitely want CPU & general system performance data as
    // well.
    //

    if (!CurrentSnapshot->GotSystemPerformanceInfo ||
        !LastSnapshot->GotSystemPerformanceInfo) {
        goto cleanup;
    }

    //
    // Calculate how many ms the idle process ran. The IdleProcessTime
    // on system performance information structures is in 100ns. To
    // convert it to ms we divide by (10 * 1000).
    //
    
    // ISSUE-2002/03/26-ScottMa -- What happens here if IdleProcessTime wraps?

    IdleProcessRunTime.QuadPart = 
        (CurrentSnapshot->SystemPerformanceInfo.IdleProcessTime.QuadPart - 
         LastSnapshot->SystemPerformanceInfo.IdleProcessTime.QuadPart);

    IdleProcessRunTime.QuadPart = IdleProcessRunTime.QuadPart / 10000;
    
    //
    // Adjust it for the number of CPUs in the system. 
    //
    
    IT_ASSERT(GlobalContext->NumProcessors);

    if (GlobalContext->NumProcessors) {
        IdleProcessRunTime.QuadPart = IdleProcessRunTime.QuadPart / GlobalContext->NumProcessors;
    }
    
    //
    // Calculate idle cpu percentage this translates to.
    //

    CpuIdlePercentage = (ULONG) (IdleProcessRunTime.QuadPart * 100 / SnapshotTimeDifference);

    DBGPR((ITID,ITSNAP,"IDLE: Snapshot: CPU %d\n", CpuIdlePercentage));

    if (CpuIdlePercentage < Parameters->MinCpuIdlePercentage) {
        goto cleanup;
    }

    //
    // We may not have disk performance data because WMI thingies were
    // not initiated etc.
    //

    if (CurrentSnapshot->GotDiskPerformanceInfo &&
        LastSnapshot->GotDiskPerformanceInfo) {

        //
        // If a new disk was added / removed since last snapshot, say
        // the system is not idle.
        //

        if (CurrentSnapshot->NumPhysicalDisks != 
            LastSnapshot->NumPhysicalDisks) {
            goto cleanup;
        }

        //
        // We assume that the disk data is in the same order in both
        // snapshots. If the ordering of disks changed etc, it will
        // most likely cause us to say the system is not idle. It may
        // cause us to ignore some real activity with very low
        // possibility. That is why we verify several times when we
        // see system idle.
        //
        
        for (DiskIdx = 0; 
             DiskIdx < CurrentSnapshot->NumPhysicalDisks;
             DiskIdx++) {
            
            DiskIdleTimeDifference = 
                CurrentSnapshot->DiskPerfData[DiskIdx].DiskIdleTime -
                LastSnapshot->DiskPerfData[DiskIdx].DiskIdleTime;
            
            DiskIdlePercentage = (DiskIdleTimeDifference  * 100) /
                                 SnapshotTimeDifference;
            
            DBGPR((ITID,ITSNAP,"IDLE: Snapshot: Disk %d:%d\n",
                   DiskIdx, DiskIdlePercentage));
            
            if (DiskIdlePercentage < Parameters->MinDiskIdlePercentage) {
                goto cleanup;
            }
        }
    }

    //
    // We passed all the checks.
    //

    SystemIsIdle = TRUE;

 cleanup:

    DBGPR((ITID,ITSRVDD,"IDLE: SrvIsSystemIdle()=%d\n",(ULONG)SystemIsIdle));
    
    return SystemIsIdle;
}

DWORD
ItSpGetLastInputInfo (
    PLASTINPUTINFO LastInputInfo
    )

/*++

Routine Description:

    This function retrieves the time of the last user input event.

Arguments:

    LastInputInfo - Pointer to structure to update.

Return Value:

    Win32 error code.
    
--*/

{
    DWORD ErrorCode;

    //
    // Verify parameter.
    //

    if (LastInputInfo->cbSize != sizeof(LASTINPUTINFO)) {
        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // We get the last input info from the shared system page that is
    // updated by all terminal server sessions.
    //

    LastInputInfo->dwTime = USER_SHARED_DATA->LastSystemRITEventTickCount;

#ifdef IT_DBG
    
    //
    // On the checked build, if we are stressing, we will set the detection
    // period below the period with which the system last input time is
    // updated. If it is so, use the Win32 GetLastInputInfo call. This call
    // will get the user input info only for the current session, but when
    // stressing this is OK.
    //

    if (ItSrvGlobalContext->Parameters.IdleDetectionPeriod < 60*1000) {

        if (!GetLastInputInfo(LastInputInfo)) {
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

#endif // IT_DBG

    ErrorCode = ERROR_SUCCESS;

cleanup:

    return ErrorCode;
}

BOOLEAN
ItSpIsPhysicalDrive (
    PDISK_PERFORMANCE DiskPerformanceData
    ) 

/*++

Routine Description:

    This function attempts to determine if the specified disk is a
    logical or physical disk.

Arguments:

    DiskPerformanceData - Pointer to disk performance data for the disk.

Return Value:

    TRUE - The disk is a physical disk.
    
    FALSE - The disk is not a physical disk.

--*/

{
    ULONG ComparisonLength;

    //
    // Initialize locals.
    //

    ComparisonLength = 
        sizeof(DiskPerformanceData->StorageManagerName) / sizeof(WCHAR);

    //
    // We have to determine if this is a physical disk or not from the
    // storage manager's name.
    //

    if (!wcsncmp(DiskPerformanceData->StorageManagerName, 
                 L"Partmgr ", 
                 ComparisonLength)) {

        return TRUE;
    }

    if (!wcsncmp(DiskPerformanceData->StorageManagerName, 
                 L"PhysDisk", 
                 ComparisonLength)) {

        return TRUE;
    }
    
    return FALSE;
}

// FUTURE-2002/03/26-ScottMa -- The InputQueryBuffer (and Size) parameters
//   are always supplied, and don't need to be optional to this function.

DWORD
ItSpGetWmiDiskPerformanceData(
    IN WMIHANDLE DiskPerfWmiHandle,
    IN OUT PITSRV_DISK_PERFORMANCE_DATA *DiskPerfData,
    IN OUT ULONG *NumPhysicalDisks,
    OPTIONAL IN OUT PVOID *InputQueryBuffer,
    OPTIONAL IN OUT ULONG *InputQueryBufferSize
    )

/*++

Routine Description:

    This function queries disk performance counters and updates input
    parameters.

Arguments:

    DiskPerfWmiHandle - WMI handle to DiskPerf.   

    DiskPerfData - This array is updated with data from all registered
      physical disks' WMI performance data blocks. If it is not big
      enough, it is freed and reallocated using IT_FREE/IT_ALLOC.
      
    NumPhysicalDisks - This is the size of DiskPerfData array on
      input. If the number of registered physical disks change, it is
      updated on return.

    InputQueryBuffer, InputQueryBufferSize - If specified, they describe a
      query buffer to be used and updated when querying WMI. The
      buffer must be allocated with IT_ALLOC. The returned buffer may
      be relocated/resized and should be freed with IT_FREE. The
      buffer's contents on input and output are trash.

Return Value:

    Win32 error code.

--*/

{
    DWORD ErrorCode;
    PVOID QueryBuffer;
    ULONG QueryBufferSize;
    ULONG RequiredSize;
    ULONG NumTries;
    PWNODE_ALL_DATA DiskWmiDataCursor;
    PDISK_PERFORMANCE DiskPerformanceData;
    LARGE_INTEGER PerformanceCounterFrequency;
    BOOLEAN UsingInputBuffer;
    ULONG NumDiskData;
    PITSRV_DISK_PERFORMANCE_DATA NewDataBuffer;

    //
    // Initialize locals.
    //

    QueryBuffer = NULL;
    QueryBufferSize = 0;
    UsingInputBuffer = FALSE;
    NewDataBuffer = NULL;

    //
    // Determine if we will be using the query buffer input by the
    // user. In case we are using them it is crucial that QueryBuffer
    // and QueryBufferSize are not set to bogus values during the
    // function.
    //

    if (InputQueryBuffer && InputQueryBufferSize) {
        UsingInputBuffer = TRUE;
        QueryBuffer = *InputQueryBuffer;
        QueryBufferSize = *InputQueryBufferSize;
    }
    
    //
    // Query disk performance data.
    //
    
    NumTries = 0;

    do {
        
        RequiredSize = QueryBufferSize;

        __try {

            ErrorCode = WmiQueryAllData(DiskPerfWmiHandle,
                                     &RequiredSize,
                                     QueryBuffer);

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            //
            // There is something wrong if we got an exception.
            //

            ErrorCode = GetExceptionCode();
            
            if (ErrorCode == ERROR_SUCCESS) {
                ErrorCode = ERROR_INVALID_FUNCTION;
            }
            
            goto cleanup;
        }
            
        if (ErrorCode == ERROR_SUCCESS) {
            
            //
            // We got the data.
            //
            
            break;
        }

        //
        // Check to see if we failed for a real reason other than that
        // our input buffer was too small.
        //

        if (ErrorCode != ERROR_INSUFFICIENT_BUFFER) {
            goto cleanup;
        }
        
        //
        // Reallocate the buffer to the required size.
        //

        if (QueryBufferSize) {
            IT_FREE(QueryBuffer);
            QueryBufferSize = 0;
        }

        QueryBuffer = IT_ALLOC(RequiredSize);

        if (!QueryBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        QueryBufferSize = RequiredSize;
        
        //
        // Don't loop forever...
        //
        
        NumTries++;

        if (NumTries >= 16) {
            ErrorCode = ERROR_INVALID_FUNCTION;
            goto cleanup;
        }

    } while (TRUE);

    //
    // We have gotten WMI disk performance data. Verify it makes sense.
    //

    DiskWmiDataCursor = QueryBuffer;
   
    if (DiskWmiDataCursor->InstanceCount == 0) {
        
        //
        // There are no disks?
        //

        ErrorCode = ERROR_BAD_FORMAT;
        goto cleanup;
    }

    //
    // Determine the number of disks we have data for.
    //

    NumDiskData = 0;

    do {

        if (DiskWmiDataCursor->WnodeHeader.BufferSize < sizeof(WNODE_ALL_DATA)) {
            IT_ASSERT(FALSE);
            ErrorCode = ERROR_BAD_FORMAT;
            goto cleanup;
        }

        DiskPerformanceData = (PDISK_PERFORMANCE) 
            ((PUCHAR) DiskWmiDataCursor + DiskWmiDataCursor->DataBlockOffset);
        
        //
        // Count only physical disk data. Otherwise we will double
        // count disk I/Os for logical disks on the physical disk.
        //

        if (ItSpIsPhysicalDrive(DiskPerformanceData)) {
            NumDiskData++;
        }
        
        if (DiskWmiDataCursor->WnodeHeader.Linkage == 0) {
            break;
        }

        DiskWmiDataCursor = (PWNODE_ALL_DATA) 
            ((LPBYTE)DiskWmiDataCursor + DiskWmiDataCursor->WnodeHeader.Linkage);

    } while (TRUE);

    //
    // Do we have enough space in the input buffer?
    //

    if (NumDiskData > *NumPhysicalDisks) {
        
        NewDataBuffer = IT_ALLOC(NumDiskData *
                                 sizeof(ITSRV_DISK_PERFORMANCE_DATA));

        if (!NewDataBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        //
        // Update old buffer & its max size.
        //
        
        if (*DiskPerfData) {
            IT_FREE(*DiskPerfData);
        }

        *DiskPerfData = NewDataBuffer;
        NewDataBuffer = NULL;
        *NumPhysicalDisks = NumDiskData;
    }

    //
    // Reset cursor and walk through the WMI data copying into the
    // target buffer.
    //

    DiskWmiDataCursor = QueryBuffer;
    *NumPhysicalDisks = 0;

    do {
        
        DiskPerformanceData = (PDISK_PERFORMANCE) 
            ((PUCHAR) DiskWmiDataCursor + DiskWmiDataCursor->DataBlockOffset);
        
        //
        // Count only physical disk data. Otherwise we will double
        // count disk I/Os for logical disks on the physical disk.
        //

        if (ItSpIsPhysicalDrive(DiskPerformanceData)) {
            
            if (*NumPhysicalDisks >= NumDiskData) {
                
                //
                // We calculated this above. Did the data change
                // beneath our feet?
                //

                IT_ASSERT(FALSE);
                ErrorCode = ERROR_INVALID_FUNCTION;
                goto cleanup;
            }
            
            //
            // Convert idle time in 100ns to ms.
            //

            // ISSUE-2002/03/26-ScottMa -- DiskPerformanceData->IdleTime
            //   could be larger than MAX_ULONG * 10000, overflowing the
            //   DiskIdleTime variable.

            (*DiskPerfData)[*NumPhysicalDisks].DiskIdleTime = 
                (ULONG) (DiskPerformanceData->IdleTime.QuadPart / 10000);
            
            (*NumPhysicalDisks)++;
        }
        
        if (DiskWmiDataCursor->WnodeHeader.Linkage == 0) {
            break;
        }

        DiskWmiDataCursor = (PWNODE_ALL_DATA) 
            ((LPBYTE)DiskWmiDataCursor + DiskWmiDataCursor->WnodeHeader.Linkage);

    } while (TRUE);

    IT_ASSERT(*NumPhysicalDisks == NumDiskData);

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    if (UsingInputBuffer) {

        //
        // Update the callers query buffer info.
        //

        *InputQueryBuffer = QueryBuffer;
        *InputQueryBufferSize = QueryBufferSize;

    } else {

        //
        // Free temporary buffer.
        //

        if (QueryBuffer) {
            IT_FREE(QueryBuffer);
        }
    }

    if (NewDataBuffer) {
        IT_FREE(NewDataBuffer);
    }

    DBGPR((ITID,ITSRVDD,"IDLE: SrvGetDiskData()=%d\n",ErrorCode));

    return ErrorCode;
}

DWORD
ItSpGetDisplayPowerStatus(
    PBOOL ScreenSaverIsRunning
    )

/*++

Routine Description:

    This routine determines power status of the default display.

Arguments:

    ScreenSaverIsRunning - Whether a screen saver is running is
      returned here.

Return Value:

    Win32 error code.

--*/  

{
    DWORD ErrorCode;
    
    //
    // Determine whether the screen saver is running.
    //

    if (!SystemParametersInfo(SPI_GETSCREENSAVERRUNNING,
                              0,
                              ScreenSaverIsRunning,
                              0)) {

        ErrorCode = GetLastError();
        goto cleanup;
    }

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    return ErrorCode;
}

BOOL
ItSpSetProcessIdleTasksNotifyRoutine (
    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE NotifyRoutine
    )

/*++

Routine Description:

    This routine is called by an internal component (prefetcher) to set a 
    notification routine that will get called if processing of all idle
    tasks are requested. The routine should be set once, and it cannot be
    removed.

Arguments:

    NotifyRoutine - Routine to be called. This routine will be called 
      and has to return before we start launching queued idle tasks. 
    
Return Value:

    Success.

--*/   

{
    BOOL Success;

    if (!ItSrvGlobalContext->ProcessIdleTasksNotifyRoutine) {
        ItSrvGlobalContext->ProcessIdleTasksNotifyRoutine = NotifyRoutine;
    }
    
    return (ItSrvGlobalContext->ProcessIdleTasksNotifyRoutine == NotifyRoutine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\server\idletsks.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idletsks.h

Abstract:

    This module contains private declarations for the idle task & detection
    server.
    
Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETSKS_H_
#define _IDLETSKS_H_

//
// Include public and common definitions.
//

#include <wmium.h>
#include <ntdddisk.h>
#include "idlrpc.h"
#include "idlecomn.h"

//
// Define the default period in ms for checking if the system is idle.
//

#define IT_DEFAULT_IDLE_DETECTION_PERIOD    (12 * 60 * 1000) // 12 minutes.

//
// If the system has been idle over the idle detection period, we
// verify that it is really idle by checking frequently over a shorter
// period for a number of times. This helps us know when there were
// 100 disk I/O's in the last second of idle detection period, but
// over 15 minutes it does not look a lot.
//

#define IT_DEFAULT_IDLE_VERIFICATION_PERIOD (30 * 1000)      // 30 seconds.
#define IT_DEFAULT_NUM_IDLE_VERIFICATIONS   5                // 5 times.

//
// We will be polling for user input when running idle tasks every
// this many ms. We want to catch user input and notify the idle task
// to stop running as soon as possible. Even though the system is
// idle, we don't want to create too much overhead which may mislead
// ourself.
//

#define IT_DEFAULT_IDLE_USER_INPUT_CHECK_PERIOD     250      // 4 times a sec. 

// FUTURE-2002/03/26-ScottMa -- The constant (below) is not used, except
//   to initialize the [unused] IdleTaskRunningCheckPeriod parameter.

//
// We check to see if the idle task we asked to run is really running
// (i.e. it is using the disk and CPU) every this many ms. This is our
// mechanism for cleaning up after unregistered/orphaned tasks. This
// should be greater than IT_USER_INPUT_POLL_PERIOD_WHEN_IDLE.
//

#define IT_DEFAULT_IDLE_TASK_RUNNING_CHECK_PERIOD   (5 * 60 * 1000) // 5 min.

//
// If the CPU is not idle more than this percent over a time interval,
// the system is not considered idle.
//

#define IT_DEFAULT_MIN_CPU_IDLE_PERCENTAGE          90

//
// If a disk is not idle more than this percent over a time interval,
// the system is not considered idle.
//

#define IT_DEFAULT_MIN_DISK_IDLE_PERCENTAGE         90

//
// We will not try to run our tasks if there is only this many seconds
// left before the system will enter hibernate or standby automatically.
// Note that the time remaining is updated every so many seconds (e.g. 
// 15) so this number should not be very small.
//

// FUTURE-2002/03/26-ScottMa -- This constant doesn't have a corresponding
//   parameter in the IT_IDLE_DETECTION_PARAMETERS structure.  Should it
//   be added to the structure like the others?

#define IT_DEFAULT_MAX_TIME_REMAINING_TO_SLEEP      60

//
// This is the maximum number of registered idle tasks. This is a
// sanity check. It also protects against evil callers.
//

#define IT_DEFAULT_MAX_REGISTERED_TASKS             512

//
// We set timer period for idle detection callback to this while the
// callback is running to prevent new callbacks from firing. We end up
// having to do this because you cannot requeue/change a timer for
// which you don't specify a period. If a callback fires while another
// one is already running, it simply returns without doing anything.
//

#define IT_VERYLONG_TIMER_PERIOD                    0x7FFFFFFF

//
// This is the number of recent server statuses that we keep track
// of. Do not make this number smaller without revisiting the logic &
// code that uses the LastStatus history.
//

#define ITSRV_GLOBAL_STATUS_HISTORY_SIZE            8

//
// Hints for the number of outstanding RPC call-ins we will have.
//

#define ITSRV_RPC_MIN_CALLS                         1
#define ITSRV_RPC_MAX_CALLS                         1

//
// Define useful macros.
//

#define IT_ALLOC(NumBytes)          (HeapAlloc(GetProcessHeap(),0,(NumBytes)))
#define IT_FREE(Buffer)             (HeapFree(GetProcessHeap(),0,(Buffer)))

//
// These macros are used to acquire/release a mutex.
//

#define IT_ACQUIRE_LOCK(Lock)                                                         \
    WaitForSingleObject((Lock), INFINITE);                                            \

#define IT_RELEASE_LOCK(Lock)                                                         \
    ReleaseMutex((Lock));                                                             \

//
// This macro is used in the idle detection callback (while holding
// the global lock of the input global context) to determine if the
// idle detection callback should just exit/go away.
//

#define ITSP_SHOULD_STOP_IDLE_DETECTION(GlobalContext)                       \
    ((GlobalContext->Status == ItSrvStatusStoppingIdleDetection) ||          \
     (GlobalContext->Status == ItSrvStatusUninitializing))                   \

//
// Status of a server global context. It also acts as a magic to
// identify/verify the global context, as it starts from Df00. There
// is not a full-blown state machine, although the state is used as a
// critical hint for making decisions when registering an idle
// task. This is more for informative and verification purposes. If
// you add a new status without updating everything that needs to be
// updated, you may hit several asserts, especially in the idle
// detection callback. Frankly, don't add a new state without a very
// good reason.
//

typedef enum _ITSRV_GLOBAL_CONTEXT_STATUS {
    ItSrvStatusMinStatus                = 'Df00',
    ItSrvStatusInitializing,
    ItSrvStatusWaitingForIdleTasks,
    ItSrvStatusDetectingIdle,
    ItSrvStatusRunningIdleTasks,
    ItSrvStatusStoppingIdleDetection,
    ItSrvStatusUninitializing,
    ItSrvStatusUninitialized,
    ItSrvStatusMaxStatus
} ITSRV_GLOBAL_CONTEXT_STATUS, *PITSRV_GLOBAL_CONTEXT_STATUS;

//
// These are the various types of idle detection overrides. Multiple
// overrides can be specified by OR'ing them (i.e. these are bits!)
//
// If you are adding an override here, check whether you need to specify
// it when force-processing all idle tasks.
//

typedef enum _ITSRV_IDLE_DETECTION_OVERRIDE {
    
    ItSrvOverrideIdleDetection                      = 0x00000001,
    ItSrvOverrideIdleVerification                   = 0x00000002,
    ItSrvOverrideUserInputCheckToStopTask           = 0x00000004,
    // FUTURE-2002/03/26-ScottMa -- The ItSrvOverrideTaskRunningCheck value
    //   is never used, presumably because some code was removed.
    ItSrvOverrideTaskRunningCheck                   = 0x00000008,
    ItSrvOverridePostTaskIdleCheck                  = 0x00000010,
    ItSrvOverrideLongRequeueTime                    = 0x00000020,
    ItSrvOverrideBatteryCheckToStopTask             = 0x00000040,
    ItSrvOverrideAutoPowerCheckToStopTask           = 0x00000080,

} ITSRV_IDLE_DETECTION_OVERRIDE, *PITSRV_IDLE_DETECTION_OVERRIDE;

//
// These are the various reasons why ItSpIsSystemIdle function may be
// called.
//

// FUTURE-2002/03/26-ScottMa -- The ItSrvIdleTaskRunningCheck is never passed
//   to the ItSpIsSystemIdle function, presumably because the call was removed.
//   to initialize the [unused] IdleTaskRunningCheckPeriod parameter.  Further,
//   there is no difference between the other two reasons -- is it needed?

typedef enum _ITSRV_IDLE_CHECK_REASON {

    ItSrvInitialIdleCheck,
    ItSrvIdleVerificationCheck,
    ItSrvIdleTaskRunningCheck,
    ItSrvMaxIdleCheckReason

}ITSRV_IDLE_CHECK_REASON, *PITSRV_IDLE_CHECK_REASON;

//
// This structure is used to keep context for a registered task for
// the server.
//

typedef struct _ITSRV_IDLE_TASK_CONTEXT {

    //
    // Link in the list of idle tasks.
    //

    LIST_ENTRY IdleTaskLink;

    //
    // Status of the idle task.
    //

    IT_IDLE_TASK_STATUS Status;

    //
    // Idle task properties the client specified.
    //

    IT_IDLE_TASK_PROPERTIES Properties;

    //
    // Event to be notified when the task should start running
    // (e.g. the system is idle).
    //

    HANDLE StartEvent;

    //
    // Event to be notified when the task should stop running.
    //
   
    HANDLE StopEvent;

} ITSRV_IDLE_TASK_CONTEXT, *PITSRV_IDLE_TASK_CONTEXT;

//
// This structure contains disk performance information we are
// interested in.
//

typedef struct _ITSRV_DISK_PERFORMANCE_DATA {
    
    //
    // How long the disk was idle in ms.
    //

    ULONG DiskIdleTime;

} ITSRV_DISK_PERFORMANCE_DATA, *PITSRV_DISK_PERFORMANCE_DATA;

//
// Define structure to contain system resource information & state at
// a specific time.
//

typedef struct _ITSRV_SYSTEM_SNAPSHOT {

    //
    // When this snapshot was taken, in ms elapsed since system was
    // started (i.e. GetTickCount)
    //

    DWORD SnapshotTime;

    //
    // Whether we were able to get the specified data in this snapshot.
    //

    ULONG GotLastInputInfo:1;
    ULONG GotSystemPerformanceInfo:1;
    ULONG GotDiskPerformanceInfo:1;
    ULONG GotSystemPowerStatus:1;
    ULONG GotSystemPowerInfo:1;
    ULONG GotSystemExecutionState:1;
    ULONG GotDisplayPowerStatus:1;

    //
    // This is when the last user input happened before the snapshot
    // was taken.
    //

    LASTINPUTINFO LastInputInfo;

    //
    // System performance information when the snapshot was taken.
    //

    SYSTEM_PERFORMANCE_INFORMATION SystemPerformanceInfo;

    //
    // Disk performance data on registered harddisks when the snapshot
    // was taken.
    //

    ULONG NumPhysicalDisks;
    ITSRV_DISK_PERFORMANCE_DATA *DiskPerfData;
    
    //
    // System power status (e.g. are we running on battery etc.)
    //
    
    SYSTEM_POWER_STATUS SystemPowerStatus;

    //
    // System power information (e.g. how long till system turns itself
    // off & goes to sleep.)
    //
    
    SYSTEM_POWER_INFORMATION PowerInfo;

    //
    // System execution state (e.g. is somebody running a presentation?)
    //

    EXECUTION_STATE ExecutionState;

    //
    // Whether the screen saver is running.
    //

    BOOL ScreenSaverIsRunning;

} ITSRV_SYSTEM_SNAPSHOT, *PITSRV_SYSTEM_SNAPSHOT;

//
// Type for the routine that is called to notify that forced processing of 
// idle tasks have been requested.
//

typedef VOID (*PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE)(VOID);

//
// Define structure to contain server global context for idle
// detection and keeping track of registered idle tasks.
//

typedef struct _ITSRV_GLOBAL_CONTEXT {

    //
    // Status of the server and its history, LastStatus[0] being the
    // most recent. The status version is incremented each time the
    // status is updated.
    //
    
    ITSRV_GLOBAL_CONTEXT_STATUS Status;
    ITSRV_GLOBAL_CONTEXT_STATUS LastStatus[ITSRV_GLOBAL_STATUS_HISTORY_SIZE];
    LONG StatusVersion;

    //
    // Nearly all operations involve the idle tasks list and instead
    // of having a lock for the list and seperate synchronization
    // mechanisms for other operations on the structure, we have a
    // single global lock to make life simpler.
    //

    HANDLE GlobalLock;

    //
    // This is the list and number of idle tasks that have been
    // scheduled.
    //

    LIST_ENTRY IdleTasksList;
    ULONG NumIdleTasks;

    //
    // Handle to the timer queue timer that is used to periodically
    // check for system idleness.
    //

    HANDLE IdleDetectionTimerHandle;

    //
    // This manual reset event gets signaled when idle detection
    // should stop (e.g. because there are no more idle tasks, the
    // server is shutting down etc.) It signals a running idle
    // detection callback to quickly exit.
    //

    HANDLE StopIdleDetection;

    //
    // This manual reset event gets signaled when idle detection has
    // fully stopped (i.e. no callback is running, the timer is not in
    // the queue etc.
    //

    HANDLE IdleDetectionStopped;

    //
    // This manual reset event is signaled when an idle task that was
    // running is unregistered/removed. This would happen usually
    // after an idle task that was told to run completes and has no
    // more to do. It unregisters itself, and this event is set to
    // notify the idle detection callback to move on to other idle
    // tasks.
    //

    HANDLE RemovedRunningIdleTask;

    // FUTURE-2002/03/26-ScottMa -- The field (below) is never used as an
    //   L-value, except in the [unused] ItSpSetProcessIdleTasksNotifyRoutine
    //   function.

    //
    // If it is set, this routine is called to notify that 
    // forced processing of idle tasks have been requested.
    //

    PIT_PROCESS_IDLE_TASKS_NOTIFY_ROUTINE ProcessIdleTasksNotifyRoutine;

    //
    // These are the parameters that control idle detection.
    //

    IT_IDLE_DETECTION_PARAMETERS Parameters;

    //
    // This is the WMI handle used in disk performance queries.
    //

    WMIHANDLE DiskPerfWmiHandle;

    //
    // Number of processors on the system. Used to calculate CPU
    // utilization.
    //

    UCHAR NumProcessors; 

    //
    // This buffer is used to make Wmi queries. It is maintained here
    // so we don't have to allocate a new one each time.
    //

    PVOID WmiQueryBuffer;
    ULONG WmiQueryBufferSize;

    //
    // The last system resource / activity snapshot we took.
    //

    // FUTURE-2002/03/26-ScottMa -- Adding the CurrentSystemSnapshot to the
    //   global context would remove the need to repeatedly initialize and
    //   cleanup the stack variable in the ItSpIdleDetectionCallbackRoutine.
    //   Since the calls to that function are already protected against
    //   re-entrancy issues, adding it to the global context is safe.

    ITSRV_SYSTEM_SNAPSHOT LastSystemSnapshot;

    //
    // Is an idle detection callback already running? This is used to
    // protect us from idle detection callbacks being fired while
    // there is already one active.
    //

    BOOLEAN IsIdleDetectionCallbackRunning;

    //
    // Various phases of idle detection can be overriden by setting
    // this.
    //

    ITSRV_IDLE_DETECTION_OVERRIDE IdleDetectionOverride;

    //
    // RPC binding vector used to register ourselves in the local
    // endpoint-map database.
    //

    RPC_BINDING_VECTOR *RpcBindingVector;

    //
    // Whether we actually registered our endpoint and interface.
    //

    BOOLEAN RegisteredRPCEndpoint;
    BOOLEAN RegisteredRPCInterface;

} ITSRV_GLOBAL_CONTEXT, *PITSRV_GLOBAL_CONTEXT;

//
// Server function declarations. They should be only used by the
// server host and the client functions.
//

DWORD
ItSrvInitialize (
    VOID
    );

VOID
ItSrvUninitialize (
    VOID
    );

//
// Local support function prototypes for the server.
//

RPC_STATUS 
RPC_ENTRY 
ItSpRpcSecurityCallback (
    IN RPC_IF_HANDLE *Interface,
    IN PVOID Context
    );
   
VOID
ItSpUnregisterIdleTask (
    ITRPC_HANDLE Reserved,
    IT_HANDLE *ItHandle,
    BOOLEAN CalledInternally
    );

VOID
ItSpUpdateStatus (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    ITSRV_GLOBAL_CONTEXT_STATUS NewStatus
    );

VOID
ItSpCleanupGlobalContext (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

VOID
ItSpCleanupIdleTask (
    PITSRV_IDLE_TASK_CONTEXT IdleTask
    );

ULONG
ItpVerifyIdleTaskProperties (
    PIT_IDLE_TASK_PROPERTIES IdleTaskProperties
    );

DWORD
ItSpStartIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

VOID
ItSpStopIdleDetection (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

VOID 
CALLBACK
ItSpIdleDetectionCallbackRoutine (
    PVOID Parameter,
    BOOLEAN TimerOrWaitFired
    );

PITSRV_IDLE_TASK_CONTEXT
ItSpFindRunningIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext
    );

PITSRV_IDLE_TASK_CONTEXT
ItSpFindIdleTask (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    IT_HANDLE ItHandle
    );

VOID
ItSpInitializeSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    );

VOID
ItSpCleanupSystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    );

DWORD
ItSpCopySystemSnapshot (
    PITSRV_SYSTEM_SNAPSHOT DestSnapshot,
    PITSRV_SYSTEM_SNAPSHOT SourceSnapshot
    );

DWORD
ItSpGetSystemSnapshot (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT SystemSnapshot
    );

// FUTURE-2002/03/26-ScottMa -- If the CurrentSystemSnapshot is added to the
//   global context, both parameters no longer need to be passed to this
//   function.  It is only called from within ItSpIdleDetectionCallbackRoutine,
//   and always uses the same values for current & last snapshot.

BOOLEAN
ItSpIsSystemIdle (
    PITSRV_GLOBAL_CONTEXT GlobalContext,
    PITSRV_SYSTEM_SNAPSHOT CurrentSnapshot,
    PITSRV_SYSTEM_SNAPSHOT LastSnapshot,
    ITSRV_IDLE_CHECK_REASON IdleCheckReason
    );

DWORD
ItSpGetLastInputInfo (
    PLASTINPUTINFO LastInputInfo
    );

DWORD
ItSpGetWmiDiskPerformanceData(
    IN WMIHANDLE DiskPerfWmiHandle,
    OUT PITSRV_DISK_PERFORMANCE_DATA *DiskPerfData,
    OUT ULONG *NumPhysicalDisks,
    OPTIONAL IN OUT PVOID *InputQueryBuffer,
    OPTIONAL IN OUT ULONG *InputQueryBufferSize
    );

BOOLEAN
ItSpIsPhysicalDrive (
    PDISK_PERFORMANCE DiskPerformanceData
    );

DWORD
ItSpGetDisplayPowerStatus(
    PBOOL ScreenSaverIsRunning
    );

#endif // _IDLETSKS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\inc\job-ids.h ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job-ids.hxx
//
//  Contents:   Property/Dispatch and other Job Scheduler IDs
//
//  History:    23-May-95 EricB created
//
//-----------------------------------------------------------------------------

// oleext.h used to define PROPID_FIRST_NAME_DEFAULT to be 4095; it doesn't
// anymore...
//#include <oleext.h>
#ifndef PROPID_FIRST_NAME_DEFAULT
#define PROPID_FIRST_NAME_DEFAULT   ( 4095 )
#endif

//
// Job object propterty set IDs/Dispatch IDs
//
#define PROPID_JOB_ID                PROPID_FIRST_NAME_DEFAULT
#define PROPID_JOB_Command          (PROPID_FIRST_NAME_DEFAULT + 1)
#define PROPID_JOB_WorkingDir       (PROPID_FIRST_NAME_DEFAULT + 2)
#define PROPID_JOB_EnvironStrs      (PROPID_FIRST_NAME_DEFAULT + 3)
#define PROPID_JOB_OleObjPath       (PROPID_FIRST_NAME_DEFAULT + 4)
#define PROPID_JOB_MethodName       (PROPID_FIRST_NAME_DEFAULT + 5)
#define PROPID_JOB_AccountSID       (PROPID_FIRST_NAME_DEFAULT + 6)
#define PROPID_JOB_Comment          (PROPID_FIRST_NAME_DEFAULT + 7)
#define PROPID_JOB_Priority         (PROPID_FIRST_NAME_DEFAULT + 8)
#define PROPID_JOB_LogCfgChanges    (PROPID_FIRST_NAME_DEFAULT + 9)
#define PROPID_JOB_LogRuns          (PROPID_FIRST_NAME_DEFAULT + 10)
#define PROPID_JOB_Interactive      (PROPID_FIRST_NAME_DEFAULT + 11)
#define PROPID_JOB_NotOnBattery     (PROPID_FIRST_NAME_DEFAULT + 12)
#define PROPID_JOB_NetSchedule      (PROPID_FIRST_NAME_DEFAULT + 13)
#define PROPID_JOB_InQueue          (PROPID_FIRST_NAME_DEFAULT + 14)
#define PROPID_JOB_Suspend          (PROPID_FIRST_NAME_DEFAULT + 15)
#define PROPID_JOB_DeleteWhenDone   (PROPID_FIRST_NAME_DEFAULT + 16)
#define PROPID_JOB_LastRunTime      (PROPID_FIRST_NAME_DEFAULT + 17)
#define PROPID_JOB_NextRunTime      (PROPID_FIRST_NAME_DEFAULT + 18)
#define PROPID_JOB_ExitCode         (PROPID_FIRST_NAME_DEFAULT + 19)
#define PROPID_JOB_Status           (PROPID_FIRST_NAME_DEFAULT + 20)

//
// Job object property set boundary values
//
#define PROPID_JOB_First             PROPID_JOB_ID
#define PROPID_JOB_Last              PROPID_JOB_Status
#define NUM_JOB_PROPS               (PROPID_JOB_Last - PROPID_JOB_First + 1)
#define JOB_PROP_IDX(x)             (x - PROPID_FIRST_NAME_DEFAULT)

//
// Version property set IDs
//
#define PROPID_VERSION_Major		(PROPID_FIRST_NAME_DEFAULT + 100)
#define PROPID_VERSION_Minor		(PROPID_FIRST_NAME_DEFAULT + 101)

//
// Version property set boundary values
//
#define NUM_VERSION_PROPS			2
#define VERSION_PROP_MAJOR			0
#define VERSION_PROP_MINOR			1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\test\itsrv\itsrv.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    itsrv.c

Abstract:

    This module builds a console test program that registers RPC
    interfaces for idle detection and runs as the idle detection server.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include "idlrpc.h"
#include "idlesrv.h"

//
// Note that the following code is test quality code.
//

HANDLE ItTstStopEvent = NULL;

BOOL
ItTstConsoleHandler(DWORD dwControl)
{
    if (ItTstStopEvent) {
        SetEvent(ItTstStopEvent);
    }

    return TRUE;
}

VOID
LogTaskStatus(
    LPCTSTR ptszTaskName,
    LPTSTR  ptszTaskTarget,
    UINT    uMsgID,
    DWORD   dwExitCode
    )
{
    return;
}

int 
__cdecl 
main(int argc, char* argv[])
{
    DWORD ErrorCode;
    DWORD WaitResult;
    BOOLEAN StartedIdleDetectionServer;

    //
    // Initialize locals.
    //
    
    StartedIdleDetectionServer = FALSE;

    //
    // Create the event to be signaled when we should stop.
    //

    ItTstStopEvent = CreateEvent (NULL,
                                  TRUE,
                                  FALSE,
                                  NULL);

    if (ItTstStopEvent == NULL) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // Specify Control-C handler.
    //

    SetConsoleCtrlHandler(ItTstConsoleHandler, TRUE);

    //
    // Specify which protocol sequences to use. (just LPC)
    //

    ErrorCode = RpcServerUseProtseq(IT_RPC_PROTSEQ,
                                    256,
                                    NULL);

    if (ErrorCode != RPC_S_OK) {
        goto cleanup;
    }

    //
    // Start the idle detection server.
    //

    ErrorCode = ItSrvInitialize();

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    StartedIdleDetectionServer = TRUE;

    printf("Started idle detection server...\n");

    //
    // Wait for the exit event to be signaled.
    //
    
    WaitResult = WaitForSingleObject(ItTstStopEvent, INFINITE);
    
    if (WaitResult != WAIT_OBJECT_0) {
        ErrorCode = GetLastError();
        goto cleanup;
    }

    //
    // We are done.
    //

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    if (StartedIdleDetectionServer) {
        ItSrvUninitialize();
    }
    
    if (ItTstStopEvent) {
        CloseHandle(ItTstStopEvent);
    }

    printf("Exiting idle detection server with error code: %d\n", ErrorCode);

    return ErrorCode;
}

/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(HeapAlloc(GetProcessHeap(),0,(len)));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    HeapFree(GetProcessHeap(),0,(ptr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\guids.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       guids.cxx
//
//  Contents:   guid allocations - guids are defined in mstask.h
//
//  History:    24-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop

//#include <windows.h>

// initguid.h requires this.
//
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>

//
// mstask.h contains the GUID
// definitions in DEFINE_GUID macros. initguid.h causes the DEFINE_GUID
// definitions to actually allocate data.
//
#include <mstask.h>
#include <job_cls.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\inc\resource.h ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Object Handler
//
//	Microsoft Windows
//	Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       resource.h
//
//  Contents:   resource IDs
//
//	History:	23-May-95 EricB created
//
//-----------------------------------------------------------------------------

#ifndef __RESOURCE_H__
#define __RESOURCE_H__

#define IDI_JOBSFLD                         100
#define IDI_JOB                             101
#define IDI_QUEUE                           102
#define IDI_SCHEDULER                       103

// string IDs

#define IDS_STATUS_WAITING				    0
#define IDS_STATUS_RUNNING				    1
#define IDS_STATUS_SUSPENDED			    2
#define IDS_STATUS_ABORTED				    3
#define IDS_STATUS_NEVER_RUN			    4
#define IDS_STATUS_ERROR_CANT_RUN		    5
#define IDS_STATUS_ERROR_FROM_RUN		    6
// note that 0x20 through 0x100 are reserved for the priority class strings
#define IDS_MULTIPLE_SELECTED               1034
#define IDS_DAILY                           1067
#define IDS_WEEKLY                          1068
#define IDS_MONTHLY                         1069
#define IDS_EVERY                           1070
#define IDS_EVERYOTHER                      1071
#define IDS_EVERY3RD                        1072
#define IDS_EVERY4TH                        1073
#define IDS_EVERY5TH                        1074
#define IDS_EVERY6TH                        1075
#define IDS_EVERY12TH                       1076
#define IDS_HOURS                           1077
#define IDS_MINUTES                         1078
#define IDS_FIRST                           1079
#define IDS_SECOND                          1080
#define IDS_THIRD                           1081
#define IDS_LAST                            1083
#define IDS_FORTH                           1082
#define IDS_DAY                             1084
#define IDS_SCHEDULER_NAME                  1085
#define IDS_IDLE_TRIGGER                    1090
#define IDS_STARTUP_TRIGGER                 1091
#define IDS_RESUME_TRIGGER                  1092
#define IDS_ONCE_DAY_FORMAT                 1093
#define IDS_MULTI_DAILY_FORMAT              1094
#define IDS_HAS_END_DATE_FORMAT             1095
#define IDS_NO_END_DATE_FORMAT              1096
#define IDS_HOURS_PAREN                     1097
#define IDS_MINUTES_PAREN                   1098
#define IDS_NETSCHED_COMMENT                1099
#define IDS_LOG_SEVERITY_WARNING            1100
#define IDS_LOG_SEVERITY_ERROR              1101
#define IDS_LOG_JOB_STATUS_STARTED          1102
#define IDS_LOG_JOB_STATUS_FINISHED         1103
#define IDS_LOG_JOB_STATUS_STARTED_NO_STOP  1104
#define IDS_LOG_JOB_ERROR_FAILED_START      1105
#define IDS_LOG_JOB_RESULT_FINISHED         1106
//#define           1107
//#define             1108
#define IDS_LOG_JOB_EXIT_CODE_MSG_NOT_FOUND 1109
#define IDS_RUNS_ONCE_FORMAT                1110
#define IDS_DAILY_FORMAT                    1111
#define IDS_EVERY_DAY                       1112
#define IDS_LIST_SEP                        1113
#define IDS_EVERY_WEEK_FORMAT               1114
#define IDS_WEEKLY_FORMAT                   1115
#define IDS_EVERY_MONTHLYDATE_FORMAT        1116
#define IDS_MONTHLYDATE_FORMAT              1117
#define IDS_EVERY_MONTHLYDOW_FORMAT         1118
#define IDS_MONTHLYDOW_FORMAT               1119
#define IDS_YEARLYDATE_FORMAT               1120
#define IDS_YEARLYDOW_FORMAT                1121
#define IDS_MULTI_DURATION_FORMAT           1122
#define IDS_TRIGGER_NOT_SET                 1123
#define IDS_EVERY_MONTHLYDATE_FORMAT_ETC    1124
#define IDS_MONTHLYDATE_FORMAT_ETC          1125
#define IDS_ERRMSG_PREFIX                   1126
#define IDS_NOT_FROM_CMD_LINE               1127
#define IDS_ONE_INSTANCE                    1128
#define IDS_BUILD_VERSION                   1129
#define IDS_LOGON_TRIGGER                   1130
#define IDS_LOG_JOB_WARNING_BAD_DIR         1131
#define IDS_LOG_JOB_WARNING_NOT_IDLE        1132
#define IDS_LOG_JOB_WARNING_ON_BATTERIES    1133
#define IDS_LOG_SERVICE_ERROR               1134
#define IDS_HELP_HINT_SEC_WRITE             1135
#define IDS_LOG_SERVICE_TITLE               1136
#define IDS_LOG_SERVICE_STARTED             1137
#define IDS_LOG_SERVICE_EXITED              1138
#define IDS_CRITICAL_ERROR                  1139
#define IDS_HELP_HINT_BADDIR                1141
#define IDS_LOG_JOB_WARNING_ABORTED         1142
#define IDS_LOG_JOB_WARNING_TIMEOUT         1143
#define IDS_LOG_EXIT_CODE_MSG_NOT_FOUND     1144
#define IDS_ERROR_FORMAT_WCODE_WHELP_I      1145
#define IDS_ERROR_FORMAT_WCODE_WOHELP_I     1146
#define IDS_ERROR_FORMAT_WOCODE_WHELP_I     1147
#define IDS_ERROR_FORMAT_WOCODE_WOHELP_I    1148
#define IDS_ERROR_FORMAT_WCODE_WHELP        1149
#define IDS_ERROR_FORMAT_WCODE_WOHELP       1150
#define IDS_ERROR_FORMAT_WOCODE_WHELP       1151
#define IDS_ERROR_FORMAT_WOCODE_WOHELP      1152
#define IDS_ERROR_NUMBER_FORMAT             1153
#define IDS_GENERIC_ERROR_MSG               1154
#define IDS_HELP_HINT_BROWSE                1155
#define IDS_HELP_HINT_LOGON                 1156
#define IDS_ACCOUNT_LOGON_FAILED            1157
#define IDS_NS_ACCOUNT_LOGON_FAILED         1158
#define IDS_FILE_ACCESS_DENIED              1159
#define IDS_FILE_ACCESS_DENIED_HINT         1160
#define IDS_FAILED_ACCOUNT_RETRIEVAL        1161
#define IDS_FAILED_NS_ACCOUNT_RETRIEVAL     1162
#define IDS_INITIALIZATION_FAILURE          1163
#define IDS_FATAL_ERROR                     1164
#define IDS_NON_FATAL_ERROR                 1165
#define IDS_HELP_HINT_REINSTALL             1166
#define IDS_HELP_HINT_RESTARTWINDOWS        1167
#define IDS_HELP_HINT_CALLPSS               1168
#define IDS_HELP_HINT_CLOSE_APPS            1169
#define IDS_HELP_HINT_TIMEOUT               1170
#define IDS_LOG_JOB_WARNING_CANNOT_LOAD     1171
#define IDS_CANT_GET_EXITCODE               1172
#define IDS_CANT_DELETE_JOB                 1173
#define IDS_CANT_UPDATE_JOB                 1174
#define IDS_HELP_HINT_STARTSVC              1175
#define IDS_LOG_SERVICE_PAUSED              1176
#define IDS_LOG_SERVICE_CONTINUED           1177
#define IDS_LOG_RUNS_MISSED                 1178
#define IDS_POPUP_RUNS_MISSED               1179
#define IDS_POPUP_SERVICE_TITLE             1180

#define IDS_NEW_JOB                         3330
#define IDS_NEW_QUEUE                       3331
#define IDS_WHEN_IDLE                       3332
#define IDS_MOSTRECENTLOGENTRYMARKER        3333

#define IERR_SECURITY_WRITE_ERROR           3400
#define IERR_SECURITY_DBASE_CORRUPTION      3401
#define IDS_HELP_HINT_INVALID_ACCT          3402
#define IDS_HELP_HINT_DBASE_CORRUPT         3403
#define IDS_HELP_HINT_ACCESS_DENIED         3404
#define IDS_HELP_HINT_SEC_GENERAL           3405
#define IDS_HELP_HINT_PARAMETERS            3406

#define IDS_Friendly_Name		    3407
#define IDS_LOCALIZED_NAME		    3408

#define IERR_SECURITY_KEYSET_CORRUPT		3409

#endif  // __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\test\winidle\winidle.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    winidle.c

Abstract:

    This module builds a gui test program for the idle detection which
    pops up a window and uses CPU to simulate a running idle task when
    the system becomes idle.

    The test programs are built from the same sources as the original. This
    allows the test program to override parts of the original program to run
    it in a managed environment, and be able to test individual functions. 

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wmium.h>
#include <ntdddisk.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "idlrpc.h"
#include "idlecomn.h"

//
// This is mostly based on DavidFie's original IdleInfo application.
//

//
// Note that this code is written for a test app, and is of that
// quality.
//

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    );

WCHAR *WinIdleUsage = 
L"Usage: winidle [options]                                                  \n"
L"Options:                                                                  \n"
L"    -wintimeout=x Sets how long notification window takes to go away.     \n"
L"    -logtrace     Will write a trace-log to c:\\idledbg.txt.              \n"
L"    -stressparams Sets idle detection defaults for the above to small     \n"
L"                  values so you can make sure it is working. These can    \n"
L"                  still be overriden by setting the above parameters.     \n"
L"StressParams OVERRIDES: To be used only if -stressparams is specified     \n"
L"    -period=x     Sets idle detection period to x ms.                     \n"
L"    -vperiod=x    Sets idle detection verification period to x ms.        \n"
L"    -vnum=x       Idle is verified over x verification periods.           \n"
L"    -taskcheck=x  Sets idle-task-running check to x ms.                   \n"
L"    -mincpu=x     Sets min cpu percentage at which system can be idle.    \n"
L"    -mindisk=x    Sets min disk percentage at which system can be idle.   \n"
;

#define DBGPRNT(x)       FileDbgPrintEx x

FILE *WinIdleDbgFile = NULL;
BOOLEAN WinIdleLogToFile = FALSE;

ULONG
_cdecl
FileDbgPrintEx(
    IN PCH Format,
    ...
    )
{
    va_list args;

    if (!WinIdleLogToFile) {
        return 0;
    }

    if (!WinIdleDbgFile) {
        char CurTime[20];
        char CurDate[20];

        WinIdleDbgFile = fopen("c:\\idledbg.txt", "a+");
        
        if (!WinIdleDbgFile) {
            return 0;
        }
        
        if (setvbuf(WinIdleDbgFile, NULL, _IONBF, 0)) {
            return 0;
        }
        
        _strtime(CurTime);
        _strdate(CurDate);
        
        fprintf(WinIdleDbgFile, ">>>>>> STARTING NEW LOG AT %s %s <<<<<<\n", 
                CurTime, CurDate);
    }

    va_start(args, Format);
    
    vfprintf(WinIdleDbgFile, Format, args);
    
    va_end(args);

    return 0;
}

#define II_POPUP_WIDTH                   300
#define II_POPUP_HEIGHT                  60
#define II_APPNAME                       L"IdleInfo"
#define II_MAINWINDOW_CLASSNAME          L"IdleInfoMainClass"

HINSTANCE IiInstance = NULL;
HWND IiMainWindow = NULL;

WCHAR *IiMessageStrings[] = {
    L"Running idle task.",
    L"No longer idle!",
};

#define II_MSG_RUNNING 0
#define II_MSG_NOTIDLE 1

ULONG IiCurrentMessageIdx = 0;

LRESULT
CALLBACK
IiMainWndProc(
    HWND hWnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HDC hDc;
    PAINTSTRUCT Paint;
    RECT Rect;
    static HWND Button;
    static LONG CharHeight;

    switch (uMsg) {
        
    case WM_CLOSE:
        PostQuitMessage (0);
        return 0;

    case WM_PAINT:
        hDc = BeginPaint(hWnd, &Paint);
        GetClientRect(hWnd, &Rect);

        Rect.top += CharHeight / 2;
        DrawText(hDc,
                 IiMessageStrings[IiCurrentMessageIdx],
                 -1,
                 &Rect,
                 DT_SINGLELINE | DT_CENTER | DT_VCENTER);

        EndPaint(hWnd, &Paint);
        return 0;

    case WM_TIMER:
        ShowWindow(IiMainWindow, SW_HIDE);
        return 0;

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

HWND
IiInit(
    HINSTANCE Instance
    )
{
    DWORD ErrorCode;
    WNDCLASSEX WindowClass;
    LONG WindowHeight;

    WindowClass.cbSize = sizeof(WNDCLASSEX);
    WindowClass.style = CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW;
    WindowClass.lpfnWndProc = IiMainWndProc;
    WindowClass.cbClsExtra = 0;
    WindowClass.cbWndExtra = 0;
    WindowClass.hInstance = Instance;
    WindowClass.hIcon = LoadIcon(NULL, IDI_INFORMATION);
    WindowClass.hCursor = LoadCursor(NULL, IDC_ARROW);
    WindowClass.hbrBackground =  (HBRUSH)(COLOR_WINDOW + 1);
    WindowClass.lpszMenuName = NULL;
    WindowClass.lpszClassName = II_MAINWINDOW_CLASSNAME;
    WindowClass.hIconSm = LoadIcon(NULL, IDI_INFORMATION);

    if (!RegisterClassEx(&WindowClass)) {
        return NULL;
    }

    WindowHeight = II_POPUP_HEIGHT +
        GetSystemMetrics(SM_CYCAPTION) +
        GetSystemMetrics(SM_CYFIXEDFRAME) +
        GetSystemMetrics(SM_CYEDGE);

    return CreateWindowEx(
        WS_EX_TOPMOST | WS_EX_OVERLAPPEDWINDOW,
        II_MAINWINDOW_CLASSNAME,
        II_APPNAME,
        WS_SYSMENU,
        (GetSystemMetrics(SM_CXSCREEN) - II_POPUP_WIDTH) / 2,
        (GetSystemMetrics(SM_CYSCREEN) - WindowHeight) / 2,
        II_POPUP_WIDTH,
        WindowHeight,
        NULL,
        NULL,
        Instance,
        NULL);
}

DWORD
RunIdleTask(
    HANDLE StopEvent,
    BOOLEAN *ShouldExitApp
    )
{
    DWORD EndTime;
    DWORD ErrorCode;
    DWORD WaitResult;
    MSG Msg;
    
    //
    // Initialize locals.
    //

    *ShouldExitApp = FALSE;

    DBGPRNT(("WIN: RunIdleTask()\n"));

    while (TRUE) {
        
        WaitResult = MsgWaitForMultipleObjects (1,
                                                &StopEvent,
                                                FALSE,
                                                0,
                                                QS_ALLEVENTS|QS_ALLINPUT);
        
        switch (WaitResult) {
            
        case WAIT_OBJECT_0:
            
            DBGPRNT(("WIN: RunIdleTask-StopEvent\n"));
            
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;

            break;

        case WAIT_OBJECT_0 + 1:

            DBGPRNT(("WIN: RunIdleTask-WindowMessage\n"));

            if (PeekMessage (&Msg, NULL, 0, 0, PM_REMOVE)) {

                if (Msg.message == WM_QUIT) {
                    *ShouldExitApp = TRUE;
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
                
                TranslateMessage (&Msg);
                DispatchMessage (&Msg);
            }
            
            break;

        case WAIT_TIMEOUT:
            
            EndTime = GetTickCount() + 50;
            while (GetTickCount() < EndTime);
            break;

        default:
            
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;
    
 cleanup:

    DBGPRNT(("WIN: RunIdleTask()=%x\n",ErrorCode));

    return ErrorCode;
}

INT WINAPI WinMain(
   HINSTANCE Instance,
   HINSTANCE PreviousInstance,
   LPSTR CommandLine,
   INT ShowCommand)
{
    DWORD ErrorCode;
    DWORD WaitResult;
    HANDLE StartEvent;
    HANDLE StopEvent;
    MSG Msg;
    IT_IDLE_DETECTION_PARAMETERS Parameters;
    BOOLEAN ShouldExitApp;
    PCHAR Argument;
    DWORD IdleWindowTimeout;
    BOOLEAN RegisteredIdleTask;
    DWORD NotIdleTimerId;
    IT_HANDLE ItHandle;

    //
    // Initialize locals.
    //

    RegisteredIdleTask = FALSE;
    IdleWindowTimeout = 3000;     // 3 seconds.
    NotIdleTimerId = 1;

    //
    // Check for a running instance. If this is the first instance,
    // continue initialization.
    //

    if (PreviousInstance) {
        ErrorCode = ERROR_ALREADY_EXISTS;
        goto cleanup;
    }

    //
    // Turn on file logging if asked for.
    //

    if (Argument = strstr(CommandLine, "-logtrace")) {
        WinIdleLogToFile = TRUE;
    }

    IiInstance = Instance;
    IiMainWindow = IiInit(IiInstance);

    if (!IiMainWindow) {
        ErrorCode = ERROR_INVALID_FUNCTION;
        goto cleanup;
    }

    //
    // Check if we need to display help.
    //    

    if (Argument = strstr(CommandLine, "?")) {
        MessageBox(IiMainWindow, 
                   WinIdleUsage, 
                   L"WinIdle - Idle Detection Test Program",
                   MB_OK);
        ErrorCode = ERROR_SUCCESS;
        goto cleanup;
    }

    //
    // Idle notification window timeout.
    //

    if (Argument = strstr(CommandLine, "-wintimeout=")) {
        sscanf(Argument, "-wintimeout=%u", &IdleWindowTimeout);
    }

    //
    // Set defaults to stress values if asked for.
    //

    Parameters.MaxNumRegisteredTasks = 256;
    
    if (Argument = strstr(CommandLine, "-stressparams")) {

        Parameters.IdleDetectionPeriod =          1000;
        Parameters.IdleVerificationPeriod =        500;
        Parameters.NumVerifications =                2;
        Parameters.IdleInputCheckPeriod =          200;
        Parameters.IdleTaskRunningCheckPeriod =   1000;
        Parameters.MinCpuIdlePercentage =           90;
        Parameters.MinDiskIdlePercentage =          85;

        //
        // Update parameters from command line options.
        //

        if (Argument = strstr(CommandLine, "-period=")) {
            sscanf(Argument, "-period=%u", &Parameters.IdleDetectionPeriod);
        }
        if (Argument = strstr(CommandLine, "-vperiod=")) {
            sscanf(Argument, "-vperiod=%u", &Parameters.IdleVerificationPeriod);
        }
        if (Argument = strstr(CommandLine, "-vnum=")) {
            sscanf(Argument, "-vnum=%u", &Parameters.NumVerifications);
        }
        if (Argument = strstr(CommandLine, "-taskcheck=")) {
            sscanf(Argument, "-taskcheck=%u", &Parameters.IdleTaskRunningCheckPeriod);
        }
        if (Argument = strstr(CommandLine, "-mincpu=")) {
            sscanf(Argument, "-mincpu=%u", &Parameters.MinCpuIdlePercentage);
        }
        if (Argument = strstr(CommandLine, "-mindisk=")) {
            sscanf(Argument, "-mindisk=%u", &Parameters.MinDiskIdlePercentage);
        }
    
        //
        // Set the parameters on the server.
        //

        RpcTryExcept {

            ErrorCode = ItSrvSetDetectionParameters(NULL, &Parameters);
        }
        RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

            ErrorCode = RpcExceptionCode();
        }
        RpcEndExcept

            DBGPRNT(("WIN: WinMain-SetParameters()=%d\n",ErrorCode));
    
        if (ErrorCode != RPC_S_OK) {
            goto cleanup;
        }
    }

    //
    // Register idle task.
    //

    ErrorCode = RegisterIdleTask(ItOptimalDiskLayoutTaskId,
                                 &ItHandle,
                                 &StartEvent,
                                 &StopEvent);   

    DBGPRNT(("WIN: WinMain-RegisterTask()=%d\n",ErrorCode));

    if (ErrorCode != ERROR_SUCCESS) {
        goto cleanup;
    }

    RegisteredIdleTask = TRUE;

    while (TRUE) {
        
        WaitResult = MsgWaitForMultipleObjects (1,
                                                &StartEvent,
                                                FALSE,
                                                INFINITE,
                                                QS_ALLEVENTS|QS_ALLINPUT);
        
        switch (WaitResult) {
            
        case WAIT_OBJECT_0:
            
            DBGPRNT(("WIN: WinMain-StartEvent\n"));
            
            KillTimer(IiMainWindow, NotIdleTimerId);
            IiCurrentMessageIdx = II_MSG_RUNNING;
            InvalidateRect(IiMainWindow, NULL, TRUE);
            ShowWindow(IiMainWindow, SW_SHOW);

            ErrorCode = RunIdleTask(StopEvent, &ShouldExitApp);

            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }

            if (ShouldExitApp) {
                goto cleanup;
            }

            IiCurrentMessageIdx = II_MSG_NOTIDLE;
            InvalidateRect(IiMainWindow, NULL, TRUE);
            SetTimer(IiMainWindow, NotIdleTimerId, IdleWindowTimeout, NULL);

            break;

        case WAIT_OBJECT_0 + 1:

            DBGPRNT(("WIN: WinMain-WindowMessage\n"));

            if (PeekMessage (&Msg, NULL, 0, 0, PM_REMOVE)) {

                if (Msg.message == WM_QUIT) {
                    ErrorCode = ERROR_SUCCESS;
                    goto cleanup;
                }
                
                TranslateMessage (&Msg);
                DispatchMessage (&Msg);
            }
            
            break;

        default:
            
            ErrorCode = GetLastError();
            goto cleanup;
        }
    }

    ErrorCode = ERROR_SUCCESS;

 cleanup:

    if (RegisteredIdleTask) {
        UnregisterIdleTask(ItHandle,
                           StartEvent,
                           StopEvent);
    }

    DBGPRNT(("WIN: WinMain()=%d\n",ErrorCode));
    
    return ErrorCode;
}

/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(HeapAlloc(GetProcessHeap(),0,(len)));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    HeapFree(GetProcessHeap(),0,(ptr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\idletask\test\conidle\conidle.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    conidle.c

Abstract:

    This module builds a console test program to stress idle
    detection, and registration/unregistration mechanisms.

    The quality of the code for the test programs is as such.

Author:

    Cenk Ergan (cenke)

Environment:

    User Mode

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wmium.h>
#include <ntdddisk.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include "idlrpc.h"
#include "idlecomn.h"

//
// Note that the following code is test quality code.
//

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    );

DWORD
ProcessIdleTasks (
    VOID
    );

#define NUM_TEST_TASKS 3

typedef enum _WORKTYPE {
    CpuWork,
    DiskWork,
    MaxWorkType
} WORKTYPE, *PWORKTYPE;

typedef struct _TESTTASK {
    HANDLE ThreadHandle;
    ULONG No;
    IT_IDLE_TASK_ID Id;
    IT_HANDLE ItHandle;
    HANDLE StartEvent;
    HANDLE StopEvent;
} TESTTASK, *PTESTTASK;

typedef struct _TESTWORK {
    ULONG No;
    WORKTYPE Type;
    DWORD WorkLength;
    HANDLE StopEvent;
} TESTWORK, *PTESTWORK;

TESTTASK g_Tasks[NUM_TEST_TASKS];

BOOLEAN g_ProcessingIdleTasks = FALSE;
HANDLE g_ProcessedIdleTasksEvent = NULL;

#define MAX_WAIT_FOR_START      20000
#define MAX_WORK_LENGTH          5000
#define MAX_READ_SIZE     (64 * 1024)

DWORD
WINAPI
DoWorkThreadProc(
    LPVOID lpParameter
    )
{
    PTESTWORK Work;
    DWORD EndTime;
    DWORD WaitResult;
    DWORD ErrorCode;
    DWORD RunTillTime;
    HANDLE DiskHandle;
    PVOID ReadBuffer;
    BOOL ReadResult;
    ULONG NumBytesRead;
    LARGE_INTEGER VolumeSize;
    LARGE_INTEGER SeekPosition;
    ULONG ReadIdx;
    DISK_GEOMETRY DiskGeometry;
    ULONG BytesReturned;
    static LONG DiskNumber;

    //
    // Initialize locals.
    //
    
    Work = lpParameter;
    EndTime = GetTickCount() + Work->WorkLength;
    DiskHandle = NULL;
    ReadBuffer = NULL;

    //
    // Do initialization for performing specified work.
    //
    
    switch (Work->Type) {
    case DiskWork:

        //
        // Open disk. Maybe we could open different physical drives
        // each time.
        //

        DiskHandle = CreateFile(L"\\\\.\\PHYSICALDRIVE0",
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_FLAG_NO_BUFFERING,
                                0);
    
        if (!DiskHandle) {
            ErrorCode = GetLastError();
            printf("W%d: Failed open PHYSICALDRIVE0.\n", Work->No);
            goto cleanup;
        }
    
        //
        // Get volume size.
        //
    
        if (!DeviceIoControl(DiskHandle,
                             IOCTL_DISK_GET_DRIVE_GEOMETRY,
                             NULL,
                             0,
                             &DiskGeometry,
                             sizeof(DiskGeometry),
                             &BytesReturned,
                             NULL)) {

            ErrorCode = GetLastError();
            printf("W%d: Failed GET_DRIVE_GEOMETRY.\n", Work->No);
            goto cleanup;
        }

        VolumeSize.QuadPart = DiskGeometry.Cylinders.QuadPart *
            DiskGeometry.TracksPerCylinder *
            DiskGeometry.SectorsPerTrack *
            DiskGeometry.BytesPerSector;

        //
        // Allocate buffer.
        //

        ReadBuffer = VirtualAlloc(NULL,
                                  MAX_READ_SIZE,
                                  MEM_COMMIT,
                                  PAGE_READWRITE);
    
        if (!ReadBuffer) {
            ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            printf("W%d: Failed VirtualAlloc.\n", Work->No);
            goto cleanup;
        }

        break;

    default:
        
        //
        // Nothing to prepare.
        //
        
        break;
    }
    
    while (GetTickCount() < EndTime) {
        
        //
        // Check if we are asked to stop.
        //

        WaitResult = WaitForSingleObject(Work->StopEvent, 0);
        if (WaitResult == WAIT_OBJECT_0) {
            ErrorCode = ERROR_SUCCESS;
            goto cleanup;
        }

        //
        // Do a unit of work that should not take more than several
        // tens of milliseconds.
        //
        
        switch (Work->Type) {

        case CpuWork:
            
            RunTillTime = GetTickCount() + 10;
            
            while (GetTickCount() < RunTillTime) ;
            
            break;

        case DiskWork:

            //
            // Seek to random position.
            //

            SeekPosition.QuadPart = rand() * 4 * 1024;
            SeekPosition.QuadPart %= VolumeSize.QuadPart;

            if (!SetFilePointerEx(DiskHandle,
                                  SeekPosition,
                                  NULL,
                                  FILE_BEGIN)) {

                printf("W%d: Failed SetFilePointerEx.\n", Work->No);
                ErrorCode = GetLastError();
                goto cleanup;
            }

            //
            // Issue read.
            //

            ReadResult = ReadFile(DiskHandle,
                                  ReadBuffer,
                                  MAX_READ_SIZE,
                                  &NumBytesRead,
                                  NULL);

            if (!ReadResult) {
                printf("W%d: Failed ReadFile.\n", Work->No);
                ErrorCode = GetLastError();
                goto cleanup;
            }

            break;

        default:
            
            printf("W%d: Not valid work type %d!\n", Work->No, Work->Type);
            ErrorCode = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    
    ErrorCode = ERROR_SUCCESS;

 cleanup:
    
    if (DiskHandle) {
        CloseHandle(DiskHandle);
    }
    
    if (ReadBuffer) {
        VirtualFree(ReadBuffer, 0, MEM_RELEASE);
    }

    printf("W%d: Exiting with error code: %d\n", Work->No, ErrorCode);

    return ErrorCode;
}

DWORD 
WINAPI 
TaskThreadProc(
    LPVOID lpParameter
    )
{
    PTESTTASK Task = lpParameter;
    TESTWORK Work;
    DWORD ErrorCode;
    WORKTYPE Type;
    DWORD WaitResult;
    DWORD WaitForStart;
    HANDLE WorkerThreadHandle;
    DWORD WorkLength;
    HANDLE Events[2];
    DWORD ElapsedTime;
    DWORD StartTime;
    ULONG TryIdx;
    BOOLEAN RegisteredIdleTask;

    //
    // Initialize locals.
    //

    RegisteredIdleTask = FALSE;
    WorkerThreadHandle = NULL;
    RtlZeroMemory(&Work, sizeof(Work));

    //
    // Initialize work structure.
    //

    Work.StopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!Work.StopEvent) {
        goto cleanup;
    }
    
    Work.No = Task->No;

    //
    // Loop registering, running, unregistering idle tasks.
    //

    while (TRUE) {

        //
        // If we are force-processing all tasks, usually wait for all tasks
        // to complete before queueing a new task.
        //

        if (g_ProcessingIdleTasks) {

            if ((rand() % 3) != 0) {

                printf("%d: Waiting for g_ProcessedIdleTasksEvent\n", Task->No);

                WaitResult = WaitForSingleObject(g_ProcessedIdleTasksEvent, INFINITE);

                if (WaitResult != WAIT_OBJECT_0) {
                    ErrorCode = GetLastError();
                    printf("%d: Failed wait for g_ProcessedIdleTasksEvent=%x\n", Task->No, ErrorCode);
                    goto cleanup;
                }
            }
        }
        
        //
        // Register the idle task.
        //

        ErrorCode = RegisterIdleTask(Task->Id,
                                     &Task->ItHandle,
                                     &Task->StartEvent,
                                     &Task->StopEvent);

        if (ErrorCode != ERROR_SUCCESS) {
            printf("%d: Could not register: %d\n", Task->No, ErrorCode);
            goto cleanup;
        }

        RegisteredIdleTask = TRUE;
        
        //
        // Determine task parameters. 
        //
        
        Type = rand() % MaxWorkType;
        WaitForStart = rand() % MAX_WAIT_FOR_START;
        WorkLength = rand() % MAX_WORK_LENGTH;

        //
        // Update work item.
        //

        Work.Type = Type;
        Work.WorkLength = WorkLength;
        
        printf("%d: NewTask Type=%d,WStart=%d,Length=%d,Handle=%p\n", 
               Task->No, Type, WaitForStart, WorkLength, Task->ItHandle);

        do {

            //
            // Wait to be signaled.
            //

            printf("%d: Waiting for start\n", Task->No);
        
            WaitResult = WaitForSingleObject(Task->StartEvent, WaitForStart);

            if (WaitResult == WAIT_TIMEOUT) {
                printf("%d: Timed out wait for start. Re-registering\n", Task->No);
                break;
            }
        
            //
            // Spawn the work.
            //

            ResetEvent(Work.StopEvent);

            StartTime = GetTickCount();
        
            WorkerThreadHandle = CreateThread(NULL,
                                              0,
                                              DoWorkThreadProc,
                                              &Work,
                                              0,
                                              NULL);
        
            if (!WorkerThreadHandle) {
                ErrorCode = GetLastError();
                printf("%d: Failed spawn work: %d\n", Task->No, ErrorCode);
                goto cleanup;
            }
        
            //
            // Wait for stop event to be signaled or the work to be
            // completed.
            //

            Events[0] = WorkerThreadHandle;
            Events[1] = Task->StopEvent;

            printf("%d: Waiting for stop or workdone\n", Task->No);
        
            WaitResult = WaitForMultipleObjects(2,
                                                Events,
                                                FALSE,
                                                INFINITE);       
        
            if (WaitResult == WAIT_OBJECT_0) {

                //
                // Break out if the work was done.
                //

                printf("%d: Work done.\n", Task->No);
                
                CloseHandle(WorkerThreadHandle);
                WorkerThreadHandle = NULL;

                break;

            } else if (WaitResult == WAIT_OBJECT_0 + 1) {

                //
                // We were told to stop. Signal the worker thread and
                // wait.
                //

                printf("%d: Stopped, Waiting for thread to exit\n", Task->No);
                
                SetEvent(Work.StopEvent);
                WaitForSingleObject(WorkerThreadHandle, INFINITE);
                CloseHandle(WorkerThreadHandle);
                WorkerThreadHandle = NULL;
                
                //
                // This is not really the time we worked (e.g. we may be
                // switched out etc.) We want to keep rolling and this is
                // what we can get easily.
                //
                
                ElapsedTime = GetTickCount() - StartTime;
            
                if (ElapsedTime > Work.WorkLength) {
                    
                    //
                    // We've gone too long with this work. Unregistester
                    // this task and pick another one.
                    //
                    
                    break;
                }
                
                Work.WorkLength -= ElapsedTime;

                //
                // Loop on until we pass enough time with this work.
                //

            } else {

                //
                // There was an error.
                //
                
                ErrorCode = GetLastError();
                printf("%d: WaitForMultipleObjects failed: %d\n", Task->No, ErrorCode);
                goto cleanup;
            }

        } while (TRUE);

        ASSERT(RegisteredIdleTask);

        UnregisterIdleTask(Task->ItHandle,
                           Task->StartEvent,
                           Task->StopEvent);
        
        RegisteredIdleTask = FALSE;
    }

 cleanup:

    if (RegisteredIdleTask) {
        UnregisterIdleTask(Task->ItHandle,
                           Task->StartEvent,
                           Task->StopEvent);
    }

    if (WorkerThreadHandle) {
        SetEvent(Work.StopEvent);
        WaitForSingleObject(WorkerThreadHandle, INFINITE);
        CloseHandle(WorkerThreadHandle);
    }

    if (Work.StopEvent) {
        CloseHandle(Work.StopEvent);
    }

    return ErrorCode;
}

int 
__cdecl 
main(int argc, char* argv[])
{
    DWORD ErrorCode;
    ULONG TaskIdx;
    IT_IDLE_DETECTION_PARAMETERS Parameters;
    PTESTTASK Task;
    INPUT MouseInput;
    ULONG SleepTime;

    //
    // Initialize locals.
    //

    RtlZeroMemory(&MouseInput, sizeof(MouseInput));
    MouseInput.type = INPUT_MOUSE;
    MouseInput.mi.dwFlags = MOUSEEVENTF_MOVE;

    //
    // Initialize globals.
    //

    g_ProcessingIdleTasks = FALSE;
    g_ProcessedIdleTasksEvent = NULL;

    //
    // Initialize random.
    //
    
    srand((unsigned)time(NULL));

    //
    // Create an manual reset event that will be signaled when we finish 
    // processing all tasks after telling the server to process all tasks.
    //

    g_ProcessedIdleTasksEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (!g_ProcessedIdleTasksEvent) {
        ErrorCode = GetLastError();
        printf("Failed to create g_ProcessedIdleTasksEvent=%x\n",ErrorCode);
        goto cleanup;
    }

    //
    // Set idle detection parameters for stress.
    //

    Parameters.IdleDetectionPeriod =          1000;
    Parameters.IdleVerificationPeriod =        500;
    Parameters.NumVerifications =                2;
    Parameters.IdleInputCheckPeriod =          100;
    Parameters.IdleTaskRunningCheckPeriod =   1000;
    Parameters.MinCpuIdlePercentage =           50;
    Parameters.MinDiskIdlePercentage =          50;
    Parameters.MaxNumRegisteredTasks =         500;

    RpcTryExcept {

        ErrorCode = ItSrvSetDetectionParameters(NULL, &Parameters);
    }
    RpcExcept(IT_RPC_EXCEPTION_HANDLER()) {

        ErrorCode = RpcExceptionCode();
    }
    RpcEndExcept
    
    if (ErrorCode != ERROR_SUCCESS) {
        printf("Failed set idle detection params for stress.\n");
        goto cleanup;
    }

    //
    // Register and start tasks.
    //

    for (TaskIdx = 0; TaskIdx < NUM_TEST_TASKS; TaskIdx++) {

        Task = &g_Tasks[TaskIdx];

        Task->No = TaskIdx;
        Task->Id = ItOptimalDiskLayoutTaskId;
        
        Task->ThreadHandle = CreateThread(NULL,
                                          0,
                                          TaskThreadProc,
                                          &g_Tasks[TaskIdx],
                                          0,
                                          0);
        
        if (!Task->ThreadHandle) {
            ErrorCode = GetLastError();
            printf("Could not spawn task %d: %x\n", TaskIdx, ErrorCode);    
            goto cleanup;
        }

    }   

    //
    // Loop forever sending input messages once in a while to stop
    // idle tasks.
    //

    while (1) {
        
        SleepTime = MAX_WAIT_FOR_START * (rand() % 64) / 64;

        Sleep(SleepTime);

        //
        // Every so often, ask all idle tasks to be processed.
        //
    
        if ((rand() % 2) == 0) {

            if ((rand() % 2) == 0) {
                printf("MainThread: Sending user input before processing all tasks\n");
                SendInput(1, &MouseInput, sizeof(MouseInput));
            }

            printf("MainThread: ProcessIdleTasks()\n");

            ResetEvent(g_ProcessedIdleTasksEvent);
            g_ProcessingIdleTasks = TRUE;
            
            ErrorCode = ProcessIdleTasks();

            printf("MainThread: ProcessIdleTasks()=%x\n",ErrorCode);

            g_ProcessingIdleTasks = FALSE;
            SetEvent(g_ProcessedIdleTasksEvent);

            if (ErrorCode != ERROR_SUCCESS) {
                goto cleanup;
            }
        }

        if ((rand() % 2) == 0) {
            printf("MainThread: Sending user input\n");
            SendInput(1, &MouseInput, sizeof(MouseInput));
        }
    }
    
 cleanup:

    if (g_ProcessedIdleTasksEvent) {
        CloseHandle(g_ProcessedIdleTasksEvent);
    }

    return ErrorCode;
}

/*********************************************************************/
/*                MIDL allocate and free                             */
/*********************************************************************/

void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(HeapAlloc(GetProcessHeap(),0,(len)));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    HeapFree(GetProcessHeap(),0,(ptr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\inc\foldersecurity.h ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2002.
//
//  File:       FolderSecurity.h
//
//  Contents:   functions to read folder security and perform access checks against it
//
//  History:    5-April-02 HHance created
//
//-----------------------------------------------------------------------------

#ifndef FOLDER_SECURITY_COMPILED_ALREADY
#define FOLDER_SECURITY_COMPILED_ALREADY

#define HandleImpersonation true
#define DontHandleImpersonation false

// returns  S_OK if the folder's DACL allows the requested access
//          E_ACCESSDENIED if not
//          ERROR_FILE_NOT_FOUND if not found
//          other error on other error

// HANDLE clientToken                       // handle to client access token
// DWORD desiredAccess                      // requested access rights
//          Suggested rights:
//                              FILE_READ_DATA
//                              FILE_WRITE_DATA
//                              FILE_EXECUTE
//                              FILE_DELETE_CHILD (for directories)
// 
HRESULT FolderAccessCheck(const WCHAR* folderName, HANDLE clientToken, DWORD desiredAccess);

// helper function - uses current thread/process token
// to call AccessCheck
HRESULT FolderAccessCheckOnThreadToken(const WCHAR* folderName, DWORD desiredAccess);

// helper function - makes use of RPC Impersonation capabilities
// intended to be called from the task scheduler service process
// if bHandleImpersonation is true, this function calls RPCImpersonateClient and RPCRevertToSelf
HRESULT RPCFolderAccessCheck(const WCHAR* folderName, DWORD desiredAccess, bool bHandleImpersonation);

// helper function - makes use of COM impersonation capabilities
HRESULT CoFolderAccessCheck(const WCHAR* pFolderName, DWORD desiredAccess);


#endif // FOLDER_SECURITY_COMPILED_ALREADY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\job.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       job.cxx
//
//  Contents:   ITask interface methods
//
//  Classes:    CJob
//
//  Interfaces: ITask
//
//  History:    23-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"
#include <StrSafe.h>

WCHAR                   wszEmpty[]              = L"";

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::Run
//
//  Synopsis:   Run the job now. Sets a service bit on the job file. The
//              running service will notice this bit being set and will run
//              this job.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Run(void)
{
    TRACE(CJob, Run)

    if (!IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
    {
        return SCHED_E_TASK_NOT_READY;
    }

    //
    // Set the magic bit.
    //

    SetFlag(JOB_I_FLAG_RUN_NOW);

    //
    // Save the service flags to disk so that the change can be noted by the
    // service.  Preserve the net schedule flag, thus allowing a user to force
    // a run of an AT job without clearing the AT bit.
    //

    return SaveWithRetry(NULL, FALSE, SAVEP_PRESERVE_NET_SCHEDULE);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::Terminate
//
//  Synopsis:   Abort this job, if it is running. Do so by setting an abort
//              flag on the job object. The scheduler service local to the
//              job object will detect this change and abort the job.
//
//  Arguments:  None.
//
//  Returns:    HRESULTS
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Terminate(void)
{
    TRACE(CJob, Terminate)

    if (m_cRunningInstances > 0)
    {
        //
        // Set the abort status bit and rewrite the state.  This will instruct
        // the service to process the job, detect the abort bit flag, and
        // abort the job.  As with the Run method, this doesn't zap the AT
        // flag.
        //

        SetFlag(JOB_I_FLAG_ABORT_NOW);

        return SaveWithRetry(NULL, FALSE, SAVEP_PRESERVE_NET_SCHEDULE);
    }
    else
    {
        return(SCHED_E_TASK_NOT_RUNNING);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::CreateTrigger
//
//  Synopsis:   Create a new trigger, add it to the job object, and return a
//              pointer to it.
//
//  Arguments:  [piNewTrigger] - the index of the new trigger, optional
//              [ppTrigger]    - a pointer to the new trigger
//
//  Returns:    HRESULTS
//
//  Notes:      The trigger is AddRef'd in CreateTriggerP
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::CreateTrigger(WORD * piNewTrigger, ITaskTrigger ** ppTrigger)
{
    TRACE3(CJob, CreateTrigger)

    *ppTrigger = NULL;              // Init in case of error.

    SYSTEMTIME st;
    GetLocalTime(&st);

    TASK_TRIGGER jt = {
        sizeof(TASK_TRIGGER),       // Trigger size.
        m_Triggers.GetCount(),      // Reserved (trigger index).
        st.wYear,                   // Beginning year.
        st.wMonth,                  // Beginning month.
        st.wDay,                    // Beginning day.
        0,                          // Ending year.
        0,                          // Ending month.
        0,                          // Ending day.
        st.wHour,                   // Starting hour.
        st.wMinute,                 // Starting minute.
        0,                          // Minutes duration.
        0,                          // Minutes interval.
        JOB_TRIGGER_I_FLAG_NOT_SET, // Flags.
        TASK_TIME_TRIGGER_DAILY,    // Trigger type.
        1,                          // Trigger union.
        0,                          // Reserved2. Unused.
        0                           // Random minutes interval.
    };

    CTrigger * pt = new CTrigger(jt.Reserved1, this);

    if (pt == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(E_OUTOFMEMORY);
    }

    HRESULT hr = m_Triggers.Add(jt);

    if (FAILED(hr))
    {
        delete pt;
        CHECK_HRESULT(hr);
        return(hr);
    }

    this->SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    this->SetTriggersDirty();

    *piNewTrigger = jt.Reserved1;
    *ppTrigger    = pt;

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::DeleteTrigger
//
//  Synopsis:   Remove a run trigger.
//
//  Arguments:  [iTrigger] - the index of the trigger to be removed
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::DeleteTrigger(WORD iTrigger)
{
    TRACE3(CJob, DeleteTrigger)

    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    if (pjt != NULL)
    {
        m_Triggers.Remove(iTrigger);

        // Fixup remaining indices to account for deletion.
        //
        for (WORD i = iTrigger; i < m_Triggers.GetCount(); i++)
        {
            m_Triggers[i].Reserved1--;
        }

        this->SetTriggersDirty();

        if (!m_Triggers.GetCount())
        {
            this->ClearFlag(JOB_I_FLAG_HAS_TRIGGERS);
        }

        return(S_OK);
    }
    else
    {
        return(SCHED_E_TRIGGER_NOT_FOUND);
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_GetTrigger, private
//
//  Synopsis:   Return the TASK_TRIGGER associated with the index. The
//              TASK_TRIGGER reserved field specifies the trigger index.
//
//  Arguments:  [iTrigger] -- Trigger index.
//
//  Returns:    TASK_TRIGGER * -- Trigger found.
//              NULL           -- Trigger not found.
//
//-----------------------------------------------------------------------------
TASK_TRIGGER *
CJob::_GetTrigger(WORD iTrigger)
{
    for (WORD i = 0; i < m_Triggers.GetCount(); i++)
    {
        if (m_Triggers[i].Reserved1 == iTrigger)
        {
            return(&m_Triggers[i]);
        }
    }

    return(NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTriggerCount
//
//  Synopsis:   Return the count of run triggers.
//
//  Arguments:  [pwCount] - the address where the count is to be returned
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTriggerCount(WORD * pwCount)
{
    TRACE3(CJob, GetTriggerCount)

    *pwCount = m_Triggers.GetCount();

    return(S_OK);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTrigger
//
//  Synopsis:   Return an ITaskTrigger pointer to the indicated trigger.
//
//  Arguments:  [iTrigger] - the index of the trigger to fetch
//              [ppTrigger] - the returned trigger pointer
//
//  Returns:    HRESULTS
//
//  Notes:      The trigger is AddRef'd in GetTriggerObj(m_Triggers.GetTrigger)
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTrigger(WORD iTrigger, ITaskTrigger ** ppTrigger)
{
    TRACE3(CJob, GetTrigger)

    *ppTrigger = NULL;              // Init in case of error.

    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    if (pjt != NULL)
    {
        CTrigger * pt = new CTrigger(iTrigger, this);

        if (pt == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return(E_OUTOFMEMORY);
        }

        *ppTrigger = pt;
        return(S_OK);
    }

    return(SCHED_E_TRIGGER_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTriggerString
//
//  Synopsis:   Return the indicated run trigger as a string.
//
//  Arguments:  [iTrigger]     - the index of the trigger to convert
//              [ppwszTrigger] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTriggerString(WORD iTrigger, LPWSTR * ppwszTrigger)
{
    TRACE3(CJob, GetTriggerString)

    *ppwszTrigger = NULL;           // Init in case of error.

    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    if (pjt != NULL)
    {
        return(::StringFromTrigger(pjt, ppwszTrigger, NULL));
    }

    return(SCHED_E_TRIGGER_NOT_FOUND);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetApplicationName
//
//  Synopsis:   Set the Application Name String property
//
//  Arguments:  [pwszApplicationName] - the name of the app to execute.
//
//  Returns:    HRESULTS
//
//  Notes:      The string is caller allocated and freed.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetApplicationName(LPCWSTR pwszApplicationName)
{
    TRACE3(CJob, SetApplicationName)

    if (!pwszApplicationName)
        return E_INVALIDARG;
    
    if (wcslen(pwszApplicationName) > MAX_PATH)
        return E_INVALIDARG;

    //
    // We don't use a try/catch
    // because the COM interface runs in the caller's context and it is their
    // responsibility to ensure good params. This latter statement is true for
    // all scheduler COM interface methods.
    //
    if (*pwszApplicationName == L'\0')
    {
        //
        // The caller wants the command set to an empty string.
        //

        ClearFlag(JOB_I_FLAG_HAS_APPNAME);

        //
        // We are using a null pointer for an empty string as an optimization.
        //
        if (m_pwszApplicationName == NULL)
        {
            //
            // Nothing to do.
            //
            return S_OK;
        }
        else
        {
            //
            // Setting this flag will instruct the persist code to
            // regenerate a GUID for this job. This is done for security
            // reasons.
            //
            // NB : This must be done for Win95 as well as NT.
            //

            SetFlag(JOB_I_FLAG_APPNAME_CHANGE);

            DELETE_CJOB_FIELD(m_pwszApplicationName);
            //
            // We want this change to trigger a wait list rebuild.
            //
            SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
        }
    }
    else
    {
        //
        // Update the flags and status.
        //
        SetFlag(JOB_I_FLAG_HAS_APPNAME);

        if (IsStatus(SCHED_S_TASK_NOT_SCHEDULED))
        {
            //
            // Note that if the status went from SCHED_S_TASK_NOT_SCHEDULED to
            // SCHED_S_TASK_HAS_NOT_RUN or SCHED_S_TASK_READY, then we
            // want CheckDir to issue a wait list rebuild because the job has
            // gone from a non-runable to a runable state. Thus, in the if
            // clause below we set JOB_I_FLAG_RUN_PROP_CHANGE.
            //
            if (IsFlagSet(JOB_I_FLAG_HAS_TRIGGERS) &&
                !IsFlagSet(JOB_I_FLAG_NO_VALID_TRIGGERS))
            {
                if (m_stMostRecentRunTime.wYear == 0)
                {
                    //
                    // Job has never run if last-run-time property is null
                    // (all elements will be zero if null, testing year is
                    // sufficient).
                    //
                    SetStatus(SCHED_S_TASK_HAS_NOT_RUN);
                }
                else
                {
                    //
                    // Job has run in the past, so it is now waiting to run
                    // again.
                    //
                    SetStatus(SCHED_S_TASK_READY);
                }
                //
                // We want this change to trigger a wait list rebuild.
                //
                SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
            }
        }

        TCHAR tszAppName[MAX_PATH+1];                               // define buffer size as 1 more than max in
        SecureZeroMemory(tszAppName, sizeof tszAppName);            // order to leave space for NULL terminator

        if (IsLocalFilename(m_ptszFileName))
        {
            lstrcpyn(tszAppName, pwszApplicationName, MAX_PATH);    // lstrcpyn needs to know maximum # of chars,
                                                                    // this needs to be 1 less than buffer size	
            ProcessApplicationName(tszAppName, MAX_PATH+1,
                                   m_pwszWorkingDirectory ?
                                      m_pwszWorkingDirectory :
                                      wszEmpty);
        }
        else
        {
            lstrcpyn(tszAppName, pwszApplicationName, MAX_PATH);    // # of chars, not buffer size
            StripLeadTrailSpace(tszAppName);
            DeleteQuotes(tszAppName);
        }

        //
        // Allocate a new string, adding one for the null terminator
        //

        ULONG  cchAppName = lstrlen(tszAppName) + 1;
        LPWSTR pwszTmp = new WCHAR[cchAppName];

        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetApplicationName", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        StringCchCopy(pwszTmp, cchAppName, tszAppName);

        //
        // Setting this flag will instruct the persist code to
        // regenerate a GUID for this job. This is done for security
        // reasons.
        //
        // NB : This must be done for Win95 as well as NT.
        //
        // Ensure first, that the application has indeed changed.
        //

        if (m_pwszApplicationName != NULL && lstrcmpiW(
                                                m_pwszApplicationName,
                                                pwszTmp) != 0)
        {
            SetFlag(JOB_I_FLAG_APPNAME_CHANGE);
        }

        DELETE_CJOB_FIELD(m_pwszApplicationName);
        m_pwszApplicationName = pwszTmp;
    }

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetApplicationName
//
//  Synopsis:   Get the ApplicationName String property
//
//  Arguments:  [ppwszApplicationName] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The command string is passed to CreateProcess to be executed
//              at task run time.
//              The string is callee allocated and caller freed with
//              CoTaskMemFree.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetApplicationName(LPWSTR * ppwszApplicationName)
{
    TRACE3(CJob, GetApplicationName)
    WCHAR * pwszCmd;

    if (m_pwszApplicationName == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszCmd = wszEmpty;
    }
    else
    {
        pwszCmd = m_pwszApplicationName;
    }

    // add one for the null.
    *ppwszApplicationName = (LPWSTR)CoTaskMemAlloc((wcslen(pwszCmd) + 1) *
                                           sizeof(WCHAR));

    if (*ppwszApplicationName == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszApplicationName, wcslen(pwszCmd) + 1, pwszCmd);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetParameters
//
//  Synopsis:   Set the Parameters String property
//
//  Arguments:  [pwszParameters] - the application parameters string
//
//  Returns:    HRESULTS
//
//  Notes:      The Parameters string is appended to the Application Name and
//              passed to CreateProcess as the command line to be executed at
//              task run time.
//              The string is caller allocated and freed.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetParameters(LPCWSTR pwszParameters)
{
    TRACE3(CJob, SetParameters)

    if (*pwszParameters == L'\0')
    {
        //
        // The caller wants the Parameters set to an empty string.
        //
        // We are using a null pointer for an empty string as an optimization.
        //
        DELETE_CJOB_FIELD(m_pwszParameters);
    }
    else
    {
        //
        // Allocate a new string, adding one for the null terminator
        //
        LPWSTR pwszTmp = new WCHAR[wcslen(pwszParameters) + 1];
        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetParameters", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        StringCchCopy(pwszTmp, wcslen(pwszParameters) + 1, pwszParameters);

        DELETE_CJOB_FIELD(m_pwszParameters);

        m_pwszParameters = pwszTmp;
    }
    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetParameters
//
//  Synopsis:   Get the Parameters String property
//
//  Arguments:  [ppwszParameters] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The Parameters string is appended to the Application Name and
//              passed to CreateProcess as the command line to be executed at
//              task run time.
//              The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetParameters(LPWSTR * ppwszParameters)
{
    TRACE3(CJob, GetParameters)
    WCHAR * pwszTmp;

    if (m_pwszParameters == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszTmp = wszEmpty;
    }
    else
    {
        pwszTmp = m_pwszParameters;
    }

    // add one for the null.
    *ppwszParameters = (LPWSTR)CoTaskMemAlloc((wcslen(pwszTmp) + 1) *
                                           sizeof(WCHAR));

    if (*ppwszParameters == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszParameters,wcslen(pwszTmp) + 1, pwszTmp);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetWorkingDirectory
//
//  Synopsis:   Set the Working Directory (current directory) property
//
//  Arguments:  [pwszWorkingDir] - the name to use
//
//  Returns:    HRESULTS
//
//  Notes:      The string is caller allocated and freed
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetWorkingDirectory(LPCWSTR pwszWorkingDirectory)
{
    TRACE3(CJob, SetWorkingDirectory)

    if (*pwszWorkingDirectory == L'\0')
    {
        //
        // The caller wants the WorkingDirectory set to an empty string.
        //
        DELETE_CJOB_FIELD(m_pwszWorkingDirectory);
    }
    else
    {
        //
        // Allocate a new string, adding one for the null terminator
        //
        LPWSTR pwszTmp = new WCHAR[wcslen(pwszWorkingDirectory) + 1];
        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetWorkingDirectory", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        StringCchCopy(pwszTmp, wcslen(pwszWorkingDirectory) + 1, pwszWorkingDirectory);

        DELETE_CJOB_FIELD(m_pwszWorkingDirectory);

        m_pwszWorkingDirectory = pwszTmp;

        //
        // Remove double quotes from working directory path; they're not supported
        // by SetCurrentDirectory.
        //

        DeleteQuotes(m_pwszWorkingDirectory);
    }

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetWorkingDir
//
//  Synopsis:   Get the Working Directory (current directory) property
//
//  Arguments:  [ppwszWorkingDirectory] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetWorkingDirectory(LPWSTR * ppwszWorkingDirectory)
{
    TRACE3(CJob, GetWorkingDirectory)
    WCHAR * pwszWorkingDir;

    if (m_pwszWorkingDirectory == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszWorkingDir = wszEmpty;
    }
    else
    {
        pwszWorkingDir = m_pwszWorkingDirectory;
    }

    // add one for the null.
    *ppwszWorkingDirectory = (LPWSTR)CoTaskMemAlloc(
                               (wcslen(pwszWorkingDir) + 1) * sizeof(WCHAR));

    if (*ppwszWorkingDirectory == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszWorkingDirectory,wcslen(pwszWorkingDir) + 1, pwszWorkingDir);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetComment
//
//  Synopsis:   Set the comment field.
//
//  Arguments:  [pwszComment] - the comment string value, caller alloc'd and
//                              freed
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetComment(LPCWSTR pwszComment)
{
    TRACE3(CJob, SetComment)

    if (*pwszComment == L'\0')
    {
        //
        // The caller wants the Comment set to an empty string.
        //
        DELETE_CJOB_FIELD(m_pwszComment);
    }
    else
    {
        //
        // Allocate a new string, adding one for the null terminator
        //
        LPWSTR pwszTmp = new WCHAR[wcslen(pwszComment) + 1];
        if (pwszTmp == NULL)
        {
            ERR_OUT("CJob::SetComment", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        StringCchCopy(pwszTmp, wcslen(pwszComment) + 1, pwszComment);

        DELETE_CJOB_FIELD(m_pwszComment);

        m_pwszComment = pwszTmp;
    }

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetComment
//
//  Synopsis:   Get the comment field property.
//
//  Arguments:  [ppwszComment] - the returned string buffer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetComment(LPWSTR * ppwszComment)
{
    TRACE3(CJob, GetComment)
    WCHAR * pwszCmt;

    if (m_pwszComment == NULL)
    {
        //
        // Return an empty string rather than a null pointer
        //
        pwszCmt = wszEmpty;
    }
    else
    {
        pwszCmt = m_pwszComment;
    }

    // add one for the null.
    *ppwszComment = (LPWSTR)CoTaskMemAlloc((wcslen(pwszCmt) + 1) *
                                           sizeof(WCHAR));

    if (*ppwszComment == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszComment, wcslen(pwszCmt) + 1, pwszCmt);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_SetSignature
//
//  Synopsis:   Set the job's signature.
//
//  Arguments:  [pbSignature] - assumed to be SIGNATURE_SIZE bytes long.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_SetSignature(const BYTE * pbSignature)
{
    TRACE3(CJob, SetSignature)

    LPBYTE pb = new BYTE[SIGNATURE_SIZE];

    if (pb == NULL)
    {
        ERR_OUT("CJob::SetSignature", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    CopyMemory(pb, pbSignature, SIGNATURE_SIZE);

    DELETE_CJOB_FIELD(m_pbSignature);

    m_pbSignature = pb;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetPriority
//
//  Synopsis:   Set the priority property
//
//  Arguments:  [dwPriority] - the priority value
//
//  Returns:    HRESULTS
//
//  Notes:      Controls the priority at which the job will run. Applies to NT
//              only, a no-op on Win95. This must be one of the four values
//              from CreateProcess's priority class.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetPriority(DWORD dwPriority)
{
    TRACE3(CJob, SetPriority)
    //
    // Check for valid priority values
    //
    switch (dwPriority)
    {
    case IDLE_PRIORITY_CLASS:
    case NORMAL_PRIORITY_CLASS:
    case HIGH_PRIORITY_CLASS:
    case REALTIME_PRIORITY_CLASS:
        break;

    default:
        return E_INVALIDARG;
    }

    m_dwPriority = dwPriority;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetPriority
//
//  Synopsis:   Get the priority property
//
//  Arguments:  [pdwPriority] - priority return address
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetPriority(DWORD * pdwPriority)
{
    TRACE3(CJob, GetPriority)

    *pdwPriority = m_dwPriority;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetMaxRunTime
//
//  Synopsis:   Set the MaximumRunTime property
//
//  Arguments:  [dwMaxRunTime] - new MaxRunTime value in milliseconds
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetMaxRunTime(DWORD dwMaxRunTime)
{
    TRACE3(CJob, SetMaxRunTime)

    m_dwMaxRunTime = dwMaxRunTime;

    // Cause a wait list rebuild
    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY | JOB_I_FLAG_RUN_PROP_CHANGE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetMaxRunTime
//
//  Synopsis:   Get the MaximumRunTime property
//
//  Arguments:  [pdwMaxRunTime] - MaxRunTime return address (milliseconds)
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetMaxRunTime(DWORD * pdwMaxRunTime)
{
    TRACE3(CJob, GetMaxRunTime)

    *pdwMaxRunTime = m_dwMaxRunTime;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetFlags
//
//  Synopsis:   Set the bit flags for the various boolean properties
//
//  Arguments:  [fLogConfig] - Boolean: should changes be logged true/false.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetFlags(DWORD rgFlags)
{
    TRACE3(CJob, SetFlags)

    if ((rgFlags ^ m_rgFlags) &
        (TASK_FLAG_DISABLED                     |
         TASK_FLAG_START_ONLY_IF_IDLE           |
         TASK_FLAG_KILL_ON_IDLE_END             |
         TASK_FLAG_DONT_START_IF_ON_BATTERIES   |
         TASK_FLAG_KILL_IF_GOING_ON_BATTERIES   |
         TASK_FLAG_RUN_ONLY_IF_DOCKED           |
         TASK_FLAG_RUN_IF_CONNECTED_TO_INTERNET |
         TASK_FLAG_RESTART_ON_IDLE_RESUME       |
         TASK_FLAG_SYSTEM_REQUIRED))
    {
        //
        // If any flag that could affect the CRun objects in the wait
        // list has changed, signal a wait list rebuild.
        // (Omitted flags: TASK_FLAG_HIDDEN, TASK_FLAG_INTERACTIVE,
        //   TASK_FLAG_DELETE_WHEN_DONE)
        // CODEWORK  Possible optimization: Omit some more flags and
        // defer reading their settings into the CRun object until the
        // time of running the job
        //
        SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
    }

    //
    // Only set the lower word of the internal flag property. The upper word
    // is reserved for internal use.
    //
    rgFlags &= ~JOB_INTERNAL_FLAG_MASK;
    m_rgFlags &= JOB_INTERNAL_FLAG_MASK;
    SetFlag(rgFlags);

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetFlags
//
//  Synopsis:   Get the bit flags for the various boolean properties
//
//  Arguments:  [prgFlags] - returned value placed here
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetFlags(DWORD * prgFlags)
{
    TRACE3(CJob, GetFlags)

    //
    // Only return the lower word of the internal flag property. The upper
    // word is reserved for internal use.
    // Also return whether this is an At job.
    //
    *prgFlags = m_rgFlags & (~JOB_INTERNAL_FLAG_MASK | JOB_I_FLAG_NET_SCHEDULE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetTaskFlags
//
//  Synopsis:   Sets the job's task flags.
//
//  Arguments:  [dwFlags] - flags to be set.
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetTaskFlags(DWORD dwFlags)
{
    TRACE3(CJob, SetTaskFlags)

    //
    // Only set the lower word of the internal flag property. The upper word
    // is reserved for internal use.
	// BUGBUG  return an error on invalid flag bits
    //
    m_rgTaskFlags = (m_rgTaskFlags & JOB_INTERNAL_FLAG_MASK) |
                    (dwFlags & ~JOB_INTERNAL_FLAG_MASK);

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetTaskFlags
//
//  Synopsis:   Returns the job's task flags.
//
//  Arguments:  [pdwFlags] - return value pointer.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetTaskFlags(DWORD * pdwFlags)
{
    TRACE3(CJob, GetTaskFlags)

    //
    // Only return the lower word of the internal flag property. The upper
    // word is reserved for internal use.
    //
    *pdwFlags = m_rgTaskFlags & ~JOB_INTERNAL_FLAG_MASK;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetWorkItemData
//
//  Synopsis:   Sets the task data. Provides optional, per-task, binary
//              storage for the caller.
//
//  Arguments:  [cbData]  -- number of bytes in buffer.
//              [rgbData] -- buffer of data to copy.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      The buffer is caller allocated and freed.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetWorkItemData(WORD cbData, BYTE rgbData[])
{
    TRACE3(CJob, SetWorkItemData)

    if ((cbData != 0 && rgbData == NULL) ||
        cbData == 0 && rgbData != NULL)
    {
        return E_INVALIDARG;
    }

    BYTE * pbData;

    if (cbData)
    {
        pbData = new BYTE[cbData];

        if (pbData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        CopyMemory(pbData, rgbData, cbData);
    }
    else
    {
        pbData = NULL;
    }

    DELETE_CJOB_FIELD(m_pbTaskData);
    m_pbTaskData = pbData;
    m_cbTaskData = cbData;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetWorkItemData
//
//  Synopsis:   Gets the task data.
//
//  Arguments:  [pcbData]  -- returns the number of bytes in buffer.
//              [prgbData] -- returns the buffer of data.
//
//  Returns:    S_OK for success.
//              E_INVALIDARG
//              E_OUTOFMEMORY.
//
//  Notes:      The buffer is callee allocated and caller freed with
//              CoTaskMemFree. If there is no user data, then *pcBytes is set
//              to zero and *ppBytes is set to NULL.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetWorkItemData(PWORD pcbData, PBYTE * prgbData)
{
    TRACE3(CJob, GetWorkItemData)

    if (m_pbTaskData != NULL)
    {
        *prgbData = (PBYTE)CoTaskMemAlloc(m_cbTaskData);

        if (*prgbData == NULL)
        {
            return E_OUTOFMEMORY;
        }

        CopyMemory(*prgbData, m_pbTaskData, m_cbTaskData);
        *pcbData = m_cbTaskData;
    }
    else
    {
        *pcbData  = 0;
        *prgbData = NULL;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetMostRecentRunTime
//
//  Synopsis:   Returns the time that the job last ran.
//
//  Arguments:  [pstLastRun] - value returned here.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetMostRecentRunTime(SYSTEMTIME * pstLastRun)
{
    TRACE3(CJob, GetLastRunTime)

    *pstLastRun = m_stMostRecentRunTime;

    if (m_stMostRecentRunTime.wYear == 0)
    {
        //
        // Job has never run if last-run-time property is null
        // (all elements will be zero if null, testing year is
        // sufficient).
        //
        return SCHED_S_TASK_HAS_NOT_RUN;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetNextRunTime
//
//  Synopsis:   Returns the next time that the job is scheduled to run.
//
//  Arguments:  [pstNextRun] - pointer to return value through
//
//  Returns:    S_OK: the next run time was returned.
//              S_FALSE: there are no more scheduled runs.
//              SCHED_S_EVENT_TRIGGER: there are only event triggers.
//              SCHED_S_TASK_NO_VALID_TRIGGERS: either there are no triggers or
//                  the triggers are disabled or not set.
//              HRESULT - failure code.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetNextRunTime(SYSTEMTIME * pstNextRun)
{
    TRACE3(CJob, GetNextRunTime)

    HRESULT hr;
    SYSTEMTIME stNow, stEmpty = { 0, 0, 0, 0, 0, 0, 0, 0 };
    GetLocalTime(&stNow);

    CTimeRunList RunList;

    WORD cRuns = 0;

    hr = GetRunTimesP(&stNow, NULL, &cRuns, 1, &RunList, NULL);

    if (S_OK != hr)
    {
        *pstNextRun = stEmpty;
        return hr;
    }
    else if (cRuns == 0)
    {
        *pstNextRun = stEmpty;
        return S_FALSE;
    }

    FILETIME ft;
    RunList.PeekHeadTime(&ft);

    if (!FileTimeToSystemTime(&ft, pstNextRun))
    {
        *pstNextRun = stEmpty;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetExitCode
//
//  Synopsis:   Returns the exit code of the jobs last run.
//
//  Arguments:  [pExitCode] - return value pointer.
//
//  Returns:    HRESULT - error from the last attempt to start the job.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetExitCode(DWORD * pExitCode)
{
    TRACE3(CJob, GetExitCode)

    *pExitCode = m_ExitCode;

    return m_hrStartError;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetStatus
//
//  Synopsis:   Returns the current status of this job object.
//
//  Arguments:  [phrStatus] - yup, the return value.
//
//  Returns:    HRESULTS
//
//  Notes:      The running status is implicit in a non-zero instance count.
//              Otherwise, return the status property. Note also that the
//              job's status and other properties that are obtained by the
//              load from disk are a snapshot that can become stale.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetStatus(HRESULT * phrStatus)
{
    TRACE3(CJob, GetStatus)

    if (m_cRunningInstances > 0)
    {
        *phrStatus = SCHED_S_TASK_RUNNING;
    }
    else
    {
        *phrStatus = m_hrStatus;
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::SetCreator
//
//  Synopsis:   Set the creator property.
//
//  Arguments:  [pwszCreator] -- Creator string.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SetCreator(LPCWSTR pwszCreator)
{
    TRACE3(CJob, SetCreator);

    LPWSTR pwsz;

    //
    // Handle empty string.
    //

    if (*pwszCreator)
    {
        pwsz = new WCHAR[wcslen(pwszCreator) + 1];

        if (pwsz == NULL)
        {
            return E_OUTOFMEMORY;
        }

        StringCchCopy(pwsz, wcslen(pwszCreator) + 1, pwszCreator);
    }
    else
    {
        pwsz = NULL;
    }

    DELETE_CJOB_FIELD(m_pwszCreator);

    m_pwszCreator = pwsz;

    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetCreator
//
//  Synopsis:   Fetch the creator property.
//
//  Arguments:  [ppwszCreator] -- Returned string.
//
//  Returns:    S_OK
//              E_INVALIDARG
//              E_OUTOFMEMORY
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetCreator(LPWSTR * ppwszCreator)
{
    TRACE3(CJob, GetCreator);

    //
    // Handle empty string.
    //

    LPWSTR pwsz = (m_pwszCreator == NULL ? wszEmpty : m_pwszCreator);

    *ppwszCreator = (LPWSTR)CoTaskMemAlloc(
                            (wcslen(pwsz) + 1) * sizeof(WCHAR));

    if (*ppwszCreator == NULL)
    {
        return E_OUTOFMEMORY;
    }

    StringCchCopy(*ppwszCreator, wcslen(pwsz) + 1, pwsz);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\pch\headers.cxx ===
#include "headers.hxx"
#pragma hdrstop

//
// This is a dummy file to force the creation of the global precompiled
// header.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\jobex.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Scheduler Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       jobex.cxx
//
//  Contents:   ITask interface methods
//
//  Classes:    CJob
//
//  Interfaces: ITask
//
//  History:    16-Oct-95 EricB     created
//              11-Nov-96 AnirudhS  Fixed both GetRunTimes methods to return
//                  the right success codes.
//              20-Nov-01 ShBrown   Switched to use standard NT build versioning
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"
#include "defines.hxx"
#include "misc.hxx"
#include <ntverp.h>
#include <strsafe.h>

//
// Increment the following if the job object file format is changed in an incompatible fashion.
//
#define JOB_OBJ_FORMAT_VERSION      1


//+----------------------------------------------------------------------------
//
//  Member:     CJob::CJob
//
//  Synopsis:   constructor
//
//-----------------------------------------------------------------------------
CJob::CJob(void) :
    m_wVersion(MAKEWORD(VER_PRODUCTMINORVERSION, VER_PRODUCTMAJORVERSION)),
    m_wFileObjVer(JOB_OBJ_FORMAT_VERSION),
    m_wTriggerOffset(0),
    m_wErrorRetryCount(0),
    m_wErrorRetryInterval(0),
    m_cRunningInstances(0),
    m_wIdleWait(SCH_DEFAULT_IDLE_TIME),
    m_wIdleDeadline(SCH_DEFAULT_IDLE_DEADLINE),
    m_dwPriority(NORMAL_PRIORITY_CLASS),
    m_dwMaxRunTime(MAX_RUN_TIME_DEFAULT),
    m_ExitCode(0),
    m_hrStatus(SCHED_S_TASK_NOT_SCHEDULED),
    m_rgFlags(JOB_I_FLAG_NO_RUN_PROP_CHANGE),        // The task is not yet dirty
    m_rgTaskFlags(0),
    m_pwszApplicationName(NULL),
    m_pwszParameters(NULL),
    m_pwszWorkingDirectory(NULL),
    m_pwszCreator(NULL),
    m_pwszComment(NULL),
    m_cbTaskData(0),
    m_pbTaskData(NULL),
    m_cReserved(0),
    m_pbReserved(NULL),
    m_hrStartError(SCHED_S_TASK_HAS_NOT_RUN),
    m_pIJobTypeInfo(NULL),
    m_cReferences(1),
    m_pAccountInfo(NULL),
    m_pbSignature(NULL),
    m_ptszFileName(NULL),
    m_fFileCreated(FALSE)
{
    //TRACE(CJob, CJob);

    UUID uuidNull = {0};
    m_uuidJob = uuidNull;

    SYSTEMTIME stNull = {0};
    m_stMostRecentRunTime = stNull;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::~CJob
//
//  Synopsis:   destructor
//
//-----------------------------------------------------------------------------
CJob::~CJob(void)
{
    //TRACE(CJob, ~CJob);
    FreeProperties();
    if (m_pIJobTypeInfo != NULL)
    {
        m_pIJobTypeInfo->Release();
    }
    delete m_ptszFileName;

    if (m_pAccountInfo != NULL)
    {
        ZERO_PASSWORD(m_pAccountInfo->pwszPassword);    // NULL is handled.
        delete m_pAccountInfo->pwszAccount;
        delete m_pAccountInfo->pwszPassword;
        delete m_pAccountInfo;
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::ITask::GetRunTimes
//
//  Synopsis:   Return a list of run times for this job that fall between the
//              bracketing times inclusively.
//
//  Arguments:  [pstBegin]     - the start of the bracketing period
//              [pstEnd]       - the end of the bracketing period, may be NULL
//              [pCount]       - On entry, points to the number of run times
//                               to retrieve.  This must be a number between 1
//                               and TASK_MAX_RUN_TIMES.  On exit, points to
//                               the number of run times actually retrieved.
//              [rgstJobTimes] - the returned array of SYSTEMTIME structures
//
//  Returns:    S_OK: the requested number of run times are returned.
//              S_FALSE: fewer than the requested number of run times are
//                  returned. (More precisely: the task has valid time-based
//                  triggers, but the number of run times during the specified
//                  time bracket is less than the number of run times requested.
//                  (This includes the case of no event triggers and zero run
//                  times during that time bracket.))
//              SCHED_S_EVENT_TRIGGER: no time-based triggers will cause the
//                  task to run during the specified time bracket, but event
//                  triggers may (note that event triggers have no set run
//                  times).  (In this case *pCount is set to 0)
//              SCHED_S_TASK_NO_VALID_TRIGGERS: the task is enabled but has no
//                  valid triggers.
//              SCHED_S_TASK_DISABLED: the task is disabled.
//              E_INVALIDARG: the arguments are not valid.
//              E_OUTOFMEMORY: not enough memory is available.
//
//  Notes:      The job time list is callee allocated and caller freed. The
//              caller must use CoTaskMemFree to free this list.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetRunTimes(const LPSYSTEMTIME pstBegin, const LPSYSTEMTIME pstEnd,
                  WORD * pCount, LPSYSTEMTIME * rgstJobTimes)
{
    TRACE(CJob, GetRunTimes);
    HRESULT hr;

    WORD cLimit = *pCount;
    if (cLimit < 1 || cLimit > TASK_MAX_RUN_TIMES)
    {
        return E_INVALIDARG;
    }

    *rgstJobTimes = NULL;

    //
    // Get the list of run times.
    //
    CTimeRunList RunList;
    *pCount = 0;    // Number of elements in RunList

    hr = GetRunTimesP(pstBegin, pstEnd, pCount, cLimit, &RunList, NULL);
    if (hr != S_OK)
    {
        *pCount = 0;
        return hr;
    }
    schAssert(*pCount <= cLimit);

    //
    // Convert the time list to an array of SYSTEMTIMEs.
    //
#if DBG
    WORD cCountBefore = *pCount;
#endif
    hr = RunList.MakeSysTimeArray(rgstJobTimes, pCount);
    if (SUCCEEDED(hr))
    {
        schAssert(*pCount == cCountBefore);

        hr = (*pCount < cLimit) ? S_FALSE : S_OK;
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetRunTimesP, private
//
//  Synopsis:   Computes a set of run times for this job that fall between the
//              bracketing times inclusively, and adds them to the run list.
//
//  Arguments:  [pstBegin] - the start of the bracketing period
//              [pstEnd]   - the end of the bracketing period, may be NULL
//              [pCount]   - On both entry and exit, points to the number of
//                            run times in the list.
//              [cLimit]   - the maximum number of CRun objects that the list
//                            may contain.
//              [pRunList] - the list of run time objects, can be
//                            NULL if just checking to see if there will be
//                            *any* runs.  (Note: If it's NULL, duplicate run
//                            times are not detected, so pCount may be over-
//                            estimated on return.)
//              [ptszShortName] - the folder-relative job name.
//
//  Returns:    S_OK: Some (zero or more) runs have been added to the list.
//              SCHED_S_EVENT_TRIGGER: the job has an event trigger and none
//                                     of the other triggers had runs.
//              SCHED_S_TASK_NO_VALID_TRIGGERS: the triggers are disabled or
//                                              not set.
//              SCHED_S_TASK_DISABLED: the job is disabled.
//
//  Notes:      The job time list is callee allocated and caller freed. The
//              caller must use FreeList to free this list.
//-----------------------------------------------------------------------------
HRESULT
CJob::GetRunTimesP(const SYSTEMTIME * pstBegin, const SYSTEMTIME * pstEnd,
                   WORD * pCount, WORD cLimit, CTimeRunList * pRunList,
                   LPTSTR ptszShortName)
{
    HRESULT hr;

    schAssert(cLimit > 0);  // If cLimit is 0, it's not clear what to return
    schAssert(cLimit <= TASK_MAX_RUN_TIMES);
    schAssert(*pCount <= cLimit);

    //
    // Test for conditions that would prevent a run time from being returned.
    //
    if (IsFlagSet(TASK_FLAG_DISABLED))
    {
        return SCHED_S_TASK_DISABLED;
    }

    WORD cTriggers = m_Triggers.GetCount();

    //
    // Don't need any of the internal job flags for run instance processing.
    // That bit space is used for run processing specific flags defined in
    // runobj.hxx.
    //
    DWORD rgFlags = GetUserFlags();

    BOOL fEventTriggerFound = FALSE;
    BOOL fTimeTriggerFound = FALSE;

    //
    // Loop over the triggers.
    //
    for (WORD i = 0; i < cTriggers; i++)
    {
        hr = ::GetTriggerRunTimes(m_Triggers[i],
                                  pstBegin,
                                  pstEnd,
                                  pCount,
                                  cLimit,
                                  pRunList,
                                  ptszShortName,
                                  rgFlags,
                                  m_dwMaxRunTime,
                                  m_wIdleWait,
                                  m_wIdleDeadline);

        if (FAILED(hr))
        {
            ERR_OUT("CJob::GetRunTimes, ::GetRunTimes", hr);
            return(hr);
        }

        if (hr == SCHED_S_EVENT_TRIGGER)
        {
            fEventTriggerFound = TRUE;
        }
        else if (hr == S_OK)
        {
            fTimeTriggerFound = TRUE;

            if (*pCount >= cLimit && pRunList == NULL)
            {
                //
                // Special case where all we want is to test *if* there are runs,
                // and don't need the run times. Otherwise, we examine all
                // triggers because they won't return run times in any particular
                // order.
                //
                break;
            }
        }
    }

    //
    // Summarize the results in the return code
    //
    if (fTimeTriggerFound)
    {
        if (*pCount == 0 && fEventTriggerFound)
        {
            hr = SCHED_S_EVENT_TRIGGER;
            // (BUGBUG Here, we are assuming that *pCount was 0 initially.
            // Maybe add this to the comments and assertions at the start
            // of this function.  However, this might not be necessary if
            // *pCount is made a member of CRunList, as it should be.)
        }
        else
        {
            hr = S_OK;
        }
    }
    else if (fEventTriggerFound)
    {
        hr = SCHED_S_EVENT_TRIGGER;
    }
    else
    {
        hr = SCHED_S_TASK_NO_VALID_TRIGGERS;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Synopsis:   Skips past the preceeding data and loads only the triggers
//
//  Notes:      This method will fail if not preceeded at some time during
//              the job object's lifetime by a call to LoadP.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::LoadTriggers(void)
{
    if (m_ptszFileName == NULL || m_wTriggerOffset == 0)
    {
        return E_FAIL;
    }

    //
    // Open the file.
    //
    HANDLE  hFile = NULL;
    HRESULT hr = OpenFileWithRetry(m_ptszFileName, GENERIC_READ, FILE_SHARE_READ, &hFile);
    if (FAILED(hr))
    {
        ERR_OUT("CJob::LoadTriggers, file open", hr);
        return hr;
    }

    //
    // Move to the trigger data.
    //
    DWORD dwBytes;

    dwBytes = SetFilePointer(hFile, m_wTriggerOffset, NULL, FILE_BEGIN);
    if (dwBytes == 0xffffffff)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::LoadTriggers, move to trigger data", hr);
        goto cleanup;
    }

    //
    // Load triggers.
    //

    hr = this->_LoadTriggers(hFile);

cleanup:
    //
    // Close the file.
    //
    CloseHandle(hFile);
    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_LoadTriggersFromBuffer, private
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_LoadTriggersFromBuffer(CInputBuffer * pBuf)
{
    HRESULT hr = S_OK;
    WORD    cTriggers;

    // Read trigger count.
    //
    if (!pBuf->Read(&cTriggers, sizeof cTriggers))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return hr;
    }

    // Verify buffer contains that many triggers.
    //
    BYTE *pTriggers = pBuf->CurrentPosition();  // save current position
    if (!pBuf->Advance(cTriggers * sizeof TASK_TRIGGER))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return hr;
    }

    // Copy triggers into a properly aligned array.
    // CODEWORK: Align them in the original buffer instead of allocating
    // a separate one.
    //
    hr = m_Triggers.AllocAndCopy(cTriggers, pTriggers);
    if (FAILED(hr))
    {
        CHECK_HRESULT(hr);
        return hr;
    }

    if (cTriggers)
    {
        //
        // BUGBUG: temporary, remove the next time the job file format
        // is revised.
        //
        TASK_TRIGGER * ajt = m_Triggers.GetArray();
        for (WORD i = 0; i < cTriggers; i++)
        {
            ajt[i].Reserved1 = i;
        }
        //
        // end of temporary code.
        //

        this->SetFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }
    else
    {
        //
        // No triggers - clear trigger flag.
        //
        this->ClearFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_LoadTriggers, private
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_LoadTriggers(HANDLE hFile)
{
    HRESULT hr = S_OK;
    DWORD   dwRead;
    WORD    cTriggers;

    // Read trigger count.
    //
    if (!ReadFile(hFile, &cTriggers, sizeof(cTriggers), &dwRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (dwRead != sizeof(cTriggers))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return(hr);
    }

    // Free existing trigger array.
    //
    m_Triggers.FreeArray();

    // Get on with load.
    //
    if (cTriggers)
    {
        TASK_TRIGGER * ajt = (TASK_TRIGGER *)
            LocalAlloc(LMEM_FIXED, cTriggers * sizeof TASK_TRIGGER);
        if (ajt == NULL)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return hr;
        }

        if (!ReadFile(hFile, ajt, cTriggers * sizeof TASK_TRIGGER, &dwRead,
                      NULL))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            LocalFree(ajt);
            return hr;
        }

        if (dwRead != cTriggers * sizeof TASK_TRIGGER)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            CHECK_HRESULT(hr);
            LocalFree(ajt);
            return hr;
        }

        for (WORD i = 0; i < cTriggers; i++)
        {
            //
            // BUGBUG: temporary, remove the next time the job file format
            // is revised.
            //
            ajt[i].Reserved1 = i;
            //
            // end of temporary code.
            //
        }

        m_Triggers.SetArray(cTriggers, ajt);

        this->SetFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }
    else
    {
        //
        // No triggers - clear trigger flag.
        //

        this->ClearFlag(JOB_I_FLAG_HAS_TRIGGERS);
    }

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::_SaveTriggers, private
//
//  Synopsis:
//
//  Arguments:  None.
//
//  Returns:
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::_SaveTriggers(HANDLE hFile)
{
    HRESULT hr = S_OK;
    DWORD   dwWritten;
    DWORD   cTriggerDataSize;
    WORD    cTriggers = m_Triggers.GetCount();

    // Write trigger count.
    //
    if (!WriteFile(hFile, &cTriggers, sizeof(cTriggers), &dwWritten, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (dwWritten != sizeof(cTriggers))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
        return(hr);
    }

    // Write trigger data.
    //
    if (!WriteFile(hFile,
                   m_Triggers.GetArray(),
                   cTriggerDataSize = sizeof(TASK_TRIGGER) * cTriggers,
                   &dwWritten,
                   NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    if (dwWritten != cTriggerDataSize)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        CHECK_HRESULT(hr);
    }

    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetTriggersDirty, protected
//
//  Synopsis:   Sets the triggers-dirty flag and clears the unchanged and
//              NetSchedule flags.
//
//  Notes:      IPersistFile::Save will call UpdateJobState if the trigger-
//              dirty flag is set. UpdateJobState updates the job's status
//              property.
//-----------------------------------------------------------------------------
void
CJob::SetTriggersDirty(void)
{
    //
    // The JOB_I_FLAG_TRIGGERS_DIRTY flag indicates the in-core object does
    // not match the persistent object. This flag is not saved persistently; it
    // is cleared on a Save.
    //
    SetFlag(JOB_I_FLAG_TRIGGERS_DIRTY);

    //
    // We set this flag here so that a rebuild will occur due to the possible
    // run time changes introduced by the trigger change.
    //
    SetFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
    ClearFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);
}

// Class members - *not* part of any interface.
//
//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetTrigger, public
//
//  Synopsis:
//
//  Arguments:  [] -
//
//  Returns:
//
//  Notes:
//-----------------------------------------------------------------------------
HRESULT
CJob::SetTrigger(WORD iTrigger, PTASK_TRIGGER pTrigger)
{
    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    schAssert(pjt != NULL);

    if (pjt == NULL)
    {
        CHECK_HRESULT(E_FAIL);
        return(E_FAIL);
    }

    //
    // Check version. Do not modify triggers created by a later version.
    //
    // BUGBUG : This doesn't seem quite right.
    //

    if (pTrigger->cbTriggerSize != sizeof(TASK_TRIGGER))
    {
        CHECK_HRESULT(E_INVALIDARG);
        return(E_INVALIDARG);
    }

    //
    // Data validation.
    //
    if (pTrigger->wStartHour > JOB_MAX_HOUR     ||
        pTrigger->wStartMinute > JOB_MAX_MINUTE)
    {
        return E_INVALIDARG;
    }
    if (!IsValidDate(pTrigger->wBeginMonth,
                     pTrigger->wBeginDay,
                     pTrigger->wBeginYear))
    {
        return E_INVALIDARG;
    }
    if (pTrigger->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE &&
        !IsValidDate(pTrigger->wEndMonth,
                     pTrigger->wEndDay,
                     pTrigger->wEndYear))
    {
        return E_INVALIDARG;
    }
    //
    // If either MinutesDuration or MinutesInterval is nonzero, then
    // MinutesInterval must be less than MinutesDuration.
    //
    if ((pTrigger->MinutesDuration > 0 || pTrigger->MinutesInterval > 0) &&
        (pTrigger->MinutesInterval >= pTrigger->MinutesDuration))
    {
        return E_INVALIDARG;
    }

    //
    // Type consistency validation and value assignment.
    //
    switch (pTrigger->TriggerType)
    {
    case TASK_TIME_TRIGGER_DAILY:
        if (pTrigger->Type.Daily.DaysInterval == 0)
        {
            return E_INVALIDARG;
        }
        pjt->Type.Daily.DaysInterval = pTrigger->Type.Daily.DaysInterval;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        if (pTrigger->Type.Weekly.WeeksInterval == 0    ||
            pTrigger->Type.Weekly.rgfDaysOfTheWeek == 0 ||
            pTrigger->Type.Weekly.rgfDaysOfTheWeek  > JOB_RGFDOW_MAX)
        {
            return E_INVALIDARG;
        }
        pjt->Type.Weekly.WeeksInterval = pTrigger->Type.Weekly.WeeksInterval;
        pjt->Type.Weekly.rgfDaysOfTheWeek =
                                      pTrigger->Type.Weekly.rgfDaysOfTheWeek;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        if (!IsValidMonthlyDateTrigger(pTrigger))
        {
            return E_INVALIDARG;
        }

        pjt->Type.MonthlyDate.rgfDays = pTrigger->Type.MonthlyDate.rgfDays;
        pjt->Type.MonthlyDate.rgfMonths = pTrigger->Type.MonthlyDate.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        if (pTrigger->Type.MonthlyDOW.wWhichWeek < TASK_FIRST_WEEK       ||
            pTrigger->Type.MonthlyDOW.wWhichWeek > TASK_LAST_WEEK        ||
            pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek == 0             ||
            pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek > JOB_RGFDOW_MAX ||
            pTrigger->Type.MonthlyDOW.rgfMonths == 0                    ||
            pTrigger->Type.MonthlyDOW.rgfMonths > JOB_RGFMONTHS_MAX)
        {
            return E_INVALIDARG;
        }
        pjt->Type.MonthlyDOW.wWhichWeek = pTrigger->Type.MonthlyDOW.wWhichWeek;
        pjt->Type.MonthlyDOW.rgfDaysOfTheWeek =
                                    pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek;
        pjt->Type.MonthlyDOW.rgfMonths = pTrigger->Type.MonthlyDOW.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_ONCE:
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
// Not yet implemented:
//    case TASK_EVENT_TRIGGER_ON_APM_RESUME:
        //
        // No type-specific data for these.
        //
        break;

    default:
        return E_INVALIDARG;
    }
    pjt->TriggerType      = pTrigger->TriggerType;
    pjt->cbTriggerSize    = pTrigger->cbTriggerSize;
    pjt->wBeginYear       = pTrigger->wBeginYear;
    pjt->wBeginMonth      = pTrigger->wBeginMonth;
    pjt->wBeginDay        = pTrigger->wBeginDay;
    pjt->wEndYear         = pTrigger->wEndYear;
    pjt->wEndMonth        = pTrigger->wEndMonth;
    pjt->wEndDay          = pTrigger->wEndDay;
    pjt->wStartHour       = pTrigger->wStartHour;
    pjt->wStartMinute     = pTrigger->wStartMinute;
    pjt->MinutesDuration  = pTrigger->MinutesDuration;
    pjt->MinutesInterval  = pTrigger->MinutesInterval;

    //
    // The upper word of pjt->rgFlags is reserved, so set only the lower
    // word and retain the upper word values.
    //
    pjt->rgFlags &= JOB_INTERNAL_FLAG_MASK;
    pjt->rgFlags = pTrigger->rgFlags & ~JOB_INTERNAL_FLAG_MASK;

    //
    // This call explicitly set the trigger values, so clear the
    // JOB_TRIGGER_I_FLAG_NOT_SET bit.
    //
    pjt->rgFlags &= ~JOB_TRIGGER_I_FLAG_NOT_SET;

    this->SetTriggersDirty();

    //
    // If GetNextRunTime returned SCHED_S_TASK_NO_MORE_RUNS prior to this
    // call, then JOB_I_FLAG_NO_MORE_RUNS is set. Clear it and then call
    // UpdateJobState to bring the status current.
    //

    this->ClearFlag(JOB_I_FLAG_NO_MORE_RUNS);

    this->UpdateJobState(FALSE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetTrigger
//
//  Synopsis:
//
//  Arguments:  [] -
//
//  Returns:    HRESULTS
//
//  Notes:
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetTrigger(WORD iTrigger, PTASK_TRIGGER pTrigger)
{
    TASK_TRIGGER * pjt = this->_GetTrigger(iTrigger);

    schAssert(pjt != NULL);

    if (pjt == NULL)
    {
        CHECK_HRESULT(E_FAIL);
        return(E_FAIL);
    }

    //
    // Do trigger type specific processing.
    //
    switch (pjt->TriggerType)
    {
    case TASK_TIME_TRIGGER_DAILY:
        pTrigger->Type.Daily.DaysInterval = pjt->Type.Daily.DaysInterval;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        pTrigger->Type.Weekly.WeeksInterval = pjt->Type.Weekly.WeeksInterval;
        pTrigger->Type.Weekly.rgfDaysOfTheWeek =
                                              pjt->Type.Weekly.rgfDaysOfTheWeek;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        pTrigger->Type.MonthlyDate.rgfDays = pjt->Type.MonthlyDate.rgfDays;
        pTrigger->Type.MonthlyDate.rgfMonths = pjt->Type.MonthlyDate.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        pTrigger->Type.MonthlyDOW.wWhichWeek = pjt->Type.MonthlyDOW.wWhichWeek;
        pTrigger->Type.MonthlyDOW.rgfDaysOfTheWeek =
                                            pjt->Type.MonthlyDOW.rgfDaysOfTheWeek;
        pTrigger->Type.MonthlyDOW.rgfMonths = pjt->Type.MonthlyDOW.rgfMonths;
        break;

    case TASK_TIME_TRIGGER_ONCE:
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
// Not yet implemented:
//    case TASK_EVENT_TRIGGER_ON_APM_RESUME:
        //
        // No trigger-specific data.
        //
        break;

    default:
        //
        // In future revisions, different trigger types would be handled
        // here.
        //
        return E_INVALIDARG;
    }

    pTrigger->TriggerType       = pjt->TriggerType;
    pTrigger->cbTriggerSize     = pjt->cbTriggerSize;
    pTrigger->wBeginYear        = pjt->wBeginYear;
    pTrigger->wBeginMonth       = pjt->wBeginMonth;
    pTrigger->wBeginDay         = pjt->wBeginDay;
    pTrigger->wEndYear          = pjt->wEndYear;
    pTrigger->wEndMonth         = pjt->wEndMonth;
    pTrigger->wEndDay           = pjt->wEndDay;
    pTrigger->wStartHour        = pjt->wStartHour;
    pTrigger->wStartMinute      = pjt->wStartMinute;
    pTrigger->MinutesDuration   = pjt->MinutesDuration;
    pTrigger->MinutesInterval   = pjt->MinutesInterval;
    pTrigger->rgFlags           = pjt->rgFlags;
    pTrigger->Reserved1         = 0;
    pTrigger->Reserved2         = pjt->Reserved2;
    pTrigger->wRandomMinutesInterval = pjt->wRandomMinutesInterval;

    //
    // If this trigger has not been set to non-default values, it will have
    // the flag bit JOB_TRIGGER_I_FLAG_NOT_SET set. Since this is an internal
    // value, replace it with TASK_TRIGGER_FLAG_DISABLED.
    //
    if (pTrigger->rgFlags & JOB_TRIGGER_I_FLAG_NOT_SET)
    {
        pTrigger->rgFlags &= ~JOB_INTERNAL_FLAG_MASK;
        pTrigger->rgFlags |= TASK_TRIGGER_FLAG_DISABLED;
    }
    else
    {
        pTrigger->rgFlags &= ~JOB_INTERNAL_FLAG_MASK;
    }

    //
    // Struct version check.
    //
    // In future revisions, different trigger structs would be handled
    // here.
    //
    //if (pTrigger->cbTriggerSize != sizeof(TASK_TRIGGER))
    //{
    //    ;
    //}

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetErrorRetryCount, public
//
//  Synopsis:   Set the number of times the service should attempt to run a
//              job that is failing to start.
//
//  Arguments:  [wRetryCount] - zero, of course, means don't retry.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SetErrorRetryCount(WORD wRetryCount)
{
    //TRACE(CJob, SetErrorRetryCount);

    m_wErrorRetryCount = wRetryCount;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetErrorRetryCount, public
//
//  Synopsis:   Get the number of times the service will attempt to run a
//              job that is failing to start.
//
//  Arguments:  [pwRetryCount] - the retry count.
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetErrorRetryCount(WORD * pwRetryCount)
{
    //TRACE(CJob, GetErrorRetryCount);

    *pwRetryCount = m_wErrorRetryCount;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetIdleWait, public
//
//  Synopsis:   Set the time to wait until idle, in minutes. This is the
//              amount of time after the last user keyboard or mouse moverment
//              until the idle state will be entered for this task.
//
//  Arguments:  [wIdleMinutes]     - the time to wait till idle in minutes.
//              [wDeadlineMinutes] - minutes to wait for [wIdleMinutes] of
//                                    idleness
//
//  Returns:    S_OK
//
//  Notes:      The task will wait for up to [wDeadlineMinutes] for an idle
//              period of [wIdleMinutes] to occur.
//
//              If [wDeadlineMinutes] is 0, the task will not run unless the
//              computer has been idle for at least [wIdleMinutes] by the
//              task's start time.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SetIdleWait(WORD wIdleMinutes, WORD wDeadlineMinutes)
{
    TRACE3(CJob, SetIdleWait);

    m_wIdleWait = wIdleMinutes;
    m_wIdleDeadline = wDeadlineMinutes;

    // Cause a wait list rebuild
    SetFlag(JOB_I_FLAG_PROPERTIES_DIRTY | JOB_I_FLAG_RUN_PROP_CHANGE);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetIdleWait, public
//
//  Synopsis:   Get the idle time requirement and deadline, in minutes.
//
//  Arguments:  [pwMinutes]  - the returned idle time.
//              [pwDeadline] - the returned idle deadline
//
//  Returns:    S_OK
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetIdleWait(WORD * pwMinutes, WORD * pwDeadline)
{
    TRACE3(CJob, GetIdleWait);

    *pwMinutes = m_wIdleWait;
    *pwDeadline = m_wIdleDeadline;

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SetErrorRetryInterval, public
//
//  Synopsis:   Set the interval, in minutes, between successive retries.
//
//  Arguments:  [wRetryInterval] - the retry interval.
//
//  Returns:    E_NOTIMPL
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SetErrorRetryInterval(WORD wRetryInterval)
{
    //TRACE(CJob, SetErrorRetryInterval);

    m_wErrorRetryInterval = wRetryInterval;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetErrorRetryInterval, public
//
//  Synopsis:   Get the interval, in minutes, between successive retries.
//
//  Arguments:  [pwRetryInterval] - the returned interval.
//
//  Returns:    E_NOTIMPL
//
//-----------------------------------------------------------------------------
HRESULT
CJob::GetErrorRetryInterval(WORD * pwRetryInterval)
{
    //TRACE(CJob, GetErrorRetryInterval);

    *pwRetryInterval = m_wErrorRetryInterval;

    //
    // Not implemented yet
    //
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\triggers.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       triggers.cxx
//
//  Contents:   trigger object and trigger collection object
//
//  Classes:    CTrigger and CBagOTriggers
//
//  History:    27-June-95 EricB created
//              11-Nov-96  AnirudhS  GetRunTimes: Changed return codes; various
//                  other fixes.
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"
#include <StrSafe.h>

// prototypes for local functions:
HRESULT AddToList(FILETIME, FILETIME, CRun *, WORD *);
void AddDaysToFileTime(LPFILETIME pft, WORD Days);

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::CTrigger
//
//  Synopsis:   Ctor
//
//-----------------------------------------------------------------------------
CTrigger::CTrigger(WORD iTrigger, CJob * pJob)
    : m_iTrigger(iTrigger),
      m_pJob(pJob),
      m_cReferences(1)
{
    schAssert(m_pJob != NULL);
    m_pJob->AddRef();
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::~CTrigger
//
//  Synopsis:   Dtor
//
//-----------------------------------------------------------------------------
CTrigger::~CTrigger(void)
{
    m_pJob->Release();
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::ITaskTrigger::GetTriggerString
//
//  Synopsis:   Returns a string representation of the trigger
//
//  Arguments:  [ppwszTrigger] - the place to return a string pointer
//
//  Returns:    HRESULTS
//
//  Notes:      The string is callee allocated and caller freed with
//              CoTaskMemFree.
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::GetTriggerString(LPWSTR * ppwszTrigger)
{
    //TRACE(CTrigger, GetTriggerString);
    return(m_pJob->GetTriggerString(m_iTrigger, ppwszTrigger));
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::ITaskTrigger::SetTrigger, public
//
//  Synopsis:   Sets the trigger values.
//
//  Arguments:  [pTrigger] - the struct containing the values
//
//  Returns:    HRESULTS
//
//  Notes:
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::SetTrigger(const PTASK_TRIGGER pTrigger)
{
    TRACE(CTrigger, SetTrigger);

	if( NULL == pTrigger )
	{
		return E_INVALIDARG;
	}
    //
    // Check struct version.
    //

    if (pTrigger->cbTriggerSize != sizeof(TASK_TRIGGER))
    {
        //
        // Don't attempt to modify triggers created by a later revision.
        //

        return E_INVALIDARG;
    }

    return(m_pJob->SetTrigger(m_iTrigger, pTrigger));
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::ITaskTrigger::GetTrigger
//
//  Synopsis:   Gets the trigger values.
//
//  Arguments:  [pTrigger] - pointer to caller supplied trigger structure
//
//  Returns:    HRESULTS
//
//  Notes:      pTrigger->cbTriggerSize must be set to sizeof(TASK_TRIGGER) on
//              function entry. This provides for trigger struct versioning.
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::GetTrigger(PTASK_TRIGGER pTrigger)
{
    //TRACE(CTrigger, GetTrigger);
	if( NULL == pTrigger )
	{
		return E_INVALIDARG;
	}

    return(m_pJob->GetTrigger(m_iTrigger, pTrigger));
}

//+----------------------------------------------------------------------------
//
//  Functions:  AddDaysToFileTime
//
//  Synopsis:   Convert the days value to filetime units and add it to
//              the filetime.
//
//-----------------------------------------------------------------------------
void
AddDaysToFileTime(LPFILETIME pft, WORD Days)
{
    if (!Days)
    {
        return; // Nothing to do.
    }
    //
    // ft = ft + Days * FILETIMES_PER_DAY;
    //
    ULARGE_INTEGER uli, uliSum;
    uli.LowPart  = pft->dwLowDateTime;
    uli.HighPart = pft->dwHighDateTime;
    uliSum.QuadPart = uli.QuadPart + (__int64)Days * FILETIMES_PER_DAY;
    pft->dwLowDateTime  = uliSum.LowPart;
    pft->dwHighDateTime = uliSum.HighPart;
}

//+----------------------------------------------------------------------------
//
//  Functions:  AddMinutesToFileTime
//
//  Synopsis:   Convert the minutes value to filetime units and add it to
//              the filetime.
//
//-----------------------------------------------------------------------------
void
AddMinutesToFileTime(LPFILETIME pft, DWORD Minutes)
{
    if (!Minutes)
    {
        return; // Nothing to do.
    }
    //
    // ft = ft + Minutes * FILETIMES_PER_MINUTE;
    //
    ULARGE_INTEGER uli, uliSum;
    uli.LowPart  = pft->dwLowDateTime;
    uli.HighPart = pft->dwHighDateTime;
    uliSum.QuadPart = uli.QuadPart + (__int64)Minutes * FILETIMES_PER_MINUTE;
    pft->dwLowDateTime  = uliSum.LowPart;
    pft->dwHighDateTime = uliSum.HighPart;
}

//+----------------------------------------------------------------------------
//
//  Function:   GetTriggerRunTimes
//
//  Synopsis:   Computes a set of run times for this trigger that fall between
//              the bracketing times -- pstBracketBegin is inclusive,
//              pstBracketEnd is exclusive -- and merges them with the list of
//              run times passed in.
//
//  Arguments:  [jt]              - Inspected trigger.
//              [pstBracketBegin] - the start of the bracketing period
//              [pstBracketEnd]   - the end of the bracketing period, may
//                                  be NULL
//              [pCount]          - on both entry and exit, points to the
//                                  number of CRun elements in the list.
//                                  CODEWORK: Make this a private member of
//                                  CRunList.
//              [cLimit]          - the maximum number of elements that the
//                                  list may grow to.
//              [pRunList]        - the list of run time objects, can
//                                  be NULL if just checking to see if there
//                                  will be *any* runs.  (Note: If it's NULL,
//                                  duplicate run times are not detected, so
//                                  pCount may be overestimated on return.)
//              [ptszJobName],
//              [dwJobFlags],
//              [dwMaxRunTime]    - the last 3 params are used for the CRun
//                                  objects as their member data.
//              [wIdleWait]       - the job's idle wait period
//              [wIdleDeadline]   - time to wait for idle wait period
//
//  Returns:    S_OK: The trigger is a time-based trigger and is enabled,
//                  and zero or more of its run times have been added to the
//                  list (subject to cLimit and the bracketing period); or,
//                  the trigger is an event trigger but will expire before
//                  the bracketing period.
//              SCHED_S_EVENT_TRIGGER: this is an event trigger that will be
//                  active (not expired) during the bracketing period.
//              SCHED_S_TASK_NO_VALID_TRIGGERS: the trigger is disabled or
//                                              not set.
//              Failure HRESULTs: Other failures.
//
//  Notes:      The trigger time list is callee allocated and caller freed. The
//              caller must use delete to free this list.
//-----------------------------------------------------------------------------
HRESULT
GetTriggerRunTimes(
    TASK_TRIGGER & jt,
    const SYSTEMTIME *  pstBracketBegin,
    const SYSTEMTIME *  pstBracketEnd,
    WORD *         pCount,
    WORD           cLimit,
    CTimeRunList * pRunList,
    LPTSTR         ptszJobName,
    DWORD          dwJobFlags,
    DWORD          dwMaxRunTime,
    WORD           wIdleWait,
    WORD           wIdleDeadline)
{
    TRACE_FUNCTION3(GetRunTimes);
    DWORD dwRet;

    schAssert(cLimit > 0);  // If cLimit is 0, it's not clear what to return
    schAssert(cLimit <= TASK_MAX_RUN_TIMES);
    schAssert(*pCount <= cLimit);

    //
    // Return if this trigger hasn't been set or if it is disabled.
    //
    if (jt.rgFlags & JOB_TRIGGER_I_FLAG_NOT_SET ||
        jt.rgFlags & TASK_TRIGGER_FLAG_DISABLED)
    {
        return SCHED_S_TASK_NO_VALID_TRIGGERS;
    }

    //
    // Event triggers don't have set run times.
    //
    switch (jt.TriggerType)
    {
    case TASK_EVENT_TRIGGER_ON_IDLE:
    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
    case TASK_EVENT_TRIGGER_AT_LOGON:
    // Not yet implemented:
    // case TASK_EVENT_TRIGGER_ON_APM_RESUME:

        //
        // Check if the trigger expires before the beginning of the bracket
        //
        if (jt.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
        {
            SYSTEMTIME stEnd;
            stEnd.wYear  = jt.wEndYear;
            stEnd.wMonth = jt.wEndMonth;
            stEnd.wDay   = jt.wEndDay;
            // IsFirstDateEarlier ignores other fields

            if (IsFirstDateEarlier(&stEnd, pstBracketBegin))
            {
                return S_OK;
            }
        }

        return SCHED_S_EVENT_TRIGGER;
    }

    SYSTEMTIME st = { 0, 0, 0, 0, 0, 0, 0, 0 };
    //
    // Convert to FILETIMEs and check if the trigger lifetime intersects the
    // requested run bracket.
    // If there is a trigger end date, then one of three conditions holds:
    // a. *pstBracketBegin > jt.End{Month/Day/Year}
    //    result, no runs
    // b. *pstBracketBegin < jt.End{Month/Day/Year} < *pstBracketEnd
    //    result, return all runs between *pstBracketBegin and
    //    jt.End{Month/Day/Year}
    // c. jt.End{Month/Day/Year} > *pstBracketEnd
    //    result, return all runs between *pstBracketBegin and *pstBracketEnd
    // In addition, if there is a bracket end we check:
    // d. *pstBracketEnd <= jt.Begin{Month/Day/Year}
    //    result, no runs
    //
    FILETIME ftTriggerBegin, ftTriggerEnd, ftBracketBegin, ftBracketEnd;

    if (!SystemTimeToFileTime(pstBracketBegin, &ftBracketBegin))
    {
        dwRet = GetLastError();
        ERR_OUT("GetRunTimes, convert pstBracketBegin", dwRet);
        return HRESULT_FROM_WIN32(dwRet);
    }

    st.wYear   = jt.wBeginYear;
    st.wMonth  = jt.wBeginMonth;
    st.wDay    = jt.wBeginDay;
    st.wHour   = jt.wStartHour;
    st.wMinute = jt.wStartMinute;

    if (!SystemTimeToFileTime(&st, &ftTriggerBegin))
    {
        dwRet = GetLastError();
        ERR_OUT("GetRunTimes, convert TriggerBegin", dwRet);
        return HRESULT_FROM_WIN32(dwRet);
    }

    st.wHour   = 23;    // set to the last hour of the day.
    st.wMinute = 59;    // set to the last minute of the day.
    st.wSecond = 59;    // set to the last second of the day.
	st.wMilliseconds = 0;

    if (jt.rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
    {
        st.wYear  = jt.wEndYear;
        st.wMonth = jt.wEndMonth;
        st.wDay   = jt.wEndDay;

        if (!SystemTimeToFileTime(&st, &ftTriggerEnd))
        {
            dwRet = GetLastError();
            ERR_OUT("GetRunTimes, convert TriggerEnd", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }

        if (CompareFileTime(&ftTriggerEnd, &ftBracketBegin) < 0)
        {
            //
            // Trigger end time is before the run bracket begin time (case a.).
            //
            return S_OK;
        }
    }
    else    // no trigger end date.
    {
        //
        // Create an end date that is reasonably large.
        // BUGBUG Change this to MAX_FILETIME - but should be tested.
        //
        st.wMonth = 12;
        st.wDay = 31;
        st.wYear = 2200;

        if (!SystemTimeToFileTime(&st, &ftTriggerEnd))
        {
            dwRet = GetLastError();
            ERR_OUT("GetRunTimes, convert TriggerEnd", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }
    }

    if (pstBracketEnd)
    {
        if (!SystemTimeToFileTime(pstBracketEnd, &ftBracketEnd))
        {
            dwRet = GetLastError();
            ERR_OUT("GetRunTimes, convert pstBracketEnd", dwRet);
            return HRESULT_FROM_WIN32(dwRet);
        }

        if (CompareFileTime(&ftTriggerBegin, &ftBracketEnd) >= 0)
        {
            //
            // The trigger start date is after the bracket end date, there are
            // no runs (case d.).
            //
            return S_OK;
        }

        if (CompareFileTime(&ftTriggerEnd, &ftBracketEnd) < 0)
        {
            //
            // Trigger end is before bracket end, so set bracket end to
            // trigger end (case b.).
            //
            ftBracketEnd = ftTriggerEnd;
        }
    }
    else
    {
        //
        // No bracket end, so use trigger end (case c.).
        //
        ftBracketEnd = ftTriggerEnd;
    }

    FILETIME ftRun, ftDurationStart, ftDurationEnd;
    WORD rgfRunDOW[JOB_DAYS_PER_WEEK], i;
    WORD rgfDaysOfMonth[JOB_DAYS_PER_MONTHMAX];
    WORD rgfMonths[JOB_MONTHS_PER_YEAR];
    WORD wDay, wBeginDOW, wCurDOW,  wCurDay, wLastDOM, wCurMonth, wCurYear;
    WORD cRunDOW, iRunDOW, IndexStart;
    BOOL fWrapped;
    fWrapped = FALSE;

    //
    // Calculate the trigger's first run time.
    //
    switch (jt.TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        // fall through to daily:

    case TASK_TIME_TRIGGER_DAILY:
        //
        // The first run time is the trigger begin time.
        //
        ftRun = ftTriggerBegin;
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        //
        // At jobs clear the DOW bits, so make sure we don't have an expired
        // At job.
        //
        if (jt.Type.Weekly.rgfDaysOfTheWeek == 0)
        {
            return S_OK;
        }

        //
        // See what day of the week the trigger begin day is. SYSTEMTIME
        // defines Sunday = 0, Monday = 1, etc.
        //
        FileTimeToSystemTime(&ftTriggerBegin, &st);
        wBeginDOW = st.wDayOfWeek;
        //
        // Convert the trigger data run day bit array into a boolean array
        // so that the results can be compared with the SYSTEMTIME value.
        // This array will also be used in the main loop.
        //
        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            rgfRunDOW[i] = (jt.Type.Weekly.rgfDaysOfTheWeek >> i) & 0x1;
        }
        //
        // Find the first set day-of-the-week after the trigger begin day.
        //
        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            wCurDOW = wBeginDOW + i;
            if (wCurDOW >= JOB_DAYS_PER_WEEK)
            {
                wCurDOW -= JOB_DAYS_PER_WEEK;
            }
            if (rgfRunDOW[wCurDOW])
            {
                ftRun = ftTriggerBegin;
                AddDaysToFileTime(&ftRun, i);
                break;
            }
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        //
        // At jobs clear the days bits, so make sure we don't have an expired
        // At job.
        //
        if (jt.Type.MonthlyDate.rgfDays == 0)
        {
            return S_OK;
        }

        //
        // Convert the bit fields to boolean arrays.
        // These arrays will also be used in the main loop.
        //
        for (i = 0; i < JOB_DAYS_PER_MONTHMAX; i++)
        {
            rgfDaysOfMonth[i] = (WORD)(jt.Type.MonthlyDate.rgfDays >> i) & 0x1;
        }
        for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
        {
            rgfMonths[i] = (jt.Type.MonthlyDate.rgfMonths >> i) & 0x1;
        }

        wCurDay = jt.wBeginDay;
        wCurMonth = jt.wBeginMonth;
        wCurYear = jt.wBeginYear;
        BOOL fDayOverflow, fDayFound;
        fDayFound = FALSE;
        do
        {
            MonthDays(wCurMonth, wCurYear, &wLastDOM);
            //
            // Find the first run day after the trigger start day, including
            // the trigger start day.
            //
            for (i = 0; i < wLastDOM; i++)
            {
                if (wCurDay > wLastDOM)
                {
                    //
                    // Adjust for wrapping.
                    //
                    wCurDay = 1;
                    fWrapped = TRUE;
                }
                if (rgfDaysOfMonth[wCurDay - 1])
                {
                    fDayFound = TRUE;
                    break;
                }
                wCurDay++;
            }
            //
            // Find the first run month.
            //
            for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
            {
                if (wCurMonth > JOB_MONTHS_PER_YEAR)
                {
                    wCurMonth = 1;
                    wCurYear++;
                }
                //
                // Check for run month match. Note that rgfMonths is zero based
                // and wCurMonth is one based.
                //
                if (rgfMonths[wCurMonth - 1])
                {
                    if (fWrapped && !i)
                    {
                        //
                        // Even though we have a match for run month, the run
                        // date for the first month has passed, so move on to
                        // the next run month.
                        //
                        fWrapped = FALSE;
                    }
                    else
                    {
                        break;
                    }
                }
                wCurMonth++;
            }
            //
            // Check for days overflow.
            //
            MonthDays(wCurMonth, wCurYear, &wLastDOM);
            if (wCurDay > wLastDOM)
            {
                //
                // Note that this clause would be entered infinitely if there
                // were no valid dates. ITask::SetTrigger validates the data to
                // ensure that there are valid dates.
                //
                fDayOverflow = TRUE;
                fDayFound = FALSE;
                wCurDay = 1;
                wCurMonth++;
                if (wCurMonth > JOB_MONTHS_PER_YEAR)
                {
                    wCurMonth = 1;
                    wCurYear++;
                }
            }
            else
            {
                fDayOverflow = FALSE;
            }
        } while (fDayOverflow & !fDayFound);

        break;

    case TASK_TIME_TRIGGER_MONTHLYDOW:
        //
        // Convert the bit fields to boolean arrays.
        // These arrays will also be used in the main loop.
        //
        cRunDOW = 0;
        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            if ((jt.Type.MonthlyDOW.rgfDaysOfTheWeek >> i) & 0x1)
            {
                cRunDOW++;
                rgfRunDOW[i] = TRUE;
            }
            else
            {
                rgfRunDOW[i] = FALSE;
            }
        }
        for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
        {
            rgfMonths[i] = (jt.Type.MonthlyDOW.rgfMonths >> i) & 0x1;
        }
        //
        // See if the trigger start month is in rgfMonths and if not
        // move to the first month in rgfMonths after jt.BeginMonth.
        //
        wCurMonth = jt.wBeginMonth;
        wCurYear = jt.wBeginYear;
        BOOL fInStartMonth;
        IndexStart = 0;
CheckNextMonth:
        for (i = IndexStart; i < (JOB_MONTHS_PER_YEAR + IndexStart); i++)
        {
            //
            // Check for run month match. Note that rgfMonths is zero based
            // and wCurMonth is one based.
            //
            if (rgfMonths[wCurMonth - 1])
            {
                break;
            }

            wCurMonth++;
            if (wCurMonth > JOB_MONTHS_PER_YEAR)
            {
                wCurMonth -= JOB_MONTHS_PER_YEAR;
                wCurYear++;
            }
        }

        fInStartMonth = i == 0;

        //
        // See what day of the week the first day of the month is.
        //
        st.wMonth = wCurMonth;
        st.wDay = 1;
        st.wYear = wCurYear;

        //
        // Convert to FILETIME and back to SYSTEMTIME to get wDayOfWeek.
        //
        SystemTimeToFileTime(&st, &ftRun);
        FileTimeToSystemTime(&ftRun, &st);
        wBeginDOW = st.wDayOfWeek;

        //
        // Find the first run DayOftheWeek. If it is before the start
        // day, find the next and so on until after the start day.
        //
        iRunDOW = cRunDOW;

        for (i = 0; i < JOB_DAYS_PER_WEEK; i++)
        {
            wCurDOW = wBeginDOW + i;
            wCurDay = 1 + i;

            if (wCurDOW >= JOB_DAYS_PER_WEEK)
            {
                wCurDOW -= JOB_DAYS_PER_WEEK;
            }

            if (rgfRunDOW[wCurDOW])
            {
                iRunDOW--;
                wCurDay += (jt.Type.MonthlyDOW.wWhichWeek - 1)
                           * JOB_DAYS_PER_WEEK;

                MonthDays(wCurMonth, wCurYear, &wLastDOM);

                if (wCurDay > wLastDOM)
                {
                    //
                    // This case can be reached if
                    // jt.Type.MonthlyDOW.wWhichWeek == TASK_LAST_WEEK
                    // which means to always run on the last occurrence of
                    // this day for the month.
                    //
                    wCurDay -= JOB_DAYS_PER_WEEK;
                }

                if (fInStartMonth && wCurDay < jt.wBeginDay)
                {
                    if (iRunDOW)
                    {
                        //
                        // There are more runs this month, so check those.
                        //
                        continue;
                    }
                    else
                    {
                        //
                        // Start with the next run month.
                        //
                        IndexStart++;
                        goto CheckNextMonth;
                    }
                }
                break;
            }
        }
        wDay = 1 + i;
        break;

    default:
        return E_FAIL;
    }

    if (jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE ||
        jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW)
    {
        st.wYear   = wCurYear;
        st.wMonth  = wCurMonth;
        st.wDay    = wCurDay;
        st.wHour   = jt.wStartHour;
        st.wMinute = jt.wStartMinute;
        st.wSecond = st.wMilliseconds = 0;
        SystemTimeToFileTime(&st, &ftRun);
    }

    //
    // Set the initial duration period endpoints.
    //
    // ftDurationEnd = ftDurationStart + jt.MinutesDuration
    //                 * FILETIMES_PER_MINUTE;
    //
    ftDurationStart = ftDurationEnd = ftRun;
    AddMinutesToFileTime(&ftDurationEnd, jt.MinutesDuration);
    BOOL fPassedDurationEnd = FALSE;

    //
    // Main loop. Find all of the runs after the initial run.
    // Stop when the run goes past the bracket end.
    //
    while (CompareFileTime(&ftRun, &ftBracketEnd) < 0)
    {
        //
        // If the run falls within the run bracket, add it to the list.
        //
        if (CompareFileTime(&ftRun, &ftBracketBegin) >= 0)
        {
            if (pRunList != NULL)
            {
                FILETIME ftKillTime = MAX_FILETIME;
                if (jt.rgFlags & TASK_TRIGGER_FLAG_KILL_AT_DURATION_END)
                {
                    ftKillTime = ftDurationEnd;
                }

                FILETIME ftDeadline = ftTriggerEnd;
                if (dwJobFlags & TASK_FLAG_START_ONLY_IF_IDLE)
                {
                    FILETIME ftIdleDeadline = ftRun;

                    AddMinutesToFileTime(&ftIdleDeadline, wIdleDeadline);
                    ftDeadline = minFileTime(ftTriggerEnd, ftIdleDeadline);
                }

                HRESULT hr = pRunList->AddSorted(ftRun, ftDeadline, ftKillTime,
                                ptszJobName, dwJobFlags, dwMaxRunTime,
                                wIdleWait, pCount, cLimit);
                if (FAILED(hr))
                {
                    return hr;
                }
                schAssert(*pCount <= cLimit);

                if (hr == S_FALSE)
                {
                    //
                    // The run time is later than the last element in the list
                    // and the list has reached its size limit.  So don't
                    // bother computing any more run times.
                    //
                    return S_OK;
                }
            }
            else
            {
                if (*pCount < cLimit)
                {
                    (*pCount)++;
                }

                if (*pCount == cLimit)
                {
                    //
                    // Computing more run times will have no effect.
                    //
                    return S_OK;
                }
            }
        }

        //
        // Calculate the next run time.
        //

        //
        // If there is minutes repetition (MinutesInterval non-zero), then
        // compute all of the runs in the duration period.
        //

        if (jt.MinutesInterval)
        {
            //
            // Add the minutes interval.
            //
            AddMinutesToFileTime(&ftRun, jt.MinutesInterval);

            //
            // See if we are at the end of this duration period.
            //
            if (CompareFileTime(&ftDurationEnd, &ftRun) <= 0)
            {
                fPassedDurationEnd = TRUE;
            }
        }

        //
        // If there is no minutes repetition (MinutesInterval is zero) or we
        // have passed the end of the duration period, then calculate the next
        // duration start (which is also the next run).
        //
        if (!jt.MinutesInterval || fPassedDurationEnd)
        {
            switch (jt.TriggerType)
            {
            case TASK_TIME_TRIGGER_ONCE:
                return S_OK;

            case TASK_TIME_TRIGGER_DAILY:
                //
                // ftNextRun = ftCurRun + DaysInterval * FILETIMES_PER_DAY;
                //
                AddDaysToFileTime(&ftDurationStart, jt.Type.Daily.DaysInterval);
                break;

            case TASK_TIME_TRIGGER_WEEKLY:
                fWrapped = FALSE;
                //
                // Find the next DayOfWeek to run on.
                //
                for (i = 1; i <= JOB_DAYS_PER_WEEK; i++)
                {
                    wCurDOW++;
                    if (wCurDOW >= JOB_DAYS_PER_WEEK)
                    {
                        //
                        // We have wrapped into the next week.
                        //
                        wCurDOW -= JOB_DAYS_PER_WEEK;
                        fWrapped = TRUE;
                    }
                    if (rgfRunDOW[wCurDOW])
                    {
                        AddDaysToFileTime(&ftDurationStart, i);
                        break;
                    }
                }

                if (fWrapped)
                {
                    //
                    // Starting a new week, so add the weeks increment.
                    //
                    AddDaysToFileTime(&ftDurationStart,
                                      (jt.Type.Weekly.WeeksInterval - 1)
                                      * JOB_DAYS_PER_WEEK);
                }
                break;

            case TASK_TIME_TRIGGER_MONTHLYDATE:
                BOOL fDayFound;
                fWrapped = FALSE;
                fDayFound = FALSE;
                //
                // Find the next day to run.
                //
                do
                {
                    MonthDays(wCurMonth, wCurYear, &wLastDOM);
                    for (i = 1; i <= wLastDOM; i++)
                    {
                        wCurDay++;
                        if (wCurDay > wLastDOM)
                        {
                            //
                            // Adjust for wrapping.
                            //
                            wCurDay = 1;
                            fWrapped = TRUE;
                            wCurMonth++;
                            if (wCurMonth > JOB_MONTHS_PER_YEAR)
                            {
                                wCurMonth = 1;
                                wCurYear++;
                            }
                            MonthDays(wCurMonth, wCurYear, &wLastDOM);
                        }
                        if (rgfDaysOfMonth[wCurDay - 1])
                        {
                            fDayFound = TRUE;
                            break;
                        }
                    }
                    if (fWrapped || !fDayFound)
                    {
                        //
                        // The prior month is done, find the next month.
                        //
                        for (i = 1; i <= JOB_MONTHS_PER_YEAR; i++)
                        {
                            if (wCurMonth > JOB_MONTHS_PER_YEAR)
                            {
                                wCurMonth = 1;
                                wCurYear++;
                            }
                            if (rgfMonths[wCurMonth - 1])
                            {
                                fWrapped = FALSE;
                                break;
                            }
                            wCurMonth++;
                        }
                    }
                } while (!fDayFound);
                break;

            case TASK_TIME_TRIGGER_MONTHLYDOW:
                if (!iRunDOW)
                {
                    //
                    // All of the runs for the current month are done, find the
                    // next month.
                    //
                    for (i = 0; i < JOB_MONTHS_PER_YEAR; i++)
                    {
                        wCurMonth++;
                        if (wCurMonth > JOB_MONTHS_PER_YEAR)
                        {
                            wCurMonth = 1;
                            wCurYear++;
                        }
                        if (rgfMonths[wCurMonth - 1])
                        {
                            break;
                        }
                    }
                    //
                    // See what day of the week the first day of the month is.
                    //
                    st.wMonth = wCurMonth;
                    st.wDay = wDay = 1;
                    st.wYear = wCurYear;
                    SystemTimeToFileTime(&st, &ftRun);
                    FileTimeToSystemTime(&ftRun, &st);
                    wCurDOW = st.wDayOfWeek;
                    iRunDOW = cRunDOW;
                    //
                    // Start at the first run DOW for this next month.
                    //
                    IndexStart = 0;
                }
                else
                {
                    //
                    // Start at the next run DOW for the current month.
                    //
                    IndexStart = 1;
                }

                //
                // Find the next DayOfWeek to run on.
                //
                for (i = IndexStart; i <= JOB_DAYS_PER_WEEK; i++)
                {
                    if (i > 0)
                    {
                        wCurDOW++;
                        wDay++;
                    }
                    if (wCurDOW >= JOB_DAYS_PER_WEEK)
                    {
                        wCurDOW -= JOB_DAYS_PER_WEEK;
                    }
                    if (rgfRunDOW[wCurDOW])
                    {
                        //
                        // Found a run DayOfWeek.
                        //
                        iRunDOW--;
                        wCurDay = wDay + (jt.Type.MonthlyDOW.wWhichWeek - 1)
                                         * JOB_DAYS_PER_WEEK;
                        WORD wLastDOM;
                        MonthDays(wCurMonth, wCurYear, &wLastDOM);
                        if (wCurDay > wLastDOM)
                        {
                            //
                            // This case can be reached if
                            // jt.Type.MonthlyDOW.wWhichWeek == JOB_LAST_WEEK
                            // which means to always run on the last occurance
                            // of this day for the month.
                            //
                            wCurDay -= JOB_DAYS_PER_WEEK;
                        }
                        break;
                    }
                }
                break;

            default:
                return E_FAIL;
            }

            if (jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE ||
                jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW)
            {
                st.wYear   = wCurYear;
                st.wMonth  = wCurMonth;
                st.wDay    = wCurDay;
                st.wHour   = jt.wStartHour;
                st.wMinute = jt.wStartMinute;
                st.wSecond = st.wMilliseconds = 0;
                SystemTimeToFileTime(&st, &ftDurationStart);
            }

            //
            // Calc the next duration period endpoints.
            //
            ftRun = ftDurationEnd = ftDurationStart;

            AddMinutesToFileTime(&ftDurationEnd, jt.MinutesDuration);

            fPassedDurationEnd = FALSE;
        }

    } // while

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\persist.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       persist.cxx
//
//  Contents:   persistent storage methods
//
//  Classes:    CJob (continued)
//
//  Interfaces: IPersist, IPersistFile
//
//  History:    24-May-95 EricB created
//              19-Jul-97 AnirudhS  Rewrote SaveP and LoadP to minimize calls
//                  to ReadFile, WriteFile and LocalAlloc
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include <align.h>		// needed only for use in some schasserts
#include "job.hxx"
#include "defines.hxx"
#include "SASecRPC.h"   // Get/SetAccountInformation RPC definition.
#include <strsafe.h>

// defined in security.cxx
HRESULT
SetTaskFileSecurity(LPCWSTR pwszTaskPath, BOOL fIsATTask);

#define JOB_SIGNATURE_VERSION               1   // data version we write
#define JOB_SIGNATURE_CLIENT_VERSION        1   // software version we are
#define JOB_SIGNATURE_MIN_CLIENT_VERSION    1   // min s/w version that can
                                                //   read data we write

struct JOB_SIGNATURE_HEADER
{
    WORD    wSignatureVersion;
    WORD    wMinClientVersion;
};

void    GenerateUniqueID(GUID * pUuid);
BOOL    ReadString(CInputBuffer * pBuf, LPWSTR *ppwsz);

//
// This array of members is used to iterate through the string fields
// of a CJob that are initially held in m_MainBlock.
//

LPWSTR CJob::* const CJob::s_StringField[] =
{
    &CJob::m_pwszApplicationName,
    &CJob::m_pwszParameters,
    &CJob::m_pwszWorkingDirectory,
    &CJob::m_pwszCreator,
    &CJob::m_pwszComment
};

// IPersist method

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersist::GetClassID
//
//  Synopsis:   supplies VBScript class object CLSID
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetClassID(CLSID * pClsID)
{
    TRACE(CJob, GetClassID);
    *pClsID = CLSID_CTask;
    return S_OK;
}

// IPersistFile methods

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::IsDirty
//
//  Synopsis:   checks for changes since it was last saved
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::IsDirty(void)
{
    TRACE3(CJob,IsDirty);
    return (IsFlagSet(JOB_I_FLAG_PROPERTIES_DIRTY) ||
            IsFlagSet(JOB_I_FLAG_TRIGGERS_DIRTY)   ||
            IsFlagSet(JOB_I_FLAG_SET_ACCOUNT_INFO)) ? S_OK : S_FALSE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::Load
//
//  Synopsis:   loads the job object indicated by the given filename
//
//  Arguments:  [pwszFileName] - name of the job object file
//              [dwMode]       - open mode, currently ignored.
//
//  Notes:      All OLE32 strings are UNICODE, including the filename passed
//              in the IPersistFile methods.
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::Load(LPCOLESTR pwszFileName, DWORD dwMode)
{
    return LoadP(pwszFileName, dwMode, TRUE, TRUE);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::LoadP, private
//
//  Synopsis:   private load method that takes a TCHAR filename
//
//  Arguments:  [ptszFileName] - name of the job object file
//              [dwMode]       - open mode, currently ignored.
//              [fRemember]    - save the file name?
//              [fAllData]     - if TRUE, load the entire job. If false, load
//                               only the fixed length data at the head of the
//                               job file + the job command.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::LoadP(
    LPCTSTR ptszFileName,
    DWORD   dwMode,
    BOOL    fRemember,
    BOOL    fAllData
    )
{
    TRACE3(CJob, LoadP);
    HRESULT hr = S_OK;
    BYTE * HeapBlock = NULL;
    //WCHAR tszFileName[MAX_PATH + 1] = L"";
    //
    // check the file name
    //
    //if (!CheckFileName((LPOLESTR)ptszFileName, tszFileName, NULL))
    //{
    //  return E_INVALIDARG;
    //}

    //
    // Save the file name?
    //
    if (fRemember)
    {
        LPTSTR ptsz = new TCHAR[lstrlen(ptszFileName) + 1];
        if (!ptsz)
        {
            ERR_OUT("CJob::LoadP", E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        if (m_ptszFileName)
        {
            delete m_ptszFileName;
        }
        m_ptszFileName = ptsz;
        StringCchCopy(m_ptszFileName, lstrlen(ptszFileName) + 1, ptszFileName);
    }

    //
    // Open the file.
    //
    HANDLE  hFile = NULL;
    hr = OpenFileWithRetry(ptszFileName, GENERIC_READ, FILE_SHARE_READ, &hFile);
    if (FAILED(hr))
    {
        ERR_OUT("CJob::LoadP, file open", hr);
        return hr;
    }

    if (FILE_TYPE_DISK != GetFileType(hFile))
    {
        CloseHandle(hFile);
        ERR_OUT("CJob::Load, Not a disk file", E_ACCESSDENIED);

        return E_ACCESSDENIED;
    }


    if (fRemember)
    {
        m_fFileCreated = TRUE;
    }

    //
    // Get the file size.
    //
    DWORD dwFileSize;
    {
        DWORD dwFileSizeHigh;
        DWORD dwError;
        dwFileSize = GetFileSize(hFile, &dwFileSizeHigh);
        if (dwFileSize == 0xFFFFFFFF &&
            (dwError = GetLastError()) != NO_ERROR)
        {
            hr = HRESULT_FROM_WIN32(dwError);
            ERR_OUT("CJob::Load, GetFileSize", hr);
            goto Cleanup;
        }

        if (dwFileSizeHigh > 0)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            schDebugOut((DEB_ERROR, "CJob::Load: file too big, SizeHigh = %u\n",
                         dwFileSizeHigh));
            goto Cleanup;
        }
    }

    if (dwFileSize < sizeof(FIXDLEN_DATA))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        schDebugOut((DEB_ERROR, "CJob::Load: file too small, size = %u\n",
                     dwFileSize));
        goto Cleanup;
    }

    //
    // Read the entire file into memory.
    //
    HeapBlock = new BYTE[dwFileSize];
    if (HeapBlock == NULL)
    {
        hr = E_OUTOFMEMORY;
        ERR_OUT("CJob::Load, buffer alloc", hr);
        goto Cleanup;
    }

    DWORD dwBytesRead;
    if (!ReadFile(hFile, HeapBlock, dwFileSize, &dwBytesRead, NULL))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::Load, read file", hr);
        delete [] HeapBlock;
        goto Cleanup;
    }
    if (dwBytesRead != dwFileSize)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        ERR_OUT("CJob::Load bytes read", hr);
        delete [] HeapBlock;
        goto Cleanup;
    }

    //
    // Close the file.
    //
    CloseHandle(hFile);
    hFile = INVALID_HANDLE_VALUE;

    //
    // Free old values of properties that we are about to read, and switch
    // to the new heap block.
    //
    FreeProperties();
    m_MainBlock.Set(HeapBlock, dwFileSize);

    //
    // Get the fixed length Job data.
    // (We already verified that the file is at least as big as FIXDLEN_DATA.)
    //
    { // scope flData and CInputBuffer to avoid "initialization skipped" error
    const FIXDLEN_DATA& flData = *(FIXDLEN_DATA *)&HeapBlock[0];
    CInputBuffer Buf(&HeapBlock[sizeof FIXDLEN_DATA],
                     &HeapBlock[dwFileSize]);

    //
    // Check the version.
    //
    // Here is where, in future versions, we would look at the version
    // properties to determine how to read the job properties.
    // For now, though, we just reject old versions as being invalid.
    //
#ifdef IN_THE_FUTURE

    if (m_wVersion != flData.wVersion)
    {
        fNewVersion = TRUE;
        //
        // Add version specific processing here.
        //
    }

#else   // !IN_THE_FUTURE

    if (m_wFileObjVer != flData.wFileObjVer)
    {
        hr = SCHED_E_UNKNOWN_OBJECT_VERSION;
        ERR_OUT("CJob::Load invalid object version", 0);
        goto Cleanup;
    }

#endif  // !IN_THE_FUTURE

    //schDebugOut((DEB_TRACE, "Load: job object version: %d.%d, build %d\n",
    //             HIBYTE(flData.wVersion), LOBYTE(flData.wVersion),
    //             flData.wFileObjVer));

    m_wVersion            = flData.wVersion;
    m_wFileObjVer         = flData.wFileObjVer;
    m_uuidJob             = flData.uuidJob;
    m_wTriggerOffset      = flData.wTriggerOffset;
    m_wErrorRetryCount    = flData.wErrorRetryCount;
    m_wErrorRetryInterval = flData.wErrorRetryInterval;
    m_wIdleWait           = flData.wIdleWait;
    m_wIdleDeadline       = flData.wIdleDeadline;
    m_dwPriority          = flData.dwPriority;
    m_dwMaxRunTime        = flData.dwMaxRunTime;
    m_ExitCode            = flData.ExitCode;
    m_hrStatus            = flData.hrStatus;
    m_rgFlags             = flData.rgFlags;
    m_stMostRecentRunTime = flData.stMostRecentRunTime;

    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

    if (!Buf.Read(&m_cRunningInstances, sizeof m_cRunningInstances))
    {
        ERR_OUT("CJob::Load, read Running Instance Count", 0);
        goto Cleanup;
    }

    //
    // Get the variable length Job properties.
    //
    // In all cases, retrieve the job application name.
    // (Notice that flData.wAppNameLenOffset is not honored.  We have to
    // leave it this way now for backward compatibility.)
    //
    if (!ReadString(&Buf, &m_pwszApplicationName))
    {
        goto Cleanup;
    }

    //
    // If a full load, retrieve the rest of the variable length data,
    // including the triggers.
    //
    if (fAllData)
    {
        // Strings
        if (!(ReadString(&Buf, &m_pwszParameters) &&
              ReadString(&Buf, &m_pwszWorkingDirectory) &&
              ReadString(&Buf, &m_pwszCreator) &&
              ReadString(&Buf, &m_pwszComment)
              ))
        {
            goto Cleanup;
        }

        // User Data size
        if (!Buf.Read(&m_cbTaskData, sizeof m_cbTaskData))
        {
            goto Cleanup;
        }

        // User Data
        if (m_cbTaskData == 0)
        {
            m_pbTaskData = NULL;
        }
        else
        {
            m_pbTaskData = Buf.CurrentPosition();
            if (!Buf.Advance(m_cbTaskData))
            {
                goto Cleanup;
            }
        }

        // Size of reserved data
        if (!Buf.Read(&m_cReserved, sizeof m_cReserved))
        {
            goto Cleanup;
        }

        // Reserved data
        //
        // If there is reserved data, it must begin with a structure
        // that we recognize.  In this version we recognize the
        // TASKRESERVED1 structure.
        //
        m_pbReserved = NULL;
        if (m_cReserved == 0)
        {
            //
            // There is no reserved data.  Initialize the members that
            // we would have read from the reserved data to defaults.
            //
            m_hrStartError = SCHED_S_TASK_HAS_NOT_RUN;
            m_rgTaskFlags = 0;
        }
        else if (m_cReserved < sizeof(TASKRESERVED1))
        {
            ERR_OUT("CJob::Load, invalid reserved data", hr);
            m_cReserved = 0;
            goto Cleanup;
        }
        else
        {
            m_pbReserved = Buf.CurrentPosition();
            if (!Buf.Advance(m_cReserved))
            {
                goto Cleanup;
            }

            //
            // Copy the portion of the Reserved Data that we understand
            // into private data members.
            // It may not be aligned properly, so use CopyMemory.
            //
            TASKRESERVED1 Reserved;
            CopyMemory(&Reserved, m_pbReserved, sizeof Reserved);
            m_hrStartError = Reserved.hrStartError;
            m_rgTaskFlags  = Reserved.rgTaskFlags;
        }

        //
        // Load trigger data.
        //
        hr = this->_LoadTriggersFromBuffer(&Buf);
        if (FAILED(hr))
        {
            ERR_OUT("Loading triggers from storage", hr);
            goto Cleanup;
        }

        //
        // If there is more data after the triggers, it must begin with a
        // signature header and a signature.  If there is less data than
        // that, treat it as though the file has no signature.
        // If a signature is present, but its "minimum client version" is
        // greater than our version, treat it as though the file has no
        // signature.
        //
        JOB_SIGNATURE_HEADER SignHead;
        if (Buf.Read(&SignHead, sizeof SignHead) &&
            SignHead.wMinClientVersion <= JOB_SIGNATURE_CLIENT_VERSION)
        {
            m_pbSignature = Buf.CurrentPosition();
            if (!Buf.Advance(SIGNATURE_SIZE))
            {
                schDebugOut((DEB_ERROR, "CJob::Load: si too small, ignoring\n"));
                m_pbSignature = NULL;
            }
        }
        // else m_pbSignature was set to NULL in FreeProperties
    }
    } // end CInputBuffer and flData scope

    hr = S_OK;

Cleanup:

    //
    // Close the file.
    //
    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::SaveP, private
//
//  Synopsis:   saves the object to storage, takes a TCHAR file name
//
//  Arguments:  [ptszFileName] - if null, save to the previously loaded file.
//              [fRemember]    - if TRUE, the object becomes associated with
//                               the new filename.
//              [flOptions]    - can have the following bits set:
//                  SAVEP_VARIABLE_LENGTH_DATA:
//                               if set, saves all job data except the running
//                               instance count.  If not set, saves
//                               only the fixed length data at the beginning
//                               of the job. The file must already exist (the
//                               filename must be NULL) in this case.
//
//                  SAVEP_RUNNING_INSTANCE_COUNT:
//                               if set, the running instance count is saved
//
//                  SAVEP_PRESERVE_NET_SCHEDULE:
//                               if NOT set, the JOB_I_FLAG_NET_SCHEDULE flag
//                               is automatically cleared.
//
//  Returns:    HRESULT codes.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::SaveP(LPCTSTR ptszFileName, BOOL fRemember, ULONG flOptions)
{
    TRACE3(CJob, SaveP);

    HRESULT hr            = S_OK;
    HANDLE  hFile         = NULL;
    BOOL    fSetSecurity  = FALSE;

    //
    // Decide which name to save the file as.  Use the one passed in if
    // there is one, otherwise use the previously remembered one.
    //
    LPCTSTR ptszFileToSaveAs = ptszFileName ? ptszFileName : m_ptszFileName;
    if (!(ptszFileToSaveAs && *ptszFileToSaveAs))
    {
        //
        // Can't do a save if there is no file name.
        //
        return E_INVALIDARG;
    }

    //
    // Figure out whether we will create a new file or open an existing one.
    // If using the passed in filename, then this is a save-as (or if
    // fRemember is false, a save-copy-as) operation and a new file must
    // be created.
    // If using the previously remembered filename, then a new file must
    // be created iff the file wasn't saved before.
    //
    DWORD dwDisposition;
    DWORD dwAttributes;

    if (!(ptszFileToSaveAs == m_ptszFileName && m_fFileCreated))
    {
        dwDisposition = CREATE_NEW;

        if (!(flOptions & SAVEP_VARIABLE_LENGTH_DATA))
        {
            //
            // Creating a new file is only valid if all the data is to be
            // saved. Otherwise we would end up with a partial (invalid) file.
            //
            return E_INVALIDARG;
        }

        dwAttributes = FILE_ATTRIBUTE_NORMAL;

        if (IsFlagSet(TASK_FLAG_HIDDEN))
        {
            dwAttributes = FILE_ATTRIBUTE_HIDDEN;
        }

        //
        // Always write running instance count on file create.
        //
        flOptions |= SAVEP_RUNNING_INSTANCE_COUNT;

        //
        // On file creation, generate a unique ID for this job.
        // Done for Win95 as well as NT.
        //

        GenerateUniqueID(&m_uuidJob);

        //
        // Set security on file creation. This is done after all writes
        // have succeeded and the file has been closed.
        //
        fSetSecurity = TRUE;
    }
    else
    {
        //
        // This is a save to an existing file.
        //
        dwDisposition = OPEN_EXISTING;

        dwAttributes = GetFileAttributes(m_ptszFileName);
        if (dwAttributes == -1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, GetFileAttributes", hr);
            return hr;
        }

        DWORD dwOrgAttributes = dwAttributes;

        //
        // Remove the read-only attribute.
        //

        dwAttributes &= ~FILE_ATTRIBUTE_READONLY;

        //
        // If the hidden flag is set and the hidden attribute has
        // not been set yet, set it now.
        //

        if (IsFlagSet(TASK_FLAG_HIDDEN))
        {
            dwAttributes |= FILE_ATTRIBUTE_HIDDEN;
        }

        if (dwAttributes != dwOrgAttributes)
        {
            SetFileAttributes(m_ptszFileName, dwAttributes);
        }
    }

    //
    // Create/Open the file.
    //
    hFile = CreateFile(ptszFileToSaveAs,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       dwDisposition,
                       dwAttributes              |
                       FILE_FLAG_SEQUENTIAL_SCAN,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        ERR_OUT("CJob::Save, file open/create", hr);
        return hr;
    }
    if (FILE_TYPE_DISK != GetFileType(hFile))
    {
        CloseHandle(hFile);
        ERR_OUT("CJob::Save, Not a disk file", E_ACCESSDENIED);

        return E_ACCESSDENIED;
    }



    if (fRemember || ptszFileToSaveAs == m_ptszFileName)
    {
        m_fFileCreated = TRUE;
    }

    //
    // Initialize the creator property if not already done so.
    // Set it to the caller's username.
    //

    if (m_pwszCreator == NULL)
    {
        //
        // Other than out of memory, if an error occurs, leave the
        // creator field alone.
        //

        TCHAR tszUserName[MAX_USERNAME + 1];
        DWORD ccUserName = MAX_USERNAME + 1;

        if (GetUserName(tszUserName, &ccUserName))
        {
            // NB : GetUserName returned char count includes the null
            //      character.
            //
            m_pwszCreator = new WCHAR[ccUserName];

            if (m_pwszCreator == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                goto ErrExit;
            }

            StringCchCopy(m_pwszCreator, ccUserName, tszUserName);
        }
    }

    { // scope to avoid "initialization skipped" error

    BOOL fUpdateJobState = FALSE;

    //
    // The disabled flag takes precedence over other states except running.
    //
    if (IsFlagSet(TASK_FLAG_DISABLED))
    {
        if (!IsStatus(SCHED_S_TASK_RUNNING))
        {
            SetStatus(SCHED_S_TASK_DISABLED);
        }
    }
    else
    {
        if (IsStatus(SCHED_S_TASK_DISABLED))
        {
            //
            // UpdateJobState will set the correct status if no longer
            // disabled.
            //
            fUpdateJobState = TRUE;
        }
    }

    //
    // Check to see if the triggers are dirty. If so, update the job status
    // and flags before writing it out.
    //
    if (IsFlagSet(JOB_I_FLAG_TRIGGERS_DIRTY))
    {
        fUpdateJobState = TRUE;
    }

    //
    // The flag value JOB_I_FLAG_RUN_PROP_CHANGE is never written to disk.
    // Instead, the need for a wait list rebuild is signalled by clearing
    // JOB_I_FLAG_NO_RUN_PROP_CHANGE. If JOB_I_FLAG_RUN_PROP_CHANGE were to be
    // written to disk, then CheckDir would see this bit set and do a wait
    // list rebuild, but it would also need to clear the bit to prevent
    // successive wait list rebuilds. However, the write to clear the bit
    // would cause an additional change notification and CheckDir call. So, to
    // avoid this thrashing, we signal a wait list rebuild by the absence of
    // the JOB_I_FLAG_NO_RUN_PROP_CHANGE bit.
    //
    if (IsFlagSet(JOB_I_FLAG_RUN_PROP_CHANGE))
    {
        ClearFlag(JOB_I_FLAG_RUN_PROP_CHANGE);
        ClearFlag(JOB_I_FLAG_NO_RUN_PROP_CHANGE);
        fUpdateJobState = TRUE;
    }

    if (fUpdateJobState)
    {
        UpdateJobState(FALSE);
    }

    //
    // Regenerate a unique id for the job (a GUID) when the application
    // changes. This is done for security reasons.
    //
    // NB : We need to do this for Win95 as well as NT since we may be
    //      editing an NT job from a Win95 machine.
    //

    if (IsFlagSet(JOB_I_FLAG_APPNAME_CHANGE))
    {
        GenerateUniqueID(&m_uuidJob);
        ClearFlag(JOB_I_FLAG_APPNAME_CHANGE);
    }

    if (!(flOptions & SAVEP_PRESERVE_NET_SCHEDULE))
    {
        ClearFlag(JOB_I_FLAG_NET_SCHEDULE);
    }

    //
    // Save Job fixed length data.
    //

    // Allocate a stack buffer which will be sufficient if we are not
    // saving variable length data.
    // Note that sizeof flStruct > sizeof FIXDLEN_DATA + sizeof WORD,
    // due to struct packing requirements, so don't use sizeof flStruct
    // to compute offsets.
    //
    struct FLSTRUCT
    {
        FIXDLEN_DATA flData;
        WORD         cRunningInstances;
    } flStruct;

    // This code depends on flData and cRunningInstances being contiguous
    schAssert(FIELD_OFFSET(FLSTRUCT, cRunningInstances) == sizeof FIXDLEN_DATA);

    flStruct.flData.wVersion            = m_wVersion;
    flStruct.flData.wFileObjVer         = m_wFileObjVer;
    flStruct.flData.uuidJob             = m_uuidJob;
    flStruct.flData.wAppNameLenOffset   = sizeof(FIXDLEN_DATA) +
                                 sizeof(m_cRunningInstances);
    flStruct.flData.wTriggerOffset      = m_wTriggerOffset;
    flStruct.flData.wErrorRetryCount    = m_wErrorRetryCount;
    flStruct.flData.wErrorRetryInterval = m_wErrorRetryInterval;
    flStruct.flData.wIdleWait           = m_wIdleWait;
    flStruct.flData.wIdleDeadline       = m_wIdleDeadline;
    flStruct.flData.dwPriority          = m_dwPriority;
    flStruct.flData.dwMaxRunTime        = m_dwMaxRunTime;
    flStruct.flData.ExitCode            = m_ExitCode;
    flStruct.flData.hrStatus            = m_hrStatus;
    //
    // Don't save the dirty & set account information flags.
    //
    flStruct.flData.rgFlags             = m_rgFlags & ~NON_PERSISTED_JOB_FLAGS;

    flStruct.flData.stMostRecentRunTime = m_stMostRecentRunTime;
    flStruct.cRunningInstances          = m_cRunningInstances;

    //
    // Compute the number of bytes to write to the file.  This will be
    // the size of the intermediate buffer to be allocated.
    //
    BYTE * pSource = (BYTE *) &flStruct;
    DWORD cbToWrite = sizeof(flStruct.flData);

    //
    // Save the running instance data only if (a) the file is being created,
    // or (b) the SAVEP_RUNNING_INSTANCE_COUNT option is set.
    // If SAVEP_VARIABLE_LENGTH_DATA is set, allocate temporary space for the
    // running instance count, regardless of whether we are going to write it.
    //
    if (flOptions & (SAVEP_RUNNING_INSTANCE_COUNT |
                     SAVEP_VARIABLE_LENGTH_DATA))
    {
        cbToWrite += sizeof(flStruct.cRunningInstances);
    }

    if (flOptions & SAVEP_VARIABLE_LENGTH_DATA)
    {
        //
        // Add the space needed to write the strings and their lengths.
        // Save the lengths for use later.
        //
        WORD acStringLen[ARRAY_LEN(s_StringField)]; // array of string lengths
        cbToWrite += sizeof acStringLen;

        for (int i = 0; i < ARRAY_LEN(acStringLen); i++)
        {
            LPWSTR pwsz = this->*s_StringField[i];
            acStringLen[i] = (pwsz && *pwsz) ? wcslen(pwsz) + 1 : 0;
            cbToWrite += acStringLen[i] * sizeof WCHAR;
        }

        //
        // Add the space needed to write the user data, the reserved data
        // and their lengths.
        //
        if (m_cReserved < sizeof TASKRESERVED1)
        {
            schAssert(m_cReserved == 0);
            m_cReserved = sizeof TASKRESERVED1;
        }
        cbToWrite += sizeof(m_cbTaskData) + m_cbTaskData
                   + sizeof(m_cReserved) + m_cReserved;

        //
        // cbToWrite is now the offset to the trigger data.  Save it.
        //
        schAssert(cbToWrite <= MAXUSHORT);    // BUGBUG Do NOT just assert.
			// Also return a "limit exceeded" error.
        flStruct.flData.wTriggerOffset = m_wTriggerOffset = (WORD) cbToWrite;

        //
        // Add the space needed to write the triggers and their count.
        //
        WORD cTriggers = m_Triggers.GetCount();
        cbToWrite += sizeof cTriggers + cTriggers * sizeof TASK_TRIGGER;

        //
        // If the job has a signature, add the space needed to write it.
        //
        if (m_pbSignature != NULL)
        {
            cbToWrite += sizeof(JOB_SIGNATURE_HEADER) + SIGNATURE_SIZE;
        }

        //
        // We have now computed the required space.  Allocate a buffer of
        // that size.
        //
        pSource = new BYTE[cbToWrite];
        if (pSource == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }

        //
        // Copy data into the buffer.
        //
        BYTE * pCurrent = pSource;  // current write position

        #define WRITE_DATA(pSrc, cbSize)                \
            CopyMemory(pCurrent, (pSrc), (cbSize));     \
            pCurrent += (cbSize);

        // FIXDLEN_DATA and Running Instance Count
        WRITE_DATA(&flStruct, sizeof flStruct.flData +
                              sizeof flStruct.cRunningInstances);

        // Strings
        for (i = 0; i < ARRAY_LEN(acStringLen); i++)
        {
            schAssert(POINTER_IS_ALIGNED(pCurrent, ALIGN_WORD));
            *(WORD *) pCurrent = acStringLen[i];
            pCurrent += sizeof WORD;

            WRITE_DATA(this->*s_StringField[i],
                       acStringLen[i] * sizeof WCHAR);
        }

        // User data
        schAssert(POINTER_IS_ALIGNED(pCurrent, ALIGN_WORD));
        *(WORD *) pCurrent = m_cbTaskData;
        pCurrent += sizeof WORD;

        WRITE_DATA(m_pbTaskData, m_cbTaskData);
        // Note that pCurrent may no longer be WORD-aligned

        // Reserved data
        WRITE_DATA(&m_cReserved, sizeof m_cReserved);

        // Copy private members into the reserved data block to save
        TASKRESERVED1 Reserved1 = { m_hrStartError, m_rgTaskFlags };
        if (m_pbReserved == NULL)
        {
            schAssert(m_cReserved == sizeof Reserved1);
            WRITE_DATA(&Reserved1, m_cReserved);
        }
        else
        {
            schAssert(m_cReserved >= sizeof Reserved1);
            CopyMemory(m_pbReserved, &Reserved1, sizeof Reserved1);
            WRITE_DATA(m_pbReserved, m_cReserved);
        }

        // Triggers
        WRITE_DATA(&cTriggers, sizeof cTriggers);
        WRITE_DATA(m_Triggers.GetArray(), sizeof TASK_TRIGGER * cTriggers);

        // Signature
        if (m_pbSignature != NULL)
        {
            JOB_SIGNATURE_HEADER SignHead;
            SignHead.wSignatureVersion = JOB_SIGNATURE_VERSION;
            SignHead.wMinClientVersion = JOB_SIGNATURE_MIN_CLIENT_VERSION;

            WRITE_DATA(&SignHead, sizeof SignHead);
            WRITE_DATA(m_pbSignature, SIGNATURE_SIZE);
        }

        #undef WRITE_DATA

        schAssert(pCurrent == pSource + cbToWrite);
    }

    //
    // Actually write the data to the file
    //
    if ((flOptions & SAVEP_VARIABLE_LENGTH_DATA) &&
        !(flOptions & SAVEP_RUNNING_INSTANCE_COUNT))
    {
        //
        // Write FIXDLEN_DATA, skip over the running instance count, and
        // write the variable length data
        //
        DWORD cbWritten;
        if (!WriteFile(hFile, pSource, sizeof FIXDLEN_DATA, &cbWritten, NULL)
            || cbWritten != sizeof FIXDLEN_DATA)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, write of Job fixed length data", hr);
            goto Cleanup;
        }

        DWORD dwNewPos = SetFilePointer(hFile,
                                        sizeof(m_cRunningInstances),
                                        NULL,
                                        FILE_CURRENT);
        if (dwNewPos == 0xffffffff)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, moving past running instance count", hr);
            goto Cleanup;
        }

        cbToWrite -= (sizeof FIXDLEN_DATA + sizeof m_cRunningInstances);

        if (!WriteFile(hFile,
                       pSource + (sizeof FIXDLEN_DATA + sizeof m_cRunningInstances),
                       cbToWrite,
                       &cbWritten,
                       NULL)
            || cbWritten != cbToWrite)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, write of Job variable length data", hr);
            goto Cleanup;
        }
    }
    else
    {
        //
        // We can do it all in a single WriteFile.
        //
        DWORD cbWritten;
        if (!WriteFile(hFile, pSource, cbToWrite, &cbWritten, NULL)
            || cbWritten != cbToWrite)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            ERR_OUT("CJob::Save, write of Job", hr);
            goto Cleanup;
        }
    }

    if ((flOptions & SAVEP_VARIABLE_LENGTH_DATA) &&
        !SetEndOfFile(hFile))
    {
        ERR_OUT("CJob::Save, SetEOF", HRESULT_FROM_WIN32(GetLastError()));
    }

Cleanup:

    CloseHandle(hFile);
    hFile = NULL;

    if (pSource != (BYTE *) &flStruct)
    {
        delete [] pSource;
    }

    if (FAILED(hr))
    {
        goto ErrExit;
    }

    } // end scope

    //
    // Notify the shell of the changes.
    //
    if (ptszFileName != NULL)
    {
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, ptszFileName, NULL);
    }
    else
    {
        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, m_ptszFileName, NULL);
    }

    //
    // If doing a Save-As, save the new filename.
    //
    if (fRemember && ptszFileName != NULL)
    {
        delete m_ptszFileName;
        m_ptszFileName = new TCHAR[lstrlen(ptszFileName) + 1];
        if (!m_ptszFileName)
        {
            ERR_OUT("CJob::SaveP", E_OUTOFMEMORY);
            hr = E_OUTOFMEMORY;
            goto ErrExit;
        }

        StringCchCopy(m_ptszFileName, lstrlen(ptszFileName) + 1, ptszFileName);
    }

    if (ptszFileName == NULL || fRemember)
    {
        //
        // BUGBUG: this is not strictly accurate.  There could be a dirty
        // string prop that wouldn't be saved during a light save
        // (SAVEP_VARIABLE_LENGTH_DATA not specified).  This source of
        // potential error could be alleviated by breaking
        // JOB_I_FLAG_PROPERTIES_DIRTY into two flags:
        // JOB_I_FLAG_FIXED_PROPS_DIRTY & JOB_I_FLAG_VAR_PROPS_DIRTY
        //
        ClearFlag(JOB_I_FLAG_PROPERTIES_DIRTY);

        if (flOptions & SAVEP_VARIABLE_LENGTH_DATA)
        {
            ClearFlag(JOB_I_FLAG_TRIGGERS_DIRTY);
        }
    }

    //
    // Set default privileges on the file. This is done only for new
    // files created as a result of save.
    //

    /**********************************
    This ** SHOULD BE ** redundant.  Inherits from container.
    if (fSetSecurity)
    {
        //
        // NB : Logic prior to CreateFile guarantees the file name
        //      will not be NULL.
        //

       hr = SetTaskFileSecurity(ptszFileToSaveAs,
                                 this->IsFlagSet(JOB_I_FLAG_NET_SCHEDULE));

        if (FAILED(hr))
        {
            goto ErrExit;
        }
    }
    ************************************/

    return S_OK;

ErrExit:
    if (hFile != NULL) CloseHandle(hFile);

    if (dwDisposition == CREATE_NEW)
    {
        if (!DeleteFile(ptszFileToSaveAs))
        {
            ERR_OUT("CJob::SaveP: DeleteFile", GetLastError());
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CJob::SaveWithRetry, private
//
//  Synopsis:   Use CJob::SaveP to save the job object to disk with failure retry.
//
//  Arguments:  [ptszFileName] - See CJob::SaveP
//              [fRemember]    - See CJob::SaveP
//              [flOptions]    - See CJob::SaveP
//
//  Notes:      This method is called everywhere SaveP was originally called to
//              add robustness in the event the file is already opened.
//
//----------------------------------------------------------------------------
HRESULT
CJob::SaveWithRetry(LPCTSTR ptszFileName, BOOL fRemember, ULONG flOptions)
{
    HRESULT hr;

    //
    // Write the updated values to the job object. If there are sharing
    // violations, retry up to two times.
    //
    for (int i = 0; i < 3; i++)
    {
        hr = SaveP(ptszFileName, fRemember, flOptions);
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }
        if (hr != HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION))
        {
            //
            // If we have a failure other than sharing violation, we will
            // retry anyway after reporting the error.
            //
            ERR_OUT("SaveWithRetry", hr);
        }

        //
        // Wait semi-pseudo-random amount of time before trying again.
        //
        Sleep(250 + (rand() % 250));
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::SaveCompleted
//
//  Synopsis:   indicates the caller has saved the file with a call to
//              IPersistFile::Save and is finished working with it
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::SaveCompleted(LPCOLESTR pwszFileName)
{
    TRACE(CJob, SaveCompleted);
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IPersistFile::GetCurFile
//
//  Synopsis:   supplies either the absolute path of the currently loaded
//              script file or the default filename prompt, if there is no
//              currently-associated file
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::GetCurFile(LPOLESTR * ppwszFileName)
{
    TRACE(CJob, GetCurFile);

    HRESULT hr;
    TCHAR * ptszName, tszDefaultName[SCH_SMBUF_LEN];
    WCHAR * pwszName, * pwszBuf = NULL;

    if (!m_ptszFileName || m_ptszFileName[0] == TEXT('\0'))
    {
        //
        // No file currently loaded, return default prompt 'cause that is
        // what the OLE spec says to do.
        //
        StringCchCopy(tszDefaultName, SCH_SMBUF_LEN, TEXT("*.") TSZ_JOB);
        ptszName = tszDefaultName;
        hr = S_FALSE;
    }
    else
    {
        ptszName = m_ptszFileName;
        hr = S_OK;
    }

    pwszName = ptszName;
    int size = wcslen(pwszName);
    LPOLESTR pwz;
    pwz = (LPOLESTR)CoTaskMemAlloc((size + 1) * sizeof(WCHAR));
    if (!pwz)
    {
        *ppwszFileName = NULL;
        return E_OUTOFMEMORY;
    }

    StringCchCopy(pwz, size + 1, pwszName);
    *ppwszFileName = pwz;

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::FreeProperties
//
//  Synopsis:   Frees variable length property memory
//
//-----------------------------------------------------------------------------
void
CJob::FreeProperties(void)
{
    for (int iProperty = 0;
         iProperty < ARRAY_LEN(s_StringField);
         iProperty++)
    {
        DELETE_CJOB_FIELD(this->*s_StringField[iProperty])
    }

    DELETE_CJOB_FIELD(m_pbTaskData)
    m_cbTaskData = 0;

    DELETE_CJOB_FIELD(m_pbReserved)
    m_cReserved = 0;

    DELETE_CJOB_FIELD(m_pbSignature)
    m_pbSignature = 0;
}

//+----------------------------------------------------------------------------
//
//  Function:   ReadString
//
//  Synopsis:   Reads a wide char string in from an in-memory buffer
//
//-----------------------------------------------------------------------------
BOOL
ReadString(CInputBuffer * pBuf, LPWSTR *ppwsz)
{
    schAssert(POINTER_IS_ALIGNED(pBuf->CurrentPosition(), ALIGN_WORD));
    schAssert(*ppwsz == NULL);

    //
    // Read the string length
    //
    WORD cch;
    if (!pBuf->Read(&cch, sizeof cch))
    {
        ERR_OUT("ReadString, file lacks string length", 0);
        return FALSE;
    }

    if (cch != 0)
    {
        LPWSTR pwsz = (LPWSTR) pBuf->CurrentPosition();

        //
        // The string length mustn't exceed the buffer size
        //
        if (!pBuf->Advance(cch * sizeof WCHAR))
        {
            ERR_OUT("ReadString, string overruns file size", 0);
            return FALSE;
        }

        //
        // Verify null termination
        //
        if (pwsz[cch-1] != L'\0')
        {
            ERR_OUT("ReadString, string not null terminated", 0);
            return FALSE;
        }

        *ppwsz = pwsz;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
//  Function:   GenerateUniqueID
//
//  Synopsis:   Intialize the UUID passed to a unique ID. On NT, UuidCreate
//              initializes it. If UuidCreate fails, default to our custom
//              ID generation code which is used always on Win95.
//
//  Arguments:  [pUuid] -- Ptr to UUID to initialize.
//
//  Returns:    None.
//
//  Notes:      None.
//
//-----------------------------------------------------------------------------
void
GenerateUniqueID(GUID * pUuid)
{
    schAssert(pUuid != NULL);

    //
    // Call UuidCreate only on NT. If this should fail, drop down to
    // our own id generation.
    //

    if (UuidCreate(pUuid) == RPC_S_OK)
    {
        return;
    }

    //
    // Must generate our own unique id.
    //
    // Set Data 1 to the windows tick count.
    //

    pUuid->Data1 = GetTickCount();

    //
    // Set Data2 & Data3 to the current system time milliseconds
    // and seconds values respectively.
    //

    SYSTEMTIME systime;
    GetSystemTime(&systime);

    pUuid->Data2 = systime.wMilliseconds;
    pUuid->Data3 = systime.wSecond;

    //
    // Write the passed uuid ptr address into the first 4 bytes of
    // Data4. Then write the current system time minute value into
    // the following 2. The remaining 2 we'll leave as-is.
    //

    CopyMemory(&pUuid->Data4, &pUuid, sizeof(GUID *));
    CopyMemory((&pUuid->Data4) + sizeof(GUID *), &systime.wMinute,
                    sizeof(systime.wMinute));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\security.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:
//
//  Interfaces:
//
//  History:    06-Jul-96   MarkBl  Created.
//              03-Mar-01   JBenton Prefix Bug 350196
//                          invalid pointer could be dereferenced on cleanup
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "common.hxx"
#include "debug.hxx"
#include "security.hxx"
#include <StrSafe.h>

typedef struct _MYSIDINFO {
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority;
    DWORD                     dwSubAuthority;
    PSID                      pSid;
} MYSIDINFO;

#define TASK_ALL    (GENERIC_READ    | GENERIC_WRITE |  \
                     GENERIC_EXECUTE | GENERIC_ALL)
#define TASK_READ   (GENERIC_READ)

DWORD   AllocateAndInitializeDomainSid(
            PSID        pDomainSid,
            MYSIDINFO * pDomainSidInfo);
HRESULT GetFileOwnerSid(
            LPCWSTR pwszFileName,
            PSID *  ppSid);


//+---------------------------------------------------------------------------
//
//  Function:   SetTaskFileSecurity
//
//  Synopsis:   Grant the following permissions to the task object:
//
//                  LocalSystem             All Access.
//                  Creator                 All Access.
//                  Domain Admininstrators  All Access.
//
//  Arguments:  [fIsATTask]    -- TRUE if the task is an AT-submitted task;
//                                FALSE otherwise.
//              [pwszTaskPath] -- Task object path.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
SetTaskFileSecurity(LPCWSTR pwszTaskPath, BOOL fIsATTask)
{
#define BASE_SID_COUNT      2
#define DOMAIN_SID_COUNT    1
#define TASK_ACE_COUNT      3

    FILESYSTEMTYPE FileSystemType;
    HRESULT hr;

    hr = GetFileSystemTypeFromPath(pwszTaskPath, &FileSystemType);

    if (FAILED(hr))
    {
        return(hr);
    }

    if (FileSystemType == FILESYSTEM_FAT)
    {
        //
        // No security on FAT. This isn't an error. Let the caller
        // think everything went fine.
        //

        return(S_OK);
    }

    //
    // Retrieve the SID of the file owner.
    //

    PSID pOwnerSid = NULL;

    hr = GetFileOwnerSid(pwszTaskPath, &pOwnerSid);

    if (FAILED(hr))
    {
        return(hr);
    }

    //
    // OK, the fun begins. Build a security descriptor and set file security.
    //

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD                Status;

    SID_IDENTIFIER_AUTHORITY NtAuth         = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY CreatorSidAuth = SECURITY_CREATOR_SID_AUTHORITY;

    MYSIDINFO rgBaseSidInfo[BASE_SID_COUNT] = {
        { &NtAuth,                          // Local System.
          SECURITY_LOCAL_SYSTEM_RID,
          NULL },
        { &NtAuth,                          // Built in domain.
          SECURITY_BUILTIN_DOMAIN_RID,
          NULL }
    };

    MYSIDINFO rgDomainSidInfo[DOMAIN_SID_COUNT] = {
        { NULL,                             // Domain administrators.
          DOMAIN_ALIAS_RID_ADMINS,
          NULL }
    };

    SECURITY_INFORMATION si = DACL_SECURITY_INFORMATION;

    //
    // Make sure we didn't goof.
    //

    schAssert(BASE_SID_COUNT == (sizeof(rgBaseSidInfo) / sizeof(MYSIDINFO)));
    schAssert(DOMAIN_SID_COUNT == (sizeof(rgDomainSidInfo) /
                                                sizeof(MYSIDINFO)));

    //
    // Create the base SIDs.
    //

    DWORD i;

    for (i = 0; i < BASE_SID_COUNT; i++)
    {
        if (!AllocateAndInitializeSid(rgBaseSidInfo[i].pIdentifierAuthority,
                                      1,
                                      rgBaseSidInfo[i].dwSubAuthority,
                                      0, 0, 0, 0, 0, 0, 0,
                                      &rgBaseSidInfo[i].pSid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            break;
        }

        if (!IsValidSid(rgBaseSidInfo[i].pSid))
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the domain SIDs.
        //

        for (i = 0; i < DOMAIN_SID_COUNT; i++)
        {
            DWORD dwError = AllocateAndInitializeDomainSid(
                                                rgBaseSidInfo[1].pSid,
                                                &rgDomainSidInfo[i]);

            if (dwError != ERROR_SUCCESS)
            {
                hr = HRESULT_FROM_WIN32(dwError);
                CHECK_HRESULT(hr);
                break;
            }
        }
    }

    //
    // Create the security descriptor.
    //
    // Possibly adjust the array size to account for two special cases:
    //     1. If this job is an AT job, only local system and administrators
    //        are to have access; don't grant users access. This case
    //        also encompasses case (2).
    //     2. The owner sid and the domain administrator SID will be equal
    //        if the user is an admin. If the user is an admin, ignore the
    //        administrator setting.
    //

    DWORD ActualTaskAceCount;

    if (fIsATTask)
    {
        ActualTaskAceCount = TASK_ACE_COUNT - 1;
    }
    else if (EqualSid(pOwnerSid, rgDomainSidInfo[0].pSid))
    {
        ActualTaskAceCount = TASK_ACE_COUNT - 1;
    }
    else
    {
        ActualTaskAceCount = TASK_ACE_COUNT;
    }

    PACCESS_ALLOWED_ACE rgAce[TASK_ACE_COUNT] = {
        NULL, NULL, NULL                   // Supply this to CreateSD so we
    };                                      // so we don't have to allocate
                                            // memory.
    MYACE rgMyAce[TASK_ACE_COUNT] = {
        { TASK_ALL,                         // Acess mask.
          NO_PROPAGATE_INHERIT_ACE,         // Inherit flags.
          rgBaseSidInfo[0].pSid },          // SID.
        { TASK_ALL,
          NO_PROPAGATE_INHERIT_ACE,
          rgDomainSidInfo[0].pSid },
        { TASK_ALL,
          NO_PROPAGATE_INHERIT_ACE,
          pOwnerSid }
    };

    schAssert(TASK_ACE_COUNT == (sizeof(rgAce)/sizeof(PACCESS_ALLOWED_ACE)) &&
              TASK_ACE_COUNT == (sizeof(rgMyAce) / sizeof(MYACE)));

    if (FAILED(hr))
    {
        goto CleanExit;
    }

    if ((pSecurityDescriptor = CreateSecurityDescriptor(ActualTaskAceCount,
                                                        rgMyAce,
                                                        rgAce,
                                                        &Status)) == NULL)
    {
        hr = HRESULT_FROM_WIN32(Status);
        goto CleanExit;
    }

    //
    // Finally, set permissions.
    //

    if (!SetFileSecurity(pwszTaskPath, si, pSecurityDescriptor))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        goto CleanExit;
    }

CleanExit:
    delete pOwnerSid;
    for (i = 0; i < BASE_SID_COUNT; i++)
    {
        if (rgBaseSidInfo[i].pSid != NULL)
        {
            FreeSid(rgBaseSidInfo[i].pSid);
        }
    }
    for (i = 0; i < DOMAIN_SID_COUNT; i++)
    {
        if (rgDomainSidInfo[i].pSid != NULL)
        {
            delete rgDomainSidInfo[i].pSid;
        }
    }
    if (pSecurityDescriptor != NULL)
    {
        DeleteSecurityDescriptor(pSecurityDescriptor);
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocateAndInitializeDomainSid
//
//  Synopsis:
//
//  Arguments:  [pDomainSid]     --
//              [pDomainSidInfo] --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
DWORD
AllocateAndInitializeDomainSid(
    PSID        pDomainSid,
    MYSIDINFO * pDomainSidInfo)
{
    UCHAR DomainIdSubAuthorityCount;
    DWORD SidLength;

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(GetSidSubAuthorityCount(pDomainSid));
    SidLength = GetSidLengthRequired(DomainIdSubAuthorityCount + 1);

    pDomainSidInfo->pSid = new BYTE[SidLength];

    if (pDomainSidInfo->pSid == NULL)
    {
        CHECK_HRESULT(E_OUTOFMEMORY);
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if (!CopySid(SidLength, pDomainSidInfo->pSid, pDomainSid))
    {
        delete pDomainSidInfo->pSid;
        pDomainSidInfo->pSid = NULL;
        CHECK_HRESULT(HRESULT_FROM_WIN32(GetLastError()));
        return(GetLastError());
    }

    //
    // Adjust the sub-authority count and add the relative Id unique
    // to the newly allocated SID
    //

    (*(GetSidSubAuthorityCount(pDomainSidInfo->pSid)))++;
    *(GetSidSubAuthority(pDomainSidInfo->pSid,
                         DomainIdSubAuthorityCount)) =
                                            pDomainSidInfo->dwSubAuthority;

    return(ERROR_SUCCESS);
}

//+---------------------------------------------------------------------------
//
//  Function:   GetFileOwnerSid
//
//  Synopsis:
//
//  Arguments:  [pwszFileName] --
//              [ppSid]        --
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
HRESULT
GetFileOwnerSid(LPCWSTR pwszFileName, PSID * ppSid)
{
    DWORD   cbSizeNeeded;

    //
    // Retrieve the file owner. Call GetFileSecurity twice - first to get
    // the buffer size, then the actual information retrieval.
    //

    if (GetFileSecurity(pwszFileName,
                        OWNER_SECURITY_INFORMATION,
                        NULL,
                        0,
                        &cbSizeNeeded))
    {
        //
        // Didn't expect this to succeed!
        //

        CHECK_HRESULT(E_UNEXPECTED);
        return(E_UNEXPECTED);
    }

    DWORD                Status         = GetLastError();
    PSECURITY_DESCRIPTOR pOwnerSecDescr = NULL;
    HRESULT              hr             = S_OK;

    if ((Status == ERROR_INSUFFICIENT_BUFFER) && (cbSizeNeeded > 0))
    {
        //
        // Allocate the buffer space necessary and retrieve the info.
        //

        pOwnerSecDescr = (SECURITY_DESCRIPTOR *)new BYTE[cbSizeNeeded];

        if (pOwnerSecDescr == NULL)
        {
            CHECK_HRESULT(E_OUTOFMEMORY);
            return(E_OUTOFMEMORY);
        }

        if (!GetFileSecurity(pwszFileName,
                             OWNER_SECURITY_INFORMATION,
                             pOwnerSecDescr,
                             cbSizeNeeded,
                             &cbSizeNeeded))
        {
            delete pOwnerSecDescr;
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
            return(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
        return(hr);
    }

    //
    // Retrieve & validate the owner sid.
    //
    // NB : After this, pOwnerSid will point into the security descriptor,
    //      pOwnerSecDescr; hence, the descriptor must exist for the
    //      lifetime of pOwnerSid.
    //

    DWORD cbOwnerSid;
    PSID  pOwnerSid;
    BOOL  fOwnerDefaulted;

    if (GetSecurityDescriptorOwner(pOwnerSecDescr,
                                   &pOwnerSid,
                                   &fOwnerDefaulted))
    {
        if (IsValidSid(pOwnerSid))
        {
            *ppSid = new BYTE[cbOwnerSid = GetLengthSid(pOwnerSid)];

            if (*ppSid != NULL)
            {
                if (!CopySid(cbOwnerSid, *ppSid, pOwnerSid))
                {
                    delete *ppSid;
                    *ppSid = NULL;
                    hr = HRESULT_FROM_WIN32(GetLastError());
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
            }

        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        CHECK_HRESULT(hr);
    }

    delete pOwnerSecDescr;

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\job\util.cxx ===
//+----------------------------------------------------------------------------
//
//  Job Schedule Application Job Object Handler
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       util.cxx
//
//  Contents:   job & trigger objects IUnknown methods, class factory, DLL fcns,
//              plus misc utility fcns
//
//  Classes:    CJob (continued), CJobCF, CTrigger
//
//  Interfaces: IUnknown, IClassFactory
//
//  History:    24-May-95 EricB created
//
//-----------------------------------------------------------------------------

#include "..\pch\headers.hxx"
#pragma hdrstop
#include "job.hxx"
#include <StrSafe.h>

//+----------------------------------------------------------------------------
//
//  Member:     CJob::GetAtInfo
//
//  Synopsis:   for a downlevel job, return its data in an AT_INFO struct.
//
//  Arguments:  [pAt] - pointer to the AT_INFO struct
//              [pwszCommand] - buffer for the command string
//              [pcchCommand] - on input, size of supplied buffer, on output,
//                              size needed/used.
//
//  Returns:    HRESULTS - ERROR_INSUFFICIENT_BUFFER if too small
//                       - SCHED_E_NOT_AN_AT_JOB if not an AT job
//
//  Notes:      This method is not exposed to external clients, thus it is not
//              part of a public interface.
//-----------------------------------------------------------------------------
HRESULT
CJob::GetAtInfo(PAT_INFO pAt, LPWSTR pwszCommand, DWORD * pcchCommand)
{
    TRACE(CJob, GetAtInfo);
    HRESULT hr = S_OK;

    if (!(m_rgFlags & JOB_I_FLAG_NET_SCHEDULE))
    {
        schDebugOut((DEB_ERROR,
            "CJob::GetAtInfo: Task object is not an AT job!\n"));
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    }

    //
    // The ApplicationName and Parameters properties need to be concatonated
    // and returned as pwszCommand. If there is any white space in the app
    // name string, then it must be enclosed in quotes.
    //

    LPWSTR pwszAppName, pwszParams;

    hr = GetApplicationName(&pwszAppName);
    if (FAILED(hr))
    {
        ERR_OUT("GetAtInfo: GetApplicationName", hr);
        return hr;
    }

    hr = GetParameters(&pwszParams);
    if (FAILED(hr))
    {
        ERR_OUT("GetAtInfo: GetParameters", hr);
        CoTaskMemFree(pwszAppName);
        return hr;
    }

    //
    // Check for whitespace in the app name.
    //
    BOOL fAppNameHasSpaces = HasSpaces(pwszAppName);

    //
    // If there is app name whitespace, add two for the quotes to be added.
    //
    DWORD cchApp = wcslen(pwszAppName) + (fAppNameHasSpaces ? 2 : 0);
    DWORD cchParam = wcslen(pwszParams);
    //
    // Add one for the terminating null and ont to concatenate the params
    //
    DWORD cch = cchApp + cchParam + 1 + 1;

    if (cch > *pcchCommand)
    {
        *pcchCommand = cch;
        CoTaskMemFree(pwszAppName);
        CoTaskMemFree(pwszParams);
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    *pcchCommand = cch;

    if (fAppNameHasSpaces)
    {
        StringCchCopy(pwszCommand, *pcchCommand, L"\"");
        StringCchCat(pwszCommand, *pcchCommand, pwszAppName);
        StringCchCat(pwszCommand, *pcchCommand, L"\"");
    }
    else
    {
        StringCchCopy(pwszCommand, *pcchCommand, pwszAppName);
    }

    if (cchParam > 0)
    {
        StringCchCat(pwszCommand, *pcchCommand, L" ");
        StringCchCat(pwszCommand, *pcchCommand, pwszParams);
    }

    CoTaskMemFree(pwszAppName);
    CoTaskMemFree(pwszParams);

    //
    // An AT job can have one or two triggers of type TASK_TIME_TRIGGER_WEEKLY
    // and/or TASK_TIME_TRIGGER_MONTHLYDATE.  It may also have, instead, a single trigger
    // of type TASK_TIME_TRIGGER_ONCE, which indicates it runs either today or
    // tomorrow, only.
    //
    WORD cTriggers = m_Triggers.GetCount();

    if (cTriggers == 0 || cTriggers > 2)
    {
        ERR_OUT("GetAtInfo: Incorrect Trigger Count", E_FAIL);
        return E_FAIL;
    }

    PTASK_TRIGGER pjt;

    pjt = _GetTrigger(0);
    if (pjt == NULL)
    {
        schAssert(!"GetCount > 0 but no trigger 0");
        return E_FAIL;
    }

    pAt->JobTime = (pjt->wStartHour * JOB_MINS_PER_HOUR +
                    pjt->wStartMinute) * JOB_MILLISECONDS_PER_MINUTE;

    pAt->DaysOfMonth = pAt->DaysOfWeek = 0;

    switch (pjt->TriggerType)
    {
    case TASK_TIME_TRIGGER_WEEKLY:
        //
        // Convert Scheduler DOW to AT_INFO DOW:
        // Scheduler rgfDaysOfTheWeek: Sunday = bit 0, Monday = bit 1.
        // AT_INFO DaysOfWeek: Monday = bit 0, Sunday = bit 6.
        //
        pAt->DaysOfWeek = pjt->Type.Weekly.rgfDaysOfTheWeek >> 1;

        if (pjt->Type.Weekly.rgfDaysOfTheWeek & 0x0001)
        {
            pAt->DaysOfWeek |= 0x0040;
        }
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
        pAt->DaysOfMonth = pjt->Type.MonthlyDate.rgfDays;
        break;

    case TASK_TIME_TRIGGER_ONCE:
        // Day of Month & Week are NULL if the job runs only once.
        break;

    default:
        schAssert(FALSE && "GetAtInfo: wrong trigger type");
        ERR_OUT("GetAtInfo: wrong trigger type", hr);
        return E_FAIL;
    }

    if (cTriggers == 2)
    {
        pjt = _GetTrigger(1);

        switch (pjt->TriggerType)
        {
        case TASK_TIME_TRIGGER_WEEKLY:
            //
            // Convert Scheduler DOW to AT_INFO DOW:
            // Scheduler rgfDaysOfTheWeek: Sunday = bit 0, Monday = bit 1.
            // AT_INFO DaysOfWeek: Monday = bit 0, Sunday = bit 6.
            //
            pAt->DaysOfWeek = pjt->Type.Weekly.rgfDaysOfTheWeek >> 1;

            if (pjt->Type.Weekly.rgfDaysOfTheWeek & 0x0001)
            {
                pAt->DaysOfWeek |= 0x0040;
            }
            break;

        case TASK_TIME_TRIGGER_MONTHLYDATE:
            pAt->DaysOfMonth = pjt->Type.MonthlyDate.rgfDays;
            break;

        case TASK_TIME_TRIGGER_ONCE:
            schAssert(FALSE && "GetAtInfo: Once triggers not allowed in multiple triggers!");
            ERR_OUT("GetAtInfo: Once triggers not allowed in multiple triggers!", 0);
            return E_FAIL;
            break;

        default:
            schAssert(FALSE && "GetAtInfo: wrong trigger type");
            ERR_OUT("GetAtInfo: wrong trigger type", 0);
            return E_FAIL;
        }
    }

    //
    // Set the AT_INFO.Flags.
    //

    pAt->Flags = 0;

    if (!(m_rgFlags & TASK_FLAG_INTERACTIVE))
    {
        pAt->Flags |= JOB_NONINTERACTIVE;
    }

    if (!(pjt->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE) &&
         (pjt->TriggerType != TASK_TIME_TRIGGER_ONCE))
    {
        pAt->Flags |= JOB_RUN_PERIODICALLY;
    }

    //
    // Check whether job runs today, or is even running in a time window
    // that is valid for a NetScheduleJob.
    //

    SYSTEMTIME stNow, stMidnight, stTomorrow;
    GetLocalTime(&stNow);

    WORD cRuns = 0;

    // Check to see if there is a run today and set the flag JOB_RUNS_TODAY

    stMidnight = stNow;
    stMidnight.wHour = stMidnight.wMinute = stMidnight.wSecond
        = stMidnight.wMilliseconds = 0;
    IncrementDay(&stMidnight);

    // Zero out cRuns - we used it, and it is not initialized in GetRunTimesP
    cRuns = 0;

    hr = GetRunTimesP(&stNow, &stMidnight, &cRuns, 1, NULL, NULL);

    if (FAILED(hr))
    {
        ERR_OUT("GetAtInfo: GetRunTimes", hr);
        return hr;
    }

    if (cRuns > 0)
    {
        pAt->Flags |= JOB_RUNS_TODAY;
    }

    //
    // Check exit status of last run and set TASK_EXEC_ERROR as needed.
    //
    if (IsFlagSet(JOB_I_FLAG_LAST_LAUNCH_FAILED) ||
        IsFlagSet(JOB_I_FLAG_ERROR_IN_LAST_RUN))
    {
        pAt->Flags |= JOB_EXEC_ERROR;
    }

    //
    // Safety check - if the trigger is a ONCE trigger, the job
    // must within the next 24 hours (or already be running)
    //
    //

    if (pjt->TriggerType == TASK_TIME_TRIGGER_ONCE &&
        !(pAt->Flags & JOB_EXEC_ERROR))
    {
       stTomorrow = stNow;
       IncrementDay(&stTomorrow);

       hr = GetRunTimesP(&stNow, &stTomorrow, &cRuns, 1, NULL, NULL);
       if (FAILED(hr))
       {
          ERR_OUT("GetAtInfo: GetRunTimes for Once Trigger", hr);
          return hr;
       }
       HRESULT status;
       GetStatus(&status);

       if (cRuns == 0)
       {
            if (status == SCHED_S_TASK_RUNNING)
                pAt->Flags |= JOB_RUNS_TODAY;
            else
            {
                ERR_OUT("GetAtInfo: Once trigger outside permitted time interval", 0);
                return E_FAIL;
            }
       }
    }

    //
    // Omit jobs whose end date has passed (usually jobs that haven't yet
    // been deleted because they're still running)
    //
    if (pjt->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
    {
        SYSTEMTIME  stEnd;
        stEnd.wYear      = pjt->wEndYear;
        stEnd.wMonth     = pjt->wEndMonth;
        stEnd.wDayOfWeek = 0;
        stEnd.wDay       = pjt->wEndDay;
        stEnd.wHour      = pjt->wStartHour;
        stEnd.wMinute    = pjt->wStartMinute;
        stEnd.wSecond    = 0;
        stEnd.wMilliseconds = 0;
        if (IsFirstTimeEarlier(&stEnd, &stNow) &&
            !(pAt->Flags & JOB_EXEC_ERROR))
        {
            return E_FAIL;
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::UpdateJobState
//
//  Synopsis:   Update the job flags and status depending on whether there are
//              valid triggers with more run times.
//
//  Arguments:  [fRunning] - optional param, defaults to false.
//                           CSchedWorker::RunJobs sets this to true while
//                           setting the new job status to
//                           SCHED_S_TASK_RUNNING. So, don't change the job's
//                           status if fRunning.
//
//  Returns:    HRESULTS
//
//  Notes:      The triggers have to be loaded.
//-----------------------------------------------------------------------------
HRESULT
CJob::UpdateJobState(BOOL fRunning)
{
    //TRACE(CJob, UpdateJobState);

    if (!IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
    {
        //
        // The job can't run without an appname.
        //
        SetStatus(SCHED_S_TASK_NOT_SCHEDULED);
        return S_OK;
    }

    SYSTEMTIME stNow;
    GetLocalTime(&stNow);

    if (fRunning)
    {
        //
        // Increment the minute value so that the current run won't be returned.
        //
        stNow.wMinute++;
        if (stNow.wMinute >= JOB_MINS_PER_HOUR)
        {
            stNow.wHour++;
            stNow.wMinute = 0;
            if (stNow.wHour >= JOB_HOURS_PER_DAY)
            {
                stNow.wHour = 0;
                IncrementDay(&stNow);
            }
        }
    }

    WORD cRuns = 0;
    HRESULT hr;

    hr = GetRunTimesP(&stNow, NULL, &cRuns, 1, NULL, NULL);
    if (FAILED(hr))
    {
        ERR_OUT("CJob::UpdateJobState", hr);
        return hr;
    }

    //
    // Update the job flags and status properties.
    //
    if (hr == SCHED_S_TASK_NO_VALID_TRIGGERS)
    {
        SetFlag(JOB_I_FLAG_NO_VALID_TRIGGERS);

        SetStatus(SCHED_S_TASK_NOT_SCHEDULED);
    }
    else
    {
        ClearFlag(JOB_I_FLAG_NO_VALID_TRIGGERS);

        if (cRuns == 0 && hr != SCHED_S_EVENT_TRIGGER)
        {
            SetFlag(JOB_I_FLAG_NO_MORE_RUNS);
        }
        else
        {
            ClearFlag(JOB_I_FLAG_NO_MORE_RUNS);

            //
            // If the job isn't currently running and had not been ready to run but
            // now have both valid triggers and valid properties, set the status.
            // TODO: test TASK_FLAG_HAS_OBJPATH and TASK_FLAG_HAS_ACCOUNT when those
            //       properties are functional.
            //
            if (!fRunning && IsFlagSet(JOB_I_FLAG_HAS_APPNAME))
            {
                if (m_stMostRecentRunTime.wYear == 0)
                {
                    //
                    // Job has never run if last-run-time property is null (all
                    // elements will be zero if null, testing year is sufficient).
                    //
                    SetStatus(SCHED_S_TASK_HAS_NOT_RUN);
                }
                else
                {
                    //
                    // Job has run in the past, so it is now waiting to run again.
                    //
                    SetStatus(SCHED_S_TASK_READY);
                }
            }
        }
    }

    //
    // The disabled flag takes precedence over other states.
    //
    if (IsFlagSet(TASK_FLAG_DISABLED))
    {
        SetStatus(SCHED_S_TASK_DISABLED);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::PostRunUpdate
//
//  Synopsis:   update the status of a job object after a run exits
//
//  Arguments:  [ExitCode]    - the run's exit code
//              [fFinishedOK] - only set the job object's exit code if TRUE.
//
//  Returns:    HRESULTS
//
//  Notes:      Set the ExitCode and Status values for the job and log the run
//              if the LogRunHistory property is set.
//              This method is not exposed to external clients, thus it is not
//              part of a public interface.
//              If any of the variable length properties or the triggers are
//              needed, then the caller will need to do a full activation of
//              the job.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::PostRunUpdate(long ExitCode, BOOL fFinishedOK)
{
    schDebugOut((DEB_ITRACE, "PostRunUpdate: decrementing running instance "
                 "count (%d before decrement)\n", m_cRunningInstances));
    if (m_cRunningInstances > 0)
    {
        m_cRunningInstances--;
    }

    //
    // Don't update the status unless the running instance count is back to
    // zero.
    //
    if (m_cRunningInstances == 0)
    {
        if (IsFlagSet(JOB_I_FLAG_NO_VALID_TRIGGERS))
        {
            SetStatus(SCHED_S_TASK_NO_VALID_TRIGGERS);
        }
        else
        {
            SetStatus(SCHED_S_TASK_READY);
        }
    }

    if (fFinishedOK)
    {
        m_ExitCode = ExitCode;
    }

    ClearFlag(JOB_I_FLAG_ABORT_NOW);

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfEventJobAddToList
//
//  Synopsis:   Check if the job has any triggers of the specified event type.
//              If so, allocate and initialize a CRun object and add it to the
//              list.  Add it to pIdleWaitList if it needs to wait for an
//              idle period, otherwise add it to pRunList.
//
//  Arguments:  [EventType]        - the event trigger type
//              [ptszJobName] - the short job name to pass to CRun.
//              [pRunList]    - a pointer to a run list object.
//              [pIdleWaitList] - a pointer to a run list object sorted by
//                  idle wait times.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//              If EventType is not TASK_EVENT_TRIGGER_ON_IDLE, this method is
//              only called when the event has occurred.  (If EventType is
//              TASK_EVENT_TRIGGER_ON_IDLE, this method is called when
//              building the wait list from the tasks folder's contents.)
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfEventJobAddToList(TASK_TRIGGER_TYPE EventType, LPCTSTR ptszJobName,
                          CRunList * pRunList, CIdleRunList * pIdleWaitList)
{
    schAssert(EventType == TASK_EVENT_TRIGGER_ON_IDLE ||
              EventType == TASK_EVENT_TRIGGER_AT_SYSTEMSTART ||
              EventType == TASK_EVENT_TRIGGER_AT_LOGON);

    if (! IsFlagSet(JOB_I_FLAG_HAS_TRIGGERS))
    {
        // (An optimization; the function would still work without it)
        return S_FALSE;
    }

    if (EventType == TASK_EVENT_TRIGGER_ON_IDLE && m_wIdleWait == 0)
    {
        //
        // We ignore all idle triggers if the idle wait time is 0.
        //
        return S_FALSE;
    }

    //
    // Will the job need to wait for an idle period before being started?
    //
    BOOL fNeedIdleWait = ((EventType == TASK_EVENT_TRIGGER_ON_IDLE ||
                           IsFlagSet(TASK_FLAG_START_ONLY_IF_IDLE))
                          && m_wIdleWait > 0);

    HRESULT hr;
    FILETIME ftNow = GetLocalTimeAsFileTime();
    // BUGBUG  ftNow should be passed in, and the same ftNow should be used
    // when checking against the deadlines.  Otherwise a run can be missed
    // if we're slow here and the deadline elapses.

    //
    // See if the job has any triggers of the specified type.
    // Find the latest deadline of these triggers.
    //
    FILETIME   ftLatestDeadline = { 0, 0 };
    for (WORD i = 0; i < m_Triggers.GetCount(); i++)
    {
        if (m_Triggers[i].TriggerType != EventType)
        {
            continue;
        }

        //
        // If the trigger is an idle trigger then the trigger's deadline
        // is simply midnight on the trigger's end date.
        //
        // If the job does not have TASK_FLAG_START_ONLY_IF_IDLE then
        // the trigger's deadline is simply midnight on the trigger's
        // end date.
        //
        // If the job does have TASK_FLAG_START_ONLY_IF_IDLE then the
        // trigger's deadline is
        //   min( trigger's end date,
        //        job's start time + trigger's MinutesDuration)
        //
        FILETIME ftDeadline             // This trigger's deadline
            = MAX_FILETIME;             // End date if no end date set

        if (m_Triggers[i].rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
        {
            SYSTEMTIME stEnd =          // This trigger's end date
            {
                m_Triggers[i].wEndYear,
                m_Triggers[i].wEndMonth,
                0,          // wDayOfWeek
                m_Triggers[i].wEndDay,
                23,         // wHour
                59,         // wMinute
                0,          // wSecond
                0           // wMilliseconds
            };

            if (!SystemTimeToFileTime(&stEnd, &ftDeadline))
            {
                // Presume the trigger had an invalid end date.
                // Ignore the trigger.  BUGBUG return an error ?
                continue;
            }
        }

        if (EventType != TASK_EVENT_TRIGGER_ON_IDLE && fNeedIdleWait)
        {
            //
            // Calculate (job's start time + trigger's MinutesDuration)
            // This method is only called when the event that fires the
            // trigger has occurred, so the job's start time is now.
            //
            FILETIME ftDurationEnd = ftNow;
            AddMinutesToFileTime(&ftDurationEnd, m_Triggers[i].MinutesDuration);

            ftDeadline = minFileTime(ftDeadline, ftDurationEnd);
        }

        ftLatestDeadline = maxFileTime(ftLatestDeadline, ftDeadline);
    }

    if (CompareFileTime(&ftLatestDeadline, &ftNow) < 0)
    {
        //
        // All the triggers of this type have expired.
        //
        return S_FALSE;
    }


    //
    // Add the job to the appropriate run list.
    //
    CRun * pNewRun;
    if (fNeedIdleWait)
    {
        DBG_OUT("Adding idle job to list.");
        pNewRun = new CRun(m_dwMaxRunTime, GetUserFlags(), m_wIdleWait,
                           ftLatestDeadline,
                           (EventType == TASK_EVENT_TRIGGER_ON_IDLE));
    }
    else
    {
        pNewRun = new CRun(m_dwMaxRunTime, GetUserFlags(), MAX_FILETIME,
                           FALSE);
    }

    if (pNewRun == NULL)
    {
        ERR_OUT("CJob::IfEventJobAddToList new CRun", E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    // Complete job info object initialization.
    //
    hr = pNewRun->Initialize(ptszJobName);

    if (FAILED(hr))
    {
        ERR_OUT("CJob::IfEventJobAddToList, CRun->Initialize", hr);
        delete pNewRun;
        return hr;
    }

    if (fNeedIdleWait)
    {
        pIdleWaitList->AddSortedByIdleWait(pNewRun);
    }
    else
    {
        pRunList->Add(pNewRun);
    }
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfStartupJobAddToList
//
//  Synopsis:   Check if the job has any startup triggers. If so, allocate and
//              initialize a CRun object and add it to the list.
//
//  Arguments:  [ptszJobName] - the short job name to pass to CRun.
//              [pRunList]    - a pointer to a run list object.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfStartupJobAddToList(LPTSTR ptszJobName, CRunList * pRunList,
                            CIdleRunList * pIdleWaitList)
{
    return IfEventJobAddToList(TASK_EVENT_TRIGGER_AT_SYSTEMSTART, ptszJobName,
                               pRunList, pIdleWaitList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfLogonJobAddToList
//
//  Synopsis:   Check if the job has any logon triggers. If so, allocate and
//              initialize a CRun object and add it to the list.
//
//  Arguments:  [ptszJobName] - the short job name to pass to CRun.
//              [pRunList]    - a pointer to a run list object.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfLogonJobAddToList(LPTSTR ptszJobName, CRunList * pRunList,
                          CIdleRunList * pIdleWaitList)
{
    return IfEventJobAddToList(TASK_EVENT_TRIGGER_AT_LOGON, ptszJobName,
                               pRunList, pIdleWaitList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IfIdleJobAddToList
//
//  Synopsis:   Check if the job has any idle triggers. If so, allocate and
//              initialize a CRun object and add it to the list.
//
//  Arguments:  [ptszJobName] - the short job name to pass to CRun.
//              [pIdleWaitList] - a pointer to a run list object.
//
//  Returns:    S_OK if the event trigger is found, S_FALSE if not, or a
//              fatal error code.
//
//  Assumes:    Triggers have already been loaded.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::IfIdleJobAddToList(LPTSTR ptszJobName, CIdleRunList * pIdleWaitList)
{
    return IfEventJobAddToList(TASK_EVENT_TRIGGER_ON_IDLE, ptszJobName,
                               NULL, pIdleWaitList);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::Delete
//
//  Synopsis:   Remove the file object for this job.
//
//-----------------------------------------------------------------------------
HRESULT
CJob::Delete(void)
{
    schDebugOut((DEB_ITRACE, "CJob:Delete on %S\n", m_ptszFileName));

    if (m_ptszFileName == NULL)
    {
        return E_INVALIDARG;
    }

    if (!DeleteFile(m_ptszFileName))
    {
        schDebugOut((DEB_ITRACE, "DeleteFile failed with error %d\n",
                     GetLastError()));
        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//      CJob::IUnknown methods
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJob::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CJob::QueryInterface\n"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(ITask *)this;
    }
    else if (IID_ITask == riid)
    {
        *ppvObject = (IUnknown *)(ITask *)this;
    }
    else if (IID_IScheduledWorkItem == riid)
    {
        *ppvObject = (IUnknown *)(IScheduledWorkItem *)this;
    }
    else if (IID_IPersist == riid)
    {
        *ppvObject = (IUnknown *)(IPersist *)this;
    }
    else if (IID_IPersistFile == riid)
    {
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    }
    else if (IID_IProvideTaskPage == riid)
    {
        *ppvObject = (IUnknown *)(IProvideTaskPage *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJob::AddRef(void)
{
    //schDebugOut((DEB_ITRACE, "CJob::AddRef refcount going in %d\n", m_cReferences));
    return InterlockedIncrement((long *)&m_cReferences);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJob::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    the reference count
//
//  Notes:      BUGBUG: do we need to check the refcount on the triggers
//              before freeing the job object?
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJob::Release(void)
{
    //schDebugOut((DEB_ITRACE, "CJob::Release ref count going in %d\n", m_cReferences));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_cReferences)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//      CJobCF - class factory for the Job object
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::Create
//
//  Synopsis:   creates a new class factory object
//
//-----------------------------------------------------------------------------
IClassFactory *
CJobCF::Create(void)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::Create\n"));
    return new CJobCF;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::CJobCF
//
//  Synopsis:   ctor
//
//-----------------------------------------------------------------------------
CJobCF::CJobCF(void)
{
    m_uRefs = 1;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::~CJobCF
//
//  Synopsis:   dtor
//
//-----------------------------------------------------------------------------
CJobCF::~CJobCF(void)
{
    //schDebugOut((DEB_ITRACE, "~CJobCF: DLL ref count going in %d\n",
    //           g_cDllRefs));
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJobCF::QueryInterface(REFIID riid, void ** ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::QueryInterface"));
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)this;
    }
    else if (IsEqualIID(IID_IClassFactory, riid))
    {
        *ppvObject = (IClassFactory *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJobCF::AddRef(void)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::AddRef\n"));
    return InterlockedIncrement((long *)&m_uRefs);
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count and frees it when
//              no longer referenced.
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CJobCF::Release(void)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::Release ref count going in %d\n",
    //           m_uRefs));
    unsigned long uTmp;
    if ((uTmp = InterlockedDecrement((long *)&m_uRefs)) == 0)
    {
        delete this;
    }
    return uTmp;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IClassFactory::CreateInstance
//
//  Synopsis:   create an incore instance of the job class object
//
//  Arguments:  [pUnkOuter] - aggregator
//              [riid]      - requested interface
//              [ppvObject] - receptor for itf ptr
//
//  Returns:    HRESULTS
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJobCF::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    //schDebugOut((DEB_ITRACE, "CJobCF::CreateInstance\n"));
    SCODE sc = S_OK;
    ITask * pJob = CJob::Create();
    if (pJob == NULL)
    {
        *ppvObject = NULL;
        return E_OUTOFMEMORY;
    }
    sc = pJob->QueryInterface(riid, ppvObject);
    if (FAILED(sc))
    {
        *ppvObject = NULL;
        return sc;
    }
    // we got a refcount of one when launched, and the above QI increments it
    // to 2, so call release to take it back to 1
    pJob->Release();
    return sc;
}

//+----------------------------------------------------------------------------
//
//  Member:     CJobCF::IClassFactory::LockServer
//
//  Synopsis:   Called with fLock set to TRUE to indicate that the server
//              should continue to run even if none of its objects are active
//
//  Arguments:  [fLock] - increment/decrement the instance count
//
//  Returns:    HRESULTS
//
//  Notes:      This function is a no-op since the server is in-proc.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CJobCF::LockServer(BOOL fLock)
{
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  CTrigger::IUnknown methods
//
//  Notes:  A trigger is not a first class COM object. They do not exist as
//          separate entities outside of Job objects; you cannot do a
//          CoCreateInstance on one and they do not go away when their ref
//          count goes to zero. When a job object is instanciated, its triggers
//          are also instanciated and they are freed from memory when the job
//          object is freed from memory. Trigger ref counting is used only to
//          prevent a client from deleting a trigger while it is holding a
//          pointer to that trigger.
//
//          Note also that the containing job object is AddRef'd and Release'd
//          along with each trigger so that the job object will not be deleted
//          while clients are holding trigger pointers.
//
//-----------------------------------------------------------------------------

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::IUnknown::QueryInterface
//
//  Synopsis:   Returns requested interface pointer
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CTrigger::QueryInterface(REFIID riid, void ** ppvObject)
{
    if (IID_IUnknown == riid)
    {
        *ppvObject = (IUnknown *)(ITaskTrigger *)this;
    }
    else
    if (IID_ITaskTrigger == riid)
    {
        *ppvObject = (IUnknown *)(ITaskTrigger *)this;
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::IUnknown::AddRef
//
//  Synopsis:   increments reference count
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CTrigger::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cReferences);
}

//+----------------------------------------------------------------------------
//
//  Member:     CTrigger::IUnknown::Release
//
//  Synopsis:   Decrements the object's reference count.
//
//  Returns:    the reference count
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CTrigger::Release(void)
{
    unsigned long uTmp;

    if ((uTmp = InterlockedDecrement((long *)&m_cReferences)) == 0)
    {
        delete this;
    }

    return uTmp;
}


//+--------------------------------------------------------------------------
//
//  Function:   IsValidMonthlyDateTrigger
//
//  Synopsis:   Return TRUE if [pTrigger] has a valid combination of month
//              and day bits set.
//
//  History:    10-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsValidMonthlyDateTrigger(
    PTASK_TRIGGER pTrigger)
{
    if (pTrigger->Type.MonthlyDate.rgfDays > JOB_RGFDAYS_MAX ||
        pTrigger->Type.MonthlyDate.rgfMonths == 0            ||
        pTrigger->Type.MonthlyDate.rgfMonths > JOB_RGFMONTHS_MAX)
    {
        return FALSE;
    }

    if (pTrigger->Type.MonthlyDate.rgfDays == 0)
    {
        //
        // rgfDays must be non-zero.
        //
        return FALSE;
    }

    //
    // More detailed testing to see if non-existent dates have been
    // specified, for example: Feb. 30th, without specifying valid dates.
    // That is, it is OK to specify invalid dates as long as there are
    // valid dates. E.g., someone may want to specify: run on the 25th
    // through 31st of every month. While that is acceptable, saying run
    // only on Feb 31st is invalid.
    //

    if (pTrigger->Type.MonthlyDate.rgfDays & 0x40000000 &&
        pTrigger->Type.MonthlyDate.rgfMonths & (TASK_FEBRUARY | TASK_APRIL |
                                                TASK_JUNE | TASK_SEPTEMBER |
                                                TASK_NOVEMBER) &&
        !(pTrigger->Type.MonthlyDate.rgfMonths & ~(TASK_FEBRUARY  |
                                                   TASK_APRIL     |
                                                   TASK_JUNE      |
                                                   TASK_SEPTEMBER |
                                                   TASK_NOVEMBER)))
    {
        //
        // None of these months have a 31st day.
        //
        return FALSE;
    }

    if (pTrigger->Type.MonthlyDate.rgfDays & 0x20000000 &&
        pTrigger->Type.MonthlyDate.rgfMonths & TASK_FEBRUARY &&
        !(pTrigger->Type.MonthlyDate.rgfMonths & ~TASK_FEBRUARY))
    {
        //
        // February does not have a 30th day. Allow for the specification
        // of the 29th to run on leap year.
        //
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\advanced.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       advanced.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/13/1996   RaviR   Created
//				11/16/00	Dgrube  Remove     Win4Assert(m_pjt->MinutesInterval >= 0);
//							Win4Assert(m_pjt->MinutesDuration >= 0); Since they are
//							DWORD this is always true and is causing compiler erros
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\inc\resource.h"
#include "..\inc\dll.hxx"

#include "dlg.hxx"
#include "rc.h"
#include <mstask.h>
#include "uiutil.hxx"
#include "strings.hxx"
#include "timeutil.hxx"
#include "helpids.h"


//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aAdvancedDlgHelpIds[] =
{
    dlg_advanced,               Hdlg_advanced,
    lbl_start_date,             Hlbl_start_date,
    dp_start_date,              Hdp_start_date,
    chk_repeat_task,            Hchk_repeat_task,
    txt_repeat_task,            Htxt_repeat_task,
    spin_repeat_task,           Hspin_repeat_task,
    cbx_time_unit,              Hcbx_time_unit,
    dp_end_date,                Hdp_end_date,
    chk_terminate_at_end,       Hchk_terminate_at_end,
    rb_end_time,                Hrb_end_time,
    rb_end_duration,            Hrb_end_duration,
    dp_end_time,                Hdp_end_time,
    txt_end_duration_hr,        Htxt_end_duration_hr,
    spin_end_duration_hr,       Hspin_end_duration_hr,
    txt_end_duration_min,       Htxt_end_duration_min,
    spin_end_duration_min,      Hspin_end_duration_min,
    grp_repeat_until,           Hgrp_repeat_until,
    lbl_hours,                  Hlbl_hours,
    lbl_min,                    Hlbl_min,
    chk_end_date,               Hchk_end_date,
    lbl_every,                  Hlbl_every,
    lbl_until,                  Hlbl_until,
    0,0
};

extern "C" TCHAR szMstaskHelp[];


//
//  externs
//

extern HINSTANCE g_hInstance;



#define INDEX_MINUTES   0
#define INDEX_HOURS     1


const size_t c_MinsPerDay = (60 * 24);


class CAdvScheduleDlg : public CDlg
{
public:

    CAdvScheduleDlg(PTASK_TRIGGER pjt) : m_pjt(pjt), CDlg() {}
    virtual ~CAdvScheduleDlg() {}

protected:

    virtual INT_PTR RealDlgProc(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:

    LRESULT _OnInitDialog(LPARAM lParam);
    LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    BOOL    _OnOK(void);
    void    _EnableRepeatCtrls(BOOL fEnable);
    LRESULT _OnSetIniChange(WPARAM wParam, LPARAM lParam);
    LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                  { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    PTASK_TRIGGER    m_pjt;

    //
    // Time format string for use with Date picker control
    //

    TCHAR           m_tszTimeFormat[MAX_DP_TIME_FORMAT];
};


INT_PTR
AdvancedDialog(
    HWND          hParent,
    PTASK_TRIGGER pjt)
{
    CAdvScheduleDlg * pAdvScheduleDlg = new CAdvScheduleDlg(pjt);

    if (pAdvScheduleDlg != NULL)
    {
        return pAdvScheduleDlg->DoModal(dlg_advanced, hParent);
    }

    return FALSE;
}


INT_PTR
CAdvScheduleDlg::RealDlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        return _OnInitDialog(lParam);

    case WM_COMMAND:
        return(_OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                          GET_WM_COMMAND_HWND(wParam, lParam),
                          GET_WM_COMMAND_CMD(wParam, lParam)));

    case WM_DESTROY:
        SetWindowLongPtr(Hwnd(), DWLP_USER, 0L);
        delete this;
        break;

    case WM_SETTINGCHANGE: // WM_WININICHANGE
        _OnSetIniChange(wParam, lParam);
        break;

    case WM_HELP:
        return _OnHelp(((LPHELPINFO) lParam)->hItemHandle, HELP_WM_HELP);

    case WM_CONTEXTMENU:
        return _OnHelp((HANDLE) wParam, HELP_CONTEXTMENU);

    default:
        return FALSE;
    }

    return TRUE;
}



LRESULT
CAdvScheduleDlg::_OnSetIniChange(
    WPARAM  wParam,
    LPARAM  lParam)
{
    TRACE(CAdvScheduleDlg, _OnSetIniChange);

    DateTime_SetFormat(_hCtrl(dp_start_date), NULL);
    DateTime_SetFormat(_hCtrl(dp_end_date), NULL);

    UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));
    DateTime_SetFormat(_hCtrl(dp_end_time), m_tszTimeFormat);
    return 0;
}


LRESULT
CAdvScheduleDlg::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND) hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aAdvancedDlgHelpIds);
    return TRUE;
}



LRESULT
CAdvScheduleDlg::_OnInitDialog(
    LPARAM lParam)
{
    //
    // Initialize time format string m_tszTimeFormat
    //

    UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));

    //
    //  Init the time unit combo box
    //

    HWND hCombo = GetDlgItem(Hwnd(), cbx_time_unit);

    TCHAR tcBuff[100];

    LoadString(g_hInstance, IDS_MINUTES, tcBuff, 100);
    ComboBox_AddString(hCombo, tcBuff);

    LoadString(g_hInstance, IDS_HOURS, tcBuff, 100);
    ComboBox_AddString(hCombo, tcBuff);

    //
    // Init all the spin controls, and the associated edit controls
    //

    Spin_SetRange(Hwnd(), spin_repeat_task, 1, 9999);
    Spin_SetRange(Hwnd(), spin_end_duration_hr, 0, 9999);
    Spin_SetRange(Hwnd(), spin_end_duration_min, 0, 59);

    SendDlgItemMessage(Hwnd(), txt_repeat_task, EM_LIMITTEXT, 4, 0);
    SendDlgItemMessage(Hwnd(), txt_end_duration_hr, EM_LIMITTEXT, 4, 0);
    SendDlgItemMessage(Hwnd(), txt_end_duration_min, EM_LIMITTEXT, 2, 0);

    //
    //  Set the start and end dates.
    //

    SYSTEMTIME  st;

    SecureZeroMemory(&st, sizeof st);
    st.wYear        = m_pjt->wBeginYear;
    st.wMonth       = m_pjt->wBeginMonth;
    st.wDay         = m_pjt->wBeginDay;

    if (DateTime_SetSystemtime(_hCtrl(dp_start_date), GDT_VALID, &st) == FALSE)
    {
        DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed, err %uL.\n", GetLastError()));
    }

    if (m_pjt->rgFlags & TASK_TRIGGER_FLAG_HAS_END_DATE)
    {
        CheckDlgButton(Hwnd(), chk_end_date, BST_CHECKED);

        st.wYear        = m_pjt->wEndYear;
        st.wMonth       = m_pjt->wEndMonth;
        st.wDay         = m_pjt->wEndDay;

        if (DateTime_SetSystemtime(_hCtrl(dp_end_date), GDT_VALID, &st)
            == FALSE)
        {
            DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed.\n"));
        }
    }
    else
    {
        CheckDlgButton(Hwnd(), chk_end_date, BST_UNCHECKED);

        DateTime_SetFormat(_hCtrl(dp_end_date), tszBlank);

        EnableWindow(_hCtrl(dp_end_date), FALSE);
    }

    if (m_pjt->TriggerType == TASK_TIME_TRIGGER_ONCE)
    {
        EnableWindow(_hCtrl(lbl_start_date), FALSE);
        EnableWindow(_hCtrl(dp_start_date), FALSE);
        EnableWindow(_hCtrl(chk_end_date), FALSE);
        EnableWindow(_hCtrl(dp_end_date), FALSE);
    }

    //
    //  Set repetition
    //

    if (m_pjt->MinutesInterval > 0)
    {
        CheckDlgButton(Hwnd(), chk_repeat_task, BST_CHECKED);

        if (m_pjt->MinutesInterval % 60)
        {
            Spin_SetPos(Hwnd(), spin_repeat_task, (WORD)m_pjt->MinutesInterval);
            ComboBox_SetCurSel(hCombo, INDEX_MINUTES);
        }
        else
        {
            Spin_SetPos(Hwnd(), spin_repeat_task,
                        (WORD)(m_pjt->MinutesInterval / 60));

            ComboBox_SetCurSel(hCombo, INDEX_HOURS);
        }

        //
        //  Set end time / duration
        //

        CheckRadioButton(Hwnd(), rb_end_time, rb_end_duration,
                                                    rb_end_duration);

        WORD wHours = (WORD) (m_pjt->MinutesDuration / 60);
        WORD wMins  = (WORD) (m_pjt->MinutesDuration % 60);

        if (wHours > 9999)
        {
            wMins += (wHours - 9999) * 60;
        }

        Spin_SetPos(Hwnd(), spin_end_duration_hr, wHours);
        Spin_SetPos(Hwnd(), spin_end_duration_min, wMins);

        DateTime_SetFormat(_hCtrl(dp_end_time), tszBlank);
        EnableWindow(_hCtrl(dp_end_time), FALSE);

        //
        //  Set terminate at end
        //

        if (m_pjt->rgFlags & TASK_TRIGGER_FLAG_KILL_AT_DURATION_END)
        {
            CheckDlgButton(Hwnd(), chk_terminate_at_end, BST_CHECKED);
        }
    }
    else
    {
        CheckDlgButton(Hwnd(), chk_repeat_task, BST_UNCHECKED);

        _EnableRepeatCtrls(FALSE);
    }

    return TRUE;
}


void
CAdvScheduleDlg::_EnableRepeatCtrls(
    BOOL fEnable)
{
    int aCtrls[] =
    {
        lbl_every,
        txt_repeat_task,
        spin_repeat_task,
        cbx_time_unit,
        lbl_until,
        rb_end_time,
        rb_end_duration,
        txt_end_duration_hr,
        spin_end_duration_hr,
        lbl_hours,
        txt_end_duration_min,
        spin_end_duration_min,
        lbl_min,
        chk_terminate_at_end,
        dp_end_time // CAUTION: last position is special, see comment below
    };

    int cCtrls;

    //
    // If we're disabling repeat controls, disable them all, i.e. set cCtrls
    // the number of repeat controls.
    //
    // Otherwise if we're enabling controls, set cCtrls to the number of
    // repeat controls less one.  This will prevent the end time date-
    // picker control from being enabled.  We need to do this because when
    // these controls are being enabled, the Duration radio button is
    // always checked, therefore the end time date picker should always
    // remain disabled.
    //

    if (fEnable == FALSE)
    {
        cCtrls = ARRAYLEN(aCtrls);
        DateTime_SetFormat(_hCtrl(dp_end_time), tszBlank);

        SetDlgItemText(Hwnd(), txt_repeat_task, TEXT(""));
        SetDlgItemText(Hwnd(), txt_end_duration_hr, TEXT(""));
        SetDlgItemText(Hwnd(), txt_end_duration_min, TEXT(""));
        SetDlgItemText(Hwnd(), cbx_time_unit, TEXT(""));
    }
    else
    {
        cCtrls = ARRAYLEN(aCtrls) - 1;
        Spin_SetPos(Hwnd(), spin_repeat_task, 10);

        ComboBox_SetCurSel(_hCtrl(cbx_time_unit), INDEX_MINUTES);

        CheckRadioButton(Hwnd(), rb_end_time, rb_end_duration,
                                                        rb_end_duration);

        Spin_SetPos(Hwnd(), spin_end_duration_hr, 1);
        Spin_SetPos(Hwnd(), spin_end_duration_min, 0);
    }


    for (int i=0; i < cCtrls; i++)
    {
        EnableWindow(_hCtrl(aCtrls[i]), fEnable);
    }
}



LRESULT
CAdvScheduleDlg::_OnCommand(
    int  id,
    HWND hwndCtl,
    UINT codeNotify)
{
    SYSTEMTIME st;
    GetSystemTime(&st);

    switch (id)
    {
    case chk_end_date:
        if (IsDlgButtonChecked(Hwnd(), chk_end_date) == BST_CHECKED)
        {
            FILETIME ftNow, ftStart;
            SYSTEMTIME stStart, stEnd;
			
            CopyMemory(&stEnd, &st, sizeof(SYSTEMTIME));

            if (DateTime_GetSystemtime(_hCtrl(dp_start_date), &stStart) == GDT_VALID)
            {
                // compare start time to current date, set End == max of the two
                SystemTimeToFileTime(&stStart, &ftStart);
                SystemTimeToFileTime(&st, &ftNow);
                if (CompareFileTime(&ftStart, &ftNow) <= 0)
                {
                    FileTimeToSystemTime(&ftNow, &stEnd);
                }
                else
                {
                    FileTimeToSystemTime(&ftStart, &stEnd);
                }
            }
            DateTime_SetSystemtime(_hCtrl(dp_end_date), GDT_VALID, &stEnd);
            DateTime_SetFormat(_hCtrl(dp_end_date), tszEmpty);
            EnableWindow(_hCtrl(dp_end_date), TRUE);
        }
        else
        {
            DateTime_SetFormat(_hCtrl(dp_end_date), tszBlank);
            EnableWindow(_hCtrl(dp_end_date), FALSE);
        }
        break;

    case chk_repeat_task:
        if (IsDlgButtonChecked(Hwnd(), chk_repeat_task) == BST_CHECKED)
        {
            _EnableRepeatCtrls(TRUE);
        }
        else
        {
            _EnableRepeatCtrls(FALSE);
        }
        break;

    case rb_end_time:
        //if (IsDlgButtonChecked(Hwnd(), rb_end_time) == BST_CHECKED)
        {
            EnableWindow(_hCtrl(dp_end_time), TRUE);
            DateTime_SetFormat(_hCtrl(dp_end_time), m_tszTimeFormat);

            Spin_Disable(Hwnd(), spin_end_duration_hr);
            Spin_Disable(Hwnd(), spin_end_duration_min);
        }
        break;

    case rb_end_duration:
        //if (IsDlgButtonChecked(Hwnd(), rb_end_duration) == BST_CHECKED)
        {
            Spin_Enable(Hwnd(), spin_end_duration_hr, 1);
            Spin_Enable(Hwnd(), spin_end_duration_min, 0);

            DateTime_SetFormat(_hCtrl(dp_end_time), tszBlank);
            EnableWindow(_hCtrl(dp_end_time), FALSE);
        }
        break;

    case IDOK:
        if (_OnOK() == TRUE)
        {
            EndDialog(Hwnd(), TRUE);
        }
        break;

    case IDCANCEL:
        EndDialog(Hwnd(), FALSE);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


BOOL
CAdvScheduleDlg::_OnOK(void)
{
    WORD wTemp = 0;
    SYSTEMTIME stStart, stEnd;

    if (DateTime_GetSystemtime(_hCtrl(dp_start_date), &stStart) == GDT_VALID)
    {
        m_pjt->wBeginYear   =  stStart.wYear;
        m_pjt->wBeginMonth  =  stStart.wMonth;
        m_pjt->wBeginDay    =  stStart.wDay;
    }
    else
    {
        DEBUG_OUT((DEB_USER1, "DateTime_GetSystemtime failed.\n"));
    }

    if (IsDlgButtonChecked(Hwnd(), chk_end_date) == BST_CHECKED)
    {
        if (DateTime_GetSystemtime(_hCtrl(dp_end_date), &stEnd) == GDT_VALID)
        {
            m_pjt->wEndYear   =  stEnd.wYear;
            m_pjt->wEndMonth  =  stEnd.wMonth;
            m_pjt->wEndDay    =  stEnd.wDay;
        }
        else
        {
            DEBUG_OUT((DEB_USER1, "DateTime_GetSystemtime failed.\n"));
        }

        m_pjt->rgFlags |= TASK_TRIGGER_FLAG_HAS_END_DATE;

        //
        //  Ensure end date is after start date
        //

        stStart.wDayOfWeek = 0;
        stEnd.wDayOfWeek = 0;

        if (CompareSystemDate(stStart, stEnd) > 0)
        {
            _ErrorDialog(IERR_ENDDATE_LT_STARTDATE);
            return FALSE;
        }
    }
    else
    {
        m_pjt->rgFlags &= ~TASK_TRIGGER_FLAG_HAS_END_DATE;
    }

    if (IsDlgButtonChecked(Hwnd(), chk_repeat_task) == BST_CHECKED)
    {
        //
        //  Determine MinutesInterval
        //

        m_pjt->MinutesInterval = Spin_GetPos(Hwnd(), spin_repeat_task);

        if (m_pjt->MinutesInterval < 1 || m_pjt->MinutesInterval > 9999)
        {
			//
			// if a user entered zero directly into the field, the control is actually returning 65537
			//
			_ErrorDialog(IERR_REPETITION_LT1);
			Spin_SetPos(Hwnd(), spin_repeat_task, 1);
			return FALSE;
        }

        switch (ComboBox_GetCurSel(_hCtrl(cbx_time_unit)))
        {
        case INDEX_MINUTES:
            break;

        case INDEX_HOURS:
            m_pjt->MinutesInterval *= 60;
            break;
        }

        //
        //  Determine MinutesDuration
        //

        if (IsDlgButtonChecked(Hwnd(), rb_end_time) == BST_CHECKED)
        {
            SYSTEMTIME stEndTime;

            if (DateTime_GetSystemtime(_hCtrl(dp_end_time), &stEndTime)
                == GDT_VALID)
            {
                DWORD dwMin = 0;

                DWORD dwStartMin = m_pjt->wStartHour * 60 + m_pjt->wStartMinute;
                DWORD dwEndMin = stEndTime.wHour * 60 + stEndTime.wMinute;

                if (dwEndMin > dwStartMin)
                {
                    dwMin = dwEndMin - dwStartMin;
                }
                else
                {
                    dwMin = c_MinsPerDay - (dwStartMin - dwEndMin);
                }

                m_pjt->MinutesDuration = dwMin;
            }
            else
            {
                DEBUG_OUT((DEB_USER1, "DateTime_GetSystemtime failed.\n"));
            }
        }
        else
        {
            ULONG ulDuration = Spin_GetPos(Hwnd(), spin_end_duration_min);

            if (HIWORD(ulDuration))
            {
                ulDuration = 59;
            }
            m_pjt->MinutesDuration = ulDuration + 60 *
                        Spin_GetPos(Hwnd(), spin_end_duration_hr);
        }

        if (m_pjt->MinutesDuration <= m_pjt->MinutesInterval)
        {
            _ErrorDialog(IERR_DURATION_LT_INTERVAL);
            return FALSE;
        }

        if (IsDlgButtonChecked(Hwnd(), chk_terminate_at_end) == BST_CHECKED)
        {
            m_pjt->rgFlags |= TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
        }
        else
        {
            m_pjt->rgFlags &= ~TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
        }

    }
    else
    {
        m_pjt->MinutesInterval = 0;
        m_pjt->MinutesDuration = 0;

        m_pjt->rgFlags &= ~TASK_TRIGGER_FLAG_KILL_AT_DURATION_END;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\defines.h ===
#define MAX_PROP_PAGES  20

//
// Used by General, Schedule & Settings page to query each other
// through PSM_QUERYSIBLINGS to see if they are ready to be saved
// to storage.
//

//
// Used by General, Schedule & Settings pages to query each other
// to see if they are ready to be saved to storage. Do this by sending
// the PSM_QUERYSIBLINGS message to each of the page with wParam set to
// QUERY_READY_TO_BE_SAVED & lParam set to 0. A return value of 0 by all
// pages imples they are all ready to be saved.
//

#define QUERY_READY_TO_BE_SAVED                     7341

//
// Used by general and schedule page to share the icon helper object.
//

#define GET_ICON_HELPER                             7342

//
// Used by all pages to set task application & account change status
// flags to pass in to the common save code (JFSaveJob).
//

#define QUERY_TASK_APPLICATION_DIRTY_STATUS         7345
#define QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS        7346
#define QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG    7347
#define RESET_TASK_APPLICATION_DIRTY_STATUS         7348
#define RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS        7349
#define RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG    7350

//
// Used to instruct the general page to refresh account information visuals.
//

#define TASK_ACCOUNT_CHANGE_NOTIFY                  7351
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\errhdlr.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       uiutil.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/20/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\folderui\macros.h"
#include "..\inc\resource.h"
#include "rc.h"
#include <mstask.h>     // Necessary for schedui.hxx inclusion.
#include "schedui.hxx"
#include <misc.hxx>

#define ERROR_STRING_BUFFER_SIZE    2048
#define ERROR_TITLE_BUFFER_SIZE     256

extern HINSTANCE g_hInstance;

void
SchedUIErrorDialog(
    HWND    hwnd,
    int     idsErrMsg,
    LONG    error,
    UINT    idsHelpHint)
{
    TCHAR szBuf1[ERROR_TITLE_BUFFER_SIZE];

    //
    // Obtain the error message string.
    //

    LPTSTR ptszErrMsg = ComposeErrorMsg(idsErrMsg,
                                        (DWORD)error,
                                        idsHelpHint,
                                        FALSE);
    if (ptszErrMsg == NULL)
    {
        return;
    }

    LoadString(g_hInstance, IDS_SCHEDULER_NAME, szBuf1, ARRAYLEN(szBuf1));

    MessageBox(hwnd, ptszErrMsg, szBuf1,
               MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

    LocalFree(ptszErrMsg);
}




//+--------------------------------------------------------------------------
//
//  Function:   SchedUIMessageDialog
//
//  Synopsis:   Display a message box and return result of user selection.
//
//  Arguments:  [hwnd]      - parent window
//              [idsMsg]    - resource id of string to load
//              [uType]     - MB_* flags
//              [pszInsert] - NULL or string to insert
//
//  Returns:    Result of MessageBox call
//
//  History:    5-19-1997   DavidMun   Commented, added pszInsert
//
//---------------------------------------------------------------------------

int
SchedUIMessageDialog(
    HWND    hwnd,
    int     idsMsg,
    UINT    uType,
    LPTSTR  pszInsert)
{
    TCHAR szBuf1[ERROR_STRING_BUFFER_SIZE];
    TCHAR szBuf2[ERROR_STRING_BUFFER_SIZE];

    if (pszInsert != 0)
    {
        LoadString(g_hInstance, idsMsg, szBuf1, ARRAYLEN(szBuf1));
        StringCchPrintf(szBuf2, ERROR_STRING_BUFFER_SIZE, szBuf1, pszInsert);
    }
    else
    {
        LoadString(g_hInstance, idsMsg, szBuf2, ARRAYLEN(szBuf2));
    }

    LoadString(g_hInstance, IDS_SCHEDULER_NAME, szBuf1, ARRAYLEN(szBuf1));

    return MessageBox(hwnd, szBuf2, szBuf1, uType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\dlg.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/4/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\dll.hxx"
#include "dlg.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\sadat.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\util.hxx"

//
//  extern EXTERN_C
//

extern HINSTANCE g_hInstance;
extern HANDLE g_hActCtx;

CPropPage::CPropPage(
    LPCTSTR szTmplt,
    LPTSTR  ptszTaskPath):
        m_hPage(NULL),
        m_fTaskInTasksFolder(FALSE),
        m_fSupportsSystemRequired(FALSE),
        m_bPlatformId(0),
        m_fDirty(FALSE),
        m_fInInit(FALSE)
{
    Win4Assert(ptszTaskPath != NULL && *ptszTaskPath);

    lstrcpyn(m_ptszTaskPath, ptszTaskPath, ARRAY_LEN(m_ptszTaskPath));

    SecureZeroMemory(&m_psp, sizeof(m_psp));

    m_psp.dwSize        = sizeof(PROPSHEETPAGE);
    m_psp.dwFlags       = PSP_USECALLBACK | PSP_USEFUSIONCONTEXT;
    m_psp.hInstance     = g_hInstance;
    m_psp.pszTemplate   = szTmplt;
    m_psp.pfnDlgProc    = StaticDlgProc;
    m_psp.pfnCallback   = PageRelease;
    m_psp.pcRefParent   = NULL; // do not set PSP_USEREFPARENT
    m_psp.lParam        = (LPARAM) this;
	m_psp.hActCtx		= g_hActCtx;
}


CPropPage::~CPropPage()
{
}


INT_PTR CALLBACK
CPropPage::StaticDlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CPropPage *pThis = (CPropPage *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        LPPROPSHEETPAGE ppsp = (LPPROPSHEETPAGE)lParam;

        pThis = (CPropPage *) ppsp->lParam;

        pThis->m_hPage = hDlg;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pThis);
    }

    if (pThis != NULL)
    {
        return pThis->DlgProc(uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hDlg, uMsg, wParam, lParam);
    }
}


LRESULT
CPropPage::DlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    LRESULT lr;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        m_fInInit = TRUE;
        _BaseInit();
        lr = _OnInitDialog(lParam);
        m_fInInit = FALSE;
        return lr;

    case PSM_QUERYSIBLINGS:
        return _OnPSMQuerySibling(wParam, lParam);

    case WM_NOTIFY:
        return _OnNotify(uMsg, (UINT)wParam, lParam);

    case WM_WININICHANGE:
        return _OnWinIniChange(wParam, lParam);

    case WM_SETFOCUS:
        return _OnSetFocus((HWND)wParam);

    case WM_TIMER:
        return _OnTimer((UINT)wParam);

    case WM_HELP:
        return _OnHelp(((LPHELPINFO) lParam)->hItemHandle,
                       HELP_WM_HELP);

    case WM_CONTEXTMENU:
        return _OnHelp((HANDLE) wParam, HELP_CONTEXTMENU);

    case WM_COMMAND:
        if (m_fInInit)
        {
            return TRUE;
        }
        return(_OnCommand(GET_WM_COMMAND_ID(wParam, lParam),
                          GET_WM_COMMAND_HWND(wParam, lParam),
                          GET_WM_COMMAND_CMD(wParam, lParam)));
    case WM_DESTROY:
        return _OnDestroy();

    default:
        return(FALSE);
    }

    return(TRUE);
}

LRESULT
CPropPage::_OnNotify(
    UINT    uMessage,
    UINT    uParam,
    LPARAM  lParam)
{
    switch (((LPNMHDR)lParam)->code)
    {
    case PSN_APPLY:
        return _OnApply();

    case PSN_RESET:
        _OnCancel();
        return FALSE; // allow the property sheet to be destroyed.

    case PSN_SETACTIVE:
        return _OnPSNSetActive(lParam);

    case PSN_KILLACTIVE:
        return _OnPSNKillActive(lParam);

    case DTN_DATETIMECHANGE:
        return _OnDateTimeChange(lParam);

    case UDN_DELTAPOS:
        return _OnSpinDeltaPos((NM_UPDOWN *)lParam);

    default:
        return _ProcessListViewNotifications(uMessage, uParam, lParam);
    }

    return TRUE;
}


LRESULT
CPropPage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, 0);
    return 0;
}


LRESULT
CPropPage::_OnSpinDeltaPos(
    NM_UPDOWN * pnmud)
{
    _EnableApplyButton();

    // Return FALSE to allow the change in the control's position.
    return FALSE;
}



LRESULT
CPropPage::_OnCommand(
    int id,
    HWND hwndCtl,
    UINT codeNotify)
{
    return FALSE;
}

LRESULT
CPropPage::_OnWinIniChange(
    WPARAM  wParam,
    LPARAM  lParam)
{
    return FALSE;
}

LRESULT
CPropPage::_OnApply(void)
{
    return FALSE;
}

LRESULT
CPropPage::_OnCancel(void)
{
    return FALSE;
}


LRESULT
CPropPage::_OnSetFocus(
    HWND hwndLoseFocus)
{
    // An application should return zero if it processes this message.
    return 1;
}


LRESULT
CPropPage::_OnPSNSetActive(
    LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}


LRESULT
CPropPage::_OnPSNKillActive(
    LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}


LRESULT
CPropPage::_OnDateTimeChange(
    LPARAM lParam)
{
    SetWindowLongPtr(m_hPage, DWLP_MSGRESULT, 0);
    return TRUE;
}


LRESULT
CPropPage::_OnDestroy(void)
{
    // If an application processes this message, it should return zero.
    return 1;
}

LRESULT
CPropPage::_OnTimer(
    UINT idTimer)
{
    // If an application processes this message, it should return zero.
    return 1;
}

BOOL
CPropPage::_ProcessListViewNotifications(
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    return FALSE;
}


UINT CALLBACK
CPropPage::PageRelease(
    HWND            hwnd,
    UINT            uMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        //
        // Determine instance that invoked this static function
        //

        CPropPage *pThis = (CPropPage *) ppsp->lParam;

        //
        // If page was created using an indirect dialog template, delete
        // that.
        //

        if (pThis->m_psp.dwFlags & PSP_DLGINDIRECT)
        {
            delete [] (BYTE *)pThis->m_psp.pResource;
        }

        delete pThis;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CPropPage::_BaseInit, private
//
//  Synopsis:   Initialize scheduling-agent specific private data members,
//              m_fTaskInTasksFolder & m_bPlatformId. Do so by reading SA.DAT
//              in the folder containing the task.
//
//  Arguments:  None.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CPropPage::_BaseInit(void)
{
    TCHAR tszFolder[MAX_PATH + 1];

    ::GetParentDirectory(m_ptszTaskPath, tszFolder, MAX_PATH + 1);

    //
    // If running on the local system, we can determine whether resume
    // timers are supported directly instead of by checking sa.dat, which
    // might be stale.
    //

    BOOL fLocal = IsLocalFilename(m_ptszTaskPath);

    if (fLocal)
    {
        CheckSaDat(tszFolder);
    }

    //
    // Read sa.dat on target machine
    //

    HRESULT hr;
    DWORD dwVersion;
    BYTE  bSvcFlags;

    hr = SADatGetData(tszFolder, &dwVersion, &m_bPlatformId, &bSvcFlags);

    if (SUCCEEDED(hr))
    {
        m_fTaskInTasksFolder = TRUE;

        if (fLocal)
        {
            m_fSupportsSystemRequired = ResumeTimersSupported();
        }
        else
        {
            m_fSupportsSystemRequired =
                bSvcFlags & SA_DAT_SVCFLAG_RESUME_TIMERS;
        }
    }
    else
    {
        //
        // Default on error (the file doesn't exist or the read failed).
        // Assume the task is external to the task folder and it exists
        // on a non-NT machine that doesn't support the system required
        // flag.
        //

        m_fTaskInTasksFolder        = FALSE;
        m_bPlatformId               = VER_PLATFORM_WIN32_WINDOWS;
        m_fSupportsSystemRequired   = FALSE;
    }
}




//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________  class CDlg       _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________


INT_PTR
CDlg::RealDlgProc(
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    return(FALSE);
}


INT_PTR CALLBACK CDlg::DlgProc(
    HWND    hDlg,
    UINT    uMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    if (uMsg == WM_INITDIALOG)
    {
        pThis = (CDlg *)lParam;
        pThis->m_hDlg = hDlg;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
    }

    if (pThis != NULL)
    {
        return pThis->RealDlgProc(uMsg, wParam, lParam);
    }
    else
    {
        return DefWindowProc(hDlg, uMsg, wParam, lParam);
    }
}


INT_PTR
CDlg::DoModal(
    UINT idRes,
    HWND hParent)
{
    return(DialogBoxParam(g_hInstance, MAKEINTRESOURCE(idRes),
                                        hParent, DlgProc, (LPARAM)this));
}


HWND
CDlg::DoModeless(
    UINT idRes,
    HWND hParent)
{
    return(CreateDialogParam(g_hInstance, MAKEINTRESOURCE(idRes),
                                        hParent, DlgProc, (LPARAM)this));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\helpids.h ===
///////////////////////////////////////////////////////////////////////////
//
//  HELPIDS FOR THE TASK FOLDER DETAILS VIEW COLUMNS
//

#define Hids_name                        100
#define Hids_next_run_time               101
#define Hids_last_run_time               102
#define Hids_last_result                 103
#define Hids_schedule                    104
#define Hids_status                      105
#define Hids_creator                     106



///////////////////////////////////////////////////////////////////////////
//
//  HELPIDS FOR PROPERTY PAGES
//

//
// Helpids for control(s) common to all three pages
//

#define Hidc_icon                        140

//
// Helpids for General page controls
//

#define Hlbl_job_name                    150
#define Hlbl_comments                    151
#define Htxt_comments                    152
#define Hlbl_app_name                    153
#define Htxt_app_name                    154
#define Hbtn_browse                      155
#define Hlbl_workingdir                  156
#define Htxt_workingdir                  157
#define Hlbl_execute_as                  158
#define Htxt_execute_as                  159
#define Hlbl_passwd                      160
#define Htxt_passwd                      161
#define Hlbl_passwd2                     162
#define Htxt_passwd2                     163
#define Hchk_enable_job                  164
#define Hbtn_settings                    165
#define Hbtn_passwd                      166
// used by Hgrp_power_management         168

//
// Helpids for Settings page controls
//

#define Hchk_start_on_idle               171
#define Hchk_stop_if_not_idle            172
#define Hchk_dont_start_if_on_batteries  173
#define Hchk_kill_if_going_on_batteries  174
#define Hchk_delete_when_done            175
#define Hchk_show_multiple_scheds        176
#define Hchk_stop_after                  177
#define Htxt_stop_after_hr               178
#define Hspin_stop_after_hr              179
#define Htxt_stop_after_min              180
#define Hspin_stop_after_min             181
// #define Hchk_interactive              182 // DELETED
#define Htxt_idle_min                    183
#define Hspin_idle_min                   184
#define Hlbl_settings_hours              185
#define Hlbl_settings_min                186
#define Hgrp_idle_time                   187
#define Htxt_idle_minutes                188
#define Hgrp_task_completed              189
#define Hgrp_power_management            168
#define Hlbl_idle_deadline               300
#define Htxt_idle_deadline               301
#define Hspin_idle_deadline              302
#define Hchk_system_required             303
// 304, etc are used below - do not reuse here

//
// Helpids for Schedule page controls (common to all triggers)
//

#define Hcbx_trigger_type                190
#define Hdp_start_time                   191
#define Hcbx_triggers                    192
#define Htxt_trigger                     193
#define Hbtn_new                         194
#define Hbtn_delete                      195
#define Hbtn_advanced                    196
#define Hgrp_schedule                    197


//
// Helpids for Schedule page controls for DAILY trigger
//

#define Hgrp_daily                       201
#define Hdaily_lbl_every                 202
#define Hdaily_txt_every                 203
#define Hdaily_spin_every                204
#define Hdaily_lbl_days                  205

//
// Helpids for Schedule page controls for WEEKLY trigger
//

#define Hgrp_weekly                      211
#define Hweekly_lbl_every                212
#define Hweekly_txt_every                213
#define Hweekly_spin_every               214
#define Hweekly_lbl_weeks_on             215
#define Hchk_mon                         216
#define Hchk_tue                         217
#define Hchk_wed                         218
#define Hchk_thu                         219
#define Hchk_fri                         220
#define Hchk_sat                         221
#define Hchk_sun                         222

//
// Helpids for Schedule page controls for MONTHLY trigger
//

#define Hgrp_monthly                     231
#define Hmd_rb                           232
#define Hmd_txt                          233
#define Hmd_spin                         234
#define Hmd_lbl                          235
#define Hdow_rb                          236
#define Hdow_cbx_week                    237
#define Hdow_cbx_day                     238
#define Hdow_lbl                         239
#define Hbtn_sel_months                  240

//
// Helpids for Schedule page controls for ONCE only trigger
//

#define Hgrp_once                        261
#define Honce_lbl_run_on                 262
#define Honce_dp_date                    263

//
// Helpids for Schedule page controls for WhenIdle trigger.
//

#define Hsch_txt_idle_min                264
#define Hgrp_idle                        265
#define Hidle_lbl_when                   266
#define Hsch_spin_idle_min               267
#define Hidle_lbl_mins                   268

//
// Helpids for Advanced Dialog controls
//

#define Hdlg_advanced                    271
#define Hlbl_start_date                  272
#define Hdp_start_date                   273
#define Hchk_repeat_task                 274
#define Htxt_repeat_task                 275
#define Hspin_repeat_task                276
#define Hcbx_time_unit                   277
#define Hdp_end_date                     278
#define Hchk_terminate_at_end            279
#define Hrb_end_time                     280
#define Hrb_end_duration                 281
#define Hdp_end_time                     282
#define Htxt_end_duration_hr             283
#define Hspin_end_duration_hr            284
#define Htxt_end_duration_min            285
#define Hspin_end_duration_min           286
#define Hgrp_repeat_until                287
#define Hlbl_hours                       288
#define Hlbl_min                         289
#define Hchk_end_date                    290
#define Hlbl_every                       291
#define Hlbl_until                       292

// used by settings page controls        300
//                                       301
//                                       302
//                                       303

//
// Helpids for Set Password dialog
//

#define Hset_passwd_dlg                  304
#define Hlbl_sp_passwd                   305
#define Hedt_sp_passwd                   306
#define Hlbl_sp_cfrmpasswd               307
#define Hedt_sp_cfrmpasswd               308

//
// Helpids for Select Months dialog
//

#define Hselect_month_dlg                309
#define Hchk_jan                         310
#define Hchk_feb                         311
#define Hchk_mar                         312
#define Hchk_apr                         313
#define Hchk_may                         314
#define Hchk_jun                         315
#define Hchk_jul                         316
#define Hchk_aug                         317
#define Hchk_sep                         318
#define Hchk_oct                         319
#define Hchk_nov                         320
#define Hchk_dec                         321
#define Hlbl_sel_months                  322
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\rc.h ===
//
// Dialogs
//

#define set_passwd_dlg                  102
#define set_account_info_dlg            103
#define IDD_AT_ACCOUNT_DLG              104
#define select_month_dlg                105

//
// Pages
//

#define general_page                     401
#define schedule_page                    402
#define settings_page                    403

#define idc_icon                         500

//
// General page controls
//

#define btn_passwd                      1000
#define lbl_job_name                    1650
#define lbl_comments                    1651
#define txt_comments                    1652
#define lbl_app_name                    1653
#define txt_app_name                    1654
#define btn_browse                      1655
#define lbl_run_as                      1658
#define txt_run_as                      1659
#define lbl_passwd                      1660
#define txt_passwd                      1661
#define lbl_passwd2                     1662
#define txt_passwd2                     1663
#define chk_enable_job                  1664
#define btn_settings                    1665
#define lbl_workingdir                  1666
#define txt_workingdir                  1667

//
// Set password dialog controls
//

#define edt_sp_cfrmpasswd               1001
#define edt_sp_passwd                   1002
#define lbl_sp_passwd                   1003
#define lbl_sp_cfrmpasswd               1004
#define btn_sp_ok                       1005
#define btn_sp_cancel                   1006

//
// Set account information dialog controls
//

#define lbl_sa_run_as                   1007
#define txt_sa_run_as                   1008
#define lbl_sa_passwd                   1009
#define lbl_sa_cfrmpasswd               1010
#define edt_sa_passwd                   1011
#define edt_sa_cfrmpasswd               1012

//
// Set AT account information controls
//

#define IDD_AT_USE_SYSTEM               100
#define IDD_AT_USE_CUSTOM               101
#define IDD_AT_CUSTOM_ACCT_NAME         102
#define IDD_AT_PWD_TXT                  103
#define IDD_AT_PASSWORD                 104
#define IDD_AT_CONFIRM_TXT              105
#define IDD_AT_CONFIRM_PASSWORD         106

//
// Settings page controls
//

#define chk_start_on_idle               1671
#define chk_stop_if_not_idle            1672
#define chk_dont_start_if_on_batteries  1673
#define chk_kill_if_going_on_batteries  1674
#define chk_delete_when_done            1675
#define chk_show_multiple_scheds        1676 // now on schedule page
#define chk_stop_after                  1677
#define txt_stop_after_hr               1678
#define spin_stop_after_hr              1679
#define txt_stop_after_min              1680
#define spin_stop_after_min             1681
#define lbl_idle_deadline1              1682
#define txt_idle_min                    1683
#define spin_idle_min                   1684
#define grp_idle_time                   1685
#define txt_idle_minutes                1686
#define grp_task_completed              1687
#define grp_power_management            1688
#define txt_idle_deadline               1689
#define spin_idle_deadline              1698
#define lbl_idle_deadline2              1699
#define chk_system_required             1700

//
// Schedule page controls (common to all triggers)
//

#define cbx_trigger_type                1690
#define dp_start_time                   1691

#define cbx_triggers                    1692
#define txt_trigger                     1693

#define btn_new                         1694
#define btn_delete                      1695
#define btn_advanced                    1696

#define grp_schedule                    1697
// used by spin_idle_deadline           1698

//  EDITTEXT
// Schedule page controls for DAILY trigger
//

#define grp_daily                       1701
#define daily_lbl_every                 1702
#define daily_txt_every                 1703
#define daily_spin_every                1704
#define daily_lbl_days                  1705

//
// Schedule page controls for WEEKLY trigger
//

#define grp_weekly                      1711
#define weekly_lbl_every                1712
#define weekly_txt_every                1713
#define weekly_spin_every               1714
#define weekly_lbl_weeks_on             1715
#define chk_mon                         1716
#define chk_tue                         1717
#define chk_wed                         1718
#define chk_thu                         1719
#define chk_fri                         1720
#define chk_sat                         1721
#define chk_sun                         1722

//
// Schedule page controls for MONTHLY trigger
//

#define grp_monthly                     1731
#define md_rb                           1732
#define md_txt                          1733
#define md_spin                         1734
#define md_lbl                          1735
#define dow_rb                          1736
#define dow_cbx_week                    1737
#define dow_cbx_day                     1738
#define dow_lbl                         1739
#define btn_sel_months                  1740
#define lbl_sel_months                  1741

//
// Select month dialog controls (invoked from MONTHLY trigger control
// btn_sel_months on schedule page).
//

#define chk_jan                         1742
#define chk_feb                         1743
#define chk_mar                         1744
#define chk_apr                         1745
#define chk_may                         1746
#define chk_jun                         1747
#define chk_jul                         1748
#define chk_aug                         1749
#define chk_sep                         1750
#define chk_oct                         1751
#define chk_nov                         1752
#define chk_dec                         1753

//
// Schedule page controls for ONCE only trigger
//

#define grp_once                        1761
#define once_lbl_run_on                 1762
#define once_dp_date                    1763

//
// Schedule page controls for WhenIdle trigger
//

#define grp_idle                        1764
#define idle_lbl_when                   1765
#define sch_txt_idle_min                1766
#define sch_spin_idle_min               1767
#define idle_lbl_mins                   1768

//
// Advanced page controls
//

#define dlg_advanced                    1771
#define lbl_start_date                  1772
#define dp_start_date                   1773
#define chk_repeat_task                 1774
#define txt_repeat_task                 1775
#define spin_repeat_task                1776
#define cbx_time_unit                   1777
#define dp_end_date                     1778
#define chk_terminate_at_end            1779
#define rb_end_time                     1780
#define rb_end_duration                 1781
#define dp_end_time                     1782
#define txt_end_duration_hr             1783
#define spin_end_duration_hr            1784
#define txt_end_duration_min            1785
#define spin_end_duration_min           1786
#define grp_repeat_until                1787
#define lbl_hours                       1788
#define lbl_min                         1789
#define chk_end_date                    1790
#define lbl_every                       1791
#define lbl_until                       1792


//
// String table
//

#define IDS_ONCE                        4101

#define IDS_SUNDAY                      4103
#define IDS_MONDAY                      4104
#define IDS_TUESDAY                     4105
#define IDS_WEDNESDAY                   4106
#define IDS_THURSDAY                    4107
#define IDS_FRIDAY                      4108
#define IDS_SATURDAY                    4109

#define IDS_EXE                         4110
#define IDS_PROGRAMSFILTER              4111
#define IDS_BROWSE                      4112
#define IDS_AT_STARTUP                  4113
#define IDS_AT_LOGON                    4114
#define IDS_NO_TRIGGERS                 4115
#define IDS_MSG_CAPTION                 4116

#define IERR_ENDDATE_LT_STARTDATE       4131
#define IERR_DURATION_LT_INTERVAL       4132
#define IERR_INTERNAL_ERROR             4133
#define IERR_PASSWORD                   4134
#define IERR_OUT_OF_MEMORY              4135
#define IERR_GENERAL_PAGE_INIT          4136
#define IERR_SCHEDULE_PAGE_INIT         4137
#define IERR_SETTINGS_PAGE_INIT         4138
#define IERR_INVALID_DAYILY_EVERY       4139
#define IERR_INVALID_WEEKLY_EVERY       4140
#define IERR_MONTHLY_DATE_LT0           4141
#define IERR_MONTHLY_DATE_GT31          4142
#define IERR_INVALID_WEEKLY_TASK        4143
#define IERR_INVALID_MONTHLY_TASK       4144
#define IERR_FILE_NOT_FOUND             4145
#define IERR_ACCESS_DENIED              4146
#define IERR_MAXRUNTIME                 4147
#define IERR_SECURITY_READ_ERROR        4148
#define IERR_ACCOUNTNAME                4149
#define IERR_APP_NOT_FOUND              4151
#define IERR_MONTHLY_DATE_INVALID       4152
#define IERR_REPETITION_LT1				4153
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\general.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       general.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    3/4/1996   RaviR   Created
//              1-30-1997   DavidMun   params edit becomes working dir
//              02/29/01   JBenton BUG 280401 app icon was not being updated
//                                 on prop sheet in case of service not running
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include "..\inc\dll.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "dlg.hxx"

#include "..\folderui\jobicons.hxx"
#include "..\inc\resource.h"
#include "..\inc\defines.hxx"
#include "..\inc\common.hxx"
#include "..\inc\misc.hxx"
#include "..\inc\policy.hxx"
#include <StrSafe.h>


#define  SECURITY_WIN32
#include <security.h>           // GetUserNameEx
#undef   SECURITY_WIN32
#include "SASecRPC.h"           // SASetNSAccountInformation RPC definition.
#include "..\inc\network.hxx"
#include "rc.h"
#include "defines.h"
#include <mstask.h>
#include "uiutil.hxx"
#include "commdlg.h"
#include "helpids.h"
#include "iconhlpr.hxx"
#include "schedui.hxx"

//
//  extern
//

extern HINSTANCE g_hInstance;

//
// Forward references
//
// CenterDialog - Centers a dialog on screen. Used by the security-related
//                  subdialogs.
//

void
CenterDialog(HWND hDlg);

void
GetDefaultDomainAndUserName(
    LPTSTR ptszDomainAndUserName,
    ULONG  cchBuf);


//
// Launches the modal set password dialog.
//

INT_PTR
LaunchSetPasswordDlg(
    HWND          hWnd,
    AccountInfo * pAccountInfo);

INT_PTR APIENTRY
SetPasswordDlgProc(
    HWND   hDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR APIENTRY
SetAccountInformationDlgProc(
    HWND   hDlg,
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam);

int
SchedGetDlgItemTextLength(
    HWND hwnd,
    int id);

//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aGeneralPageHelpIds[] =
{
    idc_icon,           Hidc_icon,
    lbl_job_name,       Hlbl_job_name,
    lbl_comments,       Hlbl_comments,
    txt_comments,       Htxt_comments,
    lbl_app_name,       Hlbl_app_name,
    txt_app_name,       Htxt_app_name,
    btn_browse,         Hbtn_browse,
    lbl_workingdir,     Hlbl_workingdir,
    txt_workingdir,     Htxt_workingdir,
    lbl_run_as,         Hlbl_execute_as,
    txt_run_as,         Htxt_execute_as,
    btn_passwd,         Hbtn_passwd,
    chk_enable_job,     Hchk_enable_job,
    btn_settings,       Hbtn_settings,
    0,0
};


const ULONG s_aSetPasswordDlgHelpIds[] =
{
    set_passwd_dlg,     Hset_passwd_dlg,
    lbl_sp_passwd,      Hlbl_sp_passwd,
    edt_sp_passwd,      Hedt_sp_passwd,
    lbl_sp_cfrmpasswd,  Hlbl_sp_cfrmpasswd,
    edt_sp_cfrmpasswd,  Hedt_sp_cfrmpasswd,
    0,0
};


extern "C" TCHAR szMstaskHelp[];

const TCHAR SAGERUN_PARAM[] = TEXT("/SAGERUN:");

TCHAR szMstaskHelp[]  = TEXT("%windir%\\help\\mstask.hlp");

//____________________________________________________________________________
//____________________________________________________________________________
//________________                      ______________________________________
//________________  class CGeneralPage  ______________________________________
//________________                      ______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CGeneralPage : public CPropPage
{
public:

    CGeneralPage(ITask * pIJob, LPTSTR ptszTaskPath, BOOL fPersistChanges);

    ~CGeneralPage();

private:

    virtual LRESULT _OnInitDialog(LPARAM lParam);
    virtual LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT _OnApply(void);
    virtual LRESULT _OnCancel(void);
    virtual LRESULT _OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnPSNKillActive(LPARAM lParam);
    virtual LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    VOID    _ExpandAppName(LPTSTR tszApp, size_t cchBuff);
    VOID    _ExpandWorkingDir();
    VOID    _GetAppAndArgs(LPTSTR tszApp, size_t appBufSize, LPTSTR * pptszArg);
    VOID    _UpdateAppNameAndIcon(LPWSTR wszApp, size_t appBufSize, LPWSTR * ppwszArg);
    VOID    _UpdateAppIcon(LPCTSTR tszApp);
    VOID    _SetAppEdit(LPCTSTR tszApp, LPCTSTR tszArgs);
    BOOL    _JobObjectIsLocal();
    void    _UpdateRunAsControl(void);
    BOOL    _Browse(TCHAR szFilePath[]);

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                 { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    void	_DisableUI(void);

    AccountInfo     m_AccountInfo;          // Account/password change info.

    ITask         * m_pIJob;

    // Flag values.  Note the compiler allocates a single dword for these

    DWORD           m_CommentDirty : 1;     //
    DWORD           m_AppNameDirty : 1;     //
    DWORD           m_WorkingDirDirty : 1;  // A value of 1 => dirty
    DWORD           m_RunAsDirty : 1;       //
    DWORD           m_updateIcon : 1;       // 1 => update needed
    DWORD           m_ChangeFromSetText : 1;// 0 => en_change from user

    //
    //  icon helper
    //

    CIconHelper   * m_pIconHelper;

    //
    //  flags
    //
    
    BOOL            m_fPersistChanges;    // Should we save on Apply or OK?
    BOOL            m_fEnableJob;            // Is the job enabled?
    BOOL            m_fNetScheduleJob;    // Is this an AT job?

    //
    // Saved or new sage settings parameter
    //

    TCHAR           m_tszSageRunParam[20]; // /SAGERUN:4294967295

    //
    // The RunAs edit control can be updated by the user, or automatically
    // with apply via the set account information dialog. In response to
    // user edits, we want to apply the changes. For the automatic RunAs
    // update, we've already applied the changes, therefore, this flag
    // exists to not re-dirty the page.
    //

    BOOL            m_fApplyRunAsEditChange;

    //
    //  The other pages need to query the general page if there is an
    //  application or security account change for the common security
    //  code in the page's save path (JFSaveJob). The record of this
    //  dirty information must be retained post-Apply; therefore, these
    //  slightly redundant flags are necessary.
    //

    BOOL            m_fTaskApplicationChange;
    BOOL            m_fTaskAccountChange;

    //
    //  Set this flag to TRUE if we have launched the set password dialog.
    //  Othwerwise, the user may get a redundant set account information
    //  dialog on apply.
    //

    BOOL            m_fSuppressAcctInfoRequestOnApply;

}; // class CGeneralPage


inline
CGeneralPage::CGeneralPage(
    ITask * pIJob,
    LPTSTR  ptszTaskPath,
    BOOL    fPersistChanges)
        :
        m_pIJob(pIJob),
        m_pIconHelper(NULL),
        m_fPersistChanges(fPersistChanges),
        m_ChangeFromSetText(FALSE),
        m_fApplyRunAsEditChange(TRUE),
        m_fTaskApplicationChange(FALSE),
        m_fTaskAccountChange(FALSE),
        m_fSuppressAcctInfoRequestOnApply(FALSE),
        m_fNetScheduleJob(FALSE),
        CPropPage(MAKEINTRESOURCE(general_page), ptszTaskPath)
{
    TRACE(CGeneralPage, CGeneralPage);

    Win4Assert(m_pIJob != NULL);

    m_pIJob->AddRef();
    m_tszSageRunParam[0] = TEXT('\0');

    InitializeAccountInfo(&m_AccountInfo);
}


inline
CGeneralPage::~CGeneralPage()
{
    TRACE(CGeneralPage, ~CGeneralPage);

    if (m_pIconHelper != NULL)
    {
        m_pIconHelper->Release();
    }

    if (m_pIJob != NULL)
    {
        m_pIJob->Release();
    }

    ResetAccountInfo(&m_AccountInfo);
}


//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_JobObjectIsLocal
//
//  Synopsis:   Return TRUE if job object being edited lives on the local
//              machine, FALSE otherwise.
//
//  History:    2-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

inline BOOL
CGeneralPage::_JobObjectIsLocal()
{
    return IsLocalFilename(GetTaskPath());
}


LRESULT
CGeneralPage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE(CGeneralPage, _OnInitDialog);

    HRESULT     hr              = S_OK;
    LPWSTR      pwsz            = NULL;
    BOOL        fEnableSecurity = FALSE;
    TCHAR       tszApp[MAX_PATH + 1] = TEXT("");

    //
    // Note that we don't limit the txt_app_name control.  App names are
    // limited to MAX_PATH characters, but app parameters are not.
    //
    HWND hwnd;
    if (hwnd = _hCtrl(txt_comments)) Edit_LimitText(hwnd, MAX_PATH);
    if (hwnd = _hCtrl(txt_workingdir)) Edit_LimitText(hwnd, MAX_PATH);
    if (hwnd = _hCtrl(txt_run_as)) Edit_LimitText(hwnd, MAX_USERNAME);

    //
    // Policy - if this reg key is valid, disable browse
    //

    if (RegReadPolicyKey(TS_KEYPOLICY_DENY_BROWSE))
    {
        DEBUG_OUT((DEB_ITRACE, "Policy ALLOW_BROWSE active, no browse or edit\n"));
        if (hwnd = _hCtrl(btn_browse)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(btn_browse)) ShowWindow(hwnd, SW_HIDE);
        if (hwnd = _hCtrl(txt_app_name)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(txt_workingdir)) EnableWindow(hwnd, FALSE);
    }

    do
    {
        // Determine if the security settings should be shown or not.
        // The task object must reside within a tasks folder & exist
        // on an NT machine.
        //

        fEnableSecurity = (this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                           this->IsTaskInTasksFolder());

        if (!fEnableSecurity)
        {
            if (hwnd = _hCtrl(lbl_run_as)) DestroyWindow(hwnd);
            if (hwnd = _hCtrl(txt_run_as)) DestroyWindow(hwnd);
            if (hwnd = _hCtrl(btn_passwd)) DestroyWindow(hwnd);
        }

        //
        //  Set the job enabled check box
        //
        DWORD dwFlags;
        hr = m_pIJob->GetFlags(&dwFlags);
        m_fEnableJob = (dwFlags & TASK_FLAG_DISABLED) ? FALSE : TRUE;
        CheckDlgButton(m_hPage, chk_enable_job, m_fEnableJob);

        //
        //  Remember this for use later
        //
        m_fNetScheduleJob = dwFlags & JOB_I_FLAG_NET_SCHEDULE;

        // See if the schedule page has already created the icon
        // helper, if not create it here.

        m_pIconHelper = (CIconHelper *)PropSheet_QuerySiblings(
                                GetParent(Hwnd()), GET_ICON_HELPER, 0);

        if (m_pIconHelper == NULL)
        {
            m_pIconHelper = new CIconHelper();

            if (m_pIconHelper == NULL)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
        }
        else
        {
            m_pIconHelper->AddRef();
        }

        //
        // Set job name (static text showing path to .job object)
        //

        SetDlgItemText(Hwnd(), lbl_job_name, this->GetTaskPath());

        //
        // Set comments
        //

        hr = m_pIJob->GetComment(&pwsz);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        I_SetDlgItemText(Hwnd(), txt_comments, pwsz);
        CoTaskMemFree(pwsz);

        //
        // Get application name preparatory to setting it.
        //

        hr = m_pIJob->GetApplicationName(&pwsz);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        lstrcpyn(tszApp, pwsz, MAX_PATH + 1);

        //
        // If the application name fetched from the job object has spaces in
        // it, add quotes around the tchar version.
        //

        if (wcschr(pwsz, L' '))
        {
            AddQuotes(tszApp, MAX_PATH + 1);
        }
        CoTaskMemFree(pwsz);

        //
        // Now get the parameters and append a space and the tchar
        // representation to the app name.
        //

        hr = m_pIJob->GetParameters(&pwsz);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);


        TCHAR * tszArg = pwsz;

        //
        // If the /SAGERUN:n parameter appears in the arguments, save it in
        // an internal buffer, but don't show it in the UI.
        //

        LPTSTR ptszSageRun = _tcsstr(tszArg, SAGERUN_PARAM);

        if (ptszSageRun)
        {
            lstrcpyn(m_tszSageRunParam,
                     ptszSageRun,
                     ARRAYLEN(m_tszSageRunParam));

            *ptszSageRun = TEXT('\0');
            StripLeadTrailSpace(tszArg); // get rid of spaces before /sagerun
        }

        _SetAppEdit(tszApp, tszArg);

        CoTaskMemFree(pwsz);

        //
        // Set the working directory
        //

        hr = m_pIJob->GetWorkingDirectory(&pwsz);
        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (wcschr(pwsz, L' '))
        {
            WCHAR wszWorkingDir[MAX_PATH + 1] = L"\"";

            wcsncpy(wszWorkingDir + 1, pwsz, MAX_PATH - 1);
           
            StringCchCat(wszWorkingDir, MAX_PATH + 1, L"\"");
            I_SetDlgItemText(Hwnd(), txt_workingdir, wszWorkingDir);
        }
        else
        {
            I_SetDlgItemText(Hwnd(), txt_workingdir, pwsz);
        }
        CoTaskMemFree(pwsz);

        if (!this->IsTaskInTasksFolder())
        {
            EnableWindow(_hCtrl(chk_enable_job), FALSE);
            m_fEnableJob = FALSE;
        }

        if (fEnableSecurity)
        {
            //
            // Set account name (run as)
            //
            DWORD cchAccount = MAX_USERNAME + 1;
            WCHAR wszDisplayAccount[MAX_USERNAME + 1] = L"";

            hr = m_pIJob->GetAccountInformation(&pwsz);
            if (SUCCEEDED(hr))
            {
                //
                //  Translate account prior to display, then display it
                //
                hr = TranslateAccount(TRANSLATE_FOR_DISPLAY, pwsz, wszDisplayAccount, cchAccount);
                if (SUCCEEDED(hr))
                {
                    I_SetDlgItemText(Hwnd(), txt_run_as, wszDisplayAccount);    // display the translated account
                }
                m_AccountInfo.pwszAccountName = pwsz;                        // use the untranslated account internally
                EnableWindow(_hCtrl(btn_passwd), TRUE);
            }
            else if (hr == SCHED_E_ACCOUNT_INFORMATION_NOT_SET)
            {
                WCHAR wszAccount[MAX_USERNAME + 1];
                
                if (m_fNetScheduleJob)
                {
                    //
                    // get the name of the AT service account
                    //
                    RpcTryExcept
                    {
                        hr = SAGetNSAccountInformation(NULL, cchAccount, wszAccount);
                    }
                    RpcExcept(1)
                    {
                        DWORD Status = RpcExceptionCode();
                        hr = SchedMapRpcError(Status);
                    }
                    RpcEndExcept;
        
                    if (FAILED(hr) || S_FALSE == hr)
                    {
                        wszAccount[0] = L'\0';
                    }
                }
                else
                {
                    //
                    // Set the run as field to the current user's name and
                    // enable the set/change password button.
                    //
                    GetDefaultDomainAndUserName(wszAccount, cchAccount);
        
                    //
                    // Sometimes I think this would be better than defaulting to the current user, because
                    // the user can get confused and think that the account is already set when it isn't.
                    //
                    // lstrcpyW(wszAccount,L"***Account not set***");
                    //
                }

                //
                //  Translate account prior to display, then display it
                //
                hr = TranslateAccount(TRANSLATE_FOR_DISPLAY, wszAccount, wszDisplayAccount, cchAccount);
                if (SUCCEEDED(hr))
                {
                    SetDlgItemText(Hwnd(), txt_run_as, wszDisplayAccount);
                }
                EnableWindow(_hCtrl(btn_passwd), TRUE);

                //
                // everything is ok, really
                //
                hr = S_OK;
            }
            else
            {
                //
                // Disable the run as and set/change password button ctrls &
                // put up an error dialog letting the user know that security
                // services are unavailable.
                //
                // Actually, the set/change password button is already
                // disabled.
                //

                CHECK_HRESULT(hr);
                EnableWindow(_hCtrl(lbl_run_as), FALSE);
                EnableWindow(_hCtrl(txt_run_as), FALSE);
            }
        }

    } while (0);

    //
    // Disable all controls if this is an AT job
    // to prevent user from making changes
    //
    if (m_fNetScheduleJob)
    	_DisableUI();

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else
        {
            _ErrorDialog(IERR_GENERAL_PAGE_INIT, hr);
        }

        //
        // Show application icon
        //
        m_updateIcon = 1;
        _UpdateAppIcon(tszApp);

        EnableWindow(Hwnd(), FALSE);

        return FALSE;
    }

    //
    // Show application icon
    //

    m_updateIcon = 1;
    _UpdateAppIcon(tszApp);


    //
    // Need to initialize these here since doing a SetDlgItemText causes
    // a WM_COMMAND msg with EN_CHANGE to be called for edit boxes.
    //

    m_CommentDirty = 0;
    m_AppNameDirty = 0;
    m_WorkingDirDirty = 0;
    m_RunAsDirty = 0;

    m_fDirty = FALSE;

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//	Member:    	CGeneralPage::_DisableUI
//
//	Synopsis:	Disable UI so the user can only view the settings
//
//	History:	2001-11-13  ShBrown	Created
//
//---------------------------------------------------------------------------

void 
CGeneralPage::_DisableUI(void)
{
	HWND hwnd;
    
    if (hwnd = _hCtrl(txt_app_name))    EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_workingdir))  EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_comments))    EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(txt_run_as))      EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_enable_job))  EnableWindow(hwnd, FALSE);

	if (hwnd = _hCtrl(btn_browse))      EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(btn_browse))      ShowWindow(hwnd, SW_HIDE);
	if (hwnd = _hCtrl(btn_passwd))      EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(btn_passwd))      ShowWindow(hwnd, SW_HIDE);
}



//+--------------------------------------------------------------------------
//
//  Function:   GetDefaultDomainAndUserName
//
//  Synopsis:   Fill [pwszDomainAndUserName] with "domain\user" string
//
//  Arguments:  [pwszDomainAndUserName] - buffer to receive string
//              [cchBuf]                - should be at least MAX_USERNAME
//
//  Modifies:   *[pwszDomainAndUserName].
//
//  History:    06-03-1997  DavidMun	Created
//        	2001-11-13  ShBrown	Modified to use wchar rather than tchar	
//
//  Notes:      If an error occurs while retrieving the domain name, only
//              the user name is returned.  If even that cannot be
//              retrieved, the buffer is set to an empty string.
//
//---------------------------------------------------------------------------

VOID
GetDefaultDomainAndUserName(
    LPWSTR pwszDomainAndUserName,
    ULONG  cchBuf)
{
    TRACE_FUNCTION(GetDefaultDomainAndUserName);

    if (!GetUserNameExW(NameSamCompatible,
                       pwszDomainAndUserName,
                       &cchBuf))
    {
        DEBUG_OUT((DEB_ERROR,
                   "GetDefaultDomainAndUserName: GetUserNameExW failed %d\n",
                   GetLastError()));

        pwszDomainAndUserName[0] = L'\0';
    }
}






void
CGeneralPage::_UpdateAppIcon(
    LPCTSTR ptszAppName)
{
    if (m_updateIcon == 0)
    {
        return;
    }

    m_updateIcon = 0;

    if (ptszAppName)
    {
        m_pIconHelper->SetAppIcon((LPTSTR)ptszAppName);
    }

    BOOL fEnabled;

    if (this->IsTaskInTasksFolder())
    {
        fEnabled = (IsDlgButtonChecked(m_hPage, chk_enable_job)
                    == BST_CHECKED);
    }
    else
    {
        fEnabled = FALSE;
    }

    m_pIconHelper->SetJobIcon(fEnabled);

    SendDlgItemMessage(Hwnd(), idc_icon, STM_SETICON,
                    (WPARAM)m_pIconHelper->hiconJob, 0L);
}


BOOL
CGeneralPage::_Browse(
    TCHAR szFilePath[]) // of size MAX_PATH
{
    TCHAR szDefExt[5];
    TCHAR szBrowserDir[MAX_PATH];
    TCHAR szFilters[MAX_PATH];
    TCHAR szTitle[100];

    DWORD dwFlags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

    LoadString(g_hInstance, IDS_EXE, szDefExt, ARRAYLEN(szDefExt));
    LoadString(g_hInstance, IDS_BROWSE, szTitle, ARRAYLEN(szTitle));

    SecureZeroMemory(szFilters, sizeof(szFilters));
    if (!LoadString(g_hInstance,
                    IDS_PROGRAMSFILTER,
                    szFilters,
                    ARRAYLEN(szFilters)))
    {
    	CHECK_HRESULT( HRESULT_FROM_WIN32(GetLastError()) );
        return FALSE;
    }

    GetCurrentDirectory(MAX_PATH, szBrowserDir);

    OPENFILENAME ofn;
    SecureZeroMemory(&ofn, sizeof(ofn));

    szFilePath[0] = TEXT('\0');

    // Setup info for comm dialog.
    ofn.lStructSize       = CDSIZEOF_STRUCT(OPENFILENAME, lpTemplateName);
    ofn.hwndOwner         = Hwnd();
    ofn.hInstance         = g_hInstance;
    ofn.lpstrFilter       = szFilters;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrInitialDir   = szBrowserDir;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = dwFlags;
    ofn.lpstrDefExt       = szDefExt;

    // Call it.
    if (GetOpenFileName(&ofn) == FALSE)
    {
        DEBUG_OUT((DEB_ERROR, "GetOpenFileName failed<0x%x>\n",
                                            CommDlgExtendedError()));

        return FALSE;
    }
    return TRUE;
}


LRESULT
CGeneralPage::_OnCommand(
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify)
{
    TRACE(CGeneralPage, _OnCommand);

    if ((id == btn_browse) && (codeNotify == BN_CLICKED))
    {
        // popup the file browse dialog

        TCHAR tszFilePath[MAX_PATH+1];

        if (_Browse(tszFilePath))
        {
            if (_tcschr(tszFilePath, TEXT(' ')))
            {
                AddQuotes(tszFilePath, MAX_PATH);
            }
            SetDlgItemText(Hwnd(), txt_app_name, tszFilePath);
            SendMessage(Hwnd(),
                        WM_NEXTDLGCTL,
                        (WPARAM)_hCtrl(txt_workingdir),
                        TRUE);
            _UpdateAppIcon(tszFilePath);
            _EnableApplyButton();
        }
    }
    else if (id == btn_passwd && codeNotify == BN_CLICKED)
    {
        // popup the set password dialog
        LaunchSetPasswordDlg(Hwnd(), &m_AccountInfo);

        //
        // Since we've launched the set password dialog, we want
        // to suppress the set account information dialog which
        // otherwise may come up on apply.
        //

        m_fSuppressAcctInfoRequestOnApply = TRUE;

        _EnableApplyButton();
    }
    else if (codeNotify == EN_CHANGE)
    {
        switch (id)
        {
        case txt_comments:
            m_CommentDirty = 1;
            break;

        case txt_app_name:
            //
            // If we just did a SetDlgItemText, then this change notification
            // should be ignored.
            //
            if (m_ChangeFromSetText)
            {
                m_ChangeFromSetText = 0;
            }
            else
            {
                m_AppNameDirty = 1;
                m_updateIcon = 1;
            }
            break;

        case txt_workingdir:
            m_WorkingDirDirty = 1;
            break;

        case txt_run_as:
                //
                // If m_fApplyRunAsEditChange is TRUE, the user has edited
                // the RunAs control, therefore, we want to apply changes.
                // If FALSE, the RunAs control has been automatically updated
                // by the UI as a result of an apply. In this case, we do
                // not want to apply the change, as it already has been.
                //

                if (m_fApplyRunAsEditChange)
                {
                    m_RunAsDirty = 1;

                    HWND hwnd;
                    if (hwnd = _hCtrl(btn_passwd)) EnableWindow(hwnd, TRUE);
                    break;
                }
                else
                {
                    Win4Assert(!m_fDirty);
                    return TRUE;
                }

        default:
            return FALSE;
        }

        _EnableApplyButton();
    }
    else if (codeNotify == EN_KILLFOCUS &&
             id == txt_app_name)
    {
        if (m_AppNameDirty == 1)
        {
            TCHAR tszApp[MAX_PATH + 1];

            _GetAppAndArgs(tszApp, MAX_PATH + 1, NULL);
            if (_JobObjectIsLocal())
            {
                _ExpandAppName(tszApp, MAX_PATH + 1);
            }
            _UpdateAppIcon(tszApp);
        }
    }
    else if (id == chk_enable_job)
    {
        _EnableApplyButton();
        m_updateIcon = 1;
        _UpdateAppIcon(NULL);
    }

    return TRUE;
}



LRESULT
CGeneralPage::_OnApply(void)
{
    TRACE(CGeneralPage, _OnApply);

    if (m_fDirty == FALSE)
    {
        return TRUE;
    }

    HRESULT     hr = S_OK;
    WCHAR       wcBuff[MAX_PATH+1];
    LPWSTR      pwszArg = NULL;
    BOOL          bNoAccountSpecified = FALSE;

    do
    {
        if (m_CommentDirty == 1)
        {
            wcBuff[0] = L'\0';

            I_GetDlgItemText(Hwnd(), txt_comments, wcBuff, MAX_PATH+1);

            hr = m_pIJob->SetComment(wcBuff);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_CommentDirty = 0;
        }

        m_fTaskApplicationChange = FALSE;

        if (m_AppNameDirty == 1)
        {
            WCHAR wszApp[MAX_PATH + 1];

            _UpdateAppNameAndIcon(wszApp, MAX_PATH + 1, &pwszArg);
            if (pwszArg == NULL)
            {
                break;
            }

            hr = m_pIJob->SetApplicationName(wszApp);
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = m_pIJob->SetParameters(pwszArg);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_AppNameDirty           = 0;
            m_fTaskApplicationChange = TRUE;
        }

        if (m_WorkingDirDirty == 1)
        {
            wcBuff[0] = L'\0';

            _ExpandWorkingDir();
            I_GetDlgItemText(Hwnd(), txt_workingdir, wcBuff, MAX_PATH+1);

            hr = m_pIJob->SetWorkingDirectory(wcBuff);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_WorkingDirDirty = 0;
        }

        m_fTaskAccountChange = FALSE;
        if (m_RunAsDirty == 1 || m_AccountInfo.pwszPassword != tszEmpty)
        {
            wcBuff[0] = L'\0';
            DWORD ccAccountName = I_GetDlgItemText(Hwnd(),
                                                   txt_run_as,
                                                   wcBuff,
                                                   MAX_USERNAME + 1);

            //
            // Yell if the user blanked out the field.
            //
            if (wcBuff[0] == L'\0')
            {
                bNoAccountSpecified = TRUE;
                hr = E_FAIL;
                break;
            }

            if ((m_RunAsDirty == 1 && m_AccountInfo.pwszAccountName == NULL) ||
                (m_RunAsDirty == 1 && m_AccountInfo.pwszAccountName != NULL &&
                 lstrcmpiW(m_AccountInfo.pwszAccountName, wcBuff) != 0))
            {
                //
                // The user has changed the account name. Check if they have
                // specified a password.
                //

                if (m_AccountInfo.pwszPassword == tszEmpty)
                {
                    //
                    // User hasn't specified a password. Launch the set
                    // password dialog.
                    //

                    LaunchSetPasswordDlg(Hwnd(), &m_AccountInfo);

                    //
                    // Since we've launched the set password dialog, we want
                    // to suppress the set account information dialog which
                    // otherwise may come up on apply.
                    //

                    m_fSuppressAcctInfoRequestOnApply = TRUE;
                }
            }

            if (m_AccountInfo.pwszPassword != tszEmpty)
            {
                //
                // Translate input account prior to saving, then save it
                //
                DWORD cchAccount = MAX_USERNAME + 1;
                WCHAR wszAccount[MAX_USERNAME + 1] = L"";
                hr = TranslateAccount(TRANSLATE_FOR_INTERNAL, wcBuff, wszAccount, cchAccount, &(m_AccountInfo.pwszPassword));
                if (SUCCEEDED(hr))
                {
                    hr = m_pIJob->SetAccountInformation(wszAccount, m_AccountInfo.pwszPassword);
                }

                if (FAILED(hr))
                {
                    CHECK_HRESULT(hr);
                    break;
                }

                m_RunAsDirty         = 0;
                m_AccountInfo.fDirty = FALSE;
                m_fTaskAccountChange = TRUE;
            }
        }

        //
        //  Save the job enabled state
        //

        if (this->IsTaskInTasksFolder())
        {
            DWORD dwFlags;

            hr = m_pIJob->GetFlags(&dwFlags);

            BOOL fTemp = (IsDlgButtonChecked(m_hPage, chk_enable_job)
                                                        == BST_CHECKED);

            if (m_fEnableJob != fTemp)
            {
                m_fEnableJob = fTemp;

                if (m_fEnableJob == TRUE)
                {
                    dwFlags &= ~TASK_FLAG_DISABLED;
                }
                else
                {
                    dwFlags |= TASK_FLAG_DISABLED;
                }

                hr = m_pIJob->SetFlags(dwFlags);

                CHECK_HRESULT(hr);
                BREAK_ON_FAIL(hr);
            }
        }

        //
        // reset dirty flag
        //

        m_fDirty = FALSE;

        //
        //  If evrything went well see if the other pages are ready to
        //  save the job to storage.
        //

        if ((m_fPersistChanges == TRUE)  &&
            (PropSheet_QuerySiblings(GetParent(Hwnd()),
                                        QUERY_READY_TO_BE_SAVED, 0))
            == 0)
        {
            //
            // Save the job file to storage.
            //
            // For the first release of the scheduling agent, all security
            // operations are disabled under Win95, even Win95 to NT.
            //

            hr = JFSaveJob(Hwnd(),
                           m_pIJob,
                           this->GetPlatformId() == VER_PLATFORM_WIN32_NT &&
                            this->IsTaskInTasksFolder(),
                           m_fTaskAccountChange,
                           m_fTaskApplicationChange,
                           m_fSuppressAcctInfoRequestOnApply);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            m_fTaskApplicationChange          = FALSE;
            m_fTaskAccountChange              = FALSE;
            m_fSuppressAcctInfoRequestOnApply = FALSE;

            // Will result in refresh of the run as edit control.
            //
            _UpdateRunAsControl();
        }

    } while (0);

    delete [] pwszArg;

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        {
            _ErrorDialog(IERR_FILE_NOT_FOUND);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            _ErrorDialog(IERR_ACCESS_DENIED);
        }
        else if (bNoAccountSpecified)
        {
            _ErrorDialog(IERR_ACCOUNTNAME);
        }
        else
        {
            _ErrorDialog(IERR_INTERNAL_ERROR, hr);
        }
    }

    return SUCCEEDED(hr);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_UpdateAppNameAndIcon
//
//  Synopsis:   Update the application name edit control with an expanded
//              path for the app, then update the icon for the new path.
//
//  Arguments:  [wszApp]  - NULL or buffer to receive WCHAR app name
//              [appBufSize] - size of buffer in WCHARs
//              [ppwszArgs] - NULL or address of pointer to buffer to receive
//                  WCHAR arguments.  Must be deallocated with delete[].
//
//  Modifies:   *[wszApp], *[ppwszArgs]
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      App path is only expanded if job object is local.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_UpdateAppNameAndIcon(
    LPWSTR wszApp,
    size_t appBufSize,
    LPWSTR * ppwszArgs)
{
    TCHAR tszApp[MAX_PATH + 1];
    LPTSTR ptszArgs = NULL;

    _GetAppAndArgs(tszApp, MAX_PATH + 1, &ptszArgs);
    if (ptszArgs == NULL)
    {
        return;
    }

    if (_JobObjectIsLocal())
    {
        _ExpandAppName(tszApp, MAX_PATH + 1);

        m_updateIcon = 1;
        _UpdateAppIcon(tszApp);

        //
        // If the working directory is empty and the app is on the local
        // machine, provide a default of the directory where the app lives.
        //

        TCHAR tszWorkingDir[MAX_PATH + 1];
        GetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir, MAX_PATH + 1);
        StripLeadTrailSpace(tszWorkingDir);
        DeleteQuotes(tszWorkingDir);

        if (!*tszWorkingDir && IsLocalFilename(tszApp))
        {
            StringCchCopy(tszWorkingDir, MAX_PATH + 1, tszApp);
            DeleteQuotes(tszWorkingDir);

            // Get rid of the filename at the end of the string

            PathRemoveFileSpec(tszWorkingDir);

            if (HasSpaces(tszWorkingDir))
            {
                AddQuotes(tszWorkingDir, MAX_PATH + 1);
            }
            SetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir);
        }

        m_ChangeFromSetText = 1;
        _SetAppEdit(tszApp, ptszArgs);
    }

    if (wszApp)
    {
        StringCchCopy(wszApp, appBufSize, tszApp);
    }

    if (ppwszArgs)
    {
        *ppwszArgs = ptszArgs;
    }
    else
    {
        delete [] ptszArgs;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_ExpandWorkingDir
//
//  Synopsis:   Replace the string in the working directory edit control
//              with one which has expanded environment strings.
//
//  History:    06-04-1997   DavidMun   Created
//
//  Notes:      Note that this will result in the working dir being marked
//              as dirty.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_ExpandWorkingDir()
{
    TCHAR tszApp[MAX_PATH + 1];

    //
    // If editing a remote job, don't touch the working dir, since we
    // can't expand using its environment variables.
    //

    if (!_JobObjectIsLocal())
    {
        return;
    }

    TCHAR tszWorkingDir[MAX_PATH + 1];

    GetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir, MAX_PATH + 1);
    StripLeadTrailSpace(tszWorkingDir);
    DeleteQuotes(tszWorkingDir);

    TCHAR tszExpandedWorkingDir[MAX_PATH + 1];

    ULONG cchWritten;

    cchWritten = ExpandEnvironmentStrings(tszWorkingDir,
                                          tszExpandedWorkingDir,
                                          ARRAYLEN(tszExpandedWorkingDir));

    //
    // If the call succeeded, write the update string to the working dir
    // edit control.  If there were no environment variables to replace,
    // the string will be unchanged.
    //
    // Note that writing to the edit control will cause an EN_CHANGE which
    // will result in m_WorkingDirDirty being set.
    //

    if (cchWritten && cchWritten <= ARRAYLEN(tszExpandedWorkingDir))
    {
        SetDlgItemText(Hwnd(), txt_workingdir, tszExpandedWorkingDir);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_GetAppAndArgs
//
//  Synopsis:   Fetch the string in the application name edit control and
//              split it into the app name part and the arguments part.
//
//  Arguments:  [tszApp]  - NULL or buffer for app name
//              [pptszArgs] - NULL or address of pointer to buffer for args,
//                  must be deallocated with delete[]
//
//  Modifies:   *[tszApp], *[pptszArgs]
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      Application name is space delimited and must be surrounded
//              by double quotes if it contains spaces.  For example:
//
//              text in edit ctrl        'filename' 'arguments'
//              ---------------------    -------------------------
//              notepad.exe foo.txt   => 'notepad.exe' 'foo.txt'
//              "notepad.exe"foo.txt  => '"notepad.exe"foo.txt' ''
//              "notepad.exe" foo.txt => '"notepad.exe"' 'foo.txt'
//              "no  pad.exe" foo.txt => '"no  pad.exe"' 'foo.txt'
//              no  pad.exe foo.txt   => 'no' '  pad.exe foo.txt'
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_GetAppAndArgs(
    LPTSTR tszApp,
    size_t appBufSize,
    LPTSTR * pptszArgs)
{
    //
    // Split application name into executable name & parameters.  First
    // strip lead/trail spaces and null terminate at the first whitespace
    // outside a quote.
    //

    int cch = SchedGetDlgItemTextLength(Hwnd(), txt_app_name) + 1;
    if (cch <= 1)
    {
        DEBUG_OUT((DEB_ERROR,
                   "SchedGetDlgItemTextLength failed %d\n",
                   GetLastError()));
    }

    TCHAR *ptszBoth = new TCHAR[cch];
    if (ptszBoth == NULL)
    {
        DEBUG_OUT((DEB_ERROR,
                   "_GetAppAndArgs alloc failed %d\n",
                   GetLastError()));
        return;
    }

    GetDlgItemText(Hwnd(), txt_app_name, ptszBoth, cch);
    StripLeadTrailSpace(ptszBoth);

    LPTSTR  ptsz;
    BOOL    fInQuote = FALSE;

    for (ptsz = ptszBoth; *ptsz; ptsz = NextChar(ptsz))
    {
        if (*ptsz == TEXT('"'))
        {
            fInQuote = !fInQuote;
        }
        else if (*ptsz == TEXT(' '))
        {
            if (!fInQuote)
            {
                *ptsz++ = L'\0';
                break;
            }
        }
    }

    //
    // Return app name if caller wants it.
    //

    if (tszApp)
    {
        StringCchCopy(tszApp, appBufSize, ptszBoth);
    }

    //
    // Now ptsz points to the first char past the application
    // name.  If there are no arguments, then ptsz is pointing
    // to the end of the string.  Otherwise it's pointing to the
    // start of the argument string.  Return this if caller wants it.
    //

    if (pptszArgs)
    {
        size_t bufSize = cch - (ptsz - ptszBoth);
        *pptszArgs = new TCHAR[bufSize];
        if (*pptszArgs == NULL)
        {
            DEBUG_OUT((DEB_ERROR,
                       "_GetAppAndArgs second alloc failed %d\n",
                       GetLastError()));
        }
        else
        {
            StringCchCopy(*pptszArgs, bufSize, ptsz);
        }
    }

    delete [] ptszBoth;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_ExpandAppName
//
//  Synopsis:   Change filename in [tszApp] to full path.
//
//  Arguments:  [tszApp] - filename to modify
//
//  Modifies:   *[tszApp]
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      CAUTION: Should be called only for job objects on the
//              LOCAL MACHINE.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_ExpandAppName(
    LPTSTR tszApp,
    size_t cchBuff)
{
    TCHAR tszWorkingDir[MAX_PATH + 1];
    BOOL fFound;

    GetDlgItemText(Hwnd(), txt_workingdir, tszWorkingDir, MAX_PATH + 1);
    fFound = ProcessApplicationName(tszApp, cchBuff, tszWorkingDir);

    if (_tcschr(tszApp, TEXT(' ')))
    {
        AddQuotes(tszApp, MAX_PATH);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_SetAppEdit
//
//  Synopsis:   Set the application edit control to contain the concatenated
//              text in [tszApp] and [tszArgs].
//
//  Arguments:  [tszApp]  - application name
//              [tszArgs] - arguments
//
//  History:    1-31-1997   DavidMun   Created
//
//  Notes:      No modification (adding quotes, etc.) is done to [tszApp].
//              Caller should set m_ChangeFromSetText = 1 if calling from
//              outside of wm_initdialog processing.
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_SetAppEdit(LPCTSTR tszApp, LPCTSTR tszArgs)
{
    HWND hwndAppName = GetDlgItem(Hwnd(), txt_app_name);

    Edit_SetText(hwndAppName, tszApp);

    if (tszArgs && *tszArgs)
    {
        ULONG cchApp = lstrlen(tszApp);

        Edit_SetSel(hwndAppName, cchApp, cchApp);
        Edit_ReplaceSel(hwndAppName, TEXT(" "));
        Edit_SetSel(hwndAppName, cchApp + 1, cchApp + 1);
        Edit_ReplaceSel(hwndAppName, tszArgs);
    }
}




LRESULT CGeneralPage::_OnCancel(void)
{
    return 0;
}



LRESULT
CGeneralPage::_OnPSMQuerySibling(
    WPARAM  wParam,
    LPARAM  lParam)
{
    TRACE(CGeneralPage, _OnPSMQuerySibling);

    INT_PTR iRet = 0;

    switch (wParam)
    {
    case QUERY_READY_TO_BE_SAVED:
        iRet = (int)m_fDirty;
        break;

    case GET_ICON_HELPER:
        iRet = (INT_PTR)m_pIconHelper;
        break;

    case QUERY_TASK_APPLICATION_DIRTY_STATUS:
        *((BOOL *)lParam) = m_fTaskApplicationChange;
        iRet = 1;
        break;

    case QUERY_TASK_ACCOUNT_INFO_DIRTY_STATUS:
        *((BOOL *)lParam) = m_fTaskAccountChange;
        iRet = 1;
        break;

    case QUERY_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG:
        *((BOOL *)lParam) = m_fSuppressAcctInfoRequestOnApply;
        iRet = 1;
        break;

    case RESET_TASK_APPLICATION_DIRTY_STATUS:
        m_fTaskApplicationChange = FALSE;
        iRet = 1;
        break;

    case RESET_TASK_ACCOUNT_INFO_DIRTY_STATUS:
        m_fTaskAccountChange = FALSE;
        iRet = 1;
        break;

    case RESET_SUPPRESS_ACCOUNT_INFO_REQUEST_FLAG:
        m_fSuppressAcctInfoRequestOnApply = FALSE;
        iRet = 1;
        break;

    case TASK_ACCOUNT_CHANGE_NOTIFY:
        Win4Assert(!m_fDirty);
        _UpdateRunAsControl();
        iRet = 1;
        break;

    }

    SetWindowLongPtr(Hwnd(), DWLP_MSGRESULT, iRet);
    return iRet;
}



void
CGeneralPage::_UpdateRunAsControl(void)
{
    LPWSTR pwsz;

    if (SUCCEEDED(m_pIJob->GetAccountInformation(&pwsz)))
    {
        //
        // Instruct the EN_CHANGE processing of the RunAs edit control
        // to not apply this change.
        //

        m_fApplyRunAsEditChange = FALSE;
        I_SetDlgItemText(Hwnd(), txt_run_as, pwsz);
        m_fApplyRunAsEditChange = TRUE;
        CoTaskMemFree(pwsz);
    }
}


LRESULT
CGeneralPage::_OnPSNKillActive(
    LPARAM lParam)
{
    TRACE(CGeneralPage, _OnPSNKillActive);

    if (m_AppNameDirty)
    {
        _UpdateAppNameAndIcon(NULL, 0, NULL);
    }

    if (m_WorkingDirDirty)
    {
        _ExpandWorkingDir();
    }
    return CPropPage::_OnPSNKillActive(lParam);
}



LRESULT
CGeneralPage::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND)hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aGeneralPageHelpIds);
    return TRUE;
}


HRESULT
GetGeneralPage(
    ITask           * pIJob,
    LPTSTR            ptszTaskPath,
    BOOL              fPersistChanges,
    HPROPSHEETPAGE  * phpage)
{
    TRACE_FUNCTION(GetGeneralPage);

    Win4Assert(pIJob != NULL);
    Win4Assert(phpage != NULL);

    HRESULT         hr      = S_OK;
    LPOLESTR        polestr = NULL;
    IPersistFile  * ppf     = NULL;
    LPTSTR          ptszPath = NULL;

    do
    {
        //
        // Get the job name.
        //

        if (ptszTaskPath != NULL)
        {
            //
            // use passed-in path
            //

            ptszPath = ptszTaskPath;
        }
        else
        {
            //
            // Obtain the job path from the interfaces.
            //

            hr = GetJobPath(pIJob, &ptszPath);
        }

        BREAK_ON_FAIL(hr);

        CGeneralPage * pPage = new CGeneralPage(
                                        pIJob,
                                        ptszPath,
                                        fPersistChanges);

        if (pPage == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        HPROPSHEETPAGE hpage = CreatePropertySheetPage(&pPage->m_psp);

        if (hpage == NULL)
        {
            delete pPage;
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *phpage = hpage;

    } while (0);

    //
    // If we made a copy of pIJob's path string, free it.
    //

    if (ptszPath != ptszTaskPath)
    {
        delete [] ptszPath;
    }

    if (ppf != NULL)
    {
        ppf->Release();
    }

    return hr;
}



HRESULT
AddGeneralPage(
    PROPSHEETHEADER &psh,
    ITask          * pIJob)
{
    TRACE_FUNCTION(AddGeneralPage);

    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetGeneralPage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        psh.phpage[psh.nPages++] = hpage;
    }

    return hr;
}



HRESULT
AddGeneralPage(
    LPFNADDPROPSHEETPAGE    lpfnAddPage,
    LPARAM                  cookie,
    ITask                 * pIJob)
{
    HPROPSHEETPAGE hpage = NULL;

    HRESULT hr = GetGeneralPage(pIJob, NULL, TRUE, &hpage);

    if (SUCCEEDED(hr))
    {
        if (!lpfnAddPage(hpage, cookie))
        {
            DestroyPropertySheetPage(hpage);

            hr = E_FAIL;
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   ResetAccountInfo
//
//  Synopsis:   Deallocate and initialize the account information specified.
//
//  Arguments:  [pAccountInfo] -- Account info structure.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
ResetAccountInfo(
    AccountInfo * pAccountInfo)
{
    //
    // Delete the account name.
    //

    if (pAccountInfo->pwszAccountName != NULL)
    {
        //
        // NB : pwszAccountName always allocated by CoTaskMemAlloc.
        //

        CoTaskMemFree(pAccountInfo->pwszAccountName);
        pAccountInfo->pwszAccountName = NULL;
    }

    //
    // Zero, delete the password. Except when the password is set to the
    // static empty string.
    //

    if (pAccountInfo->pwszPassword != NULL &&
        pAccountInfo->pwszPassword != tszEmpty)
    {
        ZERO_PASSWORD(pAccountInfo->pwszPassword);
        delete pAccountInfo->pwszPassword;
        pAccountInfo->pwszPassword = (LPWSTR) tszEmpty;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeAccountInfo
//
//  Synopsis:   Initializes account info fields.
//
//  Arguments:  [pAccountInfo]      -- Account info structure.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
InitializeAccountInfo(AccountInfo * pAccountInfo)
{
    pAccountInfo->pwszAccountName = NULL;

    //
    // If we haven't prompted for a password, pwszPassword points to the
    // global empty string variable.  This allows us to tell whether the
    // user intended the password to be an empty string, or we simply
    // haven't prompted for it.
    //

    pAccountInfo->pwszPassword    = (LPWSTR) tszEmpty;
}

//
// Helpers to launch Set/Change Password & Set Account Information dialogs.
//

//+---------------------------------------------------------------------------
//
//  Function:   LaunchSetPasswordDlg
//
//  Synopsis:   Helper to launch the dialog to modify the account password.
//
//  Arguments:  [hWnd]         -- Parent window handle.
//              [pAccountInfo] -- Structure manipulated by the dialog.
//
//  Returns:    DialogBoxParam return code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR
LaunchSetPasswordDlg(HWND hWnd, AccountInfo * pAccountInfo)
{
    return(DialogBoxParam(g_hInstance,
                          MAKEINTRESOURCE(set_passwd_dlg),
                          hWnd,
                          SetPasswordDlgProc,
                          (LPARAM)pAccountInfo));
}
//+---------------------------------------------------------------------------
//
//  Function:   LaunchSetAccountInformationDlg
//
//  Synopsis:   Helper to launch the dialog to modify the account namd and
//              password.
//
//  Arguments:  [hWnd]         -- Parent window handle.
//              [pAccountInfo] -- Structure manipulated by the dialog.
//
//  Returns:    DialogBoxParam return code.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR
LaunchSetAccountInformationDlg(HWND hWnd, AccountInfo * pAccountInfo)
{
    return(DialogBoxParam(g_hInstance,
                          MAKEINTRESOURCE(set_account_info_dlg),
                          hWnd,
                          SetAccountInformationDlgProc,
                          (LPARAM)pAccountInfo));
}

//
// Set/Change Password & Set Account Information dialogs.
//

//+---------------------------------------------------------------------------
//
//  Function:   SetPasswordDlgProc
//
//  Synopsis:   This dialog allows the user specify an account password.
//              The password is confirmed by a redundant confirmation edit
//              field.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//              [uMsg]   -- Message.
//              [wParam] -- Command.
//              [lParam] -- Account information dialog ptr on WM_INITDIALOG.
//
//  Returns:    TRUE  -- Message processed by this dialog.
//              FALSE -- Message not processed (WM_INITDIALOG excepted).
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR APIENTRY
SetPasswordDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static AccountInfo * pai                      = NULL;
    TCHAR  tszPassword[MAX_PASSWORD + 1]          = TEXT("");
    TCHAR  tszConfirmedPassword[MAX_PASSWORD + 1] = TEXT("");
    LPWSTR pwszPassword;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Win4Assert(lParam != NULL);
        pai = (AccountInfo *)lParam;
        Edit_LimitText(GetDlgItem(hDlg, edt_sp_passwd), MAX_PASSWORD);
        Edit_LimitText(GetDlgItem(hDlg, edt_sp_cfrmpasswd), MAX_PASSWORD);
        I_SetDlgItemText(hDlg, edt_sp_passwd, pai->pwszPassword);
        I_SetDlgItemText(hDlg, edt_sp_cfrmpasswd, pai->pwszPassword);

        //
        // Center the dialog.
        //

        CenterDialog(hDlg);
        return TRUE; // TRUE == let windows set focus

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            DWORD ccPassword;

            ccPassword = GetDlgItemText(hDlg,
                                        edt_sp_passwd,
                                        tszPassword,
                                        MAX_PASSWORD + 1);

            GetDlgItemText(hDlg,
                           edt_sp_cfrmpasswd,
                           tszConfirmedPassword,
                           MAX_PASSWORD + 1);

            if (lstrcmp(tszPassword, tszConfirmedPassword) != 0)
            {
                //
                // Passwords didn't match. Let the user know so he/she
                // can correct it.
                //

                SecureZeroMemory(tszPassword, sizeof tszPassword);
                SecureZeroMemory(tszConfirmedPassword, sizeof tszConfirmedPassword);
                SchedUIErrorDialog(hDlg, IERR_PASSWORD, (LPTSTR)NULL);
                return(TRUE);
            }

            if (ccPassword)
            {
                //
                // Non-NULL password.
                //

                ccPassword++;
                pwszPassword = new WCHAR[ccPassword];

                if (pwszPassword != NULL)
                {
                    StringCchCopy(pwszPassword, ccPassword, tszPassword);
                    SecureZeroMemory(tszPassword, sizeof tszPassword);
                    SecureZeroMemory(tszConfirmedPassword, sizeof tszConfirmedPassword);
                }
                else
                {
                    SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                       (LPTSTR)NULL);
                }
            }
            else
            {
                //
                // Clear the password.
                //

                pwszPassword = new WCHAR[1];
                if (pwszPassword != NULL)
                {
                    *pwszPassword = L'\0';
                }
                else
                {
                    SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                       (LPTSTR)NULL);
                    EndDialog(hDlg, wParam);
                    return(TRUE);
                }
            }

            //
            // Zero, delete the previous password. But don't delete the
            // static empty string.
            //

            if (pai->pwszPassword != NULL &&
                pai->pwszPassword != tszEmpty)
            {
                ZERO_PASSWORD(pai->pwszPassword);
                delete pai->pwszPassword;
            }
            pai->pwszPassword = pwszPassword;

        case IDCANCEL:
            SecureZeroMemory(tszPassword, sizeof tszPassword);
            SecureZeroMemory(tszConfirmedPassword, sizeof tszConfirmedPassword);
            EndDialog(hDlg, wParam);
            return TRUE;

        default:
            return FALSE;
        }

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle,
                szMstaskHelp,
                HELP_WM_HELP,
                (DWORD_PTR)(LPSTR)s_aSetPasswordDlgHelpIds);
        return TRUE;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam,
                szMstaskHelp,
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPSTR)s_aSetPasswordDlgHelpIds);
        return TRUE;

    default:
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SetAccountInformationDlgProc
//
//  Synopsis:   This dialog allows the user to specify full account
//              information: the account name and password. The password
//              is confirmed by a redundant confirmation edit field.
//              Logic also ensures the user must specify an account name.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//              [uMsg]   -- Message.
//              [wParam] -- Command.
//              [lParam] -- Account information dialog ptr on WM_INITDIALOG.
//
//  Returns:    TRUE  -- Message processed by this dialog.
//              FALSE -- Message not processed (WM_INITDIALOG excepted).
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
INT_PTR APIENTRY
SetAccountInformationDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                             LPARAM lParam)
{
    static AccountInfo * pai                      = NULL;
    TCHAR  tszAccountName[MAX_USERNAME + 1]       = TEXT("");
    TCHAR  tszPassword[MAX_PASSWORD + 1]          = TEXT("");
    TCHAR  tszConfirmedPassword[MAX_PASSWORD + 1] = TEXT("");
    DWORD  ccAccountName                          = MAX_USERNAME + 1;
    LPWSTR pwszPassword;

    switch (uMsg)
    {
    case WM_INITDIALOG:
        Win4Assert(lParam != NULL);
        pai = (AccountInfo *)lParam;
        Edit_LimitText(GetDlgItem(hDlg, edt_sa_passwd), MAX_USERNAME);
        Edit_LimitText(GetDlgItem(hDlg, edt_sa_passwd), MAX_PASSWORD);
        Edit_LimitText(GetDlgItem(hDlg, edt_sa_cfrmpasswd), MAX_PASSWORD);
        if (pai->pwszAccountName != NULL)
        {
            //
            //  Translate account prior to display, then display it
            //
            HRESULT hr = TranslateAccount(TRANSLATE_FOR_DISPLAY, pai->pwszAccountName, tszAccountName, ccAccountName);
            if (FAILED(hr))
            {
                StringCchCopy(tszAccountName, MAX_USERNAME + 1, pai->pwszAccountName);
            }
        }
        else
        {
            GetDefaultDomainAndUserName(tszAccountName, ccAccountName);
        }
        SetDlgItemText(hDlg, txt_sa_run_as, tszAccountName);
        I_SetDlgItemText(hDlg, edt_sa_passwd, pai->pwszPassword);
        I_SetDlgItemText(hDlg, edt_sa_cfrmpasswd, pai->pwszPassword);

        //
        // Center the dialog.
        //

        CenterDialog(hDlg);
        return TRUE; // TRUE == let windows set focus

    case WM_COMMAND:
        switch(LOWORD(wParam))
        {
        case IDOK:
            DWORD ccAccountName, ccPassword;
            tszAccountName[0] = _T('\0');

            ccAccountName = GetDlgItemText(hDlg, txt_sa_run_as,
                                           tszAccountName, MAX_USERNAME + 1);

            if (tszAccountName[0] != _T('\0'))
            {
                ccAccountName++;
                LPWSTR pwszAccountName = (LPWSTR)CoTaskMemAlloc(
                                     ccAccountName * sizeof(WCHAR));

                if (pwszAccountName != NULL)
                {
                    StringCchCopy(pwszAccountName, ccAccountName, tszAccountName);

                    ccPassword = GetDlgItemText(hDlg, edt_sa_passwd,
                                                tszPassword,
                                                MAX_PASSWORD + 1);

                    GetDlgItemText(hDlg, edt_sa_cfrmpasswd,
                                   tszConfirmedPassword, MAX_PASSWORD + 1);

                    if (lstrcmp(tszPassword, tszConfirmedPassword) != 0)
                    {
                        //
                        // Passwords didn't match. Let the user know so he/she
                        // can correct it.
                        //

                        CoTaskMemFree(pwszAccountName);
                        SchedUIErrorDialog(hDlg, IERR_PASSWORD,
                                           (LPTSTR)NULL);
                        return(TRUE);
                    }
                    else
                    {
                        if (ccPassword)
                        {
                            //
                            // Non-NULL password.
                            //

                            ccPassword++;
                            pwszPassword = new WCHAR[ccPassword];

                            if (pwszPassword != NULL)
                            {
                                StringCchCopy(pwszPassword, ccPassword, tszPassword);
                                SecureZeroMemory(tszPassword, sizeof tszPassword);
                                SecureZeroMemory(tszConfirmedPassword, sizeof tszConfirmedPassword);
                            }
                            else
                            {
                                CoTaskMemFree(pwszAccountName);
                                SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                                   (LPTSTR)NULL);
                                EndDialog(hDlg, wParam);
                                return(TRUE);
                            }
                        }
                        else
                        {
                            //
                            // Clear the password.
                            //
                            pwszPassword = new WCHAR[1];
                            if (pwszPassword != NULL)
                            {
                                *pwszPassword = L'\0';
                            }
                            else
                            {
                                CoTaskMemFree(pwszAccountName);
                                SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY,
                                                   (LPTSTR)NULL);
                                EndDialog(hDlg, wParam);
                                return(TRUE);
                            }
                        }
                    }

                    if (pai->pwszAccountName != NULL)
                    {
                        CoTaskMemFree(pai->pwszAccountName);
                        pai->pwszAccountName = NULL;
                    }
                    if (pai->pwszPassword != NULL &&
                        pai->pwszPassword != tszEmpty)
                    {
                        ZERO_PASSWORD(pai->pwszPassword);
                        delete pai->pwszPassword;
                        pai->pwszPassword = NULL;
                    }

                    //
                    // Translate input account prior to saving, then save it
                    //
                    DWORD cchAccount = MAX_USERNAME + 1;
                    WCHAR wszAccount[MAX_USERNAME + 1] = L"";
                    HRESULT hr = TranslateAccount(TRANSLATE_FOR_INTERNAL, pwszAccountName, wszAccount, cchAccount, &pwszPassword);
                    if (SUCCEEDED(hr))
                    {
                        lstrcpynW(pwszAccountName, wszAccount, cchAccount);        // copy translated name back into original buffer which will evenutally be CoTaskMemFree'd
                        pai->pwszAccountName = pwszAccountName;
                        pai->pwszPassword    = pwszPassword;
                    }
                    else
                    {
                        CoTaskMemFree(pwszAccountName);
                        SchedUIErrorDialog(hDlg, IERR_INTERNAL_ERROR, (LPTSTR)NULL);
                        EndDialog(hDlg, wParam);
                        return(TRUE);
                    }
                }
                else
                {
                    SchedUIErrorDialog(hDlg, IERR_OUT_OF_MEMORY, (LPTSTR)NULL);
                    EndDialog(hDlg, wParam);
                    return(TRUE);
                }
            }
            else
            {
                //
                // User cannot specify an empty account name.
                //

                SchedUIErrorDialog(hDlg, IERR_ACCOUNTNAME, (LPTSTR)NULL);
                return(TRUE);
            }

        case IDCANCEL:
            EndDialog(hDlg, wParam);
            return TRUE;
        }

    default:
        return FALSE;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CenterDialog
//
//  Synopsis:   Helper to center a dialog on screen.
//
//  Arguments:  [hDlg]   -- Dialog handle.
//
//  Returns:    None.
//
//  Notes:      None.
//
//----------------------------------------------------------------------------
void
CenterDialog(HWND hDlg)
{
    RECT rc;
    GetWindowRect(hDlg, &rc);

    SetWindowPos(hDlg,
                 NULL,
                 ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2),
                 ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2),
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SchedGetDlgItemTextLength
//
//  Synopsis:   Implements a GetDlgItemTextLength function since Win32 lacks it
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------
int
SchedGetDlgItemTextLength(
    HWND hwnd,
    int id)
{
    if ((hwnd = GetDlgItem(hwnd, id)) != NULL)
    {
        return GetWindowTextLength(hwnd);
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\jobpages.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       jobpages.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/5/1996   RaviR   Created
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "defines.h"
#include "..\inc\resource.h"
#include "..\inc\common.hxx"
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\folderui\util.hxx"
#include "..\rc.h"
#include "shared.hxx"
#include "schedui.hxx"

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

//void LogIt(WCHAR* pLine)
//{
//    FILE* pFile;
//    pFile = fopen("C:\\hmh.log", "a+");
//
//    if (pFile)
//    {
//        fputws(pLine, pFile);
//        fflush(pFile);
//        fclose(pFile);
//    }
//}

//void LogFunnyString(WCHAR* pLine, UINT count)
//{
//    FILE* pFile;
//    pFile = fopen("C:\\hmh.log", "a+");
//
//    if (pFile)
//    {
//        fputws(L"Funny file name:\n\t",pFile);
//        for(UINT i = 0; i < count; i++)
//            fputwc(pLine[i], pFile);
//        fputws(L"\n",pFile);
//
//        fflush(pFile);
//        fclose(pFile);
//    }
//}


//
//  extern EXTERN_C
//

extern HINSTANCE g_hInstance;

//
//  Local constants
//

TCHAR const FAR c_szNULL[] = TEXT("");
TCHAR const FAR c_szStubWindowClass[] = TEXT("JobPropWnd");

#define STUBM_SETDATA   (WM_USER + 1)
#define STUBM_GETDATA   (WM_USER + 2)

#define JF_PROPSHEET_STUB_CLASS 78345

LRESULT
CALLBACK
StubWndProc(
    HWND    hWnd,
    UINT    iMessage,
    WPARAM  wParam,
    LPARAM  lParam)
{
    switch(iMessage)
    {
    case STUBM_SETDATA:
        SetWindowLongPtr(hWnd, 0, wParam);
        return TRUE;

    case STUBM_GETDATA:
        return GetWindowLongPtr(hWnd, 0);

    default:
        return DefWindowProc(hWnd, iMessage, wParam, lParam);
    }
}




HWND I_CreateStubWindow(void)
{
    WNDCLASS wndclass;

    if (!GetClassInfo(g_hInstance, c_szStubWindowClass, &wndclass))
    {
        wndclass.style         = 0;
        wndclass.lpfnWndProc   = StubWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = sizeof(PVOID) * 2;
        wndclass.hInstance     = g_hInstance;
        wndclass.hIcon         = NULL;
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = c_szStubWindowClass;

        if (!RegisterClass(&wndclass))
            return NULL;
    }

    return CreateWindowEx(WS_EX_TOOLWINDOW, c_szStubWindowClass, c_szNULL,
                      WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
                      NULL, NULL, g_hInstance, NULL);
}


HANDLE
StuffStubWindow(
    HWND    hwnd,
    LPTSTR  pszFile)
{
    DWORD   dwProcId;
    HANDLE  hSharedFile;
    UINT    uiFileSize;

    uiFileSize = (lstrlen(pszFile) + 1) * sizeof(TCHAR);

    GetWindowThreadProcessId(hwnd, &dwProcId);

    hSharedFile = SCHEDAllocShared(NULL, sizeof(int)+uiFileSize, dwProcId);

    if (hSharedFile)
    {
        LPBYTE lpb = (LPBYTE)SCHEDLockShared(hSharedFile, dwProcId);

        if (lpb)
        {
            *(int *)lpb = JF_PROPSHEET_STUB_CLASS;
            CopyMemory(lpb+sizeof(int), pszFile, uiFileSize);
            SCHEDUnlockShared(lpb);
            SendMessage(hwnd, STUBM_SETDATA, (WPARAM)hSharedFile, 0);
            return hSharedFile;
        }
        SCHEDFreeShared(hSharedFile, dwProcId);
    }

    return NULL;
}


HWND
FindOtherStub(
    LPTSTR pszFile)
{
    HWND hwnd;

    //
    // BUGBUG using getwindow in a loop is not safe.  this code should
    // use EnumWindows instead.  From win32 sdk:
    //
    // "[EnumWindows] is more reliable than calling the GetWindow function in
    // a loop. An application that calls GetWindow to perform this task risks
    // being caught in an infinite loop or referencing a handle to a window
    // that has been destroyed."
    //

    for (hwnd = FindWindow(c_szStubWindowClass, NULL);
         hwnd != NULL;
         hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        TCHAR szClass[80];

        // find stub windows only
        GetClassName(hwnd, szClass, ARRAYSIZE(szClass));

        if (lstrcmpi(szClass, c_szStubWindowClass) == 0)
        {
            int     iClass;
            HANDLE  hSharedFile;
            DWORD   dwProcId;
            LPTSTR  pszTemp;

            GetWindowThreadProcessId(hwnd, &dwProcId);

            hSharedFile = (HANDLE)SendMessage(hwnd, STUBM_GETDATA, 0, 0);

            if (hSharedFile)
            {
                LPBYTE lpb;

                lpb = (LPBYTE)SCHEDLockShared(hSharedFile, dwProcId);
                pszTemp = (LPTSTR) (lpb + sizeof(int));

                if (lpb)
                {
                    iClass = *(int *)lpb;

                    if (iClass == JF_PROPSHEET_STUB_CLASS &&
                        lstrcmpi(pszTemp, pszFile) == 0)
                    {
                        SCHEDUnlockShared(lpb);
                        return hwnd;
                    }

                    SCHEDUnlockShared(lpb);
                }
            }
        }
    }
    return NULL;
}



STDMETHODIMP
I_GetTaskPage(
    ITask             * pIJob,
    TASKPAGE            tpType,
    BOOL                fPersistChanges,
    HPROPSHEETPAGE    * phPage)
{
    TRACE_FUNCTION(I_GetTaskPage);

    HRESULT     hr = S_OK;
    LPOLESTR    polestr = NULL;

    do
    {
        //
        //  Ensure that the object has a file name.
        //

        IPersistFile  * ppf = NULL;

        hr = pIJob->QueryInterface(IID_IPersistFile, (void **)&ppf);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = ppf->GetCurFile(&polestr);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        ppf->Release();

        if (hr == S_FALSE)
        {
            hr = STG_E_NOTFILEBASEDSTORAGE;

            CHECK_HRESULT(hr);
            break;
        }

        //
        // Establish if this task exists within a task's folder.
        //

        LPTSTR ptszJobPath;
        ptszJobPath = polestr;
        if (ptszJobPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        //
        //  Get the page
        //

        switch (tpType)
        {
        case TASKPAGE_TASK:
        {
            hr = GetGeneralPage(pIJob, ptszJobPath, fPersistChanges, phPage);
            CHECK_HRESULT(hr);
            break;
        }
        case TASKPAGE_SCHEDULE:
            hr = GetSchedulePage(pIJob, ptszJobPath, fPersistChanges, phPage);
            CHECK_HRESULT(hr);
            break;

        case TASKPAGE_SETTINGS:
            hr = GetSettingsPage(pIJob, ptszJobPath, fPersistChanges, phPage);
            CHECK_HRESULT(hr);
            break;

        default:
            hr = E_INVALIDARG;
            CHECK_HRESULT(hr);
            break;
        }

    } while (0);

    if (polestr != NULL)
    {
        CoTaskMemFree(polestr);
    }

    return hr;
}


HRESULT
DisplayJobProperties(
    LPDATAOBJECT    pdtobj)
{
    TRACE_FUNCTION(DisplayJobProperties);

    HRESULT     hr = S_OK;
    HANDLE      hSharedFile = NULL;
    HWND        hwnd = NULL;
    ITask     * pIJob = NULL;

    do
    {
        //
        //  Extract the job name from the data object.
        //

        STGMEDIUM stgm;
        FORMATETC fmte = {CF_HDROP, (DVTARGETDEVICE *)NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

        hr = pdtobj->GetData(&fmte, &stgm);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        TCHAR szFile[MAX_PATH + 1];
        UINT  cchRet = DragQueryFile((HDROP)stgm.hGlobal, 0, szFile, MAX_PATH + 1);
        
        ReleaseStgMedium(&stgm);

        if (cchRet == 0)
        {
            return E_FAIL;
        }

        //
        //  See if the property page for this job is already being displayed.
        //

        if (NULL != (hwnd = FindOtherStub(szFile)))
        {
            SwitchToThisWindow(GetLastActivePopup(hwnd), TRUE);
            break;
        }
        else
        {
            hwnd = I_CreateStubWindow();
            hSharedFile = StuffStubWindow(hwnd, szFile);
        }

        //
        // Bind to the ITask interface.
        //

        hr = JFCreateAndLoadTask(NULL, szFile, &pIJob);
//        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
//        {
//            LogIt(L"Got a path not found error\n");
//            LogFunnyString(szFile, cchRet);
//        }
        
        // hack: sometimes we get a corrupted directory name
        //       let's see if we can't djinn up a proper name instead...
        if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND))
        {
            WCHAR* pFoundName = PathFindFileName(szFile);
            WCHAR trialPath[MAX_PATH +1];
            WCHAR* pTasksFolder;

            if (SUCCEEDED(GetTasksFolder(&pTasksFolder)))
            {
                StringCchCopy(trialPath, MAX_PATH +1, pTasksFolder);
                StringCchCat(trialPath, MAX_PATH +1, L"\\");
                StringCchCat(trialPath, MAX_PATH +1, pFoundName);

                if (SUCCEEDED(hr = JFCreateAndLoadTask(NULL, trialPath, &pIJob)))
                    StringCchCopy(szFile, MAX_PATH +1, trialPath);

                delete[] pTasksFolder;
            }
        }

        BREAK_ON_FAIL(hr);

        LPTSTR pName = PathFindFileName(szFile);
        LPTSTR pExt  = PathFindExtension(pName);

        if (pExt)
        {
            *pExt = TEXT('\0');
        }

        //
        //  Add the pages.
        //

        HPROPSHEETPAGE ahpage[MAX_PROP_PAGES];
        PROPSHEETHEADER psh;

        SecureZeroMemory(&psh, sizeof(psh));

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = hwnd;
        psh.hInstance = g_hInstance;
        psh.pszCaption = pName;
        psh.phpage = ahpage;

        hr = AddGeneralPage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSchedulePage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSettingsPage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSecurityPage(psh, pdtobj);
        CHECK_HRESULT(hr);

        if (psh.nPages == 0)
        {
            DEBUG_OUT((DEB_USER1, "No pages to display.\n"));
            hr = E_FAIL;
            break;
        }

        PropertySheet(&psh);

    } while (0);

    if (pIJob != NULL)
    {
        pIJob->Release();
    }

    SCHEDFreeShared(hSharedFile, GetCurrentProcessId());

    if (hwnd)
    {
        DestroyWindow(hwnd);
    }

    return hr;
}


HRESULT
DisplayJobProperties(
    LPTSTR      pszJob,
    ITask     * pIJob)
{
    Win4Assert(pszJob != NULL);
    Win4Assert(pIJob != NULL);

    HRESULT         hr = S_OK;
    PROPSHEETHEADER psh;

    SecureZeroMemory(&psh, sizeof(psh));

    do
    {
        //
        // Determine the job name.
        //

        TCHAR szName[MAX_PATH + 1];
        StringCchCopy(szName, MAX_PATH + 1, PathFindFileName(pszJob));

        LPTSTR pExt  = PathFindExtension(szName);

        if (pExt)
        {
            *pExt = TEXT('\0');
        }

        //
        //  Add the pages.
        //

        HPROPSHEETPAGE ahpage[MAX_PROP_PAGES];

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_DEFAULT;
        psh.hwndParent = I_CreateStubWindow();
        psh.hInstance = g_hInstance;
        psh.pszCaption = szName;
        psh.phpage = ahpage;


        hr = AddGeneralPage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSchedulePage(psh, pIJob);
        CHECK_HRESULT(hr);

        hr = AddSettingsPage(psh, pIJob);
        CHECK_HRESULT(hr);

        if (psh.nPages == 0)
        {
            DEBUG_OUT((DEB_USER1, "No pages to display.\n"));
            hr = E_FAIL;
            break;
        }

        PropertySheet(&psh);

    } while (0);

    if (psh.hwndParent)
    {
        DestroyWindow(psh.hwndParent);
    }

    return hr;
}




HRESULT
GetJobPath(
    ITask     * pIJob,
    LPTSTR    * ppszJobPath)
{
    HRESULT         hr = S_OK;
    LPOLESTR        polestr = NULL;
    IPersistFile  * ppf = NULL;

    do
    {
        //
        // Get the object name
        //

        hr = pIJob->QueryInterface(IID_IPersistFile, (void **)&ppf);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        hr = ppf->GetCurFile(&polestr);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        LPTSTR pszJobPath = NULL;
        pszJobPath = NewDupString(polestr);
        CoTaskMemFree(polestr);
        if (pszJobPath == NULL)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        *ppszJobPath = pszJobPath;

    } while (0);

    if (ppf != NULL)
    {
        ppf->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\security.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       security.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3/5/1996   RaviR   Created
//
//____________________________________________________________________________

#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"

#include "defines.h"
#include "schedui.hxx"


// {1F2E5C40-9550-11CE-99D2-00AA006E086C}
CLSID CLSID_RShellExt = {
    0x1F2E5C40,
    0x9550,
    0x11CE,
    { 0x99, 0xD2, 0x00, 0xAA, 0x00, 0x6E, 0x08, 0x6C }
};

//
//  This function is a callback function from property sheet page extensions.
//

BOOL CALLBACK
I_AddPropSheetPage(
    HPROPSHEETPAGE  hpage,
    LPARAM          lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *)lParam;

    if (ppsh->nPages < MAX_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;

        return TRUE;
    }

    return FALSE;
}



HRESULT
AddSecurityPage(
    PROPSHEETHEADER &psh,
    LPDATAOBJECT     pdtobj)
{
    TRACE_FUNCTION(AddSecurityPage);

    HRESULT     hr = S_OK;
    IShellPropSheetExt * pShellPropSheetExt = NULL;

    do
    {
        hr = CoCreateInstance(CLSID_RShellExt, NULL, CLSCTX_ALL,
                   IID_IShellPropSheetExt, (void **)&pShellPropSheetExt);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        IShellExtInit * pShExtInit = NULL;

        hr = pShellPropSheetExt->QueryInterface(IID_IShellExtInit,
                                                (void **)&pShExtInit);

        if (SUCCEEDED(hr))
        {
            hr = pShExtInit->Initialize(NULL, pdtobj, NULL);

            CHECK_HRESULT(hr);

            pShExtInit->Release();

            if (SUCCEEDED(hr))
            {
                hr = pShellPropSheetExt->AddPages(I_AddPropSheetPage,
                                                        (LPARAM)&psh);
                CHECK_HRESULT(hr);
            }
        }

    } while (0);

    if (pShellPropSheetExt)
    {
        pShellPropSheetExt->Release();
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\services\sched\schedui\schedule.cxx ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       schedule.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  Notes:      For the first release of the scheduling agent, all security
//              operations are disabled under Win95, even Win95 to NT.
//
//  History:    3/4/1996   RaviR   Created
//				11/16/00   DGrube	removed Win4Assert(m_indexCbxTriggers >= 0);
//						   since m_indexCbxTriggers is a DWORD (unsigned) causing
//							compiler errors.
//
//____________________________________________________________________________


#include "..\pch\headers.hxx"
#pragma hdrstop

#include <mstask.h>
#include <winuserp.h>
#include "..\folderui\dbg.h"
#include "..\folderui\macros.h"
#include "..\folderui\jobicons.hxx"
#include "..\folderui\util.hxx"
#include "..\inc\resource.h"
#include "..\inc\network.hxx"
#include "..\inc\dll.hxx"

#include "dlg.hxx"
#include "rc.h"
#include "defines.h"
#include <mstask.h>
#include "misc.hxx"
#include "uiutil.hxx"
#include "strings.hxx"
#include "cdlist.hxx"
#include "helpids.h"
#include "iconhlpr.hxx"
#include "schedui.hxx"
#include "selmonth.hxx"
#include "defines.hxx"
#include <StrSafe.h>

BOOL
IsValidMonthlyDateTrigger(
    PTASK_TRIGGER pTrigger);


typedef const unsigned char *LPCBYTE;

//#undef DEB_TRACE
//#define DEB_TRACE DEB_USER1


//
//  (Control id, help id) list for context sensitivity help.
//

ULONG s_aSchedulePageHelpIds[] =
{
// Helpids for Schedule page controls (common to all triggers)
    idc_icon,                   Hidc_icon,
    cbx_trigger_type,           Hcbx_trigger_type,
    dp_start_time,              Hdp_start_time,
    cbx_triggers,               Hcbx_triggers,
    txt_trigger,                Htxt_trigger,
    btn_new,                    Hbtn_new,
    btn_delete,                 Hbtn_delete,
    btn_advanced,               Hbtn_advanced,
    grp_schedule,               Hgrp_schedule,
    chk_show_multiple_scheds,   Hchk_show_multiple_scheds,

// Helpids for Schedule page controls for DAILY trigger
    grp_daily,                  Hgrp_daily,
    daily_lbl_every,            Hdaily_lbl_every,
    daily_txt_every,            Hdaily_txt_every,
    daily_spin_every,           Hdaily_spin_every,
    daily_lbl_days,             Hdaily_lbl_days,

// Helpids for Schedule page controls for WEEKLY trigger
    grp_weekly,                 Hgrp_weekly,
    weekly_lbl_every,           Hweekly_lbl_every,
    weekly_txt_every,           Hweekly_txt_every,
    weekly_spin_every,          Hweekly_spin_every,
    weekly_lbl_weeks_on,        Hweekly_lbl_weeks_on,
    chk_mon,                    Hchk_mon,
    chk_tue,                    Hchk_tue,
    chk_wed,                    Hchk_wed,
    chk_thu,                    Hchk_thu,
    chk_fri,                    Hchk_fri,
    chk_sat,                    Hchk_sat,
    chk_sun,                    Hchk_sun,

// Helpids for Schedule page controls for MONTHLY trigger
    grp_monthly,                Hgrp_monthly,
    md_rb,                      Hmd_rb,
    md_txt,                     Hmd_txt,
    md_spin,                    Hmd_spin,
    md_lbl,                     Hmd_lbl,
    dow_rb,                     Hdow_rb,
    dow_cbx_week,               Hdow_cbx_week,
    dow_cbx_day,                Hdow_cbx_day,
    dow_lbl,                    Hdow_lbl,
    btn_sel_months,             Hbtn_sel_months,

// Helpids for Schedule page controls for ONCE only trigger
    grp_once,                   Hgrp_once,
    once_lbl_run_on,            Honce_lbl_run_on,
    once_dp_date,               Honce_dp_date,

// Helpids for Schedule page controls for WhenIdle trigger
    grp_idle,                   Hgrp_idle,
    sch_txt_idle_min,           Hsch_txt_idle_min,
    idle_lbl_when,              Hidle_lbl_when,
    sch_spin_idle_min,          Hsch_spin_idle_min,
    idle_lbl_mins,              Hidle_lbl_mins,

    0,0
};

//
// Local constants
//
// DEFAULT_TIME_FORMAT - what to use if there's a problem getting format
//                       from system.
//

#define DEFAULT_TIME_FORMAT         TEXT("hh:mm tt")

//
//  extern
//

extern "C" TCHAR szMstaskHelp[];
extern HINSTANCE g_hInstance;


//+----------------------------------------------------------------------
//
// Class:   CJobTrigger
//
// Purpose: TASK_TRIGGER structure encapsulated with double link node.
//
//----------------------------------------------------------------------

class CJobTrigger : public CDLink
{
public:
    CJobTrigger(TASK_TRIGGER &jt) : m_jt(jt) {}
    virtual ~CJobTrigger() {}

    LPTSTR TriggerString(BOOL fPrependID, TCHAR tcBuff[], size_t bufSize);

    WORD GetTriggerID(void) { return (m_jt.Reserved1 & 0x7fff); }
    void SetTriggerID(WORD wID)
            { m_jt.Reserved1 = (m_jt.Reserved1 & 0x8000) | wID; }

    void DirtyTrigger() { m_jt.Reserved1 |= 0x8000; }
    BOOL IsTriggerDirty() { return (m_jt.Reserved1 & 0x8000) ? TRUE : FALSE; }

    CJobTrigger *Prev() { return (CJobTrigger*) CDLink::Prev(); }
    CJobTrigger *Next() { return (CJobTrigger*) CDLink::Next(); }

    TASK_TRIGGER m_jt;
};



//+----------------------------------------------------------------------
//
// Class:   CJobTriggerList
//
// Purpose: A double linked list of CJobTriggers
//
//----------------------------------------------------------------------

DECLARE_DOUBLE_LINK_LIST_CLASS(CJobTrigger)



LPTSTR
CJobTrigger::TriggerString(
    BOOL  fPrependID,
    TCHAR tcBuff[],
    size_t bufSize)
{
    LPWSTR  pwsz = NULL;
    HRESULT hr = StringFromTrigger((const PTASK_TRIGGER)&m_jt, &pwsz, NULL);

    CHECK_HRESULT(hr);

    tcBuff[0] = TEXT('\0');

    if (SUCCEEDED(hr))
    {
        if (fPrependID == TRUE)
        {
            StringCchPrintf(tcBuff, bufSize, TEXT("%d. "), (this->GetTriggerID() + 1));
        }

        StringCchCat(tcBuff, bufSize, pwsz);

        CoTaskMemFree(pwsz);
    }

    return tcBuff;
}

//____________________________________________________________________________
//____________________________________________________________________________
//________________                      ______________________________________
//________________  class CSchedulePage ______________________________________
//________________                      ______________________________________
//____________________________________________________________________________
//____________________________________________________________________________


class CSchedulePage : public CPropPage
{
public:

    CSchedulePage(ITask * pIJob,
                  LPTSTR  ptszTaskPath,
                  BOOL    fMultipleTriggers,
                  BOOL    fPersistChanges);

    ~CSchedulePage();

private:

    enum
    {
        IDT_UPDATE_TRIGGER_STRING = 1
    };

    virtual LRESULT _OnInitDialog(LPARAM lParam);
    virtual LRESULT _OnCommand(int id, HWND hwndCtl, UINT codeNotify);
    virtual LRESULT _OnApply(void);
    virtual LRESULT _OnPSMQuerySibling(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnDestroy(void);
    virtual LRESULT _OnTimer(UINT idTimer);
    virtual LRESULT _OnSpinDeltaPos(NM_UPDOWN * pnmud);
    virtual LRESULT _OnWinIniChange(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnPSNSetActive(LPARAM lParam);
    virtual LRESULT _OnPSNKillActive(LPARAM lParam);
    virtual LRESULT _OnDateTimeChange(LPARAM lParam);
    virtual LRESULT _OnHelp(HANDLE hRequesting, UINT uiHelpCommand);

    void    _ShowControls(int index, int nCmdShow);
    void    _UpdateTriggerString(void);
    HRESULT _LoadTriggers(void);
    BOOL    _LoadTriggerStrings(void);
    BOOL    _InitPage(void);
    BOOL    _RefreshPage(void);
    void    _UpdateDailyControls(void);
    void    _UpdateWeeklyControls(void);
    void    _UpdateMonthlyControls(void);
    void    _CheckMonthlyRadio(TASK_TRIGGER_TYPE TriggerType);
    void    _UpdateOnceOnlyControls(void);
    void    _UpdateIdleControls(void);
    WORD    _GetDayFromRgfDays(DWORD rgfDays);
    int     _GetTriggerTypeIndex(void);
    void    _DisplayControls(int indexTrigger);
    void    _EnableTimeTriggerSpecificCtrls(BOOL fEnable);
    void    _SaveTriggerSettings(void);
    void    _ShowTriggerStringDispCtrls(void);
    void    _CreateTimerToUpdateTriggerStr(void);
    void    _DeleteTimerToUpdateTriggerStr(void);

    void    _ErrorDialog(int idsErr, LONG error = 0, UINT idsHelpHint = 0)
                { SchedUIErrorDialog(Hwnd(), idsErr, error, idsHelpHint); }

    BOOL    _PerformSanityChkOnCurrTrigger(void);

    void _EnableApplyButton(void);

    void _DisableUI(void);

    ITask         * m_pIJob;

    //
    //  icon helper
    //

    CIconHelper   * m_pIconHelper;

    //
    //  The list of triggers
    //

    CJobTriggerList m_cjtList;

    //
    //  The list of triggers deleted
    //

    CJobTriggerList m_cjtDeletedList;

    //
    //  The trigger for which the schedule is being displayed currently
    //

    CJobTrigger   * m_pcjtCurr;

    //
    //  The count of triggers at load time
    //

    WORD            m_cTriggersPrev;

    //
    //  The id to be assigned to the next trigger, when the user pushes
    //  the 'New' button for a multiple triggers schedule.
    //

    WORD            m_wNextTriggerId;

    //
    //  The current selection for the trigger type combo box.
    //

    int             m_indexCbxTriggerType;

    //
    //  The timer id of the timer used for trigger string update.
    //

    UINT_PTR        m_idTimer;

    //
    //  The current selection for the trigger strings combo box.
    //

    UINT            m_indexCbxTriggers;

    //
    //  Used by Set/KillActive
    //

    BOOL            m_fShowingMultiSchedsOnKillActive;

    BOOL            m_fShowMultiScheds;

    //
    //  Should we save on Apply or OK.
    //

    BOOL            m_fPersistChanges;

    //
    // Is this an AT job?
    //
    BOOL            m_fNetScheduleJob;

    //
    // Time format string for use with Date picker control
    //

    TCHAR           m_tszTimeFormat[MAX_DP_TIME_FORMAT];

    //
    // Selected months dialog
    //

    CSelectMonth    _SelectMonths;

    //
    // If one of the trigger comboboxes is dropped down, contains the
    // index of the item selected when the user dropped down the list.
    // Otherwise, contains -1.
    //
    // CAUTION: The _OnTimer method looks at this variable to determine
    // whether it is safe to ask the trigger controls for their values
    // and update the trigger string and settings.  If it has anything
    // other than -1, one of the comboboxes may not have a valid
    // selection.
    //

    static int      s_iCbx;

}; // class CSchedulePage

//
// CSchedulePage static.  Although it's possible multiple instances
// of the schedule page are running, only one can have the focus, therefore
// only one can be using s_iCbx at a time.
//

int CSchedulePage::s_iCbx = -1;

inline
CSchedulePage::CSchedulePage(
    ITask * pIJob,
    LPTSTR  ptszTaskPath,
    BOOL    fMultipleTriggers,
    BOOL    fPersistChanges)
        :
        m_pIJob(pIJob),
        m_pIconHelper(NULL),
        m_fShowMultiScheds(fMultipleTriggers),
        m_fPersistChanges(fPersistChanges),
        m_fNetScheduleJob(FALSE),
        m_cjtList(),
        m_cjtDeletedList(),
        m_pcjtCurr(NULL),
        m_cTriggersPrev(0),
        m_wNextTriggerId(0),
        m_indexCbxTriggerType(-1),
        m_indexCbxTriggers(0),
        m_idTimer(0),
        CPropPage(MAKEINTRESOURCE(schedule_page), ptszTaskPath)
{
    TRACE(CSchedulePage, CSchedulePage);

    Win4Assert(m_pIJob != NULL);

    m_pIJob->AddRef();

    m_fShowingMultiSchedsOnKillActive = m_fShowMultiScheds;
}


inline
CSchedulePage::~CSchedulePage()
{
    TRACE(CSchedulePage, ~CSchedulePage);

    if (m_pIconHelper != NULL)
    {
        m_pIconHelper->Release();
    }

    if (m_pIJob != NULL)
    {
        m_pIJob->Release();
    }
}


LRESULT
CSchedulePage::_OnHelp(
    HANDLE hRequesting,
    UINT uiHelpCommand)
{
    WinHelp((HWND)hRequesting,
            szMstaskHelp,
            uiHelpCommand,
            (DWORD_PTR)(LPSTR)s_aSchedulePageHelpIds);
    return TRUE;
}

void
CSchedulePage::_EnableApplyButton(void)
{
    if (m_pcjtCurr)
    {
        m_pcjtCurr->DirtyTrigger();
    }

    CPropPage::_EnableApplyButton();
}


inline
void
CSchedulePage::_CreateTimerToUpdateTriggerStr(void)
{
    if (m_idTimer == 0)
    {
        m_idTimer = SetTimer(Hwnd(), IDT_UPDATE_TRIGGER_STRING, 1500, NULL);
        DEBUG_OUT((DEB_USER12, "Created timer (%d)\n", m_idTimer));
    }
}


inline
void
CSchedulePage::_DeleteTimerToUpdateTriggerStr(void)
{
    if (m_idTimer != 0)
    {
        KillTimer(Hwnd(), IDT_UPDATE_TRIGGER_STRING);
        m_idTimer = 0;
    }
}


void
CSchedulePage::_EnableTimeTriggerSpecificCtrls(BOOL fEnable)
{
    HWND hwnd;

    if (fEnable == TRUE)
    {
        if (hwnd = _hCtrl(dp_start_time)) DateTime_SetFormat(hwnd, m_tszTimeFormat);
    }
    else
    {
        if (hwnd = _hCtrl(dp_start_time)) DateTime_SetFormat(hwnd, tszBlank);
    }

    if (hwnd = _hCtrl(dp_start_time)) EnableWindow(hwnd, fEnable);
    if (hwnd = _hCtrl(btn_advanced)) EnableWindow(hwnd, fEnable);
}



int aCtrlsDaily[] = {
    grp_daily,
    daily_lbl_every, daily_txt_every, daily_spin_every,
    daily_lbl_days
};

int aCtrlsWeekly[] = {
    grp_weekly,
    weekly_lbl_every, weekly_txt_every, weekly_spin_every,
    weekly_lbl_weeks_on,
        chk_mon, chk_tue, chk_wed, chk_thu, chk_fri, chk_sat, chk_sun
};

int aCtrlsMonthly[] = {
    grp_monthly,
    md_rb, md_txt, md_spin, md_lbl,         // md => monthly date
    dow_rb,  dow_cbx_week, dow_cbx_day, dow_lbl,   // dow => day of week
    btn_sel_months
};

int aCtrlsOnce[] = {
    grp_once,
    once_lbl_run_on, once_dp_date
};

int aCtrlsIdle[] = {
    grp_idle,
    idle_lbl_when,
    sch_txt_idle_min, sch_spin_idle_min,
    idle_lbl_mins
};


typedef struct _STriggerTypeData
{
    int                 ids;
    int               * pCtrls;
    int                 cCtrls;
} STriggerTypeData;

STriggerTypeData ttd[] = {
  {IDS_DAILY,       aCtrlsDaily,    ARRAYLEN(aCtrlsDaily)},
  {IDS_WEEKLY,      aCtrlsWeekly,   ARRAYLEN(aCtrlsWeekly)},
  {IDS_MONTHLY,     aCtrlsMonthly,  ARRAYLEN(aCtrlsMonthly)},
  {IDS_ONCE,        aCtrlsOnce,     ARRAYLEN(aCtrlsOnce)},
  {IDS_AT_STARTUP,  NULL,           0},
  {IDS_AT_LOGON,    NULL,           0},
  {IDS_WHEN_IDLE,   aCtrlsIdle,     ARRAYLEN(aCtrlsIdle)}
};

const int INDEX_DAILY = 0;
const int INDEX_WEEKLY = 1;
const int INDEX_MONTHLY = 2;
const int INDEX_ONCE = 3;
const int INDEX_STARTUP = 4;
const int INDEX_LOGON = 5;
const int INDEX_IDLE = 6;


inline
void
CSchedulePage::_ShowControls(
    int index,
    int nCmdShow)
{
    int cCtrls = ttd[index].cCtrls;

    for (int i=0; i < cCtrls; i++)
    {
        ShowWindow(GetDlgItem(Hwnd(), ttd[index].pCtrls[i]), nCmdShow);
    }
}



SWeekData g_aWeekData[] =
{
    {IDS_FIRST,     TASK_FIRST_WEEK},
    {IDS_SECOND,    TASK_SECOND_WEEK},
    {IDS_THIRD,     TASK_THIRD_WEEK},
    {IDS_FORTH,     TASK_FOURTH_WEEK},
    {IDS_LAST,      TASK_LAST_WEEK}
};

SDayData g_aDayData[] =
{
    {chk_mon,   IDS_MONDAY,     TASK_MONDAY},
    {chk_tue,   IDS_TUESDAY,    TASK_TUESDAY},
    {chk_wed,   IDS_WEDNESDAY,  TASK_WEDNESDAY},
    {chk_thu,   IDS_THURSDAY,   TASK_THURSDAY},
    {chk_fri,   IDS_FRIDAY,     TASK_FRIDAY},
    {chk_sat,   IDS_SATURDAY,   TASK_SATURDAY},
    {chk_sun,   IDS_SUNDAY,     TASK_SUNDAY}
};


void
CSchedulePage::_ShowTriggerStringDispCtrls(void)
{
    TRACE(CSchedulePage, _ShowTriggerStringDispCtrls);
    HWND hwnd;

    if (m_fShowMultiScheds == TRUE)
    {
        if (hwnd = _hCtrl(txt_trigger)) ShowWindow(hwnd, SW_HIDE);
        if (hwnd = _hCtrl(idc_icon)) ShowWindow(hwnd, SW_HIDE);

        if (hwnd = _hCtrl(cbx_triggers)) ShowWindow(hwnd, SW_SHOWNA);
        if (hwnd = _hCtrl(btn_new)) ShowWindow(hwnd, SW_SHOWNA);
        if (hwnd = _hCtrl(btn_delete)) ShowWindow(hwnd, SW_SHOWNA);

        if (hwnd = _hCtrl(btn_new)) EnableWindow(hwnd, TRUE);

        // Handle the case where you open the page for the first time
        // and there is not a trigger on the job.

        if (hwnd = _hCtrl(btn_delete)) EnableWindow(hwnd, (m_pcjtCurr) ? TRUE : FALSE);
    }
    else
    {
        if (hwnd = _hCtrl(cbx_triggers)) ShowWindow(hwnd, SW_HIDE);
        if (hwnd = _hCtrl(btn_new)) ShowWindow(hwnd, SW_HIDE);
        if (hwnd = _hCtrl(btn_delete)) ShowWindow(hwnd, SW_HIDE);

        if (hwnd = _hCtrl(txt_trigger)) ShowWindow(hwnd, SW_SHOWNA);
        if (hwnd = _hCtrl(idc_icon)) ShowWindow(hwnd, SW_SHOWNA);

        if (hwnd = _hCtrl(btn_new)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(btn_delete)) EnableWindow(hwnd, FALSE);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   MoveControlGroup
//
//  Synopsis:   Move the controls with ids in [aidControls] left by
//              [xOffset] pixels.
//
//  Arguments:  [hdlg]        - window handle of dialog containing controls
//              [aidControls] - array of ids of controls to move
//              [cControls]   - number of elements in array
//              [xOffset]     - distance, in pixels, to move controls left
//
//  History:    08-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
MoveControlGroup(
    HWND hdlg,
    int aidControls[],
    ULONG cControls,
    long xOffset)
{
    ULONG   i;
    BOOL    fOk;

    for (i = 0; i < cControls; i++)
    {
        HWND hwnd = GetDlgItem(hdlg, aidControls[i]);
        Win4Assert(hwnd);

        RECT rc;
        BOOL fOk = GetWindowRect(hwnd, &rc);
        Win4Assert(fOk);

        fOk = MapWindowPoints(NULL, hdlg, (LPPOINT) &rc, 2);
        Win4Assert(fOk);

        fOk = SetWindowPos(hwnd,
                           NULL,
                           rc.left - xOffset,
                           rc.top,
                           0,
                           0,
                           SWP_NOACTIVATE       |
                            SWP_NOCOPYBITS      |
                            SWP_NOOWNERZORDER   |
                            SWP_NOREDRAW        |
                            SWP_NOSENDCHANGING  |
                            SWP_NOSIZE          |
                            SWP_NOZORDER);
        Win4Assert(fOk);
    }
}


#define TRIGGER_OFFSET      250

LRESULT
CSchedulePage::_OnInitDialog(
    LPARAM lParam)
{
    TRACE(CSchedulePage, _OnInitDialog);

    HRESULT     hr = S_OK;

    do
    {
        //
        // Move the trigger settings for weekly, monthly, once, and idle over
        // to the left.  Each is offset by a multiple of TRIGGER_OFFSET DLUs.
        // this is done because the dialog template maps out the various 
        // control groups side-by-side to make editing easier
        // however, they must be moved into the dialog box so the user can see them!
        //

        /***************************
        
        This "should" work - but is having troubles on some localized builds
        we'll measure rather than calculate....

        RECT rc = { 0, 0, TRIGGER_OFFSET - 1, 1 };
        BOOL fOk = MapDialogRect(Hwnd(), &rc);
        Win4Assert(fOk);
        long xOffset = rc.right;

        MoveControlGroup(Hwnd(), aCtrlsWeekly,  ARRAYLEN(aCtrlsWeekly),  1 * xOffset);
        MoveControlGroup(Hwnd(), aCtrlsMonthly, ARRAYLEN(aCtrlsMonthly), 2 * xOffset);
        MoveControlGroup(Hwnd(), aCtrlsOnce,    ARRAYLEN(aCtrlsOnce),    3 * xOffset);
        MoveControlGroup(Hwnd(), aCtrlsIdle,    ARRAYLEN(aCtrlsIdle),    4 * xOffset);
        **********************************/
        
        // determine coordinates of the 'default' groupbox (Daily)
        // then, for each of the control groups, calc the proper offset.
        // and move controls accordingly
        RECT defaultRect, controlRect;

        GetWindowRect(GetDlgItem(Hwnd(), grp_daily), &defaultRect);

        GetWindowRect(GetDlgItem(Hwnd(), grp_weekly), &controlRect);
        long xOffset = abs(controlRect.left - defaultRect.left);
        MoveControlGroup(Hwnd(), aCtrlsWeekly,  ARRAYLEN(aCtrlsWeekly),  xOffset);

        GetWindowRect(GetDlgItem(Hwnd(), grp_monthly), &controlRect);
        xOffset = abs(controlRect.left - defaultRect.left);
        MoveControlGroup(Hwnd(), aCtrlsMonthly,  ARRAYLEN(aCtrlsMonthly),  xOffset);
        
        GetWindowRect(GetDlgItem(Hwnd(), grp_once), &controlRect);
        xOffset = abs(controlRect.left - defaultRect.left);
        MoveControlGroup(Hwnd(), aCtrlsOnce,  ARRAYLEN(aCtrlsOnce),  xOffset);

        GetWindowRect(GetDlgItem(Hwnd(), grp_idle), &controlRect);
        xOffset = abs(controlRect.left - defaultRect.left);
        MoveControlGroup(Hwnd(), aCtrlsIdle,  ARRAYLEN(aCtrlsIdle),  xOffset);

        //
        // Initialize time format string m_tszTimeFormat
        //

        UpdateTimeFormat(m_tszTimeFormat, ARRAYLEN(m_tszTimeFormat));

        //
        // Get job flags
        //
        DWORD dwFlags;
        hr = m_pIJob->GetFlags(&dwFlags);
        m_fNetScheduleJob = dwFlags & JOB_I_FLAG_NET_SCHEDULE;

        //
        // See if the general page has already created the icon,
        // helper, if not create it here.
        //
        m_pIconHelper = (CIconHelper *)PropSheet_QuerySiblings(
                                GetParent(Hwnd()), GET_ICON_HELPER, 0);

        if (m_pIconHelper == NULL)
        {
            m_pIconHelper = new CIconHelper();

            if (m_pIconHelper == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }

            //
            // Get the application name and set the application icon.
            //

            LPWSTR pwszAppName = NULL;

            hr = m_pIJob->GetApplicationName(&pwszAppName);
            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);
            m_pIconHelper->SetAppIcon(pwszAppName);
            CoTaskMemFree(pwszAppName);

            //
            //  Compute the job icon
            //

            BOOL fEnabled = FALSE;

            if (this->IsTaskInTasksFolder())
            {
                fEnabled = (dwFlags & TASK_FLAG_DISABLED) ? FALSE : TRUE;
            }

            m_pIconHelper->SetJobIcon(fEnabled);
        }
        else
        {
            m_pIconHelper->AddRef();
        }

        hr = _LoadTriggers();

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        _InitPage();

        _RefreshPage();

        m_fDirty = FALSE;

    } while (0);

    //
    // Disable all controls if this is an AT job
    // to prevent user from making changes
    //
    if (m_fNetScheduleJob)
    	_DisableUI();

    if (FAILED(hr))
    {
        if (hr == E_OUTOFMEMORY)
        {
            _ErrorDialog(IERR_OUT_OF_MEMORY);
        }
        else
        {
            _ErrorDialog(IERR_SCHEDULE_PAGE_INIT, hr);
        }

        EnableWindow(Hwnd(), FALSE);

        return FALSE;
    }

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//	Member:		CSchedulePage::_DisableUI
//
//	Synopsis:	Disable UI so the user can only view the settings
//
//	History:	2001-11-13  ShBrown	Created
//
//---------------------------------------------------------------------------

void
CSchedulePage::_DisableUI(void)
{
    HWND hwnd;

    if (hwnd = _hCtrl(cbx_triggers)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(cbx_trigger_type)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(dp_start_time)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(daily_txt_every)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(daily_spin_every)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(weekly_txt_every)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(weekly_spin_every)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_mon)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_tue)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_wed)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_thu)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_fri)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_sat)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_sun)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(md_rb)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(dow_rb)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(md_txt)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(md_spin)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(dow_cbx_week)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(dow_cbx_day)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(once_dp_date)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(sch_txt_idle_min)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(sch_spin_idle_min)) EnableWindow(hwnd, FALSE);
	if (hwnd = _hCtrl(chk_show_multiple_scheds)) EnableWindow(hwnd, FALSE);

	if (hwnd = _hCtrl(btn_new)) 
    {
        EnableWindow(hwnd, FALSE);
	    ShowWindow(hwnd, SW_HIDE);
    }
	if (hwnd = _hCtrl(btn_delete)) 
    {
        EnableWindow(hwnd, FALSE);
	    ShowWindow(hwnd, SW_HIDE);
    }
	if (hwnd = _hCtrl(btn_advanced)) 
    {
        EnableWindow(hwnd, FALSE);
	    ShowWindow(hwnd, SW_HIDE);
    }
	if (hwnd = _hCtrl(btn_sel_months)) 
    {
        EnableWindow(hwnd, FALSE);
	    ShowWindow(hwnd, SW_HIDE);
    }
}


#define GET_LOCALE_INFO(lcid)                           \
        {                                               \
            cch = GetLocaleInfo(LOCALE_USER_DEFAULT,    \
                                (lcid),                 \
                                tszScratch,             \
                                ARRAYLEN(tszScratch));  \
            if (!cch)                                   \
            {                                           \
                DEBUG_OUT_LASTERROR;                    \
                break;                                  \
            }                                           \
        }

//+--------------------------------------------------------------------------
//
//  Function:   UpdateTimeFormat
//
//  Synopsis:   Construct a time format containing hour and minute for use
//              with the date picker control.
//
//  Arguments:  [tszTimeFormat] - buffer to fill with time format
//              [cchTimeFormat] - size in chars of buffer
//
//  Modifies:   *[tszTimeFormat]
//
//  History:    11-18-1996   DavidMun   Created
//
//  Notes:      This is called on initialization and for wininichange
//              processing.
//
//---------------------------------------------------------------------------

void
UpdateTimeFormat(
        LPTSTR tszTimeFormat,
        ULONG  cchTimeFormat)
{
    ULONG cch;
    TCHAR tszScratch[80];
    BOOL  fAmPm = FALSE;
    BOOL  fAmPmPrefixes = FALSE;
    BOOL  fLeadingZero = FALSE;

    do
    {
        GET_LOCALE_INFO(LOCALE_ITIME);
        fAmPm = (*tszScratch == TEXT('0'));

        if (fAmPm)
        {
            GET_LOCALE_INFO(LOCALE_ITIMEMARKPOSN);
            fAmPmPrefixes = (*tszScratch == TEXT('1'));
        }

        GET_LOCALE_INFO(LOCALE_ITLZERO);
        fLeadingZero = (*tszScratch == TEXT('1'));

        GET_LOCALE_INFO(LOCALE_STIME);

        //
        // See if there's enough room in destination string
        //

        cch = 1                     +  // terminating nul
              1                     +  // first hour digit specifier "h"
              2                     +  // minutes specifier "mm"
              (fLeadingZero != 0)   +  // leading hour digit specifier "h"
              lstrlen(tszScratch)   +  // separator string
              (fAmPm ? 3 : 0);         // space and "tt" for AM/PM

        if (cch > cchTimeFormat)
        {
            cch = 0; // signal error
        }
    } while (0);

    //
    // If there was a problem in getting locale info for building time string
    // just use the default and bail.
    //

    if (!cch)
    {
        StringCchCopy(tszTimeFormat, cchTimeFormat, DEFAULT_TIME_FORMAT);
        return;
    }

    //
    // Build a time string that has hours and minutes but no seconds.
    //

    tszTimeFormat[0] = TEXT('\0');

    if (fAmPm)
    {
        if (fAmPmPrefixes)
        {
            StringCchCopy(tszTimeFormat, cchTimeFormat, TEXT("tt "));
        }

        StringCchCat(tszTimeFormat, cchTimeFormat, TEXT("h"));

        if (fLeadingZero)
        {
            StringCchCat(tszTimeFormat, cchTimeFormat, TEXT("h"));
        }
    }
    else
    {
        StringCchCat(tszTimeFormat, cchTimeFormat, TEXT("H"));

        if (fLeadingZero)
        {
            StringCchCat(tszTimeFormat, cchTimeFormat, TEXT("H"));
        }
    }

    StringCchCat(tszTimeFormat, cchTimeFormat, tszScratch); // separator
    StringCchCat(tszTimeFormat, cchTimeFormat, TEXT("mm"));

    if (fAmPm && !fAmPmPrefixes)
    {
        StringCchCat(tszTimeFormat, cchTimeFormat, TEXT(" tt"));
    }
}


HRESULT
CSchedulePage::_LoadTriggers(void)
{
    TRACE(CSchedulePage, _LoadTriggers);

    HRESULT      hr = S_OK;
    WORD         cTriggers = 0;
    TASK_TRIGGER jtTemp;

    do
    {
        hr = m_pIJob->GetTriggerCount(&cTriggers);

        CHECK_HRESULT(hr);
        BREAK_ON_FAIL(hr);

        if (cTriggers == 0)
        {
            break;
        }

        m_wNextTriggerId = m_cTriggersPrev = cTriggers;

        ITaskTrigger * pIJobTrigger = NULL;

        for (WORD wTrigger = 0; wTrigger < cTriggers; wTrigger++)
        {
            hr = m_pIJob->GetTrigger(wTrigger, &pIJobTrigger);

            CHECK_HRESULT(hr);
            BREAK_ON_FAIL(hr);

            hr = pIJobTrigger->GetTrigger(&jtTemp);

            CHECK_HRESULT(hr);

            pIJobTrigger->Release();

            BREAK_ON_FAIL(hr);

            // Set the trigger id
            jtTemp.Reserved1 = wTrigger;

            //
            //  Save it to the m_cjtList.
            //

            CJobTrigger * pcjt = new CJobTrigger(jtTemp);

            if (pcjt == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }

            m_cjtList.Add(pcjt);
        }

        BREAK_ON_FAIL(hr);

        m_pcjtCurr = m_cjtList.First();

    } while (0);

    return hr;
}


BOOL
CSchedulePage::_LoadTriggerStrings(void)
{
    TCHAR tcBuff[SCH_XBIGBUF_LEN];

    HWND hCombo = _hCtrl(cbx_triggers);
    if (!hCombo)
    {
        return FALSE;
    }
    
    int  iNew;
    HWND hwnd;

    CJobTrigger * pcjt = m_cjtList.First();

    if (pcjt == NULL)
    {
        //
        // Job not scheduled
        //

        LoadString(g_hInstance, IDS_NO_TRIGGERS, tcBuff, ARRAYLEN(tcBuff));

        if (hwnd = _hCtrl(txt_trigger)) SetWindowText(hwnd, tcBuff);

        iNew = ComboBox_AddString(hCombo, tcBuff);

        if (iNew < 0)
        {
            return FALSE;
        }

        ComboBox_SetItemData(hCombo, iNew, 0);

        return TRUE;
    }

    for (; pcjt != NULL; pcjt = pcjt->Next())
    {
        pcjt->TriggerString(TRUE, tcBuff, SCH_XBIGBUF_LEN);

        if (pcjt == m_cjtList.First())
        {
            // For single schedule set the static text box used to display
            // the schedule string.
            if (hwnd = _hCtrl(txt_trigger)) SetWindowText(hwnd, tcBuff);

            m_pcjtCurr = pcjt;
        }

        iNew = ComboBox_AddString(hCombo, tcBuff);

        if (iNew < 0)
        {
            return FALSE;
        }

        ComboBox_SetItemData(hCombo, iNew, pcjt);
    }

    return TRUE;
}



BOOL
CSchedulePage::_InitPage(void)
{
    TRACE(CSchedulePage, _InitPage);

    TCHAR   tcBuff[SCH_XBIGBUF_LEN];
    HWND    hCombo;

    //
    // set multiple schedules chk box
    //

    if (m_fShowMultiScheds == TRUE)
    {
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_UNCHECKED);
    }

    ////////////////////////////////////////////////////////////////
    //
    // Init all the combo boxes
    //

    //
    //  The triggers combo-box for multiple schedules
    //

    CJobTrigger * pcjt;
    int  iNew, iTemp;

    //
    //  The cbx_trigger_type
    //

    hCombo = GetDlgItem(Hwnd(), cbx_trigger_type);

    for (WORD w = 0; w < ARRAYLEN(ttd); w++)
    {
        LoadString(g_hInstance, ttd[w].ids, tcBuff, SCH_XBIGBUF_LEN);

        ComboBox_AddString(hCombo, tcBuff);
    }

    //
    //  The triggers comb box for multiple schedules as well as
    //  static text box for single schedule.
    //

    if (_LoadTriggerStrings() == FALSE)
    {
        return FALSE;
    }

    //
    //  The combo-boxes in monthly control
    //

    hCombo = GetDlgItem(Hwnd(), dow_cbx_week);

    for (w = 0; w < ARRAYLEN(g_aWeekData); w++)
    {
        LoadString(g_hInstance, g_aWeekData[w].ids, tcBuff,
                                        SCH_XBIGBUF_LEN);

        ComboBox_AddString(hCombo, tcBuff);
    }


    hCombo = GetDlgItem(Hwnd(), dow_cbx_day);

    for (w = 0; w < ARRAYLEN(g_aDayData); w++)
    {
        LoadString(g_hInstance, g_aDayData[w].ids, tcBuff,
                                        SCH_XBIGBUF_LEN);

        ComboBox_AddString(hCombo, tcBuff);
    }

    ////////////////////////////////////////////////////////////////
    //
    // Init all the spin controls
    //

    // daily_spin_every (1 to max), 1
    Spin_SetRange(Hwnd(), daily_spin_every, 1, 9999);
    Spin_SetPos(Hwnd(), daily_spin_every, 1);
    SendDlgItemMessage(Hwnd(), daily_txt_every, EM_LIMITTEXT, 4, 0);

    // weekly_spin_every (1 to max), 1
    Spin_SetRange(Hwnd(), weekly_spin_every, 1, 9999);
    Spin_SetPos(Hwnd(), weekly_spin_every, 1);
    SendDlgItemMessage(Hwnd(), weekly_txt_every, EM_LIMITTEXT, 4, 0);

    // md_spin (1 to 31), 1
    Spin_SetRange(Hwnd(), md_spin, 1, 31);
    Spin_SetPos(Hwnd(), md_spin, 1);
    SendDlgItemMessage(Hwnd(), md_txt, EM_LIMITTEXT, 2, 0);

    // sch_spin_idle_min (1 to max), 1
    Spin_SetRange(Hwnd(), sch_spin_idle_min, 1, MAX_IDLE_MINUTES);
    Spin_SetPos(Hwnd(), sch_spin_idle_min, 1);
    SendDlgItemMessage(Hwnd(), sch_txt_idle_min, EM_LIMITTEXT, MAX_IDLE_DIGITS, 0);

    ////////////////////////////////////////////////////////////////
    //
    // Hide all controls
    //

    _ShowControls(INDEX_DAILY, SW_HIDE);
    _ShowControls(INDEX_WEEKLY, SW_HIDE);
    _ShowControls(INDEX_MONTHLY, SW_HIDE);
    _ShowControls(INDEX_ONCE, SW_HIDE);
    _ShowControls(INDEX_IDLE, SW_HIDE);
    return TRUE;
}


int
CSchedulePage::_GetTriggerTypeIndex(void)
{
    switch (m_pcjtCurr->m_jt.TriggerType)
    {
    case TASK_TIME_TRIGGER_ONCE:
        return INDEX_ONCE;

    case TASK_TIME_TRIGGER_DAILY:
        return INDEX_DAILY;

    case TASK_TIME_TRIGGER_WEEKLY:
        return INDEX_WEEKLY;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
    case TASK_TIME_TRIGGER_MONTHLYDOW:
        return INDEX_MONTHLY;

    case TASK_EVENT_TRIGGER_ON_IDLE:
        return INDEX_IDLE;

   case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
      return INDEX_STARTUP;

    case TASK_EVENT_TRIGGER_AT_LOGON:
        return INDEX_LOGON;

    default:
        Win4Assert(0 && "Unknown trigger type");
        return -1;
    }
}



BOOL
CSchedulePage::_RefreshPage(void)
{
    TRACE(CSchedulePage, _RefreshPage);

    //
    //  Special case if Job not scheduled.
    //
    HWND hwnd;

    if (m_pcjtCurr == NULL)
    {

        if (hwnd = _hCtrl(cbx_trigger_type)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(btn_delete)) EnableWindow(hwnd, FALSE);
        _EnableTimeTriggerSpecificCtrls(FALSE);

        _ShowTriggerStringDispCtrls();

        // Force multiple schedules view
        // and prevent disabling new trigger creation if #triggers == 0

        m_fShowMultiScheds = TRUE;

        if (hwnd = _hCtrl(cbx_triggers)) ComboBox_SetCurSel(hwnd, 0);
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_CHECKED);
        if (hwnd = _hCtrl(chk_show_multiple_scheds)) EnableWindow(hwnd, FALSE);

        return TRUE;
    }

    //
    // Disable the "show multiple schedules" checkbox if there
    // is already more than one trigger on the task.
    // This prevents users from hiding the fact that they might have
    // additional triggers which they can't see.
    //

    if (m_cjtList.Count() != 1)
    {
        m_fShowMultiScheds = TRUE;
        CheckDlgButton(m_hPage, chk_show_multiple_scheds, BST_CHECKED);
        if (hwnd = _hCtrl(chk_show_multiple_scheds)) EnableWindow(hwnd, FALSE);
    }
    else
    {
        if (hwnd = _hCtrl(chk_show_multiple_scheds)) EnableWindow(hwnd, TRUE);
    }

    //
    // Set the trigger type
    //

    int indexTrigger = _GetTriggerTypeIndex();

    if (indexTrigger == -1)
    {
        return FALSE;
    }

    if (m_indexCbxTriggerType != -1  && m_indexCbxTriggerType != indexTrigger)
    {
        _ShowControls(m_indexCbxTriggerType, SW_HIDE);
    }

    m_indexCbxTriggerType = indexTrigger;

    if (hwnd = _hCtrl(cbx_trigger_type)) ComboBox_SetCurSel(hwnd, indexTrigger);

    //
    // Set the schedule
    //

    BOOL fTimeTrigger = TRUE;

    switch (m_pcjtCurr->m_jt.TriggerType)
    {
    case TASK_TIME_TRIGGER_DAILY:
        _ShowControls(INDEX_DAILY, SW_SHOWNA);
        _UpdateDailyControls();
        break;

    case TASK_TIME_TRIGGER_WEEKLY:
        _ShowControls(INDEX_WEEKLY, SW_SHOWNA);
        _UpdateWeeklyControls();
        break;

    case TASK_TIME_TRIGGER_MONTHLYDATE:
    case TASK_TIME_TRIGGER_MONTHLYDOW:
        _ShowControls(INDEX_MONTHLY, SW_SHOWNA);
        _UpdateMonthlyControls();
        break;

    case TASK_TIME_TRIGGER_ONCE:
        _ShowControls(INDEX_ONCE, SW_SHOWNA);
        _UpdateOnceOnlyControls();
        break;

    case TASK_EVENT_TRIGGER_AT_SYSTEMSTART:
        fTimeTrigger = FALSE;
        ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_STARTUP);
        break;

    case TASK_EVENT_TRIGGER_AT_LOGON:
        fTimeTrigger = FALSE;
        ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_LOGON);
        break;

    case TASK_EVENT_TRIGGER_ON_IDLE:
        fTimeTrigger = FALSE;
        ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_IDLE);
        _ShowControls(INDEX_IDLE, SW_SHOWNA);
        _UpdateIdleControls();
        break;

    default:
        Win4Assert(0 && "Unknown trigger type");
        return FALSE;
    }

    _EnableTimeTriggerSpecificCtrls(fTimeTrigger);

    if (fTimeTrigger == TRUE)
    {
        //
        // Set start time
        //

        SYSTEMTIME st;
        GetSystemTime(&st);

        st.wHour = m_pcjtCurr->m_jt.wStartHour;
        st.wMinute = m_pcjtCurr->m_jt.wStartMinute;
        st.wSecond = 0;

        hwnd = _hCtrl(dp_start_time);
        if ((NULL == hwnd) || (DateTime_SetSystemtime(hwnd, GDT_VALID, &st) == FALSE))
        {
            DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed.\n"));
        }
    }

    //
    //  Finally update the trigger string
    //

    _UpdateTriggerString();
    _ShowTriggerStringDispCtrls();

    return TRUE;
}


void
CSchedulePage::_UpdateDailyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_DAILY);

    Spin_SetPos(Hwnd(), daily_spin_every, m_pcjtCurr->m_jt.Type.Daily.DaysInterval);
}


void
CSchedulePage::_UpdateWeeklyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_WEEKLY);

    Spin_SetPos(Hwnd(), weekly_spin_every,
                            m_pcjtCurr->m_jt.Type.Weekly.WeeksInterval);

    for (int i=0; i < 7; i++)
    {
        if (m_pcjtCurr->m_jt.Type.Weekly.rgfDaysOfTheWeek & g_aDayData[i].day)
        {
            CheckDlgButton(Hwnd(), g_aDayData[i].idCtrl, BST_CHECKED);
        }
        else
        {
            CheckDlgButton(Hwnd(), g_aDayData[i].idCtrl, BST_UNCHECKED);
        }
    }
}



WORD
CSchedulePage::_GetDayFromRgfDays(
    DWORD rgfDays)
{
    WORD wDay;
    WORD wTemp;
    BYTE bTemp;

    if (LOWORD(rgfDays))
    {
        wTemp = LOWORD(rgfDays);
        wDay = 0;
    }
    else
    {
        wTemp = HIWORD(rgfDays);
        wDay = 16;
    }

    if (LOBYTE(wTemp))
    {
        bTemp = LOBYTE(wTemp);
    }
    else
    {
        bTemp = HIBYTE(wTemp);
        wDay += 8;
    }

    if (bTemp & 0x01) return (wDay + 1);
    if (bTemp & 0x02) return (wDay + 2);
    if (bTemp & 0x04) return (wDay + 3);
    if (bTemp & 0x08) return (wDay + 4);
    if (bTemp & 0x10) return (wDay + 5);
    if (bTemp & 0x20) return (wDay + 6);
    if (bTemp & 0x40) return (wDay + 7);
    if (bTemp & 0x80) return (wDay + 8);

    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSchedulePage::_CheckMonthlyRadio
//
//  Synopsis:   Set the state of the monthly radio buttons to match
//              [TriggerType].
//
//  Arguments:  [TriggerType] - TASK_TIME_TRIGGER_MONTHLYDATE or
//                               TASK_TIME_TRIGGER_MONTHLYDOW.
//
//  History:    07-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CSchedulePage::_CheckMonthlyRadio(
    TASK_TRIGGER_TYPE TriggerType)
{
    if (TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        CheckDlgButton(Hwnd(), md_rb, BST_CHECKED);
        CheckDlgButton(Hwnd(), dow_rb, BST_UNCHECKED);
    }
    else
    {
        Win4Assert(TriggerType == TASK_TIME_TRIGGER_MONTHLYDOW);

        CheckDlgButton(Hwnd(), md_rb, BST_UNCHECKED);
        CheckDlgButton(Hwnd(), dow_rb, BST_CHECKED);
    }
}




void
CSchedulePage::_UpdateMonthlyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_MONTHLY);

    WORD rgfMonths = 0;
    HWND hwnd;

    _CheckMonthlyRadio(m_pcjtCurr->m_jt.TriggerType);

    if (m_pcjtCurr->m_jt.TriggerType == TASK_TIME_TRIGGER_MONTHLYDATE)
    {
        WORD wDay = _GetDayFromRgfDays(m_pcjtCurr->m_jt.Type.MonthlyDate.rgfDays);

        Spin_SetPos(Hwnd(), md_spin, wDay);

        rgfMonths = m_pcjtCurr->m_jt.Type.MonthlyDate.rgfMonths;

        if (hwnd = _hCtrl(md_spin)) EnableWindow(hwnd, TRUE);
        if (hwnd = _hCtrl(md_txt)) EnableWindow(hwnd, TRUE);

        if (hwnd = _hCtrl(dow_cbx_week)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(dow_cbx_day)) EnableWindow(hwnd, FALSE);
    }
    else // monthly day-of-week
    {
        for (int i=0; i < ARRAYLEN(g_aWeekData); i++)
        {
            if (g_aWeekData[i].week ==
                m_pcjtCurr->m_jt.Type.MonthlyDOW.wWhichWeek)
            {
                break;
            }
        }

        if (hwnd = _hCtrl(dow_cbx_week))
        {
            ComboBox_SetCurSel(hwnd, i);
            EnableWindow(hwnd, TRUE);
        }

        WORD &wDayOfWeek = m_pcjtCurr->m_jt.Type.MonthlyDOW.rgfDaysOfTheWeek;

        for (i=0; i < ARRAYLEN(g_aDayData); i++)
        {
            if (wDayOfWeek & g_aDayData[i].day)
            {
                break;
            }
        }

        if (hwnd = _hCtrl(dow_cbx_day))
        {
            ComboBox_SetCurSel(hwnd, i);
            EnableWindow(hwnd, TRUE);
        }

        rgfMonths = m_pcjtCurr->m_jt.Type.MonthlyDOW.rgfMonths;

        if (hwnd = _hCtrl(md_txt)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(md_spin)) EnableWindow(hwnd, FALSE);
    }
}


void
CSchedulePage::_UpdateOnceOnlyControls(void)
{
    ComboBox_SetCurSel(GetDlgItem(Hwnd(), cbx_trigger_type), INDEX_ONCE);

    SYSTEMTIME st;

    SecureZeroMemory(&st, sizeof st);
    st.wYear        = m_pcjtCurr->m_jt.wBeginYear;
    st.wMonth       = m_pcjtCurr->m_jt.wBeginMonth;
    st.wDay         = m_pcjtCurr->m_jt.wBeginDay;

    HWND hwnd;
    if (hwnd = _hCtrl(once_dp_date))
    {
        if (DateTime_SetSystemtime(hwnd, GDT_VALID, &st) == FALSE)
        {
            DEBUG_OUT((DEB_ERROR,
                      "DateTime_SetSystemtime err=%uL.\n",
                      GetLastError()));
        }
    }
}

void
CSchedulePage::_UpdateIdleControls(void)
{
    WORD wIdleWait;
    WORD wIdleDeadline;

    m_pIJob->GetIdleWait(&wIdleWait, &wIdleDeadline);

    if (wIdleWait > MAX_IDLE_MINUTES)
    {
        wIdleWait = MAX_IDLE_MINUTES;
    }
    Spin_SetPos(Hwnd(), sch_spin_idle_min, wIdleWait);
}

INT_PTR
AdvancedDialog(
    HWND          hParent,
    PTASK_TRIGGER pjt);


LRESULT
CSchedulePage::_OnCommand(
    int     id,
    HWND    hwndCtl,
    UINT    codeNotify)
{
    TRACE(CSchedulePage, _OnCommand);

    HRESULT         hr = S_OK;
    CJobTrigger   * pcjt = NULL;
    BOOL            fUpdateTriggerStr = TRUE;
    SYSTEMTIME      st;
    HWND            hCombo;
    HWND            hwnd;

    switch (id)
    {
    case cbx_trigger_type:
        fUpdateTriggerStr = FALSE;
        if (codeNotify == CBN_DROPDOWN)
        {
            if (hwnd = _hCtrl(cbx_trigger_type))
            {
                s_iCbx = ComboBox_GetCurSel(hwnd);
            }
        }
        else if (codeNotify == CBN_SELENDOK)
        {
            if (hwnd = _hCtrl(cbx_trigger_type))
            {
                int iCur = ComboBox_GetCurSel(hwnd);

                if (iCur != s_iCbx)
                {
                    _DisplayControls(iCur);
    
                    _EnableApplyButton();
    
                    fUpdateTriggerStr = TRUE;
                }
            }
            s_iCbx = -1;
        }
        else if (codeNotify == CBN_SELENDCANCEL)
        {
            s_iCbx = -1;
        }
        break;

    case btn_advanced:
    {
        _SaveTriggerSettings();

        TASK_TRIGGER jt = m_pcjtCurr->m_jt;

        if (AdvancedDialog(Hwnd(), &jt) == TRUE)
        {
            if (memcmp(&jt, &m_pcjtCurr->m_jt, sizeof(jt)) != 0)
            {
                m_pcjtCurr->m_jt = jt;

                m_pcjtCurr->DirtyTrigger();

                _EnableApplyButton();
            }
            else
            {
                fUpdateTriggerStr = FALSE;
            }
        }

        break;
    }

    case btn_sel_months:
    {
        _SaveTriggerSettings();

        TASK_TRIGGER jt = m_pcjtCurr->m_jt;

        _SelectMonths.InitSelectionFromTrigger(&jt);
        INT_PTR fOk = _SelectMonths.DoModal(select_month_dlg, Hwnd());

        if (fOk)
        {
            _SelectMonths.UpdateTrigger(&jt);

            if (memcmp(&jt, &m_pcjtCurr->m_jt, sizeof(jt)) != 0)
            {
                m_pcjtCurr->m_jt = jt;

                m_pcjtCurr->DirtyTrigger();

                _EnableApplyButton();
            }
            else
            {
                fUpdateTriggerStr = FALSE;
            }
        }
        break;
    }

    // Daily controls - none to handle here
    case daily_txt_every:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    // Weekly controls

    case weekly_txt_every:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    case chk_mon: case chk_tue: case chk_wed: case chk_thu:
    case chk_fri: case chk_sat: case chk_sun:
        _EnableApplyButton();
        break;

    // Monthly controls

    case md_txt:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    case md_rb:
        _CheckMonthlyRadio(TASK_TIME_TRIGGER_MONTHLYDATE);

        Spin_Enable(Hwnd(), md_spin, 1);

        if (hwnd = _hCtrl(dow_cbx_week)) EnableWindow(hwnd, FALSE);
        if (hwnd = _hCtrl(dow_cbx_day))  EnableWindow(hwnd, FALSE);

        _EnableApplyButton();

        break;

    case dow_rb:
        _CheckMonthlyRadio(TASK_TIME_TRIGGER_MONTHLYDOW);

        Spin_Disable(Hwnd(), md_spin);

        if (hwnd = _hCtrl(dow_cbx_week))
        {
            EnableWindow(hwnd, TRUE);
            ComboBox_SetCurSel(hwnd, 0);
        }
        if (hwnd = _hCtrl(dow_cbx_day))
        {
            EnableWindow(hwnd, TRUE);
            ComboBox_SetCurSel(hwnd, 0);
        }

        _EnableApplyButton();
        break;

    case dow_cbx_week:
    case dow_cbx_day:
        fUpdateTriggerStr = FALSE;

        if (codeNotify == CBN_DROPDOWN)
        {
            if (hwnd = _hCtrl(id)) s_iCbx = ComboBox_GetCurSel(hwnd);
        }
        else if (codeNotify == CBN_SELENDOK)
        {
            if (hwnd = _hCtrl(id))
            {
                int iCur = ComboBox_GetCurSel(hwnd);
    
                if (iCur != s_iCbx)
                {
                    _EnableApplyButton();
    
                    fUpdateTriggerStr = TRUE;
                }
            }
            s_iCbx = -1;
        }
        else if (codeNotify == CBN_SELENDCANCEL)
        {
            s_iCbx = -1;
        }
        break;

    // When Idle controls

    case sch_txt_idle_min:
        if (codeNotify == EN_CHANGE)
        {
            _EnableApplyButton();
        }
        break;

    // Once only controls - none
    // At startup controls - none
    // At logon controls - none

    // Controls for multiple triggers
    case chk_show_multiple_scheds:
        if (IsDlgButtonChecked(m_hPage, chk_show_multiple_scheds)
            == BST_CHECKED)
        {
            m_fShowMultiScheds = TRUE;
        }
        else
        {
            m_fShowMultiScheds = FALSE;
        }
        _UpdateTriggerString();
        _ShowTriggerStringDispCtrls();
        break;

    case btn_new:
    {
        if (hwnd = _hCtrl(btn_new)) SetFocus(hwnd);

        hCombo = _hCtrl(cbx_triggers);
        if (!hCombo)
        {
            break;
        }

        if (_PerformSanityChkOnCurrTrigger() == FALSE)
        {
            break;
        }

        if (m_pcjtCurr == NULL)
        {
            ComboBox_ResetContent(hCombo);
            m_wNextTriggerId = 0;
        }
        else
        {
            //
            //  Save the current trigger
            //

            _SaveTriggerSettings();
        }

        //
        //  Create a new trigger, with default settings as:
        //      daily trigger starting at 6:00 AM
        //

        TASK_TRIGGER jtDefault;
        GetSystemTime(&st);

        SecureZeroMemory(&jtDefault, sizeof(jtDefault));

        jtDefault.cbTriggerSize = sizeof(jtDefault);
        jtDefault.wBeginYear = st.wYear;
        jtDefault.wBeginMonth = st.wMonth;
        jtDefault.wBeginDay = st.wDay;
        jtDefault.wStartHour = 9; // 9 AM
        jtDefault.TriggerType = TASK_TIME_TRIGGER_DAILY;
        jtDefault.Type.Daily.DaysInterval = 1; // Every day

        jtDefault.Reserved1 = m_wNextTriggerId;
        jtDefault.Reserved2 = 0;
        jtDefault.wRandomMinutesInterval = 0;

        pcjt = m_cjtDeletedList.First();

        if (pcjt != NULL)
        {
            m_cjtDeletedList.Remove(pcjt);

            pcjt->m_jt = jtDefault;
        }
        else
        {
            pcjt = new CJobTrigger(jtDefault);

            if (pcjt == NULL)
            {
                hr = E_OUTOFMEMORY;
                CHECK_HRESULT(hr);
                break;
            }
        }

        pcjt->DirtyTrigger();

        TCHAR tcBuff[SCH_XBIGBUF_LEN];

        pcjt->TriggerString(TRUE, tcBuff, SCH_XBIGBUF_LEN);

        int iNew = ComboBox_AddString(hCombo, tcBuff);

        if (iNew < 0)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
            break;
        }

        ComboBox_SetItemData(hCombo, iNew, pcjt);

        ComboBox_SetCurSel(hCombo, iNew);

        m_indexCbxTriggers = iNew;
        m_pcjtCurr = pcjt;

        m_cjtList.Add(pcjt);


        //
        //  Don't forget to increment m_wNextTriggerId
        //

        ++m_wNextTriggerId;

        //
        //  Refresh the page for the new trigger
        //

        _RefreshPage();

        //
        //  If count of triggers increased from 0 to 1 enable
        //  cbx_trigger_type & btn_delete.
        //

        if (m_cjtList.Count() == 1)
        {
            if (hwnd = _hCtrl(cbx_trigger_type)) EnableWindow(hwnd, TRUE);
            if (hwnd = _hCtrl(btn_delete))       EnableWindow(hwnd, TRUE);
        }

        _EnableApplyButton();

        break;
    }
    case btn_delete:
    {
        //
        //  Delete the current trigger.
        //

        //Win4Assert(m_cjtList.Count() > 1);

        HWND hCombo = _hCtrl(cbx_triggers);
        if (!hCombo)
        {
            break;
        }

        int iCur = ComboBox_GetCurSel(hCombo);

        pcjt = (CJobTrigger *) ComboBox_GetItemData(hCombo, iCur);

        ComboBox_DeleteString(hCombo, iCur);

        m_cjtList.Remove(pcjt);
        m_cjtDeletedList.Add(pcjt);

        //
        //  Update the triggers combo box
        //

        if (iCur >= ComboBox_GetCount(hCombo))
        {
            --iCur;
        }

        if (iCur >= 0)
        {
            ComboBox_SetCurSel(hCombo, iCur);

            m_indexCbxTriggers = iCur;
            m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(hCombo, iCur);
        }
        else
        {
            _ShowControls(m_indexCbxTriggerType, SW_HIDE);
            _LoadTriggerStrings();

            ComboBox_SetCurSel(hCombo, 0);
            m_indexCbxTriggers = 0;
            m_pcjtCurr = NULL;

            fUpdateTriggerStr = FALSE;
        }

        //
        //  Refresh the page for the new trigger
        //

        _RefreshPage();


        //
        //  If we have zero items, disable the delete button.
        //

        if (m_cjtList.Count() == 0)
        {
            if (hwnd = _hCtrl(btn_delete)) EnableWindow(hwnd, FALSE);
            if (hwnd = _hCtrl(btn_new))    SetFocus(hwnd);
        }
        else
        {
            if (hwnd = _hCtrl(btn_delete)) SetFocus(hwnd);
        }

        _EnableApplyButton();

        break;
    }

    case cbx_triggers:
        if (codeNotify == CBN_SELENDOK)
        {
            if (hwnd = _hCtrl(cbx_triggers))
            {
                m_indexCbxTriggers = ComboBox_GetCurSel(hwnd);
    
                m_pcjtCurr = (CJobTrigger *) ComboBox_GetItemData(hwnd, m_indexCbxTriggers);

                _RefreshPage();
            }
        }
        else
        {
            fUpdateTriggerStr = FALSE;
        }
        break;

    default:
        fUpdateTriggerStr = FALSE;
        return FALSE;
    }

    if (fUpdateTriggerStr == TRUE)
    {
        _CreateTimerToUpdateTriggerStr();
    }

    if (FAILED(hr))
    {
        _ErrorDialog(IERR_OUT_OF_MEMORY);
    }

    return TRUE;
}



void
CSchedulePage::_DisplayControls(int indexTrigger)
{
    TRACE(CSchedulePage, _DisplayControls);

    if (indexTrigger == m_indexCbxTriggerType)
    {
        return;
    }

    _ShowControls(m_indexCbxTriggerType, SW_HIDE);
    _ShowControls((m_indexCbxTriggerType = indexTrigger), SW_SHOWNA);

    BOOL fEnableEventControls = TRUE;
    UINT i;
    HWND hwnd;

    switch (indexTrigger)
    {
    case INDEX_DAILY:
        Spin_SetPos(Hwnd(), daily_spin_every, 1);
        break;

    case INDEX_WEEKLY:
        Spin_SetPos(Hwnd(), weekly_spin_every, 1);

        CheckDlgButton(Hwnd(), g_aDayData[0].idCtrl, BST_CHECKED);

        for (i = 1; i < ARRAYLEN(g_aDayData); i++)
        {
            CheckDlgButton(Hwnd(), g_aDayData[i].idCtrl, BST_UNCHECKED);
        }

        break;

    case INDEX_MONTHLY:
    {
        _CheckMonthlyRadio(TASK_TIME_TRIGGER_MONTHLYDATE);

        Spin_Enable(Hwnd(), md_spin, 1);
        m_pcjtCurr->m_jt.Type.MonthlyDate.rgfMonths = ALL_MONTHS;

        if (hwnd = _hCtrl(dow_cbx_week))
        {
            if( !EnableWindow(hwnd, FALSE) )
            {
                DEBUG_OUT((DEB_USER1, "EnableWindow(_hCtrl(dow_cbx_week), FALSE) failed.\n"));
            }
        }

        if (hwnd = _hCtrl(dow_cbx_day))
        {
            if( !EnableWindow(hwnd, FALSE) )
            {
                DEBUG_OUT((DEB_USER1, "EnableWindow(_hCtrl(dow_cbx_day), FALSE) failed.\n"));
            }
        }

        break;
    }
    case INDEX_ONCE:
    {
        SYSTEMTIME st;
        GetLocalTime(&st);

        if (hwnd = _hCtrl(once_dp_date))
        {
            if (DateTime_SetSystemtime(hwnd, GDT_VALID, &st) == FALSE)
            {
                DEBUG_OUT((DEB_USER1, "DateTime_SetSystemtime failed.\n"));
            }
        }

        break;
    }
    case INDEX_IDLE:
    {
        WORD wIdleWait;
        WORD wDummy;
        HRESULT hr = m_pIJob->GetIdleWait(&wIdleWait, &wDummy);

        if (FAILED(hr) || !wIdleWait)
        {
            wIdleWait = SCH_DEFAULT_IDLE_TIME;
        }
        else if (wIdleWait > MAX_IDLE_MINUTES)
        {
            wIdleWait = MAX_IDLE_MINUTES;
        }
        Spin_SetPos(Hwnd(), sch_spin_idle_min, wIdleWait);
        fEnableEventControls = FALSE;
        break;
    }

    case INDEX_STARTUP:
    case INDEX_LOGON:
        fEnableEventControls = FALSE;
        break;
    }

    _EnableTimeTriggerSpecificCtrls(fEnableEventControls);
}


void
CSchedulePage::_SaveTriggerSettings(void)
{
    TRACE(CSchedulePage, _SaveTriggerSettings);

    if (m_pcjtCurr == 0)
    {
        // No triggers
        return;
    }

    HWND hwnd = _hCtrl(cbx_trigger_type);
    if (!hwnd)
    {
        return;
    }
    int idxTriggerType = ComboBox_GetCurSel(hwnd);
    Win4Assert(idxTriggerType != CB_ERR);

    int i;

    // Get start time
    SYSTEMTIME st;

    if (hwnd = _hCtrl(dp_start_time))
    {
        if (DateTime_GetSystemtime(hwnd, &st) == GDT_VALID)
        {
            m_pcjtCurr->m_jt.wStartHour = st.wHour;
            m_pcjtCurr->m_jt.wStartMinute = st.wMinute;
        }
    }


    switch (idxTriggerType)
    {
    case INDEX_DAILY:
        m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_DAILY;
        m_pcjtCurr->m_jt.Type.Daily.DaysInterval = (WORD)Spin_GetPos(Hwnd(),
                                                         daily_spin_every);
        break;

    case INDEX_WEEKLY:
        m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_WEEKLY;
        m_pcjtCurr->m_jt.Type.Weekly.WeeksInterval = (WORD)Spin_GetPos(Hwnd(),
                                                        weekly_spin_every);

        m_pcjtCurr->m_jt.Type.Weekly.rgfDaysOfTheWeek = 0;

        for (i=0; i < ARRAYLEN(g_aDayData); i++)
        {
            if (IsDlgButtonChecked(Hwnd(), g_aDayData[i].idCtrl)
                == BST_CHECKED)
            {
                m_pcjtCurr->m_jt.Type.Weekly.rgfDaysOfTheWeek |= g_aDayData[i].day;
            }
        }

        break;

    case INDEX_MONTHLY:
    {
        if (IsDlgButtonChecked(Hwnd(), md_rb) == BST_CHECKED)
        {
            m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_MONTHLYDATE;

            WORD wTemp = (WORD)Spin_GetPos(Hwnd(), md_spin);

            m_pcjtCurr->m_jt.Type.MonthlyDate.rgfDays = (1 << (wTemp - 1));
        }
        else // monthly day-of-week
        {
            m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_MONTHLYDOW;

            if (hwnd = _hCtrl(dow_cbx_week))
            {
                i = ComboBox_GetCurSel(hwnd);
                m_pcjtCurr->m_jt.Type.MonthlyDOW.wWhichWeek = (WORD)g_aWeekData[i].week;
            }

            if (hwnd = _hCtrl(dow_cbx_day))
            {
                i = ComboBox_GetCurSel(hwnd);
                m_pcjtCurr->m_jt.Type.MonthlyDOW.rgfDaysOfTheWeek = (WORD)g_aDayData[i].day;
            }
        }
        break;
    }
    case INDEX_ONCE:
        m_pcjtCurr->m_jt.TriggerType = TASK_TIME_TRIGGER_ONCE;

        if (hwnd = _hCtrl(once_dp_date))
        {
            if (DateTime_GetSystemtime(hwnd, &st) == GDT_VALID)
            {
                m_pcjtCurr->m_jt.wBeginYear   = st.wYear;
                m_pcjtCurr->m_jt.wBeginMonth  = st.wMonth;
                m_pcjtCurr->m_j