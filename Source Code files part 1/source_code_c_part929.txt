f (bMustNotBeAlpha) {
         if (iRemainingAlpha) {
            if (iType[1] >= eDigit)
               iMinType = 1;
            else
               iMinType = 2;
         }
      }

      // Get the type to generate.
      int            iTypePosition;
      int            iTypeToGenerate;
      const TCHAR   *pszSourceString;

      if (iMinType == iMaxType)  // There's only one type. Use it.
         iTypePosition = iMinType;
      else {
         // This algorithm distributes the chances for various types.
         // If there are 13 LCs to place and one special, there's a
         // 13/14 chance of placing an LC and a 1/14 chance of placing a
         // special, due to this algorithm.
         int   iNextTypePosition = 0;

         for (int i = iMinType; i <= iMaxType; ++i) {
            for (int j = 0; j < (int)dwToPlace[i]; ++j) {
               iTypeList[iNextTypePosition++] = i;
            }
         }

         iTypePosition = iTypeList[bRandomType[iNewChar] % iNextTypePosition];
      }

      iTypeToGenerate = iType[iTypePosition];
      pszSourceString = szSourceString[iTypeToGenerate];

      // Generate the next character.
	  pszNewPassword[iNewChar] = pszSourceString[bRandomChar[iNewChar] % UStrLen(pszSourceString)];

      // Keep track of those alphas.
      if (iTypeToGenerate < eDigit) {
         ++dwConsecAlpha;
         --iRemainingAlpha;
      }
      else
         dwConsecAlpha = 0;

      // Update the types to generate.
      if (!--dwToPlace[iTypePosition]) {
         for (int iNextTypePosition = iTypePosition + 1; iNextTypePosition < iTypes; ++iNextTypePosition) {
            dwToPlace[iNextTypePosition - 1] = dwToPlace[iNextTypePosition];
            iType[iNextTypePosition - 1] = iType[iNextTypePosition];
         }
         --iTypes;
      }
   }

   pszNewPassword[dwNewLength] = '\0';

   UStrCpy( newPassword, pszNewPassword );

   return ERROR_SUCCESS;
} /* PasswordGenerate() */

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Return a random number in the range [iMin..iMax].
// Tries to be fair by discarding values of rand() that give an advantage
// to low results.
int   iRand(int iMin, int iMax)
{
   int   iSize = iMax - iMin + 1;
   int   iMaxRand = (int)((((long)RAND_MAX + 1L) / (long)iSize) * (long)iSize);
   int   i;

   if (iMaxRand > 0)
      do {
         i = rand();
      } while (i > iMaxRand);
   else
      i = rand();

   return (i % iSize) + iMin;
}


// GenerateRandom
//
// Fills buffers with cryptographically random bytes.

void __stdcall GenerateRandom(DWORD dwCount, BYTE* pbRandomType, BYTE* pbRandomChar)
{
	bool bGenerated = false;

	HCRYPTPROV hProv = NULL;

	if (CryptAcquireContext(&hProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT))
	{
		if (CryptGenRandom(hProv, dwCount, pbRandomType) && CryptGenRandom(hProv, dwCount, pbRandomChar))
		{
			bGenerated = true;
		}

		CryptReleaseContext(hProv, 0);
	}

	// if cryptographic generation fails, fallback to random number generator

	if (!bGenerated)
	{
		for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++)
		{
			pbRandomType[dwIndex] = (BYTE)iRand(0, 255);
			pbRandomChar[dwIndex] = (BYTE)iRand(0, 255);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\tevent.cpp ===
//#pragma title( "TEvent.cpp - Log events" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TAudit.cpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1995-11-10
Description -  TErrorEventLog class
Updates     -
===============================================================================
*/

#include <stdio.h>
#include <windows.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"

#include "TEvent.hpp"

BOOL
   TErrorEventLog::LogOpen(
      WCHAR          const * svcName      ,// in -service name
      int                    mode         ,// in -0=overwrite, 1=append
      int                    level         // in -minimum level to log
   )
{
   hEventSource = RegisterEventSourceW( NULL, svcName );
   if ( hEventSource == NULL )
      lastError = GetLastError();

   return hEventSource != NULL;
}

void
   TErrorEventLog::LogWrite(
      WCHAR          const * msg
   )
{
   BOOL                      rcBool;
   DWORD                     rcErr;
   static const WORD         levelTranslate[] = {EVENTLOG_INFORMATION_TYPE,
                                                 EVENTLOG_WARNING_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE,
                                                 EVENTLOG_ERROR_TYPE};

   SID                     * pSid = NULL;
   HANDLE                    hToken = NULL;
   TOKEN_USER                tUser[10];
   ULONG                     len;

   if ( OpenProcessToken(GetCurrentProcess(),TOKEN_READ,&hToken) )
   {
      if ( GetTokenInformation(hToken,TokenUser,tUser,10*(sizeof TOKEN_USER),&len) )
      {
         pSid = (SID*)tUser[0].User.Sid;
      }
      else
      {
         rcErr = GetLastError();
      }
      CloseHandle(hToken);
   }
   else
   {
      rcErr = GetLastError();
   }

   // TODO:  setup event category
   // TODO:  log events in Unicode

   rcBool = ReportEventW( hEventSource,    // handle of event source
               levelTranslate[level],      // event type
               0,                          // event category
//               CAT_AGENT,                  // event category
               DCT_MSG_GENERIC_S,          // event ID
               pSid,                       // current user's SID
               1,                          // strings in lpszStrings
               0,                          // no bytes of raw data
               &msg,                       // array of error strings
               NULL );                     // no raw data
   if ( !rcBool )
   {
      rcErr = GetLastError();
   }
}

void
   TErrorEventLog::LogClose()
{
   if ( hEventSource != NULL )
   {
      DeregisterEventSource( hEventSource );
      hEventSource = NULL;
   }
};

// TEvent.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\taskchk.cpp ===
/*Copyright (c) 1995-1999, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TaskCheck.cpp
System      -  Domain Consolidation Toolkit.
Author      -  Christy Boles
Created     -  99/07/01
Description -  Routines that examine a the job defined by a varset and determine 
               whether specific migration tasks need to be performed.

Updates     -
===============================================================================
*/

//#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
//#include <process.h>

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#include "Common.hpp"
#include "TaskChk.h"
#include "ResStr.h"
#include "UString.hpp"
#include "ErrDct.hpp"

extern TErrorDct        errTrace;

BOOL                                   // ret- BOOL, whether account replicator should be called
   NeedToUseAR(
      IVarSet              * pVarSet   // in - varset containing migration settings
   )
{
   _bstr_t                   text;
   BOOL                      bResult = FALSE;

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR:  Copying users");
      bResult = TRUE;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR:  Copying groups");
      bResult = TRUE;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR:  Copying computers");
      bResult = TRUE;
   }
   
   text = pVarSet->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));
   // account replication is only done locally on the machine where Domain Migrator is running
   // it cannot be dispatched to run on a different machine.
   // (you can't very well copy accounts from one domain to another while running as localsystem)
   if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      errTrace.DbgMsgWrite(0,L"Never use AR when running remotely.");
      bResult = FALSE; 
   }

   // Account replicator should not be run when gathering information
   _bstr_t                   wizard = pVarSet->get(L"Options.Wizard");
   if ( !_wcsicmp((WCHAR*) wizard, L"reporting") )
   {
      errTrace.DbgMsgWrite(0,L"Never use AR when Gathering Information.");
      bResult = FALSE; 
   }

   if ( !_wcsicmp((WCHAR*) wizard, L"sidremove") )
   {
      errTrace.DbgMsgWrite(0,L"Need to use AR. We are removing sids.");
      bResult = TRUE; 
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   if ( text.length() == 0 )
   {
      // no accounts were specified
      bResult = FALSE;
   }
   return ( bResult );
}

BOOL                                       // ret- BOOL, whether security translator should be called
   NeedToUseST(
      IVarSet              * pVarSet,       // in - varset containing migration settings
      BOOL                   bForceRemoteCheck // in - forces checking to be done based on the remote operations, not local ones 
   ) 
{
   BOOL                      bResult = FALSE;
   BOOL                      bLocalAgent;

   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));

   if (!text)
      return FALSE;

   bLocalAgent = ( UStrICmp(text,GET_STRING(IDS_YES)) == 0 );

   if ( bLocalAgent || bForceRemoteCheck )
   {
      // the agent dispatched to remote machines does translation for 
      // files

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateFiles));

      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Files");
         bResult = TRUE;
      }
      // and Shares
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateShares));
      if (! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Shares");
         bResult = TRUE;
      }
      // and User Rights
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserRights));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Rights");
         bResult = TRUE;
      }
      // and Local Groups   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateLocalGroups));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  LGroups");
         bResult = TRUE;
      }
      // and Printers
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslatePrinters));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Printers");
         bResult = TRUE;
      }
      // and User Profiles
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserProfiles));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Local User Profiles");
         bResult = TRUE;
      }
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateRegistry));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Registry");
         bResult = TRUE;
      }
      // when dispatching, the settings are per-job, not per-server
      // it is possible to choose whether to migrate, translate, or both,
      // for each computer in the server list.
      // this setting indicates that the translation will not be run on this computer
      // even though other computers are being translated during this same job
      text = pVarSet->get(GET_BSTR(DCTVS_LocalServer_MigrateOnly));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )

      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  but not on this computer");
         bResult = FALSE;
      }
   }
   else
   {
      // The local engine does exchange translation for 
      // mailboxes 
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateMailboxes));
      if ( text.length() )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Mailboxes");
         bResult = TRUE;
      }
      // and containers
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));
      if ( text.length() )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  Containers");
         bResult = TRUE;
      }
      // The local engine is also used to build an account mapping file to
      // send out with the dispatched agents for security translation
      text = pVarSet->get(GET_BSTR(DCTVS_Security_BuildCacheFile));
      if ( text.length() )
      {
         errTrace.DbgMsgWrite(0,L"Need to use ST:  BuildCacheFile");
         bResult = TRUE;
      }
   }   
   return bResult;
}

BOOL                                         // ret- whether agents need to be dispatched to remote machines
   NeedToDispatch(
      IVarSet              * pVarSet         // in - varset describing migration job
   )
{
   BOOL                      bNeedToDispatch = FALSE;
   _bstr_t                   text;
   long                      count;
   _bstr_t                   wizard = pVarSet->get(L"Options.Wizard");

   if (!wizard)
      return FALSE;

   if (! UStrICmp(wizard,L"user") )
   {
      bNeedToDispatch = FALSE;
   }
   else if (! UStrICmp(wizard,L"group") )
   {
      bNeedToDispatch = FALSE;
   }
   else if ( !UStrICmp(wizard,L"computer") )
   {
      bNeedToDispatch = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"security" ) )
   {
      bNeedToDispatch = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"service" ) )
   {
      bNeedToDispatch = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"retry") )
   {
      bNeedToDispatch = TRUE;
   }


   // the dispatcher is used to migrate computers, and to translate security
   count = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
   if ( count > 0 )
   {
      bNeedToDispatch = TRUE;
   }
   return bNeedToDispatch;
}

BOOL 
   NeedToRunReports(
      IVarSet              * pVarSet       // in - varset describing migration job
   )
{
   BOOL                      bNeedToReport = FALSE;
   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Reports_Generate));

   if (!text)
      return FALSE;

   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      bNeedToReport = TRUE;
   }

   return bNeedToReport;
}

BOOL                                       // ret- whether the local engine needs to be called to perform domain specific tasks
   NeedToRunLocalAgent(
      IVarSet              * pVarSet       // in - varset describing migration job
   )
{
   BOOL                      bNeedToRunLocal = FALSE;
   _bstr_t                   text;
   _bstr_t                   wizard = pVarSet->get(L"Options.Wizard");
   
   if (!wizard)
      return FALSE;

   // if the wizard type is specified, use it to determine what to do
   if ( ! UStrICmp(wizard,L"user") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if (! UStrICmp(wizard,L"group") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if ( !UStrICmp(wizard,L"computer") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if ( !UStrICmp(wizard,L"security") )
   {
      bNeedToRunLocal = FALSE;
   }
   else if ( !UStrICmp(wizard,L"undo") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if ( ! UStrICmp(wizard,L"service") )
   {
      bNeedToRunLocal = FALSE;
   }
   else if ( !UStrICmp(wizard, "exchange") )
   {
      bNeedToRunLocal = TRUE;
   }
   else if (! UStrICmp(wizard,L"retry") )
   {
      bNeedToRunLocal = FALSE;
   }
   else if ( ! UStrICmp(wizard,L"reporting") )
   {
      text = pVarSet->get(GET_BSTR(DCTVS_GatherInformation_ComputerPasswordAge));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         bNeedToRunLocal = TRUE;
      }
   }
   else
   {
      // wizard type is not specified, try to determine what needs to be done from the varset entries
      // The local agent is used for account replication and exchange translation
      if ( NeedToUseAR(pVarSet) )
         bNeedToRunLocal = TRUE;

      if ( NeedToUseST(pVarSet) )
         bNeedToRunLocal = TRUE;

   }
   return bNeedToRunLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\strhelp.cpp ===
/*---------------------------------------------------------------------------
  File: StrHelp.cpp

  Comments: Contains general string helper functions.


  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 11/02/00 

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <windows.h>
#include <stdio.h>
#endif

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 2 NOV 2000                                                  *
 *                                                                   *
 *     This function is responsible for determining if a given string*
 * is found, in whole, in a given delimited string.  The string      *
 * delimitedr can be most any character except the NULL char ('\0'). *
 *     By the term "in whole", we mean to say that the given string  *
 * to find is not solely a substring of another string in the        *
 * delimited string.                                                 *
 *                                                                   *
 *********************************************************************/

//BEGIN IsStringInDelimitedString
BOOL                                         //ret- TRUE=string found
   IsStringInDelimitedString(    
      LPCWSTR                sDelimitedString, // in- delimited string to search
      LPCWSTR                sString,          // in- string to search for
      WCHAR                  cDelimitingChar   // in- delimiting character used in the delimited string
   )
{
/* local variables */
	BOOL		bFound = FALSE;
    int			len;
    WCHAR	  * pSub;

/* function body */
	if ((!sDelimitedString) || (!sString))
	   return FALSE;

	len = wcslen(sString);
	pSub = wcsstr(sDelimitedString, sString);
	while ((pSub != NULL) && (!bFound))
	{
		  //if not the start of the string being searched
	   if (pSub != sDelimitedString)
	   {
		     //and if not the end of the string
		  if (*(pSub+len) != L'\0')
		  {
			    //and if before and after are delimiters, then found
		     if ((*(pSub-1) == cDelimitingChar) && (*(pSub+len) == cDelimitingChar))
			    bFound = TRUE;
		  } 
		     //else if end of string see the preceeding char was a delimiter
		  else if (*(pSub-1) == cDelimitingChar)
		     bFound = TRUE;  //if so, found
	   }
	      //else start of string and after is delimiter or end, found
	   else if ((*(pSub+len) == cDelimitingChar) || (*(pSub+len) == L'\0'))
	      bFound = TRUE;

	      //if not found yet, continue to search
	   if (!bFound)
	      pSub = wcsstr(pSub+1, sString);
	}

	return bFound;
}
//END IsStringInDelimitedString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\tservice.cpp ===
//#pragma title( "TService.cpp - SCM interface for MCS service" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TService.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-08-17
Description -  Service Control Manager interface for MCS service
Updates     -
===============================================================================
*/

#include <windows.h>
#include <stdio.h>

#include "TService.hpp"

///////////////////////////////////////////////////////////////////////////////
// Private data declarations
///////////////////////////////////////////////////////////////////////////////

#define  WAIT_HINT_SECONDS  (10)
#define  WAIT_HINT_MILLISECONDS  (WAIT_HINT_SECONDS*1000)

static
   TCHAR                   * gNameService;
static
   SERVICE_STATUS            gServiceStatus;
static
   SERVICE_STATUS_HANDLE     ghServiceStatus;
static
   HANDLE                    ghServDoneEvent=INVALID_HANDLE_VALUE;
static
   DWORD                     gArgc;
static
   TCHAR                  ** gArgv;
static
   TScmEpRc                  grcScmEp=TScmEpRc_Unknown; // TScmEp return code

///////////////////////////////////////////////////////////////////////////////
// Private function prototypes
///////////////////////////////////////////////////////////////////////////////

static
void
   TScmServiceMain(
      DWORD                  argc         ,// in -number of arguments
      TCHAR               ** argv          // in -string argument array
   );

static
void
   TScmServiceCtrl(
      DWORD                  dwCtrlCode
   );

static
DWORD WINAPI                               // ret-OS return code
   TScmServiceWorker(
      void                 * notUsed       // i/o-not used
   );

static
BOOL                                       // ret-TRUE if successful
   TScmReportStatusToSCMgr(
      DWORD                  dwCurrentState,
      DWORD                  dwWin32ExitCode,
      DWORD                  dwCheckPoint,
      DWORD                  dwWaitHint
   );

///////////////////////////////////////////////////////////////////////////////
// Entry point from caller's 'main' function
///////////////////////////////////////////////////////////////////////////////

TScmEpRc                                   // TScmEp return code
   TScmEp(
      int                    argc         ,// in -argument count
      char          const ** argv         ,// in -argument array
      TCHAR                * nameService   // in -name of service
   )
{
   int                       argn;         // argument number

   SERVICE_TABLE_ENTRY       dispatchTable[] =
   {
      { nameService, (LPSERVICE_MAIN_FUNCTION) TScmServiceMain },
      { NULL, NULL }
   };

   gNameService = nameService;
   grcScmEp = TScmEpRc_Unknown;

   for ( argn = 1;
         argn < argc;
         argn++ )
   {
      if ( !UScmCmdLineArgs( argv[argn] ) )
      {
         grcScmEp = TScmEpRc_InvArgCli;
      }
   }

   if ( grcScmEp == TScmEpRc_Unknown )
   {
      if ( UScmForceCli() || !StartServiceCtrlDispatcher( dispatchTable ) )
      {
//         UScmEp( FALSE );
         UScmEp();
         grcScmEp = TScmEpRc_OkCli;
      }
      else
      {
         grcScmEp = TScmEpRc_OkSrv;
      }
   }

   return grcScmEp;
}

///////////////////////////////////////////////////////////////////////////////
// Mainline for service
///////////////////////////////////////////////////////////////////////////////

static
void
   TScmServiceMain(
      DWORD                  argc         ,// in -number of arguments
      TCHAR               ** argv          // in -string argument array
   )
{
   DWORD                     dwWait;
   DWORD                     idThread;
   HANDLE                    hThread=INVALID_HANDLE_VALUE;

   gArgc = argc;
   gArgv = argv;

   do // once or until break
   {
      ghServiceStatus = RegisterServiceCtrlHandler(
            gNameService,
            (LPHANDLER_FUNCTION) TScmServiceCtrl );
      if ( !ghServiceStatus )
      {
         break;
      }
      gServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
      gServiceStatus.dwServiceSpecificExitCode = 0;
      if ( !TScmReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 1,
            WAIT_HINT_MILLISECONDS ) )
      {
         break;
      }
      ghServDoneEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
      if ( ghServDoneEvent == INVALID_HANDLE_VALUE )
      {
         break;
      }
      if ( !TScmReportStatusToSCMgr( SERVICE_START_PENDING, NO_ERROR, 2,
            WAIT_HINT_MILLISECONDS ) )
      {
         break;
      }
      hThread = CreateThread( NULL, 0, TScmServiceWorker, NULL, 0, &idThread );
      if ( hThread == INVALID_HANDLE_VALUE )
      {
         break;
      }
      if ( !TScmReportStatusToSCMgr( SERVICE_RUNNING, NO_ERROR, 0, 0 ) )
      {
         break;
      }
      dwWait = WaitForSingleObject( ghServDoneEvent, INFINITE );
   }  while ( FALSE );

   if ( hThread != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hThread );
      hThread = INVALID_HANDLE_VALUE;
   }

   if ( ghServDoneEvent != INVALID_HANDLE_VALUE )
   {
      CloseHandle( ghServDoneEvent );
      ghServDoneEvent = INVALID_HANDLE_VALUE;
   }

   if ( ghServiceStatus )
   {
      TScmReportStatusToSCMgr( SERVICE_STOPPED, 0, 0, 0 );
   }
}

///////////////////////////////////////////////////////////////////////////////
// Service control handler
///////////////////////////////////////////////////////////////////////////////

static
void
   TScmServiceCtrl(
      DWORD                  dwCtrlCode
   )
{
   DWORD                     dwState = SERVICE_RUNNING;

   switch ( dwCtrlCode )
   {
      case SERVICE_CONTROL_STOP:
      case SERVICE_CONTROL_SHUTDOWN:
         dwState = SERVICE_STOP_PENDING;
         TScmReportStatusToSCMgr( SERVICE_STOP_PENDING, NO_ERROR, 1,
               WAIT_HINT_MILLISECONDS );
         SetEvent( ghServDoneEvent );
         return;
      case SERVICE_CONTROL_INTERROGATE:
         break;
      default:
         break;
   }

   TScmReportStatusToSCMgr( dwState, NO_ERROR, 0, 0 );
}

///////////////////////////////////////////////////////////////////////////////
// Service worker thread
///////////////////////////////////////////////////////////////////////////////

static
DWORD WINAPI                               // ret-OS return code
   TScmServiceWorker(
      void                 * notUsed       // i/o-not used
   )
{
   for ( DWORD i = 1;
         i < gArgc;
         i++ )
   {
      if ( !UScmCmdLineArgs( gArgv[i] ) )
      {
         grcScmEp = TScmEpRc_InvArgSrv;
      }
   }

   if ( grcScmEp != TScmEpRc_InvArgSrv )
   {
//      UScmEp( TRUE );
      UScmEp();
   }

   SetEvent( ghServDoneEvent );

   return 0;
}

///////////////////////////////////////////////////////////////////////////////
// Report status to Service Control Manager
///////////////////////////////////////////////////////////////////////////////

static
BOOL                                       // ret-TRUE if successful
   TScmReportStatusToSCMgr(
      DWORD                  dwCurrentState,
      DWORD                  dwWin32ExitCode,
      DWORD                  dwCheckPoint,
      DWORD                  dwWaitHint
   )
{
   BOOL                      bRc;          // boolean return code

   if ( dwCurrentState == SERVICE_START_PENDING )
   {
      gServiceStatus.dwControlsAccepted = 0;
   }
   else
   {
      gServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
   }

   gServiceStatus.dwCurrentState = dwCurrentState;
   gServiceStatus.dwWin32ExitCode = dwWin32ExitCode;
   gServiceStatus.dwCheckPoint = dwCheckPoint;
   gServiceStatus.dwWaitHint = dwWaitHint;
   bRc = SetServiceStatus( ghServiceStatus, &gServiceStatus );

   if ( !bRc )
   {
      SetEvent( ghServDoneEvent );
   }

   return bRc;
}

// TService.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\txtsid.cpp ===
/*---------------------------------------------------------------------------
  File: TextualSid.cpp

  Comments: Converts a SID to and from its canonical textual representation.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:33:52

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#endif
#include "Mcs.h"
#include "TxtSid.h"

BOOL 
   GetTextualSid(    
      PSID                   pSid,           // in - binary Sid
      LPTSTR                 TextualSid,     // i/o- buffer for Textual representation of Sid
      LPDWORD                lpdwBufferLen   // in - required/provided TextualSid buffersize    
   )
{
   PSID_IDENTIFIER_AUTHORITY psia;    
   DWORD                     dwSubAuthorities;
   DWORD                     dwSidRev=SID_REVISION;    
   DWORD                     dwCounter;    
   DWORD                     dwSidSize;
   
   // Validate the binary SID.    
   if(!IsValidSid(pSid)) 
      return FALSE;
   // Get the identifier authority value from the SID.
   psia = GetSidIdentifierAuthority(pSid);
   // Get the number of subauthorities in the SID.
   dwSubAuthorities = *GetSidSubAuthorityCount(pSid);
   // Compute the buffer length.
   // S-SID_REVISION- + IdentifierAuthority- + subauthorities- + NULL
   dwSidSize=(15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);
   
   // Check input buffer length.
   // If too small, indicate the proper size and set last error.
   if (*lpdwBufferLen < dwSidSize)    
   {        
      *lpdwBufferLen = dwSidSize;
      SetLastError(ERROR_INSUFFICIENT_BUFFER);        
      return FALSE;    
   }
   // Add 'S' prefix and revision number to the string.
   dwSidSize=wsprintf(TextualSid, TEXT("S-%lu-"), dwSidRev );
   // Add SID identifier authority to the string.
   if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) )    
   {
      dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                   TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                   (USHORT)psia->Value[0],
                   (USHORT)psia->Value[1],
                   (USHORT)psia->Value[2],
                   (USHORT)psia->Value[3],
                   (USHORT)psia->Value[4],
                   (USHORT)psia->Value[5]);    
   }    
   else    
   {
      dwSidSize+=wsprintf(TextualSid + lstrlen(TextualSid),
                   TEXT("%lu"),
                   (ULONG)(psia->Value[5]      )   +
                   (ULONG)(psia->Value[4] <<  8)   +
                   (ULONG)(psia->Value[3] << 16)   +
                   (ULONG)(psia->Value[2] << 24)   );    
   }
   // Add SID subauthorities to the string.    //
   for (dwCounter=0 ; dwCounter < dwSubAuthorities ; dwCounter++)    
   {
      dwSidSize+=wsprintf(TextualSid + dwSidSize, TEXT("-%lu"),
                   *GetSidSubAuthority(pSid, dwCounter) );    
   }    
   return TRUE;
} 

PSID                                       // ret- binary representation of SID, or NULL
   SidFromString(
      WCHAR          const * strSid        // in - string representation of SID
   )
{
   BOOL                      bSuccess = TRUE;
   PSID                      pSid = NULL;
   DWORD                     dwSidRev;
//   WCHAR                   * strPtr = NULL;
   WCHAR                     sidIA[100];
   WCHAR                     sidSubs[100];
   int                       ia0,ia1,ia2,ia3,ia4,ia5;
   SID_IDENTIFIER_AUTHORITY  sia;
   
   do 
   {
      if ( strSid[0] != L'S' || strSid[1] != L'-' )
      {
         bSuccess = FALSE;
         break;
      }
      // Read SID revision level
      sidSubs[0] = 0;
      int result = swscanf(strSid,L"S-%d-%[^-]-%ls",&dwSidRev,sidIA,sidSubs);
      if ( result == 3 )
      {
         // evaluate the IA
         if ( sidIA[1] == L'x' )
         {
            // full format
            result = swscanf(sidIA,L"0x%02hx%02hx%02hx%02hx%02hx%02hx",&ia0,&ia1,&ia2,&ia3,&ia4,&ia5);
            if ( result == 6 )
            {
               sia.Value[0] = (BYTE) ia0; 
               sia.Value[1] = (BYTE) ia1; 
               sia.Value[2] = (BYTE) ia2; 
               sia.Value[3] = (BYTE) ia3; 
               sia.Value[4] = (BYTE) ia4; 
               sia.Value[5] = (BYTE) ia5; 
               
            }
            else
            {
               bSuccess = FALSE;
               break;
            }
         }
         else
         {
            DWORD            bignumber;

            result = swscanf(sidIA,L"%lu",&bignumber);
            sia.Value[0] = 0;
            sia.Value[1] = 0;
            sia.Value[2] = BYTE( (bignumber & 0xff000000) >> 24);
            sia.Value[3] = BYTE( (bignumber & 0x00ff0000) >> 16);
            sia.Value[4] = BYTE( (bignumber & 0x0000ff00) >>  8);
            sia.Value[5] = BYTE(bignumber & 0x000000ff);
         }

         // read the subauthorities 
         DWORD           subs[10];

         memset(subs,0,(sizeof subs));

         result = swscanf(sidSubs,L"%lu-%lu-%lu-%lu-%lu-%lu-%lu-%lu",&subs[0],&subs[1],&subs[2],&subs[3],&subs[4],
                           &subs[5],&subs[6],&subs[7]);

         if ( result )
         {
            if ( !AllocateAndInitializeSid(&sia,(BYTE)result,subs[0],subs[1],subs[2],subs[3],subs[4],subs[5],subs[6],subs[7],&pSid) )
            {
               pSid = NULL;
               bSuccess = FALSE;
            }
         }
      }
   } while ( false);

      //see if IsValidSid also thinks this is valid
   if (pSid)
   {
	     //if not valid, free it and return NULL
      if (!IsValidSid(pSid))
	  {
		  FreeSid(pSid);
		  pSid = NULL;
	  }
   }

   return pSid;
}

/*****************************************************************************************************/
/*   DomainizeSid: 
         Takes a domain sid, and verifies that its last subauthority value is -1.  If the RID is not 
         -1, DomainizeSid adds a -1 to the end. 
/*****************************************************************************************************/
PSID                                            // ret -the sid with RID = -1
   DomainizeSid(
      PSID                   psid,               // in -sid to check and possibly fix
      BOOL                   freeOldSid          // in -whether to free the old sid 
   ) 
{
   MCSASSERT(psid);

   UCHAR                     len = (* GetSidSubAuthorityCount(psid));
   PDWORD                    sub = GetSidSubAuthority(psid,len-1);
   
   if ( *sub != -1 )
   {
      DWORD                  sdsize = GetSidLengthRequired(len+1);  // sid doesn't already have -1 as rid
      PSID                   newsid = (SID *)malloc(sdsize); // copy the sid, and add -1 to the end

      if (newsid)
      {
         if ( ! InitializeSid(newsid,GetSidIdentifierAuthority(psid),len+1) )  // make a bigger sid w/same IA
         {
            MCSASSERT(false);
         }
         for ( DWORD i = 0 ; i < len ; i++ )
         {
            sub = GetSidSubAuthority(newsid,i);                        // copy subauthorities
            (*sub) = (*GetSidSubAuthority(psid,i));
         }
         sub = GetSidSubAuthority(newsid,len);
         *sub = -1;                                                  // set rid =-1
         if ( freeOldSid )
         {
            FreeSid(psid);
         }
         psid = newsid;
         len++;
      }
   }
  return psid;   
}            

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for taking the given source and  *
 * target account SIDs and breaking them up and returning the src    *
 * domain sid, src account rid, tgt domain sid, and tgt account rid. *
 *     The caller must call "FreeSid" on the src and tgt domain sid   *
 * pointers.                                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN SplitAccountSids
BOOL                                            // ret - Success ? TRUE | FALSE
   SplitAccountSids(
      PSID					 srcSid,			// in - src account sid
	  WCHAR                 *srcDomainSid,		// out - src domain sid textual
	  DWORD                 *srcRid,			// out - src account rid
	  PSID                   tgtSid,			// in - tgt account sid
	  WCHAR                 *tgtDomainSid,		// out - tgt domain sid textual
	  DWORD                 *tgtRid				// out - tgt account rid
   )
{
/* local variables */
   DWORD    sidLen;
   UCHAR    Count;
   PDWORD   psubAuth;
   BOOL		bSuccess = TRUE;
   DWORD	lenTxt = MAX_PATH;
   
/* function body */
   if ((!IsValidSid(srcSid)) && (!IsValidSid(tgtSid)))
      return FALSE;

      //split up the src account sid
   sidLen = GetLengthSid(srcSid);
   PSID srcDomSid = new BYTE[sidLen+1];
   if (!srcDomSid)
	  return FALSE;

   if (!CopySid(sidLen+1, srcDomSid, srcSid))
   {
	  delete [] srcDomSid;
	  return FALSE;
   }

      //get the RID out of the SID and get the domain SID
   Count = (* GetSidSubAuthorityCount(srcDomSid));
   psubAuth = GetSidSubAuthority(srcDomSid, Count-1);
   if (psubAuth) 
   {
      *srcRid = *psubAuth;
      *psubAuth = -1;
   }
   
      //convert domain sid to text format
   if (srcDomSid)
   {
      GetTextualSid(srcDomSid,srcDomainSid,&lenTxt);
	  delete [] srcDomSid;
   }

     //split up the tgt account sid
   sidLen = GetLengthSid(tgtSid);
   PSID tgtDomSid = new BYTE[sidLen+1];
   if (!tgtDomSid)
	  return FALSE;
      
   if (!CopySid(sidLen+1, tgtDomSid, tgtSid))
   {
	  delete [] tgtDomSid;
	  return FALSE;
   }

      //get the RID out of the SID and get the domain SID
   Count = (* GetSidSubAuthorityCount(tgtDomSid));
   psubAuth = GetSidSubAuthority(tgtDomSid, Count-1);
   if (psubAuth) 
   {
      *tgtRid = *psubAuth;
      *psubAuth = -1;
   }
   
      //convert domain sid to text format
   lenTxt = MAX_PATH;
   if (tgtDomSid)
   {
      GetTextualSid(tgtDomSid,tgtDomainSid,&lenTxt);
	  delete [] tgtDomSid;
   }

   return bSuccess;
}
//END SplitAccountSids
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\agrpcutl.h ===
/*---------------------------------------------------------------------------
  File: AgentRpcUtil.h

  Comments: Functions to establish binding to DCT Agent service.
  These functions are used by the dispatcher, and the agent monitor 
  to bind to the agent service on remote machines.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/


// Create RPC binding for connection with DCT Agent
DWORD                                      // ret-OS return code
   EaxBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -authentication option
   );

DWORD                                      // ret-OS return code
   EaxBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\treg.cpp ===
//#pragma title( "TReg.cpp - NT registry class" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TReg.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-09-01
Description -  NT registry class.
Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "TNode.hpp"

#include "TReg.hpp"

// Short term solution
#define MAX_REG_NAMELEN    512
#define MAX_REG_VALUELEN   2048


// Destructor function was formerly inline.
// It is here to facilitate handle leak tracing.

   TRegKey::~TRegKey()
{
   Close();
};

// Close function was formerly inline.
// It is here to facilitate handle leak tracing.
void
   TRegKey::Close()
{
   if ( hKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey( hKey );
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

};

// open registry on remote computer
DWORD
   TRegKey::Connect(
      HKEY                  hPreDefined   ,// in -must be HKEY_LOCAL_MACHINE or HKEY_USERS
      TCHAR         const * machineName    // in -remote computer name
   )
{
   LONG                     rc;           // return code

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegConnectRegistry( const_cast<TCHAR *>(machineName), hPreDefined, &hKey );

   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// create new key
DWORD
   TRegKey::Create(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                * pDisp        ,// out-disposition of create
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     disp;
   LONG                      rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegCreateKeyEx( hParent,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       access,
                       NULL,
                       &hKey,
                       (pDisp!=NULL) ? pDisp : &disp );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// create new key (using backup/restore)
DWORD
   TRegKey::CreateBR(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                * pDisp        ,// out-disposition of create
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     disp;
   LONG                      rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegCreateKeyEx( hParent,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_BACKUP_RESTORE,
                       access,
                       NULL,
                       &hKey,
                       (pDisp!=NULL) ? pDisp : &disp );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// open existing key
DWORD
   TRegKey::Open(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                  access        // in -security access mask for key
   )
{
   LONG                      rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegOpenKeyEx( hParent,
                       keyname,
                       0,
                       access,
                       &hKey );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return (DWORD)rc;
}

// Gets the subkey value of the specified index number
DWORD                                      // ret-os return code
   TRegKey::SubKeyEnum(
      DWORD                  n            ,// in -ordinal number of subkey
      TCHAR                * keyname      ,// out-key name
      DWORD                  keylen        // in -max size of key name in TCHARs
   ) const
{
   LONG                      rc;
   DWORD                     keyLen = keylen;
   FILETIME                  lastWrite;

   rc = RegEnumKeyEx( hKey,
                      n,
                      keyname,
                      &keyLen,
                      0,
                      NULL,
                      NULL,
                      &lastWrite );

   return (DWORD)rc;
}

// Enumerate value
DWORD                                      // ret-0 or error code
   TRegKey::ValueEnum(
      DWORD                  index        ,// in -ordinal number of subkey
      TCHAR                * name         ,// out-name
      DWORD                  namelen      ,// in -name size in TCHARs
      void                 * value        ,// out-value
      DWORD                * valuelen     ,// i/o-value size in BYTEs
      DWORD                * type          // out-value type code
   ) const
{
   return (DWORD)RegEnumValue( hKey, index, name, &namelen, NULL, type, (BYTE *) value, valuelen );
}

// Get REG_DWORD value
DWORD                                      // ret-OS return code
   TRegKey::ValueGetDWORD(
      TCHAR          const * name         ,// in -value name
      DWORD                * value         // out-returned DWORD value
   ) const
{
   LONG                      osRc;         // OS return code
   DWORD                     type;         // type of value
   DWORD                     len = sizeof *value; // value length

   osRc = RegQueryValueEx( hKey, name, NULL, &type, (BYTE *) value, &len );

   if ( !osRc && (type != REG_DWORD) )
   {
      osRc = ERROR_FILE_NOT_FOUND;
   }

   return (DWORD)osRc;
}

// Get REG_SZ value
DWORD                                      // ret-OS return code
   TRegKey::ValueGetStr(
      TCHAR          const * name         ,// in -value name
      TCHAR                * value        ,// out-value buffer
      DWORD                  maxlen        // in -sizeof value buffer
   ) const
{
   LONG                      osRc;         // OS return code
   DWORD                     type;         // type of value
   DWORD                     len;          // value length

   // force maxlen to an integral number of TEXT characters
   maxlen = maxlen / (sizeof value[0]) * (sizeof value[0]);

   if ( !maxlen )
   {
      osRc = ERROR_FILE_NOT_FOUND;
   }
   else
   {
      len = maxlen;
      osRc = RegQueryValueEx( hKey, name, NULL, &type, (BYTE *) value, &len );
      len = len / (sizeof value[0]) * (sizeof value[0]);
      if ( !osRc && (type != REG_SZ) )
      {
         osRc = ERROR_FILE_NOT_FOUND;
      }
      if ( osRc )
      {
         value[0] = TEXT('\0');
      }
      else
      {  // return of a null-terminated string is not guaranteed by API!
         // force null-terminated string, truncate string if necessary.
         if ( len >= maxlen )
         {
            len = maxlen - sizeof value[0];
         }
         value[len/(sizeof value[0])] = TEXT('\0');
      }
   }

   return (DWORD)osRc;
}

DWORD
   TRegKey::ValueGet(
      TCHAR          const * name         ,// in -name
      void                 * value        ,// out-value
      DWORD                * lenvalue     ,// i/o-length of value
      DWORD                * typevalue     // out-type of value
   ) const
{
   return (DWORD)RegQueryValueEx( hKey, name, 0, typevalue, (UCHAR *) value, lenvalue );
}

// Set REG_SZ value
DWORD
   TRegKey::ValueSetStr(
      TCHAR          const * name         ,// in -value name
      TCHAR          const * value        ,// out-value
      DWORD                  type          // in -value type
   ) const
{
   return (DWORD)RegSetValueEx( hKey,
                         name,
                         NULL,
                         type,
                         (LPBYTE) value,
                         (UStrLen(value) + 1) * sizeof value[0] );
}

DWORD
   TRegKey::ValueSet(
      TCHAR          const * name         ,// in -name
      void           const * value        ,// in -value
      DWORD                  lenvalue     ,// in -length of value
      DWORD                  typevalue     // in -type of value
   ) const
{
   return (DWORD)RegSetValueEx( hKey,
                         name,
                         0,
                         typevalue,
                         (UCHAR const *) value,
                         lenvalue );
}

DWORD                                      // ret-0 or error code
   TRegKey::ValueDel(
      TCHAR          const * name          // in -value name
   ) const
{
   LONG                      rc;

   rc = (DWORD)RegDeleteValue(hKey, name);

   return rc;
}

DWORD                                      // ret-OS return code
   TRegKey::HiveCopy(
      TRegKey        const * source        // in -source hive
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // key/value index
   TCHAR                     name[MAX_REG_NAMELEN];    // key name
   TCHAR                     value[MAX_REG_VALUELEN];   // value name
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type
   TRegKey                   srcNest;      // nested source registry
   TRegKey                   trgNest;      // nested target registry

   // process values at this level
   for ( index = 0;
         !retval;
         index++ )
   {
      valuelen = sizeof value;
      retval = source->ValueEnum( index, name, MAX_REG_NAMELEN, value, &valuelen, &type );
      if ( !retval )
      {
         retval = this->ValueSet( name, value, valuelen, type );
      }
      else if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   // process keys at this level; for each key make a recursive call
   for ( index = 0;
         !retval;
         index++ )
   {
      retval = source->SubKeyEnum( index, name, MAX_REG_NAMELEN );
      if ( !retval )
      {
         retval = srcNest.Open( name, source );
         if ( !retval )
         {
            retval = trgNest.Create( name, this );
            if ( !retval )
            {
               retval = trgNest.HiveCopy( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

DWORD                                      // ret-OS return code
   TRegKey::HiveDel()
{
   DWORD                     retval = 0;   // returned value
   DWORD                     index;        // value/key index
   TCHAR                     name[MAX_REG_NAMELEN];    // name
   DWORD                     namelen;      // name length
   BYTE                      value[MAX_REG_VALUELEN];   // value
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type code
   TRegKey                   trgNest;      // nested target registry

   // delete values at this level
   for ( index = 0;
         !retval;
         /* index++ */ ) // note that index remains at zero
   {
      namelen = MAX_REG_NAMELEN;
      valuelen = sizeof value;
      retval = ValueEnum( index, name, namelen, value, &valuelen, &type );
      if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
      if ( !retval )
      {
         retval = ValueDel( name );
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   // process keys at this level; for each key make a recursive call
   for ( index = 0;
         !retval;
         /* index++ */ ) // note that index remains at zero
   {
      retval = SubKeyEnum( index, name, MAX_REG_NAMELEN );
      if ( !retval )
      {
         retval = trgNest.Open( name, this );
         if ( !retval )
         {
            retval = trgNest.HiveDel();
            trgNest.Close();
         }
         retval = SubKeyDel( name );
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// These four classes are used only by TRegReplicate
// Class to represent one registry key
class RKey : public TNode
{
   friend class RKeyList;
private:
   TCHAR                   * name;         // key name
protected:
public:
   RKey() { name = NULL; };
   ~RKey() { if ( name ) delete name; };
   BOOL New( TCHAR const * aname );
   TCHAR const * GetName() const { return name; };
};

BOOL
   RKey::New(
      TCHAR          const * aname         // in -key name
   )
{
   name = new TCHAR[UStrLen(aname)+1];

   if ( name )
   {
      UStrCpy( name, aname );
   }

   return !!name;
}

// Class to represent the set of registry keys at one level
class RKeyList : public TNodeListSortable
{
private:
   static TNodeCompare( Compare ) { return UStrICmp(
         ((RKey const *) v1)->name,
         ((RKey const *) v2)->name ); }
protected:
public:
   RKeyList() : TNodeListSortable( Compare ) {}
   ~RKeyList();
};

// RKeyList object destructor
   RKeyList::~RKeyList()
{
   DeleteAllListItems( RKey );
}

// Class to represent one registry value
class RValue : public TNode
{
   friend class RValueList;
private:
   TCHAR                   * name;         // value's name
   BYTE                    * value;        // value's value
   DWORD                     valuelen;     // value's value length
   DWORD                     type;         // value's type
protected:
public:
   RValue() { name = NULL; value = NULL; valuelen = type = 0; };
   ~RValue() { if ( name ) delete name;
               if ( value ) delete value; };
   BOOL New( TCHAR const * aname, BYTE const * avalue, DWORD valuelen, DWORD type );
   TCHAR const * GetName() const { return name; };
   BYTE const * GetValue() const { return value; };
   DWORD GetValueLen() const { return valuelen; };
   DWORD GetType() const { return type; };
};

BOOL
   RValue::New(
      TCHAR          const * aname        ,// in -value's name
      BYTE           const * avalue       ,// in -value's value
      DWORD                  avaluelen    ,// in -value's value length
      DWORD                  atype         // in -value's type
   )
{
   name = new TCHAR[UStrLen(aname)+1];

   if ( name )
   {
      UStrCpy( name, aname );
   }

   value = new BYTE[avaluelen];

   if ( value )
   {
      memcpy( value, avalue, avaluelen );
   }

   valuelen = avaluelen;
   type = atype;

   return name && value;
}

// Class to represent the set of registry values at one level
class RValueList : public TNodeListSortable
{
private:
   static TNodeCompare( Compare ) { return UStrICmp(
         ((RValue const *)v1)->name,
         ((RValue const *)v2)->name ); }
protected:
public:
   RValueList() : TNodeListSortable( Compare ) {}
   ~RValueList();
};

// RValueList object destructor
   RValueList::~RValueList()
{
   DeleteAllListItems( RValue );
}

// Static subroutine used only by TRegReplicate
// collect all values at one registry level into a RValueList
DWORD static
   CollectValues(
      RValueList           * pValueList   ,// out-value list to be built
      TRegKey        const * pRegKey       // in -registry key
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // value enum index
   TCHAR                     name[MAX_REG_NAMELEN];    // value name
   BYTE                      value[MAX_REG_VALUELEN];   // value value
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type
   RValue                  * pValue;       // new value

   for ( index = 0;
         !retval;
         index++ )
   {
      valuelen = sizeof value;
      retval = pRegKey->ValueEnum( index, name, MAX_REG_NAMELEN, value, &valuelen, &type );
      if ( !retval )
      {
         pValue = new RValue;
         if ( pValue )
         {
            if ( pValue->New( name, value, valuelen, type ) )
            {
               pValueList->Insert( pValue );
            }
            else
            {
               delete pValue;
               pValue = NULL;
            }
         }
         if ( !pValue )
         {
            retval = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
      else if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
   }
   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// Static subroutine used only by TRegReplicate
// collect all keys at one registry level into a RKeyList
DWORD static
   CollectKeys(
      RKeyList             * pKeyList     ,// out-key list to be built
      TRegKey        const * pRegKey       // in -registry key
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // key enum index
   TCHAR                     name[MAX_REG_NAMELEN];    // key name
   RKey                    * pKey;         // new key object

   for ( index = 0;
         !retval;
         index++ )
   {
      retval = pRegKey->SubKeyEnum( index, name, MAX_REG_NAMELEN );
      if ( !retval )
      {
         pKey = new RKey;
         if ( pKey )
         {
            if ( pKey->New( name ) )
            {
               pKeyList->Insert( pKey );
            }
            else
            {
               delete pKey;
               pKey = NULL;
            }
         }
         if ( !pKey )
         {
            retval = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// Replicate registry hive
DWORD                                      // ret-OS return code
   TRegKey::HiveReplicate(
      TRegKey        const * source        // in -source hive
   )
{
   DWORD                     retval=0;     // returned value
   RValueList                srcValues;    // source values
   RValueList                trgValues;    // target values
   TNodeListEnum             eSrcValue;    // enumerate source values
   RValue            const * pSrcValue;    // source value
   TNodeListEnum             eTrgValue;    // enumerate target values
   RValue            const * pTrgValue;    // target value
   RKeyList                  srcKeys;      // source keys
   RKeyList                  trgKeys;      // target keys
   TNodeListEnum             eSrcKey;      // enumerate source keys
   RKey              const * pSrcKey;      // source key
   TNodeListEnum             eTrgKey;      // enumerate target keys
   RKey              const * pTrgKey;      // target key
   int                       cmpRc;        // compare return code
   TRegKey                   srcNest;      // nested source registry
   TRegKey                   trgNest;      // nested target registry

   // handle replication of values at this level
   CollectValues( &srcValues, source );
   CollectValues( &trgValues, this );

   // now merge the values
   pSrcValue = (RValue const *) eSrcValue.OpenFirst( &srcValues );
   pTrgValue = (RValue const *) eTrgValue.OpenFirst( &trgValues );
   while ( !retval && (pSrcValue || pTrgValue) )
   {
      if ( !pTrgValue )
      {
         cmpRc = -1;
      }
      else if ( !pSrcValue )
      {
         cmpRc = 1;
      }
      else
      {
         cmpRc = UStrICmp( pSrcValue->GetName(), pTrgValue->GetName() );
      }
      if ( cmpRc < 0 )
      {  // source value only (copy)
         retval = this->ValueSet( pSrcValue->GetName(), pSrcValue->GetValue(),
               pSrcValue->GetValueLen(), pSrcValue->GetType() );
         pSrcValue = (RValue const *) eSrcValue.Next();
      }
      else if ( cmpRc > 0 )
      {  // target value only (delete)
         retval = this->ValueDel( pTrgValue->GetName() );
         pTrgValue = (RValue const *) eTrgValue.Next();
      }
      else /* if ( cmpRc == 0 ) */
      {  // identical value names (replicate)
         retval = this->ValueSet( pSrcValue->GetName(), pSrcValue->GetValue(),
               pSrcValue->GetValueLen(), pSrcValue->GetType() );
         pSrcValue = (RValue const *) eSrcValue.Next();
         pTrgValue = (RValue const *) eTrgValue.Next();
      }
   }

   eSrcValue.Close();
   eTrgValue.Close();

   // handle replication of keys at this level
   CollectKeys( &srcKeys, source );
   CollectKeys( &trgKeys, this );

   // now merge the values
   pSrcKey = (RKey const *) eSrcKey.OpenFirst( &srcKeys );
   pTrgKey = (RKey const *) eTrgKey.OpenFirst( &trgKeys );

   while ( !retval && (pSrcKey || pTrgKey) )
   {
      if ( !pTrgKey )
      {
         cmpRc = -1;
      }
      else if ( !pSrcKey )
      {
         cmpRc = 1;
      }
      else
      {
         cmpRc = UStrICmp( pSrcKey->GetName(), pTrgKey->GetName() );
      }
      if ( cmpRc < 0 )
      {  // source key only (copy hive)
         retval = srcNest.Open( pSrcKey->GetName(), source );
         if ( !retval )
         {
            retval = trgNest.Create( pSrcKey->GetName(), this );
            if ( !retval )
            {
               retval = trgNest.HiveCopy( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
         pSrcKey = (RKey const *) eSrcKey.Next();
      }
      else if ( cmpRc > 0 )
      {  // target key only (delete hive)
         retval = trgNest.Open( pTrgKey->GetName(), this );
         if ( !retval )
         {
            retval = trgNest.HiveDel();
            trgNest.Close();
         }
         retval = SubKeyDel( pTrgKey->GetName() );
         pTrgKey = (RKey const *) eTrgKey.Next();
      }
      else /* if ( cmpRc == 0 ) */
      {  // identical keys (replicate hive)
         retval = srcNest.Open( pSrcKey->GetName(), source );
         if ( !retval )
         {
            retval = trgNest.Open( pSrcKey->GetName(), this );
            if ( !retval )
            {
               retval = trgNest.HiveReplicate( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
         pSrcKey = (RKey const *) eSrcKey.Next();
         pTrgKey = (RKey const *) eTrgKey.Next();
      }
   }

   eSrcKey.Close();
   eTrgKey.Close();

   return retval;
}

// TReg.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\tnode.cpp ===
//#pragma title( "TNode.cpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      - TNode.cpp
System      - Common
Author      - Tom Bernhardt
Created     - 1989-11-19
Description - List/Tree base classes.
              TNode is a base class to define a collection element.  It
              contains a left and right pointer to another TNode item and
              these may be organized as a double-linked linear list or
              binary tree in the collection classes that use TNode items.

              Central to its utility are member functions to convert between
              binary tree, sorted 2-way linear linked lists, and unsorted 2-way
              linked linear lists.

 Collection and enum classes
   TNodeList         A simple collection of TNode elements.
   TNodeListSortable A TNodeList that is sortable by one or more compare functions.


 Conversion member functions for TNodeListSortable:
   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
Updates     -
1995-05-01 TPB Converted to C++ classes.
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include "TNode.hpp"
#include "common.hpp"


//#pragma page()
//------------------------------------------------------------------------------
// Warning: Must not pass top == NULL
//------------------------------------------------------------------------------
TNode *                                    // ret-head of sorted list
   TNodeListSortable::TreeToSortedList(
      TNode                * top          ,// i/o-top of [sub]tree to squash
      TNode               ** newhead      ,// out-leftmost branch from tree
      TNode               ** newtail       // out-rightmost branch from tree
   )
{
   TNode                   * temp;         // temporary pointer placeholder

   if ( top->left == NULL )
      *newhead = top;                      // this is leftmost of parent node
   else
   {
      TreeToSortedList(top->left, newhead, &temp);
      top->left = temp;                    // left = tail of sub-list
      top->left->right = top;
   }
   if ( top->right == NULL )
      *newtail = top;                      // tree is rightmost of parent node
   else
   {
      TreeToSortedList(top->right, &temp, newtail);
      top->right = temp;                   // right = head of sub-list
      top->right->left = top;
   }
   return *newhead;
}


//------------------------------------------------------------------------------
// converts sorted 2-linked list into balanced binary tree
//------------------------------------------------------------------------------
TNode *                                    // ret-middle of list (head of Btree)
   TNodeListSortable::ListSortedToTree(
      TNode                * top           // i/o-top of [sub]list to tree-ify
   )
{
   TNode                   * mid = top    ,// middle of list
                           * curr;
   int                       odd = 1;

   if ( top == NULL )
      return NULL;
   for ( curr = top;  curr;  curr = curr->right ) // find list middle
   {
      if ( odd ^= 1 )
         mid = mid->right;
   }
   if ( mid->left )                        // split list around mid point
   {
      mid->left->right = NULL;             // right terminate new sublist
      mid->left = ListSortedToTree(top);   // recursive call to set left side
   }
   if ( mid->right )
   {
      mid->right->left = NULL;             // left terminate new sublist
      mid->right = ListSortedToTree(mid->right);// recursive call to set right side
   }
   return mid;
}


//#pragma page()
TNode *                                    // ret-new head of tree
   TNodeListSortable::UnsortedToTree()
{
   TNode                   * treehead = NULL,
                           * tree,
                           * curr,
                           * next;

   MCSASSERTSZ( !IsTree(), "TNodeListSortable::UnsortedToTree - list is already a tree" );

   if ( !IsTree() )
   {
      for ( curr = head;  curr;  curr = next )// insert each node into BinTree
      {
         next = curr->right;                  // save right pointer
         curr->right = curr->left = NULL;     // break chains for insertion node
         if ( treehead == NULL )
            treehead = curr;                  // first node become BinTree head
         else
         {
            for ( tree = treehead;  ; )       // iterative BinTree insert algorithm
            {
               if ( PCompare(curr, tree) <=0 )// if belongs left of current node
                  if ( tree->left == NULL )   //    if left tree empty
                  {
                     tree->left = curr;       //       insert here
                     break;                   //       and process right node
                  }
                  else                        //    else
                     tree = tree->left;       //       go down left side 1 level
               else                           // must be right side
               {
                  if ( tree->right == NULL )
                  {
                     tree->right = curr;
                     break;
                  }
                  else
                     tree = tree->right;
               }
            }
         }
      }
      TypeSetTree();
   }
   return treehead;
}

//#pragma page()

//------------------------------------------------------------------------------
// comparison function used for scrambling a sorted linked list
//------------------------------------------------------------------------------
TNodeCompare(ScrambledCompare)
{
   return (rand() - RAND_MAX/2);
}

//------------------------------------------------------------------------------
// converts sorted 2-linked list into a scrambled random binary tree
//------------------------------------------------------------------------------
void
   TNodeListSortable::SortedToScrambledTree()
{
   MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToScrambledTree - list is already a tree" );

   if ( !IsTree() )
   {
      TNodeCompare((*pOldCompare));
      pOldCompare = PCompare;
      CompareSet(ScrambledCompare);
      UnsortedToTree();
      CompareSet(pOldCompare);
   }
}

//#pragma page()
TNodeList::~TNodeList()
{

// _ASSERTE( (count == 0) && (head == NULL) );

   if ( (count == 0) && (head == NULL) )
      ;
   else
   {
      //printf( "\aTNodeList destructor failure - list is not empty!\a\n" );
   }
}

void
   TNodeList::InsertTop(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = head;
   eIns->left  = NULL;
   if ( head )
      head->left = eIns;
   else
      tail = eIns;
   head = eIns;
   count++;
   return;
}

void
   TNodeList::InsertBottom(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = NULL;
   eIns->left  = tail;
   if ( tail )
      tail->right = eIns;
   else
      head = eIns;
   tail = eIns;
   count++;
   return;
}

void
   TNodeList::InsertAfter(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eAft          // i/o-element insert point
   )
{
   TNode                   * eFwd;         // element after inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eAft )
      InsertTop( eIns );
   else
   {
      eFwd = eAft->right;
      eIns->right = eFwd;
      eIns->left  = eAft;
      if ( eFwd )
         eFwd->left  = eIns;
      else
         tail = eIns;
      eAft->right = eIns;
      count++;
   }
}

void
   TNodeList::InsertBefore(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eBef          // i/o-element insert point
   )
{
   TNode                   * eBwd;         // element before inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eBef )
      InsertBottom( eIns );
   else
   {
      eBwd = eBef->left;
      eIns->right = eBef;
      eIns->left  = eBwd;
      if ( eBwd )
         eBwd->right = eIns;
      else
         head = eIns;
      eBef->left = eIns;
      count++;
   }
   return;
}

void
   TNodeList::Remove(
      TNode          const * t             // i/o-new node to remove from list but not delete
   )
{
   MCSVERIFY(this);
   MCSVERIFY(t);

   if ( t->left )
      t->left->right = t->right;
   else
      head = t->right;

   if ( t->right )
      t->right->left = t->left;
   else
      tail = t->left;
   count--;

   //Remove links to the list from t. We cant do this because
   // t is a const *
   //t->left = t->right = NULL;
}


void
   TNodeList::Reverse()
{
   TNode                   * node;
   TNode                   * swap;

   MCSVERIFY(this);

   for ( node = head;  node;  node = node->left )
   {
       swap        = node->left;
       node->left  = node->right;
       node->right = swap;
   }
   swap = head;
   head = tail;
   tail = swap;
}


TNode *
   TNodeList::Find(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr;

   MCSASSERT(this);

   for ( curr = head;  curr;  curr = curr->right )
   {
      if ( !Compare( curr, findval ) )
         break;
   }
   return curr;
}

BOOL                                       // ret-TRUE if valid
   TNodeListSortable::CountTree(
      TNode                * pCurrentTop  ,// i/o-top of [sub]tree to count nodes
      DWORD                * pCount        // i/o-Number of nodes encountered in the tree
   )
{
   if ( !pCurrentTop )
      return TRUE;

   (*pCount)++;

   if( (*pCount) > count )
      return FALSE;

   if(!CountTree(pCurrentTop->left,pCount))
      return FALSE;

   if(!CountTree(pCurrentTop->right,pCount))
      return FALSE;

   return TRUE;
}


BOOL                                       // TRUE if Valid and FALSE if not
   TNodeListSortable::ValidateTree()
{
   DWORD                     dwTempCount=0;
   DWORD                     bValid;

   MCSVERIFY(listType == TNodeTypeTree);

   bValid = CountTree(head,&dwTempCount);

   return bValid;
}

// Routine to validate the state of the list
DWORD
   TNodeList::Validate(
      TNode               ** pErrorNode
   )
{
   DWORD                     dwError=0;
   DWORD                     nNodesVisited=0;
   TNode                   * pCurrentNode;
   DWORD                     dwNodeCount = Count();

   if(pErrorNode)
      *pErrorNode = NULL;

#ifndef WIN16_VERSION
   try
   {
#endif
      pCurrentNode = head;

      if ( pCurrentNode)  // If the list is not empty
      {
         if ( pCurrentNode->left)
         {
            dwError = MCS_ListError_InvalidHead;
         }
         else
         {
            while ( pCurrentNode->right )
            {
               if(pCurrentNode->right->left != pCurrentNode)
               {
                  dwError = MCS_ListError_InvalidPtr;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
                  break;
               }

               nNodesVisited++;

               if ( nNodesVisited > dwNodeCount )
               {
                  dwError = MCS_ListError_InvalidCount;
                  break;
               }
               pCurrentNode = pCurrentNode->right;
            }

            if ( (!dwError) && (!pCurrentNode->right) )
            {
               if ( pCurrentNode != tail)
               {
                  dwError = MCS_ListError_InvalidTail;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
               }
            }
         }
      }
      else  // if the list is empty
      {
         if(dwNodeCount)
         {
            dwError = MCS_ListError_InvalidCount;
         }
      }
#ifndef WIN16_VERSION
   }
   catch(...)
   {
      dwError = MCS_ListError_Exception;
   }
#endif

   return dwError;
}

void
   TNodeListSortable::TreeRemove(
      TNode                * item          // i/o-node to remove from binary tree
   )
{
   TNode                  ** prevNext = &head,
                           * rep,
                           * repLeft,
                           * temp;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   while ( *prevNext )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
      {
         // we've found a matching 'name' (they compare equal)
         if ( *prevNext == item )
         {
            // we've found the address we're looking for
            if ( (*prevNext)->right )
            {
               rep = repLeft = (*prevNext)->right;
               for ( temp = rep->left;  temp;  temp = temp->left )
                  repLeft = temp;
               repLeft->left = (*prevNext)->left;
               temp = *prevNext;
               *prevNext = rep;
            }
            else
            {
               temp = *prevNext;
               *prevNext = (*prevNext)->left; // simple case
            }

            // break removed nodes links to existing tree
            temp->left = temp->right = NULL;
            count--;
            break;
         }
      }
   }
   return;
}

// returns the insert point in a sorted list for a prospective node
TNode *                                    // ret-insert before point or NULL
   TNodeListSortable::SortedFindInsertBefore(
      TNode                * item         ,// i/o-node to insert into TNode
      BOOL                 * exists        // out-TRUE if already exists
   )
{
   int                       c;
   TNode                   * curr;

   *exists = FALSE;
   if ( !lastInsert )
   {
      if ( !head )           // if null head, empty list, return NULL
         return NULL;
      lastInsert = head;
   }

   c = PCompare(item, lastInsert);
   if ( c < 0 )
      lastInsert = head;

   for ( curr = lastInsert;  curr;  curr = curr->right )
   {
      c = PCompare(item, curr);
      if ( c <= 0 )
         if ( c == 0 )
            *exists = TRUE;
         else
            break;
   }

   return curr;
}

// inserts node into sorted linear list
void
   TNodeListSortable::SortedInsert(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;

   MCSVERIFY(listType != TNodeTypeTree);

   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   InsertBefore(item, insertPoint);
   lastInsert = item;
}


BOOL
   TNodeListSortable::SortedInsertIfNew(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;
   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   if ( !exists )
   {
      InsertBefore(item, insertPoint);
      lastInsert = item;
   }
   return !exists;
}


void
   TNodeListSortable::TreeInsert(
      TNode                * item         ,// i/o-node to insert into binary tree
      short                * depth         // out-tree/recursion depth of new item
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp <= 0 )
         prevNext = &(*prevNext)->left;
      else
         prevNext = &(*prevNext)->right;
   }
   *prevNext = item;
   item->left = item->right = NULL;
   count++;
   return;
}


TNode *
   TNodeListSortable::TreeFind(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr = head;
   int                       cmp;

   while ( curr )
   {
      cmp = Compare( curr, findval );
      if ( cmp > 0 )
         curr = curr->left;
      else if ( cmp < 0 )
         curr = curr->right;
      else   // cmp == 0
         break;
   }
   return curr;
}


TNode *                                    // ret-TNode at pos n or NULL
   TNodeListOrdEnum::Get(
      long                   n             // in -new position
   )
{
   long                 disCurr = n - nCurr, // distance to curr
                        disTop  = n < (long)list->Count()/2 ? n : n - list->Count();

#ifdef WIN16_VERSION
   long absDisTop  = (disTop<0)  ? -disTop  : disTop;
   long absDisCurr = (disCurr<0) ? -disCurr : disCurr;
   if ( absDisTop < absDisCurr )
#else
   if ( abs(disTop) < abs(disCurr) )
#endif
   {
      Top();
      disCurr = disTop;
   }
   if ( disCurr < 0 )
      for ( Prev();  n < nCurr  &&  Prev(); );
   else
      for (       ;  n > nCurr  &&  Next(); );

   return curr;
}

// returns the first node of the tree
TNode *
   TNodeTreeEnum::First()
{
   if (stackBase)
   {
      stackPos = stackBase;
      if ( top )
         Push(top);
      return Next();
   }
   else
   {
      return NULL;
   }
}

// Returns the tree node logically following the value per the sort organization
// specified by Compare, and sets up the enumeration to continue from that point.
TNode *
   TNodeTreeEnum::FirstAfter(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void  const          * findVal       // in -findVal to position after
   )
{
   TNode                   * tn;
   int                       cmp;

   if (stackBase)
   {
      stackPos = stackBase;
      for ( tn = top;  tn;  )
      {
         Push(tn);
         cmp = Compare( tn, findVal );
         if ( cmp < 0 )
         {
            stackPos->state = Sright;
            if ( tn->right )
               tn = tn->right;
            else
               return Next();
         }
         else if ( cmp > 0 )
         {
            stackPos->state = Sleft;
            if ( tn->left )
               tn = tn->left;
            else
            {
               stackPos->state = Sused;
               return tn;
            }
         }
         else
         {
            stackPos->state = Sused;
            return Next();
         }
      }
   }

   return NULL;
}


// returns the Next logical node of the tree ending with NULL when complete
TNode *
   TNodeTreeEnum::Next()
{
   if (stackBase)
   {
      for ( ;; )
      {
         switch ( stackPos->state )
         {
            case Snone:                       // we've done nothing here
               stackPos->state = Sleft;
               if ( stackPos->save->left )
                  Push(stackPos->save->left);
               break;
            case Sleft:                       // we've gone left and are back
               stackPos->state = Sused;
               return stackPos->save;
            case Sused:                       // we've used the node
               stackPos->state = Sright;
               if ( stackPos->save->right )
                  Push(stackPos->save->right);// process right side of branch
               break;
            case Sright:                      // we've gone right and are back
               if ( !Pop() )
                  return NULL;
               break;
            case SComplete:
               return NULL;
               break;                         // Do we need this?
            default:                          // bad error
               MCSASSERT(FALSE);
               return NULL;
         }
      }
   }

   return NULL;
}

// Returns the address of the forward (left/right) pointer where the find node
// already exists or would be inserted.  If the singly deferenced result is not
// null, the node's key value already exists in the tree.
// If, after obtaining the insertion point, you want to insert the node, just
// assign its address to the singly deferenced return value.  The following inserts
// the node "f" if it is not alread in the tree:
//    TNode **r = tree.TreeFindInsert(f);
//    if ( !*r )
//       *r = f;
TNode **                                   // ret-pointer forward pointer to find
   TNodeListSortable::TreeFindInsert(
      TNode const          * find         ,// in -node to find
      short                * depth         // out-tree depth of insertion point
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( find, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
         break;
   }

   return prevNext;
}

// TNode.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\tsync.cpp ===
//#pragma title( "TSync.cpp - Common synchronization classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes
               TCriticalSection
               TSemaphoreNamed
Updates     -
===============================================================================
*/

#include <stdio.h>
#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <time.h>

#include "Common.hpp"
#include "Err.hpp"
#include "TSync.hpp"

///////////////////////////////////////////////////////////////////////////////
// TSemaphoreNamed member functions
///////////////////////////////////////////////////////////////////////////////

// Create named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Create(
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted     // out-TRUE=previously existed
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = CreateSemaphore( NULL, nInitial, nMaximum, sNameT );
   if ( handle == NULL )
   {
      rcOs = GetLastError();
   }
   else if ( pbExisted )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case 0:
            *pbExisted = FALSE;
            break;
         case ERROR_ALREADY_EXISTS:
            *pbExisted = TRUE;
            rcOs = 0;
            break;
         default:
            break;
      }
   }
   return rcOs;
}

// Open named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Open(
      TCHAR          const * sNameT        // in -semaphore name
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = OpenSemaphore( SEMAPHORE_ALL_ACCESS, FALSE, sNameT );
   if ( handle == NULL ) rcOs = GetLastError();
   return rcOs;
}

// Release semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Release(
      long                   nRelease      // in -number to release
   )
{
   DWORD                     rcOs;         // OS return code
   long                      nPrevious=0;  // previous count
   rcOs = ReleaseSemaphore( Handle(), nRelease, &nPrevious )
         ? 0 : GetLastError();
   return rcOs;
}


// TSync.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\admtcrypt.h ===
#pragma once

#include <TChar.h>
#include <Windows.h>
#include <WinCrypt.h>
#include <ComDef.h>


#define ENCRYPTION_KEY_SIZE 16 // in bytes
#define SESSION_KEY_SIZE    16 // in bytes


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------

class CCryptProvider
{
public:

	CCryptProvider();
	CCryptProvider(const CCryptProvider& r);
	~CCryptProvider();

	CCryptProvider& operator =(const CCryptProvider& r);

	HCRYPTHASH CreateHash(ALG_ID aid);
	HCRYPTKEY DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags = 0);

	_variant_t GenerateRandom(DWORD cbData) const;
	void GenerateRandom(BYTE* pbData, DWORD cbData) const;

protected:

	HCRYPTPROV m_hProvider;
};


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------

class CCryptKey
{
public:

	CCryptKey(HCRYPTKEY hKey = NULL);
	~CCryptKey();

	operator HCRYPTKEY()
	{
		return m_hKey;
	}

	void Attach(HCRYPTKEY hKey)
	{
		m_hKey = hKey;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hKey = m_hKey;
		m_hKey = NULL;
		return hKey;
	}

	_variant_t Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);
	_variant_t Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);

protected:

	CCryptKey(const CCryptKey& key) {}
	CCryptKey& operator =(const CCryptKey& key) { return *this; }

protected:

	HCRYPTKEY m_hKey;
};


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------

class CCryptHash
{
public:

	CCryptHash(HCRYPTHASH hHash = NULL);
	~CCryptHash();

	operator HCRYPTHASH()
	{
		return m_hHash;
	}

	void Attach(HCRYPTHASH hHash)
	{
		m_hHash = hHash;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hHash = m_hHash;
		m_hHash = NULL;
		return hHash;
	}

	_variant_t GetValue() const;
	void SetValue(const _variant_t& vntValue);

	void Hash(LPCTSTR pszData);
	void Hash(const _variant_t& vntData);
	void Hash(BYTE* pbData, DWORD cbData);

	bool operator ==(const CCryptHash& hash);

	bool operator !=(const CCryptHash& hash)
	{
		return !this->operator ==(hash);
	}

protected:

	CCryptHash(const CCryptKey& hash) {}
	CCryptHash& operator =(const CCryptHash& hash) { return *this; }

protected:

	HCRYPTHASH m_hHash;
};


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------

class CDomainCrypt : public CCryptProvider
{
protected:

	CDomainCrypt();
	~CDomainCrypt();

	HCRYPTKEY GetEncryptionKey(LPCTSTR pszKeyId);

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes);
	void StoreBytes(LPCTSTR pszId, BYTE* pBytes, DWORD cBytes);
	_variant_t RetrieveBytes(LPCTSTR pszId);

protected:

	static _TCHAR m_szIdPrefix[];
};


//---------------------------------------------------------------------------
// Target Crypt Class
//
// CreateEncryptionKey
// - creates encryption key
// - stores encryption key using key identifier
// - returns encryption key encrypted with given password
//---------------------------------------------------------------------------

class CTargetCrypt : public CDomainCrypt
{
public:

	CTargetCrypt();
	~CTargetCrypt();

	_variant_t CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword = NULL);

	_variant_t CreateSession(LPCTSTR pszKeyId);

	_variant_t Encrypt(_bstr_t strData);

protected:

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		CDomainCrypt::StoreBytes(psz, vntBytes);
	}

	_variant_t RetrieveBytes(LPCTSTR pszId)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		return CDomainCrypt::RetrieveBytes(psz);
	}

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------

class CSourceCrypt : public CDomainCrypt
{
public:

	CSourceCrypt();
	~CSourceCrypt();

	void ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword = NULL);

	void ImportSessionKey(const _variant_t& vntEncryptedKey);

	_bstr_t Decrypt(const _variant_t& vntData);

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Use Cases
//---------------------------------------------------------------------------
//
// Target Domain Controller
// ------------------------
// Generate Encryption Key
// - given source domain name and optional password
// - generate 128 bit encryption key
// - store encryption key using source domain name
// - if given optional password encrypt key with password
// - return encrypted key
//
// Generate Session Key
// - given source domain name
// - generate 128 bit session key
// - generate hash of session key
// - retrieve encryption key using source domain name
// - encrypt session key and hash with encryption key
// - return encrypted session key/hash
//
// Encrypt Data
// - given data
// - encrypt data using session key
// - return encrypted data
//
// Password Export Server (PES)
// ----------------------------
// Store Encryption Key
// - given encrypted encryption key and password
// - decrypt key using password
// - store key
//
// Decrypt Session Key
// - given an encrypted session key / hash
// - decrypt using encryption key
// - generate hash of decrypted session key
// - compare against decrypted hash
// - store session key
// - return success or failure
//
// Decrypt Data
// - given encrypted data
// - decrypt data using session key
// - return un-encrypted data
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\adsihelpers.h ===
#pragma once

#include <map>
#include <string>
#include <vector>
#include <ComDef.h>
#include <ActiveDS.h>

#ifndef tstring
typedef std::basic_string<_TCHAR> tstring;
#endif

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif
#ifndef IADsContainerPtr
_COM_SMARTPTR_TYPEDEF(IADsContainer, IID_IADsContainer);
#endif
#ifndef IADsUserPtr
_COM_SMARTPTR_TYPEDEF(IADsUser, IID_IADsUser);
#endif

#ifndef IADsADSystemInfoPtr
_COM_SMARTPTR_TYPEDEF(IADsADSystemInfo, IID_IADsADSystemInfo);
#endif
#ifndef IADsPathnamePtr
_COM_SMARTPTR_TYPEDEF(IADsPathname, IID_IADsPathname);
#endif

#ifndef IDirectoryObjectPtr
_COM_SMARTPTR_TYPEDEF(IDirectoryObject, IID_IDirectoryObject);
#endif
#ifndef IDirectorySearchPtr
_COM_SMARTPTR_TYPEDEF(IDirectorySearch, IID_IDirectorySearch);
#endif


//---------------------------------------------------------------------------
// CADs Class
//---------------------------------------------------------------------------


class CADs
{
public:

	CADs(IADsPtr spADs) :
		m_spADs(spADs)
	{
	}

	CADs(LPCTSTR pszADsPath = NULL)
	{
		if (pszADsPath)
		{
			CheckResult(ADsGetObject(pszADsPath, IID_IADs, (VOID**)&m_spADs));
		}
	}

	CADs(const CADs& r) :
		m_spADs(r.m_spADs)
	{
	}

	operator bool() const
	{
		return m_spADs;
	}

	operator IADs*() const
	{
		return m_spADs;
	}

	CADs& operator =(IADsPtr spADs)
	{
		m_spADs = spADs;
		return *this;
	}

	CADs& operator =(const CADs& r)
	{
		m_spADs = r.m_spADs;
		return *this;
	}

	_bstr_t GetName()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Name(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetClass()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Class(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetGUID()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_GUID(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetADsPath()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_ADsPath(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetParent()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Parent(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetSchema()
	{
		BSTR bstr;
		CheckResult(m_spADs->get_Schema(&bstr));
		return _bstr_t(bstr, false);
	}

	void GetInfo()
	{
		CheckResult(m_spADs->GetInfo());
	}

	void SetInfo()
	{
		CheckResult(m_spADs->SetInfo());
	}

	_variant_t Get(_bstr_t strName)
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADs->Get(strName, &vnt));
		return _variant_t(vnt, false);
	}

	void Put(_bstr_t strName, const _variant_t& vntValue)
	{
		CheckResult(m_spADs->Put(strName, vntValue));
	}

	_variant_t GetEx(_bstr_t strName)
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADs->GetEx(strName, &vnt));
		return _variant_t(vnt, false);
	}

	void PutEx(long lControlCode, _bstr_t strName, const _variant_t& vntValue)
	{
		CheckResult(m_spADs->PutEx(lControlCode, strName, vntValue));
	}

	void GetInfoEx(const _variant_t& vntProperties, long lReserved)
	{
		CheckResult(m_spADs->GetInfoEx(vntProperties, lReserved));
	}

protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_spADs), IID_IADs);
		}
	}

protected:

	IADsPtr m_spADs;
};


//---------------------------------------------------------------------------
// CADsContainer Class
//---------------------------------------------------------------------------


class CADsContainer : public CADs
{
protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_spADsContainer), IID_IADsContainer);
		}
	}

public:

	CADsContainer(IADsContainerPtr spADsContainer) :
		CADs(spADsContainer),
		m_spADsContainer(spADsContainer)
	{
	}

	CADsContainer(LPCTSTR pszADsPath = NULL) :
		CADs(pszADsPath)
	{
		m_spADsContainer = m_spADs;
	}

	CADsContainer(const CADsContainer& r) :
		CADs(r),
		m_spADsContainer(r.m_spADsContainer)
	{
	}

	operator bool() const
	{
		return m_spADsContainer;
	}

	operator IADsContainer*() const
	{
		return m_spADsContainer;
	}

	CADsContainer& operator =(IADsContainerPtr spADsContainer)
	{
		m_spADs = spADsContainer;
		m_spADsContainer = spADsContainer;
		return *this;
	}

	CADsContainer& operator =(const CADsContainer& r)
	{
		m_spADs = r.m_spADs;
		m_spADsContainer = r.m_spADsContainer;
		return *this;
	}

	long GetCount()
	{
		long l;
		CheckResult(m_spADsContainer->get_Count(&l));
		return l;
	}

	IUnknownPtr GetNewEnum()
	{
		IUnknown* punk;
		CheckResult(m_spADsContainer->get__NewEnum(&punk));
		return IUnknownPtr(punk, false);
	}

	_variant_t GetFilter()
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADsContainer->get_Filter(&vnt));
		return _variant_t(vnt, false);
	}

	void SetFilter(const _variant_t& vnt)
	{
		CheckResult(m_spADsContainer->put_Filter(vnt));
	}

	_variant_t GetHints()
	{
		VARIANT vnt;
		VariantInit(&vnt);
		CheckResult(m_spADsContainer->get_Hints(&vnt));
		return _variant_t(vnt, false);
	}

	void SetHints(const _variant_t& vnt)
	{
		CheckResult(m_spADsContainer->put_Hints(vnt));
	}

	IDispatchPtr GetObject(_bstr_t strClassName, _bstr_t strRelativeName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->GetObject(strClassName, strRelativeName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

	IDispatchPtr Create(_bstr_t strClassName, _bstr_t strRelativeName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->Create(strClassName, strRelativeName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

	void Delete(_bstr_t strClassName, _bstr_t strRelativeName)
	{
		CheckResult(m_spADsContainer->Delete(strClassName, strRelativeName));
	}

	IDispatchPtr CopyHere(_bstr_t strSourceName, _bstr_t strNewName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->CopyHere(strSourceName, strNewName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

	IDispatchPtr MoveHere(_bstr_t strSourceName, _bstr_t strNewName)
	{
		IDispatch* pdisp;
		CheckResult(m_spADsContainer->MoveHere(strSourceName, strNewName, &pdisp));
		return IDispatchPtr(pdisp, false);
	}

protected:

	IADsContainerPtr m_spADsContainer;
};


//---------------------------------------------------------------------------
// CADsUser Class
//---------------------------------------------------------------------------


class CADsUser : public CADs
{
public:

	CADsUser(IADsUserPtr spADsUser) :
		CADs(spADsUser),
		m_spADsUser(spADsUser)
	{
	}

	CADsUser(LPCTSTR pszADsPath = NULL) :
		CADs(pszADsPath)
	{
		m_spADsUser = m_spADs;
	}

	CADsUser(const CADsUser& r) :
		CADs(r),
		m_spADsUser(r.m_spADsUser)
	{
	}

	operator bool() const
	{
		return m_spADsUser;
	}

	operator IADsUser*() const
	{
		return m_spADsUser;
	}

	CADsUser& operator =(IADsUserPtr spADsUser)
	{
		m_spADs = spADsUser;
		m_spADsUser = spADsUser;
		return *this;
	}

	CADsUser& operator =(const CADsUser& r)
	{
		m_spADs = r.m_spADs;
		m_spADsUser = r.m_spADsUser;
		return *this;
	}

	_bstr_t GetBadLoginAddress()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_BadLoginAddress(&bstr));
		return _bstr_t(bstr, false);
	}

	DATE GetLastLogin()
	{
		DATE d;
		CheckResult(m_spADsUser->get_LastLogin(&d));
		return d;
	}

	DATE GetLastLogoff()
	{
		DATE d;
		CheckResult(m_spADsUser->get_LastLogoff(&d));
		return d;
	}

	DATE GetLastFailedLogin()
	{
		DATE d;
		CheckResult(m_spADsUser->get_LastFailedLogin(&d));
		return d;
	}

	DATE GetPasswordLastChanged()
	{
		DATE d;
		CheckResult(m_spADsUser->get_PasswordLastChanged(&d));
		return d;
	}

	_bstr_t GetDescription()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Description(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetDescription(_bstr_t strDescription)
	{
		CheckResult(m_spADsUser->put_Description(strDescription));
	}

	_bstr_t GetDivision()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Division(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetDivision(_bstr_t strDivision)
	{
		CheckResult(m_spADsUser->put_Division(strDivision));
	}

	_bstr_t GetDepartment()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Department(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetDepartment(_bstr_t strDepartment)
	{
		CheckResult(m_spADsUser->put_Department(strDepartment));
	}

	_bstr_t GetEmployeeId()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_EmployeeID(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetEmployeeId(_bstr_t strEmployeeId)
	{
		CheckResult(m_spADsUser->put_EmployeeID(strEmployeeId));
	}

	_bstr_t GetFullName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_FullName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetFullName(_bstr_t strFullName)
	{
		CheckResult(m_spADsUser->put_FullName(strFullName));
	}

	_bstr_t GetFirstName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_FirstName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetFirstName(_bstr_t strFirstName)
	{
		CheckResult(m_spADsUser->put_FirstName(strFirstName));
	}

	_bstr_t GetLastName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_LastName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetLastName(_bstr_t strLastName)
	{
		CheckResult(m_spADsUser->put_LastName(strLastName));
	}

	_bstr_t GetOtherName()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_OtherName(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetOtherName(_bstr_t strOtherName)
	{
		CheckResult(m_spADsUser->put_OtherName(strOtherName));
	}

	_bstr_t GetNamePrefix()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_NamePrefix(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetNamePrefix(_bstr_t strNamePrefix)
	{
		CheckResult(m_spADsUser->put_NamePrefix(strNamePrefix));
	}

	_bstr_t GetNameSuffix()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_NameSuffix(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetNameSuffix(_bstr_t strNameSuffix)
	{
		CheckResult(m_spADsUser->put_NameSuffix(strNameSuffix));
	}

	_bstr_t GetTitle()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Title(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetTitle(_bstr_t strTitle)
	{
		CheckResult(m_spADsUser->put_Title(strTitle));
	}

	_bstr_t GetManager()
	{
		BSTR bstr;
		CheckResult(m_spADsUser->get_Manager(&bstr));
		return _bstr_t(bstr, false);
	}

	void SetManager(_bstr_t strManager)
	{
		CheckResult(m_spADsUser->put_Manager(strManager));
	}
/*
        virtual HRESULT STDMETHODCALLTYPE get_TelephoneHome( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephoneHome( 
            VARIANT vTelephoneHome) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TelephoneMobile( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephoneMobile( 
            VARIANT vTelephoneMobile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TelephoneNumber( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephoneNumber( 
            VARIANT vTelephoneNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_TelephonePager( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_TelephonePager( 
            VARIANT vTelephonePager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_FaxNumber( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_FaxNumber( 
            VARIANT vFaxNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_OfficeLocations( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_OfficeLocations( 
            VARIANT vOfficeLocations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PostalAddresses( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PostalAddresses( 
            VARIANT vPostalAddresses) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PostalCodes( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PostalCodes( 
            VARIANT vPostalCodes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_SeeAlso( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SeeAlso( 
            VARIANT vSeeAlso) = 0;
*/
		bool GetAccountDisabled()
		{
			VARIANT_BOOL b;
			CheckResult(m_spADsUser->get_AccountDisabled(&b));
			return b ? true : false;
		}

		void SetAccountDisabled(bool bAccountDisabled)
		{
			CheckResult(m_spADsUser->put_AccountDisabled(bAccountDisabled ? VARIANT_TRUE : VARIANT_FALSE));
		}
/*
        virtual HRESULT STDMETHODCALLTYPE get_AccountExpirationDate( 
            DATE __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_AccountExpirationDate( 
            DATE daAccountExpirationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GraceLoginsAllowed( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_GraceLoginsAllowed( 
            long lnGraceLoginsAllowed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_GraceLoginsRemaining( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_GraceLoginsRemaining( 
            long lnGraceLoginsRemaining) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_IsAccountLocked( 
            VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_IsAccountLocked( 
            VARIANT_BOOL fIsAccountLocked) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LoginHours( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LoginHours( 
            VARIANT vLoginHours) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LoginWorkstations( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LoginWorkstations( 
            VARIANT vLoginWorkstations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MaxLogins( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MaxLogins( 
            long lnMaxLogins) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MaxStorage( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MaxStorage( 
            long lnMaxStorage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PasswordExpirationDate( 
            DATE __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PasswordExpirationDate( 
            DATE daPasswordExpirationDate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PasswordMinimumLength( 
            long __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PasswordMinimumLength( 
            long lnPasswordMinimumLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PasswordRequired( 
            VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PasswordRequired( 
            VARIANT_BOOL fPasswordRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_RequireUniquePassword( 
            VARIANT_BOOL __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_RequireUniquePassword( 
            VARIANT_BOOL fRequireUniquePassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_EmailAddress( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_EmailAddress( 
            BSTR bstrEmailAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_HomeDirectory( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_HomeDirectory( 
            BSTR bstrHomeDirectory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Languages( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Languages( 
            VARIANT vLanguages) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Profile( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Profile( 
            BSTR bstrProfile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_LoginScript( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_LoginScript( 
            BSTR bstrLoginScript) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Picture( 
            VARIANT __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_Picture( 
            VARIANT vPicture) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_HomePage( 
            BSTR __RPC_FAR *retval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_HomePage( 
            BSTR bstrHomePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Groups( 
            IADsMembers __RPC_FAR *__RPC_FAR *ppGroups) = 0;
*/
		void SetPassword(_bstr_t strNewPassword)
		{
			CheckResult(m_spADsUser->SetPassword(strNewPassword));
		}

		void ChangePassword(_bstr_t strOldPassword, _bstr_t strNewPassword)
		{
			CheckResult(m_spADsUser->ChangePassword(strOldPassword, strNewPassword));
		}

protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_spADsUser), IID_IADsUser);
		}
	}

protected:

	IADsUserPtr m_spADsUser;
};


//---------------------------------------------------------------------------
// CADsADSystemInfo Class
//---------------------------------------------------------------------------


class CADsADSystemInfo
{
public:

	CADsADSystemInfo() :
		m_sp(CLSID_ADSystemInfo)
	{
	}

	CADsADSystemInfo(IADsADSystemInfo* pADsADSystemInfo) :
		m_sp(pADsADSystemInfo)
	{
	}

	CADsADSystemInfo(const CADsADSystemInfo& r) :
		m_sp(r.m_sp)
	{
	}

	operator IADsADSystemInfo*() const
	{
		return m_sp;
	}

	_bstr_t GetUserName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_UserName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetComputerName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_ComputerName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetSiteName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_SiteName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetDomainShortName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_DomainShortName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetDomainDNSName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_DomainDNSName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetForestDNSName()
	{
		BSTR bstr;
		CheckResult(m_sp->get_ForestDNSName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetPDCRoleOwner()
	{
		BSTR bstr;
		CheckResult(m_sp->get_PDCRoleOwner(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetSchemaRoleOwner()
	{
		BSTR bstr;
		CheckResult(m_sp->get_SchemaRoleOwner(&bstr));
		return _bstr_t(bstr, false);
	}

	bool GetIsNativeMode()
	{
		VARIANT_BOOL b;
		CheckResult(m_sp->get_IsNativeMode(&b));
		return b ? true : false;
	}

	_bstr_t GetAnyDCName()
	{
		BSTR bstr;
		CheckResult(m_sp->GetAnyDCName(&bstr));
		return _bstr_t(bstr, false);
	}

	_bstr_t GetDCSiteName(_bstr_t strServer)
	{
		BSTR bstr;
		CheckResult(m_sp->GetDCSiteName(strServer, &bstr));
		return _bstr_t(bstr, false);
	}

	void RefreshSchemaCache()
	{
		CheckResult(m_sp->RefreshSchemaCache());
	}

	_variant_t GetTrees()
	{
		VARIANT vnt;
		CheckResult(m_sp->GetTrees(&vnt));
		return _variant_t(vnt, false);
	}

protected:

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_sp), IID_IADsADSystemInfo);
		}
	}

protected:

	IADsADSystemInfoPtr m_sp;
};


//---------------------------------------------------------------------------
// CADsPathName Class
//---------------------------------------------------------------------------


class CADsPathName
{
	// ADS_DISPLAY_ENUM
	// ADS_DISPLAY_FULL       = 1
	// ADS_DISPLAY_VALUE_ONLY = 2

	// ADS_FORMAT_ENUM
	// ADS_FORMAT_WINDOWS           =  1
	// ADS_FORMAT_WINDOWS_NO_SERVER =  2
	// ADS_FORMAT_WINDOWS_DN        =  3
	// ADS_FORMAT_WINDOWS_PARENT    =  4
	// ADS_FORMAT_X500              =  5
	// ADS_FORMAT_X500_NO_SERVER    =  6
	// ADS_FORMAT_X500_DN           =  7
	// ADS_FORMAT_X500_PARENT       =  8
	// ADS_FORMAT_SERVER            =  9
	// ADS_FORMAT_PROVIDER          = 10
	// ADS_FORMAT_LEAF              = 11

	// ADS_SETTYPE_ENUM
	// ADS_SETTYPE_FULL     = 1
	// ADS_SETTYPE_PROVIDER = 2
	// ADS_SETTYPE_SERVER   = 3
	// ADS_SETTYPE_DN       = 4
public:

	CADsPathName(_bstr_t strPath = _bstr_t(), long lSetType = ADS_SETTYPE_FULL) :
		m_sp(CLSID_Pathname)
	{
		if (strPath.length() > 0)
		{
			CheckResult(m_sp->Set(strPath, lSetType));
		}
	}

	void Set(_bstr_t strADsPath, long lSetType)
	{
		CheckResult(m_sp->Set(strADsPath, lSetType));
	}

	void SetDisplayType(long lDisplayType)
	{
		CheckResult(m_sp->SetDisplayType(lDisplayType));
	}

	_bstr_t Retrieve(long lFormatType)
	{
		BSTR bstr;
		CheckResult(m_sp->Retrieve(lFormatType, &bstr));
		return _bstr_t(bstr, false);
	}

	long GetNumElements()
	{
		long l;
		CheckResult(m_sp->GetNumElements(&l));
		return l;
	}

	_bstr_t GetElement(long lElementIndex)
	{
		BSTR bstr;
		CheckResult(m_sp->GetElement(lElementIndex, &bstr));
		return _bstr_t(bstr, false);
	}

	void AddLeafElement(_bstr_t strLeafElement)
	{
		CheckResult(m_sp->AddLeafElement(strLeafElement));
	}

	void RemoveLeafElement()
	{
		CheckResult(m_sp->RemoveLeafElement());
	}

	CADsPathName CopyPath()
	{
		IDispatch* pdisp;
		CheckResult(m_sp->CopyPath(&pdisp));
		return CADsPathName(IADsPathnamePtr(IDispatchPtr(pdisp, false)));
	}

	_bstr_t GetEscapedElement(long lReserved, _bstr_t strInStr)
	{
		BSTR bstr;
		CheckResult(m_sp->GetEscapedElement(lReserved, strInStr, &bstr));
		return _bstr_t(bstr, false);
	}

	long GetEscapedMode()
	{
		long l;
		CheckResult(m_sp->get_EscapedMode(&l));
		return l;
	}

	void PutEscapedMode(long l)
	{
		CheckResult(m_sp->put_EscapedMode(l));
	}

protected:

	CADsPathName(const CADsPathName& r) :
		m_sp(r.m_sp)
	{
	}

	CADsPathName(IADsPathnamePtr& r) :
		m_sp(r)
	{
	}

	void CheckResult(HRESULT hr)
	{
		if (FAILED(hr))
		{
			_com_issue_errorex(hr, IUnknownPtr(m_sp), IID_IADsPathname);
		}
	}

protected:

	IADsPathnamePtr m_sp;
};


//---------------------------------------------------------------------------
// Directory Attributes Class
//---------------------------------------------------------------------------


class CDirectoryAttributes :
	public std::map<tstring, _variant_t>
{
public:

	CDirectoryAttributes()
	{
	}

	//

	void AddAttribute(LPCTSTR pszName)
	{
		insert(value_type(tstring(pszName), _variant_t()));
	}

	void ClearValues()
	{
		for (iterator it = begin(); it != end(); it++)
		{
			it->second.Clear();
		}
	}

	const _variant_t& GetValue(LPCTSTR pszName) const
	{
		static _variant_t s_vntEmptyValue;

		const_iterator it = find(tstring(pszName));

		if (it != end())
		{
			return it->second;
		}
		else
		{
			return s_vntEmptyValue;
		}
	}

	void SetADsValue(LPCTSTR pszName, ADSTYPE atType, PADSVALUE pavValue, DWORD dwCount)
	{
		iterator it = find(tstring(pszName));

		if (it != end())
		{
			GetADsValue(atType, pavValue, dwCount, it->second);
		}
	}

protected:

	void GetADsValue(ADSTYPE atType, PADSVALUE pavValue, DWORD dwCount, _variant_t& vntValue)
	{
		switch (atType)
		{
			case ADSTYPE_DN_STRING:
			{
				vntValue = pavValue->DNString;
				break;
			}
			case ADSTYPE_CASE_EXACT_STRING:
			{
				if (dwCount == 1)
				{
					vntValue = pavValue->CaseExactString;
				}
				else
				{
					vntValue.vt = VT_ARRAY|VT_BSTR;
					vntValue.parray = SafeArrayCreateVector(VT_BSTR, 0, dwCount);

					PADSVALUE pav = pavValue;
					BSTR* pbstr = (BSTR*)vntValue.parray->pvData;

					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++, pav++)
					{
						*pbstr++ = SysAllocString(pav->CaseExactString);
					}
				}
				break;
			}
			case ADSTYPE_CASE_IGNORE_STRING:
			{
				if (dwCount == 1)
				{
					vntValue = pavValue->CaseIgnoreString;
				}
				else
				{
					vntValue.vt = VT_ARRAY|VT_BSTR;
					vntValue.parray = SafeArrayCreateVector(VT_BSTR, 0, dwCount);

					PADSVALUE pav = pavValue;
					BSTR* pbstr = (BSTR*)vntValue.parray->pvData;

					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++, pav++)
					{
						*pbstr++ = SysAllocString(pav->CaseIgnoreString);
					}
				}
				break;
			}
			case ADSTYPE_PRINTABLE_STRING:
			{
				vntValue = pavValue->PrintableString;
				break;
			}
			case ADSTYPE_NUMERIC_STRING:
			{
				vntValue = pavValue->NumericString;
				break;
			}
			case ADSTYPE_BOOLEAN:
			{
				vntValue = pavValue->Boolean ? true : false;
				break;
			}
			case ADSTYPE_INTEGER:
			{
				vntValue = static_cast<long>(pavValue->Integer);
				break;
			}
			case ADSTYPE_OCTET_STRING:
			{
				vntValue.vt = VT_ARRAY|VT_UI1;
				vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, pavValue->OctetString.dwLength);
				memcpy(vntValue.parray->pvData, pavValue->OctetString.lpValue, pavValue->OctetString.dwLength);
				break;
			}
			case ADSTYPE_UTC_TIME:
			{
				DATE dt;
				SystemTimeToVariantTime(&pavValue->UTCTime, &dt);
				vntValue = dt;
				vntValue.ChangeType(VT_DATE);
				break;
			}
		//	case ADSTYPE_LARGE_INTEGER:
			case ADSTYPE_OBJECT_CLASS:
			{
				if (dwCount == 1)
				{
					vntValue = pavValue->ClassName;
				}
				else
				{
					vntValue.vt = VT_ARRAY|VT_BSTR;
					vntValue.parray = SafeArrayCreateVector(VT_BSTR, 0, dwCount);

					PADSVALUE pav = pavValue;
					BSTR* pbstr = (BSTR*)vntValue.parray->pvData;

					for (DWORD dwIndex = 0; dwIndex < dwCount; dwIndex++, pav++)
					{
						*pbstr++ = SysAllocString(pav->ClassName);
					}
				}
				break;
			}
		//	case ADSTYPE_PROV_SPECIFIC:
		//	case ADSTYPE_CASEIGNORE_LIST:
		//	case ADSTYPE_OCTET_LIST:
		//	case ADSTYPE_PATH:
		//	case ADSTYPE_POSTALADDRESS:
		//	case ADSTYPE_TIMESTAMP:
		//	case ADSTYPE_BACKLINK:
		//	case ADSTYPE_TYPEDNAME:
		//	case ADSTYPE_HOLD:
		//	case ADSTYPE_NETADDRESS:
		//	case ADSTYPE_REPLICAPOINTER:
		//	case ADSTYPE_FAXNUMBER:
		//	case ADSTYPE_EMAIL:
			case ADSTYPE_NT_SECURITY_DESCRIPTOR:
			{
				ADS_NT_SECURITY_DESCRIPTOR& sd = pavValue->SecurityDescriptor;
				vntValue.vt = VT_ARRAY|VT_UI1;
				vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, sd.dwLength);
				memcpy(vntValue.parray->pvData, sd.lpValue, sd.dwLength);
				break;
			}
		//	case ADSTYPE_DN_WITH_BINARY:
		//	case ADSTYPE_DN_WITH_STRING:
			default:
			{
				vntValue.Clear();
				break;
			}
		}
	}
};


//---------------------------------------------------------------------------
// Directory Attributes Name Array Class
//---------------------------------------------------------------------------


class CDirectoryAttributesNameArray
{
public:

	CDirectoryAttributesNameArray(const CDirectoryAttributes& daAttributes) :
		m_ppszNames(NULL)
	{
		m_ppszNames = new LPTSTR[daAttributes.size()];

		if (m_ppszNames)
		{
			LPTSTR* ppsz = m_ppszNames;

			for (CDirectoryAttributes::const_iterator it = daAttributes.begin(); it != daAttributes.end(); it++)
			{
				*ppsz++ = const_cast<LPTSTR>(it->first.c_str());
			}
		}
		else
		{
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	~CDirectoryAttributesNameArray()
	{
		if (m_ppszNames)
		{
			delete [] m_ppszNames;
		}
	}

	operator LPTSTR*()
	{
		return m_ppszNames;
	}

protected:

	LPTSTR* m_ppszNames;
};


#define ATTRIBUTE_ADS_PATH _T("ADsPath")
#define ATTRIBUTE_CANONICAL_NAME _T("canonicalName")
#define ATTRIBUTE_DISTINGUISHED_NAME _T("distinguishedName")
#define ATTRIBUTE_NAME _T("name")
#define ATTRIBUTE_OBJECT_CATEGORY _T("objectCategory")
#define ATTRIBUTE_OBJECT_CLASS _T("objectClass")
#define ATTRIBUTE_OBJECT_SID _T("objectSid")
#define ATTRIBUTE_SAM_ACCOUNT_NAME _T("sAMAccountName")
#define ATTRIBUTE_USER_ACCOUNT_CONTROL _T("userAccountControl")
#define ATTRIBUTE_USER_PRINCIPAL_NAME _T("userPrincipalName")


//---------------------------------------------------------------------------
// Directory Object Class
//---------------------------------------------------------------------------


class CDirectoryObject
{
public:

	CDirectoryObject(LPCTSTR pszPath = NULL)
	{
		if (pszPath)
		{
			_com_util::CheckError(ADsGetObject(pszPath, IID_IDirectoryObject, (VOID**)&m_spObject));
		}
	}

	CDirectoryObject(IDispatchPtr spDispatch) :
		m_spObject(spDispatch)
	{
	}

	~CDirectoryObject()
	{
		if (m_spObject)
		{
			m_spObject.Release();
		}
	}

	CDirectoryObject& operator =(LPCTSTR pszPath)
	{
		_com_util::CheckError(ADsGetObject(pszPath, IID_IDirectoryObject, (VOID**)&m_spObject));

		return *this;
	}

	void AddAttribute(LPCTSTR pszName)
	{
		m_daAttributes.AddAttribute(pszName);
	}

	void GetAttributes()
	{
		PADS_ATTR_INFO pAttrInfo = NULL;

		try
		{
			// clear any existing attribute values

			m_daAttributes.ClearValues();

			// get attribute values

			DWORD cAttr;

			_com_util::CheckError(
				m_spObject->GetObjectAttributes(
					CDirectoryAttributesNameArray(m_daAttributes), m_daAttributes.size(), &pAttrInfo, &cAttr
				)
			);

			// assign attribute values to directory attributes

			PADS_ATTR_INFO pai = pAttrInfo;

			for (DWORD iAttr = 0; iAttr < cAttr; iAttr++, pai++)
			{
				m_daAttributes.SetADsValue(pai->pszAttrName, pai->dwADsType, pai->pADsValues, pai->dwNumValues);
			}

			// clean up

			if (pAttrInfo)
			{
				FreeADsMem(pAttrInfo);
			}
		}
		catch (...)
		{
			if (pAttrInfo)
			{
				FreeADsMem(pAttrInfo);
			}

			throw;
		}
	}

	const _variant_t& GetAttributeValue(LPCTSTR pszName)
	{
		return m_daAttributes.GetValue(pszName);
	}

protected:

	IDirectoryObjectPtr m_spObject;
	CDirectoryAttributes m_daAttributes;
};


//---------------------------------------------------------------------------
// DirectorySearch Class
//---------------------------------------------------------------------------


class CDirectorySearch
{
public:

	//

	CDirectorySearch() :
		m_hSearch(NULL)
	{
	}

	CDirectorySearch(IDispatchPtr spDispatch) :
		m_spSearch(spDispatch),
		m_hSearch(NULL)
	{
	}

	~CDirectorySearch()
	{
		CloseSearchHandle();
	}

	void operator =(const IDispatchPtr& spDispatch)
	{
		m_spSearch = spDispatch;
	}

	//

	void SetFilter(LPCTSTR pszFilter)
	{
		m_strFilter = pszFilter;
	}

	void SetPreferences(ADS_INTEGER nScope = ADS_SCOPE_SUBTREE)
	{
		ADS_SEARCHPREF_INFO siPreferences[4];

		siPreferences[0].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
		siPreferences[0].vValue.dwType = ADSTYPE_BOOLEAN;
		siPreferences[0].vValue.Integer = TRUE;

		siPreferences[1].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
		siPreferences[1].vValue.dwType = ADSTYPE_BOOLEAN;
		siPreferences[1].vValue.Integer = FALSE;

		siPreferences[2].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
		siPreferences[2].vValue.dwType = ADSTYPE_INTEGER;
		siPreferences[2].vValue.Integer = 100;

		siPreferences[3].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
		siPreferences[3].vValue.dwType = ADSTYPE_INTEGER;
		siPreferences[3].vValue.Integer = nScope;

		m_spSearch->SetSearchPreference(siPreferences, sizeof(siPreferences) / sizeof(siPreferences[0]));
	}

	void AddAttribute(LPCTSTR pszName)
	{
		m_daAttributes.AddAttribute(pszName);
	}

	void Search()
	{
		CloseSearchHandle();

		_com_util::CheckError(m_spSearch->ExecuteSearch(
			const_cast<LPTSTR>(m_strFilter.c_str()),
			CDirectoryAttributesNameArray(m_daAttributes),
			m_daAttributes.size(),
			&m_hSearch
		));
	}

	bool GetFirstRow()
	{
		bool bGet = false;

		HRESULT hr = m_spSearch->GetFirstRow(m_hSearch);

		if (FAILED(hr))
		{
			_com_issue_error(hr);
		}

		if (hr == S_OK)
		{
			GetColumns();

			bGet = true;
		}

		return bGet;
	}

	bool GetNextRow()
	{
		bool bGet = false;

		HRESULT hr = m_spSearch->GetNextRow(m_hSearch);

		if (FAILED(hr))
		{
			_com_issue_error(hr);
		}

		if (hr == S_OK)
		{
			GetColumns();

			bGet = true;
		}

		return bGet;
	}

	const _variant_t& GetAttributeValue(LPCTSTR pszName)
	{
		return m_daAttributes.GetValue(pszName);
	}

protected:

	void GetColumns()
	{
		for (CDirectoryAttributes::iterator it = m_daAttributes.begin(); it != m_daAttributes.end(); it++)
		{
			const tstring& strName = it->first;

			ADS_SEARCH_COLUMN scColumn;

			if (m_spSearch->GetColumn(m_hSearch, const_cast<LPTSTR>(strName.c_str()), &scColumn) == S_OK)
			{
				m_daAttributes.SetADsValue(strName.c_str(), scColumn.dwADsType, scColumn.pADsValues, scColumn.dwNumValues);

				m_spSearch->FreeColumn(&scColumn);
			}
			else
			{
				it->second.Clear();
			}
		}
	}

	void CloseSearchHandle()
	{
		if (m_hSearch)
		{
			m_spSearch->CloseSearchHandle(m_hSearch);

			m_hSearch = NULL;
		}
	}

protected:

	IDirectorySearchPtr m_spSearch;
	tstring m_strFilter;
	CDirectoryAttributes m_daAttributes;
	ADS_SEARCH_HANDLE m_hSearch;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\bkuprstr.hpp ===
//#pragma title( "BkupRstr.hpp - Get backup and restore privileges" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  BkupRstr.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-05-30
Description -  Get backup and restore privileges
Updates     -
===============================================================================
*/

#ifndef  MCSINC_BkupRstr_hpp
#define  MCSINC_BkupRstr_hpp

// Get backup and restore privileges using WCHAR machine name.
BOOL                                       // ret-TRUE if successful.
   GetBkupRstrPriv(
      WCHAR          const * sMachineW=NULL// in -NULL or machine name
   );

#endif  MCSINC_BkupRstr_hpp

// BkupRstr.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\validation.cpp ===
#include <TChar.h>
#include <ComDef.h>
#include <Windows.h>
#include <Validation.h>
#include <ResStr.h>


// IsValidPrefixOrSuffix Function

bool __stdcall IsValidPrefixOrSuffix(LPCTSTR pszPrefixOrSuffix)
{
	bool bValid = false;

	if (pszPrefixOrSuffix)
	{
		int cchPrefixOrSuffix = _tcslen(pszPrefixOrSuffix);

	//	if (cchPrefixOrSuffix <= MAXIMUM_PREFIX_SUFFIX_LENGTH)
	//	{
		//	BOOL bDefaultUsed;
		//	CHAR szAnsi[2 * MAXIMUM_PREFIX_SUFFIX_LENGTH];

		//	int cchAnsi = WideCharToMultiByte(
		//		CP_ACP,
		//		WC_NO_BEST_FIT_CHARS,
		//		pszPrefixOrSuffix,
		//		cchPrefixOrSuffix,
		//		szAnsi,
		//		sizeof(szAnsi) / sizeof(szAnsi[0]),
		//		NULL,
		//		&bDefaultUsed
		//	);

		//	if ((cchAnsi != 0) && (bDefaultUsed == FALSE))
		//	{
				_TCHAR szInvalidPunctuation[256];

				_bstr_t strInvalid(GET_WSTR(IDS_INVALID_PREFIX_SUFFIX));

				if (strInvalid.length() > 0)
				{
					_tcsncpy(szInvalidPunctuation, strInvalid, 255);
					szInvalidPunctuation[255] = _T('\0');
				}
				else
				{
					szInvalidPunctuation[0] = _T('\0');
				}

				WORD wCharType;

				bool bInvalidTypeFound = false;

				for (int i = 0; i < cchPrefixOrSuffix; i++)
				{
					if (GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, &pszPrefixOrSuffix[i], 1, &wCharType))
					{
						if (wCharType & C1_CNTRL)
						{
							bInvalidTypeFound = true;
							break;
						}

						if (wCharType & C1_PUNCT)
						{
							if (_tcschr(szInvalidPunctuation, pszPrefixOrSuffix[i]) != NULL)
							{
								bInvalidTypeFound = true;
								break;
							}
						}
					}
				}

				if (bInvalidTypeFound == false)
				{
					bValid = true;
				}
		//	}
	//	}
	}

	return bValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\arutil.hpp ===
/*---------------------------------------------------------------------------
  File: ARUtil.hpp

  Comments: Definitions for helper routines and command-line parsing for Account Replicator

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 6/23/98 4:31:22 PM

 ---------------------------------------------------------------------------
*/

#include "UserCopy.hpp"

int 
   CompVal(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   );

int 
   CompNode(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   );


int 
   CompSid(
      const TNode          * v1,      // in -first node to compare
      const TNode          * v2       // in -second node to compare
   );

int 
   CompSidVal(
      const TNode          * tn,     // in -node to compare
      const void           * pVal    // in -value to compare
   );


//------------------------------------------------------------------------------
// CopyServerName: Ensures that server name is in UNC form and checks its len
//------------------------------------------------------------------------------
DWORD
   CopyServerName(
      TCHAR                 * uncServ     ,// out-UNC server name
      TCHAR const           * server       // in -\\server or domain name
   );

BOOL                                      // ret-FALSE is addto: is not a group account
   AddToGroupResolveType(
      Options              * options      // i/o-options
   );


BOOL                                            // ret-TRUE if the password is successfully generated
   PasswordGenerate(
      Options const        * options,           // in  -includes PW Generating options
      WCHAR                * password,          // out -buffer for generated password
      DWORD                  dwPWBufferLength,  // in  -DIM length of password buffer
      BOOL                   isAdminAccount = FALSE // in  -Whether to use the Admin rules 
   );

//------------------------------------------------------------------------------
// ParseParms: parse out source & target servers plus any switches.
//------------------------------------------------------------------------------
BOOL                               // ret-TRUE=success
   ParseParms(
      TCHAR const         ** argv        ,// in -argument list
      Options              * options      // out-options
   );



PSID 
   GetWellKnownSid(
      DWORD                  wellKnownAccount,     // in - which well known account to get sid for (constants defined in UserCopy.hpp)
      Options              * opt,                  // in - options structure containing source and target domains
      BOOL                   bTarget = FALSE       // in - flag, whether to use source or target domain information
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\cipher.hpp ===
//#pragma title( "Cipher.hpp" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Cipher.hpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  19??-??-??
Description -
Updates     -
===============================================================================
*/

#ifndef  MCSINC_Cipher_hpp
#define  MCSINC_Cipher_hpp

void
   SimpleCipher(
      WCHAR                * str           // i/o-string to encrypt/decrypt
   );

void
   SimpleCipher(
      char unsigned        * str          ,// i/o-string to encrypt/decrypt
      int                    len           // in -length of string
   );

#endif  // MCSINC_Cipher_hpp

// Cipher.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\ealen.hpp ===
//#pragma title( "EaLen.hpp - EA defined length fields" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  EaLen.hpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1996-03-22
Description -  EA defined length fields
Updates     -
===============================================================================
*/

#ifndef  MCSINC_EaLen_hpp
#define  MCSINC_EaLen_hpp

// Definitions - object name lengths.
// These lengths include trailing null.
// These definitions are used to be independent of values in <lm.h>, which
// may not reflect the actual limits of all target operating systems.
// These values are also usually rounded up to a four byte boundary.
// The LEN_ values reflect the size reserved in structures for object names.
// The MAXLEN_ values reflect the actual valid maximum length imposed by EA.

#define  LEN_Computer                      (32)
#define  LEN_Domain                        (32)

#define  LEN_Account                       (260)
#define  LEN_Comment                       (260)
#define  LEN_Group                         (260)
#define  LEN_Member                        (260)
#define  LEN_Password                      (260)
#define  LEN_Path                          (1260)
#define  LEN_ShutdownMessage               (128)

#define  LEN_Sid                           (80)

#define  LEN_DistName                      (260)
#define  LEN_DisplayName                   (260)

#define  LEN_Guid                          (128)

#define  LEN_WTSPhoneNumber                (50)
#define  LEN_HomeDir                       (4)

// Definitions - maximum valid length of object name
// These lengths do NOT include trailing null.
// These definitions must always be smaller that the corresponding
// definitions above.

// Other EA defined constants
// type of account
#define  EA_AccountGGroup                        (0x00000001)
#define  EA_AccountLGroup                        (0x00000002)
#define  EA_AccountUser                          (0x00000004)
#define  EA_AccountUcLGroup                      (0x00000008)

#define  EA_AccountGroup                         (EA_AccountGGroup|EA_AccountLGroup)
#define  EA_AccountAll                           (EA_AccountGroup|EA_AccountUser)


#endif  // MCSINC_EaLen_hpp

// EaLen.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\extseq.h ===
#ifndef EXT_SEQ_H
#define EXT_SEQ_H

#define AREXT_EARLIER_SEQUENCE_NUMBER        (100)
#define AREXT_DEFAULT_SEQUENCE_NUMBER        (200)
#define AREXT_LATER_SEQUENCE_NUMBER          (300)

#define AREXT_SEQUENCE_NUMBER_DisAcct        (6000)
#define AREXT_SEQUENCE_NUMBER_RidSave        (2000)
#define AREXT_SEQUENCE_NUMBER_UpdtModel      (9000)
#define AREXT_SEQUENCE_NUMBER_PwdCopy        (3000)
#define AREXT_SEQUENCE_NUMBER_SvcAcct        (4000)
#define AREXT_SEQUENCE_NUMBER_ScriptEng      (11000)
#define AREXT_SEQUENCE_NUMBER_SetPass        (5000)
#define AREXT_SEQUENCE_NUMBER_CleanupSid     (7000)
#define AREXT_SEQUENCE_NUMBER_SkipUser       (1000)
#define AREXT_SEQUENCE_NUMBER_StoreInfo      (10000)
#define AREXT_SEQUENCE_NUMBER_UPNUpdt        (8000)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\commalog.hpp ===
#ifndef __COMMALOG_HPP__
#define __COMMALOG_HPP__
/*---------------------------------------------------------------------------
  File: CommaLog.hpp

  Comments: TError based log file with optional security.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 10:49:50

 ---------------------------------------------------------------------------
*/

#include <stdio.h>
#include <tchar.h>

class CommaDelimitedLog
{
protected:
   FILE                    * fptr;
public:
   CommaDelimitedLog() { fptr = NULL; }
   BOOL IsOpen() const { return ( fptr != NULL ); }
   BOOL LogOpen(TCHAR const * filename, BOOL protect, int mode = 0); // mode 0=overwrite, 1=append

   virtual void         LogClose() { if ( fptr ) fclose(fptr); }
   BOOL MsgWrite(
      TCHAR           const   msg[]        ,// in -error message to display
       ...                                  // in -printf args to msg pattern
   ) const
   {
      TCHAR                     suffix[350];
      int                       lenSuffix = sizeof(suffix)/sizeof(TCHAR);
      va_list                   argPtr;

      va_start(argPtr, msg);
      _vsntprintf(suffix, lenSuffix - 1, msg, argPtr);
      suffix[lenSuffix - 1] = '\0';
      va_end(argPtr);
      return LogWrite(suffix);
   }

protected:
   BOOL LogWrite(TCHAR const * msg) const
   {
      int res = -1;

      if ( fptr )
      {
#ifdef UNICODE 
         res = fwprintf(
                        fptr,
                        L"%s\r\n",
                         msg );
#else
         res = fprintf(
                        fptr,
                        "%s\n",
                         msg );

#endif
         fflush( fptr );
      }
      return ( res >= 0 );
   }
   
};

PSID GetWellKnownSid(DWORD wellKnownAccount);

#endif //__COMMALOG_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\errdct.hpp ===
#ifndef __ERRDCT_HPP__
#define __ERRDCT_HPP__
/*---------------------------------------------------------------------------
  File: ErrDct.hpp

  Comments: TError derived class that specifies a numeric code for each message 
  format.  The goal is to make it easy to convert this to a real message file 
  later.

  This class also improves on the behavior of the TError class by returning text
  for HRESULT error codes.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 13:04:51

 ---------------------------------------------------------------------------
*/
#include <comdef.h>
#include "Err.hpp"
#include "Common.hpp"
#include "UString.hpp"    
#include "McsDmMsg.h"

// These codes are passed as the messageNumber argument to MsgWrite and SysMsgWrite.


// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   );

class TErrorDct : public TError
{
public:
   TErrorDct(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
      ) : TError(displevel,loglevel,NULL,logmode,beeplevel)
   {}
   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );   

   WCHAR const * LookupMessage(UINT msgNumber);

   virtual void __cdecl
   SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   );

   virtual void __cdecl
   MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

   void __cdecl
      DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      );

   virtual BOOL         LogOpen(
      WCHAR          const * fileName          ,// in -name of file including any path
      int                    mode = 0          ,// in -0=overwrite, 1=append
      int                    level = 0         ,// in -minimum level to log
      bool                   bBeginNew = false  // in -begin a new log file
   )
   {
      WCHAR                  directory[MAX_PATH];

      safecopy(directory,fileName);

      WCHAR                * x = wcsrchr(directory,'\\');
      
      if ( x )
      {
         (*x) = 0;
         DirectoryCreateR(directory);
      }
      
      return TError::LogOpen(fileName,mode,level,bBeginNew);
   }

   _bstr_t __cdecl
   GetMsgText(
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

};

#endif //__ERRDCT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );

#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\helpalias.h ===
IDH_INTRO_DOMAIN_MIGRATOR=DomMigIntro.htm

IDH_HOWTO_OVERVIEW=TasksOverview.htm
IDH_HOWTO_START_DM=TasksStartDM.htm
IDH_HOWTO_MIGRATE_TRUSTS=TasksManageTrusts.htm
IDH_HOWTO_MERGE_GROUPS=TasksMergeGroups.htm
IDH_HOWTO_MIGRATE_USERS=TasksMigrateAccounts.htm
IDH_HOWTO_MIGRATE_GROUPS=TasksMigrateGroups.htm
IDH_HOWTO_MIGRATE_COMPUTERS=TasksMigrateComputers.htm
IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS=TasksMigrateServAccts.htm
IDH_HOWTO_RESOLVE_SECURITY=TasksTranslateSecurity.htm
IDH_HOWTO_RESOLVE_EXCHANGE=TasksTranslateExchange.htm
IDH_HOWTO_RETRY_TASK=TasksRetry.htm
IDH_HOWTO_UNDO_LAST_OPERATION=TasksUndoLast.htm
IDH_HOWTO_GENERATE_REPORTS=TasksGenerateReports.htm

IDH_CONCEPT_OVERVIEW=ConceptOverview.htm
IDH_CONCEPT_REQUIREMENT=ConceptDomMigRequirements.htm
IDH_CONCEPT_SECURITY_ISSUE=ConceptDomMigSecurityIssues.htm
IDH_CONCEPT_ACCOUNT_MIGRATION=ConceptAccountMigration.htm
IDH_CONCEPT_COMPUTER_MIGRATION=ConceptComputerMigration.htm
IDH_CONCEPT_SECURITY_TRANSLATION=ConceptSecurityTranslationIssues.htm
IDH_CONCEPT_EXCHANGE_TRANSLATION=ConceptExchangeTranslationIssues.htm
IDH_CONCEPT_TRUST_MIGRATION=ConceptTrustMigration.htm
IDH_CONCEPT_UNDERSTAND_UI=ConceptUnderstandingIntro.htm
IDH_CONCEPT_UI_CONSOLE_WINDOW=ConceptUnderstandingConsole.htm
IDH_CONCEPT_UI_MENUS=ConceptUnderstandingMenus.htm

IDH_WINDOW_OVERVIEW=WindowOverview.htm
IDH_WINDOW_WELCOME=WindowWelcome.htm
IDH_WINDOW_DOMAIN_SELECTION=WindowDomainSelect.htm
IDH_WINDOW_USER_SELECTION=WindowUserSelect.htm
IDH_WINDOW_GROUP_SELECTION=WindowGroupSelect.htm
IDH_WINDOW_TARGET_GROUP_SELECTION=WindowTargetGroupSelect.htm
IDH_WINDOW_COMPUTER_SELECTION=WindowComputerSelect.htm
IDH_WINDOW_TASK_SELECTION=WindowTaskSelect.htm
IDH_WINDOW_DIRECTORY_SELECTION=WindowDirectorySelect.htm
IDH_WINDOW_OU_SELECTION=WindowOUSelect.htm
IDH_WINDOW_OBJECTTYPE_SELECTION=WindowObjectTypeSelect.htm
IDH_WINDOW_REPORT_SELECTION=WindowReportSelect.htm
IDH_WINDOW_SERVICE_ACCOUNT_SELECTION=WindowServiceAccountSelect.htm
IDH_WINDOW_EXCHANGE_SERVER_SELECTION=WindowExchangeServerSelect.htm
IDH_WINDOW_PASSWORD_OPTION=WindowPasswordOption.htm
IDH_WINDOW_ACCOUNTTRANSITION_OPTION=WindowAccountTransitionOption.htm
IDH_WINDOW_USER_OPTION=WindowUserOption.htm
IDH_WINDOW_GROUP_OPTION=WindowGroupOption.htm
IDH_WINDOW_GROUP_MEMBER_OPTION=WindowGroupMemberOption.htm
IDH_WINDOW_SECURITY_OPTION=WindowSecurityOption.htm
IDH_WINDOW_COMPUTER_OPTION=WindowComputerOption.htm
IDH_WINDOW_EXCHANGE_OPTION=WindowExchangeOption.htm
IDH_WINDOW_NAME_CONFLICT=WindowNameConflict.htm
IDH_WINDOW_SECURITY_CREDENTIALS=WindowSecurityCredential.htm
IDH_WINDOW_REPORT_CREDENTIALS=WindowReportCredential.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS=WindowSIDHistoryCredential.htm
IDH_WINDOW_AGENT_MONITOR=WindowAgentOverview.htm
IDH_WINDOW_AGENT_MONITOR_SETTING=WindowAgentMonSettings.htm
IDH_WINDOW_AGENT_SERVER_LIST=WindowAgentMonServers.htm
IDH_WINDOW_AGENT_SUMMARY=WindowAgentMonSummary.htm
IDH_WINDOW_CONFIRMATION=WindowConfirmation.htm
IDH_WINDOW_COMMIT=WindowCommitChanges.htm
IDH_WINDOW_REFRESH_INFO=WindowRefreshInfo.htm
IDH_WINDOW_SERVICE_ACCOUNT_INFO=WindowServiceAccountInfo.htm
IDH_WINDOW_TRUST_INFO=WindowTrustInfo.htm
IDH_WINDOW_UNDO=WindowUndo.htm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\helpid.h ===
#define IDH_INTRO_DOMAIN_MIGRATOR                 1000

#define IDH_HOWTO_OVERVIEW                        2000
#define IDH_HOWTO_START_DM                        2010
#define IDH_HOWTO_MIGRATE_TRUSTS                  2015
#define IDH_HOWTO_MERGE_GROUPS                    2017
#define IDH_HOWTO_MIGRATE_USERS                   2020
#define IDH_HOWTO_MIGRATE_GROUPS                  2030
#define IDH_HOWTO_MIGRATE_COMPUTERS               2040
#define IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS        2045
#define IDH_HOWTO_RESOLVE_SECURITY                2050
#define IDH_HOWTO_RESOLVE_EXCHANGE                2060
#define IDH_HOWTO_RETRY_TASK                      2070
#define IDH_HOWTO_UNDO_LAST_OPERATION             2080
#define IDH_HOWTO_GENERATE_REPORTS                2090

#define IDH_CONCEPT_OVERVIEW                      3000
#define IDH_CONCEPT_REQUIREMENT                   3010
#define IDH_CONCEPT_SECURITY_ISSUE                3020
#define IDH_CONCEPT_ACCOUNT_MIGRATION             3030
#define IDH_CONCEPT_COMPUTER_MIGRATION            3040
#define IDH_CONCEPT_SECURITY_TRANSLATION          3050
#define IDH_CONCEPT_EXCHANGE_TRANSLATION          3060
#define IDH_CONCEPT_TRUST_MIGRATION               3070
#define IDH_CONCEPT_UNDERSTAND_UI                 3100
#define IDH_CONCEPT_UI_CONSOLE_WINDOW             3110
#define IDH_CONCEPT_UI_MENUS                      3120

#define IDH_WINDOW_OVERVIEW                       4000
#define IDH_WINDOW_WELCOME                        4010
#define IDH_WINDOW_DOMAIN_SELECTION               4020
#define IDH_WINDOW_USER_SELECTION                 4030
#define IDH_WINDOW_GROUP_SELECTION                4040
#define IDH_WINDOW_TARGET_GROUP_SELECTION         4045
#define IDH_WINDOW_COMPUTER_SELECTION             4050
#define IDH_WINDOW_TASK_SELECTION                 4060
#define IDH_WINDOW_DIRECTORY_SELECTION            4070
#define IDH_WINDOW_OU_SELECTION                   4080
#define IDH_WINDOW_OBJECTTYPE_SELECTION           4090
#define IDH_WINDOW_REPORT_SELECTION               4100
#define IDH_WINDOW_SERVICE_ACCOUNT_SELECTION      4110
#define IDH_WINDOW_EXCHANGE_SERVER_SELECTION      4120
#define IDH_WINDOW_PASSWORD_OPTION                4200
#define IDH_WINDOW_ACCOUNTTRANSITION_OPTION       4210
#define IDH_WINDOW_USER_OPTION                    4220
#define IDH_WINDOW_GROUP_OPTION                   4230
#define IDH_WINDOW_GROUP_MEMBER_OPTION            4235
#define IDH_WINDOW_SECURITY_OPTION                4240
#define IDH_WINDOW_COMPUTER_OPTION                4250
#define IDH_WINDOW_EXCHANGE_OPTION                4260
#define IDH_WINDOW_NAME_CONFLICT                  4300
#define IDH_WINDOW_SECURITY_CREDENTIALS           4310
#define IDH_WINDOW_REPORT_CREDENTIALS             4320
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS         4330
#define IDH_WINDOW_AGENT_MONITOR                  4500
#define IDH_WINDOW_AGENT_MONITOR_SETTING          4510
#define IDH_WINDOW_AGENT_SERVER_LIST              4520
#define IDH_WINDOW_AGENT_SUMMARY                  4530
#define IDH_WINDOW_CONFIRMATION                   5000
#define IDH_WINDOW_COMMIT                         5010
#define IDH_WINDOW_REFRESH_INFO                   5020
#define IDH_WINDOW_SERVICE_ACCOUNT_INFO           5030
#define IDH_WINDOW_TRUST_INFO                     5040
#define IDH_WINDOW_UNDO                           5050
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\err.hpp ===
//#pragma title( "Err.hpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Err_hpp
#define  MCSINC_Err_hpp

// Start of header file dependencies

#ifndef  MCSINC_Common_hpp
#include "Common.hpp"
#endif

// End of header file dependencies

// ErrMsg error level constants
#define ErrT            (00000 - __LINE__) // Testing
#define ErrI            (00000) // Information
#define ErrW            (10000) // Warning
#define ErrE            (20000) // Error
#define ErrS            (30000) // Severe error
#define ErrV            (40000) // Very sever error
#define ErrU            (50000) // Unrecoverable error
#define ErrX            (60000) // extremely unrecoverable <g>

#define ErrNone         (0)

class TError
{
protected:
   int                       level;
   int                       lastError;
   int                       maxError;
   int                       logLevel;     // minimum level to log
   int                       dispLevel;    // minimum level to display
   FILE                    * logFile;
   int                       beepLevel;
public:
                        TError(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      WCHAR          const * filename = L"",// in -file name of log (NULL if none)
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
                                             //     Some people dont like the beeps so we turned it off by default.

                        );
                        ~TError();

   void __cdecl         MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   );
#ifndef WIN16_VERSION

   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
#endif

   void __stdcall       MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   );

   virtual void __stdcall StrWrite(int level, WCHAR const * str) const { if (level >= dispLevel) wprintf(L"%s\n", str); };

   virtual BOOL         LogOpen(
      WCHAR          const * fileName          ,// in -name of file including any path
      int                    mode = 0          ,// in -0=overwrite, 1=append
      int                    level = 0         ,// in -minimum level to log
      bool                   bBeginNew = false  // in -begin a new log file
   );
   virtual void         LogClose() { if ( logFile ) fclose(logFile); };
   virtual void         LogWrite(WCHAR const * msg);
   void                 LevelSet(int displevel=0, int loglevel=-1, int beeplevel=2)
                           { dispLevel = displevel; logLevel = loglevel; beepLevel = beeplevel; };
   void                 LevelDispSet(int  displevel=0)
                           { dispLevel = displevel; };
   void                 LevelLogSet(int  loglevel=-1)
                           { logLevel = loglevel; };
   void                 LevelBeepSet(int  beeplevel=-1)
                           { beepLevel = beeplevel; };
   DWORD                MaxError()  const { return maxError; };
   DWORD                LastError() const { return lastError; };

   int                  GetMaxSeverityLevel () { return maxError / 10000; }

   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );
};

extern TError              & errCommon;

#endif  // MCSINC_Err_hpp

// Err.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\hrmsg.h ===
#ifndef  MCSINC_HrMsg_h
#define  MCSINC_HrMsg_h

#include <string>
#include <tchar.h>
#include <comdef.h>

/******************************************************************
 *                                                                *
 * Header file for common error handling functions.               *
 *                                                                *
 ******************************************************************/

_bstr_t __stdcall HResultToText(HRESULT hr);
_bstr_t __stdcall HResultToText2(HRESULT hr);
_bstr_t FormatHRMsg(LPCTSTR pformatStr, HRESULT hr);
_com_error GetError(HRESULT hr);
void __cdecl AdmtThrowError(_com_error ce, LPCTSTR pszFormat = NULL, ...);
void __cdecl AdmtThrowError(_com_error ce, HINSTANCE hInstance, UINT uId, ...);

#endif // MCSINC_HrMsg_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\mcs.h ===
//---------------------------------------------------------------------------
// MCS.h 
//
// Main header file for all MCS applications.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_Mcs_h
#define MCSINC_Mcs_h
#ifdef __cplusplus

// Mandatory Pragma Definitions.
// #pragma warning( 3 : 4706 ) // assignment within if, while, etc.

// Header Files Common To All MCS Modules.
#include "McsDebug.h"   // contains debug macros, it depends on
                        // the following files: McsDebug.cpp,
                        // McsDebugUtil.h and McsDebugUtil.cpp.

#endif /* __cplusplus */
#endif /* MCSINC_Mcs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\migrationmutex.h ===
#pragma once


#define ADMT_MUTEX _T("{9DC80865-6CC7-4988-8CC0-2AC5CA01879C}")
#define AGENT_MUTEX _T("{E2624042-8C80-4A83-B3DF-2B840DE366E5}")
#define DISPATCHER_MUTEX _T("{7C84F7DB-CF48-4B59-99D8-6B5A95276DBD}")


//---------------------------------------------------------------------------
// MigrationMutex Class
//
// This class may be used to prevent more than one instance of a migration
// task to run at the same time.
//
//
// Revision
// Initial	01/26/01 Mark Oluper
//---------------------------------------------------------------------------

class CMigrationMutex
{
public:

	CMigrationMutex(LPCTSTR pszMutexName, bool bObtainOwnership = false) :
		m_hMutex(CreateMutex(NULL, FALSE, pszMutexName))
	{
		if (bObtainOwnership)
		{
			ObtainOwnership();
		}
	}

	~CMigrationMutex()
	{
		if (m_hMutex)
		{
			ReleaseOwnership();
			CloseHandle(m_hMutex);
		}
	}

	bool ObtainOwnership(DWORD dwTimeOut = INFINITE)
	{
		bool bObtain = false;

		if (m_hMutex)
		{
			if (WaitForSingleObject(m_hMutex, dwTimeOut) == WAIT_OBJECT_0)
			{
				bObtain = true;
			}
		}

		return bObtain;
	}

	void ReleaseOwnership()
	{
		if (m_hMutex)
		{
			ReleaseMutex(m_hMutex);
		}
	}

protected:

	HANDLE m_hMutex;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\isadmin.hpp ===
//#pragma title( "IsAdmin.hpp - Determine if user is administrator" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  IsAdmin.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-06-04
Description -  Determine if user is administrator (local or remote)
Updates     -
===============================================================================
*/

#ifndef  MCSINC_IsAdmin_hpp
#define  MCSINC_IsAdmin_hpp

// Determine if user is administrator on local machine
DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminLocal();

// Determine if user is administrator on remote machine
DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminRemote(
      WCHAR          const * pMachine      // in -\\machine name
   );

#endif  // MCSINC_IsAdmin_hpp

// IsAdmin.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h
//
// The debug macros and support classes are declared in
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The
// usage of these macros is outlined in the MCS Coding
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.
// In the debug mode these macros are the same as
// MCSASSERT(SZ).  In the release mode they throw an
// exception McsException The usage of these macros is
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.
// In the debug mode these macros are the same as
// MCSASSERT(SZ).  In the release mode they log the
// message using McsVerifyLog class.  The usage of these
// macros is outlined in the MCS Coding Standards document.
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.
// The output log file is created in the directory
// defined by MCS_LOG environment variable, or in the
// TEMP directory, or in the current directory.  The name
// of the output log file is <module name>.err.
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// -------------------------------
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      int getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// -------------------------------
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException
// -----------------
inline McsDebugException::McsDebugException ()
: m_message (0), m_fileName (0), m_lineNum (0)
{ /* EMPTY */ }

inline McsDebugException::~McsDebugException() {
   delete [] m_message;
   delete [] m_fileName;
}

inline const char *McsDebugException::getMessage
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void)
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void)
: m_isTested (FALSE), m_isTestMode_ (FALSE)
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\lsautils.h ===
/*---------------------------------------------------------------------------
  File: LSAUtils.h

  Comments: Utility functions to change the domain affiliation of a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/


#include "ntsecapi.h"

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_OBJECT_NAME_NOT_FOUND    ((NTSTATUS)0xC0000034L)
#define STATUS_OBJECT_NAME_COLLISION    ((NTSTATUS)0xC0000035L)
#define STATUS_INVALID_SID              ((NTSTATUS)0xC0000078L)
#endif


BOOL
   GetDomainDCName(
      LPWSTR                 Domain,       // in - domain name
      LPWSTR               * pPrimaryDC    // out- PDC name
    );

BOOL
   EstablishNullSession(
      LPCWSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=connect,FALSE=disconnect
    );

void
   InitLsaString(
      PLSA_UNICODE_STRING    LsaString,   // in - pointer to LSA string to initialize
      LPWSTR                 String       // in - value to initialize string to
    );

NTSTATUS
   OpenPolicy(
      LPWSTR                 ComputerName,   // in - computer name
      DWORD                  DesiredAccess,  // in - required access
      PLSA_HANDLE            PolicyHandle    // out- policy handle
    );

BOOL
   GetDomainSid(
      LPWSTR                 DomainName,   // in - domain name to acquire Sid of
      PSID                 * pDomainSid    // out- points to allocated Sid on success
    );

NTSTATUS
   SetWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - Sid of domain to manipulate
      LPWSTR                 TrustedDomainName,    // in - trusted domain name to add/update
      LPWSTR                 Password,             // in - new trust password for trusted domain
      LPWSTR                 errOut                // out- error text, if failure
    );

NTSTATUS
   SetPrimaryDomain(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - SID for new primary domain
      LPWSTR                 TrustedDomainName     // in - name of new primary domain
    );

void  
   QueryWorkstationTrustedDomainInfo(
       LSA_HANDLE            PolicyHandle,   // in - policy handle
       PSID                  DomainSid,      // in - SID for new primary domain
       BOOL                  bNoChange       // in - flag, no change mode
   );


BOOL
   EstablishSession(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Domain,       // in - domain for Username account
      LPWSTR                 Username,     // in - username to connnect as
      LPWSTR                 Password,     // in - password for Username account
      BOOL                   bEstablish    // in - TRUE=connect, FALSE=disconnect
    );

BOOL
   EstablishShare(
      LPCWSTR                Server,      // in - server name
      LPWSTR                 Share,       // in - share name to connect to
      LPWSTR                 Domain,      // in - domain for credentials
      LPWSTR                 UserName,    // in - username to connect as
      LPWSTR                 Password,    // in - password for credentials
      BOOL                   bEstablish   // in - TRUE=connect, FALSE=disconnect
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\names.hpp ===
/*---------------------------------------------------------------------------
  File: Names.hpp

  Comments: Definitions for helper functions for name modifying and converting

 ---------------------------------------------------------------------------*/

// removes invalid characters, such as ( ) from SAM account name
void 
   StripSamName(
      WCHAR                * samName              // i/o - SAM account name to process
   );

_bstr_t
   GetDomainDNSFromPath(
      _bstr_t				 sPath				  // in - path of object
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\pwgen.hpp ===
/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generate a password from the rules provided.
// Returns ERROR_SUCCESS if successful, else ERROR_INVALID_PARAMETER.
// If successful, the new password is returned in the supplied buffer.
// The buffer must be long enough to hold the minimum length password
//   that is required by the rules, plus a terminating NULL.

// Password generation service
#define PWGEN_MIN_LENGTH    8    // enforced minimum password length
#define PWGEN_MAX_LENGTH   14    // enforced maximum password length

DWORD __stdcall                            // ret-EA/OS return code
   EaPasswordGenerate(
      DWORD                  dwMinUC,              // in -minimum upper case chars
      DWORD                  dwMinLC,              // in -minimum lower case chars
      DWORD                  dwMinDigits,          // in -minimum numeric digits
      DWORD                  dwMinSpecial,         // in -minimum special chars
      DWORD                  dwMaxConsecutiveAlpha,// in -maximum consecutive alpha chars
      DWORD                  dwMinLength,          // in -minimum length
      WCHAR                * newPassword,          // out-returned password
      DWORD                  dwBufferLength        // in -returned area buffer length
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\resstr.h ===
#ifndef RES_STRING_H
#define RES_STRING_H
#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "TSync.hpp"

#define MAX_STRING_SIZE          (5000)
#include "Mcs.h"
#include "McsRes.h"
#include "UString.hpp"

class StringLoader
{
   HINSTANCE                 m_hInstance; // handle to resources to load from
   TCriticalSection          m_cs;
   WCHAR                     m_buffer[MAX_STRING_SIZE];
   DWORD                     rc;
public:
   StringLoader() 
   { 
      WCHAR                  fullpath[400];
      DWORD                  lenValue = sizeof(fullpath);
      DWORD                  type;
	  LONG					 lRet = 0;
         // first, try to load from our install directory
      HKEY           hKey;
#ifdef OFA         
      lRet = RegOpenKey((HKEY)HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\OnePointFileAdmin",&hKey);
#else
      lRet = RegOpenKey((HKEY)HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\DomainAdmin",&hKey);
#endif
      if ( !lRet )
      {
         
         lRet = RegQueryValueEx(hKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
         if (!lRet )
         {
            UStrCpy(fullpath+UStrLen(fullpath),L"McsDmRes.DLL");
         }
         RegCloseKey(hKey);
      }
      m_hInstance = LoadLibrary(fullpath);

      // If that fails, see if there's one anywhere in the path
      if ( ! m_hInstance )
      {
         m_hInstance = LoadLibrary(L"McsDmRes.DLL");
      }
      if (! m_hInstance ) 
      {
         MCSASSERTSZ(FALSE,"Failed to load McsDmRes.DLL");
         rc = GetLastError(); 
      }
   }

   WCHAR                   * GetString(UINT nID)
   {
      int                    len;
      WCHAR                * result = NULL;

      m_cs.Enter();
      m_buffer[0] = 0;
      len = LoadString(m_hInstance,nID,m_buffer,MAX_STRING_SIZE);
      if (! len )
      {
//         DWORD               rc = GetLastError();
         GetLastError();
      }
      result = new WCHAR[len+1];
	  if (!result)
	     return NULL;
      wcscpy(result,m_buffer);
      m_cs.Leave();

      return result;
   }
};
          
extern StringLoader gString;
  
class TempString
{
   WCHAR                   * m_data;
public:
   TempString(WCHAR * data) { m_data = data; }
   ~TempString() { if ( m_data ) delete [] m_data; }
   operator WCHAR * () { return m_data; }
   operator WCHAR const * () { return (WCHAR const*)m_data; }
};

//#define GET_BSTR(nID) _bstr_t(SysAllocString(GET_STRING(nID)),false)
#define GET_BSTR(nID)   _bstr_t((WCHAR*)TempString(gString.GetString(nID)))

#define GET_STRING(nID) GET_STRING2(gString,nID)

#define GET_STRING2(strObj,nID) TempString(strObj.GetString(nID))

#define GET_WSTR(nID) ((WCHAR*)TempString(gString.GetString(nID)))
#endif RES_STRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\pwdfuncs.h ===
#ifndef __PASSWORDFUNCTIONS_H__
#define __PASSWORDFUNCTIONS_H__
/*---------------------------------------------------------------------------
  File: PwdFuncs.h

  Comments: Contains general password migration helper functions.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 11/08/00 

  ---------------------------------------------------------------------------
*/

        
_bstr_t EnumLocalDrives();
void StoreDataToFloppy(LPCWSTR sPath, _variant_t & varData);
_variant_t GetDataFromFloppy(LPCWSTR sPath);
char* GetBinaryArrayFromVariant(_variant_t varData);
_variant_t SetVariantWithBinaryArray(char * aData, DWORD dwArray);
DWORD GetVariantArraySize(_variant_t & varData);
void PrintVariant(const _variant_t & varData);
#endif //__PASSWORDFUNCTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\pwrpcutl.h ===
/*---------------------------------------------------------------------------
  File: PwdRpcUtil.h

  Comments: Functions to establish binding to Password Migration Lsa 
  Notifications packages.  These functions are used by the password extension 
  to bind to the password migration Lsa notification package on remote source 
  domain DCs.
    This files was copied from AgRpcUtil.h, which was created by Christy Boles
  of NetIQ Corporation.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/04/00

 ---------------------------------------------------------------------------
*/


// Create RPC binding for connection with a remote Lsa notification package Dll
DWORD                                      // ret-OS return code
   PwdBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -authentication option
   );

DWORD                                      // ret-OS return code
   PwdBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\secpi.h ===
/*---------------------------------------------------------------------------
  File: SecPI.h

  Comments: Structure definition for the structure used for challenge/response
  authentication of our plug ins.  The dispatcher sends this structure to each 
  plug-in before adding the plug-in to the list of plug-ins to be dispatched.  
  The plug-in must modify this structure in the correct way, and return it to 
  the dispatcher.  This will make it more difficult for others to use our 
  undocumented plug-in interface.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:33:52

 ---------------------------------------------------------------------------
*/
#pragma once

typedef struct 
{
   long                      lTime;
   long                      lRand1;
   long                      lRand2;
   char                      MCS[4];
}McsChallenge;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\sd.hpp ===
/*---------------------------------------------------------------------------
  File: SD.hpp

  Comments: A generic class for managing security descriptors. 
  The constructor takes a security descriptor in self-relative format.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 01-Oct-98 12:30:26

 ---------------------------------------------------------------------------
*/
#include <stdlib.h>
#include <malloc.h>

#define SD_DEFAULT_STRUCT_SIZE (sizeof (SECURITY_DESCRIPTOR) )
#define SD_DEFAULT_ACL_SIZE 787
#define SD_DEFAULT_SID_SIZE 30
#define SD_DEFAULT_SIZE 400

#define DACL_FULLCONTROL_MASK (FILE_GENERIC_READ | FILE_ALL_ACCESS)
#define DACL_CHANGE_MASK (FILE_GENERIC_READ | FILE_GENERIC_WRITE | FILE_GENERIC_EXECUTE | DELETE)
#define DACL_READ_MASK ( FILE_GENERIC_READ | FILE_GENERIC_EXECUTE )
#define DACL_NO_MASK 0

#define SACL_READ_MASK (ACCESS_SYSTEM_SECURITY | FILE_GENERIC_READ)
#define SACL_WRITE_MASK (ACCESS_SYSTEM_SECURITY | FILE_GENERIC_WRITE)
#define SACL_EXECUTE_MASK ( SYNCHRONIZE | FILE_GENERIC_EXECUTE )
#define SACL_DELETE_MASK (DELETE)
#define SACL_CHANGEPERMS_MASK (WRITE_DAC)
#define SACL_CHANGEOWNER_MASK (WRITE_OWNER)

typedef enum { McsUnknownSD=0, McsFileSD, McsDirectorySD, McsShareSD, McsMailboxSD, McsExchangeSD, McsRegistrySD, McsPrinterSD } SecuredObjectType;

class TSecurableObject;
class TACE
{
   ACCESS_ALLOWED_ACE      * m_pAce;
   BOOL                      m_bNeedToFree;
   
public:
   TACE(BYTE type,BYTE flags,DWORD mask, PSID sid); // allocates and initializes a new ace 
   TACE(void * pAce) { m_pAce = (ACCESS_ALLOWED_ACE *)pAce; m_bNeedToFree = FALSE; } // manages an existing ace
   ~TACE() { if ( m_bNeedToFree ) free(m_pAce); }
   void * GetBuffer() { return m_pAce; }
   void SetBuffer(void * pAce, BOOL bNeedToFree = FALSE) { m_pAce = (ACCESS_ALLOWED_ACE *)pAce; m_bNeedToFree = bNeedToFree;}
   
   BYTE   GetType();
   BYTE   GetFlags();
   DWORD  GetMask();
   PSID   GetSid();
   WORD   GetSize();
   
   BOOL SetType(BYTE newType);
   BOOL SetFlags(BYTE newFlags);
   BOOL SetMask(DWORD newMask);
   BOOL SetSid(PSID sid);

   BOOL IsAccessAllowedAce();
};

class TSD
{
   friend class TSecurableObject;
protected:
   SECURITY_DESCRIPTOR     * m_absSD;             // SD in absolute format
   BOOL                      m_bOwnerChanged;
   BOOL                      m_bGroupChanged;
   BOOL                      m_bDACLChanged;
   BOOL                      m_bSACLChanged;
   BOOL                      m_bNeedToFreeSD;
   BOOL                      m_bNeedToFreeOwner;
   BOOL                      m_bNeedToFreeGroup;
   BOOL                      m_bNeedToFreeDacl;
   BOOL                      m_bNeedToFreeSacl;
   SecuredObjectType         m_ObjectType;

public:
   TSD(SECURITY_DESCRIPTOR * pSD, SecuredObjectType objectType, BOOL bResponsibleForDelete);
   TSD(TSD * pTSD);
   ~TSD();
   
   BOOL operator == (TSD & otherSD);
   
   SECURITY_DESCRIPTOR const * GetSD() const { return m_absSD; }  // returns a pointer to the absolute-format SD
   
   SECURITY_DESCRIPTOR * MakeAbsSD() const; // returns a copy of the SD in absolute format
   SECURITY_DESCRIPTOR * MakeRelSD() const; // returns a copy of the SD in self-relative format

   // type of secured object 
   SecuredObjectType GetType() const { return m_ObjectType; }
   void              SetType(SecuredObjectType newType) { m_ObjectType = newType;}

   // Security Descriptor parts
   PSID const GetOwner() const;
   void       SetOwner(PSID pNewOwner);
   PSID const GetGroup() const;
   void       SetGroup(PSID const pNewGroup);
   PACL const GetDacl() const;
   // SetDacl will free the buffer pNewAcl.
   void       SetDacl(PACL pNewAcl,BOOL present = TRUE);
   PACL const GetSacl() const;
   // SetSacl will free the buffer pNewAcl.
   void       SetSacl(PACL pNewAcl, BOOL present = TRUE);

   // Security Descriptor flags
   BOOL IsOwnerDefaulted() const;
   BOOL IsGroupDefaulted() const;
   BOOL IsDaclDefaulted() const;
   BOOL IsDaclPresent() const;
   BOOL IsSaclDefaulted() const;
   BOOL IsSaclPresent() const;

   // Change tracking functions
   BOOL IsOwnerChanged() const { return m_bOwnerChanged; }
   BOOL IsGroupChanged() const { return m_bGroupChanged; }
   BOOL IsDACLChanged()  const { return m_bDACLChanged; }
   BOOL IsSACLChanged()  const { return m_bSACLChanged; }
   BOOL IsChanged() const { return ( m_bOwnerChanged || m_bGroupChanged || m_bDACLChanged || m_bSACLChanged ); }
   void MarkAllChanged(BOOL bChanged) { m_bOwnerChanged=bChanged; m_bGroupChanged=bChanged; m_bDACLChanged=bChanged; m_bSACLChanged=bChanged; }
   // Functions to manage ACLs
   int    GetNumDaclAces() { return ACLGetNumAces(GetDacl()); }
   void   AddDaclAce(TACE * pAce);
   void   RemoveDaclAce(int ndx);
   void * GetDaclAce(int ndx) { return ACLGetAce(GetDacl(),ndx); }

   int    GetNumSaclAces() { return ACLGetNumAces(GetSacl()); }
   void   AddSaclAce(TACE * pAce);
   void   RemoveSaclAce(int ndx);
   void * GetSaclAce(int ndx) { return ACLGetAce(GetSacl(),ndx); }

   BOOL   IsValid() { return (m_absSD && IsValidSecurityDescriptor(m_absSD)); } 
   
   void FreeAbsSD(SECURITY_DESCRIPTOR * pSD, BOOL bAll = TRUE);
   void   ACLAddAce(PACL * ppAcl, TACE * pAce, int pos);
   void * ACLGetAce(PACL acl, int ndx);
protected:
   // Implementation - helper functions
   // Comparison functions
   BOOL   EqualSD(TSD * otherSD);
   BOOL   ACLCompare(PACL acl1,BOOL present1,PACL acl2, BOOL present2);
   
   // ACL manipulation functions
   int    ACLGetNumAces(PACL acl);
   DWORD  ACLGetFreeBytes(PACL acl);
   DWORD  ACLGetBytesInUse(PACL acl);
   
   void   ACLDeleteAce(PACL acl, int ndx);
   SECURITY_DESCRIPTOR * MakeAbsSD(SECURITY_DESCRIPTOR * pSD) const;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\taskchk.h ===
BOOL NeedToRunLocalAgent(IVarSet * pVarSet);
BOOL NeedToDispatch(IVarSet * pVarSet);
BOOL NeedToUseAR(IVarSet * pVarSet);
BOOL NeedToUseST(IVarSet * pVarSet, BOOL bForceRemoteCheck = FALSE); 
BOOL NeedToRunReports(IVarSet * pVarSet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\strhelp.h ===
#ifndef __STRINGHELP_H__
#define __STRINGHELP_H__
/*---------------------------------------------------------------------------
  File: StrHelp.h

  Comments: Contains general string helper functions.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 11/02/00 

  ---------------------------------------------------------------------------
*/

        
BOOL                                         //ret- TRUE=string found
   IsStringInDelimitedString(    
      LPCWSTR                sDelimitedString, // in- delimited string to search
      LPCWSTR                sString,          // in- string to search for
      WCHAR                  cDelimitingChar   // in- delimiting character used in the delimited string
   );

#endif //__STRINGHELP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\secobj.hpp ===
//#pragma title( "SDResolve.hpp - SDResolve Class definitions" )

/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  SecureObject.hpp
System      -  Domain Consolidation Toolkit
Author      -  Christy Boles
Created     -  97/06/27
Description -  Securable object classes (File, Share, and Exchange) for FST and EST.    
Updates     -
===============================================================================
*/

#include <lm.h>
#include <lmshare.h>
#include <winspool.h>

//#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <process.h>

#ifndef TNODEINCLUDED
#include "Tnode.hpp"
#define TNODEINCLUDED 
#endif


#ifdef SDRESOLVE 
   #include "sdstat.hpp"
   #include "STArgs.hpp"
#endif
#include "UString.hpp"
#include "EaLen.hpp"

class TSecurableObject
{
   protected:
   
   TNodeList                 changelog;
   WCHAR                     pathname[LEN_Path];  
   HANDLE                    handle;     
   bool                      owner_changed;
   bool                      group_changed;
   bool                      dacl_changed;
   bool                      sacl_changed;
   TSD                     * m_sd;

public:
                             TSecurableObject(){ 
                                                pathname[0]=0; handle = INVALID_HANDLE_VALUE;
                                                daceNS = 0;saceNS = 0;daceEx = 0;saceEx = 0;
                                                daceU  = 0;saceU  = 0;daceNT = 0;saceNT = 0;
                                                unkown = false; unkgrp = false; m_sd = NULL;
                             }
  
                             ~TSecurableObject();
   LPWSTR                    GetPathName() const { return (LPWSTR) &pathname; }
   void                      ResetHandle() { handle = INVALID_HANDLE_VALUE; }
   
   bool                      Changed() const { return (owner_changed || group_changed || dacl_changed || sacl_changed) ; }
   void                      Changed(bool bChanged) { m_sd->MarkAllChanged(bChanged); }
   int                       daceNS;   // not selected
   int                       saceNS;
   int                       daceU;    // unknown
   int                       saceU;
   int                       daceEx;   // examined
   int                       saceEx;
   int                       daceNT;   // no target
   int                       saceNT;
   bool                      unkown;   // unknown owners
   bool                      unkgrp;   // unknown groups

   bool                       UnknownOwner() const { return unkown;}
   bool                       UnknownGroup() const { return unkgrp; }
   void                      CopyAccessData(TSecurableObject * sourceFSD);
   
   virtual bool              WriteSD() = 0;
   virtual bool              ReadSD(const LPWSTR path) = 0;   
   bool                      HasSecurity() const { return m_sd != NULL; }
   bool                      HasDacl() const { return ( m_sd && (m_sd->GetDacl()!=NULL) ) ; }
   bool                      HasSacl() const { return ( m_sd && (m_sd->GetSacl()!=NULL) ) ; }
   bool                      IsDaclChanged() const { return dacl_changed; }
   bool                      IsSaclChanged() const { return sacl_changed; }
   TSD                     * GetSecurity() { return m_sd; }
#ifdef SDRESOLVE
   const TNodeList         * GetChangeLog() const { return &changelog; }
   void                      LogOwnerChange(TAcctNode *acct){ changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::owner,TRUE)); }
   void                      LogGroupChange(TAcctNode *acct){ changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::group,TRUE)); }
   void                      LogDACEChange(TAcctNode *acct) { changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::dace,TRUE)); }
   void                      LogSACEChange(TAcctNode *acct) { changelog.InsertTop((TNode *)new TStatNode(acct,TStatNode::sace,TRUE)); }
   
   bool                      ResolveSD(
      SecurityTranslatorArgs * args,              // in -cache to lookup accounts in 
      TSDResolveStats        * stat,              // in -stats object to increment counters
      objectType               type,              // in -is this file or dir or share
      TSecurableObject       * Last               // in -Last SD for cache comparison
   );   

protected:
  
   PACL                     ResolveACL(PACL acl, TAccountCache *cache, TSDResolveStats *stat, 
                                        bool *changes, BOOL verbose,int opType,objectType objType, BOOL bUseMapFile);
    
public:
   bool                     ResolveSDInternal( TAccountCache *cache, TSDResolveStats *stat, BOOL verbose,int opType, objectType objType, BOOL bUseMapFile);
   
#endif
   
};

/////////////////////////////////////////////////////////////////////////////////
///////////File and directory Acls  
/////////////////////////////////////////////////////////////////////////////////

class TFileSD:public TSecurableObject
{
protected:
   
public:
                              TFileSD(const LPWSTR fpath);
                             ~TFileSD();
   virtual bool              WriteSD();
   virtual bool              ReadSD(const LPWSTR path);   
};




class TShareSD : public TSecurableObject
{
private:   
   SHARE_INFO_502          * shareInfo;
   WCHAR                   * serverName;
public:
                        TShareSD(const LPWSTR name);
                        ~TShareSD() { if (shareInfo) 
                                       { NetApiBufferFree(shareInfo); 
                                         shareInfo = NULL; 
                                       }
                                      if ( serverName ) 
                                      {
                                          delete serverName;
                                          serverName = NULL;
                                      }
                        }
   
   virtual bool         WriteSD();
   virtual bool         ReadSD(const LPWSTR path); 
};


class TMapiSD : public TSecurableObject
{
   WCHAR                     name[LEN_DistName];

public:
   TMapiSD(SECURITY_DESCRIPTOR * pSD) { m_sd = new TSD(pSD,McsMailboxSD,FALSE); }
   void SetName(WCHAR const * str) { safecopy(name,str); }
   bool ReadSD(const LPWSTR path) { MCSASSERT(FALSE); return false; }
   bool WriteSD() { MCSASSERT(FALSE);return false; }
};


class TRegSD : public TSecurableObject
{
   HKEY                      m_hKey;
   WCHAR                     name[LEN_DistName];
public:
   TRegSD(const LPWSTR name, HKEY hKey);
   ~TRegSD() { }
   virtual bool         WriteSD();
   virtual bool         ReadSD(HKEY hKey);
   virtual bool         ReadSD(const LPWSTR path) { MCSASSERT(FALSE); return false; }
};

class TPrintSD: public TSecurableObject
{
   WCHAR                    name[MAX_PATH];
   HANDLE                   hPrinter;
   BYTE                   * buffer;
public:
   TPrintSD(const LPWSTR name);
   ~TPrintSD() 
    { 
      if ( hPrinter != INVALID_HANDLE_VALUE ) 
         ClosePrinter(hPrinter);
      if ( buffer )
         delete buffer;
   }
   virtual bool         WriteSD();
   virtual bool         ReadSD(const LPWSTR path); 
};

#ifdef SDRESOLVE
int
   ResolveAll(
      SecurityTranslatorArgs  * args,           // in - arguments that determine settings for the translation
      TSDResolveStats         * stats           // in - object used for counting objects examined, modified, etc.
   );
#endif

WCHAR *                                      // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   );

int EqualSignIndex(char * str);
int ColonIndex(TCHAR * str);
BOOL BuiltinRid(DWORD rid);
#ifdef SDRESOLVE
DWORD PrintSD(SECURITY_DESCRIPTOR * sd,WCHAR const * path);
DWORD PermsPrint(WCHAR* path,objectType objType);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\tevent.hpp ===
//#pragma title( "TEvent.hpp - Log events" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TEvent.hpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1995-11-16
Description -  TErrorEventLog derived class.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TEvent_hpp
#define  MCSINC_TEvent_hpp

// Start of header file dependencies

#include "ErrDct.hpp"

#ifndef  MCSINC_UString_hpp
#include "UString.hpp"
#endif

// End of header file dependencies

class TErrorEventLog : public TErrorDct
{
private:
   HANDLE                    hEventSource;
public:
   TErrorEventLog(
      WCHAR          const * server       ,// in -UNC name of server
      WCHAR          const * subkey       ,// in -event log subkey name
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
   ) : TErrorDct( displevel, loglevel, logmode, beeplevel )
   {
      hEventSource = RegisterEventSourceW( server, subkey );
   }

   ~TErrorEventLog() { LogClose(); }

   virtual BOOL         LogOpen(
      WCHAR           const * fileName    ,// in -name of file including any path
      int                     mode = 0    ,// in -0=overwrite, 1=append
      int                     level = 0    // in -minimum level to log
   );
   virtual void         LogWrite(WCHAR const * msg);
   virtual void         LogClose();
};

#endif  // MCSINC_TEvent_hpp

// TEvent.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\tnode.hpp ===
//#pragma title( "TNode.hpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TNode.hpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  1989-11-19
Description -  List/Tree base classes.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TNode_hpp
#define  MCSINC_TNode_hpp

#include "common.hpp"

#define MCS_ListError_InvalidHead       0x00000001
#define MCS_ListError_InvalidTail       0x00000002
#define MCS_ListError_InvalidCount      0x00000004
#define MCS_ListError_InvalidPtr        0x00000008
#define MCS_ListError_Exception         0x00000010

#define TNodeCompare(name)                                                     \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                    \
         TNode       const * v1          ,/* in -value1 to compare           */\
         TNode       const * v2           /* in -value2 to compare           */\
      )

#define TNodeCompareValue(name)                                               \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                   \
         TNode       const * tnode       ,/* in -value1 to compare           */\
         void        const * value        /* in -value2 to compare           */\
      )

#define DeleteAllListItems(datatype)                                          \
   TNodeListEnum             tenum;        /* enumerate values             */ \
   datatype                * tnode;        /* this node                    */ \
   datatype                * tnext;        /* next node                    */ \
   for ( tnode = (datatype *) tenum.OpenFirst( this );                        \
         tnode;                                                               \
         tnode = tnext )                                                      \
   {                                                                          \
      tnext = (datatype *) tenum.Next();                                      \
      Remove( tnode );                                                        \
      delete tnode;                                                           \
   }                                                                          \
   tenum.Close()

// TNode is a a base class for any derived object to be put into one of the
// TNodeList classes.
class TNode
{
   friend class TNodeList;
   friend class TNodeListSortable;
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
   TNode                   * left;
   TNode                   * right;
public:
   TNode                * Next() const { MCSASSERT(this); return right; }
// virtual ~TNode() {}
};


class TNodeList
{
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
protected:
   TNode                   * head,
                           * tail;
   DWORD                     count;
public:
                        TNodeList() { head = tail = NULL; count = 0; };
                        ~TNodeList();
   void                 InsertTop( TNode * eIns );
   void                 InsertBottom( TNode * eIns );
   void                 InsertAfter( TNode * eIns, TNode * eAft );
   void                 InsertBefore( TNode * eIns, TNode * eBef );
   void                 Remove(TNode const * t);
// void                 Delete(TNode * t) { Remove(t); delete t; };
   void                 Reverse();
   TNode *              Find(TNodeCompareValue((* Compare)), void const * findval) const;
   long                 Pos(TNode const * t) const
                        {
                           long n;
                           TNode * c;
                           MCSASSERT(this);
                           for (c=head, n=0; c!=t; c=c->right,n++);
                           return c ? n : -1;
                        }
   TNode              * Head() const { MCSASSERT(this); return head; }
   DWORD                Count() const { MCSASSERT (this); return count; }

protected:
   DWORD                Validate( TNode  ** pErrorNode );
};

/*
   A dynamically sortable collection of TNode entries.  The TNodes are arranged
   in either of two forms: a sorted linked linear list or a binary tree.  The
   current data data structure (form) is stored in the listType member.

   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
*/
enum TNodeListType { TNodeTypeError, TNodeTypeUnsorted, TNodeTypeLinear, TNodeTypeTree };

class TNodeListSortable : public TNodeList
{
private:
   TNode                   * lastInsert;
   static TNode *                          // ret-head of sorted list
                        TreeToSortedList(
         TNode                * top       ,// i/o-top of [sub]tree to squash
         TNode               ** newhead   ,// out-leftmost branch from tree
         TNode               ** newtail    // out-rightmost branch from tree
      );
   static TNode *                          // ret-middle of list (head of Btree)
                        ListSortedToTree(
         TNode                * top        // i/o-top of [sub]list to tree-ify
      );

   BOOL                 CountTree( TNode * pCurrentTop, DWORD * pCount);

protected:
   TNodeListType        listType;
                        TNodeCompare((* PCompare));
public:
                        TNodeListSortable(TNodeCompare((* pCompare)) = NULL, TNodeListType t = TNodeTypeLinear)
                           { lastInsert = NULL; listType = t; PCompare = pCompare; };
                                                      ~TNodeListSortable() { if ( IsTree() ) ToSorted(); }

   void                 CompareSet(TNodeCompare((* pCompare))) { PCompare = pCompare; }
   void                 TypeSetTree()   { listType = TNodeTypeTree; }
   void                 TypeSetSorted() { listType = TNodeTypeLinear; }

   void                 TreeInsert(TNode * item, short * depth);
   TNode **             TreeFindInsert(TNode const * item, short * depth);
   BOOL                 TreeInsertIfNew(TNode * item, short * depth)
   {
      TNode ** r=TreeFindInsert(item,depth);
      if (*r) return FALSE;
      *r=item;
      item->left = item->right = NULL;
      count++;
      return TRUE;
   }
   void                 TreeInsert(TNode * item) { short discard; TreeInsert(item, &discard); };
   void                 TreeRemove(TNode * item);
   TNode *              TreeFind(TNodeCompareValue((* pCompare)), void const * findval) const;

   void                 SortedInsert(TNode * t);
   BOOL                 SortedInsertIfNew(TNode * t);
   TNode *              SortedFindInsertBefore(TNode * item, BOOL * exists);

   void                 Insert(TNode * t) { if (IsTree()) TreeInsert(t); else SortedInsert(t); }
   BOOL                 InsertIfNew(TNode * t) { short depth; if (IsTree()) return TreeInsertIfNew(t,&depth);
                                                              else return SortedInsertIfNew(t); }
   virtual void         Remove(TNode * t) { if (t==lastInsert) lastInsert = NULL;
                                            if (IsTree()) TreeRemove(t);
                                            else TNodeList::Remove(t); };
// void                 Delete(TNode * t) { Remove(t); delete t; };
   TNode *              Find(TNodeCompareValue((* pCompare)), void const * findval) const
                           { if (IsTree()) return TreeFind(pCompare,findval); return TNodeList::Find(pCompare,findval); }

   void                 SortedToTree()
   {
      MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToTree - list is already a tree" );
      if ( !IsTree() )
      {
         head = ListSortedToTree( head );
         tail = NULL;
         listType = TNodeTypeTree;
      }
   }
   TNode *              UnsortedToTree();
   void                 ToSorted()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::ToSorted - list is not a tree" );
      if ( IsTree() )
      {
         MCSASSERT( ValidateTree() );
         if ( head )
            TreeToSortedList( head, &head, &tail );
         listType = TNodeTypeLinear;
      }
   }
   void                 Balance()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::Balance - list is not a tree" );
      if ( IsTree() )
      {
         ToSorted();
         SortedToTree();
      }
   }
   void                 Sort(TNodeCompare((* pCompare))) { TNodeListType lt = listType;
                                          if (lt == TNodeTypeTree) ToSorted();
                                          CompareSet(pCompare);
                                          UnsortedToTree();
                                          if (lt != TNodeTypeTree) ToSorted(); }
   void                 SortedToScrambledTree();
   BOOL                 IsTree() const { return listType == TNodeTypeTree; };

   BOOL                 ValidateTree( );
   DWORD                ValidateList( TNode  ** pErrorNode = NULL)
                        {
                           MCSASSERT(listType != TNodeTypeTree);
                           return Validate(pErrorNode);
                        }
};


/*
   TNodeListEnum is a 'friend' of TNode used to enumerate/iterate through
   TNodeList in linear list form.  It is an error to give it a TNodeList in
   tree form.
*/
class TNodeListEnum
{
protected:
   TNodeList         const * list;   // list for which enums are carried out
   TNode                   * curr;   // last node processed by enum functions
public:
                        TNodeListEnum() { list = NULL; curr = NULL; };
                        TNodeListEnum(TNodeList const * tlist) { Open(tlist); }
                        ~TNodeListEnum() { };

   void                 Open(TNodeList const * tlist) { list = tlist; Top(); };
   TNode              * OpenFirst(TNodeList const * tlist) { list = tlist; return First(); }
   TNode              * First() { return curr = list->head; };
   TNode              * Next() { return curr = (curr ? curr->right : list->head); }
   TNode              * Prev() { return curr = (curr ? curr->left  : list->tail); }
   TNode              * Last() { return curr = list->tail; };
   TNode *              Get() { return curr; }
   TNode *              Get(long n) { TNode * c; Top(); while ( n-->=0 && (c=Next()) ); return c; }
   void                 Close() { curr = NULL; }
   void                 Top() { curr = NULL; };
};

// provides optimized direct accessibility by ordinal to TNodeList at some
// expense to sequential traversal performance
class TNodeListOrdEnum : public TNodeListEnum
{
private:
   long                 nCurr;
public:
                        TNodeListOrdEnum() : TNodeListEnum() { nCurr = -1; };
                        TNodeListOrdEnum(TNodeList const * tlist) { Open(tlist); };

   void                 Open(TNodeList const * tlist) { TNodeListEnum::Open(tlist); nCurr = -1; };
   TNode              * OpenFirst(TNodeList const * tlist) { Open(tlist); return First(); }
   TNode              * First() { nCurr = list->head ? 0 : -1; return TNodeListEnum::First(); };
   TNode              * Next() { TNode * t = TNodeListEnum::Next(); if (curr) nCurr++; else nCurr=-1; return t; }
   TNode              * Prev() { TNode * t = TNodeListEnum::Prev(); if (curr) if (nCurr>0) nCurr--; else nCurr=list->Count()-1; else nCurr=-1; return t; }
   void                 Close() { nCurr=-1; TNodeListEnum::Close(); }
   void                 Top() { nCurr=-1; TNodeListEnum::Top(); };

   long                 Pos() const { return nCurr; };
   long                 Pos(TNode const * t) { long n; TNode * c;
                                               for (c=list->head, n=0; c!=t; c=c->right,n++);
                                               if (c) nCurr=n; else nCurr=-1; curr=c; return nCurr; }
   TNode *              Get(long n);
};


/*
   TNodeTreeEnum enumerates a TNodeListSortable that is in tree form.  It is an error
   to give it a TNodeListSortable that is in linear list form.
*/
enum TNodeTreeStackEntryState {Snone, Sleft, Sused, Sright, SComplete};
struct TNodeTreeStackEntry
{
   TNode                * save;
   TNodeTreeStackEntryState state;
};

const TREE_STACKSIZE = 200;            // default maximum recursion depth
class TNodeTreeEnum
{
private:
   TNodeTreeStackEntry     * stackBase,
                           * stackPos;
   int                       stackSize;
   void                 Push(TNode * item) { (++stackPos)->save = item; stackPos->state = Snone; };
   BOOL                 Pop() { if (stackBase) return --stackPos >= stackBase; else return FALSE; };
   void                 StackAlloc(int stacksize)
                           { stackSize = stacksize;
                             stackBase = new TNodeTreeStackEntry[stacksize]; };
protected:
   TNode                   * top;    // tree top for which enums are carried out
   TNode                   * curr;   // next node processed by enum functions
public:
                        TNodeTreeEnum(int stacksize = TREE_STACKSIZE) { top = NULL; StackAlloc(stacksize); };
                        TNodeTreeEnum(TNodeListSortable const * tlist, int stacksize = TREE_STACKSIZE) { StackAlloc(stacksize); Open(tlist); };
                        ~TNodeTreeEnum() { Close(); if (stackBase) delete [] stackBase; };

   void                 Open(TNodeListSortable const * tlist)
                           {
                              if (stackBase)
                              {
                                 stackPos = stackBase;
                                 stackPos->save = NULL;
                                 stackPos->state = SComplete;

                                 top = tlist->head;

                                 if ( top )
                                    Push(top);
                              }
                           }

   TNode              * First();
   TNode              * FirstAfter(TNodeCompareValue((* Compare) ), void const * findVal);
   TNode              * OpenFirst(TNodeListSortable const * tlist) { if (stackBase) { Open(tlist);  return Next(); } else return NULL; }

   TNode              * Next();
   TNode              * StackTop() { if (stackBase) return stackPos->save; else return NULL; }
   void                 Close() { stackPos = stackBase; }
};

#endif  // MCSINC_TNode_hpp

// TNode.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\tservice.hpp ===
//#pragma title( "TService.hpp - SCM interface for MCS service" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TService.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-08-17
Description -  SCM interface for MCS service
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TService_hpp
#define  MCSINC_TService_hpp

enum  TScmEpRc
{
   TScmEpRc_Unknown,                       // unknown
   TScmEpRc_OkCli,                         // normal completion (run as CLI)
   TScmEpRc_OkSrv,                         // normal completion (run as service)
   TScmEpRc_InvArgCli,                     // invalid arguments (command line)
   TScmEpRc_InvArgSrv,                     // invalid arguments (service start)
};

// Provided by TService.cpp

TScmEpRc                                   // TScmEp return code
   TScmEp(
      int                    argc         ,// in -argument count
      char          const ** argv         ,// in -argument array
      TCHAR                * nameService   // in -name of service
   );

// Provided by TService user

BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      char           const * arg           // in -command line argument
   );

BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      WCHAR          const * arg           // in -command line argument
   );

BOOL                                       // ret-TRUE if force CLI
   UScmForceCli();

void
   UScmEp(
//      BOOL                   bService      // in -FALSE=Cli,TRUE=Service
   );

#endif  // MCSINC_TService_hpp

// TService.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\validation.h ===
#pragma once


#define MAXIMUM_PREFIX_SUFFIX_LENGTH 8

bool __stdcall IsValidPrefixOrSuffix(LPCTSTR pszPrefixOrSuffix);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\txtsid.h ===
#ifndef __TEXTUALSID_H__
#define __TEXTUALSID_H__
/*---------------------------------------------------------------------------
  File: TextualSid.h

  Comments: Converts a SID between binary and textual representations.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/05/99 14:52:27

 ---------------------------------------------------------------------------
*/


        
BOOL                                         //ret- TRUE=success
   GetTextualSid(    
      PSID                   pSid,           // in - binary Sid
      LPTSTR                 TextualSid,     // out- textual representation of sid
      LPDWORD                lpdwBufferLen   // in - DIM length of buffer for TextualSid
   );


// The PSID returned from this function should be freed by the caller, using FreeSid
PSID                                        // ret- binary SID, or NULL
   SidFromString(
      WCHAR          const * strSid         // in - string representation of SID
   );


/*****************************************************************************************************/
/*   DomainizeSid: 
         Takes a domain sid, and verifies that its last subauthority value is -1.  If the RID is not 
         -1, DomainizeSid adds a -1 to the end. 
/*****************************************************************************************************/
PSID                                            // ret -the sid with RID = -1
   DomainizeSid(
      PSID                   psid,               // in -sid to check and possibly fix
      BOOL                   freeOldSid          // in -whether to free the old sid 
   );

//takes a source and target account sid and breaks it into a src and tgt
//domain sid and src and tgt account rid
BOOL                                            // ret -Success ? TRUE | FALSE
   SplitAccountSids(
      PSID					 srcSid,			// in - src account sid
	  WCHAR                 *srcDomainSid,		// out - src domain sid (textual)
	  DWORD                 *srcRid,			// out - src account rid
	  PSID                   tgtSid,			// in - tgt account sid
	  WCHAR                 *tgtDomainSid,		// out - tgt domain sid (textual)
	  DWORD                 *tgtRid				// out - tgt account rid
   );

#endif //__TEXTUALSID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\tsync.hpp ===
//#pragma title( "TSync.hpp - Common synchronization classes header file" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes header file
               This includes TCriticalSection, and TNamedSemaphore
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TSync_hpp
#define  MCSINC_TSync_hpp

#ifndef _INC_TIME
#include <time.h>
#endif

class TCriticalSection
{
   CRITICAL_SECTION          cs;
public:
                        TCriticalSection() { InitializeCriticalSection(&cs); }
                        ~TCriticalSection() { DeleteCriticalSection(&cs); }
   void                 Enter() { EnterCriticalSection(&cs); }
   void                 Leave() { LeaveCriticalSection(&cs); }
};

class TSynchObject
{
public:
   HANDLE                    handle;
   TSynchObject()
   { handle = NULL; }
   ~TSynchObject()
   { Close(); }
   void Close()
   { if ( handle != NULL ) { CloseHandle( handle ); handle = NULL; } }

   DWORD                WaitSingle(DWORD msec) const { return WaitForSingleObject(handle, msec); }
   DWORD                WaitSingle()           const { return WaitForSingleObject(handle, INFINITE); }
   HANDLE               Handle() { return handle; }
};

///////////////////////////////////////////////////////////////////////////////
// Named semaphores
///////////////////////////////////////////////////////////////////////////////

class TSemaphoreNamed : public TSynchObject
{
public:
   TSemaphoreNamed() {};
   ~TSemaphoreNamed() {};
   DWORD Create(                           // ret-OS return code
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted=NULL // out-TRUE=previously existed
   );
   DWORD Open(                             // ret-OS return code
      TCHAR          const * sNameT        // in -semaphore name
   );
   DWORD Release(                          // ret-OS return code
      long                   nRelease=1    // in -number to release
   );
};


#endif  // MCSINC_TSync_hpp

// TSync.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\treg.hpp ===
//#pragma title( "TReg.hpp - Registry class" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TReg.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham, Jay Berlin
Created     -  1995-09-01
Description -  Registry class.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TReg_hpp
#define  MCSINC_TReg_hpp


class TRegKey
{
private:

   HKEY                      hKey;

public:

   TRegKey() { hKey = (HKEY)INVALID_HANDLE_VALUE; };
   TRegKey( HKEY hPreDefined, TCHAR const * machineName ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Connect( hPreDefined, machineName ); };
   TRegKey( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Open( keyname, hParent ); };
   TRegKey( TCHAR const * keyname, TRegKey const * regParent ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Open( keyname, regParent->hKey ); };
   ~TRegKey();

   DWORD Connect( HKEY hPreDefined, TCHAR const * machineName );

   DWORD Open( TCHAR const * keyname, TRegKey const * regParent, DWORD access = KEY_ALL_ACCESS ) { return Open( keyname, regParent->hKey, access ); };
   DWORD Open( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE, DWORD access = KEY_ALL_ACCESS );
   DWORD OpenRead( TCHAR const * keyname, TRegKey const * regParent ) { return Open( keyname, regParent->hKey, KEY_READ ); };
   DWORD OpenRead( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE ) { return Open( keyname, hParent, KEY_READ ); };

   DWORD Create( TCHAR const * keyname, TRegKey const * regParent, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS ) { return Create( keyname, regParent->hKey, pDisp, access ); };
   DWORD Create( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS );
   DWORD CreateBR( TCHAR const * keyname, TRegKey const * regParent, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS ) { return CreateBR( keyname, regParent->hKey, pDisp, access ); };
   DWORD CreateBR( TCHAR const * keyname, HKEY hParent = (HKEY)HKEY_LOCAL_MACHINE, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS );

   HKEY KeyGet() { return hKey; }

   void Close();

   DWORD SubKeyDel( TCHAR const * keyname ) const { return RegDeleteKey( hKey, keyname ); };
   DWORD SubKeyEnum( DWORD index, TCHAR * keyname, DWORD keylen ) const;

// Note that "namelen" must be "sizeof name", not "DIM(name)"
// Same for "valuelen"

   DWORD ValueEnum( DWORD index, TCHAR * name, DWORD namelen, void * value, DWORD * valuelen, DWORD * valuetype ) const;

   DWORD ValueGet( TCHAR const * name, void * value, DWORD * lenvalue, DWORD * typevalue ) const;
   DWORD ValueGetDWORD( TCHAR const * name, DWORD * value ) const;
   DWORD ValueGetStr( TCHAR const * name, TCHAR * value, DWORD maxlen ) const;

   DWORD ValueSet( TCHAR const * name, void const * value, DWORD lenvalue, DWORD typevalue ) const;
   DWORD ValueSetDWORD( TCHAR const * name, DWORD value) const { return ValueSet(name, &value, sizeof value, REG_DWORD); }
   DWORD ValueSetStr( TCHAR const * name, TCHAR const * value, DWORD type = REG_SZ ) const;

   DWORD ValueDel( TCHAR const * name = NULL ) const;

   DWORD HiveCopy( TRegKey const * source );
   DWORD HiveDel();
   DWORD HiveReplicate( TRegKey const * source );
};

#endif // MCSINC_TReg.hpp

// TReg.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\t_safevector.h ===
//-------------------------------------------------------------------------------------
// T_SafeVector.h
//
//  The follwing template classes provide a way of creating and accessing SafeArrays.
//  They are derived from the C++ standard library (STL) vector class and can be used
//  the same way. They can be accessed just like an array (with the [] operator).
//
//  Use the constructors or assignment operators to extract the SafeArray from a 
//  SAFEARRAY* or array variant (VARIANT or _variant_t). The elements will be 
//  copied into the vector.  Use the GetSafeArray() or GetVariant() methods to pack
//  the elements back into a SafeArray.
//
//  To create a new SafeArray, declare a varaible of the appropriate type and call
//  resize() to set the size, or push_back() to grow the array. Call GetSafeArray() 
//  or GetVariant() to produce a SafeArray.
//
//  See the T_SafeVector2 class at the bottom of this file for more information 
//  about the constructors, extractors, and assignment operators.
// 
//  Use the following pre-defined array types:
//
//           Array Type              -    Element Type
//    -----------------------------------------------------------------------------
//       _bstr_tSafeVector           -    BSTR (uses _bstr_t)
//       longSafeVector              -    long
//       shortSafeVector             -    short
//       byteSafeVector              -    byte 
//       boolSafeVector              -    bool
//       CWbemClassObjectSafeVector  -    IWbemClassObject (uses CWbemClassObject)
//
//  Copyright (c)1997 - 1999 Microsoft Corporation, All Rights Reserved
//------------------------------------------------------------------------------------

#if !defined(__T_SafeVector_H)
#define      __T_SafeVector_H
#pragma once

#pragma warning( disable : 4786) // identifier was truncated to 'number' characters in the debug information
#pragma warning( disable : 4503) // decorated name length exceeded, name was truncated


typedef std::vector<_bstr_t>            _bstr_tVec;
typedef std::vector<long>               longVec;
typedef std::vector<short>              shortVec;
typedef std::vector<unsigned char>      byteVec;
typedef std::vector<bool>               boolVec;

#if !defined(NO_WBEM)
typedef std::vector<CWbemClassObject>   coVec;
#endif



template<typename TNContainer,typename TNDataType>
class T_SAExtractScaler
{
    public:
		 void SetToContainer(TNContainer& _cont,void * pData,int l,int u)
		 {
			 TNDataType * pWalk = reinterpret_cast<TNDataType *>(pData);
			 
			 for(;l < (u+1);l++,pWalk++)
			 {
				 _cont.push_back( *pWalk);
			 }
		 }
		 
		 void GetFromContainer
			 (
			 TNContainer& _cont,
			 void * pData,
			 TNContainer::iterator walk,
			 TNContainer::iterator finish
			 )
		 {
			 TNDataType * pWalk = reinterpret_cast<TNDataType *>(pData);
			 
			 for(;walk != finish;walk++,pWalk++)
			 {
				 *pWalk = *walk;
			 }
		 }
		 
		 _bstr_t FormatDebugOutput
			 (
			 TNContainer::iterator first,
			 TNContainer::iterator item,
			 TNContainer::iterator last
			 )
		 {
			 _bstr_t sRet;
			 
			 try
			 {
				 _variant_t v;
				 
				 v = v.operator=(TNDataType(*item));
				 
				 v.ChangeType(VT_BSTR);
				 
				 sRet = (_bstr_t) v;
				 
				 if( (item+1)!=last )
				 {
					 sRet += ", ";
				 }
			 }
			 catch(_com_error&)
			 {
				 sRet = "Not supported";
			 }
			 
			 return sRet;
		 }
};





template<typename TNContainer>
class T_Extract_bstr_t
{
    public:
		 T_Extract_bstr_t()
		 {
		 }
		 
		 void SetToContainer(TNContainer& _cont,void * pData,int l,int u)
		 {
			 BSTR * pWalk = reinterpret_cast<BSTR*>(pData);
			 
			 for(;l < (u+1);l++,pWalk++)
			 {
				 _cont.push_back( _bstr_t(*pWalk,true) );
			 }
		 }
		 
		 void GetFromContainer
			 (
			 TNContainer& _cont,
			 void * pData,
			 TNContainer::iterator walk,
			 TNContainer::iterator finish
			 )
		 {
			 BSTR * pWalk = reinterpret_cast<BSTR*>(pData);
			 
			 for(;walk != finish;walk++,pWalk++)
			 {
				 *pWalk = (*walk).copy();
			 }
		 }
		 
		 _bstr_t FormatDebugOutput
			 (
			 TNContainer::iterator first,
			 TNContainer::iterator item,
			 TNContainer::iterator last
			 )
		 {
			 _bstr_t sRet;
			 
			 sRet += "\"";
			 sRet += (*item);
			 sRet += "\"";
			 
			 if( (item+1)!=last )
			 {
				 sRet += ", ";
			 }
			 
			 return sRet;
		 }
		 
};



#if !defined(NO_WBEM)

template<typename TNContainer>
class T_Extract_IUnknown
{
    public:
		 T_Extract_IUnknown()
		 {
		 }
		 
		 void SetToContainer(TNContainer& _cont,void * pData,int l,int u)
		 {
			 IUnknown ** pWalk = reinterpret_cast<IUnknown **>(pData);
			 
			 for(;l< (u+1);l++,pWalk++)
			 {
				 _cont.push_back( CWbemClassObject((IWbemClassObject*)*pWalk) );
			 }
		 }
		 
		 void GetFromContainer
			 (
			 TNContainer& _cont,
			 void * pData,
			 TNContainer::iterator walk,
			 TNContainer::iterator finish
			 )
		 {
			 IUnknown ** pWalk = reinterpret_cast<IUnknown **>(pData);
			 
			 for(;walk != finish;walk++,pWalk++)
			 {
				 (*walk)->AddRef();
				 *pWalk = (*walk);
			 }
		 }
		 
		 _bstr_t FormatDebugOutput
			 (
			 TNContainer::iterator   first,    
			 TNContainer::iterator   item,
			 TNContainer::iterator   last
			 )
		 {
			 _bstr_t sRet;
			 
			 try
			 {
				 _variant_t v( long(item -first) );
				 v.ChangeType(VT_BSTR);
				 _variant_t v2( long(last-first-1) );
				 v2.ChangeType(VT_BSTR);
				 
				 sRet += "Object [";
				 sRet += (_bstr_t)v;
				 sRet += " of ";
				 sRet += (_bstr_t)v2;
				 sRet += "]\n";
				 
				 sRet += (*item).GetObjectText();
				 
				 if( (item+1) != last )
				 {
					 sRet += "\n";
				 }
			 }
			 catch(_com_error&)
			 {
				 sRet = "Not supported";
			 }
			 
			 return sRet;
		 }
		 
};

#endif


typedef T_SAExtractScaler<longVec,long>             __exptExtractlong;
typedef T_SAExtractScaler<shortVec,short>           __exptExtractshort;
typedef T_SAExtractScaler<byteVec,unsigned char>    __exptExtractbyte;
typedef T_SAExtractScaler<boolVec,bool>             __exptExtractbool;
typedef T_Extract_bstr_t<_bstr_tVec>                __exptExtract_bstr_t;

#if !defined(NO_WBEM)
typedef T_Extract_IUnknown<coVec>                   __exptExtractco;
#endif


template<typename TNContainer,typename TNExtractor>
class T_SafeArrayImp
{
    public:
		 void ConstructContainerFromSafeArray
			 (
			 TNExtractor&  _extract,
			 TNContainer& _cont,
			 SAFEARRAY * _pSA
			 )
		 {
			 long l = 0;
			 long u = 0;
			 
			 HRESULT hr;
			 void * pData;
			 
			 hr = SafeArrayGetLBound(_pSA,1,&l);
			 hr = SafeArrayGetUBound(_pSA,1,&u);
			 
			 hr = SafeArrayAccessData(_pSA,&pData);
			 
			 if(hr == S_OK)
			 {
				 _extract.SetToContainer(_cont,pData,l,u);
				 
				 SafeArrayUnaccessData(_pSA);
			 }
		 }
		 
		 SAFEARRAY * ConstructSafeArrayFromConatiner
			 (
			 TNExtractor&            _extract,
			 VARTYPE                 _vt,
			 TNContainer&            _cont,
			 TNContainer::iterator   start,
			 TNContainer::iterator   finish
			 )
		 {
			 HRESULT         hr   = S_OK;
			 SAFEARRAY *     pRet = NULL;
			 SAFEARRAYBOUND  rgsabound[1];
			 void * pData;
			 
			 rgsabound[0].lLbound    = 0;
			 rgsabound[0].cElements  = _cont.size();
			 
			 pRet = SafeArrayCreate(_vt,1,rgsabound);
			 
			 if(pRet)
			 {
				 hr = SafeArrayAccessData(pRet,&pData);
				 
				 if(hr == S_OK)
				 {
					 _extract.GetFromContainer(_cont,pData,start,finish);
					 
					 SafeArrayUnaccessData(pRet);
				 }
			 }
			 
			 return pRet;
		 }
};

///////////////////////////////////////////////////////////////////////////
// T_SafeVector2
//
// Derived from TNContainer which should be a type of STL vector.
// Provides for the conversion between vector and SafeArray.
// 

template
<
VARTYPE TNVariant,
typename TNDataType,
typename TNContainer = std::vector<TNDataType>,
typename TNExtractor = T_SAExtractScaler<TNContainer,TNDataType>
>
class T_SafeVector2 : public TNContainer 
{
    private:
		 T_SafeArrayImp<TNContainer,TNExtractor> m_Array;
    protected:
    public:
		 
		 T_SafeVector2()
		 {
		 }
		 
		 // copy constructor
		 T_SafeVector2(const TNContainer& _copy) : TNContainer(_copy)
		 {
		 }
		 
		 
		 // Construct vector from array variant, extracts elements
		 T_SafeVector2(_variant_t& _ValueArray)
		 {
			 if(_ValueArray.vt & VT_ARRAY)
			 {
				 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_ValueArray.parray);
			 }
		 }
		 
		 // Construct vector from SAFEARRAY, extracts elements
		 T_SafeVector2(SAFEARRAY * _pArray)
		 {
			 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_pArray);
		 }
		 
		 // assign vector from array variant, extracts elements
		 T_SafeVector2& operator=(_variant_t& _ValueArray)
		 {
			 clear();
			 
			 if(_ValueArray.vt & VT_ARRAY)
			 {
				 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_ValueArray.parray);
			 }
			 
			 return *this;
		 }
		 
		 // assign vector from SAFEARRAY, extracts elements
		 T_SafeVector2& operator=(SAFEARRAY * _pArray)
		 {
			 clear();
			 m_Array.ConstructContainerFromSafeArray(TNExtractor(),*this,_pArray);
			 return *this;
		 }
		 
		 // assign vector from another vector, copies elements
		 T_SafeVector2& operator=(const TNContainer& _copy)
		 {
			 TNContainer::operator=(_copy);
			 return *this;
		 }
		 
		 ~T_SafeVector2()
		 {
		 }
		 
		 // create SafeArray from a portion of the vector elements and return a SAFEARRAY*
		 SAFEARRAY *  GetSafeArray(TNContainer::iterator start,TNContainer::iterator finish)
		 {
			 return m_Array.ConstructSafeArrayFromConatiner(TNExtractor(),TNVariant,*this,start,finish);
		 }
		 
		 // create SafeArray from the vector elements and return a SAFEARRAY*
       SAFEARRAY * GetSafeArray()
		 {
			 return GetSafeArray(begin(),end());
		 }
		 
       // create SafeArray from a portion of the vector elements and return as an array variant
       _variant_t GetVariant(TNContainer::iterator start,TNContainer::iterator finish)
		 {
			 _variant_t vRet;
			 
			 vRet.vt        = TNVariant|VT_ARRAY;
			 vRet.parray    = GetSafeArray(start,finish);
			 
			 return vRet;
		 }
		 
       // create SafeArray from the vector elements and return as an array variant
       _variant_t GetVariant()
		 {
			 return GetVariant(begin(),end());
		 }
		 
		 _bstr_t FormatDebugOutput()
		 {
			 _bstr_t sOutput;
			 
			 for(iterator walk = begin();walk != end();walk++)
			 {
				 sOutput += TNExtractor().FormatDebugOutput(begin(),walk,end());
			 }
			 
			 return sOutput;
		 }
};



typedef T_SafeVector2
<
VT_BSTR,
_bstr_t,
_bstr_tVec,
T_Extract_bstr_t<_bstr_tVec>
>  
_bstr_tSafeVector;


typedef T_SafeVector2<VT_I4,long>           longSafeVector;
typedef T_SafeVector2<VT_I2,short>          shortSafeVector;
typedef T_SafeVector2<VT_UI1,unsigned char> byteSafeVector;
typedef T_SafeVector2<VT_BOOL,bool>         boolSafeVector;

#if !defined(NO_WBEM)
typedef T_SafeVector2
<
VT_UNKNOWN,
CWbemClassObject,
std::vector<CWbemClassObject>,
T_Extract_IUnknown<std::vector<CWbemClassObject> >
> 
CWbemClassObjectSafeVector;
#endif


#endif // __T_SafeVector_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\mcsdmmsg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsDomMsg.rc
//
#define IDR_MESSAGE_TABLE               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\mcsdmmsg\mcsdmmsg\makefile.inc ===
McDmMsg.dll : McDmMsg.res

McDmMsg.rc : McDmMsg.res
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\include\ustring.hpp ===
//#pragma title( "UString.hpp - Common string and character functions" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  UString.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-08-25
Description -  Common string and character functions.
      Many string and character functions defined in "string.h" are redefined
         here as overloaded inline functions with several extensions:
      o  Both ANSI and UNICODE strings are supported.
      o  Both ANSI and UNICODE characters are supported.
      o  For ANSI, characters can be "char signed" or "char unsigned".
      o  Functions that allow a length field, such as "lstrcpy" vs "lstrcpyn",
         are implemented as overloaded functions with optional arguments.
      o  Some functions, UStrCpy in particular, can perform conversion between
         ANSI and UNICODE strings.
      The function names defined here consist of "U" concatenated to the base
         name from "string.h".  The first letter of words or word abbreviations
         are capitalized, e.g. "strcpy" becomes "UStrCpy".
Updates     -
===============================================================================
*/

#ifndef  MCSINC_UString_hpp
#define  MCSINC_UString_hpp

#define safecopy(trg,src) ((src) ? UStrCpy(trg,src,DIM(trg)) : trg[0] = 0)

#ifdef  WIN16_VERSION
   #ifndef  UCHAR
      #define  UCHAR  unsigned char
   #endif

   #include <string.h>
   #include <ctype.h>
#endif  // WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      char           const * s1            // in -ANSI string
   )
{
   return strlen( s1 );
}


int _inline                                // ret-length in chars
   UStrLen(
      UCHAR          const * s1            // in -ANSI string
   )
{
   return strlen( (char const *) s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   strcpy( aTarget, aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      strncpy( aTarget, aSource, copylen );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( aTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource, len );
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

char _inline *
   UStrLwr(
      char                 * s             // i/o-ANSI string
   )
{
   return strlwr( s );
}

UCHAR _inline *
   UStrLwr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strlwr( (char *) s );
}

char _inline *
   UStrUpr(
      char                 * s             // i/o-ANSI string
   )
{
   return strupr( s );
}

UCHAR _inline *
   UStrUpr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strupr( (char *) s );
}

char _inline
   UToLower(
      char                   c             // in -ANSI char
   )
{
   return (char) tolower( c );
}

UCHAR _inline
   UToLower(
      UCHAR                  c             // in -ANSI char
   )
{
   return (UCHAR) tolower( (char) c );
}

char _inline
   UToUpper(
      char                   c             // in -ANSI char
   )
{
   return (char) toupper( c );
}

UCHAR _inline
   UToUpper(
      UCHAR                  c             // in -ANSI char
   )
{
   return (UCHAR) toupper( (char) c );
}

// Left-trim string in place
_inline UCHAR *
   LTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strorg = s;

   while ( *strorg == ' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

_inline char *
   LTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) LTrim( (UCHAR *) s );
}

// Right-trim string in place
_inline UCHAR *
   RTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == ' ') )
      strend--;
   *strend = '\0';
   return s;
}

_inline char *
   RTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) RTrim( (UCHAR *) s );
}

// Trim string in place
_inline UCHAR *
   Trim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

_inline char *
   Trim(
      char                 * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

#ifndef  WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      WCHAR          const * s1            // in -UNICODE string
   )
{
   return lstrlenW( s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   UStrCpy( (char *) aTarget, wSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource       // in -ANSI source string
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( wTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   lstrcpyW( wTarget, wSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, wSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( wTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      lstrcpynW( wTarget, wSource, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcscmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsncmp( s1, s2, len );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcsicmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsnicmp( s1, s2, len );
}

WCHAR _inline *
   UStrLwr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return _wcslwr( s );
}

WCHAR _inline *
   UStrUpr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return _wcsupr( s );
}

WCHAR _inline
   UToLower(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towlower( c );
}

WCHAR _inline
   UToUpper(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towupper( c );
}

// Left-trim string in place
_inline WCHAR *
   LTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strorg = s;

   while ( *strorg == L' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

// Right-trim string in place
_inline WCHAR *
   RTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == L' ') )
      strend--;
   *strend = L'\0';
   return s;
}

// Trim string in place
_inline WCHAR *
   Trim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return LTrim( RTrim( s ) );
}

char * _cdecl                             // ret-target string
   UStrJoin(
      char                 * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      char const           * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

WCHAR * _cdecl                            // ret-target string
   UStrJoin(
      WCHAR                * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      WCHAR const          * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

#endif  // WIN16_VERSION

#endif  // MCSINC_UString_hpp

// UString.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\mcsdmmsg\mcsdmmsgnt4\makefile.inc ===
McDmMsg.dll : McDmMsg.res

McDmMsg.rc : McDmMsg.res
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\mcsdmres\mcsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McDomRes.rc
//
#define DCTVS_Options_SourceDomain      1
#define DCTVS_Options_TargetDomain      2
#define DCTVS_Options_NoChange          3
#define DCTVS_Options_LogLevel          4
#define DCTVS_Options_LogToTemp         5
#define DCTVS_Options_Logfile           6
#define DCTVS_Options_Credentials_Domain 7
#define DCTVS_Options_Credentials_UserName 8
#define DCTVS_Options_Credentials_Password 9
#define DCTVS_Options_Credentials_Server 10
#define DCTVS_Options_Credentials_Share 11
#define DCTVS_Options_ResultFile        12
#define DCTVS_Options_DeleteFileAfterLoad 13
#define DCTVS_Options_RemoveAgentOnCompletion 14
#define DCTVS_Options_SourceDomainSid   15
#define DCTVS_Options_TargetDomainSid   16
#define DCTVS_Options_LocalProcessingOnly 17
#define DCTVS_ConfigurationFile         18
#define DCTVS_InstallToServer           19
#define DCTVS_Dispatcher_ResultPath     20
#define DCTVS_StatusObject              21
#define DCTVS_Options_UniqueNumberForResultsFile 22
#define DCTVS_Options_MaxThreads        23
#define DCTVS_Options_DispatchLog       24
#define DCTVS_GatherInformation_UserRights 25
#define DCTVS_GatherInformation_ComputerPasswordAge 26
#define DCTVS_Security_ReportAccountReferences 27
#define DCTVS_Security_GatherInformation 28
#define DCTVS_Security_TranslationMode  29
#define DCTVS_Security_BuildCacheFile   30
#define DCTVS_Security_TranslateFiles   31
#define DCTVS_Security_TranslateShares  32
#define DCTVS_Security_TranslateUserRights 33
#define DCTVS_Security_TranslateMailboxes 34
#define DCTVS_Security_TranslateContainers 35
#define DCTVS_Security_TranslateLocalGroups 36
#define DCTVS_Security_TranslatePrinters 37
#define DCTVS_Security_TranslateUserProfiles 38
#define DCTVS_Security_MapiProfile      39
#define DCTVS_Accounts_InputFile        40
#define DCTVS_Accounts_WildcardSpec     41
#define DCTVS_Accounts_WildcardSpec_Computer 42
#define DCTVS_Accounts_NumItems         43
#define DCTVS_AccountOptions_CopyUsers  44
#define DCTVS_AccountOptions_CopyLocalGroups 45
#define DCTVS_AccountOptions_CopyGlobalGroups 46
#define DCTVS_AccountOptions_CopyComputers 47
#define DCTVS_AccountOptions_Prefix     48
#define DCTVS_AccountOptions_AddToGroup 49
#define DCTVS_AccountOptions_AddToGroupOnSourceDomain 50
#define DCTVS_AccountOptions_DisableCopiedAccounts 51
#define DCTVS_AccountOptions_DisableSourceAccounts 52
#define DCTVS_AccountOptions_CopyPasswords 53
#define DCTVS_AccountOptions_GenerateStrongPasswords 54
#define DCTVS_AccountOptions_PasswordFile 55
#define DCTVS_AccountOptions_UpdateUserRights 56
#define DCTVS_AccountOptions_ReplaceExistingAccounts 57
#define DCTVS_AccountOptions_ReplaceExistingGroupMembers 58
#define DCTVS_AccountOptions_RemoveExistingUserRights 59
#define DCTVS_AccountOptions_CSVResultFile 60
#define DCTVS_AccountOptions_RenameOnly 61
#define DCTVS_AccountOptions_AddSidHistory 62
#define DCTVS_AccountOptions_TranslateRoamingProfiles 63
#define DCTVS_LocalServer_RenameTo      64
#define DCTVS_LocalServer_ChangeDomain  65
#define DCTVS_LocalServer_Reboot        66
#define DCTVS_LocalServer_RebootDelay   67
#define DCTVS_LocalServer_MigrateOnly   68
#define DCTVS_Servers_NumItems          69
#define DCTVS_JobStatus                 70
#define DCTVS_CurrentPath               71
#define DCTVS_Server_Index              72
#define DCTVS_Options_DontBeginNewLog   73
#define DCTVS_CurrentOperation          141
#define DCTVS_Results_ErrorLevel        142
#define DCTVS_Stats_Paths               144
#define DCTVS_Stats_Servers             145
#define DCTVS_Stats_Files_Examined      146
#define DCTVS_Stats_Files_Changed       147
#define DCTVS_Stats_Files_Skipped       148
#define DCTVS_Stats_Files_CacheHits     149
#define DCTVS_Stats_Directories_Examined 150
#define DCTVS_Stats_Directories_Changed 151
#define DCTVS_Stats_Directories_Skipped 152
#define DCTVS_Stats_Directories_CacheHits 153
#define DCTVS_Stats_Shares_Examined     154
#define DCTVS_Stats_Shares_Changed      155
#define DCTVS_Stats_Shares_Skipped      156
#define DCTVS_Stats_Shares_CacheHits    157
#define DCTVS_Stats_Members_Examined    158
#define DCTVS_Stats_Members_Changed     159
#define DCTVS_Stats_Members_Skipped     160
#define DCTVS_Stats_Members_CacheHits   161
#define DCTVS_Stats_UserRights_Examined 162
#define DCTVS_Stats_UserRights_Changed  163
#define DCTVS_Stats_UserRights_Skipped  164
#define DCTVS_Stats_UserRights_CacheHits 165
#define DCTVS_Stats_Mailboxes_Examined  166
#define DCTVS_Stats_Mailboxes_Changed   167
#define DCTVS_Stats_Mailboxes_Skipped   168
#define DCTVS_Stats_Mailboxes_CacheHits 169
#define DCTVS_Stats_Containers_Examined 170
#define DCTVS_Stats_Containers_Changed  171
#define DCTVS_Stats_Containers_Skipped  172
#define DCTVS_Stats_Containers_CacheHits 173
#define DCTVS_Stats_Owners_Examined     174
#define DCTVS_Stats_Groups_Examined     175
#define DCTVS_Stats_DACL_Examined       176
#define DCTVS_Stats_SACL_Examined       177
#define DCTVS_Stats_DACE_Examined       178
#define DCTVS_Stats_SACE_Examined       179
#define DCTVS_Stats_Owners_Changed      180
#define DCTVS_Stats_Groups_Changed      181
#define DCTVS_Stats_DACL_Changed        182
#define DCTVS_Stats_SACL_Changed        183
#define DCTVS_Stats_DACE_Changed        184
#define DCTVS_Stats_SACE_Changed        185
#define DCTVS_Stats_Owners_NoTarget     186
#define DCTVS_Stats_Groups_NoTarget     187
#define DCTVS_Stats_DACE_NoTarget       188
#define DCTVS_Stats_SACE_NoTarget       189
#define DCTVS_Stats_Owners_NotSelected  190
#define DCTVS_Stats_Groups_NotSelected  191
#define DCTVS_Stats_DACE_NotSelected    192
#define DCTVS_Stats_SACE_NotSelected    193
#define DCTVS_Stats_Owners_Unknown      194
#define DCTVS_Stats_Groups_Unknown      195
#define DCTVS_Stats_DACE_Unknown        196
#define DCTVS_Stats_SACE_Unknown        197
#define DCTVS_Stats_Accounts_NumUsers   198
#define DCTVS_Stats_Accounts_NumGlobalGroups 199
#define DCTVS_Stats_Accounts_NumLocalGroups 200
#define DCTVS_Stats_Accounts_NumOther   201
#define DCTVS_Stats_Users_Examined      202
#define DCTVS_Stats_Users_Created       203
#define DCTVS_Stats_Users_Replaced      204
#define DCTVS_Stats_Users_Warnings      205
#define DCTVS_Stats_Users_Errors        206
#define DCTVS_Stats_GlobalGroups_Examined 207
#define DCTVS_Stats_GlobalGroups_Created 208
#define DCTVS_Stats_GlobalGroups_Replaced 209
#define DCTVS_Stats_GlobalGroups_Warnings 210
#define DCTVS_Stats_GlobalGroups_Errors 211
#define DCTVS_Stats_LocalGroups_Examined 212
#define DCTVS_Stats_LocalGroups_Created 213
#define DCTVS_Stats_LocalGroups_Replaced 214
#define DCTVS_Stats_LocalGroups_Warnings 215
#define DCTVS_Stats_LocalGroups_Errors  216
#define DCTVS_Stats_Computers_Examined  217
#define DCTVS_Stats_Computers_Created   218
#define DCTVS_Stats_Computers_Replaced  219
#define DCTVS_Stats_Computers_Warnings  220
#define DCTVS_Stats_Computers_Errors    221
#define DCTVS_AgentService_DebugMode    222
#define IDS_DISPLAY_NAME                223
#define IDS_SERVICE_NAME                224
#define IDS_LOCALSERVICE_PATH           225
#define IDS_SERVICE_PATH                226
#define IDS_AGENT_EXE                   227
#define IDS_SERVICE_EXE                 228
#define IDS_WORKER_DLL                  229
#define IDS_VARSET_DLL                  230
#define IDS_DATA_FILE                   231
#define IDS_EVENTSOURCE                 232
#define IDS_APPNAME                     233
#define IDS_LOG_FILENAME                234
#define DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha 235
#define DCTVS_AccountOptions_PasswordPolicy_MinUpper 236
#define DCTVS_AccountOptions_PasswordPolicy_MinLower 237
#define DCTVS_AccountOptions_PasswordPolicy_MinSpecial 238
#define DCTVS_AccountOptions_PasswordPolicy_MinDigit 239
#define IDS_DOMAIN_ADMIN_REGKEY         240
#define IDS_AgentResultFileFmt          241
#define IDS_ACCT_REPL_OPERATION_TEXT    242
#define IDS_FST_OPERATION_TEXT          243
#define IDS_EST_OPERATION_TEXT          244
#define IDS_DCT_Status_Completed        245
#define DCTVSFmt_Accounts_D             246
#define DCTVSFmt_Accounts_TargetName_D  247
#define DCTVSFmt_Accounts_Type_D        248
#define IDS_LGST_OPERATION_TEXT         249
#define IDS_URST_OPERATION_TEXT         250
#define DCTVSFmt_Servers_D              251
#define IDS_RESULT_SHARE_NAME           252
#define IDS_RESULT_SHARE_REMARK         253
#define IDS_CACHE_FILE_NAME             254
#define IDS_DCTVSFmt_MigrateServers_D   255
#define IDS_DCTVSFmt_MigrateServers_RenameTo_D 256
#define IDS_DCTVSFmt_MigrateServers_ChangeDomain_D 257
#define IDS_DCTVSFmt_MigrateServers_Reboot_D 258
#define IDS_DCTVSFmt_MigrateServers_RebootDelay_D 259
#define IDS_DCTVSFmt_Servers_RenameTo_D 260
#define IDS_DCTVSFmt_Servers_ChangeDomain_D 261
#define IDS_DCTVSFmt_Servers_Reboot_D   262
#define IDS_DCTVSFmt_Servers_RebootDelay_D 263
#define IDS_DCTVSFmt_Servers_MigrateOnly_D 264
#define DCTVS_Options_CreateTempCredentials 265
#define DCTVS_Options_OuPath            266
#define IDS_DCTVSFmt_PlugIn_RegisterFiles_D 267
#define IDS_YES                         268
#define IDS_DEBUG_SWITCH                269
#define IDS_HKLM_DomainAdmin_Key        270
#define IDS_AGENT_DIRECTORY             271
#define IDS_DCTVS_Fmt_PlugIn_D          272
#define DCTVS_Options                   273
#define DCTVS_Accounts                  274
#define IDS_Replace                     275
#define IDS_MSG_ComputerAccountNotWorkstation 276
#define IDS_DCT_Status_NotStarted       277
#define IDS_DCT_Status_InProgress       278
#define IDS_DCT_Status_Aborting         279
#define IDS_DCT_Status_Aborted          280
#define IDS_DCT_Status_Unknown          281
#define DCTVS_Stats                     282
#define IDS_DCT_NoStatsAvailable        283
#define IDS_DCTVSFmt_Job_D              284
#define IDS_DCTVSFmt_JobStatus_D        285
#define IDS_DCTVSFmt_Job_StartTime_D    286
#define IDS_DCTVSFmt_Job_EndTime_D      287
#define IDS_DCTVSFmt_PlugIn_D           288
#define IDS_DCTVSFmt_PlugIn_Interface_D 289
#define DCTVS_PlugIn_Interface_Count    290
#define DCTVS_CopiedAccount_SourceName  291
#define DCTVS_CopiedAccount_SourcePath  292
#define DCTVS_CopiedAccount_SourceRID   293
#define DCTVS_CopiedAccount_SourceSam   294
#define DCTVS_CopiedAccount_SourceProfile 295
#define DCTVS_CopiedAccount_Status      296
#define DCTVS_CopiedAccount_TargetName  297
#define DCTVS_CopiedAccount_TargetPath  298
#define DCTVS_CopiedAccount_TargetProfile 299
#define DCTVS_CopiedAccount_TargetRID   300
#define DCTVS_CopiedAccount_TargetSam   301
#define DCTVS_CopiedAccount_Type        302
#define IDS_Special                     303
#define IDS_All                         304
#define IDS_AccountMigration            305
#define IDS_WriteChanges_No             306
#define IDS_CopyUsers_Yes               307
#define IDS_CopyUsers_No                308
#define IDS_CopyGlobalGroups_Yes        309
#define IDS_CopyGlobalGroups_No         310
#define IDS_CopyLocalGroups_Yes         311
#define IDS_CopyLocalGroups_No          312
#define IDS_CopyComputers_Yes           313
#define IDS_CopyComputers_No            314
#define IDS_ReplaceExisting_Yes         315
#define IDS_DisableAll_Yes              316
#define IDS_DisableSpecial_Yes          317
#define IDS_DisableSourceAccounts_Yes   318
#define IDS_StrongPwd_All               319
#define IDS_StrongPwd_Special           320
#define IDS_PasswordFile                321
#define IDS_AddToGroup                  322
#define IDS_AddToGroupOnTargetDescription_S 323
#define IDS_AddToGroupOnSourceDescription_S 324
#define IDS_NotAllowedOnDomainController 325
#define IDS_CannotTrustSelf             326
#define IDS_CannotGetDCName             327
#define IDS_No                          328
#define IDS_ScanningExchangeDirectory   329
#define IDS_Examining                   331
#define IDS_Add                         332
#define IDS_Remove                      333
#define DCTVS_Options_DispatchCSV       334
#define DCTVS_SUB_ERROR                 335
#define IDS_UNKNOWN_TYPE                336
#define DCTVS_Options_SourceServer      337
#define DCTVS_Options_TargetServer      338
#define DCTVS_AccountOptions_Suffix     339
#define DCTVS_AccountOptions_CopyCompters 340
#define DCTVS_AccountOptions_CopyOUs    341
#define DCTVS_AccountOptions_CopyContainerContents 342
#define DB_ActionID                     343
#define DB_Time                         344
#define DB_SourceDomain                 345
#define DB_TargetDomain                 346
#define DB_SourceAdsPath                347
#define DB_TargetAdsPath                348
#define DB_SourceSamName                349
#define DB_TargetSamName                350
#define DB_Type                         351
#define DB_GUID                         352
#define DB_status                       353
#define DCTVS_CopiedAccount_GUID        354
#define IDS_CLSET_MEMBER_NOT_INCLUDED   355
#define IDS_CLSET_GROUP_NOT_INCLUDED    356
#define DCTVS_Options_AppendToLogs      357
#define DCTVS_Options_Undo              358
#define DCTVS_Options_GlobalOperationMask 359
#define DCTVS_Accounts_D_OperationMask  360
#define DCTVS_ActionID_D                361
#define DCTVS_ActionID_Servers_SD       362
#define DCTVS_ActionID_Servers_Status_SD 363
#define DCTVS_AREXT_NUMITEM             364
#define DCTVS_AREXTENSIONS_D            365
#define DCTVS_Security_TranslateMigratedObjects 366
#define DCTVS_AccountOptions_ExpireSourceAccounts 367
#define DCTVS_AccountOptions_SidHistoryCredentials_Domain 368
#define DCTVS_AccountOptions_SidHistoryCredentials_UserName 369
#define DCTVS_AccountOptions_SidHistoryCredentials_Password 370
#define DCTVS_AccountOptions_CopyMemberOf 371
#define DCTVS_DBManager                 372
#define DCTVS_Servers                   373
#define DCTVS_Reports_Generate          374
#define DCTVS_Reports_Directory         375
#define DCTVS_Reports_MigratedAccounts  376
#define DCTVS_Reports_MigratedComputers 377
#define DCTVS_Reports_ExpiredComputers  378
#define DCTVS_Reports_AccountReferences 379
#define DCTVS_Reports_NameConflicts     380
#define IDS_REGKEY_REPORTS              381
#define IDS_REGST_OPERATION_TEXT        382
#define DCTVS_Security_TranslateRegistry 383
#define DCTVS_AccountOptions_IncludeMigratedAccts 384
#define DCTVS_GatherInformation         385
#define DCTVS_Options_Prefix            386
#define DCTVS_Options_Suffix            387
#define DCTVS_AccountOptions_PasswordPolicy_MinLength 388
#define DCTVS_Options_SourceDomainDns   389
#define DCTVS_Options_TargetDomainDns   390
#define IDS_REPORT_MigratedAccounts     391
#define IDS_REPORT_MigratedComputers    392
#define IDS_REPORT_ExpiredComputers     393
#define IDS_REPORT_AccountReferences    394
#define IDS_REPORT_NameConflicts        395
#define IDS_TABLE_FIELD_SourceDomain    396
#define IDS_TABLE_FIELD_TargetDomain    397
#define IDS_TABLE_FIELD_Type            398
#define IDS_TABLE_FIELD_SourceAdsPath   399
#define IDS_TABLE_FIELD_TargetAdsPath   400
#define IDS_TABLE_FIELD_Status          401
#define IDS_TABLE_FIELD_Time            402
#define IDS_TABLE_FIELD_DomainName      403
#define IDS_TABLE_FIELD_CompName        404
#define IDS_TABLE_FIELD_Description     405
#define IDS_TABLE_FIELD_PwdAge          406
#define IDS_TABLE_FIELD_Account         407
#define IDS_TABLE_FIELD_Server          408
#define IDS_TABLE_FIELD_RefCount        409
#define IDS_TABLE_FIELD_RefType         410
#define IDS_TABLE_FIELD_SourceType      411
#define IDS_TABLE_FIELD_TargetType      412
#define IDS_TABLE_FIELD_SourceDesc      413
#define IDS_TABLE_FIELD_TargetDesc      414
#define IDS_TABLE_FIELD_SrcFullName     415
#define IDS_TABLE_FIELD_TgtFullName     416
#define IDS_NAMECONFLICTS               417
#define IDS_DISPATCHING                 418
#define DCTVS_Options_Wizard            419
#define DCTVS_Reports_MigratedAccounts_TimeGenerated 421
#define DCTVS_Reports_MigratedComputers_TimeGenerated 422
#define DCTVS_Reports_ExpiredComputers_TimeGenerated 423
#define DCTVS_Reports_AccountReferences_TimeGenerated 424
#define DCTVS_Reports_NameConflicts_TimeGenerated 425
#define DCTVS_Options_GuiOnlyRebootSaver 426
#define DCTVS_CopiedAccount_DoNotUpdatePassword 427
#define IDS_TEMP_FILE_1                 428
#define IDS_TEMP_FILE_2                 429
#define IDS_HKLM_WINDOWS_NT             430
#define IDS_CurrentVersion              431
#define IDS_CSDVersion                  432
#define IDS_HKLM_MICROSOFT              433
#define IDS_START_FAILED                434
#define IDS_UNSOUPPORTED_OS             435
#define IDS_AGENT_RUNNING               436
#define DCTVS_Options_DeleteJobFile     437
#define IDS_BUILDING_ACCOUNT_LIST       438
#define IDS_EXPANDING_MEMBERSHIP        439
#define IDS_EXPANDING_CONTAINERS        440
#define IDS_MERGING_EXPANDED_LISTS      441
#define IDS_CREATING_S                  442
#define IDS_MAPPING_PROPS_S             443
#define IDS_UPDATING_PROPS_S            444
#define IDS_EVENT_SOURCE                445
#define IDS_RUNNING_EXTS_S              446
#define IDS_TRANSLATE_ROAMING_PROFILE_S 447
#define IDS_ADDING_SIDHISTORY_S         448
#define IDS_UPDATING_GROUP_MEMBERSHIPS_S 449
#define IDS_EXPANDING_ADDING_SS         450
#define IDS_EXPANDING_IGNORING_SS       451
#define IDS_EXPANDING_GROUP_ADDING_SS   452
#define IDS_DELETING_S                  453
#define DCTVS_Options_IsIntraforest     454
#define IDS_EXTRACTING_COMP_PWD_AGE     455
#define IDS_Gathering_SvcAcct           456
#define DCTVS_Results_LogFile           457
#define IDS_REGKEY_PROFILE_EXTENSIONS   458
#define IDS_COM_DisTarget               459
#define IDS_COM_DisPid                  460
#define IDS_COM_DisPidVer               461
#define IDS_COM_AcctReplName            462
#define IDS_COM_AcctReplPid             463
#define IDS_COM_AcctReplPidVer          464
#define IDS_COM_ChgDomName              465
#define IDS_COM_ChgDomPidVer            466
#define IDS_COM_ChgDomPid               467
#define IDS_COM_ChkName                 468
#define IDS_COM_ChkPid                  469
#define IDS_COM_ChkPidVer               470
#define IDS_COM_PIInfoName              471
#define IDS_COM_PIInfoPid               472
#define IDS_COM_PIInfoPidVer            473
#define IDS_COM_CompAgeName             474
#define IDS_COM_CompAgePid              475
#define IDS_COM_CompAgePidVer           476
#define IDS_COM_RebootName              477
#define IDS_COM_RebootPid               478
#define IDS_COM_RebootPidVer            479
#define IDS_COM_RenameName              480
#define IDS_COM_RenamePid               481
#define IDS_COM_RenamePidVer            482
#define IDS_COM_SecTransName            483
#define IDS_COM_SecTransPid             484
#define IDS_COM_SecTransPidVer          485
#define IDS_COM_StatusObjName           486
#define IDS_COM_StatusObjPid            487
#define IDS_COM_StatusObjPidVer         488
#define IDS_COM_URName                  489
#define IDS_COM_URPid                   490
#define IDS_COM_URPidVer                491
#define DB_SourceRid                    492
#define DB_TargetRid                    493
#define IDS_DOM_LOC_GRP_COMMENT         494
#define DCTVS_CopiedAccount_Operations  495
#define IDS_Reporting                   496
#define IDS_ReportsMMCNode              497
#define IDS_ActiveDirectoryMigrationTool 503
#define DCTVS_Stats_Generic_Errors      504
#define DCTVS_Stats_Generic_Warnings    505
#define DCTVS_Stats_Generic_Examined    506
#define DCTVS_Stats_Generic_Created     507
#define DCTVS_Stats_Generic_Replaced    508
#define IDS_Unspecified_Failure         509
#define IDS_RegKeyRebootMessage         510
#define IDS_UNRESOLVED                  511
#define IDS_AGENT_INTEL_DIR             512
#define IDS_AGENT_ALPHA_DIR             513
#define IDS_STReference_File            514
#define IDS_STReference_Dir             515
#define IDS_STReference_Share           516
#define IDS_STReference_Mailbox         517
#define IDS_STReference_Container       518
#define IDS_STReference_Member          519
#define IDS_STReference_UserRight       520
#define IDS_STReference_RegKey          521
#define IDS_STReference_Printer         522
#define DCTVS_Options_SourceServerOverride 523
#define DCTVS_Options_TargetServerOverride 524
#define DCTVS_Options_AllowDuplicateUPNs 525
#define DCT_MSG_CHANGE_GROUP_TYPE_S     526
#define DCT_MSG_RECORD_REMOVE_MEMBER_S  527
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_S 528
#define DCT_MSG_UPDATE_MEMBER_LIST_S    529
#define DCT_MSG_RESET_GROUP_MEMBERS_S   530
#define DCT_MSG_RESET_MEMBERSHIP_S      531
#define DCT_MSG_MOVING_S                532
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_SS 533
#define DCT_MSG_RESET_OBJECT_MEMBERSHIP_SS 534
#define DCT_MSG_RECORD_REMOVE_MEMBER_SS 535
#define DCT_MSG_RESET_GROUP_MEMBERS_SS  536
#define IDS_HiddenShare                 537
#define IDS_AgentDirectoryName          538
#define IDS_HiddenShareRemark           539
#define DCTVS_Security_AlternateCacheFile 540
#define IDS_RenamedRecyclerSuffix       541
#define DCTVS_Security                  542
#define DCTVS_CopiedAccount_ExpDate     543
#define DCTVS_CopiedAccount_UserFlags   544
#define DB_ExpDate                      545
#define DB_UserFlags                    546
#define IDS_TRUST_DIRECTION_DISABLED    547
#define IDS_TRUST_DIRECTION_INBOUND     548
#define IDS_TRUST_DIRECTION_OUTBOUND    549
#define IDS_TRUST_DIRECTION_BIDIRECTIONAL 550
#define IDS_TRUST_TYPE_DOWNLEVEL        551
#define IDS_TRUST_TYPE_CHILD            552
#define IDS_EVENTVW_MSG_MONJOBSTAT      553
#define IDS_EVENTVW_MSG_MONERROR        554
#define IDS_EVENTVW_MSG_MONEXIT         555
#define IDS_EVENTVW_MSG_STARTPLUGREG    556
#define IDS_EVENTVW_MSG_FILEREG         557
#define IDS_EVENTVW_MSG_PLUGREGDONE     558
#define IDS_EVENTVW_MSG_JOBDEL          559
#define IDS_EVENTVW_MSG_SETFLAG         560
#define IDS_EVENTVW_MSG_NOSETFLAG       561
#define IDS_EVENTVW_MSG_REMOVEAGENT     562
#define IDS_EVENTVW_MSG_UNREGFILES      563
#define IDS_EVENTVW_MSG_FILEDEL         564
#define IDS_EVENTVW_MSG_REMOVESVC       565
#define IDS_EVENTVW_MSG_NOREMOVEAGENT   566
#define IDS_EVENTVW_MSG_STOPLISTEN      567
#define IDS_EVENTVW_MSG_AGENTSVCINSTALLED 568
#define IDS_EVENTVW_MSG_AGENTSVCNOTINSTALLED 569
#define IDS_EVENTVW_MSG_OSVERSION       570
#define IDS_EVENTVW_MSG_REGISTERED      571
#define IDS_EVENTVW_MSG_UNREGISTERED    572
#define IDS_EVENTVW_MSG_INITOLE         573
#define IDS_EVENTVW_MSG_REGCOMPNT       574
#define IDS_EVENTVW_MSG_CREATEAGT       575
#define IDS_EVENTVW_MSG_INITRPC         576
#define IDS_EVENTVW_MSG_LISTENQ         577
#define IDS_EVENTVW_MSG_EXITENTRYP      578
#define IDS_EVENTVW_MSG_AGTEXITQ        579
#define IDS_EVENTVW_MSG_AGTEXITS        580
#define IDS_STOptions_Start             581
#define IDS_STOptions_WriteChng         582
#define IDS_STOptions_Files             583
#define IDS_STOptions_Shares            584
#define IDS_STOptions_LocalGroup        585
#define IDS_STOptions_URights           586
#define IDS_STOptions_Profiles          587
#define IDS_STOptions_RBin              588
#define IDS_STOptions_LogName           589
#define IDS_STOptions_AddMode           590
#define IDS_STOptions_RemoveMode        591
#define IDS_STOptions_ReplaceMode       592
#define IDS_STOptions_Printers          593
#define IDS_TypeUser                    594
#define IDS_TypeGroup                   595
#define IDS_TypeComputer                596
#define IDS_TypeUnknown                 597
#define IDS_DCTVSFmt_Servers_SkipDispatch_D 598
#define DCTVS_AccountOptions_FixMembership 599
#define DCTVSFmt_Accounts_SourceUPN_D   600
#define DCTVS_CopiedAccount_SourceUPN   601
#define IDS_PwdAgeDays                  602
#define DB_SourceDomainSid              603
#define DCTVS_CopiedAccount_SourceDomainSid 604
#define DCTVS_AccountOptions_PasswordDC 605
#define DCTVS_Options_AutoCloseHideDialogs 606
#define IDS_TABLE_FIELD_AccountSid      607
#define IDS_TABLE_NC_SDOMAIN            608
#define IDS_TABLE_NC_TDOMAIN            609
#define IDS_TABLE_AR_MOT_HDR            610
#define IDS_TABLE_AR_NOTMOT_HDR         611
#define DCTVS_AccountOptions_SecurityMapFile 612
#define DCTVS_AccountOptions_SecurityInputMOT 613
#define IDS_UnknownSid                  614
#define DCTVS_AccountOptions_MoveReplacedAccounts 615
#define IDS_USERPROPS                   616
#define IDS_GROUPPROPS                  617
#define IDS_COMPUTERPROPS               618
#define DCTVS_AccountOptions_ExcludedUserProps 619
#define DCTVS_AccountOptions_ExcludedGroupProps 620
#define DCTVS_AccountOptions_ExcludedComputerProps 621
#define DCTVS_AccountOptions_ExcludeProps 622
#define IDS_UPDATING_MGR_PROPS_S        623
#define IDS_TRUST_RELATION_ROOT         624
#define IDS_TRUST_RELATION_PARENT       625
#define IDS_TRUST_RELATION_CHILD        626
#define IDS_TRUST_RELATION_SHORTCUT     627
#define IDS_TRUST_RELATION_EXTERNAL     628
#define IDS_TRUST_RELATION_FOREST       629
#define IDS_TRUST_RELATION_INDIRECT     630
#define IDS_TRUST_RELATION_SELF         631
#define IDS_TRUST_RELATION_MIT          632
#define IDS_TRUST_RELATION_DCE          633
#define IDS_TRUST_RELATION_UNKNOWN      634
#define IDS_INVALID_PREFIX_SUFFIX       635
#define IDS_LG_MEMBER_FIXUP_UNDO        636
#define IDS_ADMT_ACCOUNT_DESCRIPTION    637
#define DCTVS_AccountOptions_TgtStateSameAsSrc 638
#define IDS_TABLE_FIELD_SourceRDN       639
#define IDS_TABLE_FIELD_ConflictAtt     640
#define IDS_TABLE_FIELD_TargetCanonicalName 641
#define IDS_TABLE_SAM_CONFLICT_VALUE    642
#define IDS_TABLE_RDN_CONFLICT_VALUE    643
#define IDS_AGENT_NT4_DIR               644

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\acctrepl.cpp ===
// AcctReplTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "driver.h"
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#include "AcctRepl.h"
#include "VSEdit.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAcctReplTestDlg property page

IMPLEMENT_DYNCREATE(CAcctReplTestDlg, CPropertyPage)

CAcctReplTestDlg::CAcctReplTestDlg() : CPropertyPage(CAcctReplTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CAcctReplTestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CAcctReplTestDlg::~CAcctReplTestDlg()
{
}

void CAcctReplTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAcctReplTestDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAcctReplTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CAcctReplTestDlg)
	ON_BN_CLICKED(IDC_EDIT_VARSET, OnEditVarset)
	ON_BN_CLICKED(IDC_PROCESS, OnProcess)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAcctReplTestDlg message handlers

void CAcctReplTestDlg::OnEditVarset() 
{
   CVarSetEditDlg          vedit;

   vedit.SetVarSet(pVarSet);

   vedit.DoModal();

   pVarSet = vedit.GetVarSet();

}

void CAcctReplTestDlg::OnProcess() 
{
   UpdateData(TRUE);
   CWaitCursor    w;
   if ( pVarSet == NULL )
   {
      OnEditVarset();
   }
   if ( pVarSet != NULL )
   {
      IUnknown       * pUnk = NULL;
      pVarSet.QueryInterface(IID_IUnknown,&pUnk);

      HRESULT hr = pAR->raw_Process(pUnk);
      if (SUCCEEDED(hr) )
      {
         MessageBox(L"AcctRepl::Process succeeded!");
      }
      else
      {
         CString        str;
         str.Format(L"AcctRepl::Process failed, hr=%lx",hr);

         MessageBox(str);
      }
      pUnk->Release();
   }
   else
   {
      MessageBox(L"The varset pointer is NULL.");
   }	
}

BOOL CAcctReplTestDlg::OnSetActive() 
{
   HRESULT hr = pAR.CreateInstance(CLSID_AcctRepl);	
   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"Failed to create Account Replicator, CoCreateInstance returned %lx",hr);
      MessageBox(msg);
   }
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\accchk.h ===
#if !defined(AFX_ACCESSCHECKTESTDLG_H__B28540D0_34C6_11D3_8AE8_00A0C9AFE114__INCLUDED_)
#define AFX_ACCESSCHECKTESTDLG_H__B28540D0_34C6_11D3_8AE8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AccessCheckTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAccessCheckTestDlg dialog

class CAccessCheckTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CAccessCheckTestDlg)

// Construction
public:
	CAccessCheckTestDlg();
	~CAccessCheckTestDlg();

// Dialog Data
	//{{AFX_DATA(CAccessCheckTestDlg)
	enum { IDD = IDD_ACCESS_CHECKER };
	CString	m_Computer;
	CString	m_strTargetDomain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAccessCheckTestDlg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   IAccessCheckerPtr          pAC;
	// Generated message map functions
	//{{AFX_MSG(CAccessCheckTestDlg)
	afx_msg void OnGetOsVersion();
	afx_msg void OnIsAdmin();
	afx_msg void OnIsNativeMode();
	afx_msg void OnInSameForest();
	afx_msg void OnIsNativeMode2();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACCESSCHECKTESTDLG_H__B28540D0_34C6_11D3_8AE8_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\acctrepl.h ===
#if !defined(AFX_ACCTREPLTESTDLG_H__377A8010_3246_11D3_99E9_0010A4F77383__INCLUDED_)
#define AFX_ACCTREPLTESTDLG_H__377A8010_3246_11D3_99E9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AcctReplTestDlg.h : header file
//
#include "Driver.h"
#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
/////////////////////////////////////////////////////////////////////////////
// CAcctReplTestDlg dialog

class CAcctReplTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CAcctReplTestDlg)

// Construction
public:
	CAcctReplTestDlg();
	~CAcctReplTestDlg();

// Dialog Data
	//{{AFX_DATA(CAcctReplTestDlg)
	enum { IDD = IDD_ACCTREPL_TEST };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CAcctReplTestDlg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   IVarSetPtr           pVarSet;
   IAcctReplPtr         pAR;
	// Generated message map functions
	//{{AFX_MSG(CAcctReplTestDlg)
	afx_msg void OnEditVarset();
	afx_msg void OnProcess();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACCTREPLTESTDLG_H__377A8010_3246_11D3_99E9_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\accchk.cpp ===
// AccessCheckTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Driver.h"
#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
#include "AccChk.h"
#include "sidflags.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAccessCheckTestDlg property page

IMPLEMENT_DYNCREATE(CAccessCheckTestDlg, CPropertyPage)

CAccessCheckTestDlg::CAccessCheckTestDlg() : CPropertyPage(CAccessCheckTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CAccessCheckTestDlg)
	m_Computer = _T("");
	m_strTargetDomain = _T("");
	//}}AFX_DATA_INIT
}

CAccessCheckTestDlg::~CAccessCheckTestDlg()
{
}

void CAccessCheckTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAccessCheckTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	DDX_Text(pDX, IDC_COMPUTER2, m_strTargetDomain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAccessCheckTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CAccessCheckTestDlg)
	ON_BN_CLICKED(IDC_GET_OS_VERSION, OnGetOsVersion)
	ON_BN_CLICKED(IDC_IS_ADMIN, OnIsAdmin)
	ON_BN_CLICKED(IDC_IS_NATIVE_MODE, OnIsNativeMode)
	ON_BN_CLICKED(IDC_BUTTON1, OnInSameForest)
	ON_BN_CLICKED(IDC_IS_NATIVE_MODE2, OnIsNativeMode2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAccessCheckTestDlg message handlers

void CAccessCheckTestDlg::OnGetOsVersion() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   HRESULT           hr;
   CString           info;
   unsigned long     maj,min,sp;

   hr = pAC->raw_GetOsVersion(m_Computer.AllocSysString(),&maj,&min,&sp);
   if ( SUCCEEDED(hr) )
   {
      info.Format(L"The OS version for %ls is %ld.%ld",m_Computer,maj,min);
   }
   else
   {
      info.Format(L"Failed to get the OS version, hr=%lx",hr);
   }
   MessageBox(info);
}

void CAccessCheckTestDlg::OnIsAdmin() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   HRESULT           hr;
   CString           info;
   long              bIs;

   hr = pAC->raw_IsAdmin(NULL,m_Computer.AllocSysString(),&bIs);
   if ( SUCCEEDED(hr) )
   {
      if ( bIs != 0 )
      {
         info.Format(L"Yes");
      }
      else
      {
         info = L"No";
      }
   }
   else
   {
      info.Format(L"Failed to check for administrator permissions, hr=%lx",hr);
   }
   MessageBox(info);

}

void CAccessCheckTestDlg::OnIsNativeMode() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   
   HRESULT  hr = pAC->raw_AddLocalGroup(SysAllocString(L"devchild"),SysAllocString(L"\\\\bolesw2ktest"));

   if ( SUCCEEDED(hr) )
   {

      MessageBox(L"This function is not yet implemented.");
   }
   else
   {
      MessageBox(L"This function failed.");
   }
	
}

BOOL CAccessCheckTestDlg::OnSetActive() 
{
	HRESULT        hr = pAC.CreateInstance(CLSID_AccessChecker);
	if ( FAILED(hr) )
   {
      CString s;
      s.Format(L"Failed to create AccessChecker COM object, hr=%lx",hr);
   }
	return CPropertyPage::OnSetActive();
}

void CAccessCheckTestDlg::OnInSameForest() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   HRESULT           hr;
   CString           info;
   long              bIs;

   hr = pAC->raw_IsInSameForest(m_Computer.AllocSysString(), m_strTargetDomain.AllocSysString(),&bIs);
   if ( SUCCEEDED(hr) )
   {
      if ( bIs != 0 )
      {
         info.Format(L"Yes");
      }
      else
      {
         info = L"No";
      }
   }
   else
   {
      info.Format(L"Failed to check for administrator permissions, hr=%lx",hr);
   }
   MessageBox(info);
}

void CAccessCheckTestDlg::OnIsNativeMode2() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   HRESULT           hr;
   CString           info;
   long              bIs;

   hr = pAC->raw_CanUseAddSidHistory(m_Computer.AllocSysString(), m_strTargetDomain.AllocSysString(),&bIs);
   if ( SUCCEEDED(hr) )
   {
      if ( bIs == 0 )
      {
         info.Format(L"Yes");
      }
      else
      {
         info = L"Following are the reasons why SID history will not work on these domains.\n";
         if ( bIs & F_WRONGOS )
            info += L"  Target domain is not a native mode Win2k domain.\n";

         if ( bIs & F_NO_REG_KEY )
            info += L"  TcpipControlSupport regkey is not set on the source domain\n";

         if ( bIs & F_NO_AUDITING_SOURCE )
            info += L"  Auditing is turned off on the source domain.\n";

         if ( bIs & F_NO_AUDITING_TARGET )
            info += L"  Auditing is turned off on the target domain.\n";

         if ( bIs & F_NO_LOCAL_GROUP )
            info += L"  The <SourceDomain>$$$ local group does not exist.\n";
      }
   }
   else
   {
      info.Format(L"Failed to check for add sid history, hr=%lx",hr);
   }
   MessageBox(info);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\dispatch.cpp ===
// DispatcherTestDlg.cpp : implementation file
//

#include "stdafx.h"
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "\bin\McsDispatcher.tlb" named_guids
#include "Driver.h"
#include "Dispatch.h"
#include "VSEdit.h"

/////////////////////////////////////////////////////////////////////////////
// CDispatcherTestDlg property page

IMPLEMENT_DYNCREATE(CDispatcherTestDlg, CPropertyPage)

CDispatcherTestDlg::CDispatcherTestDlg() : CPropertyPage(CDispatcherTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CDispatcherTestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CDispatcherTestDlg::~CDispatcherTestDlg()
{
}

void CDispatcherTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDispatcherTestDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDispatcherTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CDispatcherTestDlg)
	ON_BN_CLICKED(IDC_DISPATCH, OnDispatch)
	ON_BN_CLICKED(IDC_EDIT_VARSET, OnEditVarset)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDispatcherTestDlg message handlers

void CDispatcherTestDlg::OnDispatch() 
{
      UpdateData(TRUE);
      CWaitCursor    w;
      if ( pVarSet == NULL )
      {
         OnEditVarset();
      }
      if ( pVarSet != NULL )
      {
         IUnknown       * pUnk = NULL;
         pVarSet.QueryInterface(IID_IUnknown,&pUnk);

         HRESULT hr = pDispatcher->raw_DispatchToServers(&pUnk);
         if (SUCCEEDED(hr) )
         {
            MessageBox(L"DispatchToServers succeeded!");
         }
         else
         {
            CString        str;
            str.Format(L"DispatchToServers failed, hr=%lx",hr);

            MessageBox(str);
         }
         pUnk->Release();
      }
      else
      {
         MessageBox(L"The varset pointer is NULL.");
      }
}

void CDispatcherTestDlg::OnEditVarset() 
{
   CVarSetEditDlg          vedit;

   vedit.SetVarSet(pVarSet);

   vedit.DoModal();

   pVarSet = vedit.GetVarSet();

}

BOOL CDispatcherTestDlg::OnSetActive() 
{
   HRESULT hr = pDispatcher.CreateInstance(MCSDISPATCHERLib::CLSID_DCTDispatcher);	
   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"Failed to create dispatcher, CoCreateInstance returned %lx",hr);
      MessageBox(msg);
   }
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\chgdom.cpp ===
// ChangeDomTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "driver.h"
#include "ChgDom.h"

#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChangeDomTestDlg property page

IMPLEMENT_DYNCREATE(CChangeDomTestDlg, CPropertyPage)

CChangeDomTestDlg::CChangeDomTestDlg() : CPropertyPage(CChangeDomTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CChangeDomTestDlg)
	m_Computer = _T("");
	m_Domain = _T("");
	m_NoChange = FALSE;
	//}}AFX_DATA_INIT
}

CChangeDomTestDlg::~CChangeDomTestDlg()
{
}

void CChangeDomTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CChangeDomTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	DDX_Text(pDX, IDC_DOMAIN, m_Domain);
	DDX_Check(pDX, IDC_NOCHANGE, m_NoChange);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CChangeDomTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CChangeDomTestDlg)
	ON_BN_CLICKED(IDC_CHANGE_DOMAIN, OnChangeDomain)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChangeDomTestDlg message handlers

void CChangeDomTestDlg::OnChangeDomain() 
{
	UpdateData(TRUE);
   CWaitCursor    w;
   IChangeDomainPtr     pCDom;
   CString        msg;
   HRESULT        hr;

   hr = pCDom.CreateInstance(CLSID_ChangeDomain);
   if ( FAILED(hr) )
   {
      msg.Format(L"Failed to create ChangeDomain COM object, CoCreateInstance returned %lx",hr);
   }
   else
   {
      pCDom->NoChange = m_NoChange;
      BSTR                 status = NULL;
      hr = pCDom->raw_ChangeToWorkgroup(m_Computer.AllocSysString(),SysAllocString(L"WORKGROUP"),&status);
      if ( SUCCEEDED(hr) )
      {
         hr = pCDom->raw_ChangeToDomain(m_Computer.AllocSysString(),m_Domain.AllocSysString(),m_Computer.AllocSysString(),&status);
      }
      if ( SUCCEEDED(hr) )
      {
         msg = L"ChangeDomain succeeded!";
      }
      else
      {
         msg.Format(L"ChangeDomain failed, %ls, hr=%lx",(WCHAR*)status,hr);
      }
      
   }	
   MessageBox(msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\driver.cpp ===
// COMTestDriver.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "\bin\McsDispatcher.tlb" named_guids
#import "\bin\MigDrvr.tlb" no_namespace, named_guids
#include "Driver.h"
#include "Dispatch.h"
#include "PwdAge.h"
#include "Reboot.h"
#include "ChgDom.h"
#include "Rename.h"
#include "AcctRepl.h"
#include "SecTrans.h"
#include "Rights.h"
#include "Status.h"
#include "AccChk.h"
#include "PlugIn.h"
#include "MigDrvr.h"
#include "TrustTst.h"
#include "MoveTest.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCOMTestDriverApp

BEGIN_MESSAGE_MAP(CCOMTestDriverApp, CWinApp)
	//{{AFX_MSG_MAP(CCOMTestDriverApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCOMTestDriverApp construction

CCOMTestDriverApp::CCOMTestDriverApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CCOMTestDriverApp object

CCOMTestDriverApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CCOMTestDriverApp initialization

BOOL CCOMTestDriverApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif
   HRESULT hr = CoInitialize(NULL);

   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"CoInitialize Failed, hr=%lx",hr);
      MessageBox(NULL,msg,NULL,MB_OK);
   }
   else
   {
      {
       
         CPropertySheet       ps(L"Domain Migration Component Test Driver");
         CChangeDomTestDlg    d1;
         //CRenameTestDlg       d2;
         CRebootTestDlg       d3;
         CAccessCheckTestDlg  d4;
         CCompPwdAgeTestDlg   d5;
         CMigrationDriverTestDlg    d6;
         CPlugIn              d7;
         CMoveTest            d8;
         CTrustTst              d9;

         ps.AddPage(&d1);
         //ps.AddPage(&d2);
         ps.AddPage(&d3);
         ps.AddPage(&d4);
         ps.AddPage(&d5);
         ps.AddPage(&d6);
         ps.AddPage(&d7);
         ps.AddPage(&d8);
         ps.AddPage(&d9);
         m_pMainWnd = &d3;
	      
      
         int nResponse = ps.DoModal();
	      if (nResponse == IDOK)
	      {
		      // TODO: Place code here to handle when the dialog is
		      //  dismissed with OK
	      }
	      else if (nResponse == IDCANCEL)
	      {
		      // TODO: Place code here to handle when the dialog is
		      //  dismissed with Cancel
	      }
      }
      CoUninitialize();
   }
	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\chgdom.h ===
#if !defined(AFX_CHANGEDOMTESTDLG_H__11298480_3244_11D3_99E9_0010A4F77383__INCLUDED_)
#define AFX_CHANGEDOMTESTDLG_H__11298480_3244_11D3_99E9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ChangeDomTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChangeDomTestDlg dialog

class CChangeDomTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CChangeDomTestDlg)

// Construction
public:
	CChangeDomTestDlg();
	~CChangeDomTestDlg();

// Dialog Data
	//{{AFX_DATA(CChangeDomTestDlg)
	enum { IDD = IDD_CHANGE_DOM_TEST };
	CString	m_Computer;
	CString	m_Domain;
	BOOL	m_NoChange;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CChangeDomTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CChangeDomTestDlg)
	afx_msg void OnChangeDomain();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHANGEDOMTESTDLG_H__11298480_3244_11D3_99E9_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\dispatch.h ===
#if !defined(AFX_DISPATCHERTESTDLG_H__CCAD87B0_30C0_11D3_8AE6_00A0C9AFE114__INCLUDED_)
#define AFX_DISPATCHERTESTDLG_H__CCAD87B0_30C0_11D3_8AE6_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DispatcherTestDlg.h : header file
//


/////////////////////////////////////////////////////////////////////////////
// CDispatcherTestDlg dialog

class CDispatcherTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CDispatcherTestDlg)

// Construction
public:
	CDispatcherTestDlg();
	~CDispatcherTestDlg();

// Dialog Data
	//{{AFX_DATA(CDispatcherTestDlg)
	enum { IDD = IDD_DISPATCHER_TEST };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CDispatcherTestDlg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CDispatcherTestDlg)
	afx_msg void OnDispatch();
	afx_msg void OnEditVarset();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   IVarSetPtr           pVarSet;
   MCSDISPATCHERLib::IDCTDispatcherPtr    pDispatcher;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DISPATCHERTESTDLG_H__CCAD87B0_30C0_11D3_8AE6_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\migdrvr.cpp ===
// MigrationDriverTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Driver.h"
#import "\bin\MigDrvr.tlb" no_namespace, named_guids
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#include "MigDrvr.h"
#include "VSEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMigrationDriverTestDlg property page

IMPLEMENT_DYNCREATE(CMigrationDriverTestDlg, CPropertyPage)

CMigrationDriverTestDlg::CMigrationDriverTestDlg() : CPropertyPage(CMigrationDriverTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CMigrationDriverTestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CMigrationDriverTestDlg::~CMigrationDriverTestDlg()
{
}

void CMigrationDriverTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMigrationDriverTestDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMigrationDriverTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CMigrationDriverTestDlg)
	ON_BN_CLICKED(IDC_EDIT_VARSET, OnEditVarset)
	ON_BN_CLICKED(IDC_GET_DESC, OnGetDesc)
	ON_BN_CLICKED(IDC_GO, OnGo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMigrationDriverTestDlg message handlers

void CMigrationDriverTestDlg::OnEditVarset() 
{
	CVarSetEditDlg          vedit;

   vedit.SetVarSet(pVarSet);

   vedit.DoModal();

   pVarSet = vedit.GetVarSet();
}

void CMigrationDriverTestDlg::OnGetDesc() 
{
	BSTR           desc;
   HRESULT        hr;
   CString        txt;

   if ( pVarSet == NULL )
   {
      OnEditVarset();
   }
   hr = pDriver->raw_GetTaskDescription(pVarSet,&desc);
   if ( SUCCEEDED(hr) )
   {
      txt = desc;
   }
   else
   {
      txt.Format(L"GetTaskDescription failed, hr=%lx",hr);
   }
   MessageBox(txt);   
	
}

void CMigrationDriverTestDlg::OnGo() 
{
	HRESULT              hr;
   CString              txt;

   if ( pVarSet == NULL )
   {
      OnEditVarset();
   }
   hr = pDriver->raw_PerformMigrationTask(pVarSet,(LONG)m_hWnd);
   if ( SUCCEEDED(hr) )
   {
      txt = "Succeeded!";
   }
   else
   {
      txt.Format(L"PerformMigrationTask failed, hr=%lx",hr);
   }
	
   MessageBox(txt);
}

BOOL CMigrationDriverTestDlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
   HRESULT hr = pDriver.CreateInstance(CLSID_Migrator);	
   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"Failed to create Migration Driver, CoCreateInstance returned %lx",hr);
      MessageBox(msg);
   }	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\migdrvr.h ===
#if !defined(AFX_MIGRATIONDRIVERTESTDLG_H__2531C650_34EF_11D3_8AE8_00A0C9AFE114__INCLUDED_)
#define AFX_MIGRATIONDRIVERTESTDLG_H__2531C650_34EF_11D3_8AE8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MigrationDriverTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMigrationDriverTestDlg dialog

class CMigrationDriverTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CMigrationDriverTestDlg)

// Construction
public:
	CMigrationDriverTestDlg();
	~CMigrationDriverTestDlg();

// Dialog Data
	//{{AFX_DATA(CMigrationDriverTestDlg)
	enum { IDD = IDD_MIGRATION_DRIVER };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMigrationDriverTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   IPerformMigrationTaskPtr      pDriver;
   IVarSetPtr                    pVarSet;
	// Generated message map functions
	//{{AFX_MSG(CMigrationDriverTestDlg)
	afx_msg void OnEditVarset();
	afx_msg void OnGetDesc();
	afx_msg void OnGo();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MIGRATIONDRIVERTESTDLG_H__2531C650_34EF_11D3_8AE8_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\driver.h ===
// COMTestDriver.h : main header file for the COMTESTDRIVER application
//

#if !defined(AFX_COMTESTDRIVER_H__AE8DA5F2_2FE4_11D3_8AE6_00A0C9AFE114__INCLUDED_)
#define AFX_COMTESTDRIVER_H__AE8DA5F2_2FE4_11D3_8AE6_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CCOMTestDriverApp:
// See COMTestDriver.cpp for the implementation of this class
//

class CCOMTestDriverApp : public CWinApp
{
public:
	CCOMTestDriverApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCOMTestDriverApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CCOMTestDriverApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMTESTDRIVER_H__AE8DA5F2_2FE4_11D3_8AE6_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\movetest.cpp ===
// MoveTest.cpp : implementation file
//

#include "stdafx.h"
#include "driver.h"
#include "MoveTest.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoveTest property page

IMPLEMENT_DYNCREATE(CMoveTest, CPropertyPage)

CMoveTest::CMoveTest() : CPropertyPage(CMoveTest::IDD)
{
	//{{AFX_DATA_INIT(CMoveTest)
	m_SourceComputer = _T("whqrdt");
	m_SourceDN = _T("CN=CBTest2,CN=Users,DC=devrdt,DC=com");
	m_TargetComputer = _T("bolesw2ktest");
	m_TargetContainer = _T("OU=Christy,DC=devchild,DC=devrdt,DC=com");
	m_Account = _T("Administrator");
	m_Password = _T("control");
	m_TgtAccount = _T("");
	m_Domain = _T("");
	m_TgtDomain = _T("");
	m_TgtPassword = _T("");
	//}}AFX_DATA_INIT
}

CMoveTest::~CMoveTest()
{
}

void CMoveTest::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMoveTest)
	DDX_Text(pDX, IDC_Source, m_SourceComputer);
	DDX_Text(pDX, IDC_SOURCEDN, m_SourceDN);
	DDX_Text(pDX, IDC_Target, m_TargetComputer);
	DDX_Text(pDX, IDC_TARGET_CONTAINER, m_TargetContainer);
	DDX_Text(pDX, IDC_ACCOUNT, m_Account);
	DDX_Text(pDX, IDC_Password, m_Password);
	DDX_Text(pDX, IDC_ACCOUNT2, m_TgtAccount);
	DDX_Text(pDX, IDC_DOMAIN, m_Domain);
	DDX_Text(pDX, IDC_DOMAIN2, m_TgtDomain);
	DDX_Text(pDX, IDC_Password2, m_TgtPassword);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMoveTest, CPropertyPage)
	//{{AFX_MSG_MAP(CMoveTest)
	ON_BN_CLICKED(IDC_MOVE, OnMove)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_CLOSE, OnClose)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoveTest message handlers

void CMoveTest::OnMove() 
{
   UpdateData(TRUE);
   CWaitCursor               w;
   HRESULT                   hr;
   CString                   msg;

   hr = m_pMover->raw_MoveObject(m_SourceDN.AllocSysString(),m_TargetContainer.AllocSysString());
   if ( SUCCEEDED(hr))
   {
      msg = L"Moved successfully!";
   }
   else
   {
      msg.Format(L"MoveObject failed, hr=%lx",hr);
   }
   MessageBox(msg);
}

BOOL CMoveTest::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
   HRESULT        hr = m_pMover.CreateInstance(CLSID_Mover);
   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"CreateInstance(ObjectMover) failed, hr=%lx",hr);
      MessageBox(msg);
   }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMoveTest::OnConnect() 
{
   UpdateData(TRUE);
   CWaitCursor             w;
   HRESULT                 hr;
   CString                 msg;

   hr = m_pMover->raw_Connect(m_SourceComputer.AllocSysString(),m_TargetComputer.AllocSysString(),
                  m_Domain.AllocSysString(),m_Account.AllocSysString(),m_Password.AllocSysString(),
                  m_TgtDomain.AllocSysString(),m_TgtAccount.AllocSysString(),m_TgtPassword.AllocSysString());

   if ( SUCCEEDED(hr) )
   {
      msg = L"Connected successfully!";
   }
   else
   {
      msg.Format(L"Connect failed, hr=%lx",hr);
   }
   MessageBox(msg);
}

void CMoveTest::OnClose() 
{
   UpdateData(TRUE);
   CWaitCursor          w;
   HRESULT              hr;
   CString              msg;

   hr = m_pMover->raw_Close();
   if ( SUCCEEDED(hr) )
   {
      msg = L"Closed successfully!";
   }
   else
   {
      msg.Format(L"Close() failed, hr=%lx",hr);
   }
   MessageBox(msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\plugin.h ===
#if !defined(AFX_PLUGIN_H__766C2F40_46F0_11D3_99F3_0010A4F77383__INCLUDED_)
#define AFX_PLUGIN_H__766C2F40_46F0_11D3_99F3_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// PlugIn.h : header file
//
#include "McsPI.h"
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
/////////////////////////////////////////////////////////////////////////////
// CPlugIn dialog

class CPlugIn : public CPropertyPage
{
	DECLARE_DYNCREATE(CPlugIn)

// Construction
public:
	CPlugIn();
	~CPlugIn();

// Dialog Data
	//{{AFX_DATA(CPlugIn)
	enum { IDD = IDD_PLUGIN_TEST };
	CString	m_ProgID;
	//}}AFX_DATA

   IMcsDomPlugIn * m_pPlugIn;
   IVarSetPtr      m_pVarSet;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CPlugIn)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CPlugIn)
	afx_msg void OnConfigure();
	afx_msg void OnCreateInstance();
	afx_msg void OnEditVarset();
	afx_msg void OnGetDesc();
	afx_msg void OnGetName();
	afx_msg void OnPostTask();
	afx_msg void OnPreTask();
	afx_msg void OnRegisterableFiles();
	afx_msg void OnRequiredFiles();
	afx_msg void OnStoreResult();
	afx_msg void OnViewResult();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PLUGIN_H__766C2F40_46F0_11D3_99F3_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\plugin.cpp ===
// PlugIn.cpp : implementation file
//

#include "stdafx.h"
#include "driver.h"
#include "PlugIn.h"
#include "VSEdit.h"




#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPlugIn property page

IMPLEMENT_DYNCREATE(CPlugIn, CPropertyPage)

CPlugIn::CPlugIn() : CPropertyPage(CPlugIn::IDD)
{
	//{{AFX_DATA_INIT(CPlugIn)
	m_ProgID = _T("");
	//}}AFX_DATA_INIT
   m_pPlugIn = NULL;
}

CPlugIn::~CPlugIn()
{
   if ( m_pPlugIn )
      m_pPlugIn->Release();

}

void CPlugIn::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPlugIn)
	DDX_Text(pDX, IDC_PROG_ID, m_ProgID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPlugIn, CPropertyPage)
	//{{AFX_MSG_MAP(CPlugIn)
	ON_BN_CLICKED(IDC_CONFIGURE, OnConfigure)
	ON_BN_CLICKED(IDC_CREATE_INSTANCE, OnCreateInstance)
	ON_BN_CLICKED(IDC_EDIT_VARSET, OnEditVarset)
	ON_BN_CLICKED(IDC_GET_DESC, OnGetDesc)
	ON_BN_CLICKED(IDC_GET_NAME, OnGetName)
	ON_BN_CLICKED(IDC_POST_TASK, OnPostTask)
	ON_BN_CLICKED(IDC_PRE_TASK, OnPreTask)
	ON_BN_CLICKED(IDC_REGISTERABLE_FILES, OnRegisterableFiles)
	ON_BN_CLICKED(IDC_REQUIRED_FILES, OnRequiredFiles)
	ON_BN_CLICKED(IDC_STORE_RESULT, OnStoreResult)
	ON_BN_CLICKED(IDC_VIEW_RESULT, OnViewResult)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPlugIn message handlers

void CPlugIn::OnConfigure() 
{
   HRESULT                   hr;
   CString                   msg;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->ConfigureSettings(m_pVarSet);
      if ( SUCCEEDED(hr) )
      {
         msg = L"ConfigureSettings succeeded";
      }
      else
      {
         msg.Format(L"ConfigureSettings failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}

void CPlugIn::OnCreateInstance() 
{
	UpdateData(TRUE);
   HRESULT                   hr = S_OK;
   CLSID                     clsid;
   WCHAR                     progid[200];
   CString                   msg;

   if ( m_pPlugIn )
   {
      m_pPlugIn->Release();
      m_pPlugIn = NULL;
   }

   wcscpy(progid,m_ProgID);
   hr = CLSIDFromProgID(progid,&clsid);
	if ( SUCCEEDED(hr) )
   {
      hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&m_pPlugIn);
      if ( SUCCEEDED(hr) )
      {
         msg = L"CreateInstance succeeded!";
      }
      else
      {
         msg.Format(L"CreateInstance failed, hr=%lx",hr);
      }
   }
   else
   {
      msg.Format(L"CLSIDFromProgID failed, hr=%lx",hr);
   }
   MessageBox(msg);
}

void CPlugIn::OnEditVarset() 
{
	CVarSetEditDlg          vedit;

   vedit.SetVarSet(m_pVarSet);

   vedit.DoModal();

   m_pVarSet = vedit.GetVarSet();
}

void CPlugIn::OnGetDesc() 
{
	HRESULT                   hr;
   CString                   msg;
   BSTR                      val = NULL;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->GetDescription(&val);
      if ( SUCCEEDED(hr) )
      {
         msg = val;
      }
      else
      {
         msg.Format(L"GetDescription failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}

void CPlugIn::OnGetName() 
{
	HRESULT                   hr;
   CString                   msg;
   BSTR                      val = NULL;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->GetName(&val);
      if ( SUCCEEDED(hr) )
      {
         msg = val;
      }
      else
      {
         msg.Format(L"GetDescription failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}

void CPlugIn::OnPostTask() 
{
   HRESULT                   hr;
   CString                   msg;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->PostMigrationTask(m_pVarSet);
      if ( SUCCEEDED(hr) )
      {
         msg = L"Postmigration task succeeded";
      }
      else
      {
         msg.Format(L"Postmigration task failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}

void CPlugIn::OnPreTask() 
{
   HRESULT                   hr;
   CString                   msg;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->PreMigrationTask(m_pVarSet);
      if ( SUCCEEDED(hr) )
      {
         msg = L"Premigration task succeeded";
      }
      else
      {
         msg.Format(L"Premigration task failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}

void CPlugIn::OnRegisterableFiles() 
{
	// TODO: Add your control notification handler code here
	
}

void CPlugIn::OnRequiredFiles() 
{
	// TODO: Add your control notification handler code here
	
}

void CPlugIn::OnStoreResult() 
{
   HRESULT                   hr;
   CString                   msg;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->StoreResults(m_pVarSet);
      if ( SUCCEEDED(hr) )
      {
         msg = L"StoreResult succeeded";
      }
      else
      {
         msg.Format(L"StoreResult failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}

void CPlugIn::OnViewResult() 
{
   HRESULT                   hr;
   CString                   msg;
   BSTR                      text = NULL;

   if ( m_pPlugIn )
   {
      hr = m_pPlugIn->GetResultString(m_pVarSet,&text);
      if ( SUCCEEDED(hr) )
      {
         msg = text;
      }
      else
      {
         msg.Format(L"GetResultString failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }	
}

BOOL CPlugIn::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
   HRESULT hr = m_pVarSet.CreateInstance(CLSID_VarSet);	
   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"Failed to create VarSet, CoCreateInstance returned %lx",hr);
      MessageBox(msg);
   }	
		
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\pwdage.cpp ===
// CompPwdAgeTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Driver.h"
#include "PwdAge.h"

#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCompPwdAgeTestDlg property page

IMPLEMENT_DYNCREATE(CCompPwdAgeTestDlg, CPropertyPage)

CCompPwdAgeTestDlg::CCompPwdAgeTestDlg() : CPropertyPage(CCompPwdAgeTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CCompPwdAgeTestDlg)
	m_Computer = _T("");
	m_Domain = _T("");
	m_Filename = _T("C:\\CompPwdAge.txt");
	//}}AFX_DATA_INIT
}

CCompPwdAgeTestDlg::~CCompPwdAgeTestDlg()
{
}

void CCompPwdAgeTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCompPwdAgeTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	DDX_Text(pDX, IDC_DOMAIN, m_Domain);
	DDX_Text(pDX, IDC_FILENAME, m_Filename);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCompPwdAgeTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CCompPwdAgeTestDlg)
	ON_BN_CLICKED(IDC_EXPORT, OnExport)
	ON_BN_CLICKED(IDC_GET_PWD_AGE, OnGetPwdAge)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCompPwdAgeTestDlg message handlers

void CCompPwdAgeTestDlg::OnExport() 
{
   UpdateData(TRUE);
   CWaitCursor                w;
   IComputerPwdAgePtr         pPwdAge;
   HRESULT                    hr = pPwdAge.CreateInstance(CLSID_ComputerPwdAge);

   if ( FAILED(hr) )
   {
      CString     msg;
      msg.Format(L"Failed to create ComputerPwdAge COM object, CoCreateInstance returned %lx",hr);

      MessageBox(msg);
   }
   else
   {
      hr = pPwdAge->raw_ExportPasswordAge(m_Domain.AllocSysString(),m_Filename.AllocSysString());
      if ( SUCCEEDED(hr) )
      {
         MessageBox(L"Succeeded!");
      }
      else
      {
         CString msg;
         msg.Format(L"Export failed, hr=%lx",hr);
         MessageBox(msg);
      }
   }
}

void CCompPwdAgeTestDlg::OnGetPwdAge() 
{
   UpdateData(TRUE);
   CWaitCursor                w;
   IComputerPwdAgePtr         pPwdAge;
   HRESULT                    hr = pPwdAge.CreateInstance(CLSID_ComputerPwdAge);

   if ( FAILED(hr) )
   {
      CString     msg;
      msg.Format(L"Failed to create ComputerPwdAge COM object, CoCreateInstance returned %lx",hr);

      MessageBox(msg);
   }
   else
   {
      DWORD                age;
      
      hr = pPwdAge->raw_GetPwdAge(m_Domain.AllocSysString(),m_Computer.AllocSysString(),&age);
      
      CString              msg;
      
      if ( SUCCEEDED(hr) )
      {
         msg.Format(L"The password age is %ld seconds (%ld days).",age,age / (60*60*24) );
      }
      else
      {
         msg.Format(L"GetPwdAge failed, hr=%lx",hr);
      }
      MessageBox(msg);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\pwdage.h ===
#if !defined(AFX_COMPPWDAGETESTDLG_H__00CBAFC0_30C5_11D3_8AE6_00A0C9AFE114__INCLUDED_)
#define AFX_COMPPWDAGETESTDLG_H__00CBAFC0_30C5_11D3_8AE6_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CompPwdAgeTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCompPwdAgeTestDlg dialog

class CCompPwdAgeTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CCompPwdAgeTestDlg)

// Construction
public:
	CCompPwdAgeTestDlg();
	~CCompPwdAgeTestDlg();

// Dialog Data
	//{{AFX_DATA(CCompPwdAgeTestDlg)
	enum { IDD = IDD_COMP_PWDAGE_TEST };
	CString	m_Computer;
	CString	m_Domain;
	CString	m_Filename;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCompPwdAgeTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCompPwdAgeTestDlg)
	afx_msg void OnExport();
	afx_msg void OnGetPwdAge();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_COMPPWDAGETESTDLG_H__00CBAFC0_30C5_11D3_8AE6_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\movetest.h ===
#if !defined(AFX_MOVETEST_H__9CF501D1_B178_466D_8637_C0C4D8C5C9F8__INCLUDED_)
#define AFX_MOVETEST_H__9CF501D1_B178_466D_8637_C0C4D8C5C9F8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MoveTest.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMoveTest dialog
//#import "\bin\MoveObj.tlb" no_namespace, named_guids
#import "MoveObj.tlb" no_namespace, named_guids

class CMoveTest : public CPropertyPage
{
	DECLARE_DYNCREATE(CMoveTest)

// Construction
public:
	CMoveTest();
	~CMoveTest();

// Dialog Data
	//{{AFX_DATA(CMoveTest)
	enum { IDD = IDD_MOVEOBJECT };
	CString	m_SourceComputer;
	CString	m_SourceDN;
	CString	m_TargetComputer;
	CString	m_TargetContainer;
	CString	m_Account;
	CString	m_Password;
	CString	m_TgtAccount;
	CString	m_Domain;
	CString	m_TgtDomain;
	CString	m_TgtPassword;
	//}}AFX_DATA
   IMoverPtr  m_pMover;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMoveTest)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMoveTest)
	afx_msg void OnMove();
	virtual BOOL OnInitDialog();
	afx_msg void OnConnect();
	afx_msg void OnClose();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MOVETEST_H__9CF501D1_B178_466D_8637_C0C4D8C5C9F8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\reboot.h ===
#if !defined(AFX_REBOOTTESTDLG_H__AA467BF0_30C6_11D3_8AE6_00A0C9AFE114__INCLUDED_)
#define AFX_REBOOTTESTDLG_H__AA467BF0_30C6_11D3_8AE6_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RebootTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRebootTestDlg dialog

class CRebootTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CRebootTestDlg)

// Construction
public:
	CRebootTestDlg();
	~CRebootTestDlg();

// Dialog Data
	//{{AFX_DATA(CRebootTestDlg)
	enum { IDD = IDD_REBOOT_TEST };
	CString	m_Computer;
	long	m_Delay;
	BOOL	m_NoChange;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRebootTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRebootTestDlg)
	afx_msg void OnReboot();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REBOOTTESTDLG_H__AA467BF0_30C6_11D3_8AE6_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\reboot.cpp ===
// RebootTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Driver.h"
#include "Reboot.h"

#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids

/////////////////////////////////////////////////////////////////////////////
// CRebootTestDlg property page

IMPLEMENT_DYNCREATE(CRebootTestDlg, CPropertyPage)

CRebootTestDlg::CRebootTestDlg() : CPropertyPage(CRebootTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CRebootTestDlg)
	m_Computer = _T("");
	m_Delay = 0;
	m_NoChange = FALSE;
	//}}AFX_DATA_INIT
}

CRebootTestDlg::~CRebootTestDlg()
{
}

void CRebootTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRebootTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	DDX_Text(pDX, IDC_Delay, m_Delay);
	DDX_Check(pDX, IDC_NOCHANGE, m_NoChange);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRebootTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CRebootTestDlg)
	ON_BN_CLICKED(IDC_REBOOT, OnReboot)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRebootTestDlg message handlers

void CRebootTestDlg::OnReboot() 
{
	UpdateData(TRUE);
   CWaitCursor    w;
   IRebootComputerPtr     pReboot;
   CString        msg;
   HRESULT        hr;

   if ( ! m_NoChange && m_Computer.IsEmpty() )
   {
      if ( IDNO == MessageBox(L"Are you sure you want to reboot the local machine now?",NULL,MB_YESNO) )
         return;
   }

   hr = pReboot.CreateInstance(CLSID_RebootComputer);
   if ( FAILED(hr) )
   {
      msg.Format(L"Failed to create Reboot COM object, CoCreateInstance returned %lx",hr);
   }
   else
   {
      pReboot->NoChange = m_NoChange;
      hr = pReboot->raw_Reboot(m_Computer.AllocSysString(),m_Delay);
      if ( SUCCEEDED(hr) )
      {
         msg = L"Reboot succeeded!";
      }
      else
      {
         msg.Format(L"Reboot failed, hr=%lx",hr);
      }
      
   }
   MessageBox(msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\rename.h ===
#if !defined(AFX_RENAMETESTDLG_H__8F253960_3245_11D3_99E9_0010A4F77383__INCLUDED_)
#define AFX_RENAMETESTDLG_H__8F253960_3245_11D3_99E9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RenameTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRenameTestDlg dialog

class CRenameTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CRenameTestDlg)

// Construction
public:
	CRenameTestDlg();
	~CRenameTestDlg();

// Dialog Data
	//{{AFX_DATA(CRenameTestDlg)
	enum { IDD = IDD_RENAME_TEST };
	CString	m_Computer;
	BOOL	m_NoChange;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRenameTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CRenameTestDlg)
	afx_msg void OnRename();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RENAMETESTDLG_H__8F253960_3245_11D3_99E9_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\rename.cpp ===
// RenameTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "driver.h"
#include "Rename.h"

#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRenameTestDlg property page

IMPLEMENT_DYNCREATE(CRenameTestDlg, CPropertyPage)

CRenameTestDlg::CRenameTestDlg() : CPropertyPage(CRenameTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CRenameTestDlg)
	m_Computer = _T("");
	m_NoChange = FALSE;
	//}}AFX_DATA_INIT
}

CRenameTestDlg::~CRenameTestDlg()
{
}

void CRenameTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRenameTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	DDX_Check(pDX, IDC_NOCHANGE, m_NoChange);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRenameTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CRenameTestDlg)
	ON_BN_CLICKED(IDC_RENAME, OnRename)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRenameTestDlg message handlers

void CRenameTestDlg::OnRename() 
{
	UpdateData(TRUE);
   CWaitCursor    w;
   IRenameComputerPtr     pPtr;
   CString        msg;
   HRESULT        hr;

   hr = pPtr.CreateInstance(CLSID_ChangeDomain);
   if ( FAILED(hr) )
   {
      msg.Format(L"Failed to create ChangeDomain COM object, CoCreateInstance returned %lx",hr);
   }
   else
   {
      pPtr->NoChange = m_NoChange;
      hr = pPtr->RenameLocalComputer(m_Computer.AllocSysString());
      if ( SUCCEEDED(hr) )
      {
         msg = L"Rename succeeded!";
      }
      else
      {
         msg.Format(L"Rename failed, hr=%lx",hr);
      }
      
   }	
   MessageBox(msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Driver.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_COMTESTDRIVER_DIALOG        102
#define IDR_MAINFRAME                   128
#define IDD_VARSET_EDITOR               129
#define IDD_AGENT_SERVICE_TEST          130
#define IDD_DISPATCHER_TEST             131
#define IDD_ENGINE_TEST                 132
#define IDD_ACCTREPL_TEST               133
#define IDD_COMP_PWDAGE_TEST            134
#define IDD_REBOOT_TEST                 135
#define IDD_CHANGE_DOM_TEST             136
#define IDD_RENAME_TEST                 137
#define IDD_USERRIGHTS                  138
#define IDD_SECTRANS_TEST               139
#define IDD_STATUS_TEST                 140
#define IDD_ACCESS_CHECKER              141
#define IDD_MIGRATION_DRIVER            142
#define IDD_SET_DETECT                  143
#define IDD_PLUGIN_TEST                 144
#define IDD_MOVEOBJECT                  145
#define IDD_TRUST                       146
#define IDC_KEY                         1000
#define IDC_VALUE                       1001
#define IDC_FILENAME                    1002
#define IDC_GETVALUE                    1003
#define IDC_EDIT_VARSET                 1003
#define IDC_SETVALUE                    1004
#define IDC_DISPATCH                    1004
#define IDC_LIST                        1005
#define IDC_ENUM                        1006
#define IDC_GET_COUNT                   1007
#define IDC_DOMAIN                      1007
#define IDC_CLEAR                       1008
#define IDC_COMPUTER                    1008
#define IDC_GET_PWD_AGE                 1009
#define IDC_COMPUTER2                   1009
#define IDC_CASE_SENSITIVE              1010
#define IDC_SAVE                        1011
#define IDC_EXPORT                      1011
#define IDC_NOCHANGE                    1011
#define IDC_LOAD                        1012
#define IDC_REBOOT                      1013
#define IDC_Delay                       1014
#define IDC_CHANGE_DOMAIN               1015
#define IDC_RENAME                      1017
#define IDC_INDEXED                     1018
#define IDC_PROCESS                     1019
#define IDC_Source                      1020
#define IDC_DUMP                        1021
#define IDC_Target                      1021
#define IDC_OPEN_SOURCE                 1022
#define IDC_ACCOUNT                     1022
#define IDC_OPEN_TARGET                 1023
#define IDC_Password                    1023
#define IDC_ACCOUNT2                    1024
#define IDC_REMOVE_EXISTING             1025
#define IDC_Password2                   1025
#define IDC_SOURCE_ACCT                 1026
#define IDC_TARGET_ACCT                 1027
#define IDC_COPY_RIGHTS                 1028
#define IDC_APPEND                      1031
#define IDC_EXPORTTOFILE                1032
#define IDC_STATUS                      1033
#define IDC_GET_STATUS                  1034
#define IDC_SET_STATUS                  1035
#define IDC_IS_ADMIN                    1037
#define IDC_GET_OS_VERSION              1038
#define IDC_IS_NATIVE_MODE              1039
#define IDC_IS_NATIVE_MODE2             1040
#define IDC_GET_DESC                    1041
#define IDC_GO                          1042
#define IDC_BUTTON1                     1043
#define IDC_PROG_ID                     1044
#define IDC_CREATE_INSTANCE             1045
#define IDC_GET_NAME                    1046
#define IDC_REQUIRED_FILES              1048
#define IDC_REGISTERABLE_FILES          1049
#define IDC_CONFIGURE                   1051
#define IDC_PRE_TASK                    1053
#define IDC_POST_TASK                   1054
#define IDC_VIEW_RESULT                 1055
#define IDC_STORE_RESULT                1056
#define IDC_CLOSE                       1059
#define IDC_CONNECT                     1060
#define IDC_SOURCEDN                    1061
#define IDC_TARGET_CONTAINER            1062
#define IDC_TARGET_DN                   1063
#define IDC_MOVE                        1064
#define IDC_TRUSTING                    1065
#define IDC_TRUSTED                     1066
#define IDC_CREATE_TRUST                1067
#define IDC_DOMAIN2                     1069
#define IDC_CRED_ING_DOMAIN             1069
#define IDC_CRED_ING_ACCOUNT            1070
#define IDC_CRED_ING_PASSWORD           1071
#define IDC_CRED_ED_DOMAIN              1072
#define IDC_CRED_ED_ACCOUNT             1073
#define IDC_CRED_ED_PASSWORD            1074
#define IDC_CREATE_WITH_CREDS           1075
#define IDC_BIDIR                       1076

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        147
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1077
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\rights.cpp ===
// RightsTestDlg.cpp : implementation file
//

#include "stdafx.h"
#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
#include "Driver.h"
#include "Rights.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRightsTestDlg property page

IMPLEMENT_DYNCREATE(CRightsTestDlg, CPropertyPage)

CRightsTestDlg::CRightsTestDlg() : CPropertyPage(CRightsTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CRightsTestDlg)
	m_Computer = _T("");
	m_AppendToFile = FALSE;
	m_Filename = _T("");
	m_NoChange = FALSE;
	m_RemoveExisting = FALSE;
	m_Source = _T("");
	m_Target = _T("");
	m_SourceAccount = _T("");
	m_TargetAccount = _T("");
	//}}AFX_DATA_INIT
}

CRightsTestDlg::~CRightsTestDlg()
{
}

void CRightsTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRightsTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	DDX_Check(pDX, IDC_APPEND, m_AppendToFile);
	DDX_Text(pDX, IDC_FILENAME, m_Filename);
	DDX_Check(pDX, IDC_NOCHANGE, m_NoChange);
	DDX_Check(pDX, IDC_REMOVE_EXISTING, m_RemoveExisting);
	DDX_Text(pDX, IDC_Source, m_Source);
	DDX_Text(pDX, IDC_Target, m_Target);
	DDX_Text(pDX, IDC_SOURCE_ACCT, m_SourceAccount);
	DDX_Text(pDX, IDC_TARGET_ACCT, m_TargetAccount);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRightsTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CRightsTestDlg)
	ON_BN_CLICKED(IDC_COPY_RIGHTS, OnCopyRights)
	ON_BN_CLICKED(IDC_EXPORTTOFILE, OnExporttofile)
	ON_BN_CLICKED(IDC_OPEN_SOURCE, OnOpenSource)
	ON_BN_CLICKED(IDC_OPEN_TARGET, OnOpenTarget)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRightsTestDlg message handlers

void CRightsTestDlg::OnCopyRights() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   CString           result;

   HRESULT           hr = pRights->raw_CopyUserRights(m_SourceAccount.AllocSysString(),m_TargetAccount.AllocSysString());
   if ( SUCCEEDED(hr) )
   {
      result = L"CopyRights succeeded!";
   }
   else
   {
      result.Format(L"CopyRights failed, hr=%lx",hr);
   }
   MessageBox(result);
}

void CRightsTestDlg::OnExporttofile() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   CString           result;
   HRESULT           hr = pRights->raw_ExportUserRights(m_Computer.AllocSysString(),m_Filename.AllocSysString(),m_AppendToFile);
   if ( SUCCEEDED(hr) )
   {
      result = L"ExportToFile succeeded!";
   }
   else
   {
      result.Format(L"Export failed, hr=%lx",hr);
   }
   MessageBox(result);
}

void CRightsTestDlg::OnOpenSource() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   HRESULT           hr = pRights->raw_OpenSourceServer(m_Source.AllocSysString());
   CString           result;

   if ( SUCCEEDED(hr) )
   {
      result = L"OpenSource succeeded!";
   }
   else
   {
      result.Format(L"OpenSource failed, hr=%lx",hr);
   }
   MessageBox(result);   
	
}

void CRightsTestDlg::OnOpenTarget() 
{
	UpdateData(TRUE);
   CWaitCursor       w;
   HRESULT           hr = pRights->raw_OpenTargetServer(m_Target.AllocSysString());
   CString           result;

   if ( SUCCEEDED(hr) )
   {
      result = L"OpenTarget succeeded!";
   }
   else
   {
      result.Format(L"OpenTarget failed, hr=%lx",hr);
   }
   MessageBox(result);   
}

BOOL CRightsTestDlg::OnSetActive() 
{
	HRESULT        hr = pRights.CreateInstance(CLSID_UserRights);
   if ( FAILED(hr) )
   {
      CString           str;
      str.Format(L"Failed to create UserRights COM object, hr=%lx",hr);
      MessageBox(str);
   }
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\rights.h ===
#if !defined(AFX_RIGHTSTESTDLG_H__20671580_34C3_11D3_8AE8_00A0C9AFE114__INCLUDED_)
#define AFX_RIGHTSTESTDLG_H__20671580_34C3_11D3_8AE8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RightsTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRightsTestDlg dialog

class CRightsTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CRightsTestDlg)

// Construction
public:
	CRightsTestDlg();
	~CRightsTestDlg();

// Dialog Data
	//{{AFX_DATA(CRightsTestDlg)
	enum { IDD = IDD_USERRIGHTS };
	CString	m_Computer;
	BOOL	m_AppendToFile;
	CString	m_Filename;
	BOOL	m_NoChange;
	BOOL	m_RemoveExisting;
	CString	m_Source;
	CString	m_Target;
	CString	m_SourceAccount;
	CString	m_TargetAccount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRightsTestDlg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   IUserRightsPtr          pRights;
	// Generated message map functions
	//{{AFX_MSG(CRightsTestDlg)
	afx_msg void OnCopyRights();
	afx_msg void OnExporttofile();
	afx_msg void OnOpenSource();
	afx_msg void OnOpenTarget();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_RIGHTSTESTDLG_H__20671580_34C3_11D3_8AE8_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\sectrans.h ===
#if !defined(AFX_SECTRANSTESTDLG_H__19656570_346A_11D3_8AE7_00A0C9AFE114__INCLUDED_)
#define AFX_SECTRANSTESTDLG_H__19656570_346A_11D3_8AE7_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SecTransTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSecTransTestDlg dialog

class CSecTransTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CSecTransTestDlg)

// Construction
public:
	CSecTransTestDlg();
	~CSecTransTestDlg();

// Dialog Data
	//{{AFX_DATA(CSecTransTestDlg)
	enum { IDD = IDD_SECTRANS_TEST };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSecTransTestDlg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   IVarSetPtr           pVarSet;
   ISecTranslatorPtr    pST;
	
	// Generated message map functions
	//{{AFX_MSG(CSecTransTestDlg)
	afx_msg void OnEditVarset();
	afx_msg void OnProcess();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SECTRANSTESTDLG_H__19656570_346A_11D3_8AE7_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\sectrans.cpp ===
// SecTransTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Driver.h"
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids

#include "SecTrans.h"
#include "VSEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSecTransTestDlg property page

IMPLEMENT_DYNCREATE(CSecTransTestDlg, CPropertyPage)

CSecTransTestDlg::CSecTransTestDlg() : CPropertyPage(CSecTransTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CSecTransTestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSecTransTestDlg::~CSecTransTestDlg()
{
}

void CSecTransTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSecTransTestDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSecTransTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CSecTransTestDlg)
	ON_BN_CLICKED(IDC_EDIT_VARSET, OnEditVarset)
	ON_BN_CLICKED(IDC_PROCESS, OnProcess)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSecTransTestDlg message handlers

void CSecTransTestDlg::OnEditVarset() 
{
	CVarSetEditDlg          vedit;

   vedit.SetVarSet(pVarSet);

   vedit.DoModal();

   pVarSet = vedit.GetVarSet();

}

void CSecTransTestDlg::OnProcess() 
{
	UpdateData(TRUE);
   CWaitCursor    w;
   if ( pVarSet == NULL )
   {
      OnEditVarset();
   }
   if ( pVarSet != NULL )
   {
      IUnknown       * pUnk = NULL;
      pVarSet.QueryInterface(IID_IUnknown,&pUnk);

      HRESULT hr = pST->raw_Process(pUnk);
      if (SUCCEEDED(hr) )
      {
         MessageBox(L"SecTrans::Process succeeded!");
      }
      else
      {
         CString        str;
         str.Format(L"SecTrans::Process failed, hr=%lx",hr);

         MessageBox(str);
      }
      pUnk->Release();
   }
   else
   {
      MessageBox(L"The varset pointer is NULL.");
   }	
	
}

BOOL CSecTransTestDlg::OnSetActive() 
{
   HRESULT hr = pST.CreateInstance(CLSID_SecTranslator);	
   if ( FAILED(hr) )
   {
      CString msg;
      msg.Format(L"Failed to create Security Translator, CoCreateInstance returned %lx",hr);
      MessageBox(msg);
   }	
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\sidflags.h ===
/*---------------------------------------------------------------------------
  File: SidFlags.h

  Comments: Flags that are used by access checker to return from the
            CanAddSidHistory function.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Created : 9/24/1999 Sham Chauthani
  ---------------------------------------------------------------------------
*/

#ifndef SIDFLAG_H
#define SIDFLAG_H

#define  F_WORKS                    0x00000000
#define  F_WRONGOS                  0x00000001
#define  F_NO_REG_KEY               0x00000002
#define  F_NO_AUDITING_SOURCE       0x00000004
#define  F_NO_AUDITING_TARGET       0x00000008
#define  F_NO_LOCAL_GROUP           0x00000010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	COMTestDriver.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\status.cpp ===
// StatusTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "Driver.h"
#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
#include "Status.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatusTestDlg property page

IMPLEMENT_DYNCREATE(CStatusTestDlg, CPropertyPage)

CStatusTestDlg::CStatusTestDlg() : CPropertyPage(CStatusTestDlg::IDD)
{
	//{{AFX_DATA_INIT(CStatusTestDlg)
	m_Status = 0;
	//}}AFX_DATA_INIT
}

CStatusTestDlg::~CStatusTestDlg()
{
}

void CStatusTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatusTestDlg)
	DDX_Text(pDX, IDC_STATUS, m_Status);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatusTestDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CStatusTestDlg)
	ON_BN_CLICKED(IDC_GET_STATUS, OnGetStatus)
	ON_BN_CLICKED(IDC_SET_STATUS, OnSetStatus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatusTestDlg message handlers

void CStatusTestDlg::OnGetStatus() 
{
	UpdateData(TRUE);
   CWaitCursor    w;
   HRESULT           hr = pStatus->get_Status(&m_Status);
	if ( FAILED(hr) )
   {
      CString r;
      r.Format(L"GetStatus failed, hr=%lx",hr);
      MessageBox(r);
   }
   UpdateData(FALSE);
}

void CStatusTestDlg::OnSetStatus() 
{
	UpdateData(TRUE);
   CWaitCursor          w;
   HRESULT              hr = pStatus->put_Status(m_Status);
   if ( FAILED(hr) )
   {
      CString r;
      r.Format(L"PutStatus failed, hr=%lx",hr);
      MessageBox(r);
   }

   UpdateData(FALSE);
}

BOOL CStatusTestDlg::OnSetActive() 
{
	HRESULT              hr = pStatus.CreateInstance(CLSID_StatusObj);
   if (FAILED(hr) )
   {
      CString r;
      r.Format(L"Failed to create StatusObj, CoCreateInstance returned %lx",hr);
      MessageBox(r);
   }
	return CPropertyPage::OnSetActive();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\trusttst.cpp ===
// TrustTst.cpp : implementation file
//

#include "stdafx.h"
#include "driver.h"
#include "TrustTst.h"

//#import "\bin\TrustMgr.tlb" no_namespace
#import "TrustMgr.tlb" no_namespace

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTrustTst property page

IMPLEMENT_DYNCREATE(CTrustTst, CPropertyPage)

CTrustTst::CTrustTst() : CPropertyPage(CTrustTst::IDD)
{
	//{{AFX_DATA_INIT(CTrustTst)
	m_Trusted = _T("DEVRAPTORW2K");
	m_Trusting = _T("MCSDEV");
	m_CredTrustedAccount = _T("Administrator");
	m_CredTrustedDomain = _T("DEVRAPTORW2K");
	m_CredTrustedPassword = _T("control");
	m_CredTrustingAccount = _T("");
	m_CredTrustingDomain = _T("");
	m_CredTrustingPassword = _T("");
	m_Bidirectional = FALSE;
	//}}AFX_DATA_INIT
}

CTrustTst::~CTrustTst()
{
}

void CTrustTst::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTrustTst)
	DDX_Text(pDX, IDC_TRUSTED, m_Trusted);
	DDX_Text(pDX, IDC_TRUSTING, m_Trusting);
	DDX_Text(pDX, IDC_CRED_ED_ACCOUNT, m_CredTrustedAccount);
	DDX_Text(pDX, IDC_CRED_ED_DOMAIN, m_CredTrustedDomain);
	DDX_Text(pDX, IDC_CRED_ED_PASSWORD, m_CredTrustedPassword);
	DDX_Text(pDX, IDC_CRED_ING_ACCOUNT, m_CredTrustingAccount);
	DDX_Text(pDX, IDC_CRED_ING_DOMAIN, m_CredTrustingDomain);
	DDX_Text(pDX, IDC_CRED_ING_PASSWORD, m_CredTrustingPassword);
	DDX_Check(pDX, IDC_BIDIR, m_Bidirectional);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTrustTst, CPropertyPage)
	//{{AFX_MSG_MAP(CTrustTst)
	ON_BN_CLICKED(IDC_CREATE_TRUST, OnCreateTrust)
	ON_BN_CLICKED(IDC_CREATE_WITH_CREDS, OnCreateWithCreds)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTrustTst message handlers

void CTrustTst::OnCreateTrust() 
{
   UpdateData(TRUE);
   
   CWaitCursor               w;
   HRESULT                   hr;
   CString                   msg;
   ITrustPtr                 pEnum;

   hr = pEnum.CreateInstance(__uuidof(Trust));
   if ( SUCCEEDED(hr) )
   {
      hr = pEnum->raw_CreateTrust(m_Trusting.AllocSysString(),m_Trusted.AllocSysString(),m_Bidirectional);
      if ( SUCCEEDED(hr) )
      {
         msg = L"Succeeded!";
      }
      else
      {
         msg.Format(L"CreateTrust failed, hr=%lx",hr);
      }
   }
   else
   {
      msg.Format(L"Failed to create Trust Enumerator COM object,hr=%lx",hr);
   }
   MessageBox(msg);
}

void CTrustTst::OnCreateWithCreds() 
{
	UpdateData(TRUE);

	CWaitCursor               w;
   HRESULT                   hr;
   CString                   msg;
   ITrustPtr                 pEnum;

   hr = pEnum.CreateInstance(__uuidof(Trust));
   if ( SUCCEEDED(hr) )
   {
      hr = pEnum->raw_CreateTrustWithCreds(m_Trusting.AllocSysString(),m_Trusted.AllocSysString(),
                     m_CredTrustingDomain.AllocSysString(),m_CredTrustingAccount.AllocSysString(),m_CredTrustingPassword.AllocSysString(),
                     m_CredTrustedDomain.AllocSysString(),m_CredTrustedAccount.AllocSysString(),m_CredTrustedPassword.AllocSysString(),
                     m_Bidirectional);
      if ( SUCCEEDED(hr) )
      {
         msg = L"Succeeded!";
      }
      else
      {
         msg.Format(L"CreateTrust failed, hr=%lx",hr);
      }
   }
   else
   {
      msg.Format(L"Failed to create Trust Enumerator COM object,hr=%lx",hr);
   }
   MessageBox(msg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\status.h ===
#if !defined(AFX_STATUSTESTDLG_H__38B8BA60_34C5_11D3_8AE8_00A0C9AFE114__INCLUDED_)
#define AFX_STATUSTESTDLG_H__38B8BA60_34C5_11D3_8AE8_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// StatusTestDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatusTestDlg dialog

class CStatusTestDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CStatusTestDlg)

// Construction
public:
	CStatusTestDlg();
	~CStatusTestDlg();

// Dialog Data
	//{{AFX_DATA(CStatusTestDlg)
	enum { IDD = IDD_STATUS_TEST };
	long	m_Status;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CStatusTestDlg)
	public:
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
   IStatusObjPtr        pStatus;
	// Generated message map functions
	//{{AFX_MSG(CStatusTestDlg)
	afx_msg void OnGetStatus();
	afx_msg void OnSetStatus();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATUSTESTDLG_H__38B8BA60_34C5_11D3_8AE8_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__AE8DA5F6_2FE4_11D3_8AE6_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__AE8DA5F6_2FE4_11D3_8AE6_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__AE8DA5F6_2FE4_11D3_8AE6_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\vsedit.cpp ===
// VarSetEditDlg.cpp : implementation file
//

#include "stdafx.h"
#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids

#include "Driver.h"
#include "VSEdit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CVarSetEditDlg dialog


CVarSetEditDlg::CVarSetEditDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CVarSetEditDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CVarSetEditDlg)
	m_bCaseSensitive = FALSE;
	m_Filename = _T("");
	m_Key = _T("");
	m_Value = _T("");
   m_varset = NULL;
	m_bIndexed = FALSE;
	//}}AFX_DATA_INIT
}


void CVarSetEditDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CVarSetEditDlg)
	DDX_Control(pDX, IDC_LIST, m_List);
	DDX_Check(pDX, IDC_CASE_SENSITIVE, m_bCaseSensitive);
	DDX_Text(pDX, IDC_FILENAME, m_Filename);
	DDX_Text(pDX, IDC_KEY, m_Key);
	DDX_Text(pDX, IDC_VALUE, m_Value);
	DDX_Check(pDX, IDC_INDEXED, m_bIndexed);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CVarSetEditDlg, CDialog)
	//{{AFX_MSG_MAP(CVarSetEditDlg)
	ON_BN_CLICKED(IDC_CASE_SENSITIVE, OnCaseSensitive)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_BN_CLICKED(IDC_DUMP, OnDump)
	ON_BN_CLICKED(IDC_ENUM, OnEnum)
	ON_BN_CLICKED(IDC_GET_COUNT, OnGetCount)
	ON_BN_CLICKED(IDC_GETVALUE, OnGetvalue)
	ON_BN_CLICKED(IDC_INDEXED, OnIndexed)
	ON_BN_CLICKED(IDC_LOAD, OnLoad)
	ON_BN_CLICKED(IDC_SAVE, OnSave)
	ON_BN_CLICKED(IDC_SETVALUE, OnSetvalue)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CVarSetEditDlg message handlers

void CVarSetEditDlg::OnCaseSensitive() 
{
   CWaitCursor             w;

   UpdateData(TRUE);
   if ( m_varset )
   {
      m_varset->CaseSensitive = m_bCaseSensitive;
   }
	
}

void CVarSetEditDlg::OnClear() 
{
   CWaitCursor               w;
   UpdateData(TRUE);
   HRESULT                   hr;
   IVarSet                 * pVS = NULL;
   if ( m_varset )
   {
      hr = m_varset->raw_getReference(m_Key.AllocSysString(),&pVS);
      if ( SUCCEEDED(hr) )
      {
         pVS->Clear();
         pVS->Release();
      }
      else
      {
         MessageBox(L"ERROR!");
      }

   }
   UpdateData(FALSE);
}

void CVarSetEditDlg::OnDump() 
{
   CWaitCursor               w;
 
   UpdateData(TRUE);

   if ( m_varset )
   {
      m_varset->DumpToFile(m_Filename.AllocSysString());
      MessageBox(L"Finished!");
   }
}

void CVarSetEditDlg::OnEnum()
{
   DoEnum(m_varset);
}
void CVarSetEditDlg::DoEnum(IVarSet * vs) 
{
   CWaitCursor               w;
   _variant_t                value;
   CString                   key;
   CString                   val;
   CString                   result;
   IEnumVARIANT            * henum = NULL;
   HRESULT                   hr = 0;
   ULONG                     nGot;
   _bstr_t                   keyB;
   
   if ( vs )
   {
      m_List.ResetContent();

      // This exercises the method used by VB's For Each.
      
      // Get an IEnumVARIANT interface
      hr = vs->get__NewEnum((LPUNKNOWN*)&henum);
      
      // use the IEnumVARIANT interface to get the values
      // for simplicity, retrieve them one at a time
      if ( SUCCEEDED(hr) )
      {
         while ( SUCCEEDED(hr = henum->Next(1,&value,&nGot)) )
         {
            if ( nGot==1 )
            {
               key = value.bstrVal;
               keyB = key;
               value = vs->get(keyB);
               if ( value.vt == VT_BSTR )
               {
                  val = value.bstrVal;
                  result.Format(L"%s  :  %s",key,val);
               }
               else if ( value.vt == VT_I4 )
               { 
                  result.Format(L"%s  :  %ld",key,value.lVal);
               }
               else if ( value.vt == VT_EMPTY )
               {
                  result.Format(L"%s  : <Empty>",key);
               }
               else
               {
                  result.Format(L"%s  : vt=0x%lx",key,value.vt);
               }
               m_List.AddString(result);
            }
            else
            {
               break;
            }
         }
         if ( henum )
            henum->Release();
      }
      henum = NULL;
   }
   if  (FAILED(hr) )
   {
      CString errMsg;
      errMsg.Format(L"Error:  hr=%lx",hr);
      MessageBox(errMsg);
   }
}

void CVarSetEditDlg::OnGetCount() 
{
   CWaitCursor               w;
   CString                   msg;

   // This is the total number of items in the VarSet.
   if ( m_varset )
   {
      msg.Format(L"%ld items.",m_varset->Count);
      MessageBox(msg);
   }
   }

void CVarSetEditDlg::OnGetvalue() 
{
	CWaitCursor               w;
   
   UpdateData(TRUE);
   _variant_t                value;
   _bstr_t                   key;

   // This retrieves a value from the VarSet
   // If the value does not exist, m_varset->get will return a variant of type VT_EMPTY.
   if ( m_varset )
   {
      key = m_Key;
      value = m_varset->get(key);
      if ( value.vt == VT_BSTR )
      {
         m_Value = (WCHAR *)(_bstr_t)value;
      }
      else if ( value.vt == VT_I4 )
      {
         m_Value.Format(L"%ld",value.lVal);
      }
      else
      {
         m_Value.Format(L"Variant: Type=%ld",value.vt);
      }

   }
   UpdateData(FALSE);
}

void CVarSetEditDlg::OnIndexed() 
{
   CWaitCursor               w;

   UpdateData(TRUE);
   // Turning indexing off is always fast, but turning indexing on
   // may be very slow if the VarSet is large.  
   // It takes O(n lg n) to build the index.
   if ( m_varset )
   {
      m_varset->Indexed = m_bIndexed;
   }
	
}

void CVarSetEditDlg::OnLoad() 
{
   CWaitCursor            w;
   IPersistStoragePtr     ps = NULL;
   HRESULT                hr = 0;
   IStoragePtr            store = NULL;
   IVarSetPtr             vs = NULL;
   IOleClientSite       * site = NULL;
   UpdateData(TRUE);

   if ( m_varset )
   {
      
      hr = m_varset->QueryInterface(IID_IPersistStorage,(void**)&ps);  
      if ( SUCCEEDED(hr) )
      {                    
         hr = StgOpenStorage(m_Filename.GetBuffer(0),NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&store);
         if ( SUCCEEDED(hr) )
         {                  
            // Load the data into a new varset
            hr = OleLoad(store,IID_IUnknown,site,(void **)&vs);
            if ( SUCCEEDED(hr) )
            {
               // release the old varset
               vs->AddRef();
               if ( m_varset ) m_varset->Release();
               m_varset = vs;
               // reload the property values
               m_bCaseSensitive = m_varset->CaseSensitive;
               m_bIndexed = m_varset->Indexed;
               UpdateData(FALSE);
            }
         }

      }
      if ( FAILED(hr) )
         MessageBox(L"Failed");
      else
         MessageBox(L"Finished!");
   }
}

void CVarSetEditDlg::OnSave() 
{
   CWaitCursor            w;
   IPersistStoragePtr     ps = NULL;
   HRESULT                hr = 0;
   IStoragePtr            store = NULL;
   
   UpdateData(TRUE);

   // Save the varset to a file
   
   if ( m_varset )
   {
      
      hr = m_varset->QueryInterface(IID_IPersistStorage,(void**)&ps);  
      if ( SUCCEEDED(hr) )
      {                    
         hr = StgCreateDocfile(m_Filename.GetBuffer(0),STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE |STGM_FAILIFTHERE,0,&store);
         if ( SUCCEEDED(hr) )
         {
            hr = OleSave(ps,store,FALSE);
         }

      }
      if ( FAILED(hr) )
         MessageBox(L"Failed");
      else
         MessageBox(L"Finished!");
   }
	
}

void CVarSetEditDlg::OnSetvalue() 
{
   CWaitCursor               w;
   UpdateData(TRUE);	
   
   _variant_t                value;
   _bstr_t                   key;
   HRESULT                   hr = 0;
   CString                   myKey;
   CString                   myValue;
   
   if ( m_varset )
   {
      // add a single item to the VarSet
      // Keys are represented as BSTRs, and values are represented as VARIANTs
      key = m_Key;
      value = m_Value;
      hr = m_varset->put(key,value);
      if ( FAILED(hr) )
      {
         MessageBox(L"Failed");
      }
      else
      {
         m_Value.Empty();
      }
   }
   GetDlgItem(IDC_KEY)->SetFocus();
   OnEnum();
   UpdateData(FALSE);   }

void CVarSetEditDlg::OnOK() 
{
	CDialog::OnOK();
}

BOOL CVarSetEditDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
   if ( ! m_varset )
   {
      HRESULT hr = CoCreateInstance(CLSID_VarSet,NULL,CLSCTX_ALL,IID_IVarSet,(void**)&m_varset);
      if ( FAILED(hr) )
      {
         CString msg;
         msg.Format(L"Failed to create varset.  CoCreateInstance returned %lx",hr);
         MessageBox(msg);
      }
   }
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\trusttst.h ===
#if !defined(AFX_TRUSTTST_H__C8366FEA_6C33_4C3D_9DC1_3DF296106948__INCLUDED_)
#define AFX_TRUSTTST_H__C8366FEA_6C33_4C3D_9DC1_3DF296106948__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// TrustTst.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTrustTst dialog

class CTrustTst : public CPropertyPage
{
	DECLARE_DYNCREATE(CTrustTst)

// Construction
public:
	CTrustTst();
	~CTrustTst();

// Dialog Data
	//{{AFX_DATA(CTrustTst)
	enum { IDD = IDD_TRUST };
	CString	m_Trusted;
	CString	m_Trusting;
	CString	m_CredTrustedAccount;
	CString	m_CredTrustedDomain;
	CString	m_CredTrustedPassword;
	CString	m_CredTrustingAccount;
	CString	m_CredTrustingDomain;
	CString	m_CredTrustingPassword;
	BOOL	m_Bidirectional;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CTrustTst)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CTrustTst)
	afx_msg void OnCreateTrust();
	afx_msg void OnCreateWithCreds();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_TRUSTTST_H__C8366FEA_6C33_4C3D_9DC1_3DF296106948__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\makefile2.inc ===
#
# This file is executed by Build when it sees the NTTARGETFILES variables
# in the SOURCES file.
#
# Build DBMgr.Obj and MgeDB.obj with VC6 compiler instead of VC5
#
#
#add the VC6 directory to the start of our path
path=.\VC6;$(PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbmgr.cpp ===
// DBManager.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DBManagerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "DBMgr.h"

#include "DBMgr_i.c"
#include "MgeDB.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_IManageDB, CIManageDB)
END_OBJECT_MAP()

class CDBManagerApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDBManagerApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CDBManagerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDBManagerApp, CWinApp)
	//{{AFX_MSG_MAP(CDBManagerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDBManagerApp theApp;

BOOL CDBManagerApp::InitInstance()
{
	ATLTRACE(_T("{DBManager.dll}CDBManagerApp::InitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
    _Module.Init(ObjectMap, m_hInstance, &LIBID_DBMANAGERLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CDBManagerApp::ExitInstance()
{
	ATLTRACE(_T("{DBManager.dll}CDBManagerApp::ExitInstance() : m_hInstance=0x%08X\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\comtstdr\vsedit.h ===
#if !defined(AFX_VARSETEDITDLG_H__19229D90_30B5_11D3_8AE6_00A0C9AFE114__INCLUDED_)
#define AFX_VARSETEDITDLG_H__19229D90_30B5_11D3_8AE6_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// VarSetEditDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CVarSetEditDlg dialog

class CVarSetEditDlg : public CDialog
{
// Construction
public:
	CVarSetEditDlg(CWnd* pParent = NULL);   // standard constructor
   ~CVarSetEditDlg() 
   {
      if ( m_varset )
      {
         m_varset->Release();
         m_varset = NULL;
      }
   }

// Dialog Data
	//{{AFX_DATA(CVarSetEditDlg)
	enum { IDD = IDD_VARSET_EDITOR };
	CListBox	m_List;
	BOOL	m_bCaseSensitive;
	CString	m_Filename;
	CString	m_Key;
	CString	m_Value;
	BOOL	m_bIndexed;
	//}}AFX_DATA
   IVarSet  * m_varset;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CVarSetEditDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL
   public:
      IVarSet * GetVarSet() { if ( m_varset ) m_varset->AddRef(); return m_varset; }
      void SetVarSet(IVarSet * pVS) { if ( pVS ) pVS->AddRef(); if ( m_varset) m_varset->Release(); m_varset = pVS; }
   
// Implementation
protected:
   void DoEnum(IVarSet * pVs);
	// Generated message map functions
	//{{AFX_MSG(CVarSetEditDlg)
	afx_msg void OnCaseSensitive();
	afx_msg void OnClear();
	afx_msg void OnDump();
	afx_msg void OnEnum();
	afx_msg void OnGetCount();
	afx_msg void OnGetvalue();
	afx_msg void OnIndexed();
	afx_msg void OnLoad();
	afx_msg void OnSave();
	afx_msg void OnSetvalue();
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_VARSETEDITDLG_H__19229D90_30B5_11D3_8AE6_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9A86D842_2A83_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__9A86D842_2A83_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#pragma warning( disable : 4146 )

#ifdef _DEBUG
//#define _ATL_DEBUG_INTERFACES
#endif

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9A86D842_2A83_11D3_8C8E_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DBMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_ReportingTitle              101
#define IDR_IMANAGEDB                   102
#define IDS_E_UPGRADE_TO_4X             102
#define IDS_E_UPGRADE_TO_TEMPORARY      103
#define IDS_E_UPGRADE_RENAME_ORIGINAL   104
#define IDS_E_UPGRADE_RENAME_UPGRADED   105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\stringconversion.h ===
#pragma once


//---------------------------------------------------------------------------
// CStringUTF8
//---------------------------------------------------------------------------

class CStringUTF8
{
public:

	CStringUTF8(LPCWSTR pszOld) :
		m_pchNew(NULL)
	{
		if (pszOld)
		{
			int cchNew = WideCharToMultiByte(CP_UTF8, 0, pszOld, -1, NULL, 0, NULL, NULL);

			m_pchNew = new CHAR[cchNew];

			if (m_pchNew)
			{
				WideCharToMultiByte(CP_UTF8, 0, pszOld, -1, m_pchNew, cchNew, NULL, NULL);
			}
		}
	}

	~CStringUTF8()
	{
		delete [] m_pchNew;
	}

	operator LPCSTR()
	{
		return m_pchNew;
	}

protected:

	LPSTR m_pchNew;
};


#define WTUTF8(s) static_cast<LPCSTR>(CStringUTF8(s))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\mgedb.h ===
// IManageDB.h : Declaration of the CIManageDB

#ifndef __IMANAGEDB_H_
#define __IMANAGEDB_H_

#include "resource.h"       // main symbols
#include "EaLen.hpp"
#include "TReg.hpp"
#include "Err.hpp"
#include "ResStr.h"
//#import "\bin\mcsvarsetmin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "msado21.tlb" no_namespace no_implementation rename("EOF", "EndOfFile")
#import "msadox.dll" no_implementation exclude("DataTypeEnum")
//#import <msjro.dll> no_namespace no_implementation

const _bstr_t                sKeyBase      = L"Software\\Mission Critical Software\\DomainAdmin";

/////////////////////////////////////////////////////////////////////////////
// CIManageDB

typedef struct x
{
   _bstr_t                   sReportName;
   _bstr_t                   arReportFields[10];
   int                       arReportSize[10];
   int                       colsFilled;
} reportStruct;


class ATL_NO_VTABLE CIManageDB : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CIManageDB, &CLSID_IManageDB>,
	public ISupportErrorInfoImpl<&IID_IIManageDB>,
	public IDispatchImpl<IIManageDB, &IID_IIManageDB, &LIBID_DBMANAGERLib>
{
public:
	CIManageDB();
	~CIManageDB();

	HRESULT FinalConstruct();
	void FinalRelease();

DECLARE_REGISTRY_RESOURCEID(IDR_IMANAGEDB)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CIManageDB)
	COM_INTERFACE_ENTRY(IIManageDB)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// IIManageDB
public:
	STDMETHOD(GetUserProps)(/*[in]*/ BSTR sDom, /*[in]*/ BSTR sSam, /*[in,out]*/ IUnknown ** ppVs);
	STDMETHOD(SaveUserProps)(IUnknown * pVs);
	STDMETHOD(GetMigratedObjectBySourceDN)(/*[in]*/ BSTR sSourceDN, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(GetActionHistoryKey)(/*[in]*/ long lActionID, /*[in]*/ BSTR sKeyName, /*[in,out]*/ VARIANT * pVar);
	STDMETHOD(AreThereAnyMigratedObjects)(/*[out]*/ long * count);
	STDMETHOD(CloseAccountsTable)();
	STDMETHOD(OpenAccountsTable)(/*[in]*/ LONG bSource);
	STDMETHOD(AddSourceObject)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sSAMName, /*[in]*/ BSTR sType, /*[in]*/ BSTR sRDN, /*[in]*/ BSTR sCanonicalName, /*[in]*/ LONG bSource);
	STDMETHOD(AddAcctRef)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sAcct, /*[in]*/ BSTR sAcctSid, /*[in]*/ BSTR sComp, /*[in]*/ long lCount, /*[in]*/ BSTR sType);
	STDMETHOD(CancelDistributedAction)(/*[in]*/ long lActionID, /*[in]*/ BSTR sComp);
	STDMETHOD(SetDistActionStatus)(/*[in]*/ long lActionID, /*[in]*/ BSTR sComp, /*[in]*/ long lStatus, BSTR sText);
	STDMETHOD(SetServiceAcctEntryStatus)(/*[in]*/ BSTR sComp, /*[in]*/ BSTR sSvc, /*[in]*/ BSTR sAcct, /*[in]*/ long Status);
	STDMETHOD(GetPasswordAge)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sComp, /*[out]*/ BSTR * sDesc, /*[out]*/ long * lAge, /*[out]*/ long *lTime);
	STDMETHOD(SavePasswordAge)(/*[in]*/ BSTR sDomain, /*[in]*/ BSTR sComp, /*[in]*/ BSTR sDesc, /*[in]*/ long lAge);
	STDMETHOD(GetServiceAccount)(/*[in]*/ BSTR Account, /*[in,out]*/ IUnknown ** pUnk);
	STDMETHOD(SetServiceAccount)(/*[in]*/ BSTR System, /*[in]*/ BSTR Service, /*[in]*/ BSTR ServiceDisplayName,/*[in]*/ BSTR Account);
	STDMETHOD(GetFailedDistributedActions)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** pUnk);
	STDMETHOD(AddDistributedAction)(/*[in]*/ BSTR sServerName, /*[in]*/ BSTR sResultFile, /*[in]*/ long lStatus, BSTR sText);
	STDMETHOD(GenerateReport)(/*[in]*/ BSTR sReportName, /*[in]*/ BSTR sFileName, /*[in]*/ BSTR sSrcDomain, /*[in]*/ BSTR sTgtDomain, /*[in]*/ LONG bSourceNT4);
	STDMETHOD(GetAMigratedObject)(/*[in]*/ BSTR sSrcSamName, /*[in]*/ BSTR sSrcDomain, /*[in]*/ BSTR sTgtDomain, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(GetCurrentActionID)(/*[out]*/ long * pActionID);
	STDMETHOD(ClearSCMPasswords)();
	STDMETHOD(GetSCMPasswords)(/*[out]*/ IUnknown ** ppUnk);
	STDMETHOD(SaveSCMPasswords)(/*[in]*/ IUnknown * pUnk);
	STDMETHOD(GetRSForReport)(/*[in]*/ BSTR sReport, /*[out,retval]*/ IUnknown ** pprsData);
	STDMETHOD(GetMigratedObjects)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(SaveMigratedObject)(/*[in]*/ long lActionID, /*[in]*/ IUnknown * pUnk);
	STDMETHOD(GetNextActionID)(/*[out]*/ long * pActionID);
	STDMETHOD(GetActionHistory)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(SetActionHistory)(/*[in]*/ long lActionID, /*[in]*/ IUnknown * pUnk);
	STDMETHOD(GetSettings)(/*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(GetVarsetFromDB)(/*[in]*/ BSTR sTable, /*[in,out]*/ IUnknown ** ppVarset, /*[in,optional]*/ VARIANT ActionID = _variant_t(-1L));
	STDMETHOD(SaveSettings)(/*[in]*/ IUnknown * pUnk );
	STDMETHOD(ClearTable)(/*[in]*/ BSTR sTableName, /*[in,optional]*/ VARIANT Filter = _variant_t(L""));
	STDMETHOD(SetVarsetToDB)(/*[in]*/ IUnknown * pUnk, /*[in]*/ BSTR sTableName, /*[in,optional]*/ VARIANT ActionID = _variant_t(-1L));
	STDMETHOD(GetAMigratedObjectToAnyDomain)(/*[in]*/ BSTR sSrcSamName, /*[in]*/ BSTR sSrcDomain, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(SrcSidColumnInMigratedObjectsTable)(/*[out, retval]*/ VARIANT_BOOL * pbFound);
	STDMETHOD(GetMigratedObjectsFromOldMOT)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(CreateSrcSidColumnInMOT)(/*[out, retval]*/ VARIANT_BOOL * pbCreated);
	STDMETHOD(PopulateSrcSidColumnByDomain)(/*[in]*/ BSTR sDomainName, /*[in]*/ BSTR sSid, /*[out, retval]*/ VARIANT_BOOL * pbPopulated);
	STDMETHOD(DeleteSrcSidColumnInMOT)(/*[out, retval]*/ VARIANT_BOOL * pbDeleted);
	STDMETHOD(GetMigratedObjectsWithSSid)(/*[in]*/ long lActionID, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(CreateSidColumnInAR)();
	STDMETHOD(SidColumnInARTable)(/*[out, retval]*/ VARIANT_BOOL * pbFound);
	STDMETHOD(GetMigratedObjectByType)(/*[in]*/ long lActionID, /*[in]*/ BSTR sSrcDomain, /*[in]*/ BSTR sType, /*[in,out]*/ IUnknown ** ppUnk);
	STDMETHOD(GetAMigratedObjectBySidAndRid)(/*[in]*/ BSTR sSrcDomainSid, /*[in]*/ BSTR sRid, /*[in,out]*/ IUnknown ** ppUnk);
protected:
	HRESULT PutVariantInDB( _RecordsetPtr pRs, _variant_t val );
	HRESULT GetVarFromDB(_RecordsetPtr pRec, _variant_t& val);
	void UpgradeDatabase(LPCTSTR pszFolder);
private:
	void RestoreVarset(IVarSetPtr pVS);
	void ClipVarset(IVarSetPtr pVS);
	HRESULT ChangeNCTableColumns(BOOL bSource);
	BOOL NCTablesColumnsChanged(BOOL bSource);
   _ConnectionPtr            m_cn;
   _variant_t                m_vtConn;
   void SetActionIDInMigratedObjects(_bstr_t sFilter);
   IVarSetPtr                m_pQueryMapping;
   _RecordsetPtr             m_rsAccounts;
};

#endif //__IMANAGEDB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\dbtest.cpp ===
// DBTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "DBTest.h"
#include "DBTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDBTestApp

BEGIN_MESSAGE_MAP(CDBTestApp, CWinApp)
	//{{AFX_MSG_MAP(CDBTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDBTestApp construction

CDBTestApp::CDBTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CDBTestApp object

CDBTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CDBTestApp initialization

BOOL CDBTestApp::InitInstance()
{
	AfxEnableControlContainer();
   HRESULT hr = CoInitialize(NULL);

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CDBTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\mgedb.cpp ===
/*---------------------------------------------------------------------------
  File: MgeDB.cpp

  Comments: Implementation of DBManager COM object.
  This is interface that the Domain Migrator uses to communicate to the 
  Database (PROTAR.MDB). This interface allows Domain Migrator to Save and
  later retrieve information/Setting to run the Migration process.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
  
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "mcs.h"
#include "ErrDct.hpp"
#include "DBMgr.h"
#include "MgeDB.h"
#include <share.h>
#include <comdef.h>
#include <lm.h>
#include "UString.hpp"
#include "TxtSid.h"
#include "LSAUtils.h"
#include "HrMsg.h"
#include "StringConversion.h"

#import "msado21.tlb" no_namespace implementation_only rename("EOF", "EndOfFile")
#import "msadox.dll" implementation_only exclude("DataTypeEnum")
//#import <msjro.dll> no_namespace implementation_only
#include <msjro.tlh>
#include <msjro.tli>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TErrorDct                    err;

using namespace _com_util;

#define MAX_BUF_LEN 255

#ifndef JETDBENGINETYPE_JET4X
#define JETDBENGINETYPE_JET4X 0x05	// from MSJetOleDb.h
#endif

StringLoader gString;
/////////////////////////////////////////////////////////////////////////////
// CIManageDB
TError   dct;
TError&  errCommon = dct;


//----------------------------------------------------------------------------
// Constructor / Destructor
//----------------------------------------------------------------------------


CIManageDB::CIManageDB()
{
}


CIManageDB::~CIManageDB()
{
}


//----------------------------------------------------------------------------
// FinalConstruct
//----------------------------------------------------------------------------

HRESULT CIManageDB::FinalConstruct()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		_bstr_t                   sMissing(L"");
		_bstr_t                   sUser(L"Admin");
		WCHAR                     sConnect[LEN_Path];
		WCHAR                     sDir[LEN_Path];

		// Get the path to the MDB file from the registry
		TRegKey        key;
		DWORD rc = key.Open(sKeyBase);
		if ( !rc ) 
		 rc = key.ValueGetStr(L"Directory", sDir, LEN_Path);
		if ( rc != 0 ) 
		 wcscpy(sDir, L"");

		// Now build the connect string.
		wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);

		CheckError(m_cn.CreateInstance(__uuidof(Connection)));
		 m_cn->Open(sConnect, sUser, sMissing, adConnectUnspecified);
		 m_vtConn = (IDispatch *) m_cn;

		// if necessary, upgrade database to 4.x

		long lEngineType = m_cn->Properties->Item[_T("Jet OLEDB:Engine Type")]->Value;

		if (lEngineType < JETDBENGINETYPE_JET4X)
		{
			m_cn->Close();

			UpgradeDatabase(sDir);

			m_cn->Open(sConnect, sUser, sMissing, adConnectUnspecified);
		}

		reportStruct * prs = NULL;
		_variant_t     var;
		// Migrated accounts report information
		CheckError(m_pQueryMapping.CreateInstance(__uuidof(VarSet)));
		m_pQueryMapping->put(L"MigratedAccounts", L"Select SourceDomain, TargetDomain, Type, SourceAdsPath, TargetAdsPath from MigratedObjects where Type <> 'computer' order by time");
		prs = new reportStruct();
		if (!prs)
		   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		prs->sReportName = GET_BSTR(IDS_REPORT_MigratedAccounts);
		prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_SourceDomain);
		prs->arReportSize[0] = 10;
		prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_TargetDomain);
		prs->arReportSize[1] = 10;
		prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_Type);
		prs->arReportSize[2] = 10;
		prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_SourceAdsPath);
		prs->arReportSize[3] = 35;
		prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_TargetAdsPath);
		prs->arReportSize[4] = 35;
		prs->colsFilled = 5;
		var.vt = VT_BYREF | VT_UI1;
		var.pbVal = (unsigned char *)prs;
		m_pQueryMapping->putObject(L"MigratedAccounts.DispInfo", var);

		// Migrated computers report information
		m_pQueryMapping->put(L"MigratedComputers", L"Select SourceDomain, TargetDomain, Type, SourceAdsPath, TargetAdsPath from MigratedObjects where Type = 'computer' order by time");
		prs = new reportStruct();
		if (!prs)
		   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		prs->sReportName = GET_BSTR(IDS_REPORT_MigratedComputers);
		prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_SourceDomain);
		prs->arReportSize[0] = 10;
		prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_TargetDomain);
		prs->arReportSize[1] = 10;
		prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_Type);
		prs->arReportSize[2] = 10;
		prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_SourceAdsPath);
		prs->arReportSize[3] = 35;
		prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_TargetAdsPath);
		prs->arReportSize[4] = 35;
		prs->colsFilled = 5;
		var.vt = VT_BYREF | VT_UI1;
		var.pbVal = (unsigned char *)prs;
		m_pQueryMapping->putObject(L"MigratedComputers.DispInfo", var);

		// Expired computers report information
		m_pQueryMapping->put(L"ExpiredComputers", L"Select Time, DomainName, CompName, Description, int(pwdage/86400) & ' days' as 'Password Age' from PasswordAge where pwdage > 2592000 order by DomainName, CompName");
		prs = new reportStruct();
		if (!prs)
		   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		prs->sReportName = GET_BSTR(IDS_REPORT_ExpiredComputers);
		prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_Time);
		prs->arReportSize[0] = 20;
		prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_DomainName);
		prs->arReportSize[1] = 15;
		prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_CompName);
		prs->arReportSize[2] = 15;
		prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_Description);
		prs->arReportSize[3] = 35;
		prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_PwdAge);
		prs->arReportSize[4] = 15;
		prs->colsFilled = 5;
		var.vt = VT_BYREF | VT_UI1;
		var.pbVal = (unsigned char *)prs;
		m_pQueryMapping->putObject(L"ExpiredComputers.DispInfo", var);

		// Account reference report informaiton.
		m_pQueryMapping->put(L"AccountReferences", L"Select DomainName, Account, AccountSid, Server, RefCount as '# of Ref', RefType As ReferenceType from AccountRefs where RefCount > 0 order by DomainName, Account, Server");
		prs = new reportStruct();
		if (!prs)
		   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		prs->sReportName = GET_BSTR(IDS_REPORT_AccountReferences);
		prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_DomainName);
		prs->arReportSize[0] = 15;
		prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_Account);
		prs->arReportSize[1] = 20;
		prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_AccountSid);
		prs->arReportSize[2] = 25;
		prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_Server);
		prs->arReportSize[3] = 15;
		prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_RefCount);
		prs->arReportSize[4] = 10;
		prs->arReportFields[5] = GET_BSTR(IDS_TABLE_FIELD_RefType);
		prs->arReportSize[5] = 15;
		prs->colsFilled = 6;
		var.vt = VT_BYREF | VT_UI1;
		var.pbVal = (unsigned char *)prs;
		m_pQueryMapping->putObject(L"AccountReferences.DispInfo", var);


		// Name conflict report information
		m_pQueryMapping->put(L"NameConflicts",
			L"SELECT"
			L" SourceAccounts.Name,"
			L" SourceAccounts.RDN,"
			L" SourceAccounts.Type,"
			L" TargetAccounts.Type,"
			L" IIf(SourceAccounts.Name=TargetAccounts.Name,'" +
			GET_BSTR(IDS_TABLE_SAM_CONFLICT_VALUE) +
			L"','') +"
			L" IIf(SourceAccounts.Name=TargetAccounts.Name And SourceAccounts.RDN=TargetAccounts.RDN,',','') +"
			L" IIf(SourceAccounts.RDN=TargetAccounts.RDN,'" +
			GET_BSTR(IDS_TABLE_RDN_CONFLICT_VALUE) +
			L"',''),"
		    L" TargetAccounts.[Canonical Name] "
			L"FROM SourceAccounts, TargetAccounts "
			L"WHERE"
			L" SourceAccounts.Name=TargetAccounts.Name OR SourceAccounts.RDN=TargetAccounts.RDN "
		    L"ORDER BY"
			L" SourceAccounts.Name, TargetAccounts.Name");
//		m_pQueryMapping->put(L"NameConflicts", L"SELECT SourceAccounts.Name as AccountName, SourceAccounts.Type as SourceType, TargetAccounts.Type as TargetType, SourceAccounts.Description as \
//							 SourceDescription, TargetAccounts.Description as TargetDescription, SourceAccounts.FullName as SourceFullName, TargetAccounts.FullName as TargetFullName \
//							 FROM SourceAccounts, TargetAccounts WHERE (((SourceAccounts.Name)=[TargetAccounts].[Name])) ORDER BY SourceAccounts.Name");
		prs = new reportStruct();						
		if (!prs)
		   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		prs->sReportName = GET_BSTR(IDS_REPORT_NameConflicts);
		prs->arReportFields[0] = GET_BSTR(IDS_TABLE_FIELD_Account);
		prs->arReportSize[0] = 20;
		prs->arReportFields[1] = GET_BSTR(IDS_TABLE_FIELD_SourceRDN);
		prs->arReportSize[1] = 20;
		prs->arReportFields[2] = GET_BSTR(IDS_TABLE_FIELD_SourceType);
		prs->arReportSize[2] = 10;
		prs->arReportFields[3] = GET_BSTR(IDS_TABLE_FIELD_TargetType);
		prs->arReportSize[3] = 10;
		prs->arReportFields[4] = GET_BSTR(IDS_TABLE_FIELD_ConflictAtt);
		prs->arReportSize[4] = 15;
		prs->arReportFields[5] = GET_BSTR(IDS_TABLE_FIELD_TargetCanonicalName);
		prs->arReportSize[5] = 25;
		prs->colsFilled = 6;
		var.vt = VT_BYREF | VT_UI1;
		var.pbVal = (unsigned char *)prs;
		m_pQueryMapping->putObject(L"NameConflicts.DispInfo", var);

		// we will handle the cleanup ourselves.
		VariantInit(&var);

		CheckError(m_rsAccounts.CreateInstance(__uuidof(Recordset)));
	}
	catch (_com_error& ce)
	{
		hr = Error((LPCOLESTR)ce.Description(), ce.GUID(), ce.Error());
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


//----------------------------------------------------------------------------
// FinalRelease
//----------------------------------------------------------------------------

void CIManageDB::FinalRelease()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	try
	{
		if (m_rsAccounts)
		{
			m_rsAccounts.Release();
		}

		if (m_pQueryMapping)
		{
			// we need to cleanup all the reportStruct objects.
			_variant_t                      var;
			reportStruct                  * pRs;
			// Cleanup the MigratedAccounts information
			var = m_pQueryMapping->get(L"MigratedAccounts.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*) var.pbVal;
			delete pRs;
			}
			// Cleanup the MigratedComputers information
			var = m_pQueryMapping->get(L"MigratedComputers.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}
			// Cleanup the ExpiredComputers information
			var = m_pQueryMapping->get(L"ExpiredComputers.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}
			// Cleanup the AccountReferences information
			var = m_pQueryMapping->get(L"AccountReferences.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}
			// Cleanup the NameConflicts information
			var = m_pQueryMapping->get(L"NameConflicts.DispInfo");
			if ( var.vt == (VT_BYREF | VT_UI1) )
			{
			pRs = (reportStruct*)var.pbVal;
			delete pRs;
			}

			m_pQueryMapping.Release();
		}

		if (m_cn)
		{
			m_cn.Release();
		}
	}
	catch (...)
	{
	 //eat it
	}
}

//---------------------------------------------------------------------------------------------
// SetVarsetToDB : Saves a varset into the table identified as sTableName. ActionID is also
//                 stored if one is provided.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetVarsetToDB(IUnknown *pUnk, BSTR sTableName, VARIANT ActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try 
	{
		IVarSetPtr                pVSIn = pUnk;
		IVarSetPtr                pVS(__uuidof(VarSet));
		IEnumVARIANTPtr           varEnum;
		_bstr_t                   keyName;
		_variant_t                value;
		_variant_t                varKey;
		_variant_t                vTable = sTableName;
		_variant_t                vtConn;
		_variant_t                varAction;
		DWORD                     nGot = 0;
		long						 lActionID;

		pVS->ImportSubTree(L"", pVSIn);
		ClipVarset(pVS);

      if (ActionID.vt == VT_I4)
		  lActionID = ActionID.lVal;
	  else
		  lActionID = -1;

	   // Open the recordset object.
      _RecordsetPtr             rs(__uuidof(Recordset));
      rs->Open(vTable, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);

      // we are now going to enumerate through the varset and put the values into the DB
      // Get the IEnumVARIANT pointer to enumerate
	  varEnum = pVS->_NewEnum;

      if (varEnum)
      {
         value.vt = VT_EMPTY;
         // For each value in the varset get the property name and put it into the
         // database with the string representation of its value with its type.
         while ( (hr = varEnum->Next(1,&varKey,&nGot)) == S_OK )
         {
            if ( nGot > 0 )
            {
               keyName = V_BSTR(&varKey);
               value = pVS->get(keyName);
               rs->AddNew();
               if ( lActionID > -1 )
               {
                  // This is going to be actionID information
                  // So lets put in the actionID in the database.
                  varAction.vt = VT_I4;
                  varAction.lVal = lActionID;
                  rs->Fields->GetItem(L"ActionID")->Value = varAction;
               }
               rs->Fields->GetItem(L"Property")->Value = keyName;
               hr = PutVariantInDB(rs, value);
               rs->Update();
               if (FAILED(hr))
                  _com_issue_errorex(hr, pVS, __uuidof(VarSet));
            }
         }
         varEnum.Release();
      }
      // Cleanup
      rs->Close();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// PutVariantInDB : Stores a variant into a DB table by decoding it.
//---------------------------------------------------------------------------------------------
HRESULT CIManageDB::PutVariantInDB(_RecordsetPtr pRs, _variant_t val)
{
   // This function puts the value passed as a variant into the current record of the recordset 
   // It updates the VarType and the Value fields of the given property
   _variant_t                varType;  // Numeric value for the type of value
   _variant_t                varVal;   // String representation of the value field
   WCHAR                     strTemp[255];

   varType.vt = VT_UI4;
   varType.lVal = val.vt;
   switch ( val.vt )
   {
      case VT_BSTR :          varVal = val;
                              break;

      case VT_UI4 :           wsprintf(strTemp, L"%d", val.lVal);
                              varVal = strTemp;
                              break;
      
      case VT_I4 :           wsprintf(strTemp, L"%d", val.lVal);
                              varVal = strTemp;
                              break;
	  
	  case VT_EMPTY :		  break;
     case VT_NULL:        break;

      default :               MCSASSERT(FALSE);    // What ever this type is we are not supporting it
                                                   // so put the support in for this.
                              return E_INVALIDARG;
   }
   pRs->Fields->GetItem(L"VarType")->Value = varType;
   pRs->Fields->GetItem(L"Value")->Value = varVal;
   return S_OK;
}

//---------------------------------------------------------------------------------------------
// ClearTable : Deletes a table indicated by sTableName and applies a filter if provided.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::ClearTable(BSTR sTableName, VARIANT Filter)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		// Build a SQL string to Clear the table.
		WCHAR                     sSQL[2000];
		WCHAR                     sFilter[2000];
		_variant_t                varSQL;

		if (Filter.vt == VT_BSTR)
		   wcscpy(sFilter, (WCHAR*)Filter.bstrVal);
		else
		   wcscpy(sFilter, L"");

		wsprintf(sSQL, L"Delete from %s", sTableName);
		if ( wcslen(sFilter) > 0 )
		{
		  wcscat(sSQL, L" where ");
		  wcscat(sSQL, sFilter);
		}

		varSQL = sSQL;

		_RecordsetPtr                pRs(__uuidof(Recordset));
		pRs->Open(varSQL, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SaveSettings : This method saves the GUI setting varset into the Settings table.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SaveSettings(IUnknown *pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   // This function uses the IUnknown pointer to the varset to save its
	   // settings in the database in Settings table.
	   // First clear the whole table
	   CheckError(ClearTable(L"Settings"));

	   // Update the values in the database.
	   CheckError(SetVarsetToDB(pUnk, L"Settings"));
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetVarFromDB : Retrieves a variant from the DB table by encoding it.
//---------------------------------------------------------------------------------------------
HRESULT CIManageDB::GetVarFromDB(_RecordsetPtr pRec, _variant_t& val)
{
	HRESULT hr = S_OK;

	try
	{
		// retrieve data type

		VARTYPE vt = VARTYPE(long(pRec->Fields->GetItem(L"VarType")->Value));

		// if data type is empty or null...

		if ((vt == VT_EMPTY) || (vt == VT_NULL))
		{
			// then clear value
			val.Clear();
		}
		else
		{
			// otherwise retrieve value and convert to given data type
			_variant_t vntValue = pRec->Fields->GetItem(L"Value")->Value;
			val.ChangeType(vt, &vntValue);
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetVarsetFromDB : Retrieves a varset from the specified table. and fills the argument
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetVarsetFromDB(BSTR sTable, IUnknown **ppVarset, VARIANT ActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   IVarSetPtr                pVS = *ppVarset;
	   _bstr_t                   sKeyName;
	   _variant_t                val;
	   _variant_t                varQuery;
	   WCHAR                     sQuery[1000];
	   long						 lActionID;

      if (ActionID.vt == VT_I4)
		  lActionID = ActionID.lVal;
	  else
		  lActionID = -1;

      if ( lActionID == -1 )
         wsprintf(sQuery, L"Select * from %s", sTable);
      else
         wsprintf(sQuery, L"Select * from %s where ActionID = %d", sTable, lActionID);

      varQuery = sQuery;
      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(varQuery, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
	  if (!pRs->EndOfFile)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 val = pRs->Fields->GetItem(L"Property")->Value;
			 sKeyName = val.bstrVal;
			 hr = GetVarFromDB(pRs, val);
			 if ( FAILED(hr) )
				_com_issue_errorex(hr, pRs, __uuidof(_Recordset));
			 pVS->put(sKeyName, val);
			 pRs->MoveNext();
		  }
		  RestoreVarset(pVS);
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetSettings : Retrieves the settings from the Settings table and fills up the varset
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetSettings(IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   // Get the varset from the Settings table and return it.
   return GetVarsetFromDB(L"Settings", ppUnk);
}

//---------------------------------------------------------------------------------------------
// SetActionHistory : Saves action history information into the Action history table.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetActionHistory(long lActionID, IUnknown *pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   // Call the set varset method to set the values into the database.
   _variant_t ActionID = lActionID;
   SetVarsetToDB(pUnk, L"ActionHistory", ActionID);
	return S_OK;
}

//---------------------------------------------------------------------------------------------
// GetActionHistory : Retrieves action history information into the varset
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetActionHistory(long lActionID, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   // Get the varset from the database
   _variant_t ActionID = lActionID;
//   GetVarsetFromDB(L"ActionHistory", ppUnk, ActionID);
//	return S_OK;
	return GetVarsetFromDB(L"ActionHistory", ppUnk, ActionID);
}

//---------------------------------------------------------------------------------------------
// GetNextActionID : Rotates the Action ID between 1 and MAXID as specified in the system table
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetNextActionID(long *pActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

   // We open the system table and look at the NextActionID field.
   // if the value of the NextActionID is greater than value in MaxID field
   // then we return the nextactionid = 1.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"System";
      _variant_t                   next, max, curr;
      WCHAR                        sActionID[LEN_Path];
      next.vt = VT_I4;
      max.vt = VT_I4;
      curr.vt = VT_I4;

      pRs->Filter = L"";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  next.lVal = pRs->Fields->GetItem(L"NextActionID")->Value;
		  max.lVal = pRs->Fields->GetItem(L"MaxID")->Value;
		  if ( next.lVal > max.lVal )
			 next.lVal = 1;
		  long currentID = next.lVal;
		  *pActionID = currentID;
		  curr.lVal = currentID;
		  next.lVal++;
		  pRs->Fields->GetItem(L"NextActionID")->Value = next;
		  pRs->Fields->GetItem(L"CurrentActionID")->Value = curr;
		  pRs->Update();
		  // Delete all entries for this pirticular action.
		  wsprintf(sActionID, L"ActionID=%d", currentID);
		  _variant_t ActionID = sActionID;
		  ClearTable(L"ActionHistory", ActionID);
		  //TODO:: Add code to delete entries from any other tables if needed
		  // Since we are deleting the actionID in the the ActionHistory table we can
		  // not undo this stuff. But we still need to keep it around so that the report
		  // and the GUI can work with it. I am going to set all actionIDs to -1 if actionID is
		  // cleared
		  SetActionIDInMigratedObjects(sActionID);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SaveMigratedObject : Saves information about a object that is migrated.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SaveMigratedObject(long lActionID, IUnknown *pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

   // This fucntion updates the migrated objects table in the DB with the
   // information in the varset. If the information is not found in the Varset
   // then an error may occur.

	try
	{
	   _variant_t                var;
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
	   //dt= COleDateTime::GetCurrentTime();

      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
      IVarSetPtr                   pVs = pUnk;
      WCHAR                        sQuery[LEN_Path];
      WCHAR                        sSource[LEN_Path], sTarget[LEN_Path], sDomain[LEN_Path];
      HRESULT                      hr = S_OK;
      bool                         bComp = false;
      WCHAR                        sTemp[LEN_Path];
      _bstr_t                      tempName;

      // Delete the record if one already exists in the table. In case it is remigrated/replaced.
      var = pVs->get(GET_BSTR(DB_SourceDomain));
      wcscpy(sSource, (WCHAR*)V_BSTR(&var));
      var = pVs->get(GET_BSTR(DB_TargetDomain));
      wcscpy(sTarget, (WCHAR*)V_BSTR(&var));
      var = pVs->get(GET_BSTR(DB_SourceSamName));
      wcscpy(sDomain, (WCHAR*)V_BSTR(&var));
      wsprintf(sQuery, L"delete from MigratedObjects where SourceDomain=\"%s\" and TargetDomain=\"%s\" and SourceSamName=\"%s\"", 
                        sSource, sTarget, sDomain);
      vtSource = _bstr_t(sQuery);
      hr = pRs->raw_Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      vtSource = L"MigratedObjects";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      var.vt = VT_UI4;
      var.lVal = lActionID;
      pRs->Fields->GetItem(L"ActionID")->Value = var;
      pRs->Fields->GetItem(L"Time")->Value = DATE(dt);
      var = pVs->get(GET_BSTR(DB_SourceDomain));
      // make the string into an uppercase string.
      if ( var.vt == VT_BSTR )
         var.bstrVal = UStrUpr((WCHAR*) var.bstrVal);
      pRs->Fields->GetItem(L"SourceDomain")->Value = var;
      var = pVs->get(GET_BSTR(DB_TargetDomain));
      // make the string into an uppercase string.
      if ( var.vt == VT_BSTR )
         var.bstrVal = UStrUpr((WCHAR*) var.bstrVal);
      pRs->Fields->GetItem(L"TargetDomain")->Value = var;
      var = pVs->get(GET_BSTR(DB_SourceAdsPath));
      pRs->Fields->GetItem(L"SourceAdsPath")->Value = var;
      var = pVs->get(GET_BSTR(DB_TargetAdsPath));
      pRs->Fields->GetItem(L"TargetAdsPath")->Value = var;
      var = pVs->get(GET_BSTR(DB_status));
      pRs->Fields->GetItem(L"status")->Value = var;
      var = pVs->get(GET_BSTR(DB_SourceDomainSid));
      pRs->Fields->GetItem(L"SourceDomainSid")->Value = var;

      var = pVs->get(GET_BSTR(DB_Type));
      // make the string into an uppercase string.
      if ( var.vt == VT_BSTR )
      {
         var.bstrVal = UStrLwr((WCHAR*) var.bstrVal);
         if ( !_wcsicmp(L"computer", (WCHAR*) var.bstrVal) )
            bComp = true;
         else
            bComp = false;
      }

      pRs->Fields->GetItem(L"Type")->Value = var;
      
      var = pVs->get(GET_BSTR(DB_SourceSamName));
      // for computer accounts make sure the good old $ sign is there.
      if (bComp)
      {
         wcscpy(sTemp, (WCHAR*) var.bstrVal);
         if ( sTemp[wcslen(sTemp) - 1] != L'$' )
         {
            tempName = sTemp;
            tempName += L"$";
            var = tempName;
         }
      }
      pRs->Fields->GetItem(L"SourceSamName")->Value = var;

      var = pVs->get(GET_BSTR(DB_TargetSamName));
      // for computer accounts make sure the good old $ sign is there.
      if (bComp)
      {
         wcscpy(sTemp, (WCHAR*) var.bstrVal);
         if ( sTemp[wcslen(sTemp) - 1] != L'$' )
         {
            tempName = sTemp;
            tempName += L"$";
            var = tempName;
         }
      }
      pRs->Fields->GetItem(L"TargetSamName")->Value = var;

      var = pVs->get(GET_BSTR(DB_GUID));
      pRs->Fields->GetItem(L"GUID")->Value = var;

      var = pVs->get(GET_BSTR(DB_SourceRid));
      if ( var.vt == VT_UI4 || var.vt == VT_I4 )
         pRs->Fields->GetItem("SourceRid")->Value = var;
      else
         pRs->Fields->GetItem("SourceRid")->Value = _variant_t((long)0);

      var = pVs->get(GET_BSTR(DB_TargetRid));
      if ( var.vt == VT_UI4 || var.vt == VT_I4 )
         pRs->Fields->GetItem("TargetRid")->Value = var;
      else
         pRs->Fields->GetItem("TargetRid")->Value = _variant_t((long)0);

      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetMigratedObjects : Retrieves information about previously migrated objects withis a given
//                      action or as a whole
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjects(long lActionID, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a pirticular Action ID. This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      if ( lActionID != -1 )
      {
         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects.
         wsprintf(sActionInfo, L"ActionID=%d", lActionID);
         pRs->Filter = sActionInfo;
      }
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetMigratedObjectsWithSSid : Retrieves information about previously migrated objects within
//                      a given action or as a whole with a valid Source Domain Sid
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjectsWithSSid(long lActionID, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a pirticular Action ID. This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      if ( lActionID != -1 )
      {
         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects.
         wsprintf(sActionInfo, L"ActionID=%d", lActionID);
         pRs->Filter = sActionInfo;
      }
      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomainSid IS NOT NULL"); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetActionIDInMigratedObjects : For a discarded actionID sets its ActionID to -1 in MO table.
//---------------------------------------------------------------------------------------------
void CIManageDB::SetActionIDInMigratedObjects(_bstr_t sFilter)
{
   _bstr_t sQuery = _bstr_t(L"Update MigratedObjects Set ActionID = -1 where ") + sFilter;
   _variant_t vt = sQuery;
   try
   {
      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vt, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
   }
   catch (...)
   {
      ;
   }
}

//---------------------------------------------------------------------------------------------
// GetRSForReport : Returns a recordset for a given report.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetRSForReport(BSTR sReport, IUnknown **pprsData)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		// For a given report we have a mapping in the varset. We can get the query
		// from that varset and execute it and return the varset.

		_variant_t var = m_pQueryMapping->get(sReport);

		if ( var.vt == VT_BSTR )
		{
		  _RecordsetPtr                pRs(__uuidof(Recordset));
		  pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

		  // Now that we have the recordset pointer we can get IUnknown pointer to it and return that
		  *pprsData = IUnknownPtr(pRs).Detach();
		}
		else
		{
		  hr = E_NOTIMPL;
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SaveSCMPasswords(IUnknown *pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   return SetVarsetToDB(pUnk, L"SCMPasswords");
}

//---------------------------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetSCMPasswords(IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   return GetVarsetFromDB(L"SCMPasswords", ppUnk);
}

//---------------------------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::ClearSCMPasswords()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   ClearTable(L"SCMPasswords");
	return S_OK;
}

//---------------------------------------------------------------------------------------------
// GetCurrentActionID : Retrieves the actionID currently in use.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetCurrentActionID(long *pActionID)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"System";
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);

      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  *pActionID = pRs->Fields->GetItem(L"CurrentActionID")->Value;
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetAMigratedObject : Given the source name, and the domain information retrieves info about
//                      a previous migration.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetAMigratedObject(BSTR sSrcSamName, BSTR sSrcDomain, BSTR sTgtDomain, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      if ( (wcslen(sSrcSamName) == 0) || (wcslen(sSrcDomain) == 0))
         _com_issue_error(E_INVALIDARG);

/*      wsprintf(sActionInfo, L"SourceDomain=\"%s\" AND SourceSamName=\"%s\" AND TargetDomain=\"%s\"", sSrcDomain, sSrcSamName, sTgtDomain);
      pRs->Filter = sActionInfo;
*/
      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\" AND SourceSamName=\"%s\" AND TargetDomain=\"%s\"", sSrcDomain, sSrcSamName, sTgtDomain); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetAMigratedObjectToAnyDomain : Given the source name, and the domain information retrieves info about
//                      a previous migration.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetAMigratedObjectToAnyDomain(BSTR sSrcSamName, BSTR sSrcDomain, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      if ( (wcslen(sSrcSamName) == 0) || (wcslen(sSrcDomain) == 0))
         _com_issue_error(E_INVALIDARG);

      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\" AND SourceSamName=\"%s\" Order by Time", sSrcDomain, sSrcSamName);
//      pRs->Filter = sActionInfo;
//      wcscpy(sActionInfo, L"Time");
//      pRs->Sort = sActionInfo;
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GenerateReport Generates an HTML report for the given Query and saves it in the File.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GenerateReport(BSTR sReportName, BSTR sFileName, BSTR sSrcDomain, BSTR sTgtDomain, LONG bSourceNT4)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	FILE* logFile = NULL;

	try
	{
	   _RecordsetPtr             pRs;
	   IUnknownPtr               pUnk;
	   _variant_t                var;
	   WCHAR                     sKey[LEN_Path];
	   CString                   reportingTitle;
	   CString                   srcDm = (WCHAR*) sSrcDomain;
	   CString                   tgtDm = (WCHAR*) sTgtDomain;

			//convert source and target domain names, only used in the name conflict report,
			//to uppercase
	   srcDm.MakeUpper();
	   tgtDm.MakeUpper();

	   CheckError(GetRSForReport(sReportName, &pUnk));
	   pRs = pUnk;
   
	   // Now that we have the recordset we need to get the number of columns
	   int numFields = pRs->Fields->Count;
	   int size = 100 / numFields;

	   reportingTitle.LoadString(IDS_ReportingTitle);

	   // Open the html file to write to
	   logFile = fopen(_bstr_t(sFileName), "wb");
	   if ( !logFile )
		  _com_issue_error(HRESULT_FROM_WIN32(GetLastError())); //TODO: stream i/o doesn't set last error

	   //Put the header information into the File.
	   fputs("<HTML>\r\n", logFile);
	   fputs("<HEAD>\r\n", logFile);
	   fputs("<META HTTP-EQUIV=\"Content-Type\" CONTENT=\"text/html; CHARSET=utf-8\">\r\n", logFile);
	   fprintf(logFile, "<TITLE>%s</TITLE>\r\n", WTUTF8(reportingTitle.GetBuffer(0)));
	   fputs("</HEAD>\r\n", logFile);
	   fputs("<BODY TEXT=\"#000000\" BGCOLOR=\"#ffffff\">\r\n", logFile);

	   fprintf(logFile, "<B><FONT SIZE=5><P ALIGN=\"CENTER\">%s</P>\r\n", WTUTF8(reportingTitle.GetBuffer(0)));

	   // Get the display information for the report 
	   // I know I did not need to do all this elaborate setup to get the fieldnames and the report names
	   // I could have gotten this information dynamically but had to change it because we need to get the 
	   // info from the Res dll for internationalization.
	   wsprintf(sKey, L"%s.DispInfo", (WCHAR*) sReportName);
	   _variant_t  v1;
	   reportStruct * prs;
	   v1 = m_pQueryMapping->get(sKey);
	   prs = (reportStruct *) v1.pbVal;
	   VariantInit(&v1);

	   fprintf(logFile, "</FONT><FONT SIZE=4><P ALIGN=\"CENTER\">%s</P>\r\n", WTUTF8(prs->sReportName));
	   fputs("<P ALIGN=\"CENTER\"><CENTER><TABLE WIDTH=90%%>\r\n", logFile);
	   fputs("<TR>\r\n", logFile);
	   for (int i = 0; i < numFields; i++)
	   {
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" BGCOLOR=\"#000080\">\r\n", prs->arReportSize[i]);
		     //if Canonical Name column, left align text since the name can be really long
		  if (i==5)
		     fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#00ff00\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(prs->arReportFields[i]));
		  else
		     fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#00ff00\"><P ALIGN=\"CENTER\">%s</B></FONT></TD>\r\n", WTUTF8(prs->arReportFields[i]));
	   }
	   fputs("</TR>\r\n", logFile);

		//if name conflict report, add domains to the top of the report
	   if (wcscmp((WCHAR*) sReportName, L"NameConflicts") == 0)
	   {
		  fputs("</TR>\r\n", logFile);
			 //add "Source Domain ="
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[0]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_NC_SDOMAIN)));
		   //add %SourceDomainName%
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[1]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\"> = %s</B></FONT></TD>\r\n", WTUTF8(LPCTSTR(srcDm)));
		  fputs("<TD>\r\n", logFile);
		  fputs("<TD>\r\n", logFile);
		   //add "Target Domain ="
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[4]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_NC_TDOMAIN)));
		   //add %TargetDomainName%
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[5]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\"> = %s</B></FONT></TD>\r\n", WTUTF8(LPCTSTR(tgtDm)));
		  fputs("</TR>\r\n", logFile);
	   }

	      //write Account Reference report here since we need to build lists and
	      //categorize
	   if (wcscmp((WCHAR*) sReportName, L"AccountReferences") == 0)
	   {
	      CStringList inMotList;
		  CString accountName;
		  CString domainName;
		  CString listName;
          POSITION currentPos; 

	         //add "Migrated by ADMT" as section header for Account Reference report
		  fputs("</TR>\r\n", logFile);
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[0]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_AR_MOT_HDR)));
		  fputs("</TR>\r\n", logFile);

		     //look at each entry in the recordset and add the the migrated list if it was
		     //migrated and in the MOT
	      while ( !pRs->EndOfFile )
		  {
			    //retrieve the domain and account name for this entry
			 var = pRs->Fields->Item[(long)0]->GetValue();
             domainName = (WCHAR*)V_BSTR(&var);
			 var = pRs->Fields->Item[(long)1]->GetValue();
             accountName = (WCHAR*)V_BSTR(&var);

			    //see if this account is in the Migrated Objects table
             IVarSetPtr pVsMot(__uuidof(VarSet));
             IUnknown  * pMotUnk;
             pVsMot->QueryInterface(IID_IUnknown, (void**) &pMotUnk);
             HRESULT hrFind = GetAMigratedObjectToAnyDomain(accountName.AllocSysString(), 
				                                            domainName.AllocSysString(), &pMotUnk);
             pMotUnk->Release();
			    //if this entry was in the MOT, save in the list
             if ( hrFind == S_OK )
			 {
				   //list stores the account in the form domain\account
				listName = domainName;
				listName += L"\\";
				listName += accountName;
			       //add the name to the list, if not already in it
		        currentPos = inMotList.Find(listName);
		        if (currentPos == NULL)
			       inMotList.AddTail(listName);
			 }
  		     pRs->MoveNext();
		  }//end while build MOT list

		     //go back to the top of the recordset and print each entry that is in the
		     //list created above
  		  pRs->MoveFirst();
	      while ( !pRs->EndOfFile )
		  {
			 BOOL bInList = FALSE;
			    //retrieve the domain and account name for this entry
			 var = pRs->Fields->Item[(long)0]->GetValue();
             domainName = (WCHAR*)V_BSTR(&var);
			 var = pRs->Fields->Item[(long)1]->GetValue();
             accountName = (WCHAR*)V_BSTR(&var);

				//list stored the accounts in the form domain\account
		     listName = domainName;
			 listName += L"\\";
			 listName += accountName;
			    //see if this entry name is in the list, if so, print it
		     if (inMotList.Find(listName) != NULL)
			 {
		        fputs("<TR>\r\n", logFile);
		        for (int i = 0; i < numFields; i++)
				{
			       fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[i]);
			       var = pRs->Fields->Item[(long) i]->GetValue();
			       if ( var.vt == VT_BSTR )
					  fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(V_BSTR(&var)));
				   else
				      fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%d</FONT></TD>\r\n", var.lVal);
				}
		        fputs("</TR>\r\n", logFile);
			 }//end if in list and need to print
  		     pRs->MoveNext();
		  }//end while print those in MOT

	         //add "Not Migrated by ADMT" as section header for Account Reference report
		  fputs("</TR>\r\n", logFile);
		  fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[0]);
		  fprintf(logFile, "<B><FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</B></FONT></TD>\r\n", WTUTF8(GET_STRING(IDS_TABLE_AR_NOTMOT_HDR)));
		  fputs("</TR>\r\n", logFile);

		     //go back to the top of the recordset and print each entry that is NOT
		     //in the list created above
  		  pRs->MoveFirst();
	      while ( !pRs->EndOfFile )
		  {
			 BOOL bInList = FALSE;
			    //retrieve the domain and account name for this entry
			 var = pRs->Fields->Item[(long)0]->GetValue();
             domainName = (WCHAR*)V_BSTR(&var);
			 var = pRs->Fields->Item[(long)1]->GetValue();
             accountName = (WCHAR*)V_BSTR(&var);

				//list stored the accounts in the form domain\account
		     listName = domainName;
			 listName += L"\\";
			 listName += accountName;
			    //see if this entry name is in the list, if not, print it
		     if (inMotList.Find(listName) == NULL)
			 {
		        fputs("<TR>\r\n", logFile);
		        for (int i = 0; i < numFields; i++)
				{
			       fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[i]);
			       var = pRs->Fields->Item[(long) i]->GetValue();
			       if ( var.vt == VT_BSTR )
					  fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(V_BSTR(&var)));
				   else
				      fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%d</FONT></TD>\r\n", var.lVal);
				}
		        fputs("</TR>\r\n", logFile);
			 }//end if NOT in list and need to print
  		     pRs->MoveNext();
		  }//end while print those NOT in Mot
		  inMotList.RemoveAll(); //free the list
	   }//end if Account Ref report


	   while ((!pRs->EndOfFile) && (wcscmp((WCHAR*) sReportName, L"AccountReferences")))
	   {
		  fputs("<TR>\r\n", logFile);
		  for (int i = 0; i < numFields; i++)
		  {
			 bool bTranslateType = false;
			 bool bHideRDN = false;
			 fprintf(logFile, "<TD WIDTH=\"%d%%\" VALIGN=\"TOP\" >\r\n", prs->arReportSize[i]);
			 var = pRs->Fields->Item[(long) i]->GetValue();
			 if ( var.vt == VT_BSTR )
			 {
					//set flag for translating type fields to localizable strings
				if ((!wcscmp((WCHAR*) sReportName, L"NameConflicts")) && ((i==2) || (i==3)))
						bTranslateType = true;
				if ((!wcscmp((WCHAR*) sReportName, L"MigratedComputers")) && (i==2))
						bTranslateType = true;
				if ((!wcscmp((WCHAR*) sReportName, L"MigratedAccounts")) && (i==2))
						bTranslateType = true;
					//clear flag for not displaying RDN for NT 4.0 Source domains
				if ((!wcscmp((WCHAR*) sReportName, L"NameConflicts")) && (i==1) && bSourceNT4)
						bHideRDN = true;

				if (bTranslateType)
				{
					 //convert type from English only to a localizable string
					CString          atype;
					if (!_wcsicmp((WCHAR*)V_BSTR(&var), L"user"))
						atype = GET_STRING(IDS_TypeUser);
					else if (!_wcsicmp((WCHAR*)V_BSTR(&var), L"group"))
						atype = GET_STRING(IDS_TypeGroup);
					else if (!_wcsicmp((WCHAR*)V_BSTR(&var), L"computer"))
						atype = GET_STRING(IDS_TypeComputer);
					else 
						atype = GET_STRING(IDS_TypeUnknown);
					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(LPCTSTR(atype)));
				}
					//replace hard-coded "days" with a localizable string
				else if((!wcscmp((WCHAR*) sReportName, L"ExpiredComputers")) && (i==4))
				{
					CString          apwdage;
					WCHAR *			 ndx;
					if ((ndx = wcsstr((WCHAR*)V_BSTR(&var), L"days")) != NULL)
					{
						*ndx = L'\0';
						apwdage = (WCHAR*)V_BSTR(&var);
						apwdage += GET_STRING(IDS_PwdAgeDays);
					}
					else
						apwdage = (WCHAR*)V_BSTR(&var);

					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(LPCTSTR(apwdage)));
				}
				   //else if NT 4.0 Source do not show our fabricated RDN
				else if (bHideRDN)
					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(L""));
				else
					fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"LEFT\">%s</FONT></TD>\r\n", WTUTF8(V_BSTR(&var)));
			}	
			else
				if ( var.vt == VT_DATE )
				{
				   _variant_t v1;
				   VariantChangeType(&v1, &var, VARIANT_NOVALUEPROP, VT_BSTR);
				   WCHAR    sMsg[LEN_Path];
				   wcscpy(sMsg, (WCHAR*) V_BSTR(&v1));
				   fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%s</FONT></TD>\r\n", WTUTF8(LPCTSTR(sMsg)));
				}
				else
				{
				   //TODO :: The types need more work
				   fprintf(logFile, "<FONT SIZE=3 COLOR=\"#000000\"><P ALIGN=\"CENTER\">%d</FONT></TD>\r\n", var.lVal);
				}
		  }
		  fputs("</TR>\r\n", logFile);
		  pRs->MoveNext();
	   }
	   fputs("</TABLE>\r\n", logFile);
	   fputs("</CENTER></P>\r\n", logFile);

	   fputs("<B><FONT SIZE=5><P ALIGN=\"CENTER\"></P></B></FONT></BODY>\r\n", logFile);
	   fputs("</HTML>\r\n", logFile);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	if (logFile)
	{
		fclose(logFile);
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// AddDistributedAction : Adds a distributed action record to the DistributedAction table.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::AddDistributedAction(BSTR sServerName, BSTR sResultFile, long lStatus, BSTR sText)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   // Get the current action ID.
	   long lActionID;
	   CheckError(GetCurrentActionID(&lActionID));
   
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"DistributedAction";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"ActionID")->Value = lActionID;
      pRs->Fields->GetItem(L"ServerName")->Value = sServerName;
      pRs->Fields->GetItem(L"ResultFile")->Value = sResultFile;
      pRs->Fields->GetItem(L"Status")->Value = lStatus;
      pRs->Fields->GetItem(L"StatusText")->Value = sText;
      pRs->Update();
      pRs->Close();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetFailedDistributedActions : Returns all the failed distributed action
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetFailedDistributedActions(long lActionID, IUnknown ** pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   IVarSetPtr             pVs = * pUnk;
	   WCHAR                  sQuery[LEN_Path];
	   int                    nCnt = 0, nCntActionID = 1;
	   WCHAR                  sKey[LEN_Path];
	   _variant_t             var;

	   // The failed action has the 0x80000000 bit set so we check for that (2147483648)
	   if ( lActionID == -1 )
		  wcscpy(sQuery, L"Select * from DistributedAction where status < 0");
	   else
		  wsprintf(sQuery, L"Select * from DistributedAction where ActionID=%d and status < 0", lActionID);
	   _variant_t             vtSource = _bstr_t(sQuery);

      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      while (!pRs->EndOfFile)
      {
         wsprintf(sKey, L"DA.%d.ActionID", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"ActionID")->Value);

         wsprintf(sKey, L"DA.%d.Server", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"ServerName")->Value);

         wsprintf(sKey, L"DA.%d.Status", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"Status")->Value);

         wsprintf(sKey, L"DA.%d.JobFile", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"ResultFile")->Value);
         
         wsprintf(sKey, L"DA.%d.StatusText", nCnt);
         pVs->put(sKey, pRs->Fields->GetItem(L"StatusText")->Value);

         nCnt++;
         pRs->MoveNext();
      }
      pVs->put(L"DA", (long) nCnt);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetServiceAccount : This method is saves the account info for the Service on a pirticular
//                     machine.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetServiceAccount(
                                             BSTR System,   //in- System name
                                             BSTR Service,  //in- Service name
                                             BSTR ServiceDisplayName, // in - Display name for service
                                             BSTR Account   //in- Account used by this service
                                          )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   // Create a new record and save the information
	   _variant_t                var;
	   WCHAR                     sFilter[LEN_Path];

	   wsprintf(sFilter, L"System = \"%s\" and Service = \"%s\"", System, Service);
	   var = sFilter;
	   ClearTable(L"ServiceAccounts", var);

      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"ServiceAccounts";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      var = _bstr_t(System);
      pRs->Fields->GetItem(L"System")->Value = var;
      var = _bstr_t(Service);
      pRs->Fields->GetItem(L"Service")->Value = var;
      
      var = _bstr_t(ServiceDisplayName);
      pRs->Fields->GetItem(L"ServiceDisplayName")->Value = var;
      
      var = _bstr_t(Account);
      pRs->Fields->GetItem(L"Account")->Value = var;
      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetServiceAccount : This method gets all the Services referencing the Account specified. The
//                     values are returned in System.Service format in the VarSet.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetServiceAccount(
                                             BSTR Account,     //in- The account to lookup
                                             IUnknown ** pUnk  //out-Varset containing Services 
                                          )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   IVarSetPtr                pVs = * pUnk;
	   _bstr_t                   sQuery;
	   _bstr_t                   sKey;
	   WCHAR                     key[500];
	   _variant_t                var;
	   long                      ndx = 0;

      _RecordsetPtr                pRs(__uuidof(Recordset));
      // Set up the query to lookup a pirticular account or all accounts
      if ( wcslen((WCHAR*)Account) == 0 )
         sQuery = _bstr_t(L"Select * from ServiceAccounts order by System, Service");
      else
         sQuery = _bstr_t(L"Select * from ServiceAccounts where Account = \"") + _bstr_t(Account) + _bstr_t(L"\" order by System, Service");
      var = sQuery;
      // Get the data, Setup the varset and then return the info
      pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      while (!pRs->EndOfFile)
      {
         // computer name
         swprintf(key,L"Computer.%ld",ndx);
         var = pRs->Fields->GetItem("System")->Value;
         pVs->put(key,var);
         // service name
         swprintf(key,L"Service.%ld",ndx);
         var = pRs->Fields->GetItem("Service")->Value;
         pVs->put(key,var);

         swprintf(key,L"ServiceDisplayName.%ld",ndx);
         var = pRs->Fields->GetItem("ServiceDisplayName")->Value;
         pVs->put(key,var);

         // account name
         swprintf(key,L"ServiceAccount.%ld",ndx);
         var = pRs->Fields->GetItem("Account")->Value;
         pVs->put(key, var);
   
         swprintf(key,L"ServiceAccountStatus.%ld",ndx);
         var = pRs->Fields->GetItem("Status")->Value;
         pVs->put(key,var);

         pRs->MoveNext();
         ndx++;
         pVs->put(L"ServiceAccountEntries",ndx);
      }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SavePasswordAge : Saves the password age of the computer account at a given time.
//                   It also stores the computer description.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SavePasswordAge(BSTR sDomain, BSTR sComp, BSTR sDesc, long lAge)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _bstr_t                   sQuery;
	   WCHAR                     sTemp[LEN_Path];
	   _variant_t                var;
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
   
	   // Delete the entry if one exists.
	   wsprintf(sTemp, L"DomainName=\"%s\" and compname=\"%s\"", (WCHAR*) sDomain, (WCHAR*) sComp);
	   var = sTemp;
	   ClearTable(L"PasswordAge", var);

	   var = L"PasswordAge";
      _RecordsetPtr                 pRs(__uuidof(Recordset));
      pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"Time")->Value = DATE(dt);
      wcscpy((WCHAR*) sDomain, UStrUpr((WCHAR*)sDomain));
      pRs->Fields->GetItem(L"DomainName")->Value = sDomain;
      pRs->Fields->GetItem(L"CompName")->Value = sComp;
      pRs->Fields->GetItem(L"Description")->Value = sDesc;
      pRs->Fields->GetItem(L"PwdAge")->Value = lAge;
      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


//---------------------------------------------------------------------------------------------
// GetPasswordAge : Gets the password age and description of a given computer
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetPasswordAge(BSTR sDomain, BSTR sComp, BSTR *sDesc, long *lAge, long *lTime)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _bstr_t                   sQuery;
	   WCHAR                     sTemp[LEN_Path];
	   _variant_t                var;
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
	   DATE                      val;

	   wsprintf(sTemp, L"DomainName =\"%s\" AND CompName = \"%s\"", (WCHAR*) sDomain, (WCHAR*) sComp);
	   sQuery = _bstr_t(L"Select * from PasswordAge where  ") + _bstr_t(sTemp);
	   var = sQuery;

      _RecordsetPtr                 pRs(__uuidof(Recordset));
      pRs->Open(var, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if ( ! pRs->EndOfFile )
      {
         val = pRs->Fields->GetItem(L"Time")->Value;  
         *sDesc = pRs->Fields->GetItem(L"Description")->Value.bstrVal;
         *lAge = pRs->Fields->GetItem(L"PwdAge")->Value;
      }
	  else
	  {
		hr = S_FALSE;
	  }
      pRs->Close();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetServiceAcctEntryStatus : Sets the Account and the status for a given service on a given
//                             computer.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetServiceAcctEntryStatus(BSTR sComp, BSTR sSvc, BSTR sAcct, long Status)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _variant_t                var;
	   _bstr_t                   sQuery;
	   WCHAR                     sTemp[LEN_Path];

	   wsprintf(sTemp, L"Select * from ServiceAccounts where System = \"%s\" and Service = \"%s\"", (WCHAR*) sComp, (WCHAR*) sSvc);
	   sQuery = sTemp;
	   _variant_t                vtSource = sQuery;

      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if ( !pRs->EndOfFile )
      {
         if (  sAcct )
         {
            var = _bstr_t(sAcct);
            pRs->Fields->GetItem(L"Account")->Value = var;
         }
         var = Status;
         pRs->Fields->GetItem(L"Status")->Value = var;
         pRs->Update();
      }
	  else
	  {
	     hr = E_INVALIDARG;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// SetDistActionStatus : Sets the Distributed action's status and its message.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::SetDistActionStatus(long lActionID, BSTR sComp, long lStatus, BSTR sText)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   _variant_t                var;
	   _bstr_t                   sQuery; 
	   WCHAR                     sTemp[LEN_Path];

	   if ( lActionID == -1 )
	   {
		  // lookup by the job filename
		  wsprintf(sTemp,L"Select * from  DistributedAction where ResultFile = \"%s\"",(WCHAR*) sComp);
	   }
	   else
	   {
		  // lookup by action ID and computer name
		  wsprintf(sTemp, L"Select * from  DistributedAction where ServerName = \"%s\" and ActionID = %d", (WCHAR*) sComp, lActionID);
	   }
	   sQuery = sTemp;
	   _variant_t                vtSource = sQuery;

      _RecordsetPtr                pRs(__uuidof(Recordset));
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if ( !pRs->EndOfFile )
      {
         var = _bstr_t(sText);
         pRs->Fields->GetItem(L"StatusText")->Value = var;
         var = lStatus;
         pRs->Fields->GetItem(L"Status")->Value = var;
         pRs->Update();
      }
	  else
	  {
	     hr = E_INVALIDARG;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// CancelDistributedAction : Deletes a pirticular distributed action
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::CancelDistributedAction(long lActionID, BSTR sComp)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
   WCHAR                     sFilter[LEN_Path];
   wsprintf(sFilter, L"ActionID = %d and ServerName = \"%s\"", lActionID, (WCHAR*) sComp);
   _variant_t Filter = sFilter;
   return ClearTable(L"DistributedAction", Filter);
}

//---------------------------------------------------------------------------------------------
// AddAcctRef : Adds an account reference record.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::AddAcctRef(BSTR sDomain, BSTR sAcct, BSTR sAcctSid, BSTR sComp, long lCount, BSTR sType)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
	   time_t                    tm;
	   COleDateTime              dt(time(&tm));
	   _variant_t                var;
	   WCHAR                     sFilter[LEN_Path];
	   VARIANT_BOOL				 bSidColumn = VARIANT_FALSE;

	      //find out if the new sid column is there, if not, don't try
	      //writing to it
	   SidColumnInARTable(&bSidColumn);

	   wsprintf(sFilter, L"DomainName = \"%s\" and Server = \"%s\" and Account = \"%s\" and RefType = \"%s\"", sDomain, sComp, sAcct, sType);
	   var = sFilter;
	   ClearTable(L"AccountRefs", var);

      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"AccountRefs";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"Time")->Value = DATE(dt);
	  if (wcscmp(sDomain, GET_STRING(IDS_UnknownSid)))
         wcscpy((WCHAR*) sDomain, UStrUpr((WCHAR*)sDomain));
      pRs->Fields->GetItem(L"DomainName")->Value = sDomain;
      wcscpy((WCHAR*) sComp, UStrUpr((WCHAR*)sComp));
      pRs->Fields->GetItem(L"Server")->Value = sComp;
      pRs->Fields->GetItem(L"Account")->Value = sAcct;
      pRs->Fields->GetItem(L"RefCount")->Value = lCount;
      pRs->Fields->GetItem(L"RefType")->Value = sType;
	  if (bSidColumn)
	  {
         wcscpy((WCHAR*) sAcctSid, UStrUpr((WCHAR*)sAcctSid));
         pRs->Fields->GetItem(L"AccountSid")->Value = sAcctSid;
	  }

      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

void CIManageDB::ClipVarset(IVarSetPtr pVS)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   sTemp, keyName, sTempKey;
   long                      offset = 0;
   bool                      cont = true;
   WCHAR                     sKeyName[MAX_BUF_LEN];
   _variant_t                varKey, value;
   IEnumVARIANT            * varEnum;
   DWORD                     nGot = 0;
   IUnknown                * pEnum = NULL;
   CString                   strTemp;
   int                       len;

   // we are now going to enumerate through the varset and clip the strings if larger then MAX_BUFFER
   hr = pVS->get__NewEnum(&pEnum);
   if ( SUCCEEDED(hr) )
   {
      // Get the IEnumVARIANT pointer to enumerate
      hr = pEnum->QueryInterface(IID_IEnumVARIANT,(void**)&varEnum);
      pEnum->Release();
      pEnum = NULL;
   }

   if ( SUCCEEDED(hr))
   {
      while ( (hr = varEnum->Next(1,&varKey,&nGot)) == S_OK )
      {
         if ( nGot > 0 )
         {
            keyName = V_BSTR(&varKey);
            value = pVS->get(keyName);
            if ( value.vt == VT_BSTR )
            {
               sTemp = value;
               if ( sTemp.length() > MAX_BUF_LEN )
               {
                  CString str((WCHAR*) sTemp);
                  // This won't fit in the buffer. We need to break it up and save
                  while (cont)
                  {
                     cont = false;
                     strTemp = str.Mid((offset*255), 255);                     
                     len = strTemp.GetLength();
                     if ( len )
                     {
                        offset++;
                        wsprintf(sKeyName, L"BROKEN.%s.%d", (WCHAR*) keyName, offset);
                        sTempKey = sKeyName;
                        sTemp = strTemp;
                        pVS->put(sTempKey, sTemp);
                        cont = (len == 255);
                     }
                  }
                  pVS->put(keyName, L"DIVIDED_KEY");
                  wsprintf(sKeyName, L"BROKEN.%s", (WCHAR*) keyName);
                  sTempKey = sKeyName;
                  pVS->put(sTempKey, offset);
                  cont = true;
                  offset = 0;
               }
            }
         }
      }
      varEnum->Release();
   }
}

void CIManageDB::RestoreVarset(IVarSetPtr pVS)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   sTemp, keyName, sTempKey;
   long                      offset = 0;
   bool                      cont = true;
   WCHAR                     sKeyName[MAX_BUF_LEN];
   _variant_t                varKey, value;
   IEnumVARIANT            * varEnum;
   DWORD                     nGot = 0;
   IUnknown                * pEnum = NULL;
   _bstr_t                   strTemp;

   // we are now going to enumerate through the varset and clip the strings if larger then MAX_BUFFER
   hr = pVS->get__NewEnum(&pEnum);
   if ( SUCCEEDED(hr) )
   {
      // Get the IEnumVARIANT pointer to enumerate
      hr = pEnum->QueryInterface(IID_IEnumVARIANT,(void**)&varEnum);
      pEnum->Release();
      pEnum = NULL;
   }

   if ( SUCCEEDED(hr))
   {
      while ( (hr = varEnum->Next(1,&varKey,&nGot)) == S_OK )
      {
         if ( nGot > 0 )
         {
            keyName = V_BSTR(&varKey);
            value = pVS->get(keyName);
            if ( value.vt == VT_BSTR )
            {
               sTemp = value;
               if (!_wcsicmp((WCHAR*)sTemp, L"DIVIDED_KEY"))
               {
                  wsprintf(sKeyName, L"BROKEN.%s", (WCHAR*) keyName);
                  sTempKey = sKeyName;
                  value = pVS->get(sTempKey);
                  if ( value.vt == VT_I4 )
                  {
                     offset = value.lVal;
                     for ( long x = 1; x <= offset; x++ )
                     {
                        wsprintf(sKeyName, L"BROKEN.%s.%d", (WCHAR*) keyName, x);
                        sTempKey = sKeyName;
                        value = pVS->get(sTempKey);
                        if ( value.vt == VT_BSTR )
                        {
                           sTemp = value;
                           strTemp += V_BSTR(&value);
                        }
                     }
                     pVS->put(keyName, strTemp);
                     strTemp = L"";
                  }
               }
            }
         }
      }
      varEnum->Release();
   }
}

STDMETHODIMP CIManageDB::AddSourceObject(BSTR sDomain, BSTR sSAMName, BSTR sType, BSTR sRDN, BSTR sCanonicalName, LONG bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      m_rsAccounts->AddNew();
      wcscpy((WCHAR*) sDomain, UStrUpr((WCHAR*)sDomain));
      m_rsAccounts->Fields->GetItem(L"Domain")->Value = sDomain;
      m_rsAccounts->Fields->GetItem(L"Name")->Value = sSAMName;
      wcscpy((WCHAR*) sType, UStrLwr((WCHAR*)sType));
      m_rsAccounts->Fields->GetItem(L"Type")->Value = sType;
      m_rsAccounts->Fields->GetItem(L"RDN")->Value = sRDN;
      m_rsAccounts->Fields->GetItem(L"Canonical Name")->Value = sCanonicalName;
      m_rsAccounts->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::OpenAccountsTable(LONG bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		if (m_rsAccounts->State == adStateClosed)
		{
			_variant_t vtSource;
			if ( bSource )
				vtSource = L"SourceAccounts";
			else
				vtSource = L"TargetAccounts";
				   
			   //if not modified already, modify the table
		    if (!NCTablesColumnsChanged(bSource))
			   hr = ChangeNCTableColumns(bSource);

			if (SUCCEEDED(hr))
			   m_rsAccounts->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
		}
		else
			hr = S_FALSE;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::CloseAccountsTable()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
		if (m_rsAccounts->State == adStateOpen)
		{
			m_rsAccounts->Close();
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

// Returns the number of entries in the migratedobjects table.
STDMETHODIMP CIManageDB::AreThereAnyMigratedObjects(long *count)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      WCHAR                        sActionInfo[LEN_Path];
      _variant_t                   var;
      
      wcscpy(sActionInfo, L"Select count(*) as NUM from MigratedObjects");
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      var = pRs->Fields->GetItem((long)0)->Value;
      * count = var.lVal;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::GetActionHistoryKey(long lActionID, BSTR sKeyName, VARIANT *pVar)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
      WCHAR                        sActionInfo[LEN_Path];
      _variant_t                   var;
      
      wsprintf(sActionInfo, L"Select * from ActionHistory where Property = \"%s\" and ActionID = %d", (WCHAR*) sKeyName, lActionID);
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if ((pRs->BOF == VARIANT_FALSE) && (pRs->EndOfFile == VARIANT_FALSE))
      {
         GetVarFromDB(pRs, var);
      }

      *pVar = var.Detach();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::GetMigratedObjectBySourceDN(BSTR sSourceDN, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      if ( (wcslen(sSourceDN) == 0) )
         _com_issue_error(E_INVALIDARG);

      wsprintf(sActionInfo, L"SELECT * FROM MigratedObjects WHERE SourceAdsPath Like '%%%s'", (WCHAR*) sSourceDN); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::SaveUserProps(IUnknown * pUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
      IVarSetPtr                   pVs = pUnk;
      WCHAR                        sQuery[LEN_Path];
      WCHAR                        sSource[LEN_Path], sDomain[LEN_Path];
      HRESULT                      hr = S_OK;
      bool                         bComp = false;
      _variant_t                   var;
      
      var = pVs->get(GET_BSTR(DCTVS_Options_SourceDomain));
      wcscpy(sDomain, (WCHAR*)V_BSTR(&var));

      var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
      wcscpy(sSource, (WCHAR*)V_BSTR(&var));
      
      wsprintf(sQuery, L"delete from UserProps where SourceDomain=\"%s\" and SourceSam=\"%s\"", 
                        sDomain, sSource);
      vtSource = _bstr_t(sQuery);
      hr = pRs->raw_Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      vtSource = L"UserProps";
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      pRs->AddNew();
      pRs->Fields->GetItem(L"ActionID")->Value = pVs->get(GET_BSTR(DB_ActionID));
      pRs->Fields->GetItem(L"SourceDomain")->Value = sDomain;
      pRs->Fields->GetItem(L"SourceSam")->Value = sSource;
      pRs->Fields->GetItem(L"Flags")->Value = pVs->get(GET_BSTR(DCTVS_CopiedAccount_UserFlags));
      pRs->Fields->GetItem(L"Expires")->Value = pVs->get(GET_BSTR(DCTVS_CopiedAccount_ExpDate));
      pRs->Update();
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

STDMETHODIMP CIManageDB::GetUserProps(BSTR sDom, BSTR sSam, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"UserProps";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the parameters are not correct then we need to return an error
      if ( !wcslen((WCHAR*)sDom) && !wcslen((WCHAR*)sSam) )
         _com_issue_error(E_INVALIDARG);

      wsprintf(sActionInfo, L"SELECT * FROM UserProps WHERE SourceDomain='%s' and SourceSam='%s'", (WCHAR*)sDom, (WCHAR*)sSam); 
      vtSource = sActionInfo;
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);
      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  pVs->put(L"ActionID",pRs->Fields->GetItem(L"ActionID")->Value);
		  pVs->put(L"SourceDomain",pRs->Fields->GetItem(L"SourceDomain")->Value);
		  pVs->put(L"SourceSam",pRs->Fields->GetItem(L"SourceSam")->Value); 
		  pVs->put(GET_BSTR(DCTVS_CopiedAccount_UserFlags),pRs->Fields->GetItem(L"Flags")->Value);  
		  pVs->put(GET_BSTR(DCTVS_CopiedAccount_ExpDate),pRs->Fields->GetItem(L"Expires")->Value);  
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB checks to see*
 * if the new Source domain SID column is in the MigratedObjects     *
 * table.                                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN SrcSidColumnInMigratedObjectsTable
STDMETHODIMP CIManageDB::SrcSidColumnInMigratedObjectsTable(VARIANT_BOOL *pbFound)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	*pbFound = VARIANT_FALSE;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
	  long						   numColumns;
	  long						   ndx = 0;
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
         //get the number of columns
      numColumns = pRs->Fields->GetCount();
	     //look for new column's name in each column header
	  while ((ndx < numColumns) && (*pbFound == VARIANT_FALSE))
	  {
		     //get the column name
		  _variant_t var(ndx);
		  _bstr_t columnName = pRs->Fields->GetItem(var)->Name;
		     //if this is the Src Sid column then set return value flag to true
		  if (!_wcsicmp((WCHAR*)columnName, GET_BSTR(DB_SourceDomainSid)))
             *pbFound = VARIANT_TRUE;
		  ndx++;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END SrcSidColumnInMigratedObjectsTable

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB retrieves    *
 * information about previously migrated objects, from a MOT missing *
 * the source sid column, within a given action or as a whole.       *
 *                                                                   *
 *********************************************************************/

//BEGIN GetMigratedObjectsFromOldMOT
STDMETHODIMP CIManageDB::GetMigratedObjectsFromOldMOT(long lActionID, IUnknown ** ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	// This function returns all migrated objects and their information related
   // to a pirticular Action ID. This is going to return nothing if the actionID is
   // empty.

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[255];
      long                         lCnt = 0;

      if ( lActionID != -1 )
      {
         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects.
         wsprintf(sActionInfo, L"ActionID=%d", lActionID);
         pRs->Filter = sActionInfo;
      }
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
      if (pRs->GetRecordCount() > 0)
	  {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
	  }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END GetMigratedObjectsFromOldMOT

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 18 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB adds the     *
 * source domain SID column to the MigratedObjects table.            *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateSrcSidColumnInMOT
STDMETHODIMP CIManageDB::CreateSrcSidColumnInMOT(VARIANT_BOOL *pbCreated)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */
	const long COLUMN_MAX_CHARS = 255;

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	*pbCreated = VARIANT_FALSE;

	try
	{

	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's MigratedObjects Table
      m_pTable = m_pCatalog->Tables->Item[L"MigratedObjects"];
         //append a new column to the end of the MOT
      m_pTable->Columns->Append(L"SourceDomainSid", adVarWChar, COLUMN_MAX_CHARS);
		 //set the column to be nullable
//	  ADOX::_ColumnPtr pColumn = m_pTable->Columns->Item[L"SourceDomainSid"];
//	  pColumn->Attributes = ADOX::adColNullable;
      *pbCreated = VARIANT_TRUE;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END CreateSrcSidColumnInMOT

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB deletes the  *
 * source domain SID column from the MigratedObjects table.          *
 *                                                                   *
 *********************************************************************/

//BEGIN DeleteSrcSidColumnInMOT
STDMETHODIMP CIManageDB::DeleteSrcSidColumnInMOT(VARIANT_BOOL *pbDeleted)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	*pbDeleted = VARIANT_FALSE;

	try
	{

	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's MigratedObjects Table
      m_pTable = m_pCatalog->Tables->Item[L"MigratedObjects"];
         //delete the column from the MOT
      m_pTable->Columns->Delete(L"SourceDomainSid");
      *pbDeleted = VARIANT_TRUE;
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END DeleteSrcSidColumnInMOT

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 21 AUG 2000                                                 *
 *                                                                   *
 *     This protected member function of the CIManageDB populates the*
 * new Source domain SID column in the MigratedObjects table for all *
 * entries from the given domain.  If the domain cannot be reached no*
 * entry is added.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN PopulateSrcSidColumnByDomain
STDMETHODIMP CIManageDB::PopulateSrcSidColumnByDomain(BSTR sDomainName,
													  BSTR sSid,
													  VARIANT_BOOL * pbPopulated)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local variables */
	HRESULT                   hr = S_OK;
    PSID                      pSid = NULL;
    DWORD                     rc = 0;
    WCHAR                   * domctrl = NULL;
    WCHAR                     txtSid[MAX_PATH];
    DWORD                     lenTxt = DIM(txtSid);
      

/* function body */
	*pbPopulated = VARIANT_FALSE; //init flag to false

	try
	{
       _RecordsetPtr             pRs(__uuidof(Recordset));
       _variant_t                vtSource = L"MigratedObjects";
       WCHAR                     sActionInfo[MAX_PATH];

	      //if we don't already know the source sid then find it
	   wcscpy(txtSid, (WCHAR*)sSid);
	   if (!wcscmp(txtSid, L""))
	   {
	         //get the sid for this domain
          if ( sDomainName[0] != L'\\' )
		  {
             rc = NetGetDCName(NULL,(WCHAR*)sDomainName,(LPBYTE*)&domctrl);
		  }
          if ( rc )
		     return hr;

	      rc = GetDomainSid(domctrl,&pSid);
          NetApiBufferFree(domctrl);

          if ( !GetTextualSid(pSid,txtSid,&lenTxt) )
		  {
			 if (pSid)
			    FreeSid(pSid);
		     return hr;
		  }
		  if (pSid)
		     FreeSid(pSid);
	   }
	      //save the sid in a variant
       _variant_t vName = txtSid;
   
	      //find each entry in the MigratedObjects table from this source domain
		  //and store the source domain sid in that column
       wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\"", (WCHAR*)sDomainName);
       vtSource = _bstr_t(sActionInfo);
       pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

       if (pRs->GetRecordCount() > 0)
       {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
		     pRs->Fields->GetItem(L"SourceDomainSid")->Value = vName;
		     pRs->MoveNext();
		  }
       }
	   *pbPopulated = VARIANT_TRUE; //set flag since populated
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END PopulateSrcSidColumnByDomain

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 SEPT 2000                                                *
 *                                                                   *
 *     This protected member function of the CIManageDB checks to see*
 * if the new Account SID column is in the Account References table. *
 *                                                                   *
 *********************************************************************/

//BEGIN SidColumnInARTable
STDMETHODIMP CIManageDB::SidColumnInARTable(VARIANT_BOOL *pbFound)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	*pbFound = VARIANT_FALSE;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"AccountRefs";
	  long						   numColumns;
	  long						   ndx = 0;
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
         //get the number of columns
      numColumns = pRs->Fields->GetCount();
	     //look for new column's name in each column header
	  while ((ndx < numColumns) && (*pbFound == VARIANT_FALSE))
	  {
		     //get the column name
		  _variant_t var(ndx);
		  _bstr_t columnName = pRs->Fields->GetItem(var)->Name;
		     //if this is the Src Sid column then set return value flag to true
		  if (!_wcsicmp((WCHAR*)columnName, L"AccountSid"))
             *pbFound = VARIANT_TRUE;
		  ndx++;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END SidColumnInARTable


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 SEPT 2000                                                *
 *                                                                   *
 *     This protected member function of the CIManageDB adds the     *
 * SID column to the Account Reference table, if it is not already   *
 * there.                                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN CreateSidColumnInAR
STDMETHODIMP CIManageDB::CreateSidColumnInAR()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */
	const long COLUMN_MAX_CHARS = 255;

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	try
	{

	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's MigratedObjects Table
      m_pTable = m_pCatalog->Tables->Item[L"AccountRefs"];
         //append a new column to the end of the MOT
      m_pTable->Columns->Append(L"AccountSid", adVarWChar, COLUMN_MAX_CHARS);
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END CreateSidColumnInAR


//---------------------------------------------------------------------------
// UpgradeDatabase
//
// Upgrades Protar.mdb database from version 3.x to 4.x. Version 4.x adds
// UNICODE support.
//
// 2001-02-13 Mark Oluper - initial
//---------------------------------------------------------------------------

void CIManageDB::UpgradeDatabase(LPCTSTR pszFolder)
{
	try
	{
		_bstr_t strFolder = pszFolder;
		_bstr_t strDatabase = strFolder + _T("Protar.mdb");
		_bstr_t strDatabase3x = strFolder + _T("Protar3x.mdb");
		_bstr_t strDatabase4x = strFolder + _T("Protar4x.mdb");

		_bstr_t strConnectionPrefix = _T("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=");
		_bstr_t strSourceConnection = strConnectionPrefix + strDatabase;
		_bstr_t strTargetConnection = strConnectionPrefix + strDatabase4x + _T(";Jet OLEDB:Engine Type=5");

		IJetEnginePtr spJetEngine(__uuidof(JetEngine));

		HRESULT hr = spJetEngine->raw_CompactDatabase(strSourceConnection, strTargetConnection);

		if (FAILED(hr))
		{
			AdmtThrowError(
				hr,
				_Module.GetResourceInstance(),
				IDS_E_UPGRADE_TO_TEMPORARY,
				(LPCTSTR)strDatabase,
				(LPCTSTR)strDatabase4x
			);
		}

		if (!MoveFileEx(strDatabase, strDatabase3x, MOVEFILE_WRITE_THROUGH))
		{
			DWORD dwError = GetLastError();

			DeleteFile(strDatabase4x);

			AdmtThrowError(
				HRESULT_FROM_WIN32(dwError),
				_Module.GetResourceInstance(),
				IDS_E_UPGRADE_RENAME_ORIGINAL,
				(LPCTSTR)strDatabase,
				(LPCTSTR)strDatabase3x
			);
		}

		if (!MoveFileEx(strDatabase4x, strDatabase, MOVEFILE_WRITE_THROUGH))
		{
			DWORD dwError = GetLastError();

			MoveFileEx(strDatabase3x, strDatabase, MOVEFILE_WRITE_THROUGH);
			DeleteFile(strDatabase4x);

			AdmtThrowError(
				HRESULT_FROM_WIN32(dwError),
				_Module.GetResourceInstance(),
				IDS_E_UPGRADE_RENAME_UPGRADED,
				(LPCTSTR)strDatabase4x,
				(LPCTSTR)strDatabase
			);
		}
	}
	catch (_com_error& ce)
	{
		AdmtThrowError(ce, _Module.GetResourceInstance(), IDS_E_UPGRADE_TO_4X);
	}
	catch (...)
	{
		AdmtThrowError(E_FAIL, _Module.GetResourceInstance(), IDS_E_UPGRADE_TO_4X);
	}
}

//---------------------------------------------------------------------------------------------
// GetMigratedObjectByType : Given the type of object this function retrieves info about
//                           all previously migrated objects of this type.  The scope of the 
//							 search can be limited by optional ActionID (not -1) or optional
//							 source domain (not empty).
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetMigratedObjectByType(long lActionID, BSTR sSrcDomain, BSTR sType, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      long                         lCnt = 0;
      _bstr_t                      sName;
      
      // If the type parameter is not correct then we need to return an error
      if (wcslen((WCHAR*)sType) == 0)
         _com_issue_error(E_INVALIDARG);

         // If a valid ActionID is specified then we only return the data for that one. 
         // but if -1 is passed in then we return all migrated objects of the specified type.
      if ( lActionID != -1 )
      {
         wsprintf(sActionInfo, L"Select * from MigratedObjects where ActionID = %d AND Type=\"%s\" Order by Time", lActionID, sType);
      }
	     //else if source domain specified, get objects of the specified type from that domain
	  else if (wcslen((WCHAR*)sSrcDomain) != 0)
	  {
         wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomain=\"%s\" AND Type=\"%s\" Order by Time", sSrcDomain, sType);
	  }
	  else  //else get all objects of the specified type
	  {
         wsprintf(sActionInfo, L"Select * from MigratedObjects where Type=\"%s\" Order by Time", sType);
	  }

      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  pRs->MoveFirst();
		  while ( !pRs->EndOfFile )
		  {
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_ActionID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Time));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetDomain));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetAdsPath));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_status));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetSamName));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_Type));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_GUID));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_TargetRid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
			 wsprintf(sActionInfo, L"MigratedObjects.%d.%s", lCnt, GET_STRING(DB_SourceDomainSid));      
			 pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
			 pRs->MoveNext();
			 lCnt++;
		  }
		  pVs->put(L"MigratedObjects", lCnt);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

//---------------------------------------------------------------------------------------------
// GetAMigratedObjectBySidAndRid : Given a source domain Sid and account Rid this function 
//                           retrieves info about that migrated object, if any.
//---------------------------------------------------------------------------------------------
STDMETHODIMP CIManageDB::GetAMigratedObjectBySidAndRid(BSTR sSrcDomainSid, BSTR sRid, IUnknown **ppUnk)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource = L"MigratedObjects";
      IVarSetPtr                   pVs = *ppUnk;
      WCHAR                        sActionInfo[LEN_Path];
      
      // If the type parameter is not correct then we need to return an error
      if ((wcslen((WCHAR*)sSrcDomainSid) == 0) || (wcslen((WCHAR*)sRid) == 0))
         _com_issue_error(E_INVALIDARG);

	  int nRid = _wtoi(sRid);

      wsprintf(sActionInfo, L"Select * from MigratedObjects where SourceDomainSid=\"%s\" AND SourceRid=%d Order by Time", sSrcDomainSid, nRid);
      vtSource = _bstr_t(sActionInfo);
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdText);

      if (pRs->GetRecordCount() > 0)
      {
		  // We want the latest move.
		  pRs->MoveLast();
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_ActionID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"ActionID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Time));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Time")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetDomain));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetDomain")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetAdsPath));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetAdsPath")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_status));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"status")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetSamName));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetSamName")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_Type));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"Type")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_GUID));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"GUID")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_TargetRid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"TargetRid")->Value);
		  wsprintf(sActionInfo, L"MigratedObjects.%s", GET_STRING(DB_SourceDomainSid));      
		  pVs->put(sActionInfo, pRs->Fields->GetItem(L"SourceDomainSid")->Value);
      }
	  else
	  {
         hr = S_FALSE;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 MAR 2001                                                 *
 *                                                                   *
 *     This private member function of the CIManageDB checks to see  *
 * if the "Description" column in the Source Accounts table has been *
 * changed to "RDN".  If so, then we have modified both the Source   *
 * and Target Accounts tables for the new form of the "Name Conflict"*
 * report.                                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN NCTablesColumnsChanged
BOOL CIManageDB::NCTablesColumnsChanged(BOOL bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())

	HRESULT hr = S_OK;
	BOOL bFound = FALSE;

	try
	{
      _RecordsetPtr                pRs(__uuidof(Recordset));
      _variant_t                   vtSource;
	  long						   numColumns;
	  long						   ndx = 0;

	  if (bSource)
	     vtSource = L"SourceAccounts";
	  else
	     vtSource = L"TargetAccounts";
      
      pRs->Open(vtSource, m_vtConn, adOpenStatic, adLockOptimistic, adCmdTable);
         //get the number of columns
      numColumns = pRs->Fields->GetCount();
	     //look for new column's name in each column header
	  while ((ndx < numColumns) && (bFound == FALSE))
	  {
		     //get the column name
		  _variant_t var(ndx);
		  _bstr_t columnName = pRs->Fields->GetItem(var)->Name;
		     //if this is the Src Sid column then set return value flag to true
		  if (!_wcsicmp((WCHAR*)columnName, L"RDN"))
             bFound = TRUE;
		  ndx++;
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return bFound;
}
//END NCTablesColumnsChanged


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 MAR 2001                                                 *
 *                                                                   *
 *     This private member function of the CIManageDB modifies       *
 * several of the columns in the Source and Target Accounts tables.  *
 * It changes several column names and one column type to support new*
 * changes to the "Name Conflict" report.                            *
 *                                                                   *
 *********************************************************************/

//BEGIN ChangeNCTableColumns
HRESULT CIManageDB::ChangeNCTableColumns(BOOL bSource)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState())
/* local constants */
	const long COLUMN_MAX_CHARS = 255;

/* local variables */
	HRESULT hr = S_OK;

/* function body */
	try
	{
	  ADOX::_CatalogPtr            m_pCatalog(__uuidof(ADOX::Catalog));
	  ADOX::_TablePtr              m_pTable = NULL;
	  WCHAR                        sConnect[MAX_PATH];
	  WCHAR                        sDir[MAX_PATH];

		// Get the path to the MDB file from the registry
	  TRegKey        key;
	  DWORD rc = key.Open(sKeyBase);
	  if ( !rc ) 
	     rc = key.ValueGetStr(L"Directory", sDir, MAX_PATH);
	  if ( rc != 0 ) 
		 wcscpy(sDir, L"");

	     // Now build the connect string.
	  wsprintf(sConnect, L"Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%sprotar.mdb;", sDir);
      
         //Open the catalog
      m_pCatalog->PutActiveConnection(sConnect);
		 //get a pointer to the database's Source or Target Accounts Table
	  if (bSource)
         m_pTable = m_pCatalog->Tables->Item[L"SourceAccounts"];
	  else
         m_pTable = m_pCatalog->Tables->Item[L"TargetAccounts"];

	  if (m_pTable)
	  {
	        //remove the old Description column
         m_pTable->Columns->Delete(L"Description");
	        //remove the old FullName column
         m_pTable->Columns->Delete(L"FullName");
            //append the RDN column to the end of the Table
         m_pTable->Columns->Append(L"RDN", adVarWChar, COLUMN_MAX_CHARS);
            //append the Canonical Name column to the end of the Table
         m_pTable->Columns->Append(L"Canonical Name", adLongVarWChar, COLUMN_MAX_CHARS);
	  }
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}
//END ChangeNCTableColumns
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\dbtest.h ===
// DBTest.h : main header file for the DBTEST application
//

#if !defined(AFX_DBTEST_H__BF1692B2_2A85_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_DBTEST_H__BF1692B2_2A85_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CDBTestApp:
// See DBTest.cpp for the implementation of this class
//

class CDBTestApp : public CWinApp
{
public:
	CDBTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDBTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CDBTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DBTEST_H__BF1692B2_2A85_11D3_8C8E_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\dbtestdlg.h ===
// DBTestDlg.h : header file
//

#if !defined(AFX_DBTESTDLG_H__BF1692B4_2A85_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_DBTESTDLG_H__BF1692B4_2A85_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CDBTestDlg dialog

class CDBTestDlg : public CDialog
{
// Construction
public:
	CDBTestDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CDBTestDlg)
	enum { IDD = IDD_DBTEST_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDBTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CDBTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DBTESTDLG_H__BF1692B4_2A85_11D3_8C8E_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	DBTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by DBTEST.RC
//
#define IDR_MAINFRAME					128
#define IDM_ABOUTBOX					0x0010
#define IDD_ABOUTBOX					100
#define IDS_ABOUTBOX					101
#define IDD_DBTEST_DIALOG				102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE	129
#define _APS_NEXT_CONTROL_VALUE		1000
#define _APS_NEXT_SYMED_VALUE		101
#define _APS_NEXT_COMMAND_VALUE		32771
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\dbtestdlg.cpp ===
// DBTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "DBTest.h"
#include "DBTestDlg.h"

#import "\bin\McsVarSetMin.tlb" no_namespace
#import "..\DBManager.tlb" no_namespace
#import "c:\program files\Common Files\System\ADO\msado21.tlb" no_namespace rename("EOF", "EndOfFile")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDBTestDlg dialog

CDBTestDlg::CDBTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDBTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDBTestDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CDBTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDBTestDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDBTestDlg, CDialog)
	//{{AFX_MSG_MAP(CDBTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDBTestDlg message handlers

BOOL CDBTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CDBTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CDBTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CDBTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CDBTestDlg::OnOK() 
{
   IIManageDBPtr              pDb(__uuidof(IManageDB));
   IVarSetPtr                 pVS(__uuidof(VarSet));
   _variant_t                 var;
   var = L"This should say hello";
   pVS->put(L"Hello", var);

   var = L"****************";
   pVS->put(L"Hello.1", var);

   var.vt = VT_UI4;
   var.lVal = 25000;
   pVS->put(L"Number", var);

   var.vt = VT_I4;
   var.lVal = -8438;
   pVS->put(L"NegInt", var);

   try
   {
      // Get IUnknown pointer to the Varset
      IUnknown * pUnk;
      pVS->QueryInterface(IID_IUnknown, (void**) &pUnk);

      // Tell DB to save the settings.
//      pDb->SaveSettings(pUnk);
      long lVal = 1;
      pDb->GetNextActionID(&lVal);

      pDb->SetActionHistory(lVal, pUnk);

      // Clear the varset
      pVS->Clear();

      // Save a migrated object.
      pVS->put(L"SourceDomain", L"SDomain");
      pVS->put(L"TargetDomain", L"TDomain");
      pVS->put(L"SourceAdsPath", L"CN=Sham,OU=ShamTest");
      pVS->put(L"TargetAdsPath", L"CN=Sham,OU=More");
      var.vt = VT_UI1;
      var.lVal = 10;
      pVS->put(L"status", var);
      pVS->put(L"SourceSamName", L"Sham");
      pVS->put(L"TargetSamName", L"Sham");
      pVS->put(L"Type", L"user");
      pVS->put(L"GUID", L"10293092-290039-21290-10293");

      pDb->SaveMigratedObject(lVal, pUnk);

      // Get the Varset from DB
//      pDb->GetSettings(&pUnk);
      pDb->GetActionHistory(lVal, &pUnk);
      
      pDb->GetMigratedObjects(lVal, &pUnk);
      
      //IUnknown              * pXL;
      _RecordsetPtr           p;
      //p->QueryInterface(IID_IUnknown, (void *) &pXL);

      p = pDb->GetRSForReport(L"MigratedObjects");
      // Dump the varset to check its content.
      pUnk->Release();

      while ( !p->EndOfFile )
      {
         var = p->Fields->GetItem(L"ActionID")->Value;
         p->MoveNext();
      }

      pVS->DumpToFile(L"C:\\settings.txt");
   }
   catch ( _com_error &e )
   {
      AfxMessageBox(e.ErrorMessage() + e.Description());
   }
	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dbmgr\dbtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__BF1692B6_2A85_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__BF1692B6_2A85_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__BF1692B6_2A85_11D3_8C8E_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\dctagent.h ===
/*---------------------------------------------------------------------------
  File: DCTAgent.h

  Comments: DCT Agent COM object

  The DCT agent can either be launched directly by a client, or 
  started by the DCTAgentService, under the LocalSystem context.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/	
// DCTAgent.h : Declaration of the CDCTAgent

#ifndef __DCTAGENT_H_
#define __DCTAGENT_H_

#include "resource.h"       // main symbols

#define DCT_STATUS_NOT_STARTED         (0x00000001)
#define DCT_STATUS_IN_PROGRESS         (0x00000002)
#define DCT_STATUS_ABORTING            (0x00000004)
#define DCT_STATUS_ABORTED             (0x00000008)
#define DCT_STATUS_COMPLETED           (0x00000010)
#define DCT_STATUS_UNKNOWN             (0x00000020)


#include "TNode.hpp"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb" no_namespace , named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "WorkObj.tlb" no_namespace , named_guids
#include <atlcom.h>

#include "Err.hpp"
#include "ErrDct.hpp"

extern TErrorDct                    errTrace;


BOOL 
   AgentTraceLogging(
      WCHAR               * filename     
   );


class DCTAgentJob : public TNode
{
   GUID                      m_jobID;
   DWORD                     m_threadID;
   IVarSetPtr                m_pVarSet;
   IStatusObjPtr             m_pStatus;
   IUnknown                * m_pUnknown;
   HANDLE                    m_threadHandle;
   time_t                    m_startTime;
   time_t                    m_completionTime;
   
public:
   DCTAgentJob(GUID * pjobID, IVarSet * pVS, IUnknown * pUnk) 
   {
      HRESULT hr = m_pStatus.CreateInstance(CLSID_StatusObj);
      errTrace.DbgMsgWrite(0,L"StatusObject: CreateInstance returned %lx",hr);

      pVS->AddRef();
      memcpy(&m_jobID,pjobID,(sizeof GUID));
      m_pVarSet = pVS;
      if ( m_pStatus != NULL )
      {
         m_pStatus->Status = DCT_STATUS_NOT_STARTED;
      }
      m_threadID = 0;
      m_threadHandle = INVALID_HANDLE_VALUE;
      m_pUnknown = pUnk;
      if ( m_pUnknown )
         m_pUnknown->AddRef();
   }
   ~DCTAgentJob()
   {
      if ( m_threadHandle != INVALID_HANDLE_VALUE )
         CloseHandle(m_threadHandle);
      if ( m_pUnknown )
         m_pUnknown->Release();
      m_pVarSet->Release();
   }
   void     SetThreadInfo(DWORD id, HANDLE handle)   { m_threadID = id; m_threadHandle = handle;}
   void     SetStatus(DWORD status) { if ( m_pStatus!=NULL ) m_pStatus->Status = status; }
   void     ReleaseUnknown() { if ( m_pUnknown ) 
                               { 
                                 IUnknown * pUnk = m_pUnknown;
                                 m_pUnknown = NULL;
                                 pUnk->Release(); 
                               } 
                             }
   void     SetStartTime(time_t t){ m_startTime = t; }
   void     SetEndTime(time_t t){ m_completionTime = t; }

   GUID       GetJobID()               { return m_jobID;}
   DWORD      GetThreadID()            { return m_threadID; }
   HANDLE     GetThreadHandle()        { return m_threadHandle; }
   DWORD      GetStatus()              { if ( m_pStatus != NULL ) return m_pStatus->Status; else return DCT_STATUS_UNKNOWN; }
   IVarSet  * GetVarSet()              { return m_pVarSet; }
   IUnknown * GetUnknown()             { return m_pUnknown; }
   IStatusObj * GetStatusObject()      { return m_pStatus; }
   time_t     GetStartTime()           { return m_startTime; }
   time_t     GetEndTime()             { return m_completionTime; }
};

class DCTJobList : public TNodeList
{
public:
   ~DCTJobList() { DeleteAllListItems(DCTAgentJob); }
   DCTAgentJob * Find(REFGUID pID)
   {
      TNodeListEnum        e;
      DCTAgentJob        * p;
      BOOL                 bFound = FALSE;

      for ( p = (DCTAgentJob*)e.OpenFirst(this) ; p ; p = (DCTAgentJob *)e.Next() )
      {
         if ( IsEqualGUID(pID,p->GetJobID()) )
         {
            bFound = TRUE;
            break;
         }
      }
      e.Close();
      if ( ! bFound )
      {
         p = NULL;
      }
      return p;
   }
   void Insert(DCTAgentJob * p) { InsertBottom(p); }
};



/////////////////////////////////////////////////////////////////////////////
// CDCTAgent
class ATL_NO_VTABLE CDCTAgent : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDCTAgent, &CLSID_DCTAgent>,
	public IDispatchImpl<IDCTAgent,&IID_IDCTAgent,&LIBID_MCSEADCTAGENTLib>
{
public:
	CDCTAgent() :
		m_ulRegister(0)
	{
      WCHAR                  filename[MAX_PATH];

      if ( AgentTraceLogging(filename) )
      {
         errTrace.LogOpen(filename,1);
      }
	}
   ~CDCTAgent()
   {
      errTrace.LogClose();
   }

DECLARE_REGISTRY_RESOURCEID(IDR_DCTAGENT)
DECLARE_NOT_AGGREGATABLE(CDCTAgent)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDCTAgent)
	COM_INTERFACE_ENTRY(IDCTAgent)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		// register agent in running object table

		HRESULT hr = RegisterActiveObject(this, CLSID_DCTAgent, ACTIVEOBJECT_WEAK, &m_ulRegister);

		if (hr == MK_S_MONIKERALREADYREGISTERED)
		{
			hr = S_OK;
		}

		return hr;
	}

	void FinalRelease()
	{
		// unregister agent from the running object table

		if (m_ulRegister)
		{
			RevokeActiveObject(m_ulRegister, NULL);
		}
	}

// IDCTAgent
public:
	STDMETHOD(GetJobList)(/*[out]*/ IUnknown ** pVarSet);
	STDMETHOD(SubmitJob)(IUnknown * pWorkItemIn, /*[out]*/ BSTR * pJobID);
   STDMETHOD(QueryJobStatus)(BSTR jobID, IUnknown ** statusInfoOut);
	STDMETHOD(CancelJob)(BSTR JobID);
	STDMETHOD(RetrieveJobResults)(BSTR jobID, IUnknown ** pWorkItemOut);
	
protected:
	ULONG m_ulRegister;
   DCTJobList                m_JobList;
};

#endif //__DCTAGENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\dctagent.cpp ===
/*---------------------------------------------------------------------------
  File: DCTAgent.cpp

  Comments: Implementation of EADCTAgent aka "the Engine"

  The DCTAgent COM object acts as a workflow engine to drive the migration
  process.  It is used both for local migration, and also in the remote agent.
  
  A new thread is created for each migration job.  The engine looks at the varset
  which defines the job to see which tasks need to be performed.  
  It then calls the needed helper objects (defined in WorkerObjects) to perform these tasks.

  The DCTAgent interface allows jobs to be submitted, and also allows the client to 
  query the status of, or cancel a running job.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/
 // DCTAgent.cpp : Implementation of CDCTAgent
#include "stdafx.h"
//#include "McsEaDctAgent.h"
#include "Engine.h"


//#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids
//#import "WorkObj.tlb" no_namespace, named_guids //#imported by DCTAgent.h below

#include "DCTAgent.h"

/////////////////////////////////////////////////////////////////////////////
// CDCTAgent
#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "LSAUtils.h"
#include "TxtSid.h"
#include "CommaLog.hpp"
#include "EaLen.hpp"
#include "TReg.hpp"
#include "ResStr.h"
#include <lm.h>
#include <locale.h>
#include "TaskChk.h"  // routines to determine which tasks to perform
//#include "..\Common\Include\McsPI.h"
#include "McsPI.h"
#include "McsPI_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TErrorDct                    err;
TError                     & errCommon = err;
BOOL                         m_bRegisteredActive = FALSE;
ULONG                        m_ulRegistrationHandle = 0; 

TErrorDct                    errTrace;
StringLoader                 gString;

bool __stdcall StartNetLogonService();
bool __stdcall StopNetLogonService();

HRESULT                                      // ret- HRESULT
   ChangeDomainAffiliation(
      IVarSet              * pVarSet,      // in - varset
      BOOL                   bNoChange,    // in - flag, nochange mode
      BSTR                   targetDomain, // in - name of target domain
      BSTR                   targetName,   // in - new name of computer, if being renamed also
      BSTR                   credDomain,   // in - domain for credentials
      BSTR                   credAccount,  // in - account for credentials
      BSTR                   credPassword  // in - password for credentials
   );

HRESULT                                      // ret- HRESULT
   RenameComputer(
      BOOL                   bNoChange,      // in - flag, whether to write changes
      BSTR                   targetName      // in - new name for local computer
   );

HRESULT                                      // ret- HRESULT
   RebootTheComputer(
      BOOL                   bNoChange,      // in - flag, whether to actually do it
      LONG                   delay           // in - delay in seconds before rebooting
   );

HRESULT                                      // ret- HRESULT
   DoPlugInTask(
      IVarSet              * pVarSet,        // in - varset describing migration job
      int                    task            // in - 0=premigration, 1=postmigration
   );



DWORD __stdcall                            // ret- OS return code
   ExecuteDCTJob( 
      void                 * arg           // in - pointer to DCTAgentJob object containing information about job to do
   );

void 
   GetTempLogFile(
      WCHAR                * path          // out- path name (must be buffer that can hold at least MAX_PATH characters)
   )
{
   DWORD                     rc = 0;
   TRegKey                   rKey;
   WCHAR                     temp[MAX_PATH] = L"";
   DWORD                     type;
   DWORD                     len = DIM(temp);

   // get the temp path from the registry, since 
   // the GetTempPath API looks for the environment variables not defined when running as LocalSystem
   // When it doesn't find these environment variables, it uses %systemroot%
#ifndef OFA
   // first, look in "System\\CurrentControlSet\\Control\\Session Manager\\Environment", 
   // since this is where Win2K keeps the system TEMP environment variable
   rc = rKey.OpenRead(L"System\\CurrentControlSet\\Control\\Session Manager\\Environment",HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = rKey.ValueGet(L"TEMP",(void*)temp,&len,&type);
      if ( rc )
      {
         len = DIM(temp);
         rc = rKey.ValueGet(L"TMP",(void*)temp,&len,&type);
      }
      rKey.Close();
   }
#endif
   // if the HKLM key didn't work, use the default user's temp directory
   if ( temp[0] == 0 ) // for OFA, this will always be TRUE
   {
      rc = rKey.OpenRead(L".DEFAULT\\Environment",HKEY_USERS);
      if ( ! rc )
      {
         rc = rKey.ValueGet(L"TEMP",(void*)temp,&len,&type);
         if ( rc )
         {
            len = DIM(temp);
            rc = rKey.ValueGet(L"TMP",(void*)temp,&len,&type);
         }
      }
   }

   if ( ! rc )
   {
      // substitute for other environment variables in the path
      if ( ! ExpandEnvironmentStrings(temp,path,MAX_PATH) )
      {
         rc = GetLastError();
      }
   }
   if ( rc )
   {
      if ( ! GetTempPath(MAX_PATH,path) )
      {
         // if can't get temp dir, use root of c drive as as last resort
         UStrCpy(path,"C:\\");
      }
   }

   // append a fixed filename to the path
   if ( path[UStrLen(path)-1] != L'\\' )
   {
      len = UStrLen(path);
      path[len] = L'\\';
      path[len+1] = 0;
   }
   UStrCpy(path+UStrLen(path),GET_STRING(IDS_LOG_FILENAME));
   errTrace.DbgMsgWrite(0,L"Found temp directory log file path: %ls",path);

}

BOOL                                       // ret- whether debug information should be written
   DumpDebugInfo(
      WCHAR                * filename      // out- filename to write debug info to
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"DumpVarSet",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   return bFound;
}

BOOL                                       // ret- whether to perform trace logging to a file
   AgentTraceLogging(   
      WCHAR               * filename       // out- filename to use for trace logging
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;
   WCHAR                     fnW[MAX_PATH];

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"AgentTraceLog",fnW,MAX_PATH);
      if ( ! rc )
      {
         if ( *fnW ) 
         {
            bFound = TRUE;
            UStrCpy(filename,fnW);
         }
         else
         {
            filename[0] = 0;
         }
      }
   }
   return bFound;
}

// ExecuteDCTJob is the entry point for a thread that performs a migration task
// Each job is run in its own thread
// It instantiates helper objects as needed to perform the migration job
DWORD __stdcall 
   ExecuteDCTJob( 
      void                 * arg           // in - pointer to DCTAgentJob object containing information about job to do
   )
{

   HRESULT                   hr = S_OK;
   DWORD                     rc = 0;
   
   _wsetlocale( LC_ALL, L".ACP" );
   
   _bstr_t        domain;
   _bstr_t        username;
   _bstr_t        password;
   _bstr_t        server;
   _bstr_t        share;

   hr = CoInitialize(NULL);
   if(!SUCCEEDED(hr)) return rc;
   DCTAgentJob             * pJob = (DCTAgentJob *)arg;
   IVarSetPtr                pVarSet = pJob->GetVarSet();

   try {

      errTrace.DbgMsgWrite(0,L"ExecuteDCTJob:  Started");
      if ( SUCCEEDED(hr) )
      {
         errTrace.DbgMsgWrite(0,L"ExecuteDCTJob:  CoInitialize succeeded.");
         
         {
            
            _bstr_t                   logFile;
            BOOL                      bSessEstablished = FALSE;
            BOOL                      bNeedToReboot = FALSE;
            LONG                      delay; // reboot delay
            int                       bAppend = 0;
            
            try 
            {
               pJob->SetStatus(DCT_STATUS_IN_PROGRESS);
               pJob->SetStartTime(time(NULL));   

               // Establish a connection to the result drive
               domain = pVarSet->get(GET_WSTR(DCTVS_Options_Credentials_Domain));
               username = pVarSet->get(GET_WSTR(DCTVS_Options_Credentials_UserName));
               password = pVarSet->get(GET_WSTR(DCTVS_Options_Credentials_Password));
               server = pVarSet->get(GET_WSTR(DCTVS_Options_Credentials_Server));
               share = pVarSet->get(GET_WSTR(DCTVS_Options_Credentials_Share));
               _bstr_t        outputfile = pVarSet->get(GET_WSTR(DCTVS_Options_ResultFile));
               _bstr_t        logtotemp = pVarSet->get(GET_WSTR(DCTVS_Options_LogToTemp));
               _bstr_t        nc = pVarSet->get(GET_WSTR(DCTVS_Options_NoChange));
               _bstr_t        appendLog = pVarSet->get(GET_WSTR(DCTVS_Options_AppendToLogs));

               BOOL           bNoChange = (UStrICmp(nc,GET_STRING(IDS_YES)) == 0);
            
               bAppend = ( UStrICmp(appendLog,GET_STRING(IDS_YES)) == 0) ? 1 : 0;

               if  ( UStrICmp(logtotemp,GET_STRING(IDS_YES)) )
               {
                  logFile = pVarSet->get(GET_WSTR(DCTVS_Options_Logfile));
               }
               else
               {
                  WCHAR            log[MAX_PATH];

                  GetTempLogFile(log);
                  logFile = log;
                  pVarSet->put(GET_WSTR(DCTVS_Options_Logfile),logFile);
               }
               if ( ! err.LogOpen((WCHAR*)logFile,bAppend) )
               {
                  err.MsgWrite(ErrE,DCT_MSG_CANNOT_OPEN_LOGFILE_S,(WCHAR*)logFile);
                  errTrace.MsgWrite(ErrE,DCT_MSG_CANNOT_OPEN_LOGFILE_S,(WCHAR*)logFile);
               }
               pVarSet->put(GET_WSTR(DCTVS_Results_LogFile),logFile);
               err.DbgMsgWrite(0,L"");
               err.MsgWrite(0,DCT_MSG_EDA_STARTING);
            
               // ExecuteDCTJob will instantiate and call any worker objects we need.
               // Later, we could replace this function with a more flexible workflow 
            
               if ( pJob->GetStatusObject() != NULL )
               {
                  pVarSet->putObject(GET_WSTR(DCTVS_StatusObject),pJob->GetStatusObject());
               }
               else
               {
                  errTrace.DbgMsgWrite(0,L"Status object is NULL!");
               }

               // Do premigration task for any plug-ins
               DoPlugInTask(pVarSet,0);
               
               // Run account replicator
               if ( NeedToUseAR(pVarSet) )
               {
                  try { 
                     IAcctReplPtr ar;

                     err.MsgWrite(0,DCT_MSG_STARTING_AR);
                     hr = ar.CreateInstance(CLSID_AcctRepl);
                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Started account replicator");
                        err.LogClose();
                        pVarSet->put(GET_WSTR(DCTVS_CurrentOperation),GET_WSTR(IDS_ACCT_REPL_OPERATION_TEXT));
                        hr = ar->raw_Process(pVarSet);
                        errTrace.DbgMsgWrite(0,L"Finished account replicator");
                        pVarSet->put(GET_WSTR(DCTVS_CurrentOperation),"");
                        err.LogOpen((WCHAR*)logFile,1);
                     }
                     else
                     {
                        err.SysMsgWrite(ErrS,hr,DCT_MSG_AR_FAILED_D,hr);
                     }
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Account Replicator threw an exception.");
                  }
               }
               
               if ( NeedToUseST(pVarSet) )
               {
                  try { 
                     ISecTranslatorPtr fst;
                     err.MsgWrite(0,DCT_MSG_STARTING_ST);
                     hr = fst.CreateInstance(CLSID_SecTranslator);
                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Started FST");
                        err.LogClose();
                        try {
                           hr = fst->raw_Process(pVarSet);
                        }
                        catch (...){ 
                           err.LogOpen((WCHAR*)logFile,1);
                           err.MsgWrite(ErrS,DCT_MSG_ST_FAILED_D,E_FAIL);
                        }
                        errTrace.DbgMsgWrite(0,L"Finished FST!");
                        err.LogOpen((WCHAR*)logFile,1);
                     }
                     else
                     {
                        err.SysMsgWrite(ErrS,hr,DCT_MSG_ST_FAILED_D,hr);
                     }
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Security Translator threw an exception.");
                  }
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 1");

               pVarSet->put(GET_WSTR(DCTVS_Options_Credentials_Password),L"");
               pVarSet->put(GET_WSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),L"");

               // Need to call PwdAge?
               _bstr_t                   filename = pVarSet->get(GET_WSTR(DCTVS_GatherInformation_ComputerPasswordAge));
            
               if ( filename.length() )
               {
                  try { 
                     _bstr_t                domain = pVarSet->get(GET_WSTR(DCTVS_Options_SourceDomain));
                     IComputerPwdAgePtr pwdage;

                     err.MsgWrite(0,DCT_MSG_STARTING_COMPPWDAGE);
                     hr = pwdage.CreateInstance(CLSID_ComputerPwdAge);
                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Started comp pwd age");
                  
                        _bstr_t             statString;

                        statString += GET_WSTR(IDS_EXTRACTING_COMP_PWD_AGE);
                        statString += domain;

                        pVarSet->put(GET_WSTR(DCTVS_CurrentPath),statString);
                        hr = pwdage->raw_ExportPasswordAge(domain,filename);
                     }
                     else
                     {
                        err.SysMsgWrite(ErrS,hr,DCT_MSG_COMPPWDAGE_FAILED_D, hr);
                     }
                     pVarSet->put(GET_WSTR(DCTVS_CurrentPath),L"");
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Password Age Gatherer threw an exception.");
                  }
        
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 2");
               filename = pVarSet->get(GET_WSTR(DCTVS_GatherInformation_UserRights));
               // Gather user rights information
               if ( filename.length() )
               {
               
                  try { 
                     IUserRightsPtr userRights;
                     errTrace.DbgMsgWrite(0,L"Gathering user rights, filename = %ls",(WCHAR*)filename);
                     err.MsgWrite(0,DCT_MSG_STARTING_USERRIGHTS);
                     hr = userRights.CreateInstance(CLSID_UserRights);

                     if ( SUCCEEDED(hr) )
                     {
                        errTrace.DbgMsgWrite(0,L"Created User Rights object");
                        // Enumerate through server list
                        int                 i = 0;
                        WCHAR               key[200];
                        _bstr_t             server;
                        _bstr_t             statString;

                        do { 
                           swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);
                           server = pVarSet->get(key);
                           if ( ! server.length() )
                              break;
            
                           err.MsgWrite(0,DCT_MSG_EXPORTING_RIGHTS_SS,(WCHAR*)server,(WCHAR*)filename);
                           hr = userRights->raw_ExportUserRights(server,filename,(i!=0));
                           if ( FAILED(hr) )
                           {
                              err.SysMsgWrite(ErrS,HRESULT_CODE(hr),DCT_MSG_RIGHTS_EXPORT_FAILED_SD,(WCHAR*)server,hr);   
                           }
                           i++;
                        } while ( server.length() );
                     }
                     else
                     {
                        err.MsgWrite(ErrS,DCT_MSG_RIGHTS_NOT_STARTED_D,hr);
                     }
                     pVarSet->put(GET_WSTR(DCTVS_CurrentPath),L"");
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The User Rights Gatherer threw an exception.");
                  }
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 3");

               // OFA needs the StatusObject during the post-migration task.  I don't see any reason to blow
               // away the StatusObject here, so I'm commenting out the following line.
               // pVarSet->put(GET_WSTR(DCTVS_StatusObject),L"");
               // The reason for blowing away the status object is that the code that loads the varset result 
               // file from disk cannot load the status object
               // I'll move the commented out line to after the plug-ins have been called

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 4");
            
               // Change domain and/or rename and optionally reboot?
               hr = S_OK;
               if ( outputfile.length() )
               {
                  try { 
                     _bstr_t                TargetName = pVarSet->get(GET_WSTR(DCTVS_LocalServer_RenameTo));
                     WCHAR                  sSourceName[LEN_Path];
                     DWORD                  lenName = LEN_Path;

                     GetComputerName(sSourceName, &lenName);
                     if ( TargetName.length() )
                     {
                        // Rename the local computer
                        hr = RenameComputer(bNoChange,TargetName);
                     }

                     _bstr_t                 TargetDomain = pVarSet->get(GET_WSTR(DCTVS_LocalServer_ChangeDomain));

                     if ( SUCCEEDED(hr) && !UStrICmp(TargetDomain,GET_STRING(IDS_YES)) )  // don't try to change domain if the rename failed!
                     {
                        // stop Net Logon service so that scavenger thread does not reset
                        // the default computer password before the computer is re-booted
                        // Note: this is only required for Windows NT 4.0 or earlier

                        bool bStopLogonService = false;

                        OSVERSIONINFO vi;
                        vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                        if (GetVersionEx(&vi))
                        {
                           if ((vi.dwPlatformId == VER_PLATFORM_WIN32_NT) && (vi.dwMajorVersion < 5))
                           {
                              bStopLogonService = true;
                           }
                        }

                        if (bStopLogonService)
                        {
                           StopNetLogonService();
                        }

                        // Change domain affiliation
                        TargetDomain = pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomain));

                        hr = ChangeDomainAffiliation(pVarSet,bNoChange,TargetDomain,TargetName,domain,username,password);

                        if (FAILED(hr))
                        {
                           if (bStopLogonService)
                           {
                              StartNetLogonService();
                           }
                        }
                     }

                     if ( SUCCEEDED(hr) )
                     {
                        TargetName = pVarSet->get(GET_WSTR(DCTVS_LocalServer_Reboot));

                        if ( !UStrICmp(TargetName,GET_STRING(IDS_YES)) )
                        {
                           LONG          rebootDelay = pVarSet->get(GET_WSTR(DCTVS_LocalServer_RebootDelay));
                        
                           delay = rebootDelay;
                           // Reboot
                           bNeedToReboot = TRUE;
                           // log the reboot delay, in minutes
                           err.MsgWrite(0,DCT_MSG_REBOOT_DELAY_D,rebootDelay / 60 );
                        }
                     }
                     else if ( TargetName.length() )
                     {
                        // since we could not change the domain affiliation we should go ahead and
                        // rename it back.
                        hr = RenameComputer(bNoChange, sSourceName);
                     }
                  }
                  catch ( ... )
                  {
                     err.LogOpen((WCHAR*)logFile,1);
                     err.DbgMsgWrite(ErrS,L"The Computer Rename/Change Domain operation threw an exception.");
                  }

               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 5");
            
               // Do postmigration task for any plug-ins
               try { 
                  DoPlugInTask(pVarSet,1);
               }
               catch ( ... )
               {
                  err.LogOpen((WCHAR*)logFile,1);
                  err.DbgMsgWrite(ErrS,L"A Plug-In task threw an exception.");
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 6");
               
            
               WCHAR            dbgFile[MAX_PATH];
            
               pVarSet->put(GET_WSTR(DCTVS_StatusObject),L"");
            
               
               long                     level = pVarSet->get(GET_WSTR(DCTVS_Results_ErrorLevel));
               if ( level < err.GetMaxSeverityLevel() )
               {
                  pVarSet->put(GET_WSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
               }
               
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 7");
               if ( DumpDebugInfo(dbgFile) )
               {
                  pVarSet->DumpToFile(dbgFile);
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 8");
             
               // Finished - write results file
               // first, establish a session to the console machine where we will try to write our results

               if (username.length() && server.length() && share.length())
               {
                  errTrace.DbgMsgWrite(0,L"Establishing session to %ls",(WCHAR*)server);

                  bSessEstablished = EstablishSession(server, domain, username, password, TRUE);

                  if (bSessEstablished)
                  {
                     err.MsgWrite(0, DCT_MSG_SESSION_ESTABLISHED_S, (WCHAR*)server);
                     errTrace.MsgWrite(0, DCT_MSG_SESSION_ESTABLISHED_S, (WCHAR*)server);
                  }
                  else
                  {
                     err.SysMsgWrite(ErrW, GetLastError(), DCT_MSG_SESSION_NOT_ESTABLISHED_SSSSD, (WCHAR*)server, (WCHAR*)share, (WCHAR*)domain, (WCHAR*)username, GetLastError());
                     errTrace.SysMsgWrite(ErrW, GetLastError(), DCT_MSG_SESSION_NOT_ESTABLISHED_SSSSD, (WCHAR*)server, (WCHAR*)share, (WCHAR*)domain, (WCHAR*)username, GetLastError());
                  }
               }

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 9");

               if ( outputfile.length() )
               {
                  IPersistStorage*       ps = NULL;
                  IStoragePtr            store = NULL;
                  
                  errTrace.DbgMsgWrite(0,L"Writing results file, filename =%ls",(WCHAR*)outputfile);

                  hr = pVarSet->QueryInterface(IID_IPersistStorage,(void**)&ps);  
                  if ( SUCCEEDED(hr) )
                  {   
                     for(int i=0; i < 5; ++i)
                     {
                        hr = StgCreateDocfile((WCHAR*)outputfile,STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE ,0,&store);
                        if(SUCCEEDED(hr)) break;
                        Sleep(5000);
                        errTrace.DbgMsgWrite(0,L"Retrying StgCreateDocfile... %d", (i + 1));
                     }

                     if ( SUCCEEDED(hr) )
                     {
                        hr = OleSave(ps,store,FALSE);  
                        if ( FAILED(hr))                 
                        {
                           err.SysMsgWrite(ErrE,hr,DCT_MSG_OLESAVE_FAILED_SD,(WCHAR*)outputfile,hr);   
                        }
                        else
                        {
                           err.MsgWrite(0,DCT_MSG_WROTE_RESULTS_S,(WCHAR*)outputfile);
                        }
                     }
                     else
                     {
                        err.SysMsgWrite(ErrE,hr,DCT_MSG_STG_CREATE_FAILED_SD,(WCHAR*)outputfile,hr);
                     }
                     ps->Release();
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_NO_IPERSIST_SD,(WCHAR*)outputfile,hr);
                  }
                  if ( FAILED(hr) )
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_RESULT_FILE_FAILED_S,(WCHAR*)outputfile);
                     pVarSet->DumpToFile(outputfile);
                  }
               }

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 10");

               // if session was established, unestablish

               if (bSessEstablished)
               {
                  errTrace.DbgMsgWrite(0,L"attempting to close the session");

                  if (!EstablishSession(server, domain, username, password, FALSE))
                  {
                     errTrace.DbgMsgWrite(0,L"session not closed");
                     err.SysMsgWrite(ErrW, GetLastError(), DCT_MSG_SESSION_NOT_ESTABLISHED_SSSSD, (WCHAR*)server, (WCHAR*)share, (WCHAR*)domain, (WCHAR*)username, GetLastError());
                  }
               }

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 11");
            
               pJob->SetEndTime(time(NULL));

               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 12");
            
               if ( bNeedToReboot )
               {
                  RebootTheComputer(bNoChange,delay);         
               }
               errTrace.DbgMsgWrite(0,L"Passed Checkpoint 15");
            }
            catch ( ... ) 
            {
               err.DbgMsgWrite(ErrS,L"An Exception occurred during processing.  The agent task has been aborted.");
               errTrace.DbgMsgWrite(ErrE,L"An Exception occurred in ExecuteDCTJob(Before CoUninitialize).  Aborting.");
            }

            // We're finished with the processing, now do some cleanup tasks
            // we want the things below to always happen, even if an exception occurred above.

            // set the job status to "Completed"
            try { 
               long                     level = pVarSet->get(GET_WSTR(DCTVS_Results_ErrorLevel));
               if ( level < err.GetMaxSeverityLevel() )
               {
                  pVarSet->put(GET_WSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
               }
               pJob->SetStatus(DCT_STATUS_COMPLETED);
            
               err.MsgWrite(0,DCT_MSG_EDA_FINISHED);
               err.LogClose();
            }
            catch (... )
            {
               err.DbgMsgWrite(ErrE,L"An exception occurred while setting job status to completed.");
            }

            // Release our pointer to the agent COM object
            try { 
               pJob->ReleaseUnknown();
            }
            catch (... )
            {
               err.DbgMsgWrite(ErrE,L"An exception occurred in pJob->ReleaseUnknown");
            }

            
         }
      }
   
   }
   catch ( ... ) 
   {
      err.DbgMsgWrite(ErrE,L"An Exception occurred.  Aborting.");
      errTrace.DbgMsgWrite(ErrE,L"An Exception occurred in ExecuteDCTJob.  Aborting.");
   }
   
   err.LogClose();

   errTrace.DbgMsgWrite(0,L"ExecuteDCTJob returning %ld",rc);
   
   CoUninitialize();
   
   return rc;

}

STDMETHODIMP 
   CDCTAgent::SubmitJob(
      IUnknown             * pWorkItemIn,  // in - varset containing information about job to do
      BSTR                 * pJobID        // out- GUID uniquely identifying this job
   )
{
   try {
   
   errTrace.DbgMsgWrite(0,L"Entered SubmitJob");
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVarSet = pWorkItemIn;
   GUID                      jobID;
   _bstr_t                   text;
   
   // SubmitJob is asynchronous, so launch a thread to do the job.
   
   // Create a GUID to identify the job
   hr = ::CoCreateGuid(&jobID);
   if ( SUCCEEDED(hr) )
   {
      WCHAR                * strJobID = NULL;
      StringFromCLSID(jobID,&strJobID);
      _bstr_t              bStrJobId = strJobID;

      errTrace.DbgMsgWrite(0,L"Created GUID for job '%ls'",(WCHAR*)strJobID);
      
      (*pJobID) = bStrJobId.copy();

      errTrace.DbgMsgWrite(0,L"Copied GUID to output variable");

      CoTaskMemFree(strJobID);
      

      IUnknown             * pUnk = NULL;

      errTrace.DbgMsgWrite(0,L"Calling QueryInterface");

      hr = QueryInterface(IID_IUnknown,(void**)&pUnk);

      errTrace.DbgMsgWrite(0,L"QueryInterface returned %lx",hr);
      
      if ( SUCCEEDED(hr) )
      {
         DCTAgentJob          * job = new DCTAgentJob(&jobID,pVarSet,pUnk);
         DWORD                  threadID = 0;
         HANDLE                 threadHandle;

         errTrace.DbgMsgWrite(0,L"Created job structure");
         pUnk->Release();
         threadHandle = CreateThread(NULL,0,&ExecuteDCTJob,job,CREATE_SUSPENDED,&threadID);

         if ( threadHandle != INVALID_HANDLE_VALUE )
         {
            job->SetThreadInfo(threadID,threadHandle);  
            m_JobList.Insert(job);
            errTrace.DbgMsgWrite(0,L"Inserted job into job list.");
#ifndef OFA
            SetThreadPriority(threadHandle,THREAD_PRIORITY_BELOW_NORMAL);
#endif
            ResumeThread(threadHandle);
            errTrace.DbgMsgWrite(0,L"Started job thread.");
            
         }
         else
         {
            DWORD            rc = GetLastError();

            errTrace.DbgMsgWrite(0,L"Failed to create thread for job.");
            hr = HRESULT_FROM_WIN32(rc);
         }
      }
      
   }
    
   }
   catch (...)
   {
      // TODO:  log an error message!
      errTrace.DbgMsgWrite(0,L"Exception!!");
   }
   
	return S_OK;
}

STDMETHODIMP 
   CDCTAgent::CancelJob(
      BSTR                   strJobID        // in - ID of job to cancel
   )
{
	// Find the job
   GUID                      jobID;
   HRESULT                   hr = S_OK;
   DCTAgentJob             * job = NULL;
   
   errTrace.DbgMsgWrite(0,L"Entered CancelJob");

   hr = CLSIDFromString(strJobID,&jobID);
   
   if ( SUCCEEDED(hr) )
   {
      errTrace.DbgMsgWrite(0,L"Job ID is %ls",(WCHAR*)strJobID);

      job = m_JobList.Find(jobID);
      if ( job )
      {
         errTrace.DbgMsgWrite(0,L"Found job, status = %ld", job->GetStatus() );
         if ( job->GetStatus() == DCT_STATUS_IN_PROGRESS )
         {
            job->SetStatus(DCT_STATUS_ABORTING);
         }
      }
   }
   errTrace.DbgMsgWrite(0,L"Leaving CancelJob");
   return hr;
}

// The varset returned from QueryJobStatus will contain the following information, assuming that the job exists.
// 
// The following VarSet keys will be copied from the varset that the migration job is using
// Job Status, Current Path, Current Operation, Stats (subtree)
STDMETHODIMP 
   CDCTAgent::QueryJobStatus(
      BSTR                   strJobID,     // in - job ID of job to query
      IUnknown            ** statusInfoOut // out- varset containing information about the job, if it is running
   )
{
	GUID                      jobID;
   HRESULT                   hr = S_OK;
   DCTAgentJob             * job = NULL;
   
   try { 
      errTrace.DbgMsgWrite(0,L"Entering QueryJobStatus");
   (*statusInfoOut) = NULL;
   
   hr = CLSIDFromString(strJobID,&jobID);
   
   if ( SUCCEEDED(hr) )
   {
      errTrace.DbgMsgWrite(0,L"Job id is %ls",(WCHAR*)strJobID);

      job = m_JobList.Find(jobID);
      if ( job )
      {
         errTrace.DbgMsgWrite(0,L"Found job, status=%ld",job->GetStatus());
         IVarSet * pVarSet = NULL;
         hr = CoCreateInstance(CLSID_VarSet,NULL,CLSCTX_SERVER ,IID_IVarSet,(void**)&pVarSet);
         errTrace.DbgMsgWrite(0,L"QueryJobStatus:  VarSet CreateInstance returned %lx",hr);
         if ( SUCCEEDED(hr) )
         {
            errTrace.DbgMsgWrite(0,L"VarSet created");
            _variant_t val;
            switch ( job->GetStatus() )
            {
            case DCT_STATUS_NOT_STARTED:
               val = GET_STRING(IDS_DCT_Status_NotStarted);
               break;
            case DCT_STATUS_IN_PROGRESS:
               val = GET_STRING(IDS_DCT_Status_InProgress);
               break;
            case DCT_STATUS_ABORTING:
               val = GET_STRING(IDS_DCT_Status_Aborting);
               break;
            case DCT_STATUS_ABORTED:
               val = GET_STRING(IDS_DCT_Status_Aborted);
               break;
            case DCT_STATUS_COMPLETED:
               val = GET_STRING(IDS_DCT_Status_Completed);
               break;
            default:
               val = GET_STRING(IDS_DCT_Status_Unknown);
               break;
            }
            pVarSet->put(GET_WSTR(DCTVS_JobStatus),val);
            pVarSet->put(GET_WSTR(DCTVS_CurrentPath),job->GetVarSet()->get(GET_WSTR(DCTVS_CurrentPath)));
            pVarSet->put(GET_WSTR(DCTVS_CurrentOperation),job->GetVarSet()->get(GET_WSTR(DCTVS_CurrentOperation)));

            errTrace.DbgMsgWrite(0,L"Added status info to varset");

            IVarSet        * pStats = NULL;
            HRESULT          hr2  = job->GetVarSet()->raw_getReference(GET_WSTR(DCTVS_Stats),&pStats);
            
            if ( SUCCEEDED(hr2) )
            {
               errTrace.DbgMsgWrite(0,L"Adding stats to varset");
               pVarSet->ImportSubTree(GET_WSTR(DCTVS_Stats),pStats);
               pStats->Release();
            }
            else
            {
               errTrace.DbgMsgWrite(0,L"There are not stats to add to the varset");
               pVarSet->put(GET_WSTR(DCTVS_Stats),GET_WSTR(IDS_DCT_NoStatsAvailable));
            }
            hr = pVarSet->QueryInterface(IID_IUnknown,(void**)statusInfoOut);
            pVarSet->Release();
         }
      }
      else
      {
         hr = DISP_E_UNKNOWNNAME;
      }
   }
   } 
   catch (... )
   {
      errTrace.DbgMsgWrite(0,L"An exception occurred in QueryJobStatus");
      //hr = E_FAIL;
   }
   errTrace.DbgMsgWrite(0,L"QueryJobStatus returning %lx",hr);
   return hr;
}

STDMETHODIMP 
   CDCTAgent::RetrieveJobResults(
      BSTR                   strJobID,     // in - guid of job 
      IUnknown            ** pWorkItemOut  // out- varset containing stats
   )
{
	HRESULT                   hr = S_OK;
	GUID                      jobID;
   DCTAgentJob             * job = NULL;
   
   errTrace.DbgMsgWrite(0,L"Entering RetrieveJobResults");
   // initialize output parameter
   (*pWorkItemOut) = NULL;
   
   hr = CLSIDFromString(strJobID,&jobID);
   
   if ( SUCCEEDED(hr) )
   {
      job = m_JobList.Find(jobID);
      if ( job )
      {
         IVarSet * pVarSet = NULL;
         hr = CoCreateInstance(CLSID_VarSet,NULL,CLSCTX_ALL,IID_IVarSet,(void**)&pVarSet);
         if ( SUCCEEDED(hr) )
         {
            pVarSet->ImportSubTree(L"",job->GetVarSet());
            hr = pVarSet->QueryInterface(IID_IUnknown,(void**)pWorkItemOut);
            pVarSet->Release();
         }
         job->ReleaseUnknown();
      }
   }

	errTrace.DbgMsgWrite(0,L"RetrieveJobResults, returning %lx",hr);
   return hr;
}

// VarSet output:
// Job.x - BSTR job guid
// Job.x.Status - BSTR status of job
// Job.x.StartTime - time_t Starting time of job
// Job.x.EndTime - time_t ending time of job (if finished)
STDMETHODIMP 
   CDCTAgent::GetJobList(
      IUnknown             ** pUnkOut      // out- varset containing list of jobs
   )
{
	HRESULT                   hr = S_OK;
   TNodeListEnum             e;
   DCTAgentJob             * pJob;
   WCHAR                     key[100];
   IVarSetPtr                pVarSet(CLSID_VarSet);
   _bstr_t                   val;
   int                       ndx;

   errTrace.DbgMsgWrite(0,L"Entering GetJobList");
   (*pUnkOut) = NULL;
   for ( pJob = (DCTAgentJob *)e.OpenFirst(&m_JobList) , ndx = 0; pJob ; pJob = (DCTAgentJob*)e.Next(), ndx++ )
   {
      swprintf(key,GET_STRING(IDS_DCTVSFmt_Job_D),ndx);
      GUID                   id = pJob->GetJobID();
      
      WCHAR                * strJobID = NULL;

      StringFromCLSID(id,&strJobID);
      pVarSet->put(key,strJobID);
      SysFreeString(strJobID);

      swprintf(key,GET_STRING(IDS_DCTVSFmt_JobStatus_D),ndx);
      switch ( pJob->GetStatus() )
      {
      case DCT_STATUS_NOT_STARTED:
         val = GET_STRING(IDS_DCT_Status_NotStarted);
         break;
      case DCT_STATUS_IN_PROGRESS:
         val = GET_STRING(IDS_DCT_Status_InProgress);
         break;
      case DCT_STATUS_ABORTING:
         val = GET_STRING(IDS_DCT_Status_Aborting);
         break;
      case DCT_STATUS_ABORTED:
         val = GET_STRING(IDS_DCT_Status_Aborted);
         break;
      case DCT_STATUS_COMPLETED:
         val = GET_STRING(IDS_DCT_Status_Completed);
         break;
      default:
         val = GET_STRING(IDS_DCT_Status_Unknown);
         break;
      }
      pVarSet->put(key,val);
      swprintf(key,GET_STRING(IDS_DCTVSFmt_Job_StartTime_D),ndx);
      pVarSet->put(key,(LONG)pJob->GetStartTime());
      swprintf(key,GET_STRING(IDS_DCTVSFmt_Job_EndTime_D),ndx);
      pVarSet->put(key,(LONG)pJob->GetEndTime());
      errTrace.DbgMsgWrite(0,L"Job %ls",(WCHAR*)key);
   }
   hr = pVarSet->QueryInterface(IID_IUnknown,(void**)pUnkOut);
      
   return hr;
   errTrace.DbgMsgWrite(0,L"RetrieveJobResults returning %lx",hr);
}

HRESULT
   DoPlugInTask(IVarSet * pVarSet,int task)
{
   HRESULT                   hr = S_OK;
   WCHAR                     key[300];
   CLSID                     clsid;
   long                      nPlugIns = 0;

   if ( task == 0 )
   {
      // create the COM object for each plug-in
      _bstr_t                   bStrGuid;
      for ( int i = 0 ; ; i++ )
      {
         swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_D),i);
         bStrGuid = pVarSet->get(key);
         errTrace.DbgMsgWrite(0,L"bStrGuid = %s", (BSTR)bStrGuid);
      
         if ( bStrGuid.length() == 0 )
            break;

         IMcsDomPlugIn        * pPlugIn = NULL;
      
         hr = CLSIDFromString(bStrGuid,&clsid);
         if ( SUCCEEDED(hr) )
         {
            hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
            if ( SUCCEEDED(hr) )
            {
               swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_D),nPlugIns);
               pVarSet->putObject(key,pPlugIn);
               nPlugIns++;
            }
			else
	           errTrace.DbgMsgWrite(0,L"CoCreateInstance failed for IMcsDomPlugIn: %x", hr);
         }
         else
            errTrace.DbgMsgWrite(0,L"CLSIDFromString failed: %x", hr);
      }
      pVarSet->put(GET_WSTR(DCTVS_PlugIn_Interface_Count),nPlugIns);
   }

   // Enumerate the plug-in interfaces
   IMcsDomPlugIn           * pPlugIn = NULL;
   
   nPlugIns = pVarSet->get(GET_WSTR(DCTVS_PlugIn_Interface_Count));

   for ( int i = 0 ; i < nPlugIns ; i++ )
   {
      swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_Interface_D),i);
      IUnknown * pUnk = pVarSet->get(key);
      hr = pUnk->QueryInterface(IID_IMcsDomPlugIn,(void**)&pPlugIn);
      if ( SUCCEEDED(hr) )
      {
         switch ( task )
         {
         case 0: // pre-migration
            hr = pPlugIn->PreMigrationTask(pVarSet);
            break;
         case 1: // post-migration
            hr = pPlugIn->PostMigrationTask(pVarSet);
            // release the interface and remove it from the varset
            pPlugIn->Release();
            pVarSet->put(key,L"");
            break;
         }
      }
      else
         errTrace.DbgMsgWrite(0,L"QueryInterface failed: %x", hr);

   }
   return S_OK;
}

// renames the local computer 
HRESULT 
   RenameComputer(
      BOOL                   bNoChange,    // in - flag, nochange mode
      BSTR                   targetName    // in - new name for computer
   )
{
   HRESULT                   hr = S_OK;
   IRenameComputerPtr        pRename;

   errTrace.DbgMsgWrite(0,L"Renaming local computer to %ls",(WCHAR*)targetName);
   hr = pRename.CreateInstance(CLSID_RenameComputer);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrS,hr,DCT_MSG_RENAME_COMPUTER_COM_FAILED_D,hr);
   }
   else
   {
      pRename->NoChange = bNoChange;
      hr = pRename->raw_RenameLocalComputer(targetName);
      if ( FAILED(hr) )
      {
         err.SysMsgWrite(ErrS,hr,DCT_MSG_RENAME_COMPUTER_FAILED_SD,(WCHAR*)targetName,hr);
      }
      else
      {
         err.MsgWrite(0,DCT_MSG_COMPUTER_RENAMED_S,(WCHAR*)targetName);
      }
   }
   errTrace.DbgMsgWrite(0,L"RenameComputer, returning %lx",hr);
   
   return hr;
}

// reboots the local computer
HRESULT 
   RebootTheComputer(
      BOOL                   bNoChange,    // in - flag, nochange mode
      LONG                   delay         // in - seconds to delay before rebooting
   )
{
   HRESULT                   hr = S_OK;
   IRebootComputerPtr        pReboot;

   errTrace.DbgMsgWrite(0,L"Rebooting local computer, delay = %ld",delay);
   // Create the Reboot computer object
   hr = pReboot.CreateInstance(CLSID_RebootComputer);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrS,hr,DCT_MSG_REBOOT_COM_FAILED_D,hr);
   }
   else
   {
      pReboot->NoChange = bNoChange;
      err.MsgWrite(0,DCT_MSG_REBOOTING);
      hr = pReboot->raw_Reboot(L"",delay);
      if ( FAILED(hr) )
      {
         err.SysMsgWrite(ErrS,HRESULT_CODE(hr),DCT_MSG_REBOOT_FAILED_D,hr);
      }
   }
   errTrace.DbgMsgWrite(0,L"RebootTheComputer, returning %lx",hr);
   return hr;   
}


// joins the local computer to the target domain 
// (assumes the computer account already exists)
HRESULT 
   ChangeDomainAffiliation(
      IVarSet              * pVarSet,      // in - varset
      BOOL                   bNoChange,    // in - flag, nochange mode
      BSTR                   targetDomain, // in - name of target domain
      BSTR                   targetName,   // in - new name of computer, if being renamed also
      BSTR                   credDomain,   // in - domain for credentials
      BSTR                   credAccount,  // in - account for credentials
      BSTR                   credPassword  // in - password for credentials
   )
{
   DWORD                     rc = 0;
   IChangeDomainPtr          pChange;
   BSTR                      errStatus = NULL;
   HRESULT                   hr;
   _bstr_t                   logfile = pVarSet->get(GET_WSTR(DCTVS_Options_Logfile));
   _bstr_t                   targetDomainSid = pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomainSid));
   _bstr_t                   srcPath = pVarSet->get(GET_WSTR(DCTVS_CopiedAccount_SourcePath));

   // retrieve preferred target domain controller to avoid replication latency

   _bstr_t                   targetServer = pVarSet->get(GET_WSTR(DCTVS_Options_TargetServer));

   if (targetServer.length() > 2)
   {
      LPCWSTR pszTargetServer = targetServer;

      if (pszTargetServer && (pszTargetServer[0] == L'\\') && (pszTargetServer[1] == L'\\'))
      {
         targetServer = _bstr_t(&pszTargetServer[2]);
      }
   }

   errTrace.DbgMsgWrite(0,L"Changing domain to %ls",(WCHAR*)targetDomain);
   hr = pChange.CreateInstance(CLSID_ChangeDomain);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrS,hr,DCT_MSG_CHANGE_DOMAIN_COM_FAILED_D,hr);

   }
   else
   {
      pChange->NoChange = bNoChange;

// Now that we use a dedicated ADMT user account for agent comm.  We cannot use those
// creds for domain changing since that account doesn't have admin rights on this agent machine
//      if ( UStrLen(credAccount) && UStrLen(credDomain) )
//      {
//         pChange->ConnectAs(credDomain,credAccount,credPassword);
//      }
      err.LogClose();
      hr = pChange->raw_ChangeToDomainWithSid(
         NULL,
         targetDomain,
         targetDomainSid,
         targetServer,
         targetName,
         srcPath,
         &errStatus
      );
      err.LogOpen(logfile,1);

      if ( SUCCEEDED(hr) )
      {
         // Update the membership of the Administrators group
         _bstr_t           src = pVarSet->get(GET_WSTR(DCTVS_Options_SourceDomainSid));
         _bstr_t           tgt = pVarSet->get(GET_WSTR(DCTVS_Options_TargetDomainSid));
         _bstr_t           sourceDomain = pVarSet->get(GET_WSTR(DCTVS_Options_SourceDomain));
         PSID              srcSid = SidFromString((WCHAR*)src);
         PSID              tgtSid = SidFromString((WCHAR*)tgt);
         PSID              localAdmins = GetWellKnownSid(1/*ADMINISTRATORS*/);
         UCHAR             srcCount;
         UCHAR             tgtCount;
         LPDWORD           pLastSub;
   
         if ( srcSid && tgtSid )
         {
            srcSid = DomainizeSid(srcSid,TRUE);
            tgtSid = DomainizeSid(tgtSid,TRUE);
            // Create the Domain Admin's SID from the Domain SID
            srcCount = *GetSidSubAuthorityCount(srcSid);
            tgtCount = *GetSidSubAuthorityCount(tgtSid);

            pLastSub = GetSidSubAuthority(srcSid,(DWORD)srcCount-1);
            *pLastSub = DOMAIN_GROUP_RID_ADMINS;

            pLastSub = GetSidSubAuthority(tgtSid,(DWORD)tgtCount-1);
            *pLastSub = DOMAIN_GROUP_RID_ADMINS;
            
            WCHAR            name[LEN_Account];
            WCHAR            domain[LEN_Domain];
            DWORD            lenName = DIM(name);
            DWORD            lenDomain = DIM(name);
            SID_NAME_USE     snu;
            
            
            // Get the name of the local administrators group
            if ( LookupAccountSid(NULL,localAdmins,name,&lenName,domain,&lenDomain,&snu) )
            {
               DWORD                   rc = 0;
               
               // add to the local administrator's group
               if ( ! bNoChange )
               {
                  rc = NetLocalGroupAddMember(NULL,name,tgtSid);
               }
               else 
               {
                  rc = 0;
               }
               
               if ( rc && rc != ERROR_MEMBER_IN_ALIAS )
               {
                  err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_ADD_DOMAIN_ADMINS_SSD,(WCHAR*)targetDomain,name,rc);
               }
               else
               {
                  if ( ! bNoChange )
                  {
                     // Only add if source != target
                     if ( UStrICmp((WCHAR*)sourceDomain,(WCHAR*)targetDomain) )
                     {
                        rc = NetLocalGroupDelMember(NULL,name,srcSid);
                     }
                  }
                  else
                  {
                     rc = 0;
                  }
                  if ( rc && rc != ERROR_MEMBER_NOT_IN_ALIAS )
                  {
                     err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_REMOVE_DOMAIN_ADMINS_SSD,(WCHAR*)sourceDomain,name,rc);
                  }
               }

            }
            else
            {
               rc = GetLastError();
               err.SysMsgWrite(ErrW,rc,DCT_MSG_CANNOT_FIND_ADMIN_ACCOUNT_D,rc);
            }

            // Add domain users to users
            pLastSub = GetSidSubAuthority(srcSid,(DWORD)srcCount-1);
            *pLastSub = DOMAIN_GROUP_RID_USERS;

            pLastSub = GetSidSubAuthority(tgtSid,(DWORD)tgtCount-1);
            *pLastSub = DOMAIN_GROUP_RID_USERS;
            
            
            lenName = DIM(name);
            lenDomain = DIM(domain);

            FreeSid(localAdmins);
            localAdmins = GetWellKnownSid(6/*USERS*/);

            // Get the name of the local users group
            if ( LookupAccountSid(NULL,localAdmins,name,&lenName,domain,&lenDomain,&snu) )
            {
               DWORD                   rc = 0;
               
               // add to the local user's group
               if ( ! bNoChange )
               {
                  rc = NetLocalGroupAddMember(NULL,name,tgtSid);
               }
               else 
               {
                  rc = 0;
               }
               
               if ( rc && rc != ERROR_MEMBER_IN_ALIAS )
               {
                  err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_ADD_DOMAIN_USERS_SSD,(WCHAR*)targetDomain,name,rc);
               }
               else
               {
                  if ( ! bNoChange )
                  {
                     // Only add if source != target
                     if ( UStrICmp((WCHAR*)sourceDomain,(WCHAR*)targetDomain) )
                     {
                        rc = NetLocalGroupDelMember(NULL,name,srcSid);
                     }
                  }
                  else
                  {
                     rc = 0;
                  }
                  if ( rc && rc != ERROR_MEMBER_NOT_IN_ALIAS )
                  {
                     err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_TO_REMOVE_DOMAIN_USERS_SSD,(WCHAR*)sourceDomain,name,rc);
                  }
               }

            }
            else
            {
               rc = GetLastError();
               err.SysMsgWrite(ErrW,rc,DCT_MSG_CANNOT_FIND_USERS_ACCOUNT_D,rc);
            }


         }              
         if ( hr == S_OK )
         {
            err.MsgWrite(0,DCT_MSG_DOMAIN_CHANGED_S,(WCHAR*)targetDomain);
         }
         else 
         {
            if ( errStatus && *errStatus )
            {
               err.MsgWrite(ErrS,DCT_MSG_CHANGE_DOMAIN_FAILED_S,(WCHAR*)errStatus);
               SysFreeString(errStatus);
            }
         }
      }
      else
      {
         err.SysMsgWrite(ErrS,HRESULT_CODE(hr),DCT_MSG_CHANGE_DOMAIN_FAILED_D,hr);
      }
   }
   errTrace.DbgMsgWrite(0,L"ChangeDomain, returning %lx",hr);
   return hr;
}


// StartNetLogonService Function

bool __stdcall StartNetLogonService()
{
	bool bSuccess = false;

	SC_HANDLE hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

	if (hManager)
	{
		SC_HANDLE hService = OpenService(hManager, _T("Netlogon"), SERVICE_START);

		if (hService)
		{
			if (StartService(hService, 0, NULL))
			{
				bSuccess = true;
			}
			else
			{
				if (GetLastError() == ERROR_SERVICE_ALREADY_RUNNING)
				{
					bSuccess = true;
				}
			}

			CloseServiceHandle(hService);
		}

		CloseServiceHandle(hManager);
	}

	return bSuccess;
}


// StopNetLogonService Function

bool __stdcall StopNetLogonService()
{
	bool bSuccess = false;

	SC_HANDLE hManager = OpenSCManager(NULL, SERVICES_ACTIVE_DATABASE, SC_MANAGER_ALL_ACCESS);

	if (hManager)
	{
		SC_HANDLE hService = OpenService(hManager, _T("Netlogon"), SERVICE_STOP);

		if (hService)
		{
			SERVICE_STATUS ss;

			if (ControlService(hService, SERVICE_CONTROL_STOP, &ss))
			{
				bSuccess = true;
			}
			else
			{
				switch (GetLastError())
				{
					case ERROR_SERVICE_NOT_ACTIVE:
					{
						bSuccess = true;
						break;
					}
					case ERROR_SERVICE_CANNOT_ACCEPT_CTRL:
					{
						if (ss.dwCurrentState == SERVICE_STOP_PENDING)
						{
							bSuccess = true;
						}
						break;
					}
				}
			}

			CloseServiceHandle(hService);
		}

		CloseServiceHandle(hManager);
	}

	return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Engine.rc
//
#define IDS_SERVICENAME                 100
#define IDR_EADCTAgent                  100
#define IDR_DCTAGENT                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\engine.cpp ===
/*---------------------------------------------------------------------------
  File: EADCTAgent.cpp

  Comments: Implementation of DCT Agent COM server, mostly generated by ATL.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f EADCTAgentps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <objidl.h>
//#include "McsEaDctAgent.h"
#include "Engine.h"

//#include "McsEaDctAgent_i.c"
#include "Engine_i.c"


#include <stdio.h>
#include "DCTAgent.h"
#include <objbase.h>
#include <MigrationMutex.h>

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DCTAgent, CDCTAgent)
END_OBJECT_MAP()


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// function prototypes for DCOM initialization functions we'll try to load dynamically

/*#ifndef OFA
// here are some definitions we need, but that are only defined when _WIN32_WINNT is 0x400 and up
typedef struct  tagSOLE_AUTHENTICATION_SERVICE
    {
    DWORD dwAuthnSvc;
    DWORD dwAuthzSvc;
    OLECHAR __RPC_FAR *pPrincipalName;
    HRESULT hr;
    }	SOLE_AUTHENTICATION_SERVICE;

typedef SOLE_AUTHENTICATION_SERVICE __RPC_FAR *PSOLE_AUTHENTICATION_SERVICE;
typedef 
enum tagEOLE_AUTHENTICATION_CAPABILITIES
    {	EOAC_NONE	= 0,
	EOAC_MUTUAL_AUTH	= 0x1,
	EOAC_CLOAKING	= 0x10,
	EOAC_SECURE_REFS	= 0x2,
	EOAC_ACCESS_CONTROL	= 0x4,
	EOAC_APPID	= 0x8
    }	EOLE_AUTHENTICATION_CAPABILITIES;



#endif*/
typedef HRESULT STDAPICALLTYPE  COINITIALIZEEX (LPVOID,DWORD);
typedef HRESULT STDAPICALLTYPE  COINITIALIZESECURITY (PSECURITY_DESCRIPTOR,LONG,SOLE_AUTHENTICATION_SERVICE *,
                        void*,DWORD,DWORD,void*,DWORD,void*);

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
	bool bCreated = false;
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    if (h != NULL)
	   bCreated = true;
    CloseHandle(h);
	return bCreated;
}

LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	ATLTRACE(_T("E {ADMTAgnt.exe}_tWinMain(hInstance=0x%08lX,...)\n"), hInstance);

	// obtain agent mutex
	// the migration driver uses this mutex to determine
	// if the agent process is currently running

	CMigrationMutex mutex(AGENT_MUTEX, true);

	// set debug flags to check memory allocations and leaks
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#ifdef OFA 
   #if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
       HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
   #else
       HRESULT hRes = CoInitialize(NULL);
   #endif

   #if _WIN32_WINNT >= 0x0400

       hRes = CoInitializeSecurity(
             NULL,                        //Points to security descriptor
               -1,                          //Count of entries in asAuthSvc
               NULL,                        //Array of names to register
               NULL,                        //Reserved for future use
               RPC_C_AUTHN_LEVEL_NONE,      //The default authentication
                                            //level for proxies
               RPC_C_IMP_LEVEL_IMPERSONATE, //The default impersonation
                                            //level for proxies
               NULL,                        //Reserved; must be set to NULL
               EOAC_NONE,                   //Additional client or
                                            //server-side capabilities
               NULL                         //Reserved for future use
               );


       // errTrace.DbgMsgWrite(0, L"CoInitSecurity returned %lx", hRes);
   #endif
#else
   // we need to be able to run on NT 3.51, so see if we can dynamically load CoInitializeEx and CoInitializeSecurity
   HRESULT           hRes  = S_OK;
   HMODULE           hLib = LoadLibrary(L"ole32.dll");
   BOOL              bInitialized = FALSE;
   if ( hLib )
   {
      COINITIALIZEEX       * pCoInitializeEx = (COINITIALIZEEX *)GetProcAddress(hLib,"CoInitializeEx");
      COINITIALIZESECURITY * pCoInitializeSecurity = (COINITIALIZESECURITY *)GetProcAddress(hLib,"CoInitializeSecurity");

      if ( pCoInitializeEx && pCoInitializeSecurity )
      {
         hRes = (*pCoInitializeEx)(NULL,0 /*COINIT_MULTITHREADED*/);     
         if ( SUCCEEDED(hRes) )
         {
            hRes = (*pCoInitializeSecurity)(
             NULL,                        //Points to security descriptor
               -1,                          //Count of entries in asAuthSvc
               NULL,                        //Array of names to register
               NULL,                        //Reserved for future use
               RPC_C_AUTHN_LEVEL_NONE,      //The default authentication
                                            //level for proxies
               RPC_C_IMP_LEVEL_IMPERSONATE, //The default impersonation
                                            //level for proxies
               NULL,                        //Reserved; must be set to NULL
               EOAC_NONE,                   //Additional client or
                                            //server-side capabilities
               NULL                         //Reserved for future use
               );
            bInitialized = TRUE;
         }

      }
      FreeLibrary(hLib);
   }

   if (! bInitialized )
   {
      hRes = CoInitialize(NULL);
   }
#endif


    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_MCSEADCTAGENTLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_EADCTAgent, FALSE);
            nRet = _Module.UnregisterServer(TRUE);            
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_EADCTAgent, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

	ATLTRACE(_T("L {ADMTAgnt.exe}_tWinMain(hInstance=0x%08lX,...)\n"), hInstance);
//	_CrtDbgBreak();
    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dctagent\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6F29585B_B641_11D2_A1DE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__6F29585B_B641_11D2_A1DE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#ifdef OFA
#define _WIN32_WINNT 0x0400
#else
#define _WIN32_WINNT 0x0351
#endif
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6F29585B_B641_11D2_A1DE_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\admtaccount.cpp ===
#include "StdAfx.h"
#include "AdmtAccount.h"

#include <LM.h>
#include <NtSecApi.h>
#include <ActiveDS.h>
#include <PWGen.hpp>
#include <AdsiHelpers.h>
#include <ResStr.h>

#pragma comment(lib, "NetApi32.lib")
#pragma comment(lib, "ActiveDS.lib")
#pragma comment(lib, "adsiid.lib")
//#pragma comment(lib, "ntdsapi.lib")

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)
#endif

using namespace _com_util;


namespace nsAdmtAccount
{

bool __stdcall IsComputerDomainController();
CADsContainer __stdcall GetAccountContainer(bool bLocal);
_bstr_t __stdcall GetAccountName();
_bstr_t __stdcall CreateAccountPassword();
CADsUser __stdcall GetAccount(bool bLocal, CADsContainer& adsContainer, _bstr_t strName);
CADsUser __stdcall CreateAccount(bool bLocal, CADsContainer& adsContainer, _bstr_t strName, _bstr_t strPassword);

_bstr_t __stdcall LoadPasswordFromPrivateData();
void __stdcall SavePasswordToPrivateData(LPCTSTR pszPassword);

inline _bstr_t __stdcall GetAccountPassword()
{
	return LoadPasswordFromPrivateData();
}

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
#ifdef _DEBUG
	if (pszFormat)
	{
		_TCHAR szMessage[2048];

		va_list args;
		va_start(args, pszFormat);

		_vsntprintf(szMessage, 2048, pszFormat, args);

		va_end(args);

		OutputDebugString(szMessage);
	}
#endif
}

}

using namespace nsAdmtAccount;


//---------------------------------------------------------------------------
// GetOptionsCredentials Method
//
// Retrieves the options credentials.
//---------------------------------------------------------------------------

HRESULT __stdcall GetOptionsCredentials(_bstr_t& strDomain, _bstr_t& strUserName, _bstr_t& strPassword)
{
	HRESULT hr = S_OK;

	try
	{
		// use local account if computer is not a domain controller
		bool bLocal = IsComputerDomainController() ? false : true;

		// get account container
		CADsContainer adsContainer = GetAccountContainer(bLocal);

		// get account name
		strUserName = GetAccountName();

		// get account password

		bool bNewPassword = false;

		strPassword = GetAccountPassword();

		if (!strPassword)
		{
			strPassword = CreateAccountPassword();
			bNewPassword = true;
		}

		// get account
		CADsUser adsUser = GetAccount(bLocal, adsContainer, strUserName);

		// if account exists...

		if (adsUser)
		{
			// if new password...
			// this may occur if administrator or system deletes
			// the private data key where the password is stored

			if (bNewPassword)
			{
				// set new password
				adsUser.SetPassword(strPassword);
			}
		}
		else
		{
			// create account
			CreateAccount(bLocal, adsContainer, strUserName, strPassword);
		}

		// get account domain (NetBIOS name)

		if (bLocal)
		{
			_TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
			DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH + 1;
			
			if (GetComputerName(szComputerName, &cbComputerName))
			{
				strDomain = szComputerName;
			}
			else
			{
				_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
			}
		}
		else
		{
			strDomain = CADsADSystemInfo().GetDomainShortName();
		}
	}
	catch (_com_error& ce)
	{
		hr = ce.Error();
	}
	catch (...)
	{
		hr = E_FAIL;
	}

	return hr;
}


namespace nsAdmtAccount
{


//---------------------------------------------------------------------------
// IsComputerDomainController Function
//
// Determines whether the local computer is a domain controller or not.
//---------------------------------------------------------------------------

bool __stdcall IsComputerDomainController()
{
	Trace(_T("E IsComputerDomainController()\n"));

	bool bIs = true;

	PSERVER_INFO_101 psiInfo = NULL;

	NET_API_STATUS nasStatus = NetServerGetInfo(NULL, 101, (LPBYTE*)&psiInfo);

	if (nasStatus == ERROR_SUCCESS)
	{
		// if either the domain controller or backup domain controller type
		// bit is set then the local computer is a domain controller

		if (psiInfo->sv101_type & (SV_TYPE_DOMAIN_CTRL|SV_TYPE_DOMAIN_BAKCTRL))
		{
			bIs = true;
		}
		else
		{
			bIs = false;
		}

		NetApiBufferFree(psiInfo);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(nasStatus));
	}

	Trace(_T("L IsComputerDomainController() : %s\n"), bIs ? _T("true") : _T("false"));

	return bIs;
}


//---------------------------------------------------------------------------
// GetAccountContainer Function
//
// Retrieves container interface either to local computer or the computer's
// domain Users container.
// The WinNT: provider is used for access to the local computer's local
// security authority.
// The LDAP: provider is used for access to the domain.
//---------------------------------------------------------------------------

CADsContainer __stdcall GetAccountContainer(bool bLocal)
{
	Trace(_T("E GetAccountContainer(bLocal=%s)\n"), bLocal ? _T("true") : _T("false"));

	CADsContainer adsContainer;

	// if creating a local account...

	if (bLocal)
	{
		// get container interface to computer

		_TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
		DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH + 1;
		
		if (GetComputerName(szComputerName, &cbComputerName))
		{
			// build path to local computer
			_bstr_t strPath = _bstr_t(_T("WinNT://")) + szComputerName + _bstr_t(_T(",computer"));

			// get container interface
			adsContainer = CADsContainer(LPCTSTR(strPath));
		}
		else
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		// retrieve default naming context for computer's domain

		CADs adsRootDSE(_T("LDAP://rootDSE"));
		_bstr_t strDefaultNamingContext = adsRootDSE.Get(_T("defaultNamingContext"));

		// build path to Users container in the domain

		CADsPathName adsPathName(_T("LDAP"), ADS_SETTYPE_PROVIDER);
		adsPathName.Set(strDefaultNamingContext, ADS_SETTYPE_DN);
		adsPathName.AddLeafElement(_T("CN=Users"));

		// get container interface
		adsContainer = CADsContainer(LPCTSTR(adsPathName.Retrieve(ADS_FORMAT_X500)));
	}

	Trace(_T("L GetAccountContainer() : %p\n"), adsContainer.operator IADsContainer*());

	return adsContainer;
}


//---------------------------------------------------------------------------
// GetAccountName Function
//
// Generates account name based on the local computer's name.
//---------------------------------------------------------------------------

_bstr_t __stdcall GetAccountName()
{
	Trace(_T("E GetAccountName()\n"));

	_bstr_t strName;

	_TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD cbComputerName = MAX_COMPUTERNAME_LENGTH + 1;
	
	if (GetComputerName(szComputerName, &cbComputerName))
	{
		strName = _T("ADMT_");
		strName += szComputerName;
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	Trace(_T("L GetAccountName() : '%s'\n"), LPCTSTR(strName));

	return strName;
}


//---------------------------------------------------------------------------
// CreateAccountPassword Function
//
// Creates complex password, stores it in the local security authority
// private data and returns the password.
//---------------------------------------------------------------------------

_bstr_t __stdcall CreateAccountPassword()
{
	Trace(_T("E CreateAccountPassword()\n"));

	// generate complex password

	WCHAR szPassword[32];
	EaPasswordGenerate(3, 3, 3, 3, 2, 12, szPassword, sizeof(szPassword) / sizeof(szPassword[0]));

	SavePasswordToPrivateData(szPassword);

	Trace(_T("L CreateAccountPassword() : '%s'\n"), szPassword);

	return szPassword;
}


//---------------------------------------------------------------------------
// GetAccount Function
//
// Gets local or domain user account in the specified container.
//---------------------------------------------------------------------------

CADsUser __stdcall GetAccount(bool bLocal, CADsContainer& adsContainer, _bstr_t strName)
{
	Trace(_T("E GetAccount(bLocal=%s, adsContainer=%p, strName='%s')\n"), bLocal ? _T("true") : _T("false"), adsContainer.operator IADsContainer*(), LPCTSTR(strName));

	IDispatchPtr spDispatch;

	try
	{
		spDispatch = adsContainer.GetObject(_T("user"), bLocal ? strName : _T("CN=") + strName);
	}
	catch (_com_error& ce)
	{
		switch (ce.Error())
		{
			case HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
			case HRESULT_FROM_WIN32(NERR_UserNotFound):
				break;
			default:
				throw;
				break;
		}
	}

	Trace(_T("L GetAccount() : %p\n"), spDispatch.GetInterfacePtr());

	return spDispatch;
}


//---------------------------------------------------------------------------
// CreateAccount Function
//
// Creates local or domain user account in the specified container.
// WinNT provider is used to create a local account whereas the LDAP provider
// is used to create a domain account.
//---------------------------------------------------------------------------

CADsUser __stdcall CreateAccount(bool bLocal, CADsContainer& adsContainer, _bstr_t strName, _bstr_t strPassword)
{
	Trace(_T("E CreateAccount(bLocal=%s, adsContainer=%p, strName='%s', strPassword='%s')\n"), bLocal ? _T("true") : _T("false"), adsContainer.operator IADsContainer*(), LPCTSTR(strName), LPCTSTR(strPassword));

	CADsUser adsUser;

	// the relative name must be prefixed only for LDAP provider
	adsUser = adsContainer.Create(_T("user"), bLocal ? strName : _T("CN=") + strName);

	// if not local account...

	if (bLocal == false)
	{
		// the SAM account name attribute is mandatory in active directory
		adsUser.Put(_T("sAMAccountName"), strName);
	}

	adsUser.SetDescription(GET_BSTR(IDS_ADMT_ACCOUNT_DESCRIPTION));

	// active directory account must exist first before password can be set
	// whereas local accounts may be created with the password attribute
	// this becomes important if password policies are in effect because
	// the WinNT provider will fail to create the account if the password
	// does not meet password policy
	// the LDAP provider creates the account disabled by default and therefore
	// the password does not need to meet password policy

	if (bLocal == false)
	{
		adsUser.SetInfo();
	}

	// the password can only be set after the user account is created
	adsUser.SetPassword(strPassword);

	// enable account after setting the account password
	// set password cannot be changed to remind the administrator not to change the password
	//  note that the administrator can still set the password even with this flag set
	// set do not expire password as we do not want the password to expire

	adsUser.Put(
		bLocal ? _T("UserFlags") : _T("userAccountControl"),
		long(ADS_UF_NORMAL_ACCOUNT|ADS_UF_PASSWD_CANT_CHANGE|ADS_UF_DONT_EXPIRE_PASSWD)
	);
	adsUser.SetInfo();

	Trace(_T("L CreateAccount() : %p\n"), adsUser.operator IADs*());

	return adsUser;
}


// LSA private data key name for password storage

const WCHAR c_wszKeyName[] = L"L$4480F273-39D1-4FFA-BEB4-44DF6C848364";
const USHORT c_usKeyNameLength = sizeof(c_wszKeyName) - sizeof(c_wszKeyName[0]);


//---------------------------------------------------------------------------
// SavePasswordToPrivateData Method
//
// Stores password in local security authority private data (LSA Secret).
//---------------------------------------------------------------------------

void __stdcall SavePasswordToPrivateData(LPCTSTR pszPassword)
{
	LSA_HANDLE hPolicy = NULL;
	LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

	NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_CREATE_SECRET, &hPolicy);

	if (ntsStatus == STATUS_SUCCESS)
	{
		USHORT usPasswordLength = pszPassword ? wcslen(pszPassword) * sizeof(WCHAR) : 0;

		LSA_UNICODE_STRING lusKeyName = { c_usKeyNameLength, c_usKeyNameLength, const_cast<PWSTR>(c_wszKeyName) };
		LSA_UNICODE_STRING lusPrivateData = { usPasswordLength, usPasswordLength, const_cast<PWSTR>(pszPassword) };

		ntsStatus = LsaStorePrivateData(hPolicy, &lusKeyName, &lusPrivateData);

		LsaClose(hPolicy);

		if (ntsStatus != ERROR_SUCCESS)
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
	}
}


//---------------------------------------------------------------------------
// LoadPasswordFromPrivateData Function
//
// Retrieves password from local security authority private data (LSA Secret).
//---------------------------------------------------------------------------

_bstr_t __stdcall LoadPasswordFromPrivateData()
{
	_bstr_t strPassword;

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open local security authority policy

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

		if (ntsStatus == STATUS_SUCCESS)
		{
			// retrieve password from private data

			LSA_UNICODE_STRING lusKeyName = { c_usKeyNameLength, c_usKeyNameLength, const_cast<PWSTR>(c_wszKeyName) };
			PLSA_UNICODE_STRING plusPrivateData;

			ntsStatus = LsaRetrievePrivateData(hPolicy, &lusKeyName, &plusPrivateData);

			if (ntsStatus == STATUS_SUCCESS)
			{
				DWORD dwLength = plusPrivateData->Length / sizeof(WCHAR);

				WCHAR szPassword[64];
				wcsncpy(szPassword, plusPrivateData->Buffer, dwLength);
				szPassword[dwLength] = L'\0';

				strPassword = szPassword;

				LsaFreeMemory(plusPrivateData);
			}
			else
			{
				DWORD dwError = LsaNtStatusToWinError(ntsStatus);

				if (dwError != ERROR_FILE_NOT_FOUND)
				{
					_com_issue_error(HRESULT_FROM_WIN32(dwError));
				}
			}

			// close local security authority policy

			LsaClose(hPolicy);
		}
		else
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}

	return strPassword;
}


} // namespace nsAdmtAccount
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\admtaccount.h ===
#pragma once

#include <ComDef.h>

HRESULT __stdcall GetOptionsCredentials(_bstr_t& strDomain, _bstr_t& strUserName, _bstr_t& strPassword);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\ddisp.h ===
/*---------------------------------------------------------------------------
  File: DCTDispatcher.h

  Comments: COM object that remotely installs and starts the EDA agent.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
	
// DCTDispatcher.h : Declaration of the CDCTDispatcher

#ifndef __DCTDISPATCHER_H_
#define __DCTDISPATCHER_H_

#include "resource.h"       // main symbols
#include <mtx.h>
#include <vector>
class TJobDispatcher;

//#import "\bin\McsVarSetMin.tlb" no_namespace , named_guids
#import "VarSet.tlb" no_namespace , named_guids rename("property", "aproperty")
/////////////////////////////////////////////////////////////////////////////
// CDCTDispatcher
class ATL_NO_VTABLE CDCTDispatcher : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDCTDispatcher, &CLSID_DCTDispatcher>,
   public IDispatchImpl<IDCTDispatcher, &IID_IDCTDispatcher, &LIBID_MCSDISPATCHERLib>
{
public:
	CDCTDispatcher()
	{
		m_pUnkMarshaler = NULL;
      m_hMutex = CreateMutex(0, 0, 0);
	}

   ~CDCTDispatcher() { ::CloseHandle(m_hMutex); }

DECLARE_REGISTRY_RESOURCEID(IDR_DCTDISPATCHER)
DECLARE_NOT_AGGREGATABLE(CDCTDispatcher)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDCTDispatcher)
   COM_INTERFACE_ENTRY(IDCTDispatcher)
   COM_INTERFACE_ENTRY(IDispatch)
   COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IDCTDispatcher
public:
	STDMETHOD(GetStartedAgentsInfo)(long* nNumStartedAgents, SAFEARRAY** ppbstrStartedAgents, SAFEARRAY** ppbstrJobid, SAFEARRAY** ppbstrFailedAgents, SAFEARRAY** ppbstrFailureDesc);
	STDMETHOD(AllAgentsStarted)(long* bAllAgentsStarted);
   STDMETHOD(DispatchToServers)(IUnknown ** ppWorkItem);
protected:
   std::vector<CComBSTR> m_startFailedVector;
   std::vector<CComBSTR> m_failureDescVector;
   std::vector<CComBSTR> m_startedVector;
   std::vector<CComBSTR> m_jobidVector;
   TJobDispatcher* m_pThreadPool;
   HANDLE m_hMutex;

   HRESULT BuildInputFile(IVarSet * pVarSet);
   HRESULT ShareResultDirectory(IVarSet * pVarSet);
   DWORD SetSharePermissions(WCHAR const * domain,WCHAR const * user,WCHAR const * share,WCHAR const * directory);
   void MergeServerList(IVarSet * pVarSet);
   
STDMETHOD(Process)(
      IUnknown             * pWorkItem,    // in - varset containing job information and list of servers  
      IUnknown            ** ppResponse,   // out- not used
      UINT                 * pDisposition  // out- not used  
   );
   
   };

#endif //__DCTDISPATCHER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\ckplugin.cpp ===
#include "stdafx.h"
#include "SecPI.h"
#include "cipher.hpp"
//#include "..\Common\Include\McsPI.h"
#include "McsPI.h"


BOOL IsValidPlugIn(IMcsDomPlugIn * pPlugIn)
{
   BOOL                      bGood = FALSE;
   ISecPlugIn              * pSec = NULL;
   HRESULT                   hr = S_OK;

   hr = pPlugIn->QueryInterface(IID_ISecPlugIn,(void**)&pSec);

   if ( SUCCEEDED(hr) )
   {
      McsChallenge           ch;
      
      LONG                   one, two;
      LONG                   time1;
      ULONG                  size = sizeof(ch);

      srand(GetTickCount());
      one = (LONG)rand();
      ch.lRand1 = one;
      two = (LONG)rand();
      ch.lRand2 = two;
      time1 = GetTickCount();
      ch.lTime = time1;
      
      SimpleCipher((LPBYTE)&ch,size);
      
      hr = pSec->Verify((ULONG*)&ch,size);
      if ( SUCCEEDED(hr) )
      {

         SimpleCipher((LPBYTE)&ch,size);
         // verify that the plug-in did the right thing!
         if (  ch.MCS[0] == 'M'
            && ch.MCS[1] == 'C'
            && ch.MCS[2] == 'S'
            && ch.MCS[3] == 0 
         )
         {
            if ( ch.lRand1 == (one + two)
               && ch.lRand2 == (two - one) )
            {
               if ( ch.lTime == time1+100 )
               {
                  bGood = TRUE;
               }
            }
         }

      }

      pSec->Release();
   }
   return bGood;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\ddisp.cpp ===
/*---------------------------------------------------------------------------
  File: DCTDispatcher.cpp

  Comments: Implementation of dispatcher COM object.  Remotely installs and
  launches the DCT Agent on remote computers.

  The CDCTDispatcher class implements the COM interface for the dispatcher.
  It takes a varset, containing a list of machines, and dispatches agents to 
  each specified machine.

  A job file (varset persisted to a file) is created for each agent, and 
  necessary initialization configuration (such as building an account mapping file for 
  security translation) is done.  The DCDTDispatcher class instantiates a 
  thread pool (CPooledDispatch), and uses the CDCTInstaller class to remotely
  install and start the agent service on each machine.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/// DCTDispatcher.cpp : Implementation of CDCTDispatcher
#include "stdafx.h"
#include "resource.h"
#include <locale.h>

//#include "..\Common\Include\McsDispatcher.h"
#include "Dispatch.h"
#include "DDisp.h"
#include "DInst.h"

#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "Cipher.hpp"
#include "TNode.hpp"

#include "TPool.h"     // Thread pool for dispatching jobs
#include "LSAUtils.h"

#include "TxtSid.h"
#include "sd.hpp"
#include "SecObj.hpp"
#include "BkupRstr.hpp"
#include "TReg.hpp"

#include "ResStr.h"

#include "TaskChk.h"
#include "CommaLog.hpp"
#include "TInst.h"

#include <lm.h>

#include "AdmtAccount.h"

/////////////////////////////////////////////////////////////////////////////
// CDCTDispatcher

//#import "\bin\McsEADCTAgent.tlb" named_guids
//#include "..\AgtSvc\AgSvc.h"
#import "Engine.tlb" named_guids
#include "AgSvc.h"
#include "AgSvc_c.c"
#include "AgRpcUtl.h"

//#import "\bin\McsDctWorkerObjects.tlb" 
//#include "..\Common\Include\McsPI.h"
#import "WorkObj.tlb" 
#include "McsPI.h"
#include "McsPI_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TErrorDct                    errLog; // used to write dispatch log that is read by the agent monitor
TErrorDct                    errTrace;
TCriticalSection             gCS;
BOOL                         gbCacheFileBuilt = FALSE;
// TServerNodes make up an internally used list of machines to install to
class TServerNode : public TNode
{
   WCHAR                     sourceName[LEN_Computer];
   WCHAR                     targetName[LEN_Computer];
   BOOL                      bTranslate;
   BOOL                      bChangeDomain;
   BOOL                      bReboot;
   DWORD                     dwRebootDelay;
public:
   TServerNode() { sourceName[0] = 0; targetName[0] = 0; bTranslate = FALSE; bChangeDomain = FALSE; bReboot= FALSE; dwRebootDelay = 0; }
   WCHAR             const * SourceName() { return sourceName; }
   WCHAR             const * TargetName() { return targetName; }
   BOOL                      Translate() { return bTranslate; }
   BOOL                      Reboot() { return bReboot; }
   BOOL                      ChangeDomain() { return bChangeDomain; }
   DWORD                     RebootDelay() { return dwRebootDelay; }

   void SourceName(WCHAR const * src) { safecopy(sourceName,src); }
   void TargetName(WCHAR const * tgt) { safecopy(targetName,tgt); }
   void Translate(BOOL v) { bTranslate = v; }
   void ChangeDomain(BOOL v) { bChangeDomain = v; }
   void Reboot(BOOL v) { bReboot = v; }
   void RebootDelay(DWORD d) { dwRebootDelay = d; }
};


extern 
   TErrorDct               err;

// defined in CkPlugIn.cpp
BOOL IsValidPlugIn(IMcsDomPlugIn * pPlugIn);


BOOL                                       // ret - TRUE if need to dump debug information
   DumpDebugInfo(
      WCHAR                * filename      // out - where to dump debug information 
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"DispatchVarSet",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   return bFound;
}

void 
   BuildPlugInFileList(
      TNodeList            * pList,        // i/o- list that files needed by plug-ins wil be added to
      IVarSet              * pVarSet       // in - varset containing list of plug-ins to query
   )
{
   // for now, build a list of all plug-ins, and add it to the varset
   MCSDCTWORKEROBJECTSLib::IPlugInInfoPtr            pPtr;
   SAFEARRAY               * pArray = NULL;
   HRESULT                   hr;
   LONG                      bound;
   LONG                      ndx[1];
   WCHAR                     key[LEN_Path];

   hr = pPtr.CreateInstance(__uuidof(MCSDCTWORKEROBJECTSLib::PlugInInfo));
   
   _bstr_t                   bStrGuid;
   
   swprintf(key,GET_STRING(IDS_DCTVS_Fmt_PlugIn_D),0);
   bStrGuid = pVarSet->get(key);
   
   if (! bStrGuid.length() )
   {
      // if no plug-ins are specified, use the ones in the plug-ins directory
      if ( SUCCEEDED(hr) )
      {
         hr = pPtr->raw_EnumeratePlugIns(&pArray);
      }
      if ( SUCCEEDED(hr) )
      {
         SafeArrayGetUBound(pArray,1,&bound);
         for ( ndx[0] = 0 ; ndx[0] <= bound ; ndx[0]++ )
         {
            BSTR           val = NULL;

            SafeArrayGetElement(pArray,ndx,&val);
            swprintf(key,GET_STRING(IDS_DCTVS_Fmt_PlugIn_D),ndx[0]);
            pVarSet->put(key,val);
            SysFreeString(val);
         }
         SafeArrayDestroy(pArray);
         pArray = NULL;
      }
   }
   // enumerate the plug-ins specified in the varset, and make a list of their needed files
   int                    nRegFiles = 0;

   for ( int i = 0 ; ; i++ )
   {
      swprintf(key,GET_STRING(IDS_DCTVS_Fmt_PlugIn_D),i);
      bStrGuid = pVarSet->get(key);
      
      if ( bStrGuid.length() == 0 )
         break;
      
	   IMcsDomPlugIn        * pPlugIn = NULL;
      SAFEARRAY            * pFileArray = NULL;
      TFileNode            * pNode;
      CLSID                  clsid;

      hr = CLSIDFromString(bStrGuid,&clsid);
      if ( SUCCEEDED(hr) )
      {
         hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
      }
      if ( SUCCEEDED(hr) )
      {
         if ( IsValidPlugIn(pPlugIn) )
         {
            hr = pPlugIn->GetRequiredFiles(&pFileArray);
            if ( SUCCEEDED(hr) )
            {
               SafeArrayGetUBound(pFileArray,1,&bound);
               for ( ndx[0] = 0 ; ndx[0] <= bound ; ndx[0]++ )
               {
                  BSTR           val = NULL;

                  SafeArrayGetElement(pFileArray,ndx,&val);
                  pNode = new TFileNode(val);
                  pList->InsertBottom(pNode);
                  SysFreeString(val);
               }
               SafeArrayDestroy(pFileArray);
               pFileArray = NULL;
            }
            hr = pPlugIn->GetRegisterableFiles(&pFileArray);
            if ( SUCCEEDED(hr) )
            {
               SafeArrayGetUBound(pFileArray,1,&bound);
               for (ndx[0] = 0; ndx[0] <= bound ; ndx[0]++ )
               {
                  BSTR          val = NULL;

                  SafeArrayGetElement(pFileArray,ndx,&val);
                  swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_RegisterFiles_D),nRegFiles);
                  pVarSet->put(key,val);
                  SysFreeString(val);
                  nRegFiles++;
               }
               SafeArrayDestroy(pFileArray);
               pFileArray = NULL;
            }
         }
         pPlugIn->Release();
      }
   }   
   
}

// InstallJobInfo defines a Domain Migration 'job' to be installed and launched
struct InstallJobInfo
{
   IVarSetPtr                pVarSetList; // varset defining the server list
   IVarSetPtr                pVarSet;     // VarSet defining the job to run
   _bstr_t                   serverName;  // computer to install and run on
   long                      ndx;         // index of this server in the server list
   TNodeList               * pPlugInFileList; // list of files to install for plug-ins
   std::vector<CComBSTR>*    pStartFailedVector;
   std::vector<CComBSTR>*    pFailureDescVector;
   std::vector<CComBSTR>*    pStartedVector;
   std::vector<CComBSTR>*    pJobidVector;
   HANDLE                    hMutex;
   _bstr_t                   jobfile;     // uses the specified job file instead of creating one 
   int                       nErrCount;

};

// WaitInfo is used to pass information to a thread that waits and does cleanup
// after all the Dispatcher's work is done
struct WaitInfo
{
   IUnknown                * pUnknown;          // IUnknown interface to the DCTDisptacher object
   TJobDispatcher          **ppPool;             // pointer to thread pool performing the tasks (installations)
   TNodeList               * pPlugInFileList;   // pointer to plug-in files list that will need to be freed
};     

WCHAR          gComputerName[LEN_Computer] = L"";  // name of local computer

// Calls DCTAgentService to start the Domain Migration Job on a remote computer
DWORD                                      // ret- OS return code
   StartJob(
      WCHAR          const * serverName,   // in - computer to start job on
      WCHAR          const * password,     // in - password for "Options.Credentials" account (used for writing results back to console machine)
      WCHAR          const * fullname,     // in - full path (including filename) to file containing the job's VarSet
      WCHAR          const * filename,      // in - filename of file containing the varset for the job
      _bstr_t&               strJobid
   )
{
   DWORD                     rc = 0;
   handle_t                  hBinding = NULL;
   WCHAR                   * sBinding = NULL;
   WCHAR                     jobGUID[LEN_Guid];
   WCHAR                     passwordW[LEN_Password];

   
   safecopy(passwordW,password);
   
   rc = EaxBindCreate(serverName,&hBinding,&sBinding,TRUE);
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_BIND_FAILED_SD, serverName,rc);
   }
   if( ! rc )
   {
      RpcTryExcept
      {
         // the job file has been copied to the remote computer 
         // during the installation
         rc = EaxcSubmitJob(hBinding,filename,passwordW,jobGUID);
         if ( ! rc )
         {
            err.MsgWrite(0,DCT_MSG_AGENT_JOB_STARTED_SSS,serverName,filename,jobGUID);
            strJobid = jobGUID;
         }
         else
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);
         }
      }
      RpcExcept(1)
      {
         rc = RpcExceptionCode();
         if ( rc != RPC_S_SERVER_UNAVAILABLE )
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);      
         }
      }
      RpcEndExcept
      if ( rc == RPC_S_SERVER_UNAVAILABLE )
      {
         // maybe the agent hasn't started up yet for some reason
         
         for ( int tries = 0 ; tries < 6 ; tries++ )
         {
            Sleep(5000); // wait a few seconds and try again
         
            RpcTryExcept
            {
               rc = EaxcSubmitJob(hBinding,filename,passwordW,jobGUID);
               if ( ! rc )
               {
                  err.MsgWrite(0,DCT_MSG_AGENT_JOB_STARTED_SSS,serverName,filename,jobGUID);
                  strJobid = jobGUID;
                  break;
               }
               else
               {
                  if ( tries == 5 )
                     err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);
               }
            }
            RpcExcept(1)
            {
               rc = RpcExceptionCode();
               if ( tries == 5 )
                  err.SysMsgWrite(ErrE,rc,DCT_MSG_AGENT_JOB_START_FAILED_SSD,serverName,filename,rc);      
            }
            RpcEndExcept
         }
      }
   }
   if ( ! rc )
   {
      // if the job was started successfully, remove the job file
      if ( ! MoveFileEx(fullname,NULL, MOVEFILE_DELAY_UNTIL_REBOOT) )
      {
//         DWORD               rc2 = GetLastError();
      }
   }
   // this indicates whether the server was started
   if ( ! rc )
   {
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld,%ls,%ls",serverName,L"Start",rc,filename,jobGUID);
   }
   else
   {
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",serverName,L"Start",rc);
   }
   return rc;
}


// Gets the domain sid for the specified domain
BOOL                                       // ret- TRUE if successful
   GetSidForDomain(
      LPWSTR                 DomainName,   // in - name of domain to get SID for
      PSID                 * pDomainSid    // out- SID for domain, free with FreeSid
   )
{
   PSID                      pSid = NULL;
//   DWORD                     lenSid = 200;
   DWORD                     rc = 0;
   WCHAR                   * domctrl = NULL;
   
   if ( DomainName[0] != L'\\' )
   {
      rc = NetGetDCName(NULL,DomainName,(LPBYTE*)&domctrl);
   }
   if ( ! rc )
   {
      rc = GetDomainSid(domctrl,&pSid);
      NetApiBufferFree(domctrl);
   }
   (*pDomainSid) = pSid;
   
   return ( pSid != NULL);
}

// Set parameters in the varset that are specific to this particular computer
void 
   SetupVarSetForJob(
      InstallJobInfo       * pInfo,        // structure defining job
      IVarSet              * pVarSet,      // varset describing job
      WCHAR          const * uncname,      // UNC path for results directory 
      WCHAR          const * filename      // UNC path for results file for this job
   )
{
   WCHAR                     uncresult[MAX_PATH];
   WCHAR                     serverName[MAX_PATH];
   WCHAR                     shareName[MAX_PATH];
   _bstr_t                   text;

  // Set server-specific parameters in the varset
   swprintf(uncresult,L"%s.result",filename);
   swprintf(serverName,L"\\\\%s",gComputerName);
   UStrCpy(shareName,uncname + UStrLen(serverName) );
   shareName[UStrLen(shareName)-1] = 0;
   
   pVarSet->put(GET_BSTR(DCTVS_Options_ResultFile),uncresult);
   pVarSet->put(GET_BSTR(DCTVS_Options_Credentials_Server),serverName);
   pVarSet->put(GET_BSTR(DCTVS_Options_Credentials_Share),shareName);
   pVarSet->put(GET_BSTR(DCTVS_Options_DeleteFileAfterLoad),GET_BSTR(IDS_YES));
   pVarSet->put(GET_BSTR(DCTVS_Options_RemoveAgentOnCompletion),GET_BSTR(IDS_YES));
   pVarSet->put(GET_BSTR(DCTVS_Options_LogToTemp),GET_BSTR(IDS_YES));
   pVarSet->put(GET_BSTR(DCTVS_Server_Index), CComVariant((long)pInfo->ndx));
   
   text = pVarSet->get(GET_BSTR(DCTVS_GatherInformation_UserRights));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      swprintf(uncresult,L"%s.userrights",filename);
      pVarSet->put(GET_BSTR(DCTVS_GatherInformation_UserRights),uncresult);
   }
   text = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferences));
   if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      swprintf(uncresult,L"%s.secrefs",filename);
      pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences),uncresult);
   }
   
   pVarSet->put(GET_BSTR(DCTVS_Options_LocalProcessingOnly),GET_BSTR(IDS_YES));
}

// Entry point for thread, waits until all agents are installed and started,
// then cleans up and exits
ULONG __stdcall                            // ret- returns 0 
   Wait(
      void                 * arg           // in - WaitInfo structure containing needed pointers
   )
{
   WaitInfo                * w = (WaitInfo*)arg;
   
   SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
   
   // wait for all jobs to finish
   (*(w->ppPool))->WaitForCompletion();

   if ( w->pUnknown )
      w->pUnknown->Release();

   // delete the plug-in file list
   TNodeListEnum             tEnum;
   TFileNode               * fNode;
   TFileNode               * fNext;
   
   for ( fNode = (TFileNode*)tEnum.OpenFirst(w->pPlugInFileList); fNode; fNode = fNext )
   {
      fNext = (TFileNode*)tEnum.Next();
      w->pPlugInFileList->Remove(fNode);
      delete fNode;
   }
   tEnum.Close();
   
   delete w->pPlugInFileList;

   delete *(w->ppPool);
   *(w->ppPool) = NULL;
   
   err.MsgWrite(0,DCT_MSG_DISPATCHER_DONE);
   errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",L"All",L"Finished",0);
   err.LogClose();
   errLog.LogClose();
   return 0;
}

// Thread entry point, installs and starts agent on a single computer
ULONG __stdcall                            // ret- HRESULT error code
   DoInstall(
      void                 * arg           // in - InstallJobInfo structure
   )
{
   SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
   
   HRESULT                     hr = S_OK;
   InstallJobInfo            * pInfo = (InstallJobInfo*)arg;
   _bstr_t                     strJobid;
   _bstr_t                     strFailureDesc(GET_STRING(IDS_START_FAILED));


   if(pInfo->nErrCount == 0)
      hr = CoInitializeEx(0,COINIT_MULTITHREADED );

#ifdef OFA
   
   HKEY hkeyLocal;
   LONG lRes;
   bool bVersionSupported = true;
   // Check version info
   lRes = RegConnectRegistry(
      pInfo->serverName,
                    // address of name of remote computer
      HKEY_LOCAL_MACHINE,        // predefined registry handle
      &hkeyLocal   // address of buffer for remote registry handle
   );

   if(lRes == ERROR_SUCCESS)
   {
      HKEY hkeyWin;
      lRes = ::RegOpenKey(hkeyLocal, GET_STRING(IDS_HKLM_WINDOWS_NT), &hkeyWin);
      if(lRes == ERROR_SUCCESS)
      {
         DWORD nMaxLen = 20;
         BSTR strVersion = SysAllocStringLen(0, nMaxLen), strSP = SysAllocStringLen(0, nMaxLen);
         strVersion[0] = L'\0'; strSP[0] = L'\0';
         DWORD type;
         DWORD nTemp = nMaxLen*2;
         lRes = RegQueryValueEx(hkeyWin, GET_STRING(IDS_CurrentVersion), 0, &type, (LPBYTE)strVersion, &nTemp);
         if(!lRes)
         {
            nTemp = nMaxLen*2;
            lRes = RegQueryValueEx(hkeyWin, GET_STRING(IDS_CSDVersion), 0, &type, (LPBYTE)strSP, &nTemp);
            lRes = 0;
         }

         if(!lRes)
         {
            // write out the version info
            err.MsgWrite(ErrI,DCT_MSG_AGENT_OSVERSION,(WCHAR*)pInfo->serverName,strVersion, strSP);
            TCHAR cSP = 0; 
            if(strVersion[0] == L'4' && wcslen(strSP)) 
               cSP = strSP[wcslen(strSP) - 1];
            if(strVersion[0] < L'4' || (strVersion[0] == L'4' &&
               cSP < L'3') )
               bVersionSupported = false;
         }

         ::RegCloseKey(hkeyWin);
         ::SysFreeString(strVersion); ::SysFreeString(strSP);
      }
      else
      {
         lRes = ::RegOpenKey(hkeyLocal, GET_STRING(IDS_HKLM_MICROSOFT), &hkeyWin);
         if(!lRes)
         {
            bVersionSupported = false;
            err.MsgWrite(ErrI, lRes, DCT_MSG_AGENT_OSVERSION_NOT_WINNT,(WCHAR*)pInfo->serverName);
         }
         ::RegCloseKey(hkeyWin);
      }
      ::RegCloseKey(hkeyLocal);
   }

   if(lRes)
      err.SysMsgWrite(ErrI, lRes, DCT_MSG_AGENT_OSVERSION_NOT_FOUND,(WCHAR*)pInfo->serverName, lRes);      
   else if(!bVersionSupported)
   {
      err.MsgWrite(ErrI,DCT_MSG_AGENT_OSVERSION_NOTSUPPORTED,(WCHAR*)pInfo->serverName);
      strFailureDesc = GET_STRING(IDS_UNSOUPPORTED_OS);
      hr = E_FAIL;
   }

#endif
   
   if ( SUCCEEDED(hr) )
   {
      IWorkNode              * pInstaller = NULL;
      IVarSetPtr               pVarSet(CLSID_VarSet);
      WCHAR                    filename[MAX_PATH];
      WCHAR                    tempdir[MAX_PATH];
      WCHAR                    key[MAX_PATH];

      if ( pVarSet == NULL )
      {
         if(pInfo->nErrCount == 0)
            CoUninitialize();
         return E_FAIL;
      }

      DWORD                    uniqueNumber = (LONG)pInfo->pVarSet->get(GET_BSTR(DCTVS_Options_UniqueNumberForResultsFile));
      _bstr_t                  bstrResultPath = pInfo->pVarSet->get(GET_BSTR(DCTVS_Dispatcher_ResultPath));
      _bstr_t                  bstrPassword = pInfo->pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Password));
           // Copy the common information from the source varset
      gCS.Enter();
      // pInfo->pVarSet contains all the information except the server list
      // we don't want to copy the server list each time, so we create our new varset from pInfo->pVarSet
      pVarSet->ImportSubTree("",pInfo->pVarSet);
      gCS.Leave();
      // Set the server-specific data in the varset
      swprintf(key,GET_BSTR(IDS_DCTVSFmt_Servers_RenameTo_D),pInfo->ndx);

      // pInfo->pVarSetList contains the entire varset including the server list
      _bstr_t             text = pInfo->pVarSetList->get(key);
      
      if ( text.length() )
      {
         pVarSet->put(GET_BSTR(DCTVS_LocalServer_RenameTo),text);
      }

      swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),pInfo->ndx);
      text = pInfo->pVarSetList->get(key);
      if ( text.length() )
      {
         pVarSet->put(GET_BSTR(DCTVS_LocalServer_ChangeDomain),text);
      }

      swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),pInfo->ndx);
      text = pInfo->pVarSetList->get(key);
      pVarSet->put(GET_BSTR(DCTVS_LocalServer_MigrateOnly),text);


      swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),pInfo->ndx);
      text = pInfo->pVarSetList->get(key);
      if ( text.length() )
      {
         pVarSet->put(GET_BSTR(DCTVS_LocalServer_Reboot),text);
         LONG delay;
         swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),pInfo->ndx);
         delay = pInfo->pVarSetList->get(key);
         if ( delay )
         {
            pVarSet->put(GET_BSTR(DCTVS_LocalServer_RebootDelay),delay);
         }
      }
      // remove the password from the varset, so that we are not writing it
      // to a file in plain text.  Instead, it will be passed to the agent service
      // when the job is submitted
      pVarSet->put(GET_BSTR(DCTVS_Options_Credentials_Password),"");
      pVarSet->put(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),"");

      if ( ! uniqueNumber )
      {
         uniqueNumber = GetTickCount();
      }
      
      MCSASSERT(bstrResultPath.length());
      
      safecopy(tempdir,(WCHAR*)bstrResultPath);
      
      pInstaller = new CComObject<CDCTInstaller>;
	  if (!pInstaller)
	     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      pInstaller->AddRef();
      ((CDCTInstaller*)pInstaller)->SetFileList(pInfo->pPlugInFileList);
      if ( SUCCEEDED(hr) )
      {
         swprintf(filename,L"%s%s%ld",tempdir,(WCHAR*)pInfo->serverName + 2,uniqueNumber);
        
         if ( !pInfo->jobfile.length() )
         {
            SetupVarSetForJob(pInfo,pVarSet,tempdir,filename);
         
            // Save the input varset to a file
            IPersistStoragePtr     ps = NULL;
            IStoragePtr            store = NULL;
   
            hr = pVarSet->QueryInterface(IID_IPersistStorage,(void**)&ps);  
            if ( SUCCEEDED(hr) )
            {                    
               hr = StgCreateDocfile(filename,STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE |STGM_FAILIFTHERE,0,&store);
               if ( SUCCEEDED(hr) )
               {
                  hr = OleSave(ps,store,FALSE);
               }
            }
         }
         else
         {
            safecopy(filename,(WCHAR*)pInfo->jobfile);
         }

         IUnknown        * pWorkItem = NULL;

         if ( SUCCEEDED(hr) )
         {
            pVarSet->put(GET_BSTR(DCTVS_ConfigurationFile),filename);
            pVarSet->put(GET_BSTR(DCTVS_InstallToServer),pInfo->serverName);

            hr = pVarSet->QueryInterface(IID_IUnknown,(void**)&pWorkItem);
         }
         if ( SUCCEEDED(hr) )
         {
            // Do the installation to the server
            hr = pInstaller->Process(pWorkItem);
            if(hr == 0x88070040)
               strFailureDesc = GET_STRING(IDS_AGENT_RUNNING);

            pWorkItem->Release();

            if ( SUCCEEDED(hr) )
            {
               err.MsgWrite(0,DCT_MSG_AGENT_INSTALLED_S,(WCHAR*)pInfo->serverName);
               // try to start the job
               DWORD rc = StartJob(pInfo->serverName,bstrPassword,filename,filename + UStrLen(tempdir), strJobid );
               if ( rc )
               {
                  hr = HRESULT_FROM_WIN32(rc);
                  // if we couldn't start the job, then try to stop the service
                  TDCTInstall               x( pInfo->serverName, NULL );
                  x.SetServiceInformation(GET_STRING(IDS_DISPLAY_NAME),GET_STRING(IDS_SERVICE_NAME),L"EXE",NULL);
                  DWORD                     rcOs = x.ScmOpen();
      
                  if ( ! rcOs )
                  {
                     x.ServiceStop();
                  }
               }
            }
         }
         pInstaller->Release();
      }
   }

   if(pInfo->nErrCount == 0)
      CoUninitialize();

   if ( hr )
   {
      if ( hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) )
      {
         err.MsgWrite(ErrE,DCT_MSG_AGENT_SERVICE_NOT_STARTED_SS,(WCHAR*)pInfo->serverName,(WCHAR*)pInfo->serverName);
      }
      else
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_AGENT_LAUNCH_FAILED_SD,(WCHAR*)pInfo->serverName,hr);
      }

      if(hr == 0x80070040 && pInfo->nErrCount < 10)
      {
         Sleep(1000);
         pInfo->nErrCount++;
         err.DbgMsgWrite(0,L"Retrying install...");
         DoInstall((LPVOID)pInfo);
      }
      else if (hr == CO_E_NOT_SUPPORTED)
      {
         err.MsgWrite(ErrI,DCT_MSG_AGENT_ALPHA_NOTSUPPORTED,(WCHAR*)pInfo->serverName);
         strFailureDesc = GET_STRING(IDS_UNSOUPPORTED_OS);
         ::WaitForSingleObject(pInfo->hMutex, 30000);
         pInfo->pStartFailedVector->push_back((BSTR)pInfo->serverName);
         pInfo->pFailureDescVector->push_back((BSTR)strFailureDesc);
         ::ReleaseMutex(pInfo->hMutex);
      }
      else
      {
         ::WaitForSingleObject(pInfo->hMutex, 30000);
         pInfo->pStartFailedVector->push_back((BSTR)pInfo->serverName);
         pInfo->pFailureDescVector->push_back((BSTR)strFailureDesc);
         ::ReleaseMutex(pInfo->hMutex);
      }
   }
   else
   {
//      DWORD res = ::WaitForSingleObject(pInfo->hMutex, 30000);
      ::WaitForSingleObject(pInfo->hMutex, 30000);
      pInfo->pStartedVector->push_back((BSTR)pInfo->serverName);
      _ASSERTE(strJobid != _bstr_t(L""));
      pInfo->pJobidVector->push_back((BSTR)strJobid);
      ::ReleaseMutex(pInfo->hMutex);
   }

   if(pInfo->nErrCount == 0)
      delete pInfo;
   return hr;
}

// DispatchToServers
// VarSet input:
// 
STDMETHODIMP                               // ret- HRESULT
   CDCTDispatcher::DispatchToServers(
      IUnknown            ** ppData        // i/o- pointer to varset
   )
{
   HRESULT                   hr;
   SetThreadLocale(LOCALE_SYSTEM_DEFAULT);
   
//Sleep(60000); //delay for debugging
   (*ppData)->AddRef();
   hr = Process(*ppData,NULL,NULL);
   return hr;
}

// Sets share level permissions
DWORD                                      // OS return code
   CDCTDispatcher::SetSharePermissions(
      WCHAR          const * domain,       // in - domain for user account
      WCHAR          const * user,         // in - user account to grant permissions to
      WCHAR          const * share,        // in - name of share
      WCHAR          const * directory     // in - path of shared directory
   )
{
   DWORD                     rc = 0;
   WCHAR                     domainname[LEN_Domain];
   WCHAR                   * server = NULL;
   WCHAR                     sharename[MAX_PATH];
   WCHAR                     dirname[MAX_PATH];
   BYTE                    * sid = (BYTE*)malloc(200);
   DWORD                     lenSid = 200;
   DWORD                     lenDomain = DIM(domainname);
   SID_NAME_USE              snu;
   BOOL                      bGotSid = FALSE;

   if (!sid)
      return ERROR_NOT_ENOUGH_MEMORY;

   safecopy(sharename,share);
   safecopy(dirname,directory);

   // Set the share permissions
   TShareSD                  sd(sharename);

   // Get a domain controller for domain
   if ( UStrICmp(domain,gComputerName) )
   {
      rc = NetGetDCName(NULL,domain,(LPBYTE*)&server);
   }
   if ( ! rc )
   {
      // get the SID for the user account
      if ( ! LookupAccountName(server,user,sid,&lenSid,domainname,&lenDomain,&snu) )
      {
         rc = GetLastError();
      }
      else
      {
         bGotSid = TRUE;
         if (! UStrICmp(domainname,domain) )
         {
            // we found the correct account
            // grant permissions to this user

            if ( sd.GetSecurity() != NULL )
            {
               TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,sid);
               PACL             acl = sd.GetSecurity()->GetDacl();
               
               sd.GetSecurity()->ACLAddAce(&acl,&ace,-1);
               sd.GetSecurity()->SetDacl(acl,TRUE);

               sd.WriteSD();
            }
         }
      }
      NetApiBufferFree(server);
   }
   if ( rc )
   {
      err.SysMsgWrite(ErrW,rc,DCT_MSG_CANNOT_FIND_ACCOUNT_SSD,domain,user,rc);
   }
   
   GetBkupRstrPriv();
   // Set NTFS permissions for the results directory
   TFileSD                *  fsd = new TFileSD(dirname);

   if (!fsd)
      return ERROR_NOT_ENOUGH_MEMORY;

   if ( bGotSid && fsd->GetSecurity() != NULL )
   {
      BYTE             inherit = OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
      TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,sid);
      TACE             ace2(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,sid);
      TACE             ace3(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,GetWellKnownSid(1/*ADMINISTRATORS*/));
      TACE             ace4(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,GetWellKnownSid(1/*ADMINISTRATORS*/));
      PACL             acl = NULL;
      
      ace2.SetFlags(inherit);
      ace4.SetFlags(inherit);

      fsd->GetSecurity()->ACLAddAce(&acl,&ace,0);
      fsd->GetSecurity()->ACLAddAce(&acl,&ace2,1);
      fsd->GetSecurity()->ACLAddAce(&acl,&ace3,2);
      fsd->GetSecurity()->ACLAddAce(&acl,&ace4,3);
      fsd->GetSecurity()->SetDacl(acl,TRUE);
      
      fsd->WriteSD();
   }
   
   return rc;
}


// DoesAccountHaveAccessToShare Function
//
// Checks if the specified account's SID is in the specified folder's DACL. This function only
// verifies the existence of the SID in the DACL.

bool DoesAccountHaveAccessToShare(LPCTSTR pszDomainName, LPCTSTR pszAccountName, LPCTSTR pszResultFolder)
{
	bool bAccess = false;

	try
	{
		// maximum SID size in bytes
		// Revision				 1
		// SubAuthorityCount	 1
		// IdentifierAuthority	 6
		// SubAuthority[15]		60
		// Total				68

		BYTE bytSid[128];
		PSID pSid = (PSID)bytSid;
		DWORD cbSid = sizeof(bytSid);

		_TCHAR szDomainName[128];
		DWORD cchDomainName = sizeof(szDomainName) / sizeof(szDomainName[0]);

		SID_NAME_USE snu;

		LookupAccountName(NULL, pszAccountName, pSid, &cbSid, szDomainName, &cchDomainName, &snu);

		// verify that the domains match

		if (_tcsicmp(szDomainName, pszDomainName) == 0)
		{
			// add backup/restore privilege to current process/thread token
			GetBkupRstrPriv();

			// search for SID in DACL of result folder

			TFileSD sdFile((const LPTSTR)(pszResultFolder));

			TSD* psd = sdFile.GetSecurity();

			if (psd && psd->IsDaclPresent())
			{
				int c = psd->GetNumDaclAces();

				for (int i = 0; i < c; i++)
				{
					TACE ace(psd->GetDaclAce(i));

					if (EqualSid(ace.GetSid(), pSid))
					{
						bAccess = true;
						break;
					}
				}
			}
		}
	}
	catch (...)
	{
		;
	}

	return bAccess;
}


// creates a share on the local machine for the results directory
// the name of the share is determined by RESULT_SHARE_NAME, and a number
//
// VarSet input:
// Dispatcher.ResultPath            - name of directory to share
// Options.Credentials.Domain       - domain for user account
// Options.Credentials.UserName     - user account to grant permissions to
//
HRESULT                                    // ret- HRESULT
   CDCTDispatcher::ShareResultDirectory(
      IVarSet              * pVarSet       // in - varset containing credentials
   )
{
   DWORD                     rc = 0;
   _bstr_t                   bstrResultDir = pVarSet->get(GET_BSTR(DCTVS_Dispatcher_ResultPath));
   _bstr_t                   bstrDomain = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Domain));
   _bstr_t                   bstrAccount = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_UserName));
   _bstr_t                   bstrShareName = pVarSet->get(_bstr_t((BSTR)L"Options.ShareName"));
   WCHAR                     resultPath[MAX_PATH];
   WCHAR                     uncResultPath[MAX_PATH];
   WCHAR                     shareName[MAX_PATH];
   
   if ( bstrResultDir.length() )
   {
      safecopy(resultPath,(WCHAR*)bstrResultDir);
   }
   else
   {
      GetTempPath(DIM(resultPath),resultPath);
   }
   // create a share for the results directory
   if ( bstrShareName.length() )
   {
      safecopy(shareName,(WCHAR*)bstrShareName);
   }
   else
   {
      swprintf(shareName,L"%s$",GET_STRING(IDS_RESULT_SHARE_NAME));
   }
   
   SHARE_INFO_2             shareInfo;

   memset(&shareInfo,0,(sizeof shareInfo));

   // remove the trailing backslash from the path
   if ( resultPath[UStrLen(resultPath)-1] == L'\\' )
      resultPath[UStrLen(resultPath)-1] = 0;

   shareInfo.shi2_netname = shareName;
   shareInfo.shi2_remark = GET_BSTR(IDS_RESULT_SHARE_REMARK);
   shareInfo.shi2_path = resultPath;
   shareInfo.shi2_max_uses = -1;
   shareInfo.shi2_type = STYPE_DISKTREE;
   
   swprintf(uncResultPath,L"\\\\%s\\%s\\",gComputerName,shareName);
   pVarSet->put(GET_BSTR(DCTVS_Dispatcher_ResultPath),uncResultPath);
      
   rc = NetShareAdd(NULL,2,(LPBYTE)&shareInfo,NULL);
   if ( ! rc )
   {
      // remove trailing backslash
      uncResultPath[UStrLen(uncResultPath)-1] = 0;
      // update the permissions for the share
      rc = SetSharePermissions((WCHAR*)bstrDomain,(WCHAR*)bstrAccount,uncResultPath,resultPath);
   }
   else if ( rc == NERR_DuplicateShare )
   {
      SHARE_INFO_2         * shInfo = NULL;
      DWORD                  parmErr;

      // make sure the share is pointing to the right directory
      rc = NetShareGetInfo(NULL,shareName,2,(LPBYTE*)&shInfo);
      if ( ! rc )
      {
         if ( UStrICmp(resultPath,shInfo->shi2_path) )
         {
            rc = NetShareDel(NULL, shareName, 0);
            if(!rc)
            {
               rc = NetShareAdd(NULL,2,(LPBYTE)&shareInfo,NULL);
               if ( ! rc )
               {
                                    // remove trailing backslash
                  uncResultPath[UStrLen(uncResultPath)-1] = 0;
                  // update the permissions for the share
                  rc = SetSharePermissions((WCHAR*)bstrDomain,(WCHAR*)bstrAccount,uncResultPath,resultPath);
               }
            }
            else
            {
               // the share points to the wrong place
               shInfo->shi2_netname = shareName; 
               rc = NetShareSetInfo(NULL,shareName,2,(LPBYTE)&shInfo,&parmErr);
            }
         }
		 else
		 {
			if (DoesAccountHaveAccessToShare(bstrDomain, bstrAccount, resultPath) == false)
			{
				uncResultPath[UStrLen(uncResultPath) - 1] = 0;

				SetSharePermissions(bstrDomain, bstrAccount, uncResultPath, resultPath);
			}
		 }
         NetApiBufferFree(shInfo);
         
      }
   }

   if ( ! rc )
   {
      err.MsgWrite(0,DCT_MSG_CREATED_RESULT_SHARE_SS,resultPath,uncResultPath);
      errLog.DbgMsgWrite(0,L"%ls : %ls",resultPath,uncResultPath);
   }
   return HRESULT_FROM_WIN32(rc);
}

// BuildInputFile constructs a cache file to be used for security translation
// VarSet input:
// Options.UniqueNumberForResultsFile  -unique number to append 
// Dispatcher.ResultPath               -directory to write file to
//
HRESULT                                    // ret- HRESULT
   CDCTDispatcher::BuildInputFile(
      IVarSet              * pVarSet       // in - varset containing data
   )
{
   IVarSetPtr                pVarSetST(CLSID_VarSet); // varset to use to run security translator
   IVarSetPtr                pVarSetTemp;       
   HRESULT                   hr = S_OK;
   _bstr_t                   key = GET_BSTR(DCTVS_Options);
   WCHAR                     tempdir[MAX_PATH];
   WCHAR                     resultPath[MAX_PATH];
   WCHAR                     logfile[MAX_PATH];
   
   DWORD                     uniqueNumber = (LONG)pVarSet->get(GET_BSTR(DCTVS_Options_UniqueNumberForResultsFile));
   _bstr_t                   bstrResultDir = pVarSet->get(GET_BSTR(DCTVS_Dispatcher_ResultPath));
   _bstr_t                   temp = pVarSet->get(GET_BSTR(DCTVS_Security_AlternateCacheFile));

   
   if ( pVarSetST == NULL )
   {
      return E_FAIL;
   }
  
   if ( ! NeedToUseST(pVarSet,TRUE) )
   {
      return S_OK;
   }
   // construct a filename for the cache
   if ( ! uniqueNumber )
   {
      uniqueNumber = GetTickCount();
   }
   
   if ( bstrResultDir.length() )
   {
      safecopy(tempdir,(WCHAR*)bstrResultDir);
   }
   else
   {
      // if no result path specified, use temp directory
      hr = GetTempPath(DIM(tempdir),tempdir);
   }
   swprintf(resultPath,L"%s%s",tempdir,GET_STRING(IDS_CACHE_FILE_NAME));

   // if a cache file is specified, use it instead of building a new one
   if ( temp.length() )
   {
      CopyFile(temp,resultPath,FALSE);
      pVarSet->put(GET_BSTR(DCTVS_Accounts_InputFile),GET_BSTR(IDS_CACHE_FILE_NAME));
      pVarSet->put(GET_BSTR(DCTVS_Accounts_WildcardSpec),"");
      gbCacheFileBuilt = TRUE;
      return S_OK;
   }

   // copy 'Options' settings to ST varset
   hr = pVarSet->raw_getReference(key,&pVarSetTemp);
   if ( SUCCEEDED(hr) )
   {
      pVarSetST->ImportSubTree(key,pVarSetTemp);
   }

   // copy 'Accounts' settings to ST varset
   key = GET_BSTR(DCTVS_Accounts);
   hr = pVarSet->raw_getReference(key,&pVarSetTemp);
   if ( SUCCEEDED(hr) )
   {
      pVarSetST->ImportSubTree(key,pVarSetTemp);
   }

   pVarSetST->put(GET_BSTR(DCTVS_Security_TranslationMode),GET_BSTR(IDS_Replace));
   pVarSetST->put(GET_BSTR(DCTVS_Options_NoChange),GET_BSTR(IDS_YES));
   
   pVarSetST->put(GET_BSTR(DCTVS_Options_LogLevel),(LONG)0);
   pVarSetST->put(GET_BSTR(DCTVS_Security_BuildCacheFile),resultPath);

   // change the log file - the building of the cache file happens behind the scenes
   // so we won't put it in the regular log file because it would cause confusion
   swprintf(logfile,L"%s%s",tempdir,L"BuildCacheFileLog.txt");
   pVarSetST->put(GET_BSTR(DCTVS_Options_Logfile),logfile);

      //are we using a sID mapping file to perform security translation
   pVarSetST->put(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT),
	              pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT)));
   pVarSetST->put(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile),
	              pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile)));

   MCSEADCTAGENTLib::IDCTAgentPtr              pAgent(MCSEADCTAGENTLib::CLSID_DCTAgent);

   try {
      if ( pAgent == NULL )
         return E_FAIL;

      _bstr_t                   jobID;
      BSTR                      b = NULL;
      hr = pAgent->raw_SubmitJob(pVarSetST,&b);
      if ( SUCCEEDED(hr) )
      {
         jobID = b;
      
         IVarSetPtr                pVarSetStatus;     // used to retrieve status of running job
         _bstr_t                   jobStatus;
         IUnknown                * pUnk;

         // loop until the agent is finished
         do {
   
            Sleep(1000);

            hr = pAgent->QueryJobStatus(jobID,&pUnk);
            if ( SUCCEEDED(hr) )
            {
               pVarSetStatus = pUnk;
               jobStatus = pVarSetStatus->get(GET_BSTR(DCTVS_JobStatus));      
               pUnk->Release();
            }
            else
            {
               break;
            }
         } while ( UStrICmp(jobStatus,GET_STRING(IDS_DCT_Status_Completed)) );
      }
   }
   catch(...)
   {
      hr = E_FAIL;
   }
   if ( SUCCEEDED(hr) )
   {
      pVarSet->put(GET_BSTR(DCTVS_Accounts_InputFile),GET_BSTR(IDS_CACHE_FILE_NAME));
      pVarSet->put(GET_BSTR(DCTVS_Accounts_WildcardSpec),"");
      err.MsgWrite(0,DCT_MSG_CACHE_FILE_BUILT_S,(WCHAR*)GET_STRING(IDS_CACHE_FILE_NAME));
      gbCacheFileBuilt = TRUE;
   }
   return hr;
}

// These are TNodeListSortable sorting functions

int ServerNodeCompare(TNode const * t1,TNode const * t2)
{
   TServerNode             * n1 = (TServerNode *)t1;
   TServerNode             * n2 = (TServerNode *)t2;

   return UStrICmp(n1->SourceName(),n2->SourceName());
}

int ServerValueCompare(TNode const * t1, void const * val)
{
   TServerNode             * n1 = (TServerNode *)t1;
   WCHAR             const * name = (WCHAR const *) val;

   return UStrICmp(n1->SourceName(),name); 
}

// MergeServerList combines the security translation server list in Servers.* with the computer migration
// server list in MigrateServers.* 
// The combined list is stored in the varset under Servers.* with subkeys specifying which actions to take for 
// each computer
void 
   CDCTDispatcher::MergeServerList(
      IVarSet              * pVarSet       // in - varset containing list of servers to migrate and translate on
   )
{
	int                       ndx = 0;
	WCHAR                     key[1000];
	_bstr_t                   text;
	int						  lastndx = -1;
	long					  totalsrvs;

		//get the number of servers in the varset
	totalsrvs = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
 
	// if there are computers being migrated
	if (totalsrvs > 0)
	{
		//add code to move varset server entries, with SkipDispatch set, to the bottom
		//of the server list and decrease the number of server items by each server
		//to be skipped
		//check each server in the list moving all to be skipped to the end of the list and
		//decreasing the server count for each to be skipped
	   for (ndx = 0; ndx < totalsrvs; ndx++)
	   {
		  swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),ndx);
		  text = pVarSet->get(key);
			//if the server is not to be skipped, we may have to move it above
			//a server that is being skipped
		  if (!UStrICmp(text,GET_STRING(IDS_No)))
		  {
				//if the last server looked at is not being skipped then we don't
				//need to swap any servers in the list and we can increment the
				//last server not being skipped
			  if (lastndx == (ndx - 1))
			  {
				  lastndx = ndx;
			  }
			  else //else swap servers in the varset so skipped server comes after
			  {    //the one not being skipped
				 _bstr_t  tempName, tempNewName, tempChngDom, tempReboot, tempMigOnly;
				 long tempRebootDelay;
				 _bstr_t  skipName, skipNewName, skipChngDom, skipReboot, skipMigOnly;
				 long skipRebootDelay;
				 lastndx++; //move to the skipped server that we will swap with

					//copy skipped server's values to temp
				 swprintf(key,GET_STRING(DCTVSFmt_Servers_D),lastndx);
				 skipName = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),lastndx);
				 skipNewName = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),lastndx);
				 skipChngDom = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),lastndx);
				 skipReboot = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),lastndx);
				 skipMigOnly = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),lastndx);
				 skipRebootDelay = pVarSet->get(key);
				 
					//copy current, non-skipped, server valuesto second temp
				 swprintf(key,GET_STRING(DCTVSFmt_Servers_D),ndx);
				 tempName = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),ndx);
				 tempNewName = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),ndx);
				 tempChngDom = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),ndx);
				 tempReboot = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),ndx);
				 tempMigOnly = pVarSet->get(key); 
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),ndx);
				 tempRebootDelay = pVarSet->get(key);

					//place current server's values in place of values for the one
					//being skipped
				 swprintf(key,GET_STRING(DCTVSFmt_Servers_D),lastndx);
				 pVarSet->put(key,tempName);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),lastndx);
				 pVarSet->put(key,tempNewName);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),lastndx);
				 pVarSet->put(key,tempChngDom);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),lastndx);
				 pVarSet->put(key,tempReboot);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),lastndx);
				 pVarSet->put(key,tempMigOnly);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),lastndx);
				 pVarSet->put(key,tempRebootDelay);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),lastndx);
				 pVarSet->put(key,GET_BSTR(IDS_No));

					//place skipped server's values in place of values for current server
				 swprintf(key,GET_STRING(DCTVSFmt_Servers_D),ndx);
				 pVarSet->put(key,skipName);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),ndx);
				 pVarSet->put(key,skipNewName);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),ndx);
				 pVarSet->put(key,skipChngDom);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),ndx);
				 pVarSet->put(key,skipReboot);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),ndx);
				 pVarSet->put(key,skipMigOnly);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RebootDelay_D),ndx);
				 pVarSet->put(key,skipRebootDelay);
				 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),ndx);
				 pVarSet->put(key,GET_BSTR(IDS_YES));
			  }//end else need to swap with skipped server
		  }//end if not skipping dispatch for this server
	   }//end for each server in the server list
		//exclude servers to be skipped for dispatch from being included in the server count
	   pVarSet->put(GET_BSTR(DCTVS_Servers_NumItems),(long)++lastndx);
   }
}


STDMETHODIMP                               // ret- HRESULT
   CDCTDispatcher::Process(
      IUnknown             * pWorkItem,    // in - varset containing job information and list of servers  
      IUnknown            ** ppResponse,   // out- not used
      UINT                 * pDisposition  // out- not used  
   )
{
	// initialize output parameters
   if ( ppResponse )
   {
      (*ppResponse) = NULL;
   }

   HRESULT                   hr = S_OK;
   IVarSetPtr                pVarSetIn = pWorkItem;
   LONG                      nThreads;
   WCHAR                     key[100];
   _bstr_t                   serverName;
   LONG                      nServers = 0;
   _bstr_t                   log;
   _bstr_t                   useTempCredentials;
   BOOL                      bFatalError = FALSE;
   _bstr_t                   text;
   WCHAR                     debugLog[MAX_PATH];
   long                      bAppend = 0;
   _bstr_t                   skip;
   _bstr_t					 sWizard, text2;
   BOOL						 bSkipSourceSid;
						

   if ( DumpDebugInfo(debugLog) )
   {
      if ( pVarSetIn != NULL )
      {
		  // temporarily remove the password fromthe varset, so that we don't write it to the file
         _bstr_t password = pVarSetIn->get(GET_BSTR(DCTVS_Options_Credentials_Password));
         pVarSetIn->put(GET_BSTR(DCTVS_Options_Credentials_Password),L"");
         pVarSetIn->DumpToFile(debugLog);
         pVarSetIn->put(GET_BSTR(DCTVS_Options_Credentials_Password),password);
         
      }
   }
	 //get the wizard being run
   sWizard = pVarSetIn->get(GET_BSTR(DCTVS_Options_Wizard)); 
   text2 = pVarSetIn->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
   if ((!UStrICmp(sWizard, L"security")) && (!UStrICmp(text2,GET_STRING(IDS_YES))))
	   bSkipSourceSid = TRUE;
   else
	   bSkipSourceSid = FALSE;

   nThreads = pVarSetIn->get(GET_BSTR(DCTVS_Options_MaxThreads));

   log = pVarSetIn->get(GET_BSTR(DCTVS_Options_DispatchCSV));
   errLog.LogOpen((WCHAR*)log,0);
   
   text = pVarSetIn->get(GET_BSTR(DCTVS_Options_AppendToLogs));
   if (! UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      bAppend = 1;
   }
   log = pVarSetIn->get(GET_BSTR(DCTVS_Options_DispatchLog));
   err.LogOpen((WCHAR*)log,bAppend);

   errLog.DbgMsgWrite(0,L"%ls",(WCHAR*)log);
   // default to 20 threads if the client doesn't specify
   if ( ! nThreads )
   {
      nThreads = 20;
   }

   // set credentials used to access share

   _bstr_t strAdmtAccountDomain;
   _bstr_t strAdmtAccountUserName;
   _bstr_t strAdmtAccountPassword;

   hr = GetOptionsCredentials(strAdmtAccountDomain, strAdmtAccountUserName, strAdmtAccountPassword);

   pVarSetIn->put(GET_BSTR(DCTVS_Options_Credentials_Domain), _variant_t(strAdmtAccountDomain));
   pVarSetIn->put(GET_BSTR(DCTVS_Options_Credentials_UserName), _variant_t(strAdmtAccountUserName));
   pVarSetIn->put(GET_BSTR(DCTVS_Options_Credentials_Password), _variant_t(strAdmtAccountPassword));

   if (FAILED(hr))
   {
      err.SysMsgWrite(ErrE, HRESULT_CODE(hr), DCT_MSG_COULDNT_GET_OPTIONS_CREDENTIALS);
   }

   // Get the name of the local computer
   DWORD                     dim = DIM(gComputerName);
      
   GetComputerName(gComputerName,&dim);
   
   m_pThreadPool = new TJobDispatcher(nThreads);
   if (!m_pThreadPool)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   hr = ShareResultDirectory(pVarSetIn);
   
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_RESULT_SHARE_CREATION_FAILED);
      bFatalError = TRUE;
   }
   
   // Build an input file for the ST cache, to send to each server
   hr = BuildInputFile(pVarSetIn);
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_CACHE_CONSTRUCTION_FAILED);
      bFatalError = TRUE;   
   }
   
   // Split out the remotable tasks for each server
   // Get the sids for the source and target domains
   PSID                      pSidSrc = NULL;
   PSID                      pSidTgt = NULL;

   _bstr_t                   source = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t                   target = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomain));

      //if security translation, retrieve source sid and convert so
	  //that it can be convert back below
   if (bSkipSourceSid)
   {
      _bstr_t sSid = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomainSid));
	  pSidSrc = SidFromString((WCHAR*)sSid);
   }
   else  //else get the sid now
      GetSidForDomain((WCHAR*)source,&pSidSrc);
   GetSidForDomain((WCHAR*)target,&pSidTgt);

   if ( pSidSrc && pSidTgt )
   {
      WCHAR            txtSid[200];
      DWORD            lenTxt = DIM(txtSid);

      if ( GetTextualSid(pSidSrc,txtSid,&lenTxt) )
      {
         pVarSetIn->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
      }
      lenTxt = DIM(txtSid);
      if ( GetTextualSid(pSidTgt,txtSid,&lenTxt) )
      {
         pVarSetIn->put(GET_BSTR(DCTVS_Options_TargetDomainSid),txtSid);
      }
      FreeSid(pSidSrc);
      FreeSid(pSidTgt);
   }
/* if ( pSidSrc )
   {
      WCHAR            txtSid[200];
      DWORD            lenTxt = DIM(txtSid);

      if ( GetTextualSid(pSidSrc,txtSid,&lenTxt) )
      {
         pVarSetIn->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
      }
   }
   if ( pSidTgt )
   {
      WCHAR            txtSid[200];
      DWORD            lenTxt = DIM(txtSid);

      if ( GetTextualSid(pSidTgt,txtSid,&lenTxt) )
      {
         pVarSetIn->put(GET_BSTR(DCTVS_Options_TargetDomainSid),txtSid);
      }
   }
*/ else
//   if (!((pSidSrc) && (pSidTgt)))
   {
//      if ((source.length()) && (!pSidSrc) && (!bSkipSourceSid))
      if ( source.length() && ! pSidSrc )
      {
         err.MsgWrite(ErrE,DCT_MSG_DOMAIN_SID_NOT_FOUND_S,(WCHAR*)source);
         bFatalError = TRUE;
      }
      else if ( target.length() && ! pSidTgt )
      {
         err.MsgWrite(ErrE,DCT_MSG_DOMAIN_SID_NOT_FOUND_S,(WCHAR*)target);
         bFatalError = TRUE;
      }
   }
   MergeServerList(pVarSetIn);

   LONG                      nServerCount = pVarSetIn->get(GET_BSTR(DCTVS_Servers_NumItems));
   
   if ( nServerCount && ! bFatalError )
   {
      err.MsgWrite(0,DCT_MSG_DISPATCH_SERVER_COUNT_D,nServerCount);
   }
   errLog.DbgMsgWrite(0,L"%ld",nServerCount);

   TNodeList               * fileList = new TNodeList;
   if (!fileList)
   {
	  delete m_pThreadPool;
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   // Build list of files to install for plug-ins (if any)
   BuildPlugInFileList(fileList,pVarSetIn);

   // Make a copy of the varset with the server lists removed,
   // so we don't have to copy the entire server list for each agent
   gCS.Enter();
   IVarSet                 * pTemp = NULL;
   IVarSetPtr                pVarSetTemp(CLSID_VarSet);

   hr = pVarSetTemp->ImportSubTree(_bstr_t(L""),pVarSetIn);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetTemp->raw_getReference(SysAllocString(L"MigrateServers"),&pTemp);
      if ( SUCCEEDED(hr) )
      {
         pTemp->Clear();
         pTemp->Release();
         pTemp = NULL;
      }
      hr = pVarSetTemp->raw_getReference(SysAllocString(L"Servers"),&pTemp);
      if ( SUCCEEDED(hr) )
      {
         pTemp->Clear();
         pTemp->Release();
         pTemp = NULL;
      }
   }
   else
   {
      bFatalError = TRUE;
   }
   gCS.Leave();

   m_startFailedVector.clear();

   do 
   {
      if ( bFatalError )
      {
         break;
      }
      swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),nServers);
      skip = pVarSetIn->get(key);
      swprintf(key,GET_STRING(DCTVSFmt_Servers_D),nServers);
      serverName = pVarSetIn->get(key);

      if ((serverName.length()) && (UStrICmp(skip,GET_STRING(IDS_YES))))
      {
         IVarSetPtr          pVS(CLSID_VarSet);

         InstallJobInfo    * pInfo = new InstallJobInfo;
         if (!pInfo)
		 {
	        delete fileList;
	        delete m_pThreadPool;
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		 }
         
         if ( pVS == NULL )
         { 
            return E_FAIL;
         }
         
         UStrCpy(key+UStrLen(key),L".JobFile");
         _bstr_t     file = pVarSetIn->get(key);

         // Set up job structure
         pInfo->pVarSetList = pVarSetIn;
         pInfo->pVarSet = pVarSetTemp;
         pInfo->serverName = serverName;
         pInfo->ndx = nServers;
         pInfo->pPlugInFileList = fileList;
         pInfo->pStartFailedVector = &m_startFailedVector;
         pInfo->pFailureDescVector = &m_failureDescVector;
         pInfo->pStartedVector = &m_startedVector;
         pInfo->pJobidVector = &m_jobidVector;
         pInfo->hMutex = m_hMutex;
         pInfo->nErrCount = 0;
         if ( file.length() )
         {
            pInfo->jobfile = file;
         }
         err.MsgWrite(0,DCT_MSG_DISPATCHING_TO_SERVER_S,(WCHAR*)pInfo->serverName);
         errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",(WCHAR*)pInfo->serverName,L"WillInstall",0);
         m_pThreadPool->SubmitJob(&DoInstall,(void *)pInfo);
      }
      nServers++;
      
      if ( nServers == nServerCount )
         break;
   } while ( serverName.length() );
   
   // launch a thread to wait for all jobs to finish, then clean up and exit
   WaitInfo* wInfo = new WaitInfo;
   if (!wInfo)
   {
	  delete fileList;
	  delete m_pThreadPool;
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   wInfo->ppPool = &m_pThreadPool;
   wInfo->pUnknown = NULL;
   wInfo->pPlugInFileList = fileList;

   QueryInterface(IID_IUnknown,(LPVOID*)&(wInfo->pUnknown));

   DWORD                     id = 0;
   HANDLE                     waitHandle = CreateThread(NULL,0,&Wait,(void *)wInfo,0,&id);
   
   CloseHandle(waitHandle);   

   return hr;
}

    

STDMETHODIMP CDCTDispatcher::AllAgentsStarted(long *bAllAgentsStarted)
{
   *bAllAgentsStarted = m_pThreadPool == NULL;
	return S_OK;
}

SAFEARRAY* MakeSafeArray(std::vector<CComBSTR>& stVector)
{
   SAFEARRAYBOUND rgsabound[1];    
   rgsabound[0].lLbound = 0;
   rgsabound[0].cElements = stVector.size(); 

   SAFEARRAY FAR* psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
   std::vector<CComBSTR>::iterator iter = stVector.begin();
   for(long i=0; iter != stVector.end(); ++iter, ++i)
   {
      _ASSERTE(*iter && *iter != L"");
      SafeArrayPutElement(psa, &i, (void*)(*iter).Copy());
   }
   stVector.clear();
   return psa;
}

STDMETHODIMP CDCTDispatcher::GetStartedAgentsInfo(long* bAllAgentsStarted, SAFEARRAY** ppbstrStartedAgents, SAFEARRAY** ppbstrJobid, SAFEARRAY** ppbstrFailedAgents, SAFEARRAY** ppbstrFailureDesc)
{
   *bAllAgentsStarted = m_pThreadPool == NULL;

//   DWORD res = ::WaitForSingleObject(m_hMutex, 30000);
   ::WaitForSingleObject(m_hMutex, 30000);
   *ppbstrFailedAgents = MakeSafeArray(m_startFailedVector);
   *ppbstrFailureDesc = MakeSafeArray(m_failureDescVector);

   _ASSERTE(m_startedVector.size() == m_jobidVector.size());
   *ppbstrStartedAgents = MakeSafeArray(m_startedVector);
   *ppbstrJobid = MakeSafeArray(m_jobidVector);
   ::ReleaseMutex(m_hMutex);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\dispatch.cpp ===
/*---------------------------------------------------------------------------
  File: Dispatcher.cpp

  Comments: COM server implementation for dispatcher, generated by ATL.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/// Dispatcher.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Dispatcherps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
//#include "..\Common\Include\McsDispatcher.h"
#include "Dispatch.h"

//#include "McsDispatcher_i.c"
#include "Dispatch_i.c"
#include "DDisp.h"
#include "DInst.h"
#include <MigrationMutex.h>


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
	bool bCreated = false;
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    if (h != NULL)
	   bCreated = true;
    CloseHandle(h);
	return bCreated;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DCTDispatcher, CDCTDispatcher)
OBJECT_ENTRY(CLSID_DCTInstaller, CDCTInstaller)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	ATLTRACE(_T("{McsDispatcher.exe}_tWinMain(hInstance=0x%08lX,...)\n"), hInstance);

	// obtain dispatcher mutex
	// the migration driver uses this mutex to determine
	// if the dispatcher process is currently running

	CMigrationMutex mutex(DISPATCHER_MUTEX, true);

	// set debug flags to check memory allocations and leaks
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
//    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_MCSDISPATCHERLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Dispatcher, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Dispatcher, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));

        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

	ATLTRACE(_T("{McsDispatcher.exe}_tWinMain() : hInstance=0x%08lX\n"), hInstance);
    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\qprocess.cpp ===
//#pragma title( "QProcess.cpp - Query type of processor on machine" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  QProcess.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-21
Description -  Query type of processor on machine
Updates     -
===============================================================================
*/

#include <stdio.h>

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "TReg.hpp"
#include "QProcess.hpp"

extern TErrorDct err;

#define  REGKEY_ARCHITECTURE  TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment")
#define  REGVAL_ARCHITECTURE  TEXT("PROCESSOR_ARCHITECTURE")

// Determine processor of machine
ProcessorType                              // ret-processor type
   QProcessor(
      TCHAR          const * machineName   // in -Machine name
   )
{
   ProcessorType             processor=PROCESSOR_IS_UNKNOWN;
   DWORD                     rcOs;         // OS return code
   TRegKey                   regMachine;   // Registry object for target machine
   TRegKey                   regEnviron;   // Registry object for selected key
   TCHAR                     strEnviron[32];  // Selected value
   
   rcOs = regMachine.Connect( HKEY_LOCAL_MACHINE, machineName );
   if ( rcOs )
   {
      err.SysMsgWrite( ErrW, rcOs, DCT_MSG_QPROCESSOR_REG_CONNECT_FAILED_SD,
            machineName, rcOs );
   }
   else
   {
      rcOs = regEnviron.Open( REGKEY_ARCHITECTURE, &regMachine );
      if ( rcOs )
      {
         err.SysMsgWrite( ErrW, rcOs, DCT_MSG_QPROCESSOR_REGKEY_OPEN_FAILED_SSD,
               machineName, REGKEY_ARCHITECTURE, rcOs );
      }
      else
      {
         rcOs = regEnviron.ValueGetStr( REGVAL_ARCHITECTURE, strEnviron, sizeof strEnviron );
         if ( rcOs )
         {
            err.SysMsgWrite( ErrW, rcOs, DCT_MSG_QPROCESSOR_REGKEY_OPEN_FAILED_SSD,
                  machineName, REGKEY_ARCHITECTURE, REGVAL_ARCHITECTURE, rcOs );
         }
         else
         {
            if ( !UStrICmp( strEnviron, TEXT("x86") ) )
            {
               processor = PROCESSOR_IS_INTEL;
            }
            else if ( !UStrICmp( strEnviron, TEXT("ALPHA") ) )
            {
               processor = PROCESSOR_IS_ALPHA;
            }
            else
            {
               err.MsgWrite( ErrW,DCT_MSG_QPROCESSOR_UNRECOGNIZED_VALUE_SSSS,
                     machineName, REGKEY_ARCHITECTURE, REGVAL_ARCHITECTURE, strEnviron );
            }
         }
         regEnviron.Close();
      }
      regMachine.Close();
   }
   return processor;
}

// QProcess.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\dinst.h ===
/*---------------------------------------------------------------------------
  File: DCTInstaller.h

  Comments: COM object that installs the DCT Agent Service on a remote machine.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
	
// DCTInstaller.h : Declaration of the CDCTInstaller

#ifndef __DCTINSTALLER_H_
#define __DCTINSTALLER_H_

#include "resource.h"       // main symbols

#include "EaLen.hpp"

//#include <mstask.h>
#include <comdef.h>
#include <mtx.h>
#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"

/////////////////////////////////////////////////////////////////////////////
// CDCTInstaller
class ATL_NO_VTABLE CDCTInstaller : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDCTInstaller, &CLSID_DCTInstaller>,
   public IWorkNode
   {
   _bstr_t                   m_Account;
   _bstr_t                   m_Password;
   _bstr_t                   m_SourcePath;
   _bstr_t                   m_TargetPath;
   WCHAR                     m_LocalComputer[LEN_Computer];
   TNodeList               * m_PlugInFileList;
public:
	CDCTInstaller()
	{
		m_LocalComputer[0] = L'\0';
      m_pUnkMarshaler = NULL;
      m_PlugInFileList = NULL;
	}
   void SetFileList(TNodeList *pList) { m_PlugInFileList = pList; }
DECLARE_REGISTRY_RESOURCEID(IDR_DCTINSTALLER)
DECLARE_NOT_AGGREGATABLE(CDCTInstaller)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDCTInstaller)
	COM_INTERFACE_ENTRY(IWorkNode)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IDCTInstaller
public:
	STDMETHOD(SetCredentials)(BSTR account, BSTR password);
	STDMETHOD(InstallToServer)(BSTR serverName, BSTR configurationFile);

protected:
   // helper functions
   DWORD GetLocalMachineName();
   
public:
   
// IWorkNode
	STDMETHOD(Process)(IUnknown * pUnknown);

};

class TFileNode: public TNode
{
   WCHAR                     filename[LEN_Path];
public:
   TFileNode(WCHAR const * f) { safecopy(filename,f); }

   WCHAR const * FileName() { return filename; }
};


#endif //__DCTINSTALLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dispatch.rc
//
#define IDS_PROJNAME                    100
#define IDR_Dispatcher                  100
#define IDR_DCTDISPATCHER               101
#define IDS_FAILED_TO_BIND_TO_AGENT     101
#define IDR_DCTINSTALLER                102
#define IDR_WORKNODEPOOLEDDISPATCH      103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         206
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\dinst.cpp ===
/*---------------------------------------------------------------------------
  File: DCTInstaller.cpp

  Comments: implementation of COM object that installs the DCT agent service.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

// DCTInstaller.cpp : Implementation of CDCTInstaller
#include "stdafx.h"
//#include "McsDispatcher.h"
#include "Dispatch.h"
#include "DInst.h"

#include "Common.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "QProcess.hpp"
#include "IsAdmin.hpp"
#include "TSync.hpp"
#include "TReg.hpp"
#include "TInst.h"
#include "TFile.hpp"
#include "ResStr.h"
#include "sd.hpp"
#include "CommaLog.hpp"

#include <lm.h>

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

TErrorDct                      err;
TError                       & errCommon = err;
StringLoader                   gString;
extern TErrorDct               errLog;
extern BOOL                    gbCacheFileBuilt;

#ifdef OFA
#define AGENT_EXE              L"OFAAgent.exe"
#define SERVICE_EXE            L"OFAAgentService.exe"
#else
#define AGENT_EXE              GET_STRING(IDS_AGENT_EXE)
#define SERVICE_EXE            GET_STRING(IDS_SERVICE_EXE)
#endif
#define WORKER_DLL             GET_STRING(IDS_WORKER_DLL)
#define VARSET_DLL             GET_STRING(IDS_VARSET_DLL)
#define DATA_FILE              GET_STRING(IDS_DATA_FILE)
#define RESOURCE_DLL           L"McsDmRes.dll"
#define MESSAGE_DLL            L"McsDmMsg.dll"
#define CACHE_FILE             L"DCTCache"

#define AGENT_INTEL_DIR        GET_STRING(IDS_AGENT_INTEL_DIR)
#define AGENT_ALPHA_DIR        GET_STRING(IDS_AGENT_ALPHA_DIR)

/////////////////////////////////////////////////////////////////////////////
// CDCTInstaller

namespace {
   class workerDeleteFile {
      _bstr_t m_strFile;
   public:
      workerDeleteFile(_bstr_t strFile):m_strFile(strFile)
      {}
      ~workerDeleteFile()
      { ::DeleteFile(m_strFile); }
   };

   union Time {
   FILETIME m_stFileTime;
   LONGLONG m_llTime;
   };

   bool IsServiceInstalling(_bstr_t sDirSysTgt, _bstr_t strTemp1, _bstr_t strTemp2)
   {
      bool bRes = false;
      HANDLE hFind;
      WIN32_FIND_DATA findData1;
      if((hFind = FindFirstFile(strTemp1, &findData1)) != INVALID_HANDLE_VALUE)
      {
         WIN32_FIND_DATA findData2;
         ::FindClose(hFind);
         hFind = CreateFile(
            strTemp2,          // pointer to name of the file
            GENERIC_WRITE,       // access (read-write) mode
            0,           // share mode
            0,
            // pointer to security attributes
            CREATE_ALWAYS,  // how to create
            FILE_ATTRIBUTE_NORMAL,   // file attributes
            0          // handle to file with attributes to 
            );
         if(hFind != INVALID_HANDLE_VALUE)
         {
            CloseHandle(hFind);
            hFind = FindFirstFile(strTemp2, &findData2);
            ::DeleteFile(strTemp2);
            if(hFind != INVALID_HANDLE_VALUE)
            {
               ::FindClose(hFind);
               // look at difference in file creation times
               Time t1, t2;
               t1.m_stFileTime = findData1.ftCreationTime;
               t2.m_stFileTime = findData2.ftCreationTime;
               LONGLONG lldiff = t2.m_llTime - t1.m_llTime;
               if((lldiff/10000000) <= 600)
                  bRes = true;
            }
         }
      }
      
      if(!bRes)
      {
         hFind = CreateFile(
            strTemp1,          // pointer to name of the file
            GENERIC_WRITE,       // access (read-write) mode
            0,           // share mode
            0,
            // pointer to security attributes
            CREATE_ALWAYS,  // how to create
            FILE_ATTRIBUTE_NORMAL,   // file attributes
            0          // handle to file with attributes to 
            );
         if(hFind != INVALID_HANDLE_VALUE)
            ::CloseHandle(hFind);
      }

      return bRes;
   }

   bool IsServiceRunning(_bstr_t strServer)
   {
      SC_HANDLE hScm = OpenSCManager(strServer, NULL, GENERIC_READ);
      if(!hScm)
      {
         err.DbgMsgWrite(ErrW,L"Could not open SCManager on %s : GetLastError() returned %d", 
            (WCHAR*)strServer, GetLastError());
         return false;
      }

      CComBSTR bstrServiceName(L"OnePointFileAdminService");
      SC_HANDLE hSvc = OpenService(hScm, GET_STRING(IDS_SERVICE_NAME), GENERIC_READ);
      
      if(!hSvc)
      {
         if ( GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST )
            err.DbgMsgWrite(ErrW,L"Could not open service on %s : GetLastError() returned %d", 
               (WCHAR*)strServer, GetLastError());
         CloseServiceHandle(hScm);
         return false;
      }
      CloseServiceHandle(hScm);

      SERVICE_STATUS status;
      BOOL bRes = QueryServiceStatus(hSvc, &status);
      
      if(!bRes)
      {
         err.DbgMsgWrite(ErrW,L"Could not get service status on %s : GetLastError() returned %d", 
            (WCHAR*)strServer, GetLastError());
         CloseServiceHandle(hSvc);
         return false;
      }
      CloseServiceHandle(hSvc);
      if(status.dwCurrentState != SERVICE_STOPPED)
         return true;
      else
         return false;
   }
}


int GetTargetOSVersion(LPWSTR sServerName)
{
   DWORD rc = NERR_Success;
   SERVER_INFO_101 * servInfo = NULL;
   int nVersion = 4;
   
      // Check version info
   rc = NetServerGetInfo(sServerName, 101, (LPBYTE *)&servInfo);
   if (rc == NERR_Success)
   {
      if(servInfo->sv101_version_major >= 5) 
         nVersion = 5;
      else
         nVersion = 4;
      NetApiBufferFree(servInfo);
   }

   return nVersion;
}

DWORD                                      // ret- OS return code
   CDCTInstaller::GetLocalMachineName()
{
   DWORD                     rc = 0;
   WKSTA_INFO_100          * buf = NULL;

   rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&buf);
   if ( ! rc )
   {
      safecopy(m_LocalComputer,L"\\\\");
      UStrCpy(m_LocalComputer+2,buf->wki100_computername);
      NetApiBufferFree(buf);
   }
   return rc;
}

DWORD                                      // ret- OS return code
   GetPlugInDirectory(
      WCHAR                * directory     // out- directory where plug-in files are
   )
{
   TRegKey                   key;
   DWORD                     rc;
   
   // Get the plug-ins directory from the registry
   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"PlugInDirectory",directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}

DWORD                                     // ret- OS return code
   GetInstallationDirectory(
      WCHAR                * directory    // out- directory we were installed to
   )
{
   TRegKey                   key;
   DWORD                     rc;
   
   // Get the plug-ins directory from the registry
   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"Directory",directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}

DWORD                                      // ret- OS return code
   GetProgramFilesDirectory(
      WCHAR                * directory,    // out- location of program files directory
      WCHAR          const * computer      // in - computer to find PF directory on
   )
{
   TRegKey                   hklm;
   TRegKey                   key;
   DWORD                     rc;

   rc = hklm.Connect(HKEY_LOCAL_MACHINE,computer);
   if ( ! rc )
   {
      rc = key.Open(L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion",&hklm);
   }
   if ( !rc )
   {
      rc = key.ValueGetStr(L"ProgramFilesDir",directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}

STDMETHODIMP                                    // ret- HRESULT
   CDCTInstaller::InstallToServer(
      BSTR                   serverName,        // in - computer name to install to
      BSTR                   configurationFile  // in - full path to job file (varset file, copied as part of install)
   )
{
   DWORD                     rcOs=0;       // OS return code

   if ( ! *m_LocalComputer )
   {
      rcOs = GetLocalMachineName();
      if ( rcOs )
      {
         err.SysMsgWrite(ErrE,rcOs,DCT_MSG_NO_LOCAL_MACHINE_NAME_D,rcOs);
         return HRESULT_FROM_WIN32(rcOs);
      }
   }
   
   // Check for admin privileges on the server
   rcOs = IsAdminRemote((WCHAR*)serverName);

   if ( rcOs == ERROR_ACCESS_DENIED )
   {
      err.MsgWrite(ErrE,DCT_MSG_NOT_ADMIN_ON_SERVER_S,(WCHAR*)serverName);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if ( rcOs == ERROR_BAD_NET_NAME )
   {
      err.MsgWrite(ErrE,DCT_MSG_NO_ADMIN_SHARES_S,(WCHAR*)serverName);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if ( rcOs == ERROR_BAD_NETPATH )
   {
      err.MsgWrite(ErrE,DCT_MSG_COMPUTER_NOT_FOUND_S,(WCHAR*)serverName);
      return HRESULT_FROM_WIN32(rcOs);
   }
   else if ( rcOs )
   {
      err.SysMsgWrite(ErrE,rcOs,DCT_MSG_NO_ADMIN_SHARE_SD,(WCHAR*)serverName,rcOs);
      return HRESULT_FROM_WIN32(rcOs);
   }
      
   TDCTInstall               x( serverName, m_LocalComputer );
   DWORD                     typeThis = 0;
   DWORD                     typeTarg = 0;
   BOOL						     bNoProgramFiles = FALSE;  
   BOOL                      bShareCreated = FALSE;
   SHARE_INFO_502            shareInfo;
            

   errCommon = err;
   do // once or until break
   {
      typeThis = QProcessor( m_LocalComputer );
      typeTarg = QProcessor( serverName );

	     //do not install to ALPHAs, atleast for Whistler Beta 2
	  if (typeTarg == PROCESSOR_IS_ALPHA)
         return CO_E_NOT_SUPPORTED;
   
      // Set installation directories for source and target

      WCHAR                sDirInstall[MAX_PATH];
      WCHAR                sDirPlugIn[MAX_PATH];
      WCHAR                sDirSrc[MAX_PATH];
      
      WCHAR                sDirTgt[MAX_PATH];
      WCHAR                sDirSysTgt[MAX_PATH];
      WCHAR                sDirTgtProgramFiles[MAX_PATH];
      WCHAR                sDirTgtProgramFilesLocal[MAX_PATH];
      WCHAR                sDestination[MAX_PATH];
      WCHAR                sSvc[MAX_PATH];
      SHARE_INFO_1       * shInfo1 = NULL;
      
      rcOs = GetInstallationDirectory(sDirInstall);
      if ( rcOs ) break;

      rcOs = GetPlugInDirectory(sDirPlugIn);
      //if ( rcOs ) break;

      rcOs = GetProgramFilesDirectory(sDirTgtProgramFiles,serverName);
      if ( rcOs ) 
	   {
		   if ( rcOs != ERROR_FILE_NOT_FOUND )
         {
            break;
         }
         // this doesn't work on NT 3.51, so if we can't get the program files directory, we'll 
         // create a directory off the system root.
         safecopy(sDirTgtProgramFiles,"\\ADMIN$");
		   bNoProgramFiles = TRUE;
         rcOs = 0;
      }
      safecopy(sDirTgtProgramFilesLocal,sDirTgtProgramFiles);
      // See if the admin$ shares exist already
      if ( sDirTgtProgramFiles[1] == L':' && sDirTgtProgramFiles[2] == L'\\' )
      {
         BOOL                bNeedToCreateShare = FALSE;

         sDirTgtProgramFiles[1] = L'$';
         sDirTgtProgramFiles[2] = 0;
         rcOs = NetShareGetInfo(serverName,sDirTgtProgramFiles,1,(LPBYTE*)&shInfo1);
         if ( rcOs )
         {
            if ( rcOs == NERR_NetNameNotFound ) 
            {
               bNeedToCreateShare = TRUE;                           
            }
            else
            {
               bNeedToCreateShare = FALSE;
               err.SysMsgWrite(ErrE,rcOs,DCT_MSG_ADMIN_SHARE_GETINFO_FAILED_SSD,serverName,sDirTgtProgramFiles,rcOs);
               // put the program files path name back like it was
               sDirTgtProgramFiles[1] = L':';
               sDirTgtProgramFiles[2] = L'\\';

            }
         }
         else
         {
            if ( shInfo1->shi1_type & STYPE_SPECIAL )
            {
               // the admin share exists -- we'll just use it
               bNeedToCreateShare = FALSE;
               // put the program files path name back like it was
               sDirTgtProgramFiles[1] = L':';
               sDirTgtProgramFiles[2] = L'\\';
            }
            else
            {
               err.MsgWrite(0,DCT_MSG_SHARE_IS_NOT_ADMIN_SHARE_SS,serverName,shInfo1->shi1_netname);
               bNeedToCreateShare = TRUE;
            }
            NetApiBufferFree(shInfo1);
         }
         if ( bNeedToCreateShare )
         {
            SECURITY_DESCRIPTOR emptySD;
            WCHAR            shareName[LEN_Path];
            WCHAR            remark[LEN_Path];
            BYTE             emptyRelSD[LEN_Path];
            DWORD            lenEmptyRelSD = DIM(emptyRelSD);
            
            sDirTgtProgramFiles[1] = L':';
            sDirTgtProgramFiles[2] = L'\\';

            memset(&emptySD,0,(sizeof SECURITY_DESCRIPTOR));
            InitializeSecurityDescriptor(&emptySD,SECURITY_DESCRIPTOR_REVISION);
            MakeSelfRelativeSD(&emptySD,emptyRelSD,&lenEmptyRelSD);
            
            TSD              pSD((SECURITY_DESCRIPTOR*)emptyRelSD,McsShareSD,FALSE);
            PACL             dacl = NULL;
            TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,GetWellKnownSid(1/*ADMINISTRATORS*/));
            DWORD            lenInfo = (sizeof shareInfo);
            pSD.ACLAddAce(&dacl,&ace,0);
            pSD.SetDacl(dacl);

            UStrCpy(shareName,GET_STRING(IDS_HiddenShare));
            UStrCpy(remark,GET_STRING(IDS_HiddenShareRemark));
            
            memset(&shareInfo,0,(sizeof shareInfo));
            shareInfo.shi502_netname = shareName;
            shareInfo.shi502_type = STYPE_DISKTREE;
            shareInfo.shi502_remark = remark;
            shareInfo.shi502_max_uses = 1;
            shareInfo.shi502_path = sDirTgtProgramFiles;
            shareInfo.shi502_security_descriptor = pSD.MakeRelSD();

            rcOs = NetShareAdd(serverName,502,(LPBYTE)&shareInfo,&lenInfo);
            if ( rcOs )
            {
               err.SysMsgWrite(ErrE,rcOs,DCT_MSG_TEMP_SHARE_CREATE_FAILED_SSD,serverName,shareName,rcOs);
               break;
            }
            else
            {
               safecopy(sDirTgtProgramFiles,shareName);
               bShareCreated = TRUE;
            }
            free(shareInfo.shi502_security_descriptor);
            shareInfo.shi502_security_descriptor = NULL;
         }
      
      }
      else
      {
         // something went wrong...the program files directory is not in drive:\path format
         err.MsgWrite(ErrW,DCT_MSG_INVALID_PROGRAM_FILES_DIR_SS,serverName,sDirTgtProgramFiles);
      }
      
      // setup source directory name for install
      UStrCpy( sDirSrc, sDirInstall );
      switch ( typeTarg )
      {
      case PROCESSOR_IS_INTEL:
         if ( typeTarg != typeThis )
         {
            UStrCpy(sDirSrc + UStrLen(sDirSrc),AGENT_INTEL_DIR);
            UStrCpy(sDirPlugIn + UStrLen(sDirPlugIn),AGENT_INTEL_DIR);
         }
         break;
      case PROCESSOR_IS_ALPHA:
         if ( typeTarg != typeThis )
         {
            UStrCpy(sDirSrc + UStrLen(sDirSrc),AGENT_ALPHA_DIR);
            UStrCpy(sDirPlugIn + UStrLen(sDirPlugIn),AGENT_ALPHA_DIR);
         }
         break;
      default:
         rcOs = ERROR_CAN_NOT_COMPLETE;
         break;
      }
      if ( rcOs ) break;

	  //if the target machine is downlevel (NT4), dispatch NT4, non-robust, agent files
	  int nVer = GetTargetOSVersion(serverName);
	  if (nVer == 4)
	  {
		 _bstr_t sAgentDir = GET_STRING(IDS_AGENT_NT4_DIR);
		 if (UStrLen(sDirSrc) + sAgentDir.length() < MAX_PATH)
            wcscat(sDirSrc, (WCHAR*)sAgentDir);
		 if (UStrLen(sDirPlugIn) + sAgentDir.length() < MAX_PATH)
            wcscat(sDirPlugIn, (WCHAR*)sAgentDir);
	  }

      // setup target directory name for install
      UStrCpy( sDirTgt, serverName );
      UStrCpy( sDirTgt+UStrLen(sDirTgt), L"\\" );
      if ( sDirTgtProgramFiles[1] == L':' )
      {
         sDirTgtProgramFiles[1] = L'$';
      }
      UStrCpy(sDirTgt + UStrLen(sDirTgt),sDirTgtProgramFiles);
      
#ifdef OFA
      UStrCpy(sDirTgt + UStrLen(sDirTgt),L"\\OnePointFileAdminAgent\\");
#else
      UStrCpy(sDirTgt + UStrLen(sDirTgt),GET_STRING(IDS_AgentDirectoryName));
#endif
      
      UStrCpy( sDirSysTgt, serverName );
      UStrCpy( sDirSysTgt+UStrLen(sDirSysTgt), L"\\ADMIN$\\System32\\" );
   
      _bstr_t strTemp1(sDirSysTgt), strTemp2(sDirSysTgt);
      strTemp1 += (BSTR)GET_STRING(IDS_TEMP_FILE_1);
      strTemp2 += (BSTR)GET_STRING(IDS_TEMP_FILE_2);
      if(IsServiceInstalling(sDirSysTgt, strTemp1, strTemp2))
      {
         err.MsgWrite(ErrE,DCT_MSG_AGENT_SERVICE_ALREADY_RUNNING,(WCHAR*)serverName);
#ifdef OFA
         return 0x88070040;
#else
         return HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING);
#endif
      }

      workerDeleteFile wrk(strTemp1);
 
      if(IsServiceRunning(serverName))
      {
         err.MsgWrite(ErrE,DCT_MSG_AGENT_SERVICE_ALREADY_RUNNING,(WCHAR*)serverName);
#ifdef OFA
         return 0x88070040;
#else 
         return HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING);
#endif
      }
      
      if ( bNoProgramFiles )
      {
#ifdef OFA
         UStrCpy(sSvc,"%systemroot%\\OnePointFileAdminAgent\\");
#else
         UStrCpy(sSvc,"%systemroot%\\OnePointDomainAgent\\");
#endif
         UStrCpy( sSvc + UStrLen(sSvc),SERVICE_EXE );
      }
      else
      {
         UStrCpy( sSvc, sDirTgtProgramFilesLocal );
#ifdef OFA
         UStrCpy( sSvc + UStrLen(sSvc),L"\\OnePointFileAdminAgent\\");
#else
         UStrCpy( sSvc + UStrLen(sSvc),L"\\OnePointDomainAgent\\");
#endif         
         UStrCpy( sSvc + UStrLen(sSvc),SERVICE_EXE );
         sSvc[1] = L':';
      }
      
      
      if ( UStrICmp(m_LocalComputer,serverName) )
      {
         x.SetServiceInformation(GET_STRING(IDS_DISPLAY_NAME),GET_STRING(IDS_SERVICE_NAME),sSvc,NULL);
      }
      else
      {
         safecopy(sSvc,sDirSrc);
         UStrCpy(sSvc + UStrLen(sSvc),GET_STRING(IDS_SERVICE_EXE)); 
         x.SetServiceInformation(GET_STRING(IDS_DISPLAY_NAME),GET_STRING(IDS_SERVICE_NAME),sSvc,NULL);
      }


      rcOs = x.ScmOpen();
      
      if ( rcOs ) break;
      
      x.ServiceStop();
      
      if ( UStrICmp( m_LocalComputer, serverName ) )
      {
         // Create the target directory, if it does not exist
         if ( ! CreateDirectory(sDirTgt,NULL) )
         {
            rcOs = GetLastError();
            if ( rcOs && rcOs != ERROR_ALREADY_EXISTS )
            {
               err.SysMsgWrite(ErrE,rcOs,DCT_MSG_CREATE_DIR_FAILED_SD,sDirTgt,rcOs);
               break;
            }
         }
         // shared MCS files
            // source files
         TInstallFile         varset(VARSET_DLL,sDirSrc);
            // target\system32 files 
         TInstallFile         varsettargetsys(VARSET_DLL,sDirSysTgt,TRUE);
            // target\OnePoint files
         TInstallFile         varsettarget(VARSET_DLL,sDirTgt,TRUE);
         
         // agent specific files
         TInstallFile         worker(WORKER_DLL,sDirSrc);
         TInstallFile         agent(AGENT_EXE,sDirSrc);
         TInstallFile         service(SERVICE_EXE,sDirSrc);
         TInstallFile         resourceMsg(RESOURCE_DLL,sDirSrc);
         TInstallFile         eventMsg(MESSAGE_DLL,sDirSrc);
         
         TInstallFile         workertarget(WORKER_DLL,sDirTgt,TRUE);
         TInstallFile         agenttarget(AGENT_EXE,sDirTgt,TRUE);
         TInstallFile         servicetarget(SERVICE_EXE,sDirTgt,TRUE);
         TInstallFile         resourceMsgtarget(RESOURCE_DLL,sDirTgt,TRUE);
         TInstallFile         eventMsgtarget(MESSAGE_DLL,sDirTgt,TRUE);
         
#ifdef OFA
         if ( varset.CompareFile(&varsettargetsys) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,VARSET_DLL);
            varset.CopyTo(sDestination);
         }
         
#ifdef OFA
         if ( worker.CompareFile(&workertarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,WORKER_DLL);
            worker.CopyTo(sDestination);
         }

#ifdef OFA
         if ( agent.CompareFile(&agenttarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,AGENT_EXE);
            agent.CopyTo(sDestination);
         }

#ifdef OFA
         if ( service.CompareFile(&servicetarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,SERVICE_EXE);
            service.CopyTo(sDestination);
         }
#ifdef OFA
         if ( resourceMsg.CompareFile(&resourceMsgtarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,RESOURCE_DLL);
            resourceMsg.CopyTo(sDestination);
         }

#ifdef OFA
         if ( eventMsg.CompareFile(&eventMsgtarget) > 0 )
#endif
         {
            swprintf(sDestination,L"%s%s",sDirTgt,MESSAGE_DLL);
            eventMsg.CopyTo(sDestination);
         }

         // Copy files needed for plug-ins
         if ( m_PlugInFileList )
         {
            TNodeListEnum    e;
            TFileNode      * pNode;

            for ( pNode = (TFileNode*)e.OpenFirst(m_PlugInFileList) ; pNode ; pNode = (TFileNode*)e.Next() )
            {
               TInstallFile  plugInSource(pNode->FileName(),sDirPlugIn);
               TInstallFile  plugInTarget(pNode->FileName(),sDirTgt,TRUE);

               swprintf(sDestination,L"%s%s",sDirTgt,pNode->FileName());
               plugInSource.CopyTo(sDestination);
            }
            e.Close();
         }
      }
      else
      {
         safecopy(sDirTgt,sDirSrc);
      }
         
         
      // Copy the job file
      // separate the directory and filename
      WCHAR         sConfigPath[MAX_PATH];
      
      safecopy(sConfigPath,(WCHAR*)configurationFile);
      
      WCHAR       * lastslash = wcsrchr(sConfigPath,L'\\');
      if ( lastslash )
      {
         *lastslash = 0;
      }

      WCHAR const * sConfigFile = lastslash + 1;
      
      TInstallFile         config(sConfigFile,sConfigPath);

      swprintf(sDestination,L"%s%s",sDirTgt,sConfigFile);
      config.CopyTo(sDestination);
      
      if ( gbCacheFileBuilt )
      {
         // also copy the dct cache file
         TInstallFile         cache(CACHE_FILE,sConfigPath);
      
         swprintf(sDestination,L"%s%s",sDirTgt,CACHE_FILE);
         cache.CopyTo(sDestination);
      }
      // start the service
      rcOs = x.ServiceStart();
   }  while ( FALSE );

   if ( bShareCreated )
   {
      rcOs = NetShareDel(serverName,GET_STRING(IDS_HiddenShare),0);
      if ( rcOs )
      {
         err.SysMsgWrite(ErrW,rcOs,DCT_MSG_SHARE_DEL_FAILED_SSD,serverName,GET_STRING(IDS_HiddenShare),rcOs);
      }
   }
   if ( rcOs && rcOs != E_ABORT )
   {
      err.SysMsgWrite(
            ErrW,
            rcOs,
            DCT_MSG_AGENT_INSTALL_FAILED_SD,
            (WCHAR*)serverName,
            rcOs);
   }
   
   if ( SUCCEEDED(rcOs) )
   {
      return HRESULT_FROM_WIN32(rcOs);
   }
   else
   {
      return rcOs;
   }
}


STDMETHODIMP                               // ret- HRESULT
   CDCTInstaller::SetCredentials(
      BSTR                   account,      // in - account name
      BSTR                   password      // in - password
   )
{
	m_Account = account;
   m_Password = password;
   
   return S_OK;
}
// Installs the agent to a computer
// VarSet input:
//    InstallToServer      - computer to install agent on
//    ConfigurationFile    - file containing varset for job, installed with agent
// 
STDMETHODIMP                               // ret- HRESULT
   CDCTInstaller::Process(
      IUnknown             * pWorkItem     // in - varset containing data
   )
{
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVarSet = pWorkItem;
   _bstr_t                   serverName;
   _bstr_t                   dataFile;

   // Read the server name
   serverName = pVarSet->get(GET_BSTR(DCTVS_InstallToServer));
   dataFile = pVarSet->get(GET_BSTR(DCTVS_ConfigurationFile));
   if ( serverName.length() )
   {
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ls",(WCHAR*)serverName,L"JobFile",(WCHAR*)dataFile);
      hr = InstallToServer(serverName,dataFile);
      _bstr_t strChoice = pVarSet->get(GET_BSTR(DCTVS_Options_DeleteJobFile));
      if(strChoice == _bstr_t(GET_STRING(IDS_YES)))
         ::DeleteFile(dataFile);
      errLog.DbgMsgWrite(0,L"%ls\t%ls\t%ld",(WCHAR*)serverName,L"Install",HRESULT_CODE(hr));
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__59C98118_C29C_11D2_A1E0_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__59C98118_C29C_11D2_A1E0_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_FREE_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
	HANDLE hEventShutdown;
	void MonitorShutdown();
	bool StartMonitor();
	bool bActivity;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__59C98118_C29C_11D2_A1E0_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\qprocess.hpp ===
//#pragma title( "QProcess.hpp - Query type of processor on machine" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  QProcess.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-21
Description -  Query type of processor on machine
Updates     -
===============================================================================
*/

#ifndef  MCSINC_QProcess_hpp
#define  MCSINC_QProcess_hpp

// Returned value from QProcessor.
enum ProcessorType
      { PROCESSOR_IS_UNKNOWN, PROCESSOR_IS_INTEL, PROCESSOR_IS_ALPHA };

// Determine processor of machine
ProcessorType                              // ret-processor type
   QProcessor(
      TCHAR          const * machineName   // in -Machine name
   );

#endif  // MCSINC_QProcess_hpp

// QProcess.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\documents\help\helpalias.h ===
IDH_INTRO_DOMAIN_MIGRATOR=DomMigIntro.htm

IDH_HOWTO_OVERVIEW=TasksOverview.htm
IDH_HOWTO_START_DM=TasksStartDM.htm
IDH_HOWTO_MIGRATE_TRUSTS=TasksManageTrusts.htm
IDH_HOWTO_MERGE_GROUPS=TasksMergeGroups.htm
IDH_HOWTO_MIGRATE_USERS=TasksMigrateAccounts.htm
IDH_HOWTO_MIGRATE_GROUPS=TasksMigrateGroups.htm
IDH_HOWTO_MIGRATE_COMPUTERS=TasksMigrateComputers.htm
IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS=TasksMigrateServAccts.htm
IDH_HOWTO_RESOLVE_SECURITY=TasksTranslateSecurity.htm
IDH_HOWTO_RESOLVE_EXCHANGE=TasksTranslateExchange.htm
IDH_HOWTO_RETRY_TASK=TasksRetry.htm
IDH_HOWTO_UNDO_LAST_OPERATION=TasksUndoLast.htm
IDH_HOWTO_GENERATE_REPORTS=TasksGenerateReports.htm

IDH_CONCEPT_OVERVIEW=ConceptOverview.htm
IDH_CONCEPT_REQUIREMENT=ConceptDomMigRequirements.htm
IDH_CONCEPT_SECURITY_ISSUE=ConceptDomMigSecurityIssues.htm
IDH_CONCEPT_ACCOUNT_MIGRATION=ConceptAccountMigration.htm
IDH_CONCEPT_COMPUTER_MIGRATION=ConceptComputerMigration.htm
IDH_CONCEPT_SECURITY_TRANSLATION=ConceptSecurityTranslationIssues.htm
IDH_CONCEPT_EXCHANGE_TRANSLATION=ConceptExchangeTranslationIssues.htm
IDH_CONCEPT_TRUST_MIGRATION=ConceptTrustMigration.htm
IDH_CONCEPT_UNDERSTAND_UI=ConceptUnderstandingIntro.htm
IDH_CONCEPT_UI_CONSOLE_WINDOW=ConceptUnderstandingConsole.htm
IDH_CONCEPT_UI_MENUS=ConceptUnderstandingMenus.htm

IDH_WINDOW_OVERVIEW=WindowOverview.htm
IDH_WINDOW_WELCOME=WindowWelcome.htm
IDH_WINDOW_DOMAIN_SELECTION=WindowDomainSelect.htm
IDH_WINDOW_USER_SELECTION=WindowUserSelect.htm
IDH_WINDOW_GROUP_SELECTION=WindowGroupSelect.htm
IDH_WINDOW_TARGET_GROUP_SELECTION=WindowTargetGroupSelect.htm
IDH_WINDOW_COMPUTER_SELECTION=WindowComputerSelect.htm
IDH_WINDOW_TASK_SELECTION=WindowTaskSelect.htm
IDH_WINDOW_DIRECTORY_SELECTION=WindowDirectorySelect.htm
IDH_WINDOW_OU_SELECTION=WindowOUSelect.htm
IDH_WINDOW_OBJECTTYPE_SELECTION=WindowObjectTypeSelect.htm
IDH_WINDOW_REPORT_SELECTION=WindowReportSelect.htm
IDH_WINDOW_SERVICE_ACCOUNT_SELECTION=WindowServiceAccountSelect.htm
IDH_WINDOW_EXCHANGE_SERVER_SELECTION=WindowExchangeServerSelect.htm
IDH_WINDOW_PASSWORD_OPTION=WindowPasswordOption.htm
IDH_WINDOW_ACCOUNTTRANSITION_OPTION=WindowAccountTransitionOption.htm
IDH_WINDOW_USER_OPTION=WindowUserOption.htm
IDH_WINDOW_GROUP_OPTION=WindowGroupOption.htm
IDH_WINDOW_GROUP_MEMBER_OPTION=WindowGroupMemberOption.htm
IDH_WINDOW_SECURITY_OPTION=WindowSecurityOption.htm
IDH_WINDOW_COMPUTER_OPTION=WindowComputerOption.htm
IDH_WINDOW_EXCHANGE_OPTION=WindowExchangeOption.htm
IDH_WINDOW_NAME_CONFLICT=WindowNameConflict.htm
IDH_WINDOW_SECURITY_CREDENTIALS=WindowSecurityCredential.htm
IDH_WINDOW_REPORT_CREDENTIALS=WindowReportCredential.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS=WindowSIDHistoryCredential.htm
IDH_WINDOW_AGENT_MONITOR=WindowAgentOverview.htm
IDH_WINDOW_AGENT_MONITOR_SETTING=WindowAgentMonSettings.htm
IDH_WINDOW_AGENT_SERVER_LIST=WindowAgentMonServers.htm
IDH_WINDOW_AGENT_SUMMARY=WindowAgentMonSummary.htm
IDH_WINDOW_CONFIRMATION=WindowConfirmation.htm
IDH_WINDOW_COMMIT=WindowCommitChanges.htm
IDH_WINDOW_REFRESH_INFO=WindowRefreshInfo.htm
IDH_WINDOW_SERVICE_ACCOUNT_INFO=WindowServiceAccountInfo.htm
IDH_WINDOW_TRUST_INFO=WindowTrustInfo.htm
IDH_WINDOW_UNDO=WindowUndo.htm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\documents\help\helpid.h ===
#define IDH_INTRO_DOMAIN_MIGRATOR                 1000

#define IDH_HOWTO_OVERVIEW                        2000
#define IDH_HOWTO_START_DM                        2010
#define IDH_HOWTO_MIGRATE_TRUSTS                  2015
#define IDH_HOWTO_MERGE_GROUPS                    2017
#define IDH_HOWTO_MIGRATE_USERS                   2020
#define IDH_HOWTO_MIGRATE_GROUPS                  2030
#define IDH_HOWTO_MIGRATE_COMPUTERS               2040
#define IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS        2045
#define IDH_HOWTO_RESOLVE_SECURITY                2050
#define IDH_HOWTO_RESOLVE_EXCHANGE                2060
#define IDH_HOWTO_RETRY_TASK                      2070
#define IDH_HOWTO_UNDO_LAST_OPERATION             2080
#define IDH_HOWTO_GENERATE_REPORTS                2090

#define IDH_CONCEPT_OVERVIEW                      3000
#define IDH_CONCEPT_REQUIREMENT                   3010
#define IDH_CONCEPT_SECURITY_ISSUE                3020
#define IDH_CONCEPT_ACCOUNT_MIGRATION             3030
#define IDH_CONCEPT_COMPUTER_MIGRATION            3040
#define IDH_CONCEPT_SECURITY_TRANSLATION          3050
#define IDH_CONCEPT_EXCHANGE_TRANSLATION          3060
#define IDH_CONCEPT_TRUST_MIGRATION               3070
#define IDH_CONCEPT_UNDERSTAND_UI                 3100
#define IDH_CONCEPT_UI_CONSOLE_WINDOW             3110
#define IDH_CONCEPT_UI_MENUS                      3120

#define IDH_WINDOW_OVERVIEW                       4000
#define IDH_WINDOW_WELCOME                        4010
#define IDH_WINDOW_DOMAIN_SELECTION               4020
#define IDH_WINDOW_USER_SELECTION                 4030
#define IDH_WINDOW_GROUP_SELECTION                4040
#define IDH_WINDOW_TARGET_GROUP_SELECTION         4045
#define IDH_WINDOW_COMPUTER_SELECTION             4050
#define IDH_WINDOW_TASK_SELECTION                 4060
#define IDH_WINDOW_DIRECTORY_SELECTION            4070
#define IDH_WINDOW_OU_SELECTION                   4080
#define IDH_WINDOW_OBJECTTYPE_SELECTION           4090
#define IDH_WINDOW_REPORT_SELECTION               4100
#define IDH_WINDOW_SERVICE_ACCOUNT_SELECTION      4110
#define IDH_WINDOW_EXCHANGE_SERVER_SELECTION      4120
#define IDH_WINDOW_PASSWORD_OPTION                4200
#define IDH_WINDOW_ACCOUNTTRANSITION_OPTION       4210
#define IDH_WINDOW_USER_OPTION                    4220
#define IDH_WINDOW_GROUP_OPTION                   4230
#define IDH_WINDOW_GROUP_MEMBER_OPTION            4235
#define IDH_WINDOW_SECURITY_OPTION                4240
#define IDH_WINDOW_COMPUTER_OPTION                4250
#define IDH_WINDOW_EXCHANGE_OPTION                4260
#define IDH_WINDOW_NAME_CONFLICT                  4300
#define IDH_WINDOW_SECURITY_CREDENTIALS           4310
#define IDH_WINDOW_REPORT_CREDENTIALS             4320
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS         4330
#define IDH_WINDOW_AGENT_MONITOR                  4500
#define IDH_WINDOW_AGENT_MONITOR_SETTING          4510
#define IDH_WINDOW_AGENT_SERVER_LIST              4520
#define IDH_WINDOW_AGENT_SUMMARY                  4530
#define IDH_WINDOW_CONFIRMATION                   5000
#define IDH_WINDOW_COMMIT                         5010
#define IDH_WINDOW_REFRESH_INFO                   5020
#define IDH_WINDOW_SERVICE_ACCOUNT_INFO           5030
#define IDH_WINDOW_TRUST_INFO                     5040
#define IDH_WINDOW_UNDO                           5050
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\tfile.hpp ===
//#pragma title("TFile.hpp - Install File class")

/*---------------------------------------------------------------------------
  File: TFile.hpp

  Comments: This file contains file installation functions.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical SOftware, Inc.

  REVISION LOG ENTRY
  Author:  Juan Medrano
  Revision By: ...
  Revised on 7/9/97

  Revision By: Christy Boles
  Converted to UNICODE, removed dependency on CString
  
 ---------------------------------------------------------------------------*/

#ifndef MCSINC_TFile_hpp
#define MCSINC_TFile_hpp

class TInstallFile
{
protected:

   TCHAR                m_szFileName[MAX_PATH];        // file name (not a full path)
   TCHAR                m_szFilePath[MAX_PATH];        // full path (including file name)
   TCHAR                m_szTargetPath[MAX_PATH];      // target path (full path)
   TCHAR                m_szFileVersion[MAX_PATH];     // file version string from version resource
   TCHAR                m_szFileSize[MAX_PATH];        // file size
   TCHAR                m_szFileDateTime[MAX_PATH];    // modification date/time
   TCHAR              * m_VersionInfo;       // version info
   DWORD                m_dwLanguageCode;    // language code for version info strings
   VS_FIXEDFILEINFO     m_FixedFileInfo;     // file info structure from version resource
   WIN32_FIND_DATA      m_FileData;          // structure for FindFirstFile()
   BOOL                 m_bCopyNeeded;       // does this file need to be copied?
   BOOL                 m_bSilent;           

public:

   TInstallFile( TCHAR const * pszFileName = NULL,
                 TCHAR const * pszFileDir = NULL, 
                 BOOL silent = FALSE);
   ~TInstallFile() { delete [] m_VersionInfo; }

   DWORD    OpenFileInfo( TCHAR const * pszFileDir );
   TCHAR  * GetFileName() { return m_szFileName; }
   TCHAR  * GetFilePath() { return m_szFilePath; }
   TCHAR  * GetTargetPath() { return m_szTargetPath; }
   void     SetFileName( TCHAR const * pszFileName ) { safecopy(m_szFileName,pszFileName); }
   void     SetFilePath( TCHAR const * pszFilePath ) { safecopy(m_szFilePath,pszFilePath); }
   void     SetTargetPath( TCHAR const * pszTargetPath ) { safecopy(m_szTargetPath,pszTargetPath); }
   void     SetCopyNeeded( BOOL bCopyNeeded ) { m_bCopyNeeded = bCopyNeeded; }
   BOOL     IsCopyNeeded() { return m_bCopyNeeded; }
   DWORD    CopyTo( TCHAR const * pszDestinationPath );
   DWORD    CopyToTarget() { return CopyTo( m_szTargetPath ); }
   int      CompareFile( TInstallFile * pFileTrg );
   int      CompareFileSize( TInstallFile * pFileTrg );
   int      CompareFileDateTime( TInstallFile * pFileTrg );
   int      CompareFileVersion( TInstallFile * pFileTrg );
   void     GetFileVersion( UINT * uVerMaj, UINT * uVerMin, UINT * uVerRel, UINT * uVerMod );
   DWORD    GetFileSize() { return m_FileData.nFileSizeLow; }
   FILETIME GetFileDateTime() { return m_FileData.ftLastWriteTime; }
   TCHAR  * GetFileVersionString();
   TCHAR  * GetFileSizeString();
   TCHAR  * GetFileDateTimeString( TCHAR const * szFormatString = TEXT("%#c") );
   BOOL     IsBusy();
};

class TDllFile : public TInstallFile
{
protected:

   TCHAR       m_szProgId[MAX_PATH];                  // Prog ID (OCX's only)
   TCHAR       m_szRegPath[MAX_PATH];                 // full path where file is currently registered
   BOOL        m_bSystemFile;                         // should this file be located in system32?
   BOOL        m_bRegistrationNeeded;                 // do we need to register this file?
   BOOL        m_bRegisterTarget;                     // do we need to register this file on the target path?

public:

   TDllFile( TCHAR const * pszFileName = NULL,
             TCHAR const * pszFileDir = NULL,
             TCHAR const * pszProgId = NULL, 
             BOOL bSystemFile = FALSE ); 
   ~TDllFile() {};

   BOOL     SupportsSelfReg();
   BOOL     IsRegistered();
   BOOL     IsRegistrationNeeded() { return m_bRegistrationNeeded; }
   BOOL     DoRegisterTarget() { return m_bRegisterTarget; }
   BOOL     IsSystemFile() { return m_bSystemFile; }
   DWORD    CallDllFunction( TCHAR const * pszFunctionName, TCHAR const * pszDllName = NULL );
   DWORD    Register();
   DWORD    Unregister();
   TCHAR  * GetProgId() { return m_szProgId; }
   TCHAR  * GetRegPath() { return m_szRegPath; }
   void     SetRegistrationNeeded( BOOL bRegistrationNeeded ) { m_bRegistrationNeeded = bRegistrationNeeded; }
   void     SetRegisterTarget( BOOL bRegisterTarget ) { m_bRegisterTarget = bRegisterTarget; }
   void     SetProgId( TCHAR const * pszProgId ) { safecopy(m_szProgId,pszProgId); }
};

#endif // MCSINC_TFile_hpp

// TFile.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\tpool.h ===
#ifndef __TPOOLEDDISPATCH_H__
#define __TPOOLEDDISPATCH_H__
/*---------------------------------------------------------------------------
  File: TPooledDispatch.h

  Comments: TJobDispatcher implements a thread pool to execute jobs.  Jobs are
  executed on a FIFO basis.  This dispatcher does not provide any support for 
  job scheduling, only multithreaded dispatch of jobs.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/19/99 16:35:54

 ---------------------------------------------------------------------------
*/


#include "Common.hpp"
#include "TNode.hpp"
#include "TSync.hpp"


class Job : public TNode
{
public:
   enum JobStatus { JobStatusUninitialized, JobStatusWaiting, JobStatusRunning, JobStatusFinished };
private:
   LPTHREAD_START_ROUTINE    m_pStartRoutine;
   LPVOID                    m_pArgs;
   JobStatus                 m_Status;
   DWORD                     m_ThreadID;
   time_t                    m_timeStarted;
   time_t                    m_timeEnded;
   int                       m_result;
public:
   
   Job() 
   {
      m_pStartRoutine = NULL;
      m_pArgs = NULL;
      m_Status = JobStatusUninitialized;
      m_ThreadID = 0;
      m_timeStarted = 0;
      m_timeEnded = 0;
      m_result = 0;
   }
   ~Job() {};
   void SetEntryPoint(LPTHREAD_START_ROUTINE pStart, LPVOID pArg)
   {
      MCSASSERT(m_Status == JobStatusUninitialized || m_Status == JobStatusFinished );
      MCSASSERT(pStart);
      
      m_pStartRoutine = pStart;
      m_pArgs = pArg;
      m_Status = JobStatusWaiting;
   }

   int Run();
   
//   int GetElapsedTime() { return m_timeEnded - m_timeStarted; }
   time_t GetElapsedTime() { return m_timeEnded - m_timeStarted; }
   int GetResult() { return m_result; }
   JobStatus GetStatus() { return m_Status; }
};


class JobList : public TNodeList
{
   TCriticalSection          m_cs;

public:
   ~JobList() { DeleteAllListItems(Job); }
   Job *  AddJob(LPTHREAD_START_ROUTINE pfnStart, void * arg) { Job * pJob = new Job; pJob->SetEntryPoint(pfnStart,arg);
                                                               m_cs.Enter(); InsertBottom(pJob); m_cs.Leave(); return pJob; }
   void   RemoveJob(Job * pJob) { m_cs.Enter(); Remove(pJob); m_cs.Leave(); }
   Job *  GetFirstJob() { m_cs.Enter(); Job * pJob = (Job *)Head(); if ( pJob ) Remove(pJob); m_cs.Leave(); return pJob; }
};


class TJobDispatcher 
{
   DWORD                     m_numThreads;
   JobList                   m_JobsWaiting;
   JobList                   m_JobsInProgress;
   TSemaphoreNamed           m_sem;
   TCriticalSection          m_cs;
   DWORD                     m_numActiveThreads;
   BOOL                      m_Aborting;
public:
   TJobDispatcher(DWORD maxThreads = 10) { InitThreadPool(maxThreads); m_Aborting = FALSE;}
   ~TJobDispatcher() { WaitForCompletion(); ShutdownThreads(); }
   
   // These are called by the client
   Job * SubmitJob(LPTHREAD_START_ROUTINE pStart,LPVOID pArg)
   {
//      Job * pJob = m_JobsWaiting.AddJob(pStart,pArg);
      m_JobsWaiting.AddJob(pStart,pArg);
      m_sem.Release(1);     
      return 0;
   }

   void    WaitForCompletion();
   int     UnfinishedJobs();

   // These functions are called by the threads - clients should not call these functions!
   DWORD   SignalForJob();
   Job   * GetAvailableJob();
   void    ThreadFinished() { m_cs.Enter(); m_numActiveThreads--; m_cs.Leave(); }
protected:
   void  InitThreadPool(DWORD nThreads);
   void  ShutdownThreads();
};



#endif //__TPOOLEDDISPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\tinst.cpp ===
/*---------------------------------------------------------------------------
  File: TDCTInsall.cpp

  Comments: Utility class used by the dispatcher to install the DCT agent service.
  The TDCTInstall class encapsulates the service control management required
  to remotely install the agent service, configure it, and start it.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:33:17

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "TInst.h"

#include "ErrDct.hpp"

extern TErrorDct        err;

//-----------------------------------------------------------------------------
// Open service control manager
//-----------------------------------------------------------------------------

DWORD                                      // ret-OS return code
   TDCTInstall::ScmOpen(BOOL bSilent)
{
   DWORD                     rcOs=0;       // OS return code

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls Start - Open SCM",
            m_sDisplayName,m_sComputer );
   }
   
   m_hScm = OpenSCManager(m_sComputer,NULL, SC_MANAGER_ALL_ACCESS );

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install  on %ls End   - Open SCM",
            m_sDisplayName,m_sComputer );
   }
   
   if ( !m_hScm )
   {
      rcOs = GetLastError();
      if ( ! bSilent )
         err.SysMsgWrite(
            ErrW,
            rcOs,
            DCT_MSG_SCM_OPEN_FAILED_SD,
            m_sComputer,
            rcOs );
   }
   return rcOs;
}

//-----------------------------------------------------------------------------
// Close service control manager
//-----------------------------------------------------------------------------

void
   TDCTInstall::ScmClose()
{
   if ( m_hScm )
   {
      CloseServiceHandle( m_hScm );
      m_hScm = NULL;
   }
}

//-----------------------------------------------------------------------------
// Create and start the service
//-----------------------------------------------------------------------------

DWORD                                      // ret-OS return code
   TDCTInstall::ServiceStart()
{
   DWORD                     rcOs=0;       // OS return code
   WCHAR                     sFile[LEN_Path];
   SC_HANDLE                 hSvc;         // Service handle
   BOOL                      bRc;          // boolean return code

   
   MCSASSERT(*m_sExeName);
   MCSASSERT(*m_sDisplayName);
   MCSASSERT(*m_sServiceName);

   
   swprintf(sFile,L"%s",m_sExeName);
   
   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls Start - Open %ls service",
            m_sDisplayName,
            m_sComputer,
            m_sServiceName
            );
   }
   hSvc = OpenService( m_hScm, m_sServiceName, SERVICE_ALL_ACCESS );

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls End   - Open %ls service",
            m_sDisplayName, m_sComputer, m_sServiceName );
   }
   
   if ( !hSvc )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case ERROR_SERVICE_DOES_NOT_EXIST:
            break; // no message for this case
         default:
            err.SysMsgWrite(
                  ErrW,
                  rcOs,
                  DCT_MSG_OPEN_SERVICE_FAILED_SSD,
                  m_sComputer,
                  m_sServiceName,
                  rcOs );
            break;
      }
      rcOs = 0;
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Create %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }

      hSvc = CreateService( m_hScm,     // SCM database handle
            m_sServiceName,             // Name of service
            m_sDisplayName,             // Display name
            SERVICE_ALL_ACCESS,         // Type of access to service
            SERVICE_WIN32_OWN_PROCESS,  // Type of service
            m_StartType,                // When to start service
            SERVICE_ERROR_NORMAL,       // Severity if service fails to start
            sFile,                      // Name of binary file
            NULL,                       // Name of load ordering group
            NULL,                       // Variable to get tag identifier
 //           m_sDependencies,            // Array of dependency names
            NULL,
            *m_sServiceAccount ? m_sServiceAccount : NULL,          // Account name of service
            *m_sServiceAccountPassword ? m_sServiceAccountPassword : NULL); // Password for service account

      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End   - Create %ls service",
               m_sDisplayName,m_sComputer,m_sServiceName );
      }
      if ( !hSvc )
      {
         rcOs = GetLastError();
         
         err.SysMsgWrite(
               ErrW,
               rcOs,
               DCT_MSG_CREATE_SERVICE_FAILED_SSSSD,
               m_sServiceName,
               m_sDisplayName,
               sFile,
               m_sDependencies,
               rcOs );
      }
   }
   else
   {
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Configure %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }
      
      bRc = ChangeServiceConfig(
            hSvc,                       // service handle
            SERVICE_WIN32_OWN_PROCESS,  // Type of service
            m_StartType,                // When to start service
            SERVICE_ERROR_NORMAL,       // Severity if service fails to start
            sFile,                      // Name of binary file
            NULL,                       // Name of load ordering group
            NULL,                       // Variable to get tag identifier
            m_sDependencies,            // Array of dependency names
            *m_sServiceAccount ? m_sServiceAccount : NULL,          // Account name of service
            *m_sServiceAccountPassword ? m_sServiceAccountPassword : NULL,  // Password for service account
            m_sDisplayName );           // Display name
      
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End   - Configure %ls service",
               m_sDisplayName,m_sComputer, m_sServiceName );
      }
      if ( !bRc )
      {
         rcOs = GetLastError();
         err.SysMsgWrite(
               ErrW,
               rcOs,
               DCT_MSG_CHANGE_SERVICE_CONFIG_FAILED_SSSSD,
               m_sServiceName,
               m_sDisplayName,
               sFile,
               m_sDependencies,
               rcOs );
      }

   }

   if ( hSvc )
   {
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Start %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }
      int nCnt = 0;
      do
      {
         bRc = StartService( hSvc, 0, NULL );
         if ( !bRc )
         {
            Sleep(5000);
            nCnt++;
            err.DbgMsgWrite(0, L"Start service failed.");
         }
      } while ( !bRc && nCnt < 5 );
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End   - Start %ls service",
               m_sDisplayName, m_sComputer, m_sServiceName );
      }
      if ( !bRc ) 
      {
         rcOs = GetLastError();
         err.SysMsgWrite(
               ErrW,
               rcOs,
               DCT_MSG_START_SERVICE_FAILED_SD,
               m_sServiceName,
               rcOs );
      }
      else
      {
         Sleep( 2000 ); // give the service two seconds to get going
      }
      CloseServiceHandle( hSvc );
   }

   return rcOs;
}

//-----------------------------------------------------------------------------
// Stop the service if it is running
//-----------------------------------------------------------------------------

void
   TDCTInstall::ServiceStop()
{
   DWORD                     rcOs=0;       // OS return code
   SC_HANDLE                 hSvc;         // Service handle
   SERVICE_STATUS            SvcStat;      // Service status
   DWORD                     i;
   BOOL                      bRc;

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls Start - Open %ls service",
            m_sDisplayName, m_sComputer,m_sServiceName );
   }

   hSvc = OpenService(
         m_hScm,
         m_sServiceName,
         SERVICE_STOP | SERVICE_INTERROGATE );

   if ( DebugLogging() )
   {
      err.DbgMsgWrite(
            ErrI,
            L"%ls install on %ls End   - Open %ls service",
            m_sDisplayName, m_sComputer, m_sServiceName );
   }
   if ( !hSvc )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case ERROR_SERVICE_DOES_NOT_EXIST:
            break; // no message for this case
         default:
            err.SysMsgWrite(
                  ErrW,
                  rcOs,
                  DCT_MSG_OPEN_SERVICE_FAILED_SSD,
                  m_sComputer,
                  m_sServiceName,
                  rcOs );
            break;
      }
   }
   else
   {
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls Start - Interrogate %ls service",
               m_sDisplayName,m_sComputer,m_sServiceName );
      }
      bRc = ControlService( hSvc, SERVICE_CONTROL_INTERROGATE, &SvcStat );
      if ( DebugLogging() )
      {
         err.DbgMsgWrite(
               ErrI,
               L"%ls install on %ls End - Interrogate %ls service",
               m_sDisplayName,m_sComputer,m_sServiceName );
      }
      if ( bRc )
      {
         if ( SvcStat.dwCurrentState != SERVICE_STOPPED )
         {  // Service is running
            if ( DebugLogging() )
            {
               err.DbgMsgWrite(
                     ErrI,
                     L"%ls install on %ls Start - Stop %ls service",
                     m_sDisplayName,m_sComputer,m_sServiceName);
            }
            bRc = ControlService( hSvc, SERVICE_CONTROL_STOP, &SvcStat );
            if ( DebugLogging() )
            {
               err.DbgMsgWrite(
                     ErrI,
                     L"%ls on %ls End   - Stop %ls service",
                     m_sDisplayName,m_sComputer,m_sServiceName);
            }
            if ( bRc )
            {  // Service accepted the stop request
               for ( i = 0;  i < 10;  i++ ) // 30 seconds total
               {
                  Sleep( 3000 ); // three seconds
                  if ( DebugLogging() )
                  {
                     err.DbgMsgWrite(
                           ErrI,
                           L"%ls install on %ls Start - Interrogate %ls service",
                           m_sDisplayName,m_sComputer,m_sServiceName);
                  }
                  bRc = ControlService(
                        hSvc,
                        SERVICE_CONTROL_INTERROGATE,
                        &SvcStat );
                  if ( DebugLogging() )
                  {
                     err.DbgMsgWrite(
                           ErrI,
                           L"%ls install on %ls End   - Interrogate %ls service",
                           m_sDisplayName,m_sComputer,m_sServiceName);
                  }
                  if ( !bRc )
                     break;
                  if ( SvcStat.dwCurrentState == SERVICE_STOPPED )
                     break;
               }
               if ( SvcStat.dwCurrentState != SERVICE_STOPPED )
               {
                  rcOs = GetLastError();
                  switch ( rcOs )
                  {
                     case 0:
                     case ERROR_SERVICE_NOT_ACTIVE: // Service is not running
                        break;
                     default:
                        err.SysMsgWrite(
                              ErrW,
                              rcOs,
                              DCT_MSG_SERVICE_STOP_FAILED_SSD,
                              m_sComputer,
                              m_sServiceName,
                              rcOs );
                        break;
                  }
               }
            }
         }
      }
      else
      {
         rcOs = GetLastError();
         rcOs = 0;
      }
      CloseServiceHandle( hSvc );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\tfile.cpp ===
//#pragma title("TFile - Install File class")

/*---------------------------------------------------------------------------
  File: TFile.CPP

  Comments: This file contains file installation functions.

  (c) Copyright 1995-1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Author:  Juan Medrano                                                                            l
  Revision By: Christy Boles
  Revised on 7/9/97

 ---------------------------------------------------------------------------*/

#ifdef USE_STDAFX
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include <tchar.h>
#include "Common.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "TReg.hpp"
#include "TFile.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct     err;


//----------------------------------------------------------------------------
// TInstallFile::TInstallFile - constructor initializes variables and if 
// pszFileDir is specified, it will get file information for the file located
// in that directory.
//----------------------------------------------------------------------------
   TInstallFile::TInstallFile(
      TCHAR const * pszFileName,             // in  -file name (not a full path)
      TCHAR const * pszFileDir,              // in  -directory path (without file name)
      BOOL          silent
   )
{
   m_bCopyNeeded = FALSE;
   m_VersionInfo = NULL;
   m_dwLanguageCode = 0;
   m_szFileName[0] = 0;
   m_szFilePath[0] = 0;
   m_szTargetPath[0] = 0;
   m_szFileVersion[0] = 0;
   m_szFileSize[0] = 0;
   m_szFileDateTime[0] = 0;
   m_bSilent = silent;

   ZeroMemory( &m_FixedFileInfo, sizeof m_FixedFileInfo );
   ZeroMemory( &m_FileData, sizeof m_FileData );

   if ( pszFileName )
   {
      safecopy(m_szFileName,pszFileName);
   }

   if ( pszFileDir )
   {
      OpenFileInfo( pszFileDir );
   }
}

//----------------------------------------------------------------------------
// TInstallFile::OpenFileInfo - gathers file information (file size, mod time,
// version info) and stores it in member variables for later use.
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TInstallFile::OpenFileInfo(
      TCHAR const * pszFileDir               // in  -directory path (without filename)
   )
{
   DWORD                rc = 0;              // OS return code
   DWORD                dwBytes;             // version info structure size
   DWORD                dwHandle;            // version info handle
   DWORD              * dwVerPointer;        // pointer to version language code
   UINT                 uBytes;              // version info size
   HANDLE               hFile;               // file handle
   VS_FIXEDFILEINFO   * lpBuffer;            // pointer to version info structure

   // construct a full path for the file
   safecopy(m_szFilePath,pszFileDir);
   UStrCpy(m_szFilePath + UStrLen(m_szFilePath),TEXT("\\"));
   UStrCpy(m_szFilePath + UStrLen(m_szFilePath),m_szFileName);

   // get file size, mod time info
   hFile = FindFirstFile( m_szFilePath, &m_FileData );
   if ( hFile == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( ! m_bSilent )
      {
         err.SysMsgWrite( 0,
                       rc,
                       DCT_MSG_OPEN_FILE_INFO_FAILED_SD,
                       m_szFilePath,
                       rc );
      }
   }
   else
   {
      FindClose( hFile );
      dwBytes = GetFileVersionInfoSize( m_szFilePath, &dwHandle );
      if ( dwBytes <= 0 )
      {
         //err.MsgWrite( 0,
         //             "No version resource: %ls",
         //             m_szFilePath );
      }
      else
      {
         delete [] m_VersionInfo;
         m_VersionInfo = new WCHAR[dwBytes + 1];

         // get version resource info
         if ( ! GetFileVersionInfo( m_szFilePath, 
                                    0, 
                                    dwBytes, 
                                    m_VersionInfo ) )
         {
            rc = GetLastError();
            if ( ! m_bSilent )
            {

               err.SysMsgWrite( 0,
                             rc,
                             DCT_MSG_GET_VERSION_INFO_FAILED_SD,
                             m_szFilePath,
                             rc );
            }
         }
         else
         {
            // get fixed file info
            if ( ! VerQueryValue( m_VersionInfo,
                                  TEXT("\\"),
                                  (void **) &lpBuffer,
                                  &uBytes) )
            {
               if ( ! m_bSilent )
               {
                  err.MsgWrite( 0,
                             DCT_MSG_VER_QUERY_VALUE_FAILED_SS,           
                             m_szFilePath,
                             L"\\");
               }
            }
            else
            {
               m_FixedFileInfo = *lpBuffer;

               // get variable file info language code
               if ( ! VerQueryValue( m_VersionInfo,  
                                     TEXT("\\VarFileInfo\\Translation"), 
                                     (void **) &dwVerPointer, 
                                     &uBytes) )
               {
                  if ( ! m_bSilent )
                  {
                     err.MsgWrite( 0,
                                DCT_MSG_VER_QUERY_VALUE_FAILED_SS,
                                m_szFilePath,
                                L"\\VarFileInfo\\Translation");
                  }
               }
               else
               {
                  m_dwLanguageCode = *dwVerPointer;
               }
            }
         }
      }
   }

   return rc;
}

//----------------------------------------------------------------------------
// TInstallFile::CopyTo - copies the file to a destination path. if it is busy,
// renames the file and tries to copy again.
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TInstallFile::CopyTo(
      TCHAR const * pszDestinationPath       // in  -destination path (full path)
   )
{
   DWORD    rc = 0;                          // OS return code
   DWORD    dwFileAttributes;                // file attribute mask

   // make sure read-only flag of destination is turned off
   dwFileAttributes = ::GetFileAttributes( pszDestinationPath );
   if ( dwFileAttributes != 0xFFFFFFFF )
   {
      // Turn off read-only file attribute
      if ( dwFileAttributes & FILE_ATTRIBUTE_READONLY )
      {
         ::SetFileAttributes( pszDestinationPath, 
                              dwFileAttributes & ~FILE_ATTRIBUTE_READONLY );
      }
   }

   // copy file to destination path
   if ( ! ::CopyFile( m_szFilePath, pszDestinationPath, FALSE ) )
   {
      rc = GetLastError();
      err.SysMsgWrite( 0,
                       rc,
                       DCT_MSG_COPY_FILE_FAILED_SSD,
                       m_szFilePath,
                       pszDestinationPath,
                       rc );

      if ( rc == ERROR_SHARING_VIOLATION || rc == ERROR_USER_MAPPED_FILE )
      {
         // file was busy, we need to rename it and try again

         // create temp filename
         TCHAR               szDestDir[MAX_PATH];
         TCHAR               szTempFile[MAX_PATH];

         safecopy(szDestDir,pszDestinationPath);
         
         TCHAR             * lastSlash = _tcsrchr(szDestDir,_T('\\'));
         
         if ( lastSlash )
         {
            (*lastSlash) = 0;
         }

         if ( ! ::GetTempFileName( szDestDir, TEXT("~MC"), 0, szTempFile ) )
         {
            rc = GetLastError();
            err.SysMsgWrite( 0,
                             rc,
                             DCT_MSG_GET_TEMP_FILENAME_FAILED_D,
                             rc );
         }
         else
         {
            DeleteFile( szTempFile );

            // rename destination to temp filename
            if ( ! ::MoveFile( pszDestinationPath, szTempFile ) )
            {
               rc = GetLastError();
               err.SysMsgWrite( 0,
                                rc,
                                DCT_MSG_MOVE_FILE_FAILED_SSD,
                                pszDestinationPath,
                                szTempFile,
                                rc );

               // can't rename, try rename on reboot

               if ( ! ::CopyFile( m_szFilePath, szTempFile, FALSE ) )
               {
                  rc = GetLastError();
                  err.SysMsgWrite( 0,
                                   rc,
                                   DCT_MSG_COPY_FILE_FAILED_SSD,
                                   m_szFilePath,
                                   szTempFile,
                                   rc );
               }
               else
               {
                  err.MsgWrite( 0,
                                DCT_MSG_SOURCE_COPIED_TO_TEMP_SS,
                                m_szFilePath,
                                szTempFile );

                  
                  if ( ! ::MoveFileEx( szTempFile, pszDestinationPath, 
                                       MOVEFILE_DELAY_UNTIL_REBOOT ) )
                  {
                     rc = GetLastError();
                     err.SysMsgWrite( 0,
                                      rc,
                                      DCT_MSG_MOVE_FILE_EX_FAILED_SSD,
                                      szTempFile,
                                      pszDestinationPath,
                                      rc );
                  }
                  else
                  {
                     err.MsgWrite( 0,
                                    DCT_MSG_RENAME_ON_REBOOT_SS,  
                                   szTempFile,
                                   pszDestinationPath );
                  }
               }
            }
            else
            {
               err.MsgWrite( 0,
                             DCT_MSG_BUSY_FILE_RENAMED_SS,           
                             pszDestinationPath,
                             szTempFile );

               if ( ! ::MoveFileEx( szTempFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT ) )
               {
                  rc = GetLastError();
                  err.SysMsgWrite( 0,
                                   rc,
                                   DCT_MSG_MOVE_FILE_EX_FAILED_SSD,
                                   szTempFile,
                                   L"NULL",
                                   rc );
               }
               // try to copy again
               if ( ! ::CopyFile( m_szFilePath, pszDestinationPath, FALSE ) )
               {
                  rc = GetLastError();
                  err.SysMsgWrite( 0,
                                   rc,
                                   DCT_MSG_COPY_FILE_FAILED_SSD,
                                   m_szFilePath,
                                   pszDestinationPath,
                                   rc );
               }
               else
               {
                  err.MsgWrite( 0,
                                DCT_MSG_FILE_COPIED_2ND_ATTEMPT_SS,           
                                m_szFilePath,
                                pszDestinationPath );
               }
            }
         }
      }
   }

   return rc;
}

//----------------------------------------------------------------------------
// TInstallFile::CompareFile - compares the version, date, and size of the 
// file object to the given target file object
//----------------------------------------------------------------------------
int                                          // ret -(-1) if source < target
   TInstallFile::CompareFile(                //      ( 0) if source = target
                                             //      ( 1) if source > target
      TInstallFile * pFileTrg                // in  -target file object
   )
{
   int      nComp;                           // comparison result

   nComp = CompareFileVersion( pFileTrg );
   if ( nComp == 0 )
   {
      // versions are the same, compare dates
      nComp = CompareFileDateTime( pFileTrg );
      if ( nComp <= 0 )
      {
         // source date is less than or equal to target date
         // compare file size
         nComp = CompareFileSize( pFileTrg );
         if ( nComp != 0 )
         {
            // file sizes are not equal, return (source > target)
            nComp = 1;
         }
      }
   }

   return nComp;
}

//----------------------------------------------------------------------------
// TInstallFile::CompareFileSize - compares the file size of the this file 
// object with the size of the target file object
//----------------------------------------------------------------------------
int                                       // ret -(-1) if source < target
   TInstallFile::CompareFileSize(         //      ( 0) if source = target
                                          //      ( 1) if source > target
      TInstallFile * pFileTrg             // in  -target file object
   )
{
   int      nCompResult = 0;              // comparison result  
   DWORD    dwSrcFileSize = 0;            // source file size
   DWORD    dwTrgFileSize = 0;            // target file size

   dwSrcFileSize = m_FileData.nFileSizeLow;
   dwTrgFileSize = pFileTrg->m_FileData.nFileSizeLow;

   if ( dwSrcFileSize && dwTrgFileSize )
   {
      if ( dwSrcFileSize < dwTrgFileSize )
      {
         nCompResult = -1;
      }
      else if ( dwSrcFileSize > dwTrgFileSize )
      {
         nCompResult = 1;
      }
   }

   return nCompResult;
}

//----------------------------------------------------------------------------
// TInstallFile::CompareFileDateTime - compares the file modification time of
// this file object with the time of the target file object
//----------------------------------------------------------------------------
int                                       // ret -(-1) if source < target
   TInstallFile::CompareFileDateTime(     //      ( 0) if source = target
                                          //      ( 1) if source > target
      TInstallFile * pFileTrg             // in  -target file object
   )
{
   int   nCompResult = 0;                 // comparison result

   __int64 cmp = *(__int64*)&m_FileData.ftLastWriteTime - 
                 *(__int64*)&pFileTrg->m_FileData.ftLastWriteTime;
   if ( cmp )
   {
      // The following lines do a "fuzzy" compare so that file systems that
      // store timestamps with different precision levels can be compared for
      // equivalence.  20,000,000 represents the number of 100ns intervals in
      // a FAT/HPFS twosec file timestamp.
      if ( cmp < 0 )
      {
         cmp = -cmp;
      }
      
      if ( cmp >= 20000000 )
      {
         // the timestamps differ by more than 2 seconds, so we need to
         // compare the filetime structures
        nCompResult = CompareFileTime( &m_FileData.ftLastWriteTime, 
                                       &pFileTrg->m_FileData.ftLastWriteTime );
      }
   }

   return nCompResult;
}

//---------------------------------------------------------------
// TInstallFile::CompareFileVersion - compares the version of this
// file object with the version of the target file object
//---------------------------------------------------------------
int                                    // ret -(-1) if source version < target version 
   TInstallFile::CompareFileVersion(   //      ( 0) if source version = target version
                                       //      ( 1) if source version > target version
      TInstallFile * pFileTrg          // in  -target file object
   )
{
   int         nCompResult = 0;        // comparison result
   DWORDLONG   dwlSrcVersion = 0;      // source version
   DWORDLONG   dwlTrgVersion = 0;      // target version

   dwlSrcVersion = ((DWORDLONG)m_FixedFileInfo.dwFileVersionMS << 32) |
                    (DWORDLONG)m_FixedFileInfo.dwFileVersionLS;

   dwlTrgVersion = ((DWORDLONG)pFileTrg->m_FixedFileInfo.dwFileVersionMS << 32) |
                    (DWORDLONG)pFileTrg->m_FixedFileInfo.dwFileVersionLS;

   if ( dwlTrgVersion )
   {
      if ( dwlSrcVersion < dwlTrgVersion )
      {
         nCompResult = -1;
      }
      else if ( dwlSrcVersion > dwlTrgVersion )
      {
         nCompResult = 1;
      }
   }
   else
   {
      nCompResult = 1;
   }

   return nCompResult;
}

//---------------------------------------------------------------
// TInstallFile::GetFileVersion - retrieves the version as separate
// components:  Major, Minor, Release, Modification
//---------------------------------------------------------------
void                                   
   TInstallFile::GetFileVersion(   
      UINT           * uVerMaj,              // out -major version
      UINT           * uVerMin,              // out -minor version
      UINT           * uVerRel,              // out -release version
      UINT           * uVerMod               // out -modification version
   )
{
   *uVerMaj = HIWORD(m_FixedFileInfo.dwFileVersionMS);
   *uVerMin = LOWORD(m_FixedFileInfo.dwFileVersionMS);
   *uVerRel = HIWORD(m_FixedFileInfo.dwFileVersionLS);
   *uVerMod = LOWORD(m_FixedFileInfo.dwFileVersionLS);
}

//---------------------------------------------------------------
// TInstallFile::GetFileVersionString - retrieves the FileVersion 
// string of the version resource
//---------------------------------------------------------------
TCHAR *                                      // ret -version string
   TInstallFile::GetFileVersionString()
{
   UINT     uBytes;                          // size of version info
   TCHAR  * szBuffer;                        // version info buffer

   if ( m_VersionInfo && m_szFileVersion[0] == 0 )
   {
      TCHAR  szStrFileInfo[MAX_PATH];
      _stprintf(szStrFileInfo,TEXT( "\\StringFileInfo\\%04X%04X\\FileVersion"), 
                            LOWORD(m_dwLanguageCode), HIWORD(m_dwLanguageCode) );

      if ( ! VerQueryValue( m_VersionInfo,
                            szStrFileInfo,
                            (void **) &szBuffer,
                            &uBytes) )
      {
         err.MsgWrite( 0,
                       DCT_MSG_VER_QUERY_VALUE_FAILED_SS,
                       m_szFilePath,
                       szStrFileInfo );
      }
      else
      {
         safecopy(m_szFileVersion,szBuffer);
      }
   }

   return m_szFileVersion;
}

//---------------------------------------------------------------
// TInstallFile::GetFileSizeString - retrieves the file size as a string
//---------------------------------------------------------------
TCHAR *                                      // ret -file size string
   TInstallFile::GetFileSizeString()
{
   _stprintf(m_szFileSize,TEXT("%ld"), m_FileData.nFileSizeLow );
   return m_szFileSize;
}

//---------------------------------------------------------------
// TInstallFile::GetFileDateTimeString - retrieves the file modification
// time as a string
//---------------------------------------------------------------
TCHAR *                                      // ret -file mod string             
   TInstallFile::GetFileDateTimeString(
      TCHAR const * szFormatString           // in  -date/time format string
   )
{
   //safecopy(m_szFileDateTime,ctime(m_FileData.ftLastWriteTime));
   return m_szFileDateTime;
}

//----------------------------------------------------------------------------
// TInstallFile::IsBusy - determines if the file is busy by trying to open it
// for reading and writing.
//----------------------------------------------------------------------------
BOOL                                         // ret -TRUE if the file is busy
   TInstallFile::IsBusy()                    //     -FALSE otherwise
{
   BOOL     bIsBusy = FALSE;                 // is the file busy?
   HANDLE   hFile;                           // file handle
   DWORD    rc;                              // OS return code

   // try to open file for read and write
   hFile = CreateFile( m_szFilePath,
                       GENERIC_READ | GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );
   if ( hFile == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( rc == ERROR_ACCESS_DENIED || rc == ERROR_SHARING_VIOLATION )
      {
         err.MsgWrite( 0,
                       DCT_MSG_FILE_IN_USE_S,           
                       m_szFilePath );
         bIsBusy = TRUE;
      }
      else
      {
         if ( ! m_bSilent )
            err.SysMsgWrite( 0,
                          rc,
                          DCT_MSG_CREATE_FILE_FAILED_SD,
                          m_szFilePath,
                          rc );
      }
   }
   else
   {
      CloseHandle( hFile );
   }

   return bIsBusy;
}

//----------------------------------------------------------------------------
// TDllFile::TDllFile - constructor for DLL file objects.
//----------------------------------------------------------------------------
   TDllFile::TDllFile(
      TCHAR const * pszFileName,             // in  -file name (not a full path)
      TCHAR const * pszFileDir,              // in  -directory (without file name)
      TCHAR const * pszProgId,               // in  -Prog ID (for OCX's)
      BOOL          bSystemFile              // in  -TRUE if file is a system file
   ) : TInstallFile( pszFileName, pszFileDir )
{
   m_bSystemFile = bSystemFile;
   m_bRegistrationNeeded = FALSE;
   m_bRegisterTarget = FALSE;
   m_szProgId[0] = 0;
   m_szRegPath[0] = 0;

   if ( pszProgId )
   {
      safecopy(m_szProgId,pszProgId);
   }
}

//----------------------------------------------------------------------------
// TDllFile::SupportsSelfReg - determines whether the file supports self-registration
//----------------------------------------------------------------------------
BOOL                                         // ret -TRUE if file supports self-reg
   TDllFile::SupportsSelfReg()               //     -FALSE otherwise
{
   BOOL        bSelfReg = FALSE;             // supports self-reg?
   UINT        uBytes;                       // size of version info
   TCHAR     * szBuffer;                     // version info buffer

   if ( m_VersionInfo )
   {
      TCHAR szStrFileInfo[MAX_PATH];
      _stprintf(szStrFileInfo,TEXT("\\StringFileInfo\\%04X%04X\\OLESelfRegister"), 
                            LOWORD(m_dwLanguageCode), HIWORD(m_dwLanguageCode) );

      if ( ! VerQueryValue( m_VersionInfo,
                            szStrFileInfo,
                            (void **) &szBuffer,
                            &uBytes) )
      {
         if ( *m_szProgId )
         {
            bSelfReg = TRUE;
         }
         else
         {
            err.MsgWrite( 0,
                          DCT_MSG_FILE_NO_SELF_REGISTRATION_S,
                          m_szFilePath );
         }
      }
      else
      {
         bSelfReg = TRUE;
      }
   }

   return bSelfReg;
}

//----------------------------------------------------------------------------
// TDllFile::IsRegistered - determines whether a file is registered
//----------------------------------------------------------------------------
BOOL                                         // ret -TRUE if file is registered
   TDllFile::IsRegistered()                  //     -FALSE otherwise
{
   BOOL              bIsRegistered = FALSE;  // is the file registered?
   DWORD             rc;                     // OS return code
   HRESULT           hr;                     // OLE return code
   CLSID             clsid;                  // CLSID for registered class
   IClassFactory   * pICFGetClassObject;     // ClassFactory interface
   TCHAR             szBuffer[MAX_PATH];     // registry key buffer

   // initialize OLE
   CoInitialize( NULL );
   hr = CLSIDFromProgID( SysAllocString(m_szProgId), &clsid );
   if ( SUCCEEDED( hr ) )
   {
      hr = CoGetClassObject( clsid, 
                             CLSCTX_ALL, 
                             NULL, 
                             IID_IClassFactory, 
                             (void **)&pICFGetClassObject );
      if ( SUCCEEDED( hr ) )
      {
         bIsRegistered = TRUE;
         pICFGetClassObject->Release();
      }
   }
   CoUninitialize();

   if ( bIsRegistered )
   {
      WCHAR                  szKeyName[MAX_PATH];

      safecopy(szKeyName,m_szProgId);

      UStrCpy(szKeyName + UStrLen(szKeyName),"\\CLSID");
      
      TRegKey regKey;

      rc = regKey.OpenRead( szKeyName, HKEY_CLASSES_ROOT );
      if ( ! rc )
      {
         rc = regKey.ValueGetStr( _T(""), szBuffer, sizeof szBuffer );
         if ( ! rc )
         {
            regKey.Close();
            UStrCpy(szKeyName,"CLSID\\");
            UStrCpy(szKeyName + UStrLen(szKeyName),szBuffer);
            UStrCpy(szKeyName + UStrLen(szKeyName),"\\InProcServer32");
            
            rc = regKey.OpenRead( szKeyName, HKEY_CLASSES_ROOT );
            if ( ! rc )
            {
               rc = regKey.ValueGetStr( _T(""), szBuffer, sizeof szBuffer );
               if ( ! rc )
               {
                  regKey.Close();
                  safecopy(m_szRegPath,szBuffer);
                  bIsRegistered = TRUE;
               }
            }
         }
      }
   }

   return bIsRegistered;
}

//----------------------------------------------------------------------------
// TDllFile::CallDllFunction - call an exported function of a dll
//----------------------------------------------------------------------------
DWORD                                        // ret -TRUE if function call success
   TDllFile::CallDllFunction(                //      FALSE if function call failure
      TCHAR const * pszFunctionName,         // in  -Exported function name
      TCHAR const * pszDllName               // in  -name of dll file
   )
{
   DWORD       rc = 0;                       // OS return code
   HINSTANCE   hLib;                         // handle
   
   WCHAR                     szDllNameUsed[MAX_PATH];
   char                      pszFunctionNameA[MAX_PATH];

   safecopy(pszFunctionNameA,pszFunctionName);

   if ( pszDllName )
   {
      safecopy(szDllNameUsed,pszDllName);
   }
   else
   {
      safecopy(szDllNameUsed,m_szFilePath);
   }

   // load the dll into memory
   hLib = LoadLibrary( szDllNameUsed );
   if ( ! hLib )
   {
      rc = GetLastError();
      err.SysMsgWrite( 0,
                       rc,
                       DCT_MSG_LOAD_LIBRARY_FAILED_SD,
                       szDllNameUsed,
                       rc );
   }
   else
   {
      // Find the entry point.
      FARPROC lpDllEntryPoint = GetProcAddress( hLib, pszFunctionNameA );
      if ( lpDllEntryPoint == NULL )
      {
         rc = GetLastError();
         err.SysMsgWrite( 0,
                          rc,
                          DCT_MSG_GET_PROC_ADDRESS_FAILED_SSD,
                          szDllNameUsed,
                          pszFunctionName,
                          rc );
      }
      else
      {
         // call the dll function
         rc = (DWORD)(*lpDllEntryPoint)();
      }

      FreeLibrary( hLib );
   }

   return rc;
}

//----------------------------------------------------------------------------
// TDllFile::Register - registers the file
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TDllFile::Register()
{
   DWORD rc = 0;                             // OS return code
   TCHAR const szFunctionName[MAX_PATH] = _T("DllRegisterServer");

   if ( m_bRegisterTarget )
   {
      rc = CallDllFunction( szFunctionName, m_szTargetPath );
   }
   else
   {
      rc = CallDllFunction( szFunctionName );
   }

  
   if ( rc )
   {
      err.MsgWrite( 0,
                    DCT_MSG_DLL_CALL_FAILED_SDS,
                    szFunctionName,
                    rc,
                    "failed to register object classes" );
   }

   return rc;
}

//----------------------------------------------------------------------------
// TDllFile::Unregister - unregisters the file
//----------------------------------------------------------------------------
DWORD                                        // ret -last OS return code
   TDllFile::Unregister()
{
   DWORD rc = 0;                             // OS return code
   TCHAR const szFunctionName[MAX_PATH] = _T("DllUnregisterServer");

   if ( m_bRegisterTarget )
   {
      rc = CallDllFunction( szFunctionName, m_szTargetPath );
   }
   else
   {
      rc = CallDllFunction( szFunctionName );
   }

   if ( rc )
   {
      err.MsgWrite( 0,
                    DCT_MSG_DLL_CALL_FAILED_SDS,
                    szFunctionName,
                    rc,
                    "failed to unregister object classes" );
   }
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\documents\help-ms\helpid.h ===
#define IDH_INTRO_DOMAIN_MIGRATOR                 1000

#define IDH_HOWTO_OVERVIEW                        2000
#define IDH_HOWTO_START_DM                        2010
#define IDH_HOWTO_MIGRATE_TRUSTS                  2015
#define IDH_HOWTO_MERGE_GROUPS                    2017
#define IDH_HOWTO_MIGRATE_USERS                   2020
#define IDH_HOWTO_MIGRATE_GROUPS                  2030
#define IDH_HOWTO_MIGRATE_COMPUTERS               2040
#define IDH_HOWTO_MIGRATE_SERVICE_ACCOUNTS        2045
#define IDH_HOWTO_RESOLVE_SECURITY                2050
#define IDH_HOWTO_RESOLVE_EXCHANGE                2060
#define IDH_HOWTO_RETRY_TASK                      2070
#define IDH_HOWTO_UNDO_LAST_OPERATION             2080
#define IDH_HOWTO_GENERATE_REPORTS                2090

#define IDH_CONCEPT_OVERVIEW                      3000
#define IDH_CONCEPT_REQUIREMENT                   3010
#define IDH_CONCEPT_SECURITY_ISSUE                3020
#define IDH_CONCEPT_ACCOUNT_MIGRATION             3030
#define IDH_CONCEPT_COMPUTER_MIGRATION            3040
#define IDH_CONCEPT_SECURITY_TRANSLATION          3050
#define IDH_CONCEPT_EXCHANGE_TRANSLATION          3060
#define IDH_CONCEPT_TRUST_MIGRATION               3070
#define IDH_CONCEPT_UNDERSTAND_UI                 3100
#define IDH_CONCEPT_UI_CONSOLE_WINDOW             3110
#define IDH_CONCEPT_UI_MENUS                      3120

#define IDH_WINDOW_OVERVIEW                       4000
#define IDH_WINDOW_WELCOME                        4010
#define IDH_WINDOW_DOMAIN_SELECTION               4020
#define IDH_WINDOW_USER_SELECTION                 4030
#define IDH_WINDOW_GROUP_SELECTION                4040
#define IDH_WINDOW_TARGET_GROUP_SELECTION         4045
#define IDH_WINDOW_COMPUTER_SELECTION             4050
#define IDH_WINDOW_TASK_SELECTION                 4060
#define IDH_WINDOW_DIRECTORY_SELECTION            4070
#define IDH_WINDOW_OU_SELECTION                   4080
#define IDH_WINDOW_OBJECTTYPE_SELECTION           4090
#define IDH_WINDOW_REPORT_SELECTION               4100
#define IDH_WINDOW_SERVICE_ACCOUNT_SELECTION      4110
#define IDH_WINDOW_EXCHANGE_SERVER_SELECTION      4120
#define IDH_WINDOW_PASSWORD_OPTION                4200
#define IDH_WINDOW_ACCOUNTTRANSITION_OPTION       4210
#define IDH_WINDOW_USER_OPTION                    4220
#define IDH_WINDOW_GROUP_OPTION                   4230
#define IDH_WINDOW_GROUP_MEMBER_OPTION            4235
#define IDH_WINDOW_SECURITY_OPTION                4240
#define IDH_WINDOW_COMPUTER_OPTION                4250
#define IDH_WINDOW_EXCHANGE_OPTION                4260
#define IDH_WINDOW_NAME_CONFLICT                  4300
#define IDH_WINDOW_SECURITY_CREDENTIALS           4310
#define IDH_WINDOW_REPORT_CREDENTIALS             4320
#define IDH_WINDOW_SIDHISTORY_CREDENTIALS         4330
#define IDH_WINDOW_AGENT_MONITOR                  4500
#define IDH_WINDOW_AGENT_MONITOR_SETTING          4510
#define IDH_WINDOW_AGENT_SERVER_LIST              4520
#define IDH_WINDOW_AGENT_SUMMARY                  4530
#define IDH_WINDOW_CONFIRMATION                   5000
#define IDH_WINDOW_COMMIT                         5010
#define IDH_WINDOW_REFRESH_INFO                   5020
#define IDH_WINDOW_SERVICE_ACCOUNT_INFO           5030
#define IDH_WINDOW_TRUST_INFO                     5040
#define IDH_WINDOW_UNDO                           5050
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\tpool.cpp ===
/*---------------------------------------------------------------------------
  File: TPooledDispatch.cpp

  Comments: Implementation of thread pool.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/22/99 11:48:28

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "StdAfx.h"
#else 
   #include <windows.h>
#endif
#include "Common.hpp"
#include "UString.hpp"
#include "Tnode.hpp"

#include "TPool.h"

// maximum number of jobs allowed
#define  MAX_COUNT   5000000

// executes a job from the thread pool
int 
   Job::Run()
{
   MCSASSERT(m_pStartRoutine);
   
   m_Status = JobStatusRunning;
   m_ThreadID = GetCurrentThreadId();
   m_timeStarted = GetTickCount();
   m_result = (m_pStartRoutine)(m_pArgs);
   m_timeEnded = GetTickCount();
   
   m_Status = JobStatusFinished;

   return m_result;
}

// Thread entry point function used by all threads in the job pool
// waits for a job and then executes it
DWORD __stdcall 
   ThreadEntryPoint(
      void                 * arg           // in - pointer to job pool
   )
{
   MCSASSERT(arg);

   TJobDispatcher          * pPool = (TJobDispatcher *)arg;
   DWORD                     result = 0;
   BOOL                      bAbort = FALSE;

   do 
   {
      if (  ! pPool->SignalForJob() )
      {

         // Now there should be a job waiting for us!
         Job                     * pJob = pPool->GetAvailableJob();

         if ( pJob )
         {
            result = pJob->Run();
         }
         else
         {
            bAbort = TRUE;
         }
      }
      else
      {
         result = (int)GetLastError();
         bAbort = TRUE;
      }
   }
   while ( ! bAbort );
   pPool->ThreadFinished();
   return result;
}

void 
   TJobDispatcher::InitThreadPool(
      DWORD                  nThreads     // in - number of threads to use
   )
{
   BOOL                      bExisted;
   DWORD                     rc;
   DWORD                     ThreadID;
   HANDLE                    hThread;

   rc = m_sem.Create(NULL,0,MAX_COUNT, &bExisted);
   if ( ! rc && ! bExisted )
   {
      m_numThreads = nThreads;
      m_numActiveThreads = m_numThreads;
      // Construct the threads
      for ( UINT i = 0 ; i < nThreads ; i++ )
      {
         hThread = CreateThread(NULL,0,&ThreadEntryPoint,this,0,&ThreadID);
         CloseHandle(hThread);
      }
   }
}

DWORD                                      // ret- OS return code
   TJobDispatcher::SignalForJob()
{
   return m_sem.WaitSingle();
}

Job * 
   TJobDispatcher::GetAvailableJob()
{
   Job                     * pJob = NULL;

   if ( ! m_Aborting ) 
   { 
      // get the first job from the 'waiting' list
      pJob = m_JobsWaiting.GetFirstJob(); 
      // and put it in the 'in progress' list
      if ( pJob )
      {
         m_JobsInProgress.InsertBottom(pJob);
      }
      else
      {
         MCSASSERT(m_JobsWaiting.Count() == 0);
      }
   }
   return pJob;
}

// Causes threads to stop when they finish their current job
// any jobs that are waiting will not be executed.
void 
   TJobDispatcher::ShutdownThreads()
{
   m_Aborting = TRUE;
   
   m_sem.Release(m_numThreads);
   // wait until all of our threads have exited, so we don't delete the thread pool out from under them.
   while ( m_numActiveThreads > 0 )
   {
      Sleep(100);
   }
}


// This function returns when all jobs are completed
void TJobDispatcher::WaitForCompletion()
{
   while ( UnfinishedJobs() )
   {
      Sleep(1000);
   }
}

// This functions returns the number of jobs that have not yet completed
int 
   TJobDispatcher::UnfinishedJobs()
{
   int                       nUnfinished = 0;
   TNodeListEnum             e;
   Job                     * j;
   
   nUnfinished += m_JobsWaiting.Count();

   
   for ( j = (Job*)e.OpenFirst(&m_JobsInProgress) ; j ; j = (Job*)e.Next() )
   {
      if ( j->GetStatus() != Job::JobStatusFinished )
         nUnfinished++;
   }
   return nUnfinished;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\disp\tinst.h ===
#ifndef __TDCTINSTALL_H__
#define __TDCTINSTALL_H__
/*---------------------------------------------------------------------------
  File: TDCTInstall.h

  Comments: Utility class to install a service.
  Current implementation is specific to the DCT service.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:32:21

 ---------------------------------------------------------------------------
*/

#include "EaLen.hpp"
#include "Common.hpp"
#include "UString.hpp"


class TDCTInstall
{
   BOOL                      m_bDebugLogging;
   WCHAR                     m_sComputer[LEN_Computer];
   WCHAR                     m_sComputerSource[LEN_Computer];
   
   // Service-specific information
   WCHAR                     m_sDisplayName[200];
   WCHAR                     m_sServiceName[200];
   WCHAR                     m_sServiceAccount[LEN_Account];
   WCHAR                     m_sServiceAccountPassword[LEN_Password];
   WCHAR                     m_sDependencies[500];

   SC_HANDLE                 m_hScm;         // SCM handle
   WCHAR                     m_sDirThis[32];
   WCHAR                     m_sExeName[200];
   DWORD                     m_StartType;
   
public:

   TDCTInstall(
      WCHAR          const * asComputer,    // in -target computer name
      WCHAR          const * srcComputer    // in -source computer name
      
   )
   {
      m_bDebugLogging = FALSE;
      safecopy( m_sComputer, asComputer );
      safecopy( m_sComputerSource, srcComputer );
      m_sDisplayName[0] = L'\0';
      m_sServiceName[0] = L'\0';
      m_sServiceAccount[0] = L'\0';
      m_sServiceAccountPassword[0] = L'\0';
      m_sDependencies[0] = L'\0';

      m_hScm = NULL;
      m_sDirThis[0] = L'\0';
      m_sExeName[0] = L'\0';
      m_StartType = SERVICE_DEMAND_START;

   }
   ~TDCTInstall()
   {
      ScmClose();
   }
   
   BOOL        DebugLogging() { return m_bDebugLogging; }
   void        DebugLogging(BOOL val) { m_bDebugLogging = val; }
   
   void        SetServiceInformation(WCHAR const * displayName, 
                                     WCHAR const * serviceName, 
                                     WCHAR const * exeName,
                                     WCHAR const * dependencies,
                                     DWORD         startType = SERVICE_DEMAND_START )
   {
      MCSASSERT(displayName && *displayName);
      MCSASSERT(serviceName && *serviceName);
      MCSASSERT(exeName && *exeName);

      safecopy(m_sDisplayName, displayName);
      safecopy(m_sServiceName, serviceName);
      safecopy(m_sExeName,exeName);
      safecopy(m_sDependencies, dependencies ? dependencies : L"");
      m_StartType = startType;
   }


   void        SetServiceAccount(WCHAR const * account, WCHAR const * password)
   {
      safecopy(m_sServiceAccount, account ? account : L"" );
      safecopy(m_sServiceAccountPassword, password ? password : L"" );
   }

   void        SourceDir(WCHAR const * dir) { safecopy(m_sDirThis,dir); }
   DWORD       ScmOpen(BOOL bSilent = FALSE);
   void        ScmClose();
   DWORD       ServiceStart();
   void        ServiceStop();

};



#endif //__TDCTINSTALL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\documents\help-ms\helpalias.h ===
IDH_INTRO_DOMAIN_MIGRATOR=DomMigIntro.htm

IDH_HOWTO_OVERVIEW=TasksOverview.htm
IDH_HOWTO_RESOLVE_EXCHANGE=TasksTranslateExchange.htm
IDH_HOWTO_RETRY_TASK=TasksRetry.htm
IDH_HOWTO_UNDO_LAST_OPERATION=TasksUndoLast.htm
IDH_HOWTO_GENERATE_REPORTS=TasksGenerateReports.htm

IDH_CONCEPT_OVERVIEW=ConceptOverview.htm
IDH_CONCEPT_SECURITY_ISSUE=ConceptDomMigSecurityIssues.htm
IDH_CONCEPT_SECURITY_TRANSLATION=ConceptSecurityTranslationIssues.htm

IDH_WINDOW_OVERVIEW=WindowOverview.htm
IDH_WINDOW_WELCOME=WindowWelcome.htm
IDH_WINDOW_DOMAIN_SELECTION=WindowDomainSelect.htm
IDH_WINDOW_USER_SELECTION=WindowUserSelect.htm
IDH_WINDOW_GROUP_SELECTION=WindowGroupSelect.htm
IDH_WINDOW_TARGET_GROUP_SELECTION=WindowTargetGroupSelect.htm
IDH_WINDOW_COMPUTER_SELECTION=WindowComputerSelect.htm
IDH_WINDOW_TASK_SELECTION=WindowTaskSelect.htm
IDH_WINDOW_DIRECTORY_SELECTION=WindowDirectorySelect.htm
IDH_WINDOW_OU_SELECTION=WindowOUSelect.htm
IDH_WINDOW_OBJECTTYPE_SELECTION=WindowObjectTypeSelect.htm
IDH_WINDOW_REPORT_SELECTION=WindowReportSelect.htm
IDH_WINDOW_SERVICE_ACCOUNT_SELECTION=WindowServiceAccountSelect.htm
IDH_WINDOW_EXCHANGE_SERVER_SELECTION=WindowExchangeServerSelect.htm
IDH_WINDOW_PASSWORD_OPTION=WindowPasswordOption.htm
IDH_WINDOW_ACCOUNTTRANSITION_OPTION=WindowAccountTransitionOption.htm
IDH_WINDOW_USER_OPTION=WindowUserOption.htm
IDH_WINDOW_GROUP_OPTION=WindowGroupOption.htm
IDH_WINDOW_GROUP_MEMBER_OPTION=WindowGroupMemberOption.htm
IDH_WINDOW_SECURITY_OPTION=WindowSecurityOption.htm
IDH_WINDOW_COMPUTER_OPTION=WindowComputerOption.htm
IDH_WINDOW_NAME_CONFLICT=WindowNameConflict.htm
IDH_WINDOW_SECURITY_CREDENTIALS=WindowSecurityCredential.htm
IDH_WINDOW_REPORT_CREDENTIALS=WindowReportCredential.htm
IDH_WINDOW_SIDHISTORY_CREDENTIALS=WindowSIDHistoryCredential.htm
IDH_WINDOW_AGENT_MONITOR=WindowAgentOverview.htm
IDH_WINDOW_AGENT_MONITOR_SETTING=WindowAgentMonSettings.htm
IDH_WINDOW_AGENT_SERVER_LIST=WindowAgentMonServers.htm
IDH_WINDOW_AGENT_SUMMARY=WindowAgentMonSummary.htm
IDH_WINDOW_CONFIRMATION=WindowConfirmation.htm
IDH_WINDOW_COMMIT=WindowCommitChanges.htm
IDH_WINDOW_REFRESH_INFO=WindowRefreshInfo.htm
IDH_WINDOW_SERVICE_ACCOUNT_INFO=WindowServiceAccountInfo.htm
IDH_WINDOW_TRUST_INFO=WindowTrustInfo.htm
IDH_WINDOW_UNDO=WindowUndo.htm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\dommigr.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "MultiSel.h"
#include <windows.h>
#include "TReg.hpp"
#include "ResStr.h"

HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   CString                   strPath, strName;
   TRegKey                   key;
   TCHAR                     szModule[2*_MAX_PATH];
   DWORD                     dwReturn = 0;
   LPOLESTR					 lpHelpFile;

	  //mmc requires we use CoTaskMemAlloc to allocate memory returned from 
      //this function
   lpHelpFile = (LPOLESTR) CoTaskMemAlloc( 2 * MAX_PATH * sizeof(WCHAR) );
   if ( !lpHelpFile )
   {
       return E_OUTOFMEMORY;
   }

   dwReturn = key.Open(GET_STRING(IDS_DOMAIN_ADMIN_REGKEY),HKEY_LOCAL_MACHINE);
   if ( ! dwReturn )
   {
      dwReturn = key.ValueGetStr(L"Directory",szModule,DIM(szModule));
      if (! dwReturn )
      {
         strPath = szModule;
         strPath += L"\\";
         strName.LoadString(IDS_HELPFILE);
         strPath += strName;
      }
   }
   wcscpy(lpHelpFile, strPath);
   *bstrHelp = lpHelpFile;

   return HRESULT_FROM_WIN32(dwReturn);
}

/////////////////////////////////////////////////////////////////////////////
// CDomMigratorComponentData
static const GUID CDomMigratorGUID_NODETYPE = 
{ 0xe1975d72, 0x3f8e, 0x11d3, { 0x99, 0xee, 0x0, 0xc0, 0x4f, 0x39, 0xbd, 0x92 } };

HRESULT CDomMigrator::Initialize(LPUNKNOWN pUnknown)
{
	HRESULT hr = IComponentDataImpl<CDomMigrator, CDomMigratorComponent >::Initialize(pUnknown);
	if (FAILED(hr))
		return hr;

	CComPtr<IImageList> spImageList;

	if (m_spConsole->QueryScopeImageList(&spImageList) != S_OK)
	{
		ATLTRACE(_T("IConsole::QueryScopeImageList failed\n"));
		return E_UNEXPECTED;
	}

	// Load bitmaps associated with the scope pane
	// and add them to the image list
	// Loads the default bitmaps generated by the wizard
	// Change as required
	HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_16));
	if (hBitmap16 == NULL)
		return S_OK;

	HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_32));
	if (hBitmap32 == NULL)
		return S_OK;

//	if (spImageList->ImageListSetStrip((long*)hBitmap16, 
//		(long*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	if (spImageList->ImageListSetStrip((LONG_PTR*)hBitmap16, 
		(LONG_PTR*)hBitmap32, 0, RGB(0, 128, 128)) != S_OK)
	{
		ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
		return E_UNEXPECTED;
	}
	DeleteObject(hBitmap16);
	DeleteObject(hBitmap32);

	// setting root node handle to main window
	// so that the root node may disable the main
	// window when a wizard is active

	HWND hwndMainWindow = 0;
	m_spConsole->GetMainWindow(&hwndMainWindow);

	if (m_pNode)
	{
		((CRootNode*)m_pNode)->SetMainWindow(hwndMainWindow);
	}

	return S_OK;
}


STDMETHODIMP 
   CDomMigratorComponent::AddMenuItems(
      LPDATAOBJECT           pDataObject,
      LPCONTEXTMENUCALLBACK  piCallback,
      long                 * pInsertionAllowed
   )
{
   ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::AddMenuItems\n"));

   HRESULT hr = E_POINTER;

   ATLASSERT(pDataObject != NULL);
   
   if (pDataObject == NULL)
   {
      ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::AddMenuItems called with pDataObject==NULL\n"));
   }
   else
   {
      CSnapInItem          * pItem;
      DATA_OBJECT_TYPES      type;

      hr = m_pComponentData->GetDataClass(pDataObject, &pItem, &type);

      if (SUCCEEDED(hr))
      {
         hr = pItem->AddMenuItems(piCallback, pInsertionAllowed, type);
      }
      else
      {  // is it multiselection data
         SMMCDataObjects *pMsDataObjs = CMultiSelectItemDataObject::ExtractMSDataObjects(pDataObject);

         if ((pMsDataObjs) && ( pMsDataObjs->count ))
         {
            LPDATAOBJECT   pMsData;
            pMsData = pMsDataObjs->lpDataObject[0];
            FORMATETC format={(CLIPFORMAT)CMultiSelectItemDataObject::s_cfMsObjTypes,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
            hr = pMsData->QueryGetData(&format);
            if ( hr == S_OK ) 
            {
               hr = ((CMultiSelectItemDataObject *)pMsData)->AddMenuItems(piCallback, pInsertionAllowed, type);
            }
         }
      }
   }
   return hr;
}


STDMETHODIMP CDomMigratorComponent::Command(long lCommandID,
  LPDATAOBJECT pDataObject)
{
	ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenuImpl::Command\n"));

	HRESULT hr = E_POINTER;

	ATLASSERT(pDataObject != NULL);
	if (pDataObject == NULL)
		ATLTRACE2(atlTraceSnapin, 0, _T("IExtendContextMenu::Command called with pDataObject==NULL\n"));
	else
	{
		CSnapInItem          * pItem;
		DATA_OBJECT_TYPES      type;

		hr = m_pComponentData->GetDataClass(pDataObject, &pItem, &type);
		
		if (SUCCEEDED(hr))
      {
         hr = pItem->Command(lCommandID, (CSnapInObjectRootBase*)this, type);
      }
      else
      {  // is it multiselection data
         SMMCDataObjects *pMsDataObjs = CMultiSelectItemDataObject::ExtractMSDataObjects(pDataObject);

         if ((pMsDataObjs) && ( pMsDataObjs->count ))
         {
            LPDATAOBJECT   pMsData;
            pMsData = pMsDataObjs->lpDataObject[0];
            FORMATETC format={(CLIPFORMAT)CMultiSelectItemDataObject::s_cfMsObjTypes,NULL,DVASPECT_CONTENT,-1,TYMED_HGLOBAL};
            HRESULT hr = pMsData->QueryGetData(&format);
            if ( hr == S_OK ) 
            {
               hr = ((CMultiSelectItemDataObject *)pMsData)->Command(lCommandID, (CSnapInObjectRootBase*)this, type);
            }
         }
      }

	}
	return hr;
}

CDomMigrator::CDomMigrator()
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   m_pNode = new CRootNode;
	_ASSERTE(m_pNode != NULL);
	m_pComponentData = this;
   m_lpszSnapinHelpFile.LoadString(IDS_HELPFILE);
}

CDomMigrator::~CDomMigrator()
{
	delete m_pNode;
	m_pNode = NULL;
}

   /*
   On the Help menu, there should be 1 Help Topics option that displays a Contents list with both our Help and the MMC Help.
*/
STDMETHODIMP CDomMigrator::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  if (m_lpszSnapinHelpFile.IsEmpty() )
  {
    *lpCompiledHelpFile = NULL;
    return E_NOTIMPL;
  }

  return GetHelpFileFullPath(lpCompiledHelpFile);
}

STDMETHODIMP CDomMigrator::GetLinkedTopics(LPOLESTR* lpCompiledHelpFile)
{
  	AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
   if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  return GetHelpFileFullPath(lpCompiledHelpFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\dommigr.h ===
#ifndef __DOMMIGRATOR_H_
#define __DOMMIGRATOR_H_
#include "resource.h"
#include <atlsnap.h>
#include "MyNodes.h"

class CDomMigrator;

class CDomMigratorComponent : public CComObjectRootEx<CComSingleThreadModel>,
	public CSnapInObjectRoot<2, CDomMigrator >,
	public IExtendContextMenuImpl<CDomMigratorComponent>,
   public IExtendControlbarImpl<CDomMigratorComponent>,
	public IComponentImpl<CDomMigratorComponent>
{
public:
BEGIN_COM_MAP(CDomMigratorComponent)
	COM_INTERFACE_ENTRY(IComponent)
   COM_INTERFACE_ENTRY(IExtendContextMenu)
   COM_INTERFACE_ENTRY(IExtendControlbar)
END_COM_MAP()

public:
	CDomMigratorComponent()
	{
	}

	STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
	{
		if (lpDataObject != NULL)
			return IComponentImpl<CDomMigratorComponent>::Notify(lpDataObject, event, arg, param);
		// TODO : Add code to handle notifications that set lpDataObject == NULL.
		return E_NOTIMPL;
	}


   // IExtendContextMenu methods
   STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject,
      LPCONTEXTMENUCALLBACK piCallback,
      long *pInsertionAllowed);
   STDMETHOD(Command)(long lCommandID,
      LPDATAOBJECT pDataObject);

};

class CDomMigrator : public CComObjectRootEx<CComSingleThreadModel>,
public CSnapInObjectRoot<1, CDomMigrator>,
	public IComponentDataImpl<CDomMigrator, CDomMigratorComponent>,
   public IExtendContextMenuImpl<CDomMigrator>,
   public IPersistStreamInit,
   public ISnapinHelp2,
	public CComCoClass<CDomMigrator, &CLSID_DomMigrator>
{

   CString m_lpszSnapinHelpFile;
public:
	CDomMigrator();
	~CDomMigrator();
	
BEGIN_COM_MAP(CDomMigrator)
	 COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
 	COM_INTERFACE_ENTRY(IPersistStreamInit)
   COM_INTERFACE_ENTRY(ISnapinHelp)
   COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

//DECLARE_REGISTRY_RESOURCEID(IDR_DOMMIGRATOR)
static HRESULT WINAPI UpdateRegistry( BOOL bUpdateRegistry )
{
   WCHAR szBuf[256] = L"";
		
   ::LoadString(_Module.GetResourceInstance(), IDS_Title, szBuf, 256);
   _ATL_REGMAP_ENTRY         regMap[] = 
   {
      { OLESTR("TOOLNAME"),  SysAllocString(szBuf) },
      { 0, 0 }
   };
   return _Module.UpdateRegistryFromResourceD( IDR_DOMMIGRATOR, bUpdateRegistry, regMap );
}


DECLARE_NOT_AGGREGATABLE(CDomMigrator)

	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
      return S_OK;
      ATLTRACENOTIMPL(_T("CDomMigrator::GetClassID"));
   }

	STDMETHOD(IsDirty)()
	{
      return S_FALSE;
   	ATLTRACENOTIMPL(_T("CDomMigrator::IsDirty"));
	}

	STDMETHOD(Load)(IStream *pStm)
	{
	   return S_OK;
   	ATLTRACENOTIMPL(_T("CDomMigrator::Load"));
	}

	STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty)
	{
	   return S_OK;
   	ATLTRACENOTIMPL(_T("CDomMigrator::Save"));
	}

	STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
	{
	   return S_OK;
   	ATLTRACENOTIMPL(_T("CDomMigrator::GetSizeMax"));
	}

	STDMETHOD(InitNew)()
	{
		ATLTRACE(_T("CDomMigrator::InitNew\n"));
		return S_OK;
	}

	STDMETHOD(Initialize)(LPUNKNOWN pUnknown);

	static void WINAPI ObjectMain(bool bStarting)
	{
		if (bStarting)
			CSnapInItem::Init();
	}

      // ISnapinHelp2 methods
   STDMETHOD(GetHelpTopic)(LPOLESTR *lpCompiledHelpFile);
   STDMETHOD(GetLinkedTopics)(LPOLESTR *lpCompiledHelpFiles);

};

class ATL_NO_VTABLE CDomMigratorAbout : public ISnapinAbout,
	public CComObjectRoot,
	public CComCoClass< CDomMigratorAbout, &CLSID_DomMigratorAbout>
{
public:
	DECLARE_REGISTRY(CDomMigratorAbout, _T("DomMigratorAbout.1"), _T("DomMigratorAbout.1"), IDS_DOMMIGRATOR_DESC, THREADFLAGS_BOTH);

	BEGIN_COM_MAP(CDomMigratorAbout)
		COM_INTERFACE_ENTRY(ISnapinAbout)
	END_COM_MAP()

	STDMETHOD(GetSnapinDescription)(LPOLESTR *lpDescription)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_DOMMIGRATOR_DESC, szBuf, 256) == 0)
			return E_FAIL;

		*lpDescription = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpDescription == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpDescription, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetProvider)(LPOLESTR *lpName)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_DOMMIGRATOR_PROVIDER, szBuf, 256) == 0)
			return E_FAIL;

		*lpName = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpName == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpName, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinVersion)(LPOLESTR *lpVersion)
	{
		USES_CONVERSION;
		TCHAR szBuf[256];
		if (::LoadString(_Module.GetResourceInstance(), IDS_DOMMIGRATOR_VERSION, szBuf, 256) == 0)
			return E_FAIL;

		*lpVersion = (LPOLESTR)CoTaskMemAlloc((lstrlen(szBuf) + 1) * sizeof(OLECHAR));
		if (*lpVersion == NULL)
			return E_OUTOFMEMORY;

		ocscpy(*lpVersion, T2OLE(szBuf));

		return S_OK;
	}

	STDMETHOD(GetSnapinImage)(HICON *hAppIcon)
	{
		*hAppIcon = NULL;
		return S_OK;
	}

	STDMETHOD(GetStaticFolderImage)(HBITMAP *hSmallImage,
		HBITMAP *hSmallImageOpen,
		HBITMAP *hLargeImage,
		COLORREF *cMask)
	{
		*hSmallImageOpen = *hLargeImage = *hLargeImage = 0;
		return S_OK;
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\domsel.cpp ===
// DomSel.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DomSel.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDomainSelDlg dialog


CDomainSelDlg::CDomainSelDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDomainSelDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDomainSelDlg)
	m_Domain = _T("");
	//}}AFX_DATA_INIT
}


void CDomainSelDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDomainSelDlg)
	DDX_Text(pDX, IDC_DOMAIN, m_Domain);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDomainSelDlg, CDialog)
	//{{AFX_MSG_MAP(CDomainSelDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDomainSelDlg message handlers

void CDomainSelDlg::OnOK() 
{
	
   UpdateData(TRUE);

	CDialog::OnOK();
}

void CDomainSelDlg::OnCancel() 
{
	UpdateData(TRUE);

	CDialog::OnCancel();
}

BOOL CDomainSelDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\dommigsi.cpp ===
// DomMigSI.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DomMigSIps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <locale.h>

#include "DomMigSI.h"

#include "DomMigSI_i.c"
#include "DomMigr.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DomMigrator, CDomMigrator)
OBJECT_ENTRY(CLSID_DomMigratorAbout, CDomMigratorAbout)
END_OBJECT_MAP()

class CDomMigSIApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomMigSIApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CDomMigSIApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CDomMigSIApp, CWinApp)
	//{{AFX_MSG_MAP(CDomMigSIApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CDomMigSIApp theApp;

BOOL CDomMigSIApp::InitInstance()
{
	ATLTRACE(_T("{DomMigSI.dll}CDomMigSIApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _wsetlocale( LC_ALL, L".ACP" );
    _Module.Init(ObjectMap, m_hInstance, &LIBID_DOMMIGSILib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CDomMigSIApp::ExitInstance()
{
	ATLTRACE(_T("{DomMigSI.dll}CDomMigSIApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\globals.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "globals.h"

HRESULT 
   InsertNodeToScopepane( 
      IConsoleNameSpace    * pConsoleNameSpace, 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID 
   )
{
   HRESULT           hr = S_OK;
   LPSCOPEDATAITEM   pDataItem;

   hr = pNewNode->GetScopeData(&pDataItem);
   if (FAILED(hr))
      return hr;

   if ( pDataItem->ID )
      return hr;

   if ( nextSiblingID )
   {
      pDataItem->relativeID = nextSiblingID;
      pDataItem->mask |= SDI_NEXT;
   }
   else
   {
      pDataItem->relativeID = parentID;
      pDataItem->mask &= ~SDI_NEXT;
      pDataItem->mask |= SDI_PARENT;
   }

   hr = pConsoleNameSpace->InsertItem(pDataItem);
   if (FAILED(hr))
      return hr;

   return hr;

}

HRESULT 
   InsertNodeToScopepane2( 
      IConsole             * pConsole     , 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID
   )
{
   HRESULT           hr = S_OK;
   LPSCOPEDATAITEM   pDataItem;
   CComQIPtr<IConsoleNameSpace>  pNewSpace(pConsole);

   hr = pNewNode->GetScopeData(&pDataItem);
   if (FAILED(hr))
      return hr;

   if ( pDataItem->ID )
      return hr;

   if ( nextSiblingID )
   {
      pDataItem->relativeID = nextSiblingID;
      pDataItem->mask |= SDI_NEXT;
   }
   else
   {
      pDataItem->relativeID = parentID;
      pDataItem->mask &= ~SDI_NEXT;
      pDataItem->mask |= SDI_PARENT;
   }

   hr = pNewSpace->InsertItem(pDataItem);
   if (FAILED(hr))
      return hr;

   return hr;

}

HRESULT 
   GetSnapInItemGuid( 
      CSnapInItem          * pItem        , 
      GUID                 * pOutGuid
   )
{
   HRESULT  hr = S_OK;
   CComPtr<IDataObject> pDataObject;

   if ( NULL == pItem )
      return E_POINTER;

   hr = pItem->GetDataObject( &pDataObject, CCT_RESULT );
   if ( FAILED(hr) )
      return hr;

   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = { CSnapInItem::m_CCF_NODETYPE, 
      NULL, 
      DVASPECT_CONTENT,
      -1,
      TYMED_HGLOBAL
   };

   //
   // Allocate memory to received the GUID.
   //
   stgmedium.hGlobal = GlobalAlloc( 0, sizeof( GUID ) );
   if ( stgmedium.hGlobal == NULL )
      return( E_OUTOFMEMORY );

   //
   // Retrieve the GUID of the paste object.
   //
   hr = pDataObject->GetDataHere( &formatetc, &stgmedium );
   if( FAILED( hr ) )
   {
      GlobalFree(stgmedium.hGlobal);
      return( hr );
   }

   //
   // Make a local copy of the GUID.
   //
   memcpy( pOutGuid, stgmedium.hGlobal, sizeof( GUID ) );
   GlobalFree( stgmedium.hGlobal );

   return hr;
}



HRESULT 
   GetConsoleFromCSnapInObjectRootBase( 
      CSnapInObjectRootBase* pObj, 
      IConsole             **ppConsole
   )
{
   HRESULT              hr = E_FAIL;

   switch (pObj->m_nType)
   {
   case 1:
      {
         *ppConsole = ((CDomMigrator*)pObj)->m_spConsole;
         (*ppConsole)->AddRef();
         hr = S_OK;
      }
      break;
   case 2:
      {
         *ppConsole = ((CDomMigratorComponent *)pObj)->m_spConsole;
         (*ppConsole)->AddRef();
         hr = S_OK;
      }
      break;
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\globals.h ===
#ifndef GLOBALS_H
#define GLOBALS_H


#define  IMAGE_INDEX_TOOL              0  
#define  IMAGE_INDEX_TOOL_OPEN         1  

#define  IMAGE_INDEX_DOMAIN            2
#define  IMAGE_INDEX_DOMAIN_OPEN       3

#define  IMAGE_INDEX_VIEW              27//4
#define  IMAGE_INDEX_VIEW_OPEN         28//5
                                       
#define  IMAGE_INDEX_AD                6  
#define  IMAGE_INDEX_AD_OPEN           7  

#define  IMAGE_INDEX_OU                8  
#define  IMAGE_INDEX_OU_OPEN           9  

#define  IMAGE_INDEX_USERSCTN          10  
#define  IMAGE_INDEX_USERSCTN_OPEN     11  

#define  IMAGE_INDEX_USER              12
#define  IMAGE_INDEX_USER_OPEN         12

#define  IMAGE_INDEX_GROUP             13
#define  IMAGE_INDEX_GROUP_OPEN        13

#define  IMAGE_INDEX_TRTYFLTSCTN       14  
#define  IMAGE_INDEX_TRTYFLTSCTN_OPEN  15

#define  IMAGE_INDEX_TRTYFILTER        16
#define  IMAGE_INDEX_TRTYFILTER_OPEN   17

#define  IMAGE_INDEX_TERRITORY         18
#define  IMAGE_INDEX_TERRITORY_OPEN    18

#define  IMAGE_INDEX_TERRSECTOR        19
#define  IMAGE_INDEX_TERRSECTOR_OPEN   19

#define  IMAGE_INDEX_GRPFLTSCTN        20
#define  IMAGE_INDEX_GRPFLTSCTN_OPEN   21

#define  IMAGE_INDEX_GRPFILTER         22
#define  IMAGE_INDEX_GRPFILTER_OPEN    23

#define  IMAGE_INDEX_LOG               24
#define  IMAGE_INDEX_LOG_OPEN          24

#define  IMAGE_INDEX_ACTIVITY          25
#define  IMAGE_INDEX_ACTIVITY_OPEN     25

#define  IMAGE_INDEX_OBJECTS           26
#define  IMAGE_INDEX_OBJECTS_OPEN      26

#define  IMAGE_INDEX_COMPUTER_WS       29
#define  IMAGE_INDEX_COMPUTER_WS_OPEN  30

#define  IMAGE_INDEX_COMPUTER_DC       41
#define  IMAGE_INDEX_COMPUTER_DC_OPEN  41

#define  IMAGE_INDEX_COMPFILTER        31
#define  IMAGE_INDEX_COMPFILTER_OPEN   32

#define  IMAGE_INDEX_AD_BUSY           33
#define  IMAGE_INDEX_AD_BUSY_OPEN      34
#define  IMAGE_INDEX_OU_BUSY           35
#define  IMAGE_INDEX_OU_BUSY_OPEN      36
#define  IMAGE_INDEX_USERSCTN_BUSY     37
#define  IMAGE_INDEX_USERSCTN_BUSY_OPEN 38

#define  IMAGE_INDEX_PRINTER           39
#define  IMAGE_INDEX_PRINTER_OPEN      39

#define  IMAGE_INDEX_SHARE             40
#define  IMAGE_INDEX_SHARE_OPEN        40

HRESULT 
   InsertNodeToScopepane( 
      IConsoleNameSpace    * pConsoleNameSpace, 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID = 0
   );

HRESULT 
   InsertNodeToScopepane2( 
      IConsole             * pConsole     , 
      CSnapInItem          * pNewNode     , 
      HSCOPEITEM             parentID     ,
      HSCOPEITEM             nextSiblingID = 0
   );


HRESULT 
   GetSnapInItemGuid( 
      CSnapInItem          * pItem        , 
      GUID                 * pOutGuid
   );


HRESULT 
   GetConsoleFromCSnapInObjectRootBase( 
      CSnapInObjectRootBase* pObj, 
      IConsole             **ppConsole
   );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\domsel.h ===
#if !defined(AFX_DOMSEL_H__26ECF6A0_405B_11D3_8AED_00A0C9AFE114__INCLUDED_)
#define AFX_DOMSEL_H__26ECF6A0_405B_11D3_8AED_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DomSel.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDomainSelDlg dialog

class CDomainSelDlg : public CDialog
{
// Construction
public:
	CDomainSelDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDomainSelDlg)
	enum { IDD = IDD_DOMAIN };
	CString	m_Domain;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDomainSelDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDomainSelDlg)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DOMSEL_H__26ECF6A0_405B_11D3_8AED_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\helputils.h ===
//--------------------------------------------------------------------------
// HelpUtils.h: interface for the HelpUtils class.
// 
// (c) Copyright 1999, Mission Critical Software, Inc. All Rights Reserved.
// 
// Proprietary and confidential to Mission Critical Software, Inc. 
//--------------------------------------------------------------------------

#if !defined(AFX_HELPUTILS_H__AEB6F4E8_50CD_11D3_8AA4_0090270D38BA__INCLUDED_)
#define AFX_HELPUTILS_H__AEB6F4E8_50CD_11D3_8AA4_0090270D38BA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//--------------------------------------------------------------------------
// Included Files
//--------------------------------------------------------------------------
#include "EemGuiDll.h"

//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
namespace HelpUtils  
{
   HRESULT ShowHelpTopic(HWND hWnd, UINT nHelpTopicID);
};

#endif // !defined(AFX_HELPUTILS_H__AEB6F4E8_50CD_11D3_8AA4_0090270D38BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\helputils.cpp ===
//--------------------------------------------------------------------------
// HelpUtils.cpp: implementation of the HelpUtils class.
// 
// (c) Copyright 1999, Mission Critical Software, Inc. All Rights Reserved.
// 
// Proprietary and confidential to Mission Critical Software, Inc. 
//--------------------------------------------------------------------------

#include "stdafx.h"
#include <McString.h>
#include <GuiUtils.h>
#include "HelpUtils.h"
#include <HtmlHelp.h>

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
HRESULT
   HelpUtils::ShowHelpTopic(HWND hWnd, UINT nHelpTopicID)
{
   McString::String mcstrHelpPathName = GuiUtils::GetHelpPathName();
   ::HtmlHelp(hWnd, mcstrHelpPathName.getWide(), HH_HELP_CONTEXT, nHelpTopicID);
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\multisel.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "Globals.h"
#include "MultiSel.h"

UINT CMultiSelectItemDataObject::s_cfMsObjTypes  = 0;       // MultiSelect clipformat
UINT CMultiSelectItemDataObject::s_cfMsDataObjs  = 0;       // MultiSelect clipformat

CMultiSelectItemDataObject::CMultiSelectItemDataObject()
{
   m_objectDataArray.RemoveAll();
   m_ddStatusArray.RemoveAll();
   m_pParentItem = NULL;
   s_cfMsObjTypes  = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
   s_cfMsDataObjs  = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);
   m_bHasGroup = false;
}


CMultiSelectItemDataObject::~CMultiSelectItemDataObject()
{
   for ( int i = 0; i < m_objectDataArray.GetSize(); i++ )
   {
      delete (CObjectData *)(m_objectDataArray[i]);
   }
}


DWORD  CMultiSelectItemDataObject::GetItemCount()
{
   return (DWORD)m_objectDataArray.GetSize();
}

HRESULT  CMultiSelectItemDataObject::AddMultiSelectItem( CObjectData *pDataObject )
{
   m_objectDataArray.Add(pDataObject);
   m_ddStatusArray.Add(DD_NONE);

   return S_OK;
}

void  CMultiSelectItemDataObject::SetParentItem( CSnapInItem *pParentItem )
{
   m_pParentItem = pParentItem;
}

CSnapInItem *CMultiSelectItemDataObject::GetParentItem()
{
   return m_pParentItem;
}

void CMultiSelectItemDataObject::GetParentGuid(GUID *guid)
{
   memcpy( guid, &m_parentGuid, sizeof( GUID ) );
}

void CMultiSelectItemDataObject::SetParentGuid(GUID *guid)
{
   memcpy( &m_parentGuid, guid, sizeof( GUID ) );
}

CSnapInItem *CMultiSelectItemDataObject::GetSnapInItem(DWORD index)
{
   if ( GetItemCount() <= index )
      return NULL;
   return ((CObjectData *)m_objectDataArray[index])->m_pItem;
}

BYTE CMultiSelectItemDataObject::GetDDStatus(DWORD index)
{
   if ( GetItemCount() <= index )
      return DD_NONE;
   return m_ddStatusArray[index];
}

void CMultiSelectItemDataObject::SetDDStatus(DWORD index, BYTE status)
{
   if ( GetItemCount() <= index )
      return;
   m_ddStatusArray[index] = status;
}


STDMETHODIMP CMultiSelectItemDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{

   if ( NULL == pmedium )
      return E_POINTER;
   
   pmedium->pUnkForRelease = NULL;   // by OLE spec

   HRESULT hr = DV_E_TYMED;

   // Make sure the type medium is HGLOBAL
   if (pmedium->tymed == TYMED_HGLOBAL )
   {
      if ( s_cfMsObjTypes == pformatetc->cfFormat )
      {
         // Create the stream on the hGlobal passed in
         CComPtr<IStream> spStream;
         hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &spStream);
         if (SUCCEEDED(hr))
         {
            hr = DV_E_CLIPFORMAT;
            if (pformatetc->cfFormat == s_cfMsObjTypes)
            {
               DWORD  objCount = (DWORD)m_objectDataArray.GetSize();
               spStream->Write( &objCount, sizeof(DWORD), NULL );
               for ( DWORD i = 0; i < objCount; i++ )
               {
                  CSnapInItem* pItem;
                  pItem = (CSnapInItem*)((CObjectData*)m_objectDataArray[i])->m_pItem;
                  pItem->FillData( pItem->m_CCF_NODETYPE, spStream);
               }
            }
         }
      }
   }

   return hr;

}


STDMETHODIMP CMultiSelectItemDataObject::GetData
(
   FORMATETC *pformatetc,     // [in]  Pointer to the FORMATETC structure 
   STGMEDIUM *pmedium          // [out] Pointer to the STGMEDIUM structure  
)
{
   HRESULT hr = DATA_E_FORMATETC;
  
   if( s_cfMsObjTypes == pformatetc->cfFormat )
   {
      HGLOBAL  hMem    = NULL;
      DWORD  objCount = GetItemCount();

      ATLTRACE( L"CMultiSelectItemDataObject::GetData - asked for MultiSelect Object \n" );
      hMem = ::GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(GUID)*objCount + sizeof(DWORD));
      if( NULL == hMem )
         hr = STG_E_MEDIUMFULL;               
      else
      {                                        
         CComPtr<IStream> spStream;
         hr = CreateStreamOnHGlobal(hMem, FALSE, &spStream);
         if (SUCCEEDED(hr))
         {
            spStream->Write( &objCount, sizeof(DWORD), NULL );
            for ( DWORD i = 0; i < objCount; i++ )
            {
               CSnapInItem* pItem;
               pItem = (CSnapInItem*)((CObjectData*)m_objectDataArray[i])->m_pItem;
               pItem->FillData( pItem->m_CCF_NODETYPE, spStream);
            }
            pmedium->hGlobal = hMem;               // StgMedium variables 
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->pUnkForRelease = NULL;
         }
      }
   }  

   ATLTRACE( L"CMultiSelectItemDataObject::GetData returned 0x%X \n", hr );
   return hr;

} // end GetData()


STDMETHODIMP CMultiSelectItemDataObject::QueryGetData(FORMATETC *pformatetc)
{
   HRESULT hr = S_FALSE;

   if( (0 != s_cfMsObjTypes) && (s_cfMsObjTypes == pformatetc->cfFormat) )
   {
      hr = S_OK;            
   }    
  
   ATLTRACE( L"CMultiSelectItemDataObject::QueryGetData() called with ClipFormat 0x%X \n", pformatetc->cfFormat );
   return hr;
}


HRESULT  CMultiSelectItemDataObject::OnNotify(CDomMigratorComponent *pComponent, MMC_NOTIFY_TYPE event, long arg, long param )
{
   HRESULT hr = E_NOTIMPL;
   DWORD objCount = (DWORD)m_objectDataArray.GetSize();
   CComPtr<IConsole> spConsole;

   if ( 0 == objCount )
      return hr;

   spConsole = ((CDomMigratorComponent*)pComponent)->m_spConsole;

   switch (event)
   {
   case MMCN_SELECT:
      {   
         bool  bSelect = (HIWORD(arg) != 0 );
         if ( bSelect )
         {
            hr = OnSelect(spConsole);
         }
         break;
      }
   case MMCN_DELETE:
      //hr = OnDelete(spConsole);
      break;

   case MMCN_CUTORMOVE:               
      hr = OnCutOrMove(spConsole);
      break;
   default:
      break;
   }
   
   return hr;

}


HRESULT CMultiSelectItemDataObject::OnCutOrMove( IConsole* pConsole )
{
   HRESULT  hr = S_OK;//E_NOTIMPL;
   DWORD objCount = (DWORD)m_objectDataArray.GetSize();
   
   if ( 0 == objCount )
      goto ret_exit;

   GUID           itemParentGuid;
   GetParentGuid( &itemParentGuid );
   
ret_exit:
   return hr;
}




HRESULT CMultiSelectItemDataObject::OnSelect(IConsole *pConsole)
{
   HRESULT  hr = S_OK;//E_NOTIMPL;
   DWORD objCount = (DWORD)m_objectDataArray.GetSize();
   
   if ( 0 == objCount )
      goto ret_exit;

   GUID           itemParentGuid;
   GetParentGuid( &itemParentGuid );
   
   hr = OnSelectAllowDragDrop( pConsole );
   
ret_exit:
   return hr;
}


HRESULT CMultiSelectItemDataObject::OnSelectAllowDragDrop(IConsole *pConsole)
{
   HRESULT        hr = S_OK;
   CComPtr<IConsoleVerb> pConsoleVerb;

   hr = pConsole->QueryConsoleVerb( &pConsoleVerb );
   if ( FAILED( hr ) )
      goto ret_exit;

   //
   // Enable the delete verb.
   //
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, ENABLED, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;
   hr = pConsoleVerb->SetVerbState( MMC_VERB_DELETE, HIDDEN, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;

   //
   // Enable the copy verb.
   //
   hr = pConsoleVerb->SetVerbState( MMC_VERB_COPY, ENABLED, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;
   hr = pConsoleVerb->SetVerbState( MMC_VERB_COPY, HIDDEN, TRUE );
   if ( FAILED( hr ) )
      goto ret_exit;

ret_exit:
   return hr;
}

SMMCDataObjects *CMultiSelectItemDataObject::ExtractMSDataObjects( LPDATAOBJECT lpDataObject )
{
   HRESULT        hr = S_OK;
   SMMCDataObjects *p = NULL;
   STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
   FORMATETC formatetc = { (CLIPFORMAT)s_cfMsDataObjs, NULL,
                           DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                           };


   hr = lpDataObject->GetData(&formatetc, &stgmedium);
   if (FAILED(hr))
      goto ret_exit;

   p = reinterpret_cast<SMMCDataObjects*>(stgmedium.hGlobal);

   //ReleaseStgMedium(&stgmedium);

ret_exit:
   return p;
}

HRESULT CMultiSelectItemDataObject::Command(long lCommandID,
   CSnapInObjectRootBase* pObj,
   DATA_OBJECT_TYPES type)
{
   bool bHandled;
   
   return ProcessCommand(lCommandID, bHandled, pObj, type);
}


HRESULT CMultiSelectItemDataObject::AddMenuItems(LPCONTEXTMENUCALLBACK piCallback,
   long *pInsertionAllowed,
   DATA_OBJECT_TYPES type)
{
   if ( m_bHasGroup )
      return S_OK;

   //ATLTRACE2(atlTraceSnapin, 0, _T("CSnapInItemImpl::AddMenuItems\n"));
   //T* pT = static_cast<T*>(this);
   bool bIsExtension = false;

   if (!bIsExtension)
      /*pT->*/SetMenuInsertionFlags(true, pInsertionAllowed);

   UINT menuID = /*pT->*/GetMenuID();
   if (menuID == 0)
      return S_OK;

   HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(menuID));
   long insertionID;
   if (hMenu)
   {
      for (int i = 0; 1; i++)
      {
         HMENU hSubMenu = GetSubMenu(hMenu, i);
         if (hSubMenu == NULL)
            break;
         
         MENUITEMINFO menuItemInfo;
         memset(&menuItemInfo, 0, sizeof(menuItemInfo));
         menuItemInfo.cbSize = sizeof(menuItemInfo);

         switch (i)
         {
         case 0:
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP) )
               continue;
            insertionID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
            break;

         case 1:
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW) )
               continue;
            if (bIsExtension)
               insertionID = CCM_INSERTIONPOINTID_3RDPARTY_NEW;
            else
               insertionID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
            break;

         case 2:;
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_TASK) )
               continue;
            if (bIsExtension)
               insertionID = CCM_INSERTIONPOINTID_3RDPARTY_TASK;
            else
               insertionID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
            break;
         case 3:;
            if (! (*pInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) )
               continue;
            insertionID = CCM_INSERTIONPOINTID_PRIMARY_VIEW;
            break;
         default:
            {
               insertionID = 0;
               continue;
            }
            break;
         }

         menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
         menuItemInfo.fType = MFT_STRING;
         TCHAR szMenuText[128];

         for (int j = 0; 1; j++)
         {
            menuItemInfo.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
            menuItemInfo.fType = MFT_STRING;
            menuItemInfo.cch = 128;
            menuItemInfo.dwTypeData = szMenuText;
            TCHAR szStatusBar[256];

            if (!GetMenuItemInfo(hSubMenu, j, TRUE, &menuItemInfo))
               break;
            if (menuItemInfo.fType != MFT_STRING)
               continue;

            /*pT->*/UpdateMenuState(menuItemInfo.wID, szMenuText, &menuItemInfo.fState);
            LoadString(_Module.GetResourceInstance(), menuItemInfo.wID, szStatusBar, 256);

            OLECHAR wszStatusBar[256];
            OLECHAR wszMenuText[128];
            USES_CONVERSION;
            ocscpy(wszMenuText, T2OLE(szMenuText));
            ocscpy(wszStatusBar, T2OLE(szStatusBar));

            CONTEXTMENUITEM contextMenuItem;
            contextMenuItem.strName = wszMenuText;
            contextMenuItem.strStatusBarText = wszStatusBar;
            contextMenuItem.lCommandID = menuItemInfo.wID;
            contextMenuItem.lInsertionPointID = insertionID;
            contextMenuItem.fFlags = menuItemInfo.fState;
            contextMenuItem.fSpecialFlags = 0;
            
            HRESULT hr = piCallback->AddItem(&contextMenuItem);
            ATLASSERT(SUCCEEDED(hr));
         }
      }
      DestroyMenu(hMenu);
   }

   if (!bIsExtension)
      /*pT->*/SetMenuInsertionFlags(true, pInsertionAllowed);

   return S_OK;
}


HRESULT  CMultiSelectItemDataObject::OnVersionInfo(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   HRESULT           hr=S_OK;
/*   CVersionInfoDlg   dlg;

   dlg.DoModal();

  */ hr = S_OK;

   return hr;
}


HRESULT CMultiSelectItemDataObject::OnMoveMultipleObjs(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   HRESULT           hr = S_OK;
   CComPtr<IConsole> pConsole;

   hr = GetConsoleFromCSnapInObjectRootBase(pObj, &pConsole);
   if (FAILED(hr))
      return hr;

  
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\reptnode.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "MyNodes.h"
#include "TReg.hpp"
#include "ResStr.h"
#include "Err.hpp"

TError         err;
TError      &  errCommon = err;
StringLoader   gString;

//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace, named_guids

// {F521FE00-3FA1-11d3-8AED-00A0C9AFE114}
static const GUID CReportingGUID_NODETYPE = 
{ 0xf521fe00, 0x3fa1, 0x11d3, { 0x8a, 0xed, 0x0, 0xa0, 0xc9, 0xaf, 0xe1, 0x14 } };
const GUID*  CReportingNode::m_NODETYPE = &CReportingGUID_NODETYPE;
const OLECHAR* CReportingNode::m_SZNODETYPE = OLESTR("F521FE00-3FA1-11d3-8AED-00A0C9AFE114");
const OLECHAR* CReportingNode::m_SZDISPLAY_NAME = GET_BSTR(IDS_Reporting);
const CLSID* CReportingNode::m_SNAPIN_CLASSID = &CLSID_DomMigrator;

CReportingNode::CReportingNode()
{
//   m_idHTML = IDR_REPT_HTML;
   m_htmlPath[0] = 0;
   m_bstrDisplayName = SysAllocString(GET_STRING(IDS_ReportsMMCNode));
   m_scopeDataItem.nImage = IMAGE_INDEX_AD;
   m_scopeDataItem.nOpenImage = IMAGE_INDEX_AD_OPEN;
   m_resultDataItem.nImage = 0;
   
   m_Reports[0] = NULL;
   m_Reports[1] = NULL;
   m_Reports[2] = NULL;
   m_Reports[3] = NULL;
   m_Reports[4] = NULL;

         
};

STDMETHODIMP CReportingNode::GetResultViewType(LPOLESTR * ppViewType, long *pViewOptions)
{
   USES_CONVERSION;
   TCHAR                     szPath[MAX_PATH];
   TCHAR                     szModulePath[MAX_PATH];

   // set the result view to an HTML page
   GetModuleFileName(_Module.GetModuleInstance(),szModulePath, MAX_PATH);

      // append decorations                                    RT_HTML       IDR_HTML1
   
   if ( m_htmlPath[0] )
   {
      _stprintf(szPath,_T("file://%s"),m_htmlPath);  
   }
   else
   {
//      _stprintf(szPath,_T("res://%s/%ld"),szModulePath,m_idHTML);
      _stprintf(szPath,_T("res://%s/rept.htm"),szModulePath);
   }
   
   
   (*ppViewType) = (LPOLESTR) CoTaskMemAlloc( (_tcslen(szPath)+1) * (sizeof OLECHAR));
   if (!(*ppViewType))
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   ocscpy(*ppViewType,T2OLE(szPath));
   (*pViewOptions) = MMC_VIEW_OPTIONS_NOLISTVIEWS;
   return S_OK;
}

HRESULT CReportingNode::UpdateChildren(IConsole * pConsole)
{
   HRESULT                   hr = S_OK;

   m_ChildArray.RemoveAll();

   // check the registry entries to see if which reports have been generated
   TRegKey                   rKey;
   WCHAR                     filename[MAX_PATH];
   CReportingNode          * pNode = NULL;

   hr = rKey.Open(GET_STRING(IDS_REGKEY_REPORTS));
   if ( ! hr )
   {
      // check each report
      // Migrated users & groups
      hr = rKey.ValueGetStr(L"MigratedAccounts",filename,MAX_PATH);
      if (! hr )
      {
         if ( ! m_Reports[0] )
         {
            pNode = new CReportingNode();
		    if (pNode)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedAccounts),filename);
            m_Reports[0] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            m_Reports[0]->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedAccounts),filename);
         }
         m_ChildArray.Add(pNode);
      }
      // Migrated computers
      hr = rKey.ValueGetStr(L"MigratedComputers",filename,MAX_PATH);
      if (! hr )
      {
         if ( ! m_Reports[1] )
         {
            pNode = new CReportingNode();
		    if (pNode)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedComputers),filename);
            m_Reports[1] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            m_Reports[1]->SetHtmlPath(GET_STRING(IDS_REPORT_MigratedComputers),filename);
         }
         m_ChildArray.Add(pNode);
      }
      
      // expired computers
      hr = rKey.ValueGetStr(L"ExpiredComputers",filename,MAX_PATH);
      if (! hr )
      {
      
         if ( ! m_Reports[2] ) 
         {
            pNode = new CReportingNode();
		    if (pNode)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_ExpiredComputers),filename);
            m_Reports[2] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            m_Reports[2]->SetHtmlPath(GET_STRING(IDS_REPORT_ExpiredComputers),filename);
         }
         m_ChildArray.Add(pNode);
      }
      
      // account references
      hr = rKey.ValueGetStr(L"AccountReferences",filename,MAX_PATH);
      if (! hr )
      {
         if (! m_Reports[3] )
         {
            pNode = new CReportingNode();
		    if (pNode)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_AccountReferences),filename);
            m_Reports[3] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }
         else
         {
            m_Reports[3]->SetHtmlPath(GET_STRING(IDS_REPORT_AccountReferences),filename);
         }
         m_ChildArray.Add(pNode);
      }

      // name conflicts
      hr = rKey.ValueGetStr(L"NameConflicts",filename,MAX_PATH);
      if (! hr )
      {
         if ( ! m_Reports[4] )
         {
            pNode = new CReportingNode();
		    if (pNode)
		       return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            pNode->SetHtmlPath(GET_STRING(IDS_REPORT_NameConflicts),filename);
            m_Reports[4] = pNode;
            if ( pConsole )
            {
               hr = InsertNodeToScopepane2(pConsole,pNode,m_scopeDataItem.ID);
            }
         }   
         else
         {
            m_Reports[4]->SetHtmlPath(GET_STRING(IDS_REPORT_NameConflicts),filename);   
         }
         m_ChildArray.Add(pNode);

      }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\mynodes.h ===
#ifndef MYNODES_H
#define MYNODES_H
#include "NetNode.h"
#include "resource.h"
#include <comdef.h>
//#include "..\\Common\\Common.hpp"
//#include "..\\Common\\UString.hpp"
#include "Common.hpp"
#include "UString.hpp"

class CRootNode : public CNetNode<CRootNode>
{
public:
   static const GUID* m_NODETYPE;
   static const OLECHAR* m_SZNODETYPE;
   static const OLECHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;

   BEGIN_SNAPINCOMMAND_MAP(CRootNode, FALSE)
      SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEUSERSANDGROUPS, OnMigrateUsers )
      SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEGROUPS, OnMigrateGroups )
      SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATECOMPUTERS, OnMigrateComputers )
      SNAPINCOMMAND_ENTRY(ID_TOP_TRANSLATESECURITY, OnTranslateSecurity )
	  SNAPINCOMMAND_ENTRY(ID_TOP_UNDO, OnUndo )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEEXCHANGESERVER, OnMigrateExchangeServer )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATEEXCHANGEDIRECTORY, OnMigrateExchangeDirectory )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATESERVICEACCOUNTS, OnMigrateServiceAccounts )
	  SNAPINCOMMAND_ENTRY(ID_TOP_REPORTING, OnReporting )
	  SNAPINCOMMAND_ENTRY(ID_TOP_RETRY, OnRetry )
	  SNAPINCOMMAND_ENTRY(ID_TOP_MIGRATETRUSTS, OnMigrateTrusts )
	  SNAPINCOMMAND_ENTRY(ID_TOP_GROUPMAPPING, OnGroupMapping )
      //SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
   END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_ROOT_MENU)
   
   
   
   CRootNode();
   ~CRootNode();

   void SetMainWindow(HWND hwndMainWindow)
   {
      m_hwndMainWindow = hwndMainWindow;
   }

   void CheckForFailedActions(BOOL bPrompt = TRUE);
	void UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags);
   
   HRESULT OnGroupMapping(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateUsers(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnUndo(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateGroups(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateComputers(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnTranslateSecurity(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateExchangeServer(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateExchangeDirectory(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateServiceAccounts(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnReporting(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnRetry(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnMigrateTrusts(bool &bHandled, CSnapInObjectRootBase* pObj);
 
private:

   HWND m_hwndMainWindow;

   bool IsUndoable;
   bool CanUseST;
   bool CanRetry;

  void CheckUndoable();
  void CheckForST();
  void UpdateMigratedObjectsTable();
  void UpdateAccountReferenceTable();
  
};

class CReportingNode : public CNetNode<CReportingNode>
{
   UINT           m_idHTML;
   WCHAR          m_htmlPath[MAX_PATH];
   CReportingNode * m_Reports[5];

public:

   BEGIN_SNAPINCOMMAND_MAP(CReportingNode, FALSE)
      //SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
  END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_REPORTS)
   

   CReportingNode();

   static const GUID* m_NODETYPE;
   static const OLECHAR* m_SZNODETYPE;
   static const OLECHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;

   void SetHtmlPath(WCHAR const * title, WCHAR const * path) { m_bstrDisplayName = SysAllocString(title); safecopy(m_htmlPath,path); }

   STDMETHODIMP GetResultViewType(LPOLESTR * ppViewType, long *pViewOptions);
   HRESULT UpdateChildren(IConsole * pConsole);   
   // action handlers
};

class CPruneGraftNode : public CNetNode<CPruneGraftNode>
{
   BOOL              m_bLoaded;
   _bstr_t           m_Domain;
   _bstr_t           m_LDAPPath;
   _bstr_t           m_objectClass;
   CStringArray      m_Data;

  
public:

   BEGIN_SNAPINCOMMAND_MAP(CPruneGraftNode, FALSE)
      //SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
      SNAPINCOMMAND_ENTRY(ID_TOP_ADDDOMAIN,OnAddDomain)
   END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_PRUNE_GRAFT_MENU)
   

   CPruneGraftNode();

   // initialization
   void Init( WCHAR const * domain, WCHAR const *  path, WCHAR const * objClass, WCHAR const * displayName);

   BOOL ShowInScopePane();

   static const GUID* m_NODETYPE;
   static const OLECHAR* m_SZNODETYPE;
   static const OLECHAR* m_SZDISPLAY_NAME;
   static const CLSID* m_SNAPIN_CLASSID;


   // Action handlers
   HRESULT OnAddDomain(bool &bHandled, CSnapInObjectRootBase * pObj);
   virtual HRESULT OnExpand( IConsole *spConsole );
   virtual HRESULT OnShow( bool bShow, IHeaderCtrl *spHeader, IResultData *spResultData);
   virtual LPOLESTR GetResultPaneColInfo(int nCol);
   void AddColumnValue(int col,WCHAR const * value);

protected:
   // helper functions
   HRESULT EnumerateChildren( IConsole * spConsole);
   SAFEARRAY * GetAvailableColumns(WCHAR const * objectClass);
   HRESULT LoadChildren(IEnumVARIANT * pValues);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DomMigSI.rc
//
#define ID_DIALOG_FONTSIZE              8
#define IDS_PROJNAME                    100
#define IDB_DOMMIGRATOR_16              102
#define IDB_DOMMIGRATOR_32              103
#define IDS_DOMMIGRATOR_DESC            104
#define IDS_DOMMIGRATOR_PROVIDER        105
#define IDS_DOMMIGRATOR_VERSION         106
#define IDR_DOMMIGRATOR                 107
#define IDS_WizardAlreadyRunning        107
#define IDS_Title                       108
#define IDS_HELPFILE                    109
#define IDS_FailedActions               110
#define IDS_FAILED                      111
#define IDS_NAME                        112
#define IDS_TYPE                        113
#define IDS_DESC                        114
#define IDS_HelpFileIntroTopic          115
#define IDS_NoDatabase                  116
#define IDS_ERR_RUN_WIZARD              117
#define IDS_ERR_CHECK_FAILED_ACTIONS    118
#define IDS_NOSRCSIDCLM_TITLE           119
#define IDR_MULTISEL_MENU               120
#define IDS_NOSRCSIDCLM_MSG             120
#define IDS_ERR_NOSRCSIDCLM_MSG         120
#define IDS_QUERYCLM_TITLE              121
#define IDS_ERR_QUERYCLM_MSG            122
#define IDR_NET_MENU                    201
#define IDC_DOMAIN                      201
#define IDR_ROOT_MENU                   202
#define IDR_REPORTS                     203
#define IDR_PRUNE_GRAFT_MENU            204
#define IDD_DOMAIN                      206
#define IDB_DOMAIN                      208
#define IDB_OU                          209
#define IDB_GROUP                       210
#define IDB_USER                        211
#define IDB_PG_ROOT                     212
#define IDB_TOOL_32                     213
#define IDB_TOOL_16                     214
#define ID_TOP_MIGRATEUSERSANDGROUPS    32768
#define ID_TOP_MIGRATECOMPUTERS         32769
#define ID_TASK_UNDO                    32770
#define ID_TASK_REDO                    32771
#define ID_TOP_TRANSLATESECURITY        32774
#define ID_TOP_REPORTING                32775
#define ID_TASK_MIGRATEDACCOUNTSREPORT  32776
#define ID_TOP_MOVE                     32777
#define ID_TASK_MIGRATEDCOMPUTERSREPORT 32777
#define ID_TASK_EXPIREDCOMPUTERSREPORT  32778
#define ID_TASK_IMPORTDATA              32779
#define ID_VIEW_VERSION                 32780
#define ID_TOP_IMPORTDATA               32783
#define ID_TOP_GENERATE_REPORTS         32783
#define ID_TOP_ADDDOMAIN                32784
#define ID_TOP_REPORT1                  32785
#define ID_TOP_REPORT2                  32786
#define ID_TOP_REPORT3                  32787
#define ID_TOP_REPORT4                  32788
#define ID_TOP_MIGRATEGROUPS            32789
#define ID_TOP_MIGRATESERVICEACCOUNTS   32790
#define ID_TOP_MIGRATEEXCHANGESERVER    32791
#define ID_TOP_UNDO                     32792
#define ID_TOP_RETRY                    32794
#define ID_TOP_MIGRATETRUSTS            32795
#define ID_TOP_MIGRATEEXCHANGEDIRECTORY 32796
#define ID_TOP_GROUPMAPPING             32797

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        213
#define _APS_NEXT_COMMAND_VALUE         32798
#define _APS_NEXT_CONTROL_VALUE         202
#define _APS_NEXT_SYMED_VALUE           108
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\netnode.cpp ===
#include "stdafx.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "NetNode.h"
#include "Globals.h"


template <class T> HRESULT  CNetNode<T>::IsDirty()
{
   return m_bIsDirty;
}



template <class T> HRESULT  CNetNode<T>::Load(IStream *pStm)
{
   HRESULT           hr = S_OK;
   
   return hr;
}

template <class T> HRESULT  CNetNode<T>::Save(IStream *pStm, BOOL fClearDirty )
{
   HRESULT           hr = S_OK;

   return hr;
}

template <class T> HRESULT  CNetNode<T>::GetSaveSizeMax(ULARGE_INTEGER *pcbSize)
{
   HRESULT  hr = S_OK;
   int      size = 0, i, numDomain;

   numDomain = m_ChildArray.GetSize();
   // number of domains
   size += sizeof(numDomain);
   // domainNames
   for ( i = 0; i < numDomain; i++ )
   {  
      T  * pDomain;
      
      pDomain = (T *)m_ChildArray[i];
   }
   pcbSize->QuadPart = size;

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\common.cpp ===
//#pragma title( "Common.cpp - Common class implementations" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common class implementations.
Updates     -  1997-09-09 RED ErrorCodeToText moved to Err.cpp
            -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"

///////////////////////////////////////////////////////////////////////////////
// TTime class member functions
///////////////////////////////////////////////////////////////////////////////

   TTime                     gTTime;       // global instance of TTime

time_t                                     // ret-current time
   TTime::Now(
      time_t               * pTime         // out-optional current time
   )  const
{
   time_t                    tTime;        // work copy of current time

   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   tTime = ConvertFiletimeToTimet( wTime.intTime );

   if ( pTime ) *pTime = tTime;
   return tTime;
}

__int64                                    // ret-current time
   TTime::NowAsFiletime(
      __int64              * pTime         // out-optional current time
   )  const
{
   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   if ( pTime ) *pTime = wTime.intTime;
   return wTime.intTime;
}

time_t                                     // ret-time_t representation
   TTime::ConvertFiletimeToTimet(
      __int64                fileTime      // in -filetime representation
   )  const
{
   __int64                   wTime;        // intermediate work area
   time_t                    retTime;      // returned time

   // If the source date/time is less than the minimum date/time supported
   // by time_t, then zero is returned.
   // If the source date/time is more that the maximum date/time supported
   // by time_t, then ULONG_MAX is returned.

   wTime = fileTime / 10000000;

   if ( wTime < 11644473600 )
   {
      retTime = 0;
   }
   else
   {
      wTime -= 11644473600;
      if ( wTime > ULONG_MAX )
      {
         retTime = ULONG_MAX;
      }
      else
      {
         retTime = (time_t) wTime;
      }
   }

   return retTime;
}


WCHAR *                                     // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoUtc(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   tmTime = gmtime( &tTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

WCHAR *                                    // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoLcl(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   TIME_ZONE_INFORMATION     infoTime;     // WIN32 time zone info
   time_t                    wTime;        // workarea
   switch ( GetTimeZoneInformation( &infoTime ) )
   {
      case TIME_ZONE_ID_STANDARD:
         wTime = infoTime.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         wTime = infoTime.DaylightBias;
         break;
      default:
         wTime = 0;
         break;
   }
   wTime = (infoTime.Bias + wTime) * 60;
   wTime = tTime - wTime;
   if ( wTime < 0 )
   {
      wTime = 0;
   }
   tmTime = gmtime( &wTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) plus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   )
{
   memset( pTimeZoneInfo, 0, sizeof *pTimeZoneInfo );
   BOOL                      retval=TRUE;  // returned value
   DWORD                     OsRc;         // OS return code
   TIME_ZONE_INFORMATION     TimeZoneInfo; // WIN32 time zone info

   OsRc = GetTimeZoneInformation( &TimeZoneInfo );
   switch ( OsRc )
   {
      case TIME_ZONE_ID_STANDARD:
         pTimeZoneInfo->dst = TimeZoneInfo.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         pTimeZoneInfo->dst = TimeZoneInfo.DaylightBias;
         break;
      case TIME_ZONE_ID_UNKNOWN:
         retval = TimeZoneInfo.Bias;
         break;
      default:
         retval = FALSE;
         break;
   }
   if ( retval )
   {
      pTimeZoneInfo->bias = TimeZoneInfo.Bias * 60;
      pTimeZoneInfo->dst *= 60;
      pTimeZoneInfo->biasdst = pTimeZoneInfo->bias + pTimeZoneInfo->dst;
   }
   return retval;
}

// Common.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );

#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\multisel.h ===
#include <atlsnap.h>
#include <wtypes.h>

// multiselection dragdrop status
enum 
{ 
   DD_NONE = 0,
   DD_SUCCEEDED,
   DD_FAILED
};


class CMultiSelectItemDataObject: 
   public CComObjectRootEx<CComSingleThreadModel>,
   public IDataObject
{
public:
   CMultiSelectItemDataObject();
   ~CMultiSelectItemDataObject();

public:
   BEGIN_COM_MAP(CMultiSelectItemDataObject)
      COM_INTERFACE_ENTRY(IDataObject)
   END_COM_MAP()

   BEGIN_SNAPINCOMMAND_MAP(CMultiSelectItemDataObject, FALSE)
      SNAPINCOMMAND_ENTRY(ID_TOP_MOVE, OnMoveMultipleObjs )
      SNAPINCOMMAND_ENTRY(ID_VIEW_VERSION, OnVersionInfo )
   END_SNAPINCOMMAND_MAP()

   SNAPINMENUID(IDR_MULTISEL_MENU)

   // interface member functions
public:
   STDMETHOD(GetDataHere)(FORMATETC *pformatetc, STGMEDIUM *pmedium);
   STDMETHOD(GetData)(FORMATETC *pformatetc, STGMEDIUM *pmedium);
   STDMETHOD(QueryGetData)(FORMATETC *pformatetc);
   
   STDMETHOD(GetClassID)(CLSID *pCLSID)
   {
      return S_FALSE;
   }
   
   STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::GetCanonicalFormatEtc\n"));
   }
   STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }
   STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::EnumFormatEtc\n"));
   }
   STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
      DWORD *pdwConnection)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }
   STDMETHOD(DUnadvise)(DWORD dwConnection)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetDatan\n"));
   }
   STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
   {
      ATLTRACENOTIMPL(_T("SnapInDataObjectImpl::SetData\n"));
   }

   // non-interface member functions
public:
   HRESULT  AddMultiSelectItem( CObjectData *pDataObject );
   HRESULT  OnNotify(CDomMigratorComponent *pComponent, MMC_NOTIFY_TYPE event, long arg, long param );

   HRESULT  AddMenuItems(LPCONTEXTMENUCALLBACK piCallback,
      long *pInsertionAllowed, DATA_OBJECT_TYPES type);
   void UpdateMenuState( UINT id, LPTSTR pBuf, UINT *flags){}
   void SetMenuInsertionFlags(bool bBeforeInsertion, long* pInsertionAllowed){}
   HRESULT Command(long lCommandID, CSnapInObjectRootBase* pObj, DATA_OBJECT_TYPES type);

   HRESULT  OnSelect(IConsole *spConsole);
   HRESULT  OnSelectAllowDragDrop(IConsole *spConsole);

   HRESULT  OnCutOrMove( IConsole* pConsole );
   
   void     SetParentGuid( GUID *guid );
   void     GetParentGuid( GUID *guid );
   DWORD    GetItemCount();
   void     SetParentItem( CSnapInItem *pParentItem );
   CSnapInItem *GetParentItem();
   CSnapInItem *GetSnapInItem(DWORD index);

   BYTE GetDDStatus(DWORD index);
   void SetDDStatus(DWORD index, BYTE status);

   static SMMCDataObjects *ExtractMSDataObjects( LPDATAOBJECT lpDataObject );

/*   CNetNode *GetDomainPtr()
   {
      return m_pDomain;
   }

   void SetDomainPtr( CNetNode *ptr )
   {
      m_pDomain = ptr;
   }
*/
   HRESULT OnMoveMultipleObjs(bool &bHandled, CSnapInObjectRootBase* pObj);
   HRESULT OnVersionInfo(bool &bHandled, CSnapInObjectRootBase* pObj);

private:
   CPtrArray      m_objectDataArray;
   CByteArray     m_ddStatusArray;
   CSnapInItem    *m_pParentItem;
   GUID           m_parentGuid;
//   CNetNode       *m_pDomain;

public:
   bool           m_bHasGroup;

public:
   static UINT    s_cfMsObjTypes;          // MultiSelect clipformats
   static UINT    s_cfMsDataObjs;          // MultiSelect snapin

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\ealen.hpp ===
//#pragma title( "EaLen.hpp - EA defined length fields" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  EaLen.hpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1996-03-22
Description -  EA defined length fields
Updates     -
===============================================================================
*/

#ifndef  MCSINC_EaLen_hpp
#define  MCSINC_EaLen_hpp

// Definitions - object name lengths.
// These lengths include trailing null.
// These definitions are used to be independent of values in <lm.h>, which
// may not reflect the actual limits of all target operating systems.
// These values are also usually rounded up to a four byte boundary.
// The LEN_ values reflect the size reserved in structures for object names.
// The MAXLEN_ values reflect the actual valid maximum length imposed by EA.

#define  LEN_Computer                      (32)
#define  LEN_Domain                        (32)

#define  LEN_Account                       (260)
#define  LEN_Comment                       (260)
#define  LEN_Group                         (260)
#define  LEN_Member                        (260)
#define  LEN_Password                      (260)
#define  LEN_Path                          (1260)
#define  LEN_ShutdownMessage               (128)

#define  LEN_Sid                           (80)

#define  LEN_DistName                      (260)
#define  LEN_DisplayName                   (260)

#define  LEN_Guid                          (128)

#define  LEN_WTSPhoneNumber                (50)
#define  LEN_HomeDir                       (4)

// Definitions - maximum valid length of object name
// These lengths do NOT include trailing null.
// These definitions must always be smaller that the corresponding
// definitions above.

// Other EA defined constants
// type of account
#define  EA_AccountGGroup                        (0x00000001)
#define  EA_AccountLGroup                        (0x00000002)
#define  EA_AccountUser                          (0x00000004)
#define  EA_AccountUcLGroup                      (0x00000008)

#define  EA_AccountGroup                         (EA_AccountGGroup|EA_AccountLGroup)
#define  EA_AccountAll                           (EA_AccountGroup|EA_AccountUser)


#endif  // MCSINC_EaLen_hpp

// EaLen.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\prgrnode.cpp ===
// This node class ...
#include "stdafx.h"
#include "MyNodes.h"
#include "DomSel.h"
#include "..\Common\UString.hpp"
#include "..\Common\Common.hpp"

#import "\bin\NetEnum.tlb" no_namespace, named_guids

// {162A41A3-405C-11d3-8AED-00A0C9AFE114}
static const GUID CPruneGraftGUID_NODETYPE = 
{ 0x162a41a3, 0x405c, 0x11d3, { 0x8a, 0xed, 0x0, 0xa0, 0xc9, 0xaf, 0xe1, 0x14 } };

const GUID*  CPruneGraftNode::m_NODETYPE = &CPruneGraftGUID_NODETYPE;
const OLECHAR* CPruneGraftNode::m_SZNODETYPE = OLESTR("C8C24622-3FA1-11d3-8AED-00A0C9AFE114");
const OLECHAR* CPruneGraftNode::m_SZDISPLAY_NAME = OLESTR("Domain Migrator");
const CLSID* CPruneGraftNode::m_SNAPIN_CLASSID = &CLSID_DomMigrator;

//                               0            1                    2          3         4
WCHAR    * gLDAPColumns[] = { L"", L"", L"",  L"", L"" };
WCHAR    * gColumnHeaders[] =  { L"", L"",L"",L"" };

// these define the index in gLDAPColumns to use for each column
int        gDomainMapping[] = { 0,1,2,4 };
int        gOuMapping[] = { 3,1,2,4 };
int        gContainerMapping[] = { 0,1,2,4 };
int        gGroupMapping[] = { 0, 1,2,4 };
int        gUserMapping[] = { 0, 1,2,4 };

CPruneGraftNode::CPruneGraftNode()
{
   // Initialize the array of children
   // TODO:  load the domain hierarchy for the current forest
   m_bLoaded = FALSE;
   m_bstrDisplayName = SysAllocString(L"Prune & Graft");
   m_scopeDataItem.nImage = IMAGE_INDEX_AD;      // May need modification
   m_scopeDataItem.nOpenImage = IMAGE_INDEX_AD_OPEN;   // May need modification
   m_resultDataItem.nImage = IMAGE_INDEX_AD;     // May need modification
   m_Data.SetSize(MAX_COLUMNS);
}

void 
   CPruneGraftNode::Init(
      WCHAR          const * domain,
      WCHAR          const * path, 
      WCHAR          const * objClass,
      WCHAR          const * displayName
   ) 
{ 
   m_Domain = domain;
   m_LDAPPath = path; 
   m_objectClass = objClass; 

   m_bstrDisplayName = displayName;
   // set the icons
   if ( ! UStrICmp(objClass,L"user") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_USER;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_USER_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_USER;     
   }
   else if ( ! UStrICmp(objClass,L"group") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_GROUP;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_GROUP_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_GROUP;     
   }
   else if ( ! UStrICmp(objClass,L"organizationalUnit") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_OU;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_OU_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_OU;     
   }
   else if ( ! UStrICmp(objClass,L"domain") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_DOMAIN;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_DOMAIN_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_DOMAIN;     
   }
   else if ( ! UStrICmp(objClass,L"container") )
   {
      m_scopeDataItem.nImage = IMAGE_INDEX_VIEW;     
      m_scopeDataItem.nOpenImage = IMAGE_INDEX_VIEW_OPEN; 
      m_resultDataItem.nImage = IMAGE_INDEX_VIEW;     
   }
}

BOOL
   CPruneGraftNode::ShowInScopePane()
{
   return ( UStrICmp(m_objectClass,L"user") );
}


HRESULT CPruneGraftNode::OnAddDomain(bool &bHandled, CSnapInObjectRootBase * pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   HRESULT                   hr = S_OK;
   CDomainSelDlg             dlg;
   CComPtr<IConsole>         pConsole;
  
   hr = GetConsoleFromCSnapInObjectRootBase(pObj, &pConsole );
   if (FAILED(hr))
      return hr;
   
   if ( IDOK == dlg.DoModal() )
   {
      // insert the domain in the scope pane
      CPruneGraftNode         * pNode = new CPruneGraftNode();

      pNode->Init(dlg.m_Domain.AllocSysString(),L"",L"domain",dlg.m_Domain.AllocSysString());
      
      hr = InsertNodeToScopepane2((IConsole*)pConsole, pNode, m_scopeDataItem.ID );

      m_ChildArray.Add(pNode);

   }
   return hr;
}


HRESULT CPruneGraftNode::OnExpand( IConsole *spConsole )
{
   // TODO:  if we haven't already, enumerate our contents
   if ( ! m_bLoaded )
   {
      EnumerateChildren(spConsole);
      m_bLoaded = TRUE;
   }
   
   return CNetNode<CPruneGraftNode>::OnExpand(spConsole);
}

SAFEARRAY * CPruneGraftNode::GetAvailableColumns(WCHAR const * objectClass)
{
   long                      nItems = 0;
   WCHAR                  ** columns = NULL;

   columns = gLDAPColumns;
   nItems = DIM(gLDAPColumns);

   
   // Build a safearray containing the data
   SAFEARRAYBOUND      bound[1] = { { 0, 0 } };
   long ndx[1];
   
   bound[0].cElements = nItems;

   SAFEARRAY         * pArray = SafeArrayCreate(VT_BSTR,1,bound);
   
   for ( long i = 0 ; i < nItems ; i++ )
   {
      ndx[0] = i;
      SafeArrayPutElement(pArray,ndx,SysAllocString(columns[i]));
   }
   return pArray;
}

HRESULT CPruneGraftNode::EnumerateChildren(IConsole * spConsole)
{
   HRESULT                   hr = S_OK;
   WCHAR                     path[MAX_PATH];
   INetObjEnumeratorPtr      pEnum;
   IEnumVARIANT            * pValues = NULL;
   
   hr = pEnum.CreateInstance(CLSID_NetObjEnumerator);

   if ( SUCCEEDED(hr) )
   {
      if ( m_LDAPPath.length() )
      {
         swprintf(path,L"LDAP://%ls/%ls",(WCHAR*)m_Domain,(WCHAR*)m_LDAPPath);
      }
      else
      {
         safecopy(path,(WCHAR*)m_LDAPPath);
      }
      hr = pEnum->raw_SetQuery(path,m_Domain,L"(objectClass=*)",1,FALSE);
   }
   if ( SUCCEEDED(hr) )
   {
      hr = pEnum->raw_SetColumns(GetAvailableColumns(m_objectClass));
   }
   if ( SUCCEEDED(hr) )
   {
      hr = pEnum->raw_Execute(&pValues);
   }
   if ( SUCCEEDED(hr) )
   {
      hr = LoadChildren(pValues);
      pValues->Release();
   }

   return hr;
}

HRESULT CPruneGraftNode::LoadChildren(IEnumVARIANT * pEnumerator)
{
   HRESULT                   hr = 0;
   VARIANT                   var;
   long                      count = 0;
   ULONG                     nReturned = 0;
   CPruneGraftNode         * pNode = NULL;
   VariantInit(&var);

   while (  hr != S_FALSE )
   {
      hr = pEnumerator->Next(1,&var,&nReturned);
   
      // break if there was an error, or Next returned S_FALSE
      if ( hr != S_OK )
         break;
      // see if this is an array ( it should be!)
      if ( var.vt == ( VT_ARRAY | VT_VARIANT ) )
      {
         VARIANT              * pData;
         SAFEARRAY            * pArray;

         pArray = var.parray;
         
         pNode = new CPruneGraftNode;

         SafeArrayGetUBound(pArray,1,&count);
         SafeArrayAccessData(pArray,(void**)&pData);
         // make sure we at least have an LDAP path and an objectClass
         if ( count )
         {
            // get the object class and distinguishedName
            pNode->Init(m_Domain,pData[1].bstrVal,pData[2].bstrVal,pData[0].bstrVal);

            m_ChildArray.Add(pNode);
            for ( long i = 0 ; i <= count ; i++ )
            {
               // convert each value to a string, and store it in the node
               if ( SUCCEEDED(VariantChangeType(&pData[i],&pData[i],0,VT_BSTR)) )
               {
                 pNode->AddColumnValue(i,pData[i].bstrVal);
               }
            }
         }
         else
         {
            delete pNode;
         }
         
      }  
   }
   return hr;
}

HRESULT CPruneGraftNode::OnShow( bool bShow, IHeaderCtrl *spHeader, IResultData *spResultData)
{
   HRESULT hr=S_OK;

   if (bShow)       
   {  // show
      for ( int i = 0 ; i < DIM(gColumnHeaders) ; i++ )
      {
         spHeader->InsertColumn(i, gColumnHeaders[i], LVCFMT_LEFT, m_iColumnWidth[i]);
      }
      {
         CString  cstr;
         CComBSTR text;

         cstr.Format(_T("%d subitem(s)"), m_ChildArray.GetSize() );
         text = (LPCTSTR)cstr;
         spResultData->SetDescBarText( BSTR(text) ); 
      }
   }
   else
   {  // hide
      // save the column widths
      for ( int i = 0 ; i < DIM(gColumnHeaders) ; i++ )
      {
         spHeader->GetColumnWidth(i, m_iColumnWidth + i);
      }
   }
   hr = S_OK;

   return hr;
}
 

LPOLESTR CPruneGraftNode::GetResultPaneColInfo(int nCol)
{
   CString                 value;
   int                     ndx = nCol;
   int                   * mapping = NULL;

   if ( m_objectClass.length() && UStrICmp(m_objectClass,L"domain") )
   {
      
      if ( ! UStrICmp(m_objectClass,L"user") )
      {
         mapping = gUserMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"group") )
      {
         mapping = gGroupMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"organizationalUnit") )
      {
         mapping = gOuMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"domain") )
      {
         mapping = gDomainMapping;
      }
      else if ( ! UStrICmp(m_objectClass,L"container") )
      {
         mapping = gContainerMapping;
      }
      else 
      {
         mapping = gContainerMapping;
      }
      if ( mapping ) 
         ndx = mapping[nCol];

      if ( ndx <= m_Data.GetUpperBound() )
      {
         value = m_Data.GetAt(ndx);
         return value.AllocSysString();
      }
      else
         return OLESTR("Override GetResultPaneColInfo");
   }
   else
   {
      return CNetNode<CPruneGraftNode>::GetResultPaneColInfo(nCol);
   }
   return NULL;
}


void CPruneGraftNode::AddColumnValue(int col,WCHAR const * value) 
{ 
   m_Data.SetAtGrow(col,value);
   
   // see if we need to update the display name
   // get the pointer for the columns
   int * mapping = NULL;

   if ( ! UStrICmp(m_objectClass,L"user") )
   {
      mapping = gUserMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"group") )
   {
      mapping = gGroupMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"organizationalUnit") )
   {
      mapping = gOuMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"domain") )
   {
      mapping = gDomainMapping;
   }
   else if ( ! UStrICmp(m_objectClass,L"container") )
   {
      mapping = gContainerMapping;
   }
   else 
   {
      mapping = gContainerMapping;
   }
   if ( mapping && col == mapping[0] )  // display name
   {
      m_bstrDisplayName = value;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\netnode.h ===
#ifndef NETNODE_H
#define NETNODE_H

#include <atlsnap.h>
#include "resource.h"
#include "DomMigSI.h"
#include "DomMigr.h"
#include "Globals.h"
#include "HtmlHelp.h"
#include "HelpID.h"
#define MAX_COLUMNS              6

extern CSnapInToolbarInfo   m_toolBar;
template <class T>
class ATL_NO_VTABLE CNetNode : public CSnapInItemImpl<T>
{
public:
// 
   bool           m_bExpanded;
   int            m_iColumnWidth[MAX_COLUMNS];

   bool           m_bIsDirty;
   bool           m_bLoaded;
//
   CPtrArray      m_ChildArray;

   CComPtr<IControlbar>        m_spControlBar;
   
   
   CNetNode()
   {
      // Image indexes may need to be modified depending on the images specific to 
      // the snapin.
      memset(&m_scopeDataItem, 0, sizeof(SCOPEDATAITEM));
      m_scopeDataItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_PARAM;
      m_scopeDataItem.displayname = MMC_CALLBACK;
      m_scopeDataItem.nImage = 0;      // May need modification
      m_scopeDataItem.nOpenImage = 0;   // May need modification
      m_scopeDataItem.lParam = (LPARAM) this;
      memset(&m_resultDataItem, 0, sizeof(RESULTDATAITEM));
      m_resultDataItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
      m_resultDataItem.str = MMC_CALLBACK;
      m_resultDataItem.nImage = 0;     // May need modification
      m_resultDataItem.lParam = (LPARAM) this;

      // 
      CoInitialize( NULL );
      m_bLoaded = false;
      m_bExpanded = false;
   
      m_iColumnWidth[0] = 400;
      m_iColumnWidth[1] = 0;
      m_iColumnWidth[2] = 0;
      SetClean();
   }
   ~CNetNode()
   {
         
      for ( int i = 0; i < m_ChildArray.GetSize(); i++ )
      {
         delete (T *)(m_ChildArray[i]);
      }
      CoUninitialize();
   }

  STDMETHOD(GetScopePaneInfo)(SCOPEDATAITEM *pScopeDataItem)
  {
      if (pScopeDataItem->mask & SDI_STR)
         pScopeDataItem->displayname = m_bstrDisplayName;
      if (pScopeDataItem->mask & SDI_IMAGE)
         pScopeDataItem->nImage = m_scopeDataItem.nImage;
      if (pScopeDataItem->mask & SDI_OPENIMAGE)
         pScopeDataItem->nOpenImage = m_scopeDataItem.nOpenImage;
      if (pScopeDataItem->mask & SDI_PARAM)
         pScopeDataItem->lParam = m_scopeDataItem.lParam;
      if (pScopeDataItem->mask & SDI_STATE )
         pScopeDataItem->nState = m_scopeDataItem.nState;
      pScopeDataItem->cChildren = (int)m_ChildArray.GetSize();
      
      return S_OK;
  }

   STDMETHOD(GetResultPaneInfo)(RESULTDATAITEM *pResultDataItem)
   {
      if (pResultDataItem->bScopeItem)
      {
         if (pResultDataItem->mask & RDI_STR)
         {
            pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
         }
         if (pResultDataItem->mask & RDI_IMAGE)
         {
            pResultDataItem->nImage = m_scopeDataItem.nImage;
         }
         if (pResultDataItem->mask & RDI_PARAM)
         {
            pResultDataItem->lParam = m_scopeDataItem.lParam;
         }

         return S_OK;
      }

      if (pResultDataItem->mask & RDI_STR)
      {
         pResultDataItem->str = GetResultPaneColInfo(pResultDataItem->nCol);
      }
      if (pResultDataItem->mask & RDI_IMAGE)
      {
         pResultDataItem->nImage = m_resultDataItem.nImage;
      }
      if (pResultDataItem->mask & RDI_PARAM)
      {
         pResultDataItem->lParam = m_resultDataItem.lParam;
      }
      if (pResultDataItem->mask & RDI_INDEX)
      {
         pResultDataItem->nIndex = m_resultDataItem.nIndex;
      }

      return S_OK;
   }


   HRESULT __stdcall Notify( MMC_NOTIFY_TYPE event,
      long arg,
      long param,
      IComponentData* pComponentData,
      IComponent* pComponent,
      DATA_OBJECT_TYPES type)
   {
      // Add code to handle the different notifications.
      // Handle MMCN_SHOW and MMCN_EXPAND to enumerate children items.
      // In response to MMCN_SHOW you have to enumerate both the scope
      // and result pane items.
      // For MMCN_EXPAND you only need to enumerate the scope items
      // Use IConsoleNameSpace::InsertItem to insert scope pane items
      // Use IResultData::InsertItem to insert result pane item.
      HRESULT hr = E_NOTIMPL;

   
      _ASSERTE(pComponentData != NULL || pComponent != NULL);

      CComPtr<IConsole> spConsole;
      CComQIPtr<IHeaderCtrl, &IID_IHeaderCtrl> spHeader;
      if (pComponentData != NULL)
         spConsole = ((CDomMigrator*)pComponentData)->m_spConsole;
      else
      {
         spConsole = ((CDomMigratorComponent*)pComponent)->m_spConsole;
         spHeader = spConsole;
      }

      switch (event)
      {
      case MMCN_REMOVE_CHILDREN:
         hr = S_OK;
         break;

      case MMCN_SHOW:
         {
            CComQIPtr<IResultData, &IID_IResultData> spResultData(spConsole);

            bool bShow = (arg != 0);
            hr = OnShow( bShow, spHeader, spResultData );
            break;
         }
   /*   case MMCN_EXPANDSYNC:
         {
            MMC_EXPANDSYNC_STRUCT  *pExpandStruct = ( MMC_EXPANDSYNC_STRUCT *)param;
            break;
         }
   */
      case MMCN_EXPAND:
         {
            m_bExpanded = true;
            m_scopeDataItem.ID = param;
            hr = OnExpand( spConsole );
            hr = S_OK;
            break;
         }
		case MMCN_ADD_IMAGES:
			{
				// Add Images
				IImageList* pImageList = (IImageList*) arg;
				hr = E_FAIL;
				// Load bitmaps associated with the scope pane
				// and add them to the image list
				// Loads the default bitmaps generated by the wizard
				// Change as required
				HBITMAP hBitmap16 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_16));
				if (hBitmap16 != NULL)
				{
					HBITMAP hBitmap32 = LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDB_TOOL_32));
					if (hBitmap32 != NULL)
					{
						hr = pImageList->ImageListSetStrip((long*)hBitmap16, 
						(long*)hBitmap32, 0, RGB(0, 128, 128));
						if (FAILED(hr))
							ATLTRACE(_T("IImageList::ImageListSetStrip failed\n"));
	                    DeleteObject(hBitmap16);
	                    DeleteObject(hBitmap32);
					}
				}
				break;
			}
      case MMCN_DBLCLICK:
         {
            hr = S_FALSE;
            break;
         }
      case MMCN_REFRESH:
         {
            hr = OnRefresh(spConsole);
   //         ShowErrorMsg( spConsole, hr, _T("Refresh All Domains") );
            break;
         }
      case MMCN_SELECT:
         {
            //
            // Call our select handler.
            //
            bool  bScope = (LOWORD(arg) != 0 );
            bool  bSelect = (HIWORD(arg) != 0 );
            hr = OnSelect( bScope, bSelect, spConsole );
            break;
         }
	  case MMCN_SNAPINHELP:
		  {		  
//			  break;
		  }

	  case MMCN_HELP :
		  {		  
//			  break;
		  }
		  
	  case MMCN_CONTEXTHELP:       
		  {	
			  AFX_MANAGE_STATE(AfxGetStaticModuleState());
           HWND            mainHwnd;
			  CComBSTR        bstrTopic;
			  HRESULT         hr;
			  IDisplayHelp *  pHelp = NULL;

			  ATLTRACE(_T("MMCN_SNAPINHELP\n"));
			  
           spConsole->GetMainWindow( &mainHwnd );
         
           hr = spConsole->QueryInterface(IID_IDisplayHelp,(void**)&pHelp);
           if ( SUCCEEDED(hr) )
           {
			     CString      strTopic;

              strTopic.FormatMessage(IDS_HelpFileIntroTopic);

              if ( SUCCEEDED(hr) )
			     {
				     hr = pHelp->ShowTopic(strTopic.AllocSysString());
                 if ( FAILED(hr) )
                 {
                    CString s;
				        s.LoadString(IDS_FAILED);
				        MessageBox(NULL,s,L"",MB_OK);
                 }
			     }
			     else
			     {
				     CString s;
				     s.LoadString(IDS_FAILED);
				     MessageBox(NULL,s,L"",MB_OK);
			     }
              pHelp->Release();
           }
		  }
		  return S_OK;
		  
	  default:
         break;

      }
      return hr;
   }

   virtual LPOLESTR GetResultPaneColInfo(int nCol)
   {
      if (nCol == 0)
         return m_bstrDisplayName;
      // TODO : Return the text for other columns
      return OLESTR("Override GetResultPaneColInfo");
   }
   // Message handler helpers
   HRESULT OnSelect( bool bScope, bool bSelect, IConsole* pConsole )
   {
      HRESULT hr=S_OK;

      if ( bSelect )
      {
         CComPtr<IConsoleVerb> spConsoleVerb;
         hr = pConsole->QueryConsoleVerb( &spConsoleVerb );
         if ( FAILED( hr ) )
            return hr;
         //
         // Enable the refresh verb.
         //
         hr = spConsoleVerb->SetVerbState( MMC_VERB_REFRESH, ENABLED, TRUE );
         if ( FAILED( hr ) )
            return hr;
      }

      return( hr );
   }
   
   virtual BOOL ShowInScopePane() { return TRUE; }
   virtual HRESULT OnExpand( IConsole *spConsole )
   {
      HRESULT hr=S_OK;
      CComQIPtr<IConsoleNameSpace, &IID_IConsoleNameSpace> spConsoleNameSpace(spConsole);
         
      //
      // Enumerate scope pane items
      //
      for (int i = 0; i < m_ChildArray.GetSize(); ++i)
      {
         if ( ((CNetNode*)m_ChildArray[i])->ShowInScopePane() )
         {
            hr = InsertNodeToScopepane(spConsoleNameSpace, (CNetNode*)m_ChildArray[i], m_scopeDataItem.ID );
            if (FAILED(hr))
               break;
         }
      }
      return hr;
   }

   virtual HRESULT OnShow( bool bShow, IHeaderCtrl *spHeader, IResultData *spResultData)
   {
      HRESULT hr=S_OK;

      if (bShow)       
      {  // show
	         {
            CString  cstr;
            CComBSTR text;

            cstr.Format(_T("%d subitem(s)"), m_ChildArray.GetSize() );
            text = (LPCTSTR)cstr;
            spResultData->SetDescBarText( BSTR(text) ); 
         }
      }
      else
      {  // hide
         // save the column widths
         spHeader->GetColumnWidth(0, m_iColumnWidth);
         spHeader->GetColumnWidth(1, m_iColumnWidth + 1);
         spHeader->GetColumnWidth(2, m_iColumnWidth + 2);
      }
      hr = S_OK;

      return hr;
   }
   HRESULT OnRefresh(IConsole *spConsole)
   {
      HRESULT  hr=S_OK;
      int      i;

      if ( m_bExpanded )
      {   
         // Refresh the children
         for ( i = 0; i < m_ChildArray.GetSize(); i++ )
         {
            hr = ((T *)m_ChildArray[i])->OnRefresh(spConsole);
            if ( FAILED(hr) )
               break;
         }
      }
      if ( FAILED(hr) )
      {
         ATLTRACE("CNetNode::OnRefresh failed, hr = %lx\n", hr );
      }
      return hr;
   }
   HRESULT OnGroupDDSetup(bool &bHandled, CSnapInObjectRootBase* pObj) { return S_OK; }
   HRESULT OnVersionInfo(bool &bHandled, CSnapInObjectRootBase* pObj) { return S_OK; }
   
   void UpdateMenuState( UINT id, LPTSTR pBuf, UINT *flags)
   {
      if ( id == ID_TASK_UNDO )
      {
         //if ( CanUndo(pBuf) )
         //   *flags = MF_ENABLED;
        // else
            *flags = MF_GRAYED;
      }
      if ( id == ID_TASK_REDO )
      {
        // if ( CanRedo(pBuf) )
        //    *flags = MF_ENABLED;
        // else
            *flags = MF_GRAYED;
      }
   }
   // IPersistStreamImpl
   HRESULT Load(IStream *pStm);
   HRESULT Save(IStream *pStm, BOOL fClearDirty);
   HRESULT GetSaveSizeMax(ULARGE_INTEGER *pcbSize);
   
   
   HRESULT Loaded()
   {
      if ( m_bLoaded )
         return S_OK;
      else
         return S_FALSE;
   }

   HRESULT IsDirty();

   void SetDirty()
   {
      m_bIsDirty = S_OK;
   }

   void SetClean()
   {
      m_bIsDirty = S_FALSE;
   }
   static CSnapInToolbarInfo* GetToolbarInfo()
	{
		return (CSnapInToolbarInfo*)&m_toolBar;
	}
	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8FC152E2_3F8B_11D3_8AED_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__8FC152E2_3F8B_11D3_8AED_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8FC152E2_3F8B_11D3_8AED_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\errdct.hpp ===
#ifndef __ERRDCT_HPP__
#define __ERRDCT_HPP__
/*---------------------------------------------------------------------------
  File: ErrDct.hpp

  Comments: TError derived class that specifies a numeric code for each message 
  format.  The goal is to make it easy to convert this to a real message file 
  later.

  This class also improves on the behavior of the TError class by returning text
  for HRESULT error codes.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 13:04:51

 ---------------------------------------------------------------------------
*/
#include "Err.hpp"
#include "Common.hpp"
#include "UString.hpp"    
#include "McsDmMsg.h"

// These codes are passed as the messageNumber argument to MsgWrite and SysMsgWrite.


// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   );

class TErrorDct : public TError
{
public:
   TErrorDct(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
      ) : TError(displevel,loglevel,NULL,logmode,beeplevel)
   {}
   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );   

   WCHAR const * LookupMessage(UINT msgNumber);

   virtual void __cdecl
   SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   );

   virtual void __cdecl
   MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

   void __cdecl
      DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      );

   virtual BOOL         LogOpen(
      WCHAR          const * fileName     ,// in -name of file including any path
      int                    mode = 0     ,// in -0=overwrite, 1=append
      int                    level = 0     // in -minimum level to log
   )
   {
      WCHAR                  directory[MAX_PATH];

      safecopy(directory,fileName);

      WCHAR                * x = wcsrchr(directory,'\\');
      
      if ( x )
      {
         (*x) = 0;
         DirectoryCreateR(directory);
      }
      
      return TError::LogOpen(fileName,mode,level);
   }

};

#endif //__ERRDCT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\lsautils.cpp ===
/*---------------------------------------------------------------------------
  File: LSAUtils.cpp

  Comments: Code to change the domain membership of a workstation.
  

  This file also contains some general helper functions, such as:

  GetDomainDCName
  EstablishNullSession
  EstablishSession
  EstablishShare   // connects to a share
  InitLsaString
  GetDomainSid


  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/03/99 12:37:51

 ---------------------------------------------------------------------------
*/

//

#include "stdafx.h"

#ifndef UNICODE
#define UNICODE
#define _UNICODE
#endif

#include <lm.h>         // for NetXxx API

#include <stdio.h>

#include "LSAUtils.h"
#include "ErrDct.hpp"
#include "ResStr.h"


#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

extern TErrorDct        err;


BOOL
   GetDomainDCName(
      LPWSTR                 Domain,       // in - domain name
      LPWSTR               * pPrimaryDC    // out- PDC name (must be freed with NetApiBufferFree)
    )
{
   NET_API_STATUS            nas;

   //
   // get the name of the Primary Domain Controller
   //
   // we're using NetGetDCName instead of DsGetDCName so this can work on NT 3.51

   nas = NetGetDCName(NULL, Domain, (LPBYTE *)pPrimaryDC);

   if(nas != NERR_Success) 
   {
      SetLastError(nas);
      return FALSE;
   }

   return TRUE;
}

BOOL 
   EstablishNullSession(
      LPCWSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   return EstablishSession(Server,L"",L"",L"",bEstablish);
}

BOOL
   EstablishSession(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Domain,       // in - domain name for user credentials
      LPWSTR                 UserName,     // in - username for credentials to use
      LPWSTR                 Password,     // in - password for credentials 
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   LPCWSTR                   szIpc = L"\\IPC$";
   WCHAR                     RemoteResource[UNCLEN + 5 + 1]; // UNC len + \IPC$ + NULL
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == L'\0') 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = lstrlenW( Server );

   if( Server[0] != L'\\' && Server[1] != L'\\') 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = L'\\';
      RemoteResource[1] = L'\\';
      RemoteResource[2] = L'\0';
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = L'\0';
   }

   if(cchServer > CNLEN) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if(lstrcatW(RemoteResource, Server) == NULL) 
   {
      return FALSE;
   }
   if(lstrcatW(RemoteResource, szIpc) == NULL) 
   {
      return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_IPC;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}

BOOL
   EstablishShare(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Share,        // in - share name
      LPWSTR                 Domain,       // in - domain name for credentials to connect with
      LPWSTR                 UserName,     // in - user name to connect as
      LPWSTR                 Password,     // in - password for username
      BOOL                   bEstablish    // in - TRUE=connect, FALSE=disconnect
    )
{
   WCHAR                     RemoteResource[MAX_PATH]; 
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == L'\0') 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = lstrlenW( Server );

   if( Server[0] != L'\\' && Server[1] != L'\\') 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = L'\\';
      RemoteResource[1] = L'\\';
      RemoteResource[2] = L'\0';
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = L'\0';
   }

   if(cchServer > CNLEN) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if(lstrcatW(RemoteResource, Server) == NULL) 
   {
      return FALSE;
   }
   if(lstrcatW(RemoteResource, Share) == NULL) 
   {
      return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_DISKDEV;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}



void
   InitLsaString(
      PLSA_UNICODE_STRING    LsaString,    // i/o- pointer to LSA string to initialize
      LPWSTR                 String        // in - value to initialize LSA string to
    )
{
   DWORD                     StringLength;

   if( String == NULL ) 
   {
       LsaString->Buffer = NULL;
       LsaString->Length = 0;
       LsaString->MaximumLength = 0;
   }
   else
   {
      StringLength = lstrlenW(String);
      LsaString->Buffer = String;
      LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
      LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
   }
}

BOOL
   GetDomainSid(
      LPWSTR                 PrimaryDC,   // in - domain controller of domain to acquire Sid
      PSID                 * pDomainSid   // out- points to allocated Sid on success
    )
{
   NET_API_STATUS            nas;
   PUSER_MODALS_INFO_2       umi2 = NULL;
   DWORD                     dwSidSize;
   BOOL                      bSuccess = FALSE; // assume this function will fail
   
   *pDomainSid = NULL;    // invalidate pointer

   __try {

   //
   // obtain the domain Sid from the PDC
   //
   nas = NetUserModalsGet(PrimaryDC, 2, (LPBYTE *)&umi2);
   
   if(nas != NERR_Success) __leave;
   //
   // if the Sid is valid, obtain the size of the Sid
   //
   if(!IsValidSid(umi2->usrmod2_domain_id)) __leave;
   
   dwSidSize = GetLengthSid(umi2->usrmod2_domain_id);

   //
   // allocate storage and copy the Sid
   //
   *pDomainSid = LocalAlloc(LPTR, dwSidSize);
   
   if(*pDomainSid == NULL) __leave;

   if(!CopySid(dwSidSize, *pDomainSid, umi2->usrmod2_domain_id)) __leave;

   bSuccess = TRUE; // indicate success

    } // try
    
    __finally 
    {

      if(umi2 != NULL)
      {
         NetApiBufferFree(umi2);
      }

      if(!bSuccess) 
      {
        //
        // if the function failed, free memory and indicate result code
        //

         if(*pDomainSid != NULL) 
         {
            FreeSid(*pDomainSid);
            *pDomainSid = NULL;
         }

         if( nas != NERR_Success ) 
         {
            SetLastError(nas);
         }
      }

   } // finally

   return bSuccess;
}

NTSTATUS 
   OpenPolicy(
      LPWSTR                 ComputerName,   // in - computer name
      DWORD                  DesiredAccess,  // in - access rights needed for policy
      PLSA_HANDLE            PolicyHandle    // out- LSA handle
    )
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   LSA_UNICODE_STRING        ComputerString;
   PLSA_UNICODE_STRING       Computer = NULL;
   LPWSTR                    NewComputerName;

   NewComputerName = (WCHAR*)LocalAlloc(LPTR,
        (MAX_COMPUTERNAME_LENGTH+3)*sizeof(WCHAR));

   //
   // Prepend some backslashes to the computer name so that
   // this will work on NT 3.51
   //
   lstrcpy(NewComputerName,L"\\\\");
   lstrcat(NewComputerName,ComputerName);

   lstrcpy(NewComputerName,ComputerName);

   //
   // Always initialize the object attributes to all zeroes
   //
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   if(ComputerName != NULL) 
   {
      //
      // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
      //
      InitLsaString(&ComputerString, NewComputerName);

      Computer = &ComputerString;
   }

   //
   // Attempt to open the policy
   //
   return LsaOpenPolicy(Computer,&ObjectAttributes,DesiredAccess,PolicyHandle);
}

/*++
 This function sets the Primary Domain for the workstation.

 To join the workstation to a Workgroup, ppdi.Name should be the name of
 the Workgroup and ppdi.Sid should be NULL.

--*/
NTSTATUS
   SetPrimaryDomain(
      LSA_HANDLE             PolicyHandle,      // in -policy handle for computer
      PSID                   DomainSid,         // in - sid for new domain
      LPWSTR                 TrustedDomainName  // in - name of new domain
    )
{
   POLICY_PRIMARY_DOMAIN_INFO ppdi;

   InitLsaString(&ppdi.Name, TrustedDomainName);
   
   ppdi.Sid = DomainSid;

   return LsaSetInformationPolicy(PolicyHandle,PolicyPrimaryDomainInformation,&ppdi);
}


// This function removes the information from the domain the computer used to
// be a member of
void 
   QueryWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,   // in - policy handle for computer
      PSID                   DomainSid,      // in - SID for new domain the computer is member of
      BOOL                   bNoChange       // in - flag indicating whether to write changes
   )
{
   // This function is not currently used.
   NTSTATUS                  Status;
   LSA_ENUMERATION_HANDLE    h = 0;
   LSA_TRUST_INFORMATION   * ti = NULL;
   ULONG                     count;

   Status = LsaEnumerateTrustedDomains(PolicyHandle,&h,(void**)&ti,50000,&count);

   if ( Status == STATUS_SUCCESS )
   {
      for ( UINT i = 0 ; i < count ; i++ )
      {
         if ( !bNoChange && !EqualSid(DomainSid,ti[i].Sid) )
         {
            // Remove the old trust
            Status = LsaDeleteTrustedDomain(PolicyHandle,ti[i].Sid);

            if ( Status != STATUS_SUCCESS )
            {
               
            }
         }
      }
      LsaFreeMemory(ti);
   }
   else
   {
      
   }
}


/*++
 This function manipulates the trust associated with the supplied
 DomainSid.

 If the domain trust does not exist, it is created with the
 specified password.  In this case, the supplied PolicyHandle must
 have been opened with POLICY_TRUST_ADMIN and POLICY_CREATE_SECRET
 access to the policy object.

--*/
NTSTATUS
   SetWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - Sid of domain to manipulate
      LPWSTR                 TrustedDomainName,    // in - trusted domain name to add/update
      LPWSTR                 Password,             // in - new trust password for trusted domain
      LPWSTR                 errOut                // out- error text if function fails
    )
{
   LSA_UNICODE_STRING        LsaPassword;
   LSA_UNICODE_STRING        KeyName;
   LSA_UNICODE_STRING        LsaDomainName;
   DWORD                     cchDomainName; // number of chars in TrustedDomainName
   NTSTATUS                  Status;

   InitLsaString(&LsaDomainName, TrustedDomainName);

   //
   // ...convert TrustedDomainName to uppercase...
   //
   cchDomainName = LsaDomainName.Length / sizeof(WCHAR);
   
   while(cchDomainName--) 
   {
      LsaDomainName.Buffer[cchDomainName] = towupper(LsaDomainName.Buffer[cchDomainName]);
   }

   //
   // ...create the trusted domain object
   //
   Status = LsaSetTrustedDomainInformation(
     PolicyHandle,
     DomainSid,
     TrustedDomainNameInformation,
     &LsaDomainName
     );

   if(Status == STATUS_OBJECT_NAME_COLLISION)
   {
      //printf("LsaSetTrustedDomainInformation: Name Collision (ok)\n");
   }
   else if (Status != STATUS_SUCCESS) 
   {
      err.SysMsgWrite(ErrE,LsaNtStatusToWinError(Status),DCT_MSG_LSA_OPERATION_FAILED_SD,L"LsaSetTrustedDomainInformation", Status);
      return RTN_ERROR;
   }

   InitLsaString(&KeyName, L"$MACHINE.ACC");
   InitLsaString(&LsaPassword, Password);

   //
   // Set the machine password
   //
   Status = LsaStorePrivateData(
     PolicyHandle,
     &KeyName,
     &LsaPassword
     );

   if(Status != STATUS_SUCCESS) 
   {
      err.SysMsgWrite(ErrE,LsaNtStatusToWinError(Status),DCT_MSG_LSA_OPERATION_FAILED_SD,L"LsaStorePrivateData", Status);
      return RTN_ERROR;
   }

   return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\lsautils.h ===
/*---------------------------------------------------------------------------
  File: LSAUtils.h

  Comments: Utility functions to change the domain affiliation of a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/


#include "ntsecapi.h"

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS                  ((NTSTATUS)0x00000000L)
#define STATUS_OBJECT_NAME_NOT_FOUND    ((NTSTATUS)0xC0000034L)
#define STATUS_OBJECT_NAME_COLLISION    ((NTSTATUS)0xC0000035L)
#define STATUS_INVALID_SID              ((NTSTATUS)0xC0000078L)
#endif


BOOL
   GetDomainDCName(
      LPWSTR                 Domain,       // in - domain name
      LPWSTR               * pPrimaryDC    // out- PDC name
    );

BOOL
   EstablishNullSession(
      LPCWSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=connect,FALSE=disconnect
    );

void
   InitLsaString(
      PLSA_UNICODE_STRING    LsaString,   // in - pointer to LSA string to initialize
      LPWSTR                 String       // in - value to initialize string to
    );

NTSTATUS
   OpenPolicy(
      LPWSTR                 ComputerName,   // in - computer name
      DWORD                  DesiredAccess,  // in - required access
      PLSA_HANDLE            PolicyHandle    // out- policy handle
    );

BOOL
   GetDomainSid(
      LPWSTR                 DomainName,   // in - domain name to acquire Sid of
      PSID                 * pDomainSid    // out- points to allocated Sid on success
    );

NTSTATUS
   SetWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - Sid of domain to manipulate
      LPWSTR                 TrustedDomainName,    // in - trusted domain name to add/update
      LPWSTR                 Password,             // in - new trust password for trusted domain
      LPWSTR                 errOut                // out- error text, if failure
    );

NTSTATUS
   SetPrimaryDomain(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - SID for new primary domain
      LPWSTR                 TrustedDomainName     // in - name of new primary domain
    );

void  
   QueryWorkstationTrustedDomainInfo(
       LSA_HANDLE            PolicyHandle,   // in - policy handle
       PSID                  DomainSid,      // in - SID for new primary domain
       BOOL                  bNoChange       // in - flag, no change mode
   );


BOOL
   EstablishSession(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Domain,       // in - domain for Username account
      LPWSTR                 Username,     // in - username to connnect as
      LPWSTR                 Password,     // in - password for Username account
      BOOL                   bEstablish    // in - TRUE=connect, FALSE=disconnect
    );

BOOL
   EstablishShare(
      LPCWSTR                Server,      // in - server name
      LPWSTR                 Share,       // in - share name to connect to
      LPWSTR                 Domain,      // in - domain for credentials
      LPWSTR                 UserName,    // in - username to connect as
      LPWSTR                 Password,    // in - password for credentials
      BOOL                   bEstablish   // in - TRUE=connect, FALSE=disconnect
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\dommigsi\rootnode.cpp ===
// This node class represents the root node of our snap-in
#include "stdafx.h"
#include "MyNodes.h"
#include "DomSel.h"
#include "TSync.hpp"
#include "ResStr.h"
#include "HrMsg.h"

//#import "\bin\DBManager.tlb" no_namespace,named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace,named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "UpdateMOT.tlb" no_namespace,named_guids

// {C8C24622-3FA1-11d3-8AED-00A0C9AFE114}
static const GUID CRootGUID_NODETYPE = 
{ 0xc8c24622, 0x3fa1, 0x11d3, { 0x8a, 0xed, 0x0, 0xa0, 0xc9, 0xaf, 0xe1, 0x14 } };

const GUID*  CRootNode::m_NODETYPE = &CRootGUID_NODETYPE;
const OLECHAR* CRootNode::m_SZNODETYPE = OLESTR("C8C24622-3FA1-11d3-8AED-00A0C9AFE114");
const OLECHAR* CRootNode::m_SZDISPLAY_NAME = NULL;
const CLSID* CRootNode::m_SNAPIN_CLASSID = &CLSID_DomMigrator;
static LONG SnapInCount = -1;

extern "C" int runWizard(int whichWizard, HWND hParentWindow);
#define  WIZARD_SEMNAME  L"McsDomMigrAgent.990000.Sem"

CSnapInToolbarInfo   m_toolBar;


namespace
{




//---------------------------------------------------------------------------
// DisplayError Helper Function
//---------------------------------------------------------------------------

void DisplayError(HRESULT hr, UINT uFormatId)
{
   _com_error ce = GetError(hr);

   if (FAILED(ce.Error()))
   {
      CString strTitle;
      strTitle.LoadString(IDS_Title);

      CString strMessage;
      strMessage.Format(uFormatId);

      _bstr_t bstrSource = ce.Source();

      if (bstrSource.length() > 0)
      {
         strMessage += _T(" : ");
         strMessage += bstrSource;
      }

      _bstr_t bstrDescription = ce.Description();

      if (bstrDescription.length() > 0)
      {
         strMessage += _T(" : ");
         strMessage += bstrDescription;
      }
      else
      {
         CString strError;
         strError.Format(_T(" : %s (%08lX)"), ce.ErrorMessage(), ce.Error());

         strMessage += strError;
      }

      MessageBox(NULL, strMessage, strTitle, MB_OK|MB_ICONERROR);
   }
}


}


CRootNode::CRootNode() :
   m_hwndMainWindow(0)
{
   // Initialize the array of children
   CReportingNode * pNode = new CReportingNode;

   pNode->UpdateChildren(NULL);
   m_ChildArray.Add(pNode);
   UpdateMigratedObjectsTable();
   UpdateAccountReferenceTable();
   CheckForFailedActions(FALSE);
   //m_ChildArray.Add(new CPruneGraftNode);
   if (InterlockedIncrement(&SnapInCount) == 0)
      m_SZDISPLAY_NAME = GET_BSTR(IDS_ActiveDirectoryMigrationTool).copy();
}

CRootNode::~CRootNode()
{
   if ((m_SZDISPLAY_NAME) && (InterlockedDecrement(&SnapInCount) < 0))
   {
      SysFreeString(const_cast<OLECHAR*>(m_SZDISPLAY_NAME));
      m_SZDISPLAY_NAME = NULL;
   }
}

class CWizardRunner
{
public:
   int RunTheWizard(int wizardNdx, HWND hwndParent)
   {
      int                    result = 0;
      TSemaphoreNamed        cSem;         // named semaphore
      BOOL                   bExisted = FALSE;
      CString                message;
      CString                title;
     
      DWORD                  rcOs = cSem.Create( WIZARD_SEMNAME, 0, 1, &bExisted );
      
      if ( rcOs || bExisted )
      {
         message.LoadString(IDS_WizardAlreadyRunning);
         title.LoadString(IDS_Title);
         MessageBox(NULL,message,title,MB_OK | MB_ICONERROR);
         
      }
      else
      {
         result = runWizard(wizardNdx, hwndParent);

         // if user cancels wizard or an error occurs

         if (result == 0)
         {
            // if able to retrieve error information
            // then an error occurred, notify user

            // Note: It is currently possible for errors
            // to occur without the error information being set

            DisplayError(S_OK, IDS_ERR_RUN_WIZARD);
         }
      }

      return result;
   }

};


void CRootNode::CheckUndoable()
{
   IIManageDBPtr             pDB;
   HRESULT                   hr;
   _bstr_t                   sWizard = L"Options.Wizard";
   long                      lAction = -2;
   VARIANT                   var;
   _variant_t                vnt;

   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )  
      hr = pDB->raw_GetCurrentActionID(&lAction);
   if ( SUCCEEDED(hr) )
   {
      VariantInit(&var);
      hr = pDB->raw_GetActionHistoryKey(lAction, sWizard, &var);
      vnt.Attach(var);
   }
   if ( SUCCEEDED(hr) && (V_VT(&vnt) == VT_BSTR) )
   {
      sWizard = vnt;
      if (sWizard.length() > 0)
      {
         IsUndoable = ( !_wcsicmp(sWizard, L"user") || !_wcsicmp(sWizard, L"group") || !_wcsicmp(sWizard, L"computer") );
         if ( IsUndoable )
         {
            sWizard = GET_BSTR(DCTVS_Options_NoChange);
            VariantInit(&var);
            hr = pDB->raw_GetActionHistoryKey(lAction, sWizard, &var);
            vnt.Attach(var);
            if ( SUCCEEDED(hr) && (V_VT(&vnt) == VT_BSTR) )
            {
               sWizard = vnt;
               if (!sWizard || !UStrICmp(sWizard,GET_STRING(IDS_YES)) )
               {
                  IsUndoable = false; // can't undo a no-change mode operation
               }
            }
         }
      }
      else
      {
         IsUndoable = false;
      }
   }
   else
   {
      IsUndoable = false;
   }
   if ( hr == 0x800a0bb9 )
   {
      // the database is missing or corrupt
      CString           msg;
      CString           title;
      
      msg.LoadString(IDS_NoDatabase);
      title.LoadString(IDS_Title);
      MessageBox(NULL,msg,title,MB_ICONERROR | MB_OK);
      throw new _com_error(hr);
   }
}

void CRootNode::CheckForST()
{
   IIManageDBPtr              pDB;

   HRESULT                   hr = S_OK;
   long                      cnt;

   CanUseST = false;
   if ( SUCCEEDED(hr) )
   {
      hr = pDB.CreateInstance(CLSID_IManageDB);
   }
   if ( SUCCEEDED(hr) )  
   {
      hr = pDB->raw_AreThereAnyMigratedObjects(&cnt);
   }
   if ( SUCCEEDED(hr) )
   {
      if ( cnt > 0 )
      {
         // there are some migrated objects
         CanUseST = true;
      }
   }
}

void CRootNode::CheckForFailedActions(BOOL bPrompt)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   HRESULT                   hr = S_OK;
   IIManageDBPtr             pDB;
   IVarSetPtr                pVarSet(CLSID_VarSet);
   IUnknown                * pUnk = NULL;
   long                      lAction = -2;

   CanRetry = false;
   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSet.QueryInterface(IID_IUnknown,&pUnk);
      if ( SUCCEEDED(hr) )
      {
         // we will also check the last action type and set the IsUndoable flag.
         CheckUndoable();
         CheckForST();
         hr = pDB->raw_GetFailedDistributedActions(-1,&pUnk);
         pUnk->Release();
         if ( SUCCEEDED(hr) )
         {
            _bstr_t          numItemsText = pVarSet->get(L"DA");
            long             nItems = _wtoi(numItemsText);

            if ( nItems )
            {
               CString        str;
               CString        title;

               title.LoadString(IDS_Title);
               str.FormatMessage(IDS_FailedActions,nItems);
               
               CanRetry = true;
               
               if ( bPrompt && IDYES == MessageBox(NULL,str,title,MB_YESNO) )
               {
                  bool bHandled;

                  OnRetry(bHandled,NULL);
               }
            }
         }
      }
   }
   if (FAILED(hr))
   {
      DisplayError(hr, IDS_ERR_CHECK_FAILED_ACTIONS);

      _com_issue_error(hr);
   }
}


HRESULT CRootNode::OnMigrateUsers(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(1, m_hwndMainWindow);

   if (result)
   {
      CheckUndoable();
      CheckForST();
   }
   return hr;  
}

HRESULT CRootNode::OnMigrateGroups(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(2, m_hwndMainWindow);
   

   if (result)
   {
      CheckUndoable();
      CheckForST();
   }
   return hr;
}

HRESULT CRootNode::OnMigrateComputers(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;

   int                       result = r.RunTheWizard(3, m_hwndMainWindow);

   if (result)
   {
      CheckUndoable();
      CheckForFailedActions(FALSE);
   }
   return hr;
}

HRESULT CRootNode::OnTranslateSecurity(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(4, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}

HRESULT CRootNode::OnMigrateExchangeServer(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(11, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   return hr;
}
HRESULT CRootNode::OnMigrateExchangeDirectory(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(7, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   return hr;
}

HRESULT CRootNode::OnMigrateServiceAccounts(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(5, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}
HRESULT CRootNode::OnReporting(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(8, m_hwndMainWindow);
   IConsole                * pConsole = NULL;

   // Reload the Child-Nodes for the reporting node
   CReportingNode          * pRept = (CReportingNode*)m_ChildArray[0];
   
   if ( pRept )
   {
      hr = GetConsoleFromCSnapInObjectRootBase(pObj,&pConsole);
      if ( SUCCEEDED(hr) )
      {   
         pRept->UpdateChildren(pConsole);
      }
   }
   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}

HRESULT CRootNode::OnUndo(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(6, m_hwndMainWindow);

   if (result)
   {
      IsUndoable = false;
      CheckForST();
   }
   return hr;
}

HRESULT CRootNode::OnRetry(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   CWizardRunner             r;
   int                       result = r.RunTheWizard(9, m_hwndMainWindow);

   if (result)
      IsUndoable = false;
   CheckForFailedActions(FALSE);
   return hr;
}

HRESULT CRootNode::OnMigrateTrusts(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(10, m_hwndMainWindow);
   
   if (result)
      IsUndoable = false;
   return hr;
}

HRESULT CRootNode::OnGroupMapping(bool &bHandled, CSnapInObjectRootBase* pObj)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   CWaitCursor               wait;
   HRESULT                   hr = S_OK;
   int                       result;
   CWizardRunner             r;

   result = r.RunTheWizard(12, m_hwndMainWindow);
   
   if (result)
      IsUndoable = false;
   return hr;
}


void CRootNode::UpdateMenuState(UINT id, LPTSTR pBuf, UINT *flags)
{
   switch (id)
   {
   case ID_TOP_UNDO:
      if ( !IsUndoable )
         *flags = MF_DISABLED | MF_GRAYED;
      else
         *flags = MF_ENABLED;
      break;
   
   case ID_TOP_MIGRATEEXCHANGEDIRECTORY:  
      if ( ! CanUseST )
         *flags = MF_DISABLED | MF_GRAYED;
      else
         *flags = MF_ENABLED;
      break;
   case ID_TOP_TRANSLATESECURITY:
         //always allow the Security Translation wizards now 
	     //that we can reACL using a sid mapping file
      *flags = MF_ENABLED;
      break;
   case ID_TOP_RETRY:
      if ( ! CanRetry )
         *flags = MF_DISABLED | MF_GRAYED;
      else
         *flags = MF_ENABLED;
      break;
   };
}

void CRootNode::UpdateMigratedObjectsTable()
{
   ISrcSidUpdatePtr			 pSrcUpdate(CLSID_SrcSidUpdate);
   HRESULT					 hr;
   VARIANT_BOOL              bvar;
   VARIANT_BOOL              bHide = VARIANT_FALSE;
   CString					 title;
   CString                   sFormat;
   CString					 msg;
   
      //see if the new Source domain Sid column is in this migrated object's table
   hr = pSrcUpdate->raw_QueryForSrcSidColumn(&bvar);
   if ( FAILED(hr) )
   {
	  _bstr_t sDescription = HResultToText(hr);
      title.LoadString(IDS_QUERYCLM_TITLE);
      sFormat.LoadString(IDS_ERR_QUERYCLM_MSG);
      msg.Format(sFormat, (WCHAR*)sDescription);

      MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
      _com_issue_error(hr);
	  return;
   }
      //if not then run the code to add it
   if ( bvar == VARIANT_FALSE )
   {
	     //add and populate the new source Sid column
      hr = pSrcUpdate->raw_CreateSrcSidColumn(bHide, &bvar);
      if ( FAILED(hr) )
	  {
	     _bstr_t sDescription = HResultToText(hr);
         title.LoadString(IDS_NOSRCSIDCLM_TITLE);
         sFormat.LoadString(IDS_ERR_NOSRCSIDCLM_MSG);
         msg.Format(sFormat, (WCHAR*)sDescription);

         MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
         _com_issue_error(hr);
	  }
      if ( bvar == VARIANT_FALSE )
	  {
//         title.LoadString(IDS_NOSRCSIDCLM_TITLE);
//         msg.LoadString(IDS_ERR_NOSRCSIDCLM_MSG);

//         MessageBox(NULL, msg, title, MB_ICONERROR | MB_OK);
         _com_issue_error(hr);
	  }
   }
}

void CRootNode::UpdateAccountReferenceTable()
{
   IIManageDBPtr   pDB(CLSID_IManageDB);
   VARIANT_BOOL	   bFound = VARIANT_FALSE;     
   
      //see if the new AccountSid column has already been added to
      //the AccountRefs table
   bFound = pDB->SidColumnInARTable();

      //if not there, create it
   if (!bFound)
      pDB->CreateSidColumnInAR();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\mcs.h ===
//---------------------------------------------------------------------------
// MCS.h 
//
// Main header file for all MCS applications.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_Mcs_h
#define MCSINC_Mcs_h
#ifdef __cplusplus

// Mandatory Pragma Definitions.
// #pragma warning( 3 : 4706 ) // assignment within if, while, etc.

// Header Files Common To All MCS Modules.
#include "McsDebug.h"   // contains debug macros, it depends on
                        // the following files: McsDebug.cpp,
                        // McsDebugUtil.h and McsDebugUtil.cpp.

#endif /* __cplusplus */
#endif /* MCSINC_Mcs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\enumtrst.cpp ===
/*---------------------------------------------------------------------------
  File:  McsEnumTrustRelations.cpp 

  Comments: COM object to enumerate trust relationships between domains

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  
 ---------------------------------------------------------------------------
*/// McsEnumTrustRelations.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsEnumTrustRelationsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "EnumTr.h"

#include "EnumTr_i.c"
#include "TrEnum.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TrustEnumerator, CTrustEnumerator)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSENUMTRUSTRELATIONSLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\mcsdbgu.cpp ===
//---------------------------------------------------------------------------
// McsDebugUtil.cpp
//
// The classes declared in MCSDebugUtil.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++  */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "McsDbgU.h"

// -----------
// McsDebugLog
// ----------- 
void McsDebugUtil::McsDebugLog::write 
			(const char *messageIn) {
   if (m_outStream) {
      *(m_outStream) << messageIn;
      m_outStream->flush(); 
   }
}

#endif 	/* Not WIN16_VERSION */
#endif	/* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\err.cpp ===
//#pragma title( "Err.cpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#ifndef WIN16_VERSION
   #include <lm.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <stdarg.h>
#include <share.h>
#include <time.h>
#include <rpc.h>
#include <rpcdce.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"

#define  TERR_MAX_MSG_LEN  (2000)
#define  BYTE_ORDER_MARK   (0xFEFF)


TError::TError(
      int                    displevel    ,// in -mimimum severity level to display
      int                    loglevel     ,// in -mimimum severity level to log
      WCHAR          const * filename     ,// in -file name of log (NULL if none)
      int                    logmode      ,// in -0=replace, 1=append
      int                    beeplevel     // in -min error level for beeping
   )
{
   lastError = 0;
   maxError = 0;
   logLevel = loglevel;
   dispLevel = displevel;
   logFile = NULL;
   beepLevel = beeplevel;
   LogOpen(filename, logmode, loglevel);
}


TError::~TError()
{
   LogClose();
}

// Closes any existing open logFile and opens a new log file if the fileName is
// not null.  If it is a null string, then a default fileName of "Temp.log" is
// used.
BOOL
   TError::LogOpen(
      WCHAR           const * fileName    ,// in -name of file including any path
      int                     mode        ,// in -0=overwrite, 1=append
      int                     level        // in -minimum level to log
   )
{
   BOOL                       retval=TRUE;

   if ( logFile )
   {
      fclose(logFile);
      logFile = NULL;
   }

   if ( fileName && fileName[0] )
   {
      // Check to see if the file already exists
      WIN32_FIND_DATA      fDat;
      HANDLE               hFind;
      BOOL                 bExisted = FALSE;

      hFind = FindFirstFile(fileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         FindClose(hFind);
         bExisted = TRUE;   
      }

      logFile = _wfsopen( fileName, mode == 0 ? L"wb" : L"ab", _SH_DENYNO );
      if ( !logFile )
      {
         MsgWrite( 4101, L"Log Open(%s) failed", fileName );
         retval = FALSE;
      }
      else
      {
         if (! bExisted )
         {
            // this is a new file we've just created
            // we need to write the byte order mark to the beginning of the file
            WCHAR x = BYTE_ORDER_MARK;
            fwprintf(logFile,L"%lc",x);
         }
      }
   }

   logLevel = level;

   return retval;
}


//-----------------------------------------------------------------------------
// Writes formatted message to log file and flushes buffers
//-----------------------------------------------------------------------------
void TError::LogWrite(WCHAR const * msg)
{
   WCHAR                     sTime[32];
   WCHAR                     sTemp[TERR_MAX_MSG_LEN];   
   
   // Get rid of the <CR> from the end of the message because it causes things
   // to run together in the logs
   wcscpy(sTemp, msg);
   DWORD dwLen = wcslen(sTemp);
   if ( sTemp[dwLen-1] == 0x0d )
      sTemp[dwLen-1] = 0x00;

   if ( logFile )
   {
      fwprintf(
            logFile,
            L"%s-%s\r\n",
            gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ),
            sTemp );
      fflush( logFile );
   }
}

//-----------------------------------------------------------------------------
// Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr, msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

#ifndef WIN16_VERSION
//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start(argPtr, msg);
   len = _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;
   DWORD                     lastRc = GetLastError();

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start( argPtr, msg );
   len = _vsnwprintf( suffix, DIM(suffix) - 1, msg, argPtr );

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}
#endif

//-----------------------------------------------------------------------------
// Error message format, display and exception processing function
//-----------------------------------------------------------------------------
void __stdcall
   TError::MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   )
{
   static WCHAR      const   prefLetter[] = L"TIWESVUXXXXX"; // These form the status code that appears at the start of each error message
   WCHAR                     fullmsg[TERR_MAX_MSG_LEN];
   struct
   {
      USHORT                 frequency;    // audio frequency
      USHORT                 duration;     // duration in mSec
   }                         audio[] = {{ 300,  20},{ 500,  50},{ 700, 100},
                                        { 800, 200},{1000, 300},{1500, 400},
                                        {2500, 750},{2500,1000},{2500,1000}};

   if ( num >= 0 )
      level = num / 10000;                 // 10000's position of error number
   else
      level = -1;
   if ( num == 0 )
   {
      wcsncpy(fullmsg, str, DIM(fullmsg));
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }
   else
   {
      if ( num > maxError )
         maxError = num;
      _snwprintf(fullmsg, DIM(fullmsg), L"%c%05d: %-s", prefLetter[level+1], num, str);
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }

   lastError = num;
   StrWrite(level, fullmsg);

   if ( level >= beepLevel )
      Beep(audio[level].frequency, audio[level].duration);

   if ( level >= logLevel )
      LogWrite(fullmsg);

   if ( level > 4 )
   {
      exit(level);
   }
}

//-----------------------------------------------------------------------------
// Return text for error code
//-----------------------------------------------------------------------------

WCHAR *        
   TError::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   static HMODULE            hNetMsg = NULL;
   DWORD                     rc;
   WCHAR                   * pMsg;

   msg[0] = '\0'; // force to null

   if ( code >= NERR_BASE && code < MAX_NERR )
   {
      if ( !hNetMsg )
         hNetMsg = LoadLibrary(L"netmsg.dll");
      rc = 1;
   }
   else
   {
      rc = DceErrorInqText( code, msg );
      // Change any imbedded CR or LF to blank.
      for ( pMsg = msg;
            *pMsg;
            pMsg++ )
      {
         if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
            *pMsg = L' ';
      }
      // Remove trailing blanks
      for ( pMsg--;
            pMsg >= msg;
            pMsg-- )
      {
         if ( *pMsg == L' ' )
            *pMsg = L'\0';
         else
            break;
      }
   }
   if ( rc )
   {
      if ( code >= NERR_BASE && code < MAX_NERR && hNetMsg )
      {
         FormatMessage(FORMAT_MESSAGE_FROM_HMODULE
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        hNetMsg,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
      else
      {
         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        NULL,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
   }
   return msg;
}

// Err.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\err.hpp ===
//#pragma title( "Err.hpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Err_hpp
#define  MCSINC_Err_hpp

// Start of header file dependencies

#ifndef  MCSINC_Common_hpp
#include "Common.hpp"
#endif

// End of header file dependencies

// ErrMsg error level constants
#define ErrT            (      - __LINE__) // Testing
#define ErrI            (00000 + __LINE__) // Information
#define ErrW            (10000 + __LINE__) // Warning
#define ErrE            (20000 + __LINE__) // Error
#define ErrS            (30000 + __LINE__) // Severe error
#define ErrV            (40000 + __LINE__) // Very sever error
#define ErrU            (50000 + __LINE__) // Unrecoverable error
#define ErrX            (60000 + __LINE__) // extremely unrecoverable <g>

#define ErrNone         (0)

class TError
{
protected:
   int                       level;
   int                       lastError;
   int                       maxError;
   int                       logLevel;     // minimum level to log
   int                       dispLevel;    // minimum level to display
   FILE                    * logFile;
   int                       beepLevel;
public:
                        TError(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      WCHAR          const * filename = L"",// in -file name of log (NULL if none)
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
                                             //     Some people dont like the beeps so we turned it off by default.

                        );
                        ~TError();

   void __cdecl         MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   );
#ifndef WIN16_VERSION

   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
#endif

   void __stdcall       MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   );

   virtual void __stdcall StrWrite(int level, WCHAR const * str) const { wprintf(L"%ls\n", str); };

   virtual BOOL         LogOpen(
      WCHAR          const * fileName     ,// in -name of file including any path
      int                    mode = 0     ,// in -0=overwrite, 1=append
      int                    level = 0     // in -minimum level to log
   );
   virtual void         LogClose() { if ( logFile ) fclose(logFile); };
   virtual void         LogWrite(WCHAR const * msg);
   void                 LevelSet(int displevel=0, int loglevel=-1, int beeplevel=2)
                           { dispLevel = displevel; logLevel = loglevel; beepLevel = beeplevel; };
   void                 LevelDispSet(int  displevel=0)
                           { dispLevel = displevel; };
   void                 LevelLogSet(int  loglevel=-1)
                           { logLevel = loglevel; };
   void                 LevelBeepSet(int  beeplevel=-1)
                           { beepLevel = beeplevel; };
   DWORD                MaxError()  const { return maxError; };
   DWORD                LastError() const { return lastError; };

   int                  GetMaxSeverityLevel () { return maxError / 10000; }

   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );
};

extern TError              & errCommon;

#endif  // MCSINC_Err_hpp

// Err.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\errdct.cpp ===
/*---------------------------------------------------------------------------
  File: ErrDct.cpp

  Comments: TError derived class for OnePoint Domain Administrator messages

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "ErrDct.hpp"
#include "AdsErr.h"

#define  TERR_MAX_MSG_LEN  (2000)

// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   )
{
   WCHAR                   * c;
   WCHAR                   * end;
   BOOL                      error = FALSE;
   DWORD                     rcOs;
   WCHAR                     dirName[MAX_PATH+1];
   BOOL                      isUNC = FALSE;
   BOOL                      skipShareName = FALSE;

   if ( !dirName )
      return ERROR_INVALID_PARAMETER;

   safecopy(dirName,dirToCreate);

   // Note: if the string is empty, that's ok - we will catch it when we don't see C:\ or C$\ below
   // walk through the string, and try to create at each step along the way

   do { // once
      c = dirName;
      end = dirName + UStrLen(dirName);
          // skip computer-name if UNC
      if ( *c == L'\\' && *(c + 1) == L'\\' )
      {
         isUNC = TRUE;
         for ( c=c+2 ; *c && *c != L'\\' ; c++ )
         ;
         if ( ! *c )
         {
            error = TRUE;
            rcOs = ERROR_INVALID_PARAMETER;
            break;
         }
         c++;
      }
      // skip C:\ or C$\.
      if ( *(c) &&  ( *(c+1)==L'$' || *(c+1)==L':' ) && *(c+2)==L'\\' )
      {
         c = c + 3;
         if ( c == end ) // They put in the root directory for some volume
            break;

      }
      else
      {
         if ( isUNC )
         {
            skipShareName = TRUE;
         }
         else
         {
            rcOs = ERROR_INVALID_PARAMETER;
            error = TRUE;
            break;
         }
      }
      // scan through the string looking for '\'
      for ( ; c <= end ; c++ )
      {
         if ( !*c || *c == L'\\' )
         {
            if ( skipShareName )
            {
               skipShareName = FALSE;
               continue;
            }
            // try to create at this level
            *c = L'\0';
            if ( ! CreateDirectory(dirName,NULL) )
            {
               rcOs = GetLastError();
               switch ( rcOs )
               {
               case 0:
               case ERROR_ALREADY_EXISTS:
                  break;
               default:
                  error = TRUE;
               }
            }
            if (c != end )
               *c = L'\\';
            if ( error )
                  break;
         }
      }
   } while ( FALSE );
   if ( !error )
      rcOs = 0;

   return rcOs;
}


WCHAR const *                               // ret- text for DCT message
   TErrorDct::LookupMessage(
      UINT                   msgNumber     // in - message number DCT_MSG_???
   )
{
   WCHAR             const * msg = NULL;

   return msg;
}

WCHAR *                                     // ret-text for system or EA error
   TErrorDct::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   if ( SUCCEEDED(code) )
   {
      return TError::ErrorCodeToText(code,lenMsg,msg);
   }
   else
   {
      if ( HRESULT_FACILITY(code) == FACILITY_WIN32 )
      {
         return TError::ErrorCodeToText(HRESULT_CODE(code),lenMsg,msg);
      }
      else
      {
         //Translate ADSI errors to DCT errors so message can be written.
         DWORD msgId = 0;
         switch ( code )
         {
            case (E_ADS_BAD_PATHNAME)              :   msgId = DCT_MSG_E_MSG_ADS_BAD_PATHNAME;
                                                      break;
            case (E_ADS_INVALID_DOMAIN_OBJECT)     :   msgId = DCT_MSG_E_ADS_INVALID_DOMAIN_OBJECT;
                                                      break;
            case (E_ADS_INVALID_USER_OBJECT)       :   msgId = DCT_MSG_E_ADS_INVALID_USER_OBJECT;
                                                      break;
            case (E_ADS_INVALID_COMPUTER_OBJECT)   :   msgId = DCT_MSG_E_ADS_INVALID_COMPUTER_OBJECT;
                                                      break;
            case (E_ADS_UNKNOWN_OBJECT)            :   msgId = DCT_MSG_E_ADS_UNKNOWN_OBJECT;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SET)          :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SET;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SUPPORTED)    :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SUPPORTED;
                                                      break;
            case (E_ADS_PROPERTY_INVALID)          :   msgId = DCT_MSG_E_ADS_PROPERTY_INVALID;
                                                      break;
            case (E_ADS_BAD_PARAMETER)             :   msgId = DCT_MSG_E_ADS_BAD_PARAMETER;
                                                      break;
            case (E_ADS_OBJECT_UNBOUND)            :   msgId = DCT_MSG_E_ADS_OBJECT_UNBOUND;
                                                      break;
            case (E_ADS_PROPERTY_NOT_MODIFIED)     :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_MODIFIED;
                                                      break;
            case (E_ADS_PROPERTY_MODIFIED)         :   msgId = DCT_MSG_E_ADS_PROPERTY_MODIFIED;
                                                      break;
            case (E_ADS_CANT_CONVERT_DATATYPE)     :   msgId = DCT_MSG_E_ADS_CANT_CONVERT_DATATYPE;
                                                      break;
            case (E_ADS_PROPERTY_NOT_FOUND)        :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_FOUND;
                                                      break;
            case (E_ADS_OBJECT_EXISTS)             :   msgId = DCT_MSG_E_ADS_OBJECT_EXISTS;
                                                      break;
            case (E_ADS_SCHEMA_VIOLATION)          :   msgId = DCT_MSG_E_ADS_SCHEMA_VIOLATION;
                                                      break;
            case (E_ADS_COLUMN_NOT_SET)            :   msgId = DCT_MSG_E_ADS_COLUMN_NOT_SET;
                                                      break;
            case (E_ADS_INVALID_FILTER)            :   msgId = DCT_MSG_E_ADS_INVALID_FILTER;
                                                      break;
            default                                :   msgId = 0;
         }

         if ( !msgId )
         {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         | FORMAT_MESSAGE_MAX_WIDTH_MASK
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | 80,
                           NULL,
                           code,
                           0,
                           msg,
                           lenMsg,
                           NULL );
         }
         else
         {
            static HMODULE            hDctMsg = NULL;
            DWORD                     rc = 0;   
            if ( ! hDctMsg )
            {
               hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
               if ( ! hDctMsg )
               {
                  rc = GetLastError();
               }
            }

            if ( ! rc )
            {
               FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                          hDctMsg,
                          msgId,
                          0,
                          msg,
                          lenMsg,
                          NULL);
            }
            else
            {
               swprintf(msg,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgId);
            }
            
         }
      }
   }
   return msg;
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   WCHAR                   * pMsg = NULL;
   va_list                   argPtr;
   int                       len;
   
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
      hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
      if ( ! hDctMsg )
      {
         rc = GetLastError();
      }
   }
   
   va_start(argPtr,msgNumber);
   
   if ( ! rc )
   {
      len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   va_end(argPtr);
   
   // Change any imbedded CR or LF to blank.
   for ( pMsg = suffix;
         *pMsg;
         pMsg++ )
   {
      if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
         *pMsg = L' ';
   }
   // append the system message for the lastRc at the end.
   len = UStrLen(suffix);
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len );
   }
   suffix[DIM(suffix) - 1] = '\0';
   
   va_end(argPtr);
   
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;
   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
     hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
	  if ( ! hDctMsg )
	  {
		  DWORD rc = GetLastError();
	  }

   }
   
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   va_list                   argPtr;

   va_start(argPtr,msgNumber);
   
   if ( rc == 0 )
   {
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   if ( suffix[UStrLen(suffix)-1] == L'\n' )
   {
		suffix[UStrLen(suffix)-1] = L'\0';
   }
   
   va_end(argPtr);
   
   MsgProcess(num, suffix);

}

void __cdecl
   TErrorDct::DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr,msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);

   MsgProcess(num, suffix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7D90B951_2357_11D3_AFC9_0090270D4944__INCLUDED_)
#define AFX_STDAFX_H__7D90B951_2357_11D3_AFC9_0090270D4944__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7D90B951_2357_11D3_AFC9_0090270D4944__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\mcsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McDomRes.rc
//
#define DCTVS_Options_SourceDomain      1
#define DCTVS_Options_TargetDomain      2
#define DCTVS_Options_NoChange          3
#define DCTVS_Options_LogLevel          4
#define DCTVS_Options_LogToTemp         5
#define DCTVS_Options_Logfile           6
#define DCTVS_Options_Credentials_Domain 7
#define DCTVS_Options_Credentials_UserName 8
#define DCTVS_Options_Credentials_Password 9
#define DCTVS_Options_Credentials_Server 10
#define DCTVS_Options_Credentials_Share 11
#define DCTVS_Options_ResultFile        12
#define DCTVS_Options_DeleteFileAfterLoad 13
#define DCTVS_Options_RemoveAgentOnCompletion 14
#define DCTVS_Options_SourceDomainSid   15
#define DCTVS_Options_TargetDomainSid   16
#define DCTVS_Options_LocalProcessingOnly 17
#define DCTVS_ConfigurationFile         18
#define DCTVS_InstallToServer           19
#define DCTVS_Dispatcher_ResultPath     20
#define DCTVS_StatusObject              21
#define DCTVS_Options_UniqueNumberForResultsFile 22
#define DCTVS_Options_MaxThreads        23
#define DCTVS_Options_DispatchLog       24
#define DCTVS_GatherInformation_UserRights 25
#define DCTVS_GatherInformation_ComputerPasswordAge 26
#define DCTVS_Security_ReportAccountReferences 27
#define DCTVS_Security_GatherInformation 28
#define DCTVS_Security_TranslationMode  29
#define DCTVS_Security_BuildCacheFile   30
#define DCTVS_Security_TranslateFiles   31
#define DCTVS_Security_TranslateShares  32
#define DCTVS_Security_TranslateUserRights 33
#define DCTVS_Security_TranslateMailboxes 34
#define DCTVS_Security_TranslateContainers 35
#define DCTVS_Security_TranslateLocalGroups 36
#define DCTVS_Security_TranslatePrinters 37
#define DCTVS_Security_TranslateUserProfiles 38
#define DCTVS_Security_MapiProfile      39
#define DCTVS_Accounts_InputFile        40
#define DCTVS_Accounts_WildcardSpec     41
#define DCTVS_Accounts_WildcardSpec_Computer 42
#define DCTVS_Accounts_NumItems         43
#define DCTVS_AccountOptions_CopyUsers  44
#define DCTVS_AccountOptions_CopyLocalGroups 45
#define DCTVS_AccountOptions_CopyGlobalGroups 46
#define DCTVS_AccountOptions_CopyComputers 47
#define DCTVS_AccountOptions_Prefix     48
#define DCTVS_AccountOptions_AddToGroup 49
#define DCTVS_AccountOptions_AddToGroupOnSourceDomain 50
#define DCTVS_AccountOptions_DisableCopiedAccounts 51
#define DCTVS_AccountOptions_DisableSourceAccounts 52
#define DCTVS_AccountOptions_CopyPasswords 53
#define DCTVS_AccountOptions_GenerateStrongPasswords 54
#define DCTVS_AccountOptions_PasswordFile 55
#define DCTVS_AccountOptions_UpdateUserRights 56
#define DCTVS_AccountOptions_ReplaceExistingAccounts 57
#define DCTVS_AccountOptions_ReplaceExistingGroupMembers 58
#define DCTVS_AccountOptions_RemoveExistingUserRights 59
#define DCTVS_AccountOptions_CSVResultFile 60
#define DCTVS_AccountOptions_RenameOnly 61
#define DCTVS_AccountOptions_AddSidHistory 62
#define DCTVS_AccountOptions_TranslateRoamingProfiles 63
#define DCTVS_LocalServer_RenameTo      64
#define DCTVS_LocalServer_ChangeDomain  65
#define DCTVS_LocalServer_Reboot        66
#define DCTVS_LocalServer_RebootDelay   67
#define DCTVS_LocalServer_MigrateOnly   68
#define DCTVS_Servers_NumItems          69
#define DCTVS_JobStatus                 70
#define DCTVS_CurrentPath               71
#define DCTVS_Server_Index              72
#define DCTVS_CurrentOperation          141
#define DCTVS_Results_ErrorLevel        142
#define DCTVS_Stats_Paths               144
#define DCTVS_Stats_Servers             145
#define DCTVS_Stats_Files_Examined      146
#define DCTVS_Stats_Files_Changed       147
#define DCTVS_Stats_Files_Skipped       148
#define DCTVS_Stats_Files_CacheHits     149
#define DCTVS_Stats_Directories_Examined 150
#define DCTVS_Stats_Directories_Changed 151
#define DCTVS_Stats_Directories_Skipped 152
#define DCTVS_Stats_Directories_CacheHits 153
#define DCTVS_Stats_Shares_Examined     154
#define DCTVS_Stats_Shares_Changed      155
#define DCTVS_Stats_Shares_Skipped      156
#define DCTVS_Stats_Shares_CacheHits    157
#define DCTVS_Stats_Members_Examined    158
#define DCTVS_Stats_Members_Changed     159
#define DCTVS_Stats_Members_Skipped     160
#define DCTVS_Stats_Members_CacheHits   161
#define DCTVS_Stats_UserRights_Examined 162
#define DCTVS_Stats_UserRights_Changed  163
#define DCTVS_Stats_UserRights_Skipped  164
#define DCTVS_Stats_UserRights_CacheHits 165
#define DCTVS_Stats_Mailboxes_Examined  166
#define DCTVS_Stats_Mailboxes_Changed   167
#define DCTVS_Stats_Mailboxes_Skipped   168
#define DCTVS_Stats_Mailboxes_CacheHits 169
#define DCTVS_Stats_Containers_Examined 170
#define DCTVS_Stats_Containers_Changed  171
#define DCTVS_Stats_Containers_Skipped  172
#define DCTVS_Stats_Containers_CacheHits 173
#define DCTVS_Stats_Owners_Examined     174
#define DCTVS_Stats_Groups_Examined     175
#define DCTVS_Stats_DACL_Examined       176
#define DCTVS_Stats_SACL_Examined       177
#define DCTVS_Stats_DACE_Examined       178
#define DCTVS_Stats_SACE_Examined       179
#define DCTVS_Stats_Owners_Changed      180
#define DCTVS_Stats_Groups_Changed      181
#define DCTVS_Stats_DACL_Changed        182
#define DCTVS_Stats_SACL_Changed        183
#define DCTVS_Stats_DACE_Changed        184
#define DCTVS_Stats_SACE_Changed        185
#define DCTVS_Stats_Owners_NoTarget     186
#define DCTVS_Stats_Groups_NoTarget     187
#define DCTVS_Stats_DACE_NoTarget       188
#define DCTVS_Stats_SACE_NoTarget       189
#define DCTVS_Stats_Owners_NotSelected  190
#define DCTVS_Stats_Groups_NotSelected  191
#define DCTVS_Stats_DACE_NotSelected    192
#define DCTVS_Stats_SACE_NotSelected    193
#define DCTVS_Stats_Owners_Unknown      194
#define DCTVS_Stats_Groups_Unknown      195
#define DCTVS_Stats_DACE_Unknown        196
#define DCTVS_Stats_SACE_Unknown        197
#define DCTVS_Stats_Accounts_NumUsers   198
#define DCTVS_Stats_Accounts_NumGlobalGroups 199
#define DCTVS_Stats_Accounts_NumLocalGroups 200
#define DCTVS_Stats_Accounts_NumOther   201
#define DCTVS_Stats_Users_Examined      202
#define DCTVS_Stats_Users_Created       203
#define DCTVS_Stats_Users_Replaced      204
#define DCTVS_Stats_Users_Warnings      205
#define DCTVS_Stats_Users_Errors        206
#define DCTVS_Stats_GlobalGroups_Examined 207
#define DCTVS_Stats_GlobalGroups_Created 208
#define DCTVS_Stats_GlobalGroups_Replaced 209
#define DCTVS_Stats_GlobalGroups_Warnings 210
#define DCTVS_Stats_GlobalGroups_Errors 211
#define DCTVS_Stats_LocalGroups_Examined 212
#define DCTVS_Stats_LocalGroups_Created 213
#define DCTVS_Stats_LocalGroups_Replaced 214
#define DCTVS_Stats_LocalGroups_Warnings 215
#define DCTVS_Stats_LocalGroups_Errors  216
#define DCTVS_Stats_Computers_Examined  217
#define DCTVS_Stats_Computers_Created   218
#define DCTVS_Stats_Computers_Replaced  219
#define DCTVS_Stats_Computers_Warnings  220
#define DCTVS_Stats_Computers_Errors    221
#define DCTVS_AgentService_DebugMode    222
#define IDS_DISPLAY_NAME                223
#define IDS_SERVICE_NAME                224
#define IDS_LOCALSERVICE_PATH           225
#define IDS_SERVICE_PATH                226
#define IDS_AGENT_EXE                   227
#define IDS_SERVICE_EXE                 228
#define IDS_WORKER_DLL                  229
#define IDS_VARSET_DLL                  230
#define IDS_DATA_FILE                   231
#define IDS_EVENTSOURCE                 232
#define IDS_APPNAME                     233
#define IDS_LOG_FILENAME                234
#define DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha 235
#define DCTVS_AccountOptions_PasswordPolicy_MinUpper 236
#define DCTVS_AccountOptions_PasswordPolicy_MinLower 237
#define DCTVS_AccountOptions_PasswordPolicy_MinSpecial 238
#define DCTVS_AccountOptions_PasswordPolicy_MinDigit 239
#define IDS_DOMAIN_ADMIN_REGKEY         240
#define IDS_AgentResultFileFmt          241
#define IDS_ACCT_REPL_OPERATION_TEXT    242
#define IDS_FST_OPERATION_TEXT          243
#define IDS_EST_OPERATION_TEXT          244
#define IDS_DCT_Status_Completed        245
#define DCTVSFmt_Accounts_D             246
#define DCTVSFmt_Accounts_TargetName_D  247
#define DCTVSFmt_Accounts_Type_D        248
#define IDS_LGST_OPERATION_TEXT         249
#define IDS_URST_OPERATION_TEXT         250
#define DCTVSFmt_Servers_D              251
#define IDS_RESULT_SHARE_NAME           252
#define IDS_RESULT_SHARE_REMARK         253
#define IDS_CACHE_FILE_NAME             254
#define IDS_DCTVSFmt_MigrateServers_D   255
#define IDS_DCTVSFmt_MigrateServers_RenameTo_D 256
#define IDS_DCTVSFmt_MigrateServers_ChangeDomain_D 257
#define IDS_DCTVSFmt_MigrateServers_Reboot_D 258
#define IDS_DCTVSFmt_MigrateServers_RebootDelay_D 259
#define IDS_DCTVSFmt_Servers_RenameTo_D 260
#define IDS_DCTVSFmt_Servers_ChangeDomain_D 261
#define IDS_DCTVSFmt_Servers_Reboot_D   262
#define IDS_DCTVSFmt_Servers_RebootDelay_D 263
#define IDS_DCTVSFmt_Servers_MigrateOnly_D 264
#define DCTVS_Options_CreateTempCredentials 265
#define DCTVS_Options_OuPath            266
#define IDS_DCTVSFmt_PlugIn_RegisterFiles_D 267
#define IDS_YES                         268
#define IDS_DEBUG_SWITCH                269
#define IDS_HKLM_DomainAdmin_Key        270
#define IDS_AGENT_DIRECTORY             271
#define IDS_DCTVS_Fmt_PlugIn_D          272
#define DCTVS_Options                   273
#define DCTVS_Accounts                  274
#define IDS_Replace                     275
#define IDS_MSG_ComputerAccountNotWorkstation 276
#define IDS_DCT_Status_NotStarted       277
#define IDS_DCT_Status_InProgress       278
#define IDS_DCT_Status_Aborting         279
#define IDS_DCT_Status_Aborted          280
#define IDS_DCT_Status_Unknown          281
#define DCTVS_Stats                     282
#define IDS_DCT_NoStatsAvailable        283
#define IDS_DCTVSFmt_Job_D              284
#define IDS_DCTVSFmt_JobStatus_D        285
#define IDS_DCTVSFmt_Job_StartTime_D    286
#define IDS_DCTVSFmt_Job_EndTime_D      287
#define IDS_DCTVSFmt_PlugIn_D           288
#define IDS_DCTVSFmt_PlugIn_Interface_D 289
#define DCTVS_PlugIn_Interface_Count    290
#define DCTVS_CopiedAccount_SourceName  291
#define DCTVS_CopiedAccount_SourcePath  292
#define DCTVS_CopiedAccount_SourceRID   293
#define DCTVS_CopiedAccount_SourceSam   294
#define DCTVS_CopiedAccount_SourceProfile 295
#define DCTVS_CopiedAccount_Status      296
#define DCTVS_CopiedAccount_TargetName  297
#define DCTVS_CopiedAccount_TargetPath  298
#define DCTVS_CopiedAccount_TargetProfile 299
#define DCTVS_CopiedAccount_TargetRID   300
#define DCTVS_CopiedAccount_TargetSam   301
#define DCTVS_CopiedAccount_Type        302
#define IDS_Special                     303
#define IDS_All                         304
#define IDS_AccountMigration            305
#define IDS_WriteChanges_No             306
#define IDS_CopyUsers_Yes               307
#define IDS_CopyUsers_No                308
#define IDS_CopyGlobalGroups_Yes        309
#define IDS_CopyGlobalGroups_No         310
#define IDS_CopyLocalGroups_Yes         311
#define IDS_CopyLocalGroups_No          312
#define IDS_CopyComputers_Yes           313
#define IDS_CopyComputers_No            314
#define IDS_ReplaceExisting_Yes         315
#define IDS_DisableAll_Yes              316
#define IDS_DisableSpecial_Yes          317
#define IDS_DisableSourceAccounts_Yes   318
#define IDS_StrongPwd_All               319
#define IDS_StrongPwd_Special           320
#define IDS_PasswordFile                321
#define IDS_AddToGroup                  322
#define IDS_AddToGroupOnTargetDescription_S 323
#define IDS_AddToGroupOnSourceDescription_S 324
#define IDS_NotAllowedOnDomainController 325
#define IDS_CannotTrustSelf             326
#define IDS_CannotGetDCName             327
#define IDS_No                          328
#define IDS_ScanningExchangeDirectory   329
#define IDS_Examining                   331
#define IDS_Add                         332
#define IDS_Remove                      333
#define DCTVS_Options_DispatchCSV       334
#define DCTVS_SUB_ERROR                 335
#define IDS_UNKNOWN_TYPE                336
#define DCTVS_Options_SourceServer      337
#define DCTVS_Options_TargetServer      338
#define DCTVS_AccountOptions_Suffix     339
#define DCTVS_AccountOptions_CopyCompters 340
#define DCTVS_AccountOptions_CopyOUs    341
#define DCTVS_AccountOptions_CopyContainerContents 342
#define DB_ActionID                     343
#define DB_Time                         344
#define DB_SourceDomain                 345
#define DB_TargetDomain                 346
#define DB_SourceAdsPath                347
#define DB_TargetAdsPath                348
#define DB_SourceSamName                349
#define DB_TargetSamName                350
#define DB_Type                         351
#define DB_GUID                         352
#define DB_status                       353
#define DCTVS_CopiedAccount_GUID        354
#define IDS_CLSET_MEMBER_NOT_INCLUDED   355
#define IDS_CLSET_GROUP_NOT_INCLUDED    356
#define DCTVS_Options_AppendToLogs      357
#define DCTVS_Options_Undo              358
#define DCTVS_Options_GlobalOperationMask 359
#define DCTVS_Accounts_D_OperationMask  360
#define DCTVS_ActionID_D                361
#define DCTVS_ActionID_Servers_SD       362
#define DCTVS_ActionID_Servers_Status_SD 363
#define DCTVS_AREXT_NUMITEM             364
#define DCTVS_AREXTENSIONS_D            365
#define DCTVS_Security_TranslateMigratedObjects 366
#define DCTVS_AccountOptions_ExpireSourceAccounts 367
#define DCTVS_AccountOptions_SidHistoryCredentials_Domain 368
#define DCTVS_AccountOptions_SidHistoryCredentials_UserName 369
#define DCTVS_AccountOptions_SidHistoryCredentials_Password 370
#define DCTVS_AccountOptions_CopyMemberOf 371
#define DCTVS_DBManager                 372
#define DCTVS_Servers                   373
#define DCTVS_Reports_Generate          374
#define DCTVS_Reports_Directory         375
#define DCTVS_Reports_MigratedAccounts  376
#define DCTVS_Reports_MigratedComputers 377
#define DCTVS_Reports_ExpiredComputers  378
#define DCTVS_Reports_AccountReferences 379
#define DCTVS_Reports_NameConflicts     380
#define IDS_REGKEY_REPORTS              381
#define IDS_REGST_OPERATION_TEXT        382
#define DCTVS_Security_TranslateRegistry 383
#define DCTVS_AccountOptions_IncludeMigratedAccts 384
#define DCTVS_GatherInformation         385
#define DCTVS_Options_Prefix            386
#define DCTVS_Options_Suffix            387
#define DCTVS_AccountOptions_PasswordPolicy_MinLength 388
#define DCTVS_Options_SourceDomainDns   389
#define DCTVS_Options_TargetDomainDns   390
#define IDS_REPORT_MigratedAccounts     391
#define IDS_REPORT_MigratedComputers    392
#define IDS_REPORT_ExpiredComputers     393
#define IDS_REPORT_AccountReferences    394
#define IDS_REPORT_NameConflicts        395
#define IDS_TABLE_FIELD_SourceDomain    396
#define IDS_TABLE_FIELD_TargetDomain    397
#define IDS_TABLE_FIELD_Type            398
#define IDS_TABLE_FIELD_SourceAdsPath   399
#define IDS_TABLE_FIELD_TargetAdsPath   400
#define IDS_TABLE_FIELD_Status          401
#define IDS_TABLE_FIELD_Time            402
#define IDS_TABLE_FIELD_DomainName      403
#define IDS_TABLE_FIELD_CompName        404
#define IDS_TABLE_FIELD_Description     405
#define IDS_TABLE_FIELD_PwdAge          406
#define IDS_TABLE_FIELD_Account         407
#define IDS_TABLE_FIELD_Server          408
#define IDS_TABLE_FIELD_RefCount        409
#define IDS_TABLE_FIELD_RefType         410
#define IDS_TABLE_FIELD_SourceType      411
#define IDS_TABLE_FIELD_TargetType      412
#define IDS_TABLE_FIELD_SourceDesc      413
#define IDS_TABLE_FIELD_TargetDesc      414
#define IDS_TABLE_FIELD_SrcFullName     415
#define IDS_TABLE_FIELD_TgtFullName     416
#define IDS_NAMECONFLICTS               417
#define IDS_DISPATCHING                 418
#define DCTVS_Options_Wizard            419
#define DCTVS_Reports_MigratedAccounts_TimeGenerated 421
#define DCTVS_Reports_MigratedComputers_TimeGenerated 422
#define DCTVS_Reports_ExpiredComputers_TimeGenerated 423
#define DCTVS_Reports_AccountReferences_TimeGenerated 424
#define DCTVS_Reports_NameConflicts_TimeGenerated 425
#define DCTVS_Options_GuiOnlyRebootSaver 426
#define DCTVS_CopiedAccount_DoNotUpdatePassword 427
#define IDS_TEMP_FILE_1                 428
#define IDS_TEMP_FILE_2                 429
#define IDS_HKLM_WINDOWS_NT             430
#define IDS_CurrentVersion              431
#define IDS_CSDVersion                  432
#define IDS_HKLM_MICROSOFT              433
#define IDS_START_FAILED                434
#define IDS_UNSOUPPORTED_OS             435
#define IDS_AGENT_RUNNING               436
#define DCTVS_Options_DeleteJobFile     437
#define IDS_BUILDING_ACCOUNT_LIST       438
#define IDS_EXPANDING_MEMBERSHIP        439
#define IDS_EXPANDING_CONTAINERS        440
#define IDS_MERGING_EXPANDED_LISTS      441
#define IDS_CREATING_S                  442
#define IDS_MAPPING_PROPS_S             443
#define IDS_UPDATING_PROPS_S            444
#define IDS_EVENT_SOURCE                445
#define IDS_RUNNING_EXTS_S              446
#define IDS_TRANSLATE_ROAMING_PROFILE_S 447
#define IDS_ADDING_SIDHISTORY_S         448
#define IDS_UPDATING_GROUP_MEMBERSHIPS_S 449
#define IDS_EXPANDING_ADDING_SS         450
#define IDS_EXPANDING_IGNORING_SS       451
#define IDS_EXPANDING_GROUP_ADDING_SS   452
#define IDS_DELETING_S                  453
#define DCTVS_Options_IsIntraforest     454
#define IDS_EXTRACTING_COMP_PWD_AGE     455
#define IDS_Gathering_SvcAcct           456
#define DCTVS_Results_LogFile           457
#define IDS_REGKEY_PROFILE_EXTENSIONS   458
#define IDS_COM_DisTarget               459
#define IDS_COM_DisPid                  460
#define IDS_COM_DisPidVer               461
#define IDS_COM_AcctReplName            462
#define IDS_COM_AcctReplPid             463
#define IDS_COM_AcctReplPidVer          464
#define IDS_COM_ChgDomName              465
#define IDS_COM_ChgDomPidVer            466
#define IDS_COM_ChgDomPid               467
#define IDS_COM_ChkName                 468
#define IDS_COM_ChkPid                  469
#define IDS_COM_ChkPidVer               470
#define IDS_COM_PIInfoName              471
#define IDS_COM_PIInfoPid               472
#define IDS_COM_PIInfoPidVer            473
#define IDS_COM_CompAgeName             474
#define IDS_COM_CompAgePid              475
#define IDS_COM_CompAgePidVer           476
#define IDS_COM_RebootName              477
#define IDS_COM_RebootPid               478
#define IDS_COM_RebootPidVer            479
#define IDS_COM_RenameName              480
#define IDS_COM_RenamePid               481
#define IDS_COM_RenamePidVer            482
#define IDS_COM_SecTransName            483
#define IDS_COM_SecTransPid             484
#define IDS_COM_SecTransPidVer          485
#define IDS_COM_StatusObjName           486
#define IDS_COM_StatusObjPid            487
#define IDS_COM_StatusObjPidVer         488
#define IDS_COM_URName                  489
#define IDS_COM_URPid                   490
#define IDS_COM_URPidVer                491
#define DB_SourceRid                    492
#define DB_TargetRid                    493
#define IDS_DOM_LOC_GRP_COMMENT         494
#define DCTVS_CopiedAccount_Operations  495
#define IDS_Reporting                   496
#define IDS_ReportsMMCNode              497
#define IDS_ActiveDirectoryMigrationTool 503
#define DCTVS_Stats_Generic_Errors      504
#define DCTVS_Stats_Generic_Warnings    505
#define DCTVS_Stats_Generic_Examined    506
#define DCTVS_Stats_Generic_Created     507
#define DCTVS_Stats_Generic_Replaced    508
#define IDS_Unspecified_Failure         509
#define IDS_RegKeyRebootMessage         510
#define IDS_UNRESOLVED                  511
#define IDS_AGENT_INTEL_DIR             512
#define IDS_AGENT_ALPHA_DIR             513
#define IDS_STReference_File            514
#define IDS_STReference_Dir             515
#define IDS_STReference_Share           516
#define IDS_STReference_Mailbox         517
#define IDS_STReference_Container       518
#define IDS_STReference_Member          519
#define IDS_STReference_UserRight       520
#define IDS_STReference_RegKey          521
#define IDS_STReference_Printer         522
#define DCTVS_Options_SourceServerOverride 523
#define DCTVS_Options_TargetServerOverride 524
#define DCTVS_Options_AllowDuplicateUPNs 525
#define DCT_MSG_CHANGE_GROUP_TYPE_S     526
#define DCT_MSG_RECORD_REMOVE_MEMBER_S  527
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_S 528
#define DCT_MSG_UPDATE_MEMBER_LIST_S    529
#define DCT_MSG_RESET_GROUP_MEMBERS_S   530
#define DCT_MSG_RESET_MEMBERSHIP_S      531
#define DCT_MSG_MOVING_S                532
#define DCT_MSG_RECORD_REMOVE_MEMBEROF_SS 533
#define DCT_MSG_RESET_OBJECT_MEMBERSHIP_SS 534
#define DCT_MSG_RECORD_REMOVE_MEMBER_SS 535
#define DCT_MSG_RESET_GROUP_MEMBERS_SS  536
#define IDS_HiddenShare                 537
#define IDS_AgentDirectoryName          538
#define IDS_HiddenShareRemark           539
#define DCTVS_Security_AlternateCacheFile 540
#define IDS_RenamedRecyclerSuffix       541
#define DCTVS_Security                  542
#define DCTVS_CopiedAccount_ExpDate     543
#define DCTVS_CopiedAccount_UserFlags   544
#define DB_ExpDate                      545
#define DB_UserFlags                    546
#define IDS_TRUST_DIRECTION_DISABLED    547
#define IDS_TRUST_DIRECTION_INBOUND     548
#define IDS_TRUST_DIRECTION_OUTBOUND    549
#define IDS_TRUST_DIRECTION_BIDIRECTIONAL 550
#define IDS_TRUST_TYPE_DOWNLEVEL        551
#define IDS_TRUST_TYPE_CHILD            552
#define IDS_EVENTVW_MSG_MONJOBSTAT      553
#define IDS_EVENTVW_MSG_MONERROR        554
#define IDS_EVENTVW_MSG_MONEXIT         555
#define IDS_EVENTVW_MSG_STARTPLUGREG    556
#define IDS_EVENTVW_MSG_FILEREG         557
#define IDS_EVENTVW_MSG_PLUGREGDONE     558
#define IDS_EVENTVW_MSG_JOBDEL          559
#define IDS_EVENTVW_MSG_SETFLAG         560
#define IDS_EVENTVW_MSG_NOSETFLAG       561
#define IDS_EVENTVW_MSG_REMOVEAGENT     562
#define IDS_EVENTVW_MSG_UNREGFILES      563
#define IDS_EVENTVW_MSG_FILEDEL         564
#define IDS_EVENTVW_MSG_REMOVESVC       565
#define IDS_EVENTVW_MSG_NOREMOVEAGENT   566
#define IDS_EVENTVW_MSG_STOPLISTEN      567
#define IDS_EVENTVW_MSG_AGENTSVCINSTALLED 568
#define IDS_EVENTVW_MSG_AGENTSVCNOTINSTALLED 569
#define IDS_EVENTVW_MSG_OSVERSION       570
#define IDS_EVENTVW_MSG_REGISTERED      571
#define IDS_EVENTVW_MSG_UNREGISTERED    572
#define IDS_EVENTVW_MSG_INITOLE         573
#define IDS_EVENTVW_MSG_REGCOMPNT       574
#define IDS_EVENTVW_MSG_CREATEAGT       575
#define IDS_EVENTVW_MSG_INITRPC         576
#define IDS_EVENTVW_MSG_LISTENQ         577
#define IDS_EVENTVW_MSG_EXITENTRYP      578
#define IDS_EVENTVW_MSG_AGTEXITQ        579
#define IDS_EVENTVW_MSG_AGTEXITS        580
#define IDS_STOptions_Start             581
#define IDS_STOptions_WriteChng         582
#define IDS_STOptions_Files             583
#define IDS_STOptions_Shares            584
#define IDS_STOptions_LocalGroup        585
#define IDS_STOptions_URights           586
#define IDS_STOptions_Profiles          587
#define IDS_STOptions_RBin              588
#define IDS_STOptions_LogName           589
#define IDS_STOptions_AddMode           590
#define IDS_STOptions_RemoveMode        591
#define IDS_STOptions_ReplaceMode       592

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsEnumTrustRelations.rc
//
#define IDS_PROJNAME                    100
#define IDR_TRUSTENUMERATOR             101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h 
//
// The debug macros and support classes are declared in 
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The 
// usage of these macros is outlined in the MCS Coding 
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they throw an 
// exception McsException The usage of these macros is 
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they log the 
// message using McsVerifyLog class.  The usage of these 
// macros is outlined in the MCS Coding Standards document.  
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.  
// The output log file is created in the directory 
// defined by MCS_LOG environment variable, or in the 
// TEMP directory, or in the current directory.  The name 
// of the output log file is <module name>.err.  
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG 
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG 
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0) 

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException 
// -----------------
inline McsDebugException::McsDebugException () 
: m_message (0), m_fileName (0), m_lineNum (0) 
{ /* EMPTY */ }
   
inline McsDebugException::~McsDebugException() { 
   delete [] m_message; 
   delete [] m_fileName; 
}

inline const char *McsDebugException::getMessage 
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName 
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum 
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void) 
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void) 
: m_isTested (FALSE), m_isTestMode_ (FALSE) 
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\tsync.cpp ===
//#pragma title( "TSync.cpp - Common synchronization classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes
               TCriticalSection
               TSemaphoreNamed
Updates     -
===============================================================================
*/

#include <stdio.h>
#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <time.h>

#include "Common.hpp"
#include "Err.hpp"
#include "TSync.hpp"

///////////////////////////////////////////////////////////////////////////////
// TSemaphoreNamed member functions
///////////////////////////////////////////////////////////////////////////////

// Create named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Create(
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted     // out-TRUE=previously existed
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = CreateSemaphore( NULL, nInitial, nMaximum, sNameT );
   if ( handle == NULL )
   {
      rcOs = GetLastError();
   }
   else if ( pbExisted )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case 0:
            *pbExisted = FALSE;
            break;
         case ERROR_ALREADY_EXISTS:
            *pbExisted = TRUE;
            rcOs = 0;
            break;
         default:
            break;
      }
   }
   return rcOs;
}

// Open named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Open(
      TCHAR          const * sNameT        // in -semaphore name
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = OpenSemaphore( SEMAPHORE_ALL_ACCESS, FALSE, sNameT );
   if ( handle == NULL ) rcOs = GetLastError();
   return rcOs;
}

// Release semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Release(
      long                   nRelease      // in -number to release
   )
{
   DWORD                     rcOs;         // OS return code
   long                      nPrevious=0;  // previous count
   rcOs = ReleaseSemaphore( Handle(), nRelease, &nPrevious )
         ? 0 : GetLastError();
   return rcOs;
}


// TSync.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\tsync.hpp ===
//#pragma title( "TSync.hpp - Common synchronization classes header file" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes header file
               This includes TCriticalSection, and TNamedSemaphore
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TSync_hpp
#define  MCSINC_TSync_hpp

#ifndef _INC_TIME
#include <time.h>
#endif

class TCriticalSection
{
   CRITICAL_SECTION          cs;
public:
                        TCriticalSection() { InitializeCriticalSection(&cs); }
                        ~TCriticalSection() { DeleteCriticalSection(&cs); }
   void                 Enter() { EnterCriticalSection(&cs); }
   void                 Leave() { LeaveCriticalSection(&cs); }
};

class TSynchObject
{
public:
   HANDLE                    handle;
   TSynchObject()
   { handle = NULL; }
   ~TSynchObject()
   { Close(); }
   void Close()
   { if ( handle != NULL ) { CloseHandle( handle ); handle = NULL; } }

   DWORD                WaitSingle(DWORD msec) const { return WaitForSingleObject(handle, msec); }
   DWORD                WaitSingle()           const { return WaitForSingleObject(handle, INFINITE); }
   HANDLE               Handle() { return handle; }
};

///////////////////////////////////////////////////////////////////////////////
// Named semaphores
///////////////////////////////////////////////////////////////////////////////

class TSemaphoreNamed : public TSynchObject
{
public:
   TSemaphoreNamed() {};
   ~TSemaphoreNamed() {};
   DWORD Create(                           // ret-OS return code
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted=NULL // out-TRUE=previously existed
   );
   DWORD Open(                             // ret-OS return code
      TCHAR          const * sNameT        // in -semaphore name
   );
   DWORD Release(                          // ret-OS return code
      long                   nRelease=1    // in -number to release
   );
};


#endif  // MCSINC_TSync_hpp

// TSync.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );

#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\resstr.h ===
#ifndef RES_STRING_H
#define RES_STRING_H
#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "TSync.hpp"

#define MAX_STRING_SIZE          (5000)
#include "Mcs.h"
#include "McsRes.h"
#include "UString.hpp"

class StringLoader
{
   HINSTANCE                 m_hInstance; // handle to resources to load from
   TCriticalSection          m_cs;
   WCHAR                     m_buffer[MAX_STRING_SIZE];
   DWORD                     rc;
public:
   StringLoader() 
   { 
      WCHAR                  fullpath[400];
      DWORD                  lenValue = sizeof(fullpath);
      DWORD                  type;
         // first, try to load from our install directory
      HKEY           hKey;
#ifdef OFA         
      rc = RegOpenKey(HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\OnePointFileAdmin",&hKey);
#else
      rc = RegOpenKey(HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\DomainAdmin",&hKey);
#endif
      if ( ! rc )
      {
         
         rc = RegQueryValueEx(hKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
         if (! rc )
         {
            UStrCpy(fullpath+UStrLen(fullpath),L"McsDmRes.DLL");
         }
         RegCloseKey(hKey);
      }
      m_hInstance = LoadLibrary(fullpath);

      // If that fails, see if there's one anywhere in the path
      if ( ! m_hInstance )
      {
         m_hInstance = LoadLibrary(L"McsDmRes.DLL");
      }
      if (! m_hInstance ) 
      {
         MCSASSERTSZ(FALSE,"Failed to load McsDmRes.DLL");
         rc = GetLastError(); 
      }
   }

   WCHAR                   * GetString(UINT nID)
   {
      int                    len;
      WCHAR                * result = NULL;

      m_cs.Enter();
      m_buffer[0] = 0;
      len = LoadString(m_hInstance,nID,m_buffer,MAX_STRING_SIZE);
      if (! len )
      {
         DWORD               rc = GetLastError();
      }
      result = new WCHAR[len+1];
      wcscpy(result,m_buffer);
      m_cs.Leave();

      return result;
   }
};
          
extern StringLoader gString;
  
class TempString
{
   WCHAR                   * m_data;
public:
   TempString(WCHAR * data) { m_data = data; }
   ~TempString() { if ( m_data ) delete [] m_data; }
   operator WCHAR * () { return m_data; }
   operator WCHAR const * () { return (WCHAR const*)m_data; }
};

//#define GET_BSTR(nID) _bstr_t(SysAllocString(GET_STRING(nID)),false)
#define GET_BSTR(nID)   _bstr_t((WCHAR*)TempString(gString.GetString(nID)))

#define GET_STRING(nID) GET_STRING2(gString,nID)

#define GET_STRING2(strObj,nID) TempString(strObj.GetString(nID))

#define GET_WSTR(nID) ((WCHAR*)TempString(gString.GetString(nID)))
#endif RES_STRING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\trenum.h ===
//---------------------------------------------------------------------------
// TrustEnumerator.h
//
// declaration of CTrustEnumerator: a COM object for enumerating trust relationships
//
// (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __TRUSTENUMERATOR_H_
#define __TRUSTENUMERATOR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTrustEnumerator
class ATL_NO_VTABLE CTrustEnumerator : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTrustEnumerator, &CLSID_TrustEnumerator>,
	public IDispatchImpl<ITrustEnumerator, &IID_ITrustEnumerator, &LIBID_MCSENUMTRUSTRELATIONSLib>
{
public:
	CTrustEnumerator()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_TRUSTENUMERATOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTrustEnumerator)
	COM_INTERFACE_ENTRY(ITrustEnumerator)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ITrustEnumerator
public:
   // **enumeration is an IVarSet that contains the the enumerated domain information in the form:
   //  [Server1.Name] DEVBOLES
   //  [Server1.TrustAttributes] 16777216
   //  [Server1.TrustDirection] 2
   //  [Server1.TrustType] 1
   //  [Server2] <Empty>
   //  [Server2.Name] devrdt1.devblewerg.com
   //  [Server2.TrustAttributes] 0
   //  [Server2.TrustDirection] 3
   //  [Server2.TrustType] 2
   //  [Server3] <Empty>
   //  [Server3.Name] MCSFOX1
   //  [Server3.TrustAttributes] 16777216
   //  [Server3.TrustDirection] 2
   //  [Server3.TrustType] 1

	STDMETHOD(getTrustRelations)(/*[in]*/ BSTR server, /*[out, retval]*/ IUnknown **enumeration);
   STDMETHOD(createTrust)(/*[in]*/ BSTR trustingDomain,/*[in]*/ BSTR trustedDomain);
   };

#endif //__TRUSTENUMERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\mcsdebug.cpp ===
//---------------------------------------------------------------------------
// MCSDebug.cpp
//
// The classes declared in MCSDebug.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include <time.h>
#include <strstrea.h>
#include "UString.hpp"
#include "McsDebug.h"

// -----------------
// McsDebugException
// -----------------
McsDebugException::McsDebugException 
      (const McsDebugException &t) 
: m_message (0), m_fileName (0), m_lineNum (t.m_lineNum) {
	if (t.m_message) { 
		m_message = new char [UStrLen(t.m_message)+1];
      if (m_message) { UStrCpy (m_message, t.m_message); }
    }
    if (t.m_fileName) {
		m_fileName = new char [UStrLen(t.m_fileName)+1];
      if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
    }
}

McsDebugException::McsDebugException 
                           (const char *messageIn,
						          const char *fileNameIn,
							       int        lineNumIn) 
: m_lineNum (lineNumIn) {
   if (messageIn) { 
      m_message = new char [UStrLen (messageIn)+1];
      if (m_message) { UStrCpy (m_message, messageIn); }
   }
   if (fileNameIn) {
      m_fileName = new char [UStrLen(fileNameIn)+1];
      UStrCpy (m_fileName, fileNameIn);
   }
}

McsDebugException& McsDebugException::operator= 
         (const McsDebugException &t) {
   if (this != &t) {
      if (t.m_message) { 
         m_message = new char [UStrLen(t.m_message)+1];
         if (m_message) { UStrCpy (m_message, t.m_message); }
      }
      if (t.m_fileName) {
         m_fileName = new char [UStrLen(t.m_fileName)+1];
         if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
      }
      m_lineNum = t.m_lineNum;
   }
   return *this;
}

// ------------
// McsVerifyLog
// ------------
static McsVerifyLog *pVerifyLog;
static LONG         verifyInitFlag;

McsVerifyLog* McsVerifyLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pVerifyLog) {
      while (::InterlockedExchange 
               (&verifyInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pVerifyLog) {
         static McsVerifyLog verifyLog;
         pVerifyLog = &verifyLog;
      }
      ::InterlockedExchange (&verifyInitFlag, 0);
   }
   return pVerifyLog;
}

void McsVerifyLog::changeLog (ostream *outStreamIn) {
   m_logSec.enter();
   m_log.changeLog (outStreamIn);
   delete m_outLog;
   m_outLog = 0;
   m_logSec.leave();
}

void McsVerifyLog::log (const char *messageIn,
                        const char *fileNameIn,
                        int        lineNumIn) {
   m_logSec.enter();
   // If the log file has not been set, set it
   // to the module name log file.
   if (!m_log.isLogSet()) {
      m_outLog = new fstream (getLogFileName(), 
         ios::app);
      m_log.changeLog (m_outLog);
   }
   // Format and write the message.
   formatMsg (messageIn, fileNameIn, lineNumIn);
   m_log.write (m_msgBuf);
   m_logSec.leave();
}

const char* McsVerifyLog::getLogFileName (void) {
   const char  *MCS_LOG_ENV  = "MCS_LOG";
   const char  *DIR_SEP      = "\\";
   const char  *EXT          = ".err";
   const char  *DEFAULT_NAME = "MCSDEBUG";
   static char logFileName[MAX_PATH];

   // Get MCS_LOG_ENV, or temp directory path, 
   // NULL means current directory.
   logFileName[0] = 0;
   char *mcs_log_path = getenv (MCS_LOG_ENV);
   bool isLogPath = false;
   if (mcs_log_path) {
      DWORD attrib = ::GetFileAttributesA (mcs_log_path);
      if ((attrib != 0xFFFFFFFF)
          && (attrib & FILE_ATTRIBUTE_DIRECTORY)) {
         UStrCpy (logFileName, mcs_log_path);
         isLogPath = true;
      }
   }
   if (!isLogPath) { 
      ::GetTempPathA (MAX_PATH, logFileName);
   }

   // Get file name from the module name.  If error
   // generate fixed filename. 
   char fullFilePath [MAX_PATH];
   char fileName[MAX_PATH];
   if (::GetModuleFileNameA (NULL, fullFilePath, 
                  MAX_PATH)) {
      // Get file name out of the path
      _splitpath (fullFilePath, NULL, NULL, fileName, 
                        NULL);

      // Generate full path name with extension.
      int len = UStrLen (logFileName);
      if (len) {
         UStrCpy (logFileName + len, DIR_SEP);
         UStrCpy (logFileName + UStrLen (logFileName), 
                     fileName);
      } else {
         UStrCpy (logFileName, fileName);
      }
   } else {
      UStrCpy (logFileName, DEFAULT_NAME);
   }
   strcat (logFileName + UStrLen (logFileName), EXT);

   return logFileName;
}

void McsVerifyLog::formatMsg (const char *messageIn,
                              const char *fileNameIn,
                              int         lineNumIn) {
   const char  *TIME        = "TIME : ";
   const char  *MSG         = "MSG  : ";
   const char  *FILE        = "FILE : ";
   const char  *LINE        = "LINE : ";
   const char  *SPACER      = ", ";

   // Create stream buf object.
   strstream msgBufStream (m_msgBuf, MSG_BUF_LEN, ios::out);

   // Write time stamp.
   time_t cur;
   time (&cur);
   struct tm *curTm = localtime (&cur);
   if (curTm) {
      char *tstr = asctime (curTm);
      if (tstr) {
         msgBufStream << TIME << tstr << SPACER;
      }
   }

   // Write message.
   if (messageIn) {
      msgBufStream << MSG << messageIn << SPACER;
   }

   // Write file name.
   if (fileNameIn) {
      msgBufStream << FILE << fileNameIn << SPACER;
   }

   // Write line number.
   msgBufStream << LINE << lineNumIn << endl;
}

// ----------
// McsTestLog
// ----------
static McsTestLog *pTestLog;
static LONG       testInitFlag;

McsTestLog* McsTestLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pTestLog) {
      while (::InterlockedExchange 
               (&testInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pTestLog) {
         static McsTestLog testLog;
         pTestLog = &testLog;
      }
      ::InterlockedExchange (&testInitFlag, 0);
   }
   return pTestLog;
}

bool McsTestLog::isTestMode (void) {
   const char *TEST_ENV = "MCS_TEST";
   const char *PRE_FIX  = "MCS";

   // Check if tested.
   if (!m_isTested) {
      // If not tested lock, test again, and
      // initialize test mode flag.
      m_testSec.enter();
      if (!m_isTested) {
         m_isTested    = true;
         m_isTestMode_ = getenv (TEST_ENV) != NULL;
      }
      m_testSec.leave();
   }

   return m_isTestMode_;
}

#endif 	/* Not WIN16_VERSION */
#endif  /* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\ealen.hpp ===
//#pragma title( "EaLen.hpp - EA defined length fields" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  EaLen.hpp
System      -  EnterpriseAdministrator
Author      -  Rich Denham
Created     -  1996-03-22
Description -  EA defined length fields
Updates     -
===============================================================================
*/

#ifndef  MCSINC_EaLen_hpp
#define  MCSINC_EaLen_hpp

// Definitions - object name lengths.
// These lengths include trailing null.
// These definitions are used to be independent of values in <lm.h>, which
// may not reflect the actual limits of all target operating systems.
// These values are also usually rounded up to a four byte boundary.
// The LEN_ values reflect the size reserved in structures for object names.
// The MAXLEN_ values reflect the actual valid maximum length imposed by EA.

#define  LEN_Computer                      (32)
#define  LEN_Domain                        (32)

#define  LEN_Account                       (260)
#define  LEN_Comment                       (260)
#define  LEN_Group                         (260)
#define  LEN_Member                        (260)
#define  LEN_Password                      (260)
#define  LEN_Path                          (1260)
#define  LEN_ShutdownMessage               (128)

#define  LEN_Sid                           (80)

#define  LEN_DistName                      (260)
#define  LEN_DisplayName                   (260)

#define  LEN_Guid                          (128)

#define  LEN_WTSPhoneNumber                (50)
#define  LEN_HomeDir                       (4)

// Definitions - maximum valid length of object name
// These lengths do NOT include trailing null.
// These definitions must always be smaller that the corresponding
// definitions above.

// Other EA defined constants
// type of account
#define  EA_AccountGGroup                        (0x00000001)
#define  EA_AccountLGroup                        (0x00000002)
#define  EA_AccountUser                          (0x00000004)
#define  EA_AccountUcLGroup                      (0x00000008)

#define  EA_AccountGroup                         (EA_AccountGGroup|EA_AccountLGroup)
#define  EA_AccountAll                           (EA_AccountGroup|EA_AccountUser)


#endif  // MCSINC_EaLen_hpp

// EaLen.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\trenum.cpp ===
//---------------------------------------------------------------------------
// TrustEnumerator.cpp
//
// definition of a COM object for enumerating trust relationships
//
// (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

// TrustEnumerator.cpp : Implementation of CTrustEnumerator
#include "stdafx.h"
#include "EnumTr.h"
#include "TrEnum.h"
#include <activeds.h>
#include <lm.h>
#include <dsgetdc.h>
#include "ntsecapi.h"

#import "\bin\McsVarSetMin.tlb"

#include "LSAUtils.h"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "EaLen.hpp"

TErrorDct        err;

/////////////////////////////////////////////////////////////////////////////
// CTrustEnumerator

#undef DIM
#define DIM(array) (sizeof(array) / sizeof(array[0]))
#define MAX_ELEM  16

using MCSVARSETMINLib::IVarSet;
using MCSVARSETMINLib::IVarSetPtr;
using MCSVARSETMINLib::VarSet;

// Get the LDAP distinguished name of the server
HRESULT
   GetNameDc(
   _bstr_t              & sNameDc     ,// out-LDAP distinguished name
   const BSTR             sServer      // in -command line arguments
   )
{
   HRESULT                hr;
   CComPtr<IADs>          pIRootDse = NULL;
   _bstr_t                sLdapPath;
   
   sLdapPath = L"LDAP://";
   if( sServer && wcslen(sServer) > 0 )
   {
      sLdapPath += sServer;
      sLdapPath += L"/";
   }
   sLdapPath += L"RootDse";

   hr = ADsGetObject(static_cast<WCHAR*>(sLdapPath), IID_IADs, (void **) &pIRootDse);
   
   if ( FAILED(hr) )
   {
      return hr;
   }
   else
   {
      VARIANT             var;
      VariantInit(&var);
      hr = pIRootDse->Get(L"DefaultNamingContext", &var);
      if ( FAILED(hr) )
      {
         VariantClear(&var);
         return hr;
      }
      else
      {
         sNameDc = var.bstrVal;
      }
      VariantClear(&var);
   }
   return S_OK;
}

// given a server name, get a pointer to an IADsContainer
HRESULT
   getIADContainer
   (
      BSTR const                server          , // in, the server to use
      IADsContainer          ** ppIContainer      // out
   )
{
   HRESULT                   hr;
   _bstr_t                   sNameDc;          // LDAP distinguished name
   _bstr_t                   sLdapPath(L"LDAP://");
      
   hr = GetNameDc(sNameDc,  server);
   if( FAILED(hr) )   { return hr; }
   
   if( server )
   {
      sLdapPath += server;
      sLdapPath += L"/";
   }
   sLdapPath += L"CN=System,";
   sLdapPath += sNameDc;
   
   hr = ADsGetObject(sLdapPath, IID_IADsContainer, (void **) ppIContainer);
   return hr;
}


// clear all the elements of an array of variants
void
   clearVariantArray(
      VARIANT                 * array           ,
      unsigned int const        numItems
   )
{
   for( VARIANT *currItem = array;
   currItem < array + numItems;
   ++currItem )
   {
      VariantClear(currItem);
   }

}

// This class maintains the state across multiple insertions into the VarSet.
// Mainly this is needed to name the servers properly: Server1, Server2, Server3, etc

class AdItemHandler
{
private:
   IVarSetPtr                pIVarset;     // The VarSet in which to insert all items processed
   int                       counter;      // the number (converted to a string) to append to "Server" to get the name
   AdItemHandler(){}                       // don't allow use of the default constructor
public:
   AdItemHandler( IVarSetPtr & p ) : pIVarset(p), counter(1) {}
   void insertItem( IADs * pObject );
};

// Take in an IADs an insert it into the VarSet if it is a TrustedDomain. The name to put it under
void AdItemHandler::
   insertItem(
      IADs                 * pObject       // in -AD object
   )
{
   HRESULT                   hr;
   WCHAR                   * sClass=NULL;  // class
   WCHAR                   * sName=NULL;   // name
   VARIANT                   var;
   WCHAR                     numBuffer [3 * sizeof(int)]; // hold result of _itow
   
   VariantInit(&var);
   // See if desired class
   hr = pObject->get_Class(&sClass);
   if ( FAILED(hr) )
   {  /* so what */  }
   else
   {
      if ( !wcsicmp(L"TrustedDomain", sClass) )
      {
         hr = pObject->get_Name(&sName);
         if ( FAILED(hr) )
         {  /* so what */  }
         else
         {
            _bstr_t name;
            if( wcsncmp(sName, L"CN=", 3) == 0 )
            {
               name = (sName + 3); // chop off the leading "CN="
            }
            else
            {
               name = sName;
            }
              
            _bstr_t server(L"Server");
            SysFreeString(sName);
            server += _itow(counter++, numBuffer, 10); // the servers are named "Server1", "Server2", etc
            hr = pIVarset->put(server + L".Name", name);
            
            hr = pObject->Get(L"TrustDirection", &var);
            if ( SUCCEEDED(hr) )
            {
               hr = pIVarset->put( server + L".TrustDirection", var );
            }
            VariantClear(&var);
            hr = pObject->Get(L"TrustType", &var);
            if ( SUCCEEDED(hr) )
            {
               hr = pIVarset->put( server + L".TrustType", var);
            }
            VariantClear(&var);
            hr = pObject->Get(L"TrustAttributes", &var);
            if ( SUCCEEDED(hr) )
            {
               hr = pIVarset->put( server + L".TrustAttributes", var);
            }
            VariantClear(&var);
         }
      }
      SysFreeString(sClass);
   }   
}

BOOL IsDownLevel(WCHAR  * sComputer)
{
   BOOL                      bDownlevel = TRUE;
   WKSTA_INFO_100          * pInfo;
   
   long rc = NetWkstaGetInfo(sComputer,100,(LPBYTE*)&pInfo);
	if ( ! rc )
	{
      if ( pInfo->wki100_ver_major >= 5 )
      {
         bDownlevel = FALSE;
      }
      NetApiBufferFree(pInfo);
	}  
   return bDownlevel;
}

STDMETHODIMP CTrustEnumerator::createTrust(/*[in]*/ BSTR trustingDomain,/*[in]*/ BSTR trustedDomain)
{
   HRESULT                   hr = S_OK;
   WCHAR                     trustingComp[MAX_PATH];
   WCHAR                     trustedComp[MAX_PATH];
   WCHAR                     trustingDNSName[MAX_PATH];
   WCHAR                     trustedDNSName[MAX_PATH];
   WCHAR                     name[LEN_Domain];
   DWORD                     lenName = DIM(name);
   BYTE                      trustingSid[200];
   BYTE                      trustedSid[200];
   DWORD                     lenSid = DIM(trustingSid);
   SID_NAME_USE              snu;
   DOMAIN_CONTROLLER_INFO  * pInfo;
   DWORD                     rc = 0;
   LSA_HANDLE                hTrusting = NULL;
   LSA_HANDLE                hTrusted = NULL;
   NTSTATUS                  status;
   LSA_AUTH_INFORMATION      curr;
   LSA_AUTH_INFORMATION      prev;
   WCHAR                     password[] = L"password";
            


   rc = DsGetDcName(NULL, trustingDomain, NULL, NULL, DS_PDC_REQUIRED, &pInfo);
   if ( !rc )
   {
      wcscpy(trustingComp,pInfo->DomainControllerName);
      wcscpy(trustingDNSName,pInfo->DomainName);
      NetApiBufferFree(pInfo);
   }

   rc = DsGetDcName(NULL, trustedDomain, NULL, NULL, DS_PDC_REQUIRED, &pInfo);
   if ( !rc )
   {
      wcscpy(trustedComp,pInfo->DomainControllerName);
      wcscpy(trustedDNSName,pInfo->DomainName);
      NetApiBufferFree(pInfo);
   }
   
   // Need to get the computer name and the SIDs for the domains.
   if ( ! LookupAccountName(trustingComp,trustingDomain,trustingSid,&lenSid,name,&lenName,&snu) )
   {
      rc = GetLastError();
      return 1;
   }
   lenSid = DIM(trustedSid);
   lenName = DIM(name);
   if (! LookupAccountName(trustedComp,trustedDomain,trustedSid,&lenSid,name,&lenName,&snu) )
   {
      rc = GetLastError();
      return 1;
   }
   
   // open an LSA handle to each domain
   if ( *trustingComp && *trustedComp )
   {
      status = OpenPolicy(trustedComp,POLICY_VIEW_LOCAL_INFORMATION | POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET,&hTrusted);
      rc = LsaNtStatusToWinError(rc);

      if ( ! rc )
      {
         // set up the auth information for the trust relationship
         curr.AuthInfo = (LPBYTE)password;
         curr.AuthInfoLength = sizeof (password);
         curr.AuthType = TRUST_AUTH_TYPE_CLEAR;
         curr.LastUpdateTime.QuadPart = 0;

         prev.AuthInfo = NULL;
         prev.AuthInfoLength = 0;
         prev.AuthType = TRUST_AUTH_TYPE_CLEAR;
         prev.LastUpdateTime.QuadPart = 0;
         // set up the trusted side of the relationship
         if ( IsDownLevel(trustedComp) )
         {
               // create an inter-domain trust account for the trusting domain on the trusted domain
            USER_INFO_1          uInfo;
            DWORD                parmErr;

            memset(&uInfo,0,(sizeof uInfo));

            UStrCpy(name,trustingDomain);
            name[UStrLen(name) + 1] = 0;
            name[UStrLen(name)] = L'$';
            uInfo.usri1_flags = UF_SCRIPT | UF_INTERDOMAIN_TRUST_ACCOUNT;
            uInfo.usri1_name = name;
            uInfo.usri1_password = password;
            uInfo.usri1_priv = 1;
      
            rc = NetUserAdd(trustedComp,1,(LPBYTE)&uInfo,&parmErr);
         }
         else
         {
            // Create the trustedDomain object.
            LSA_UNICODE_STRING                  sTemp;
            TRUSTED_DOMAIN_INFORMATION_EX       trustedInfo;
            TRUSTED_DOMAIN_AUTH_INFORMATION     trustAuth;
            
            InitLsaString(&sTemp, const_cast<WCHAR*>(trustingDomain));
            trustedInfo.FlatName = sTemp;

            InitLsaString(&sTemp, trustingDNSName);
            trustedInfo.Name = sTemp;

            trustedInfo.Sid = trustingSid;

            if ( IsDownLevel(trustingComp) )
            {
               trustedInfo.TrustAttributes = TRUST_TYPE_DOWNLEVEL;
            }
            else
            {
               trustedInfo.TrustAttributes = TRUST_TYPE_UPLEVEL;
            }
            
            trustedInfo.TrustDirection = TRUST_DIRECTION_INBOUND;
            
            trustedInfo.TrustType = TRUST_ATTRIBUTE_NON_TRANSITIVE;

            trustAuth.IncomingAuthInfos = 1;
            trustAuth.OutgoingAuthInfos = 0;
            trustAuth.OutgoingAuthenticationInformation = NULL;
            trustAuth.OutgoingPreviousAuthenticationInformation = NULL;
            trustAuth.IncomingAuthenticationInformation = &curr;
            trustAuth.IncomingPreviousAuthenticationInformation = &prev;

            status = LsaCreateTrustedDomainEx( hTrusted, &trustedInfo, &trustAuth, POLICY_VIEW_LOCAL_INFORMATION | 
                                             POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET, &hTrusting );
            rc = LsaNtStatusToWinError(status);
            if ( ! rc )
            {
               LsaClose(hTrusting);
               hTrusting = NULL;
            }
         }

         status = OpenPolicy(trustingComp,POLICY_VIEW_LOCAL_INFORMATION 
                                             | POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET,&hTrusting);
         rc = LsaNtStatusToWinError(rc);
            
         // set up the trusting side of the relationship
         if ( IsDownLevel(trustingComp) )
         {
            TRUSTED_DOMAIN_NAME_INFO               nameInfo;
            
            InitLsaString(&nameInfo.Name,const_cast<WCHAR*>(trustedDomain));
            
            status = LsaSetTrustedDomainInformation(hTrusting,trustedSid,TrustedDomainNameInformation,&nameInfo);
            rc = LsaNtStatusToWinError(status);
            if ( ! rc )
            {
               // set the password for the new trust
               TRUSTED_PASSWORD_INFO     pwdInfo;

               InitLsaString(&pwdInfo.Password,password);
               InitLsaString(&pwdInfo.OldPassword,NULL);

               status = LsaSetTrustedDomainInformation(hTrusting,trustedSid,TrustedPasswordInformation,&pwdInfo);
               rc = LsaNtStatusToWinError(status);
            }
   
         }
         else
         {
            // for Win2K domain, use LsaCreateTrustedDomainEx
            // to create the trustedDomain object.
            LSA_UNICODE_STRING                  sTemp;
            TRUSTED_DOMAIN_INFORMATION_EX       trustedInfo;
            TRUSTED_DOMAIN_AUTH_INFORMATION     trustAuth;
            
            InitLsaString(&sTemp, const_cast<WCHAR*>(trustedDomain));
            trustedInfo.FlatName = sTemp;

            InitLsaString(&sTemp, trustedDNSName);
            trustedInfo.Name = sTemp;

            trustedInfo.Sid = trustedSid;

            if ( IsDownLevel(trustedComp) )
            {
               trustedInfo.TrustAttributes = TRUST_TYPE_DOWNLEVEL;
            }
            else
            {
               trustedInfo.TrustAttributes = TRUST_TYPE_UPLEVEL;
            }
            
            trustedInfo.TrustDirection = TRUST_DIRECTION_OUTBOUND;
            
            trustedInfo.TrustType = TRUST_ATTRIBUTE_NON_TRANSITIVE;

            trustAuth.IncomingAuthInfos = 0;
            trustAuth.OutgoingAuthInfos = 1;
            trustAuth.IncomingAuthenticationInformation = NULL;
            trustAuth.IncomingPreviousAuthenticationInformation = NULL;
            trustAuth.OutgoingAuthenticationInformation = &curr;
            trustAuth.OutgoingPreviousAuthenticationInformation = &prev;

            LSA_HANDLE           hTemp;
            
            status = LsaCreateTrustedDomainEx( hTrusting, &trustedInfo, &trustAuth, 0, &hTemp );
            rc = LsaNtStatusToWinError(status);
            if( ! rc )
            {
               LsaClose(hTemp);
            }
         }
      }
   }
   if ( hTrusting )
      LsaClose(hTrusting);

   if( hTrusted )
      LsaClose(hTrusted);

   return HRESULT_FROM_WIN32(rc);
}


// externally visible method
STDMETHODIMP CTrustEnumerator::
getTrustRelations
(
   BSTR                      server       ,// in, The name of the server from which to get trust information
   IUnknown               ** enumeration   // [out, retval] a pointer to an IVarSet containing the enumerated machines
)
{
   *enumeration = NULL;
   IVarSetPtr                pIVarset = NULL;
   CComPtr<IADsContainer>    pIContainer = NULL;
   HRESULT                   hr;
   IEnumVARIANT            * pIContents=NULL;
   
   hr = getIADContainer(server, &pIContainer);
   if( FAILED(hr) ) { return hr; }
   
   hr = pIVarset.CreateInstance(__uuidof(VarSet));
   if( FAILED(hr) ) { return hr; }
   
   AdItemHandler handler(pIVarset);
   
   hr = ADsBuildEnumerator(pIContainer, &pIContents);
   if( FAILED(hr) ) { return hr; }
   
   DWORD               nRead=0;      // number enumerated items returned
   do
   {
      VARIANT          arrayEnumItems[MAX_ELEM]; // array of enumerated items
      VARIANT        * pEnumItem;    // enumerated item
      nRead = 0;
      memset(arrayEnumItems, 0, sizeof arrayEnumItems);
      hr = ADsEnumerateNext(
         pIContents,
         DIM(arrayEnumItems),
         arrayEnumItems,
         &nRead );
      if( FAILED(hr) ) { return hr; }
      
      const VARIANT *pEndOfItems = arrayEnumItems + nRead;
      for ( pEnumItem = arrayEnumItems;
      pEnumItem < pEndOfItems;
      pEnumItem++ )
      {
         CComPtr<IDispatch> pDispatch (pEnumItem->pdispVal);
         CComPtr<IADs>      pObject;
         hr = pDispatch->QueryInterface(
            IID_IADs,
            (void **) &pObject );
         if ( FAILED(hr) )
         {
            clearVariantArray(arrayEnumItems, nRead);
            return hr;
         }
         if ( SUCCEEDED(hr) )
            handler.insertItem(pObject);  // insert the item into the varset if necessary
      }
      clearVariantArray(arrayEnumItems, nRead);
      
   } while ( nRead );
   
   
   if ( pIContents )
   {
      ADsFreeEnumerator( pIContents );
      // pIContents->Release(); 
      pIContents = NULL;
   }
   
   hr = pIVarset->QueryInterface(__uuidof(IUnknown), reinterpret_cast<void**>(enumeration));
   return hr;
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\testenumtrustrelations\enumtrusts.cpp ===
// EnumTrusts.cpp

#include <windows.h>
#include <stdio.h>
#include <atlbase.h>
#include <adserr.h>
#import "..\McsVarSetMin.tlb"
#import "..\McsEnumTrustRelations.tlb"

namespace
{
   void
      usage(
         WCHAR const          * cmdName         // in, what was the name of this program
      )
   {
      printf("Usage: %ls servername\n", cmdName);
   }

}

#define STRING_CASE(name) case name: err_name = #name; break

int printNameHresult(HRESULT hr){
	const char* err_name = "Unknown error";
	switch(hr){
		STRING_CASE(S_OK); 
		STRING_CASE(S_FALSE); 
	 
		STRING_CASE(DRAGDROP_S_CANCEL); 
		STRING_CASE(DRAGDROP_S_DROP); 
		STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS); 
	 
		STRING_CASE(E_UNEXPECTED); 
		STRING_CASE(E_NOTIMPL); 
		STRING_CASE(E_OUTOFMEMORY); 
		STRING_CASE(E_INVALIDARG); 
		STRING_CASE(E_NOINTERFACE); 
		STRING_CASE(E_POINTER); 
		STRING_CASE(E_HANDLE); 
		STRING_CASE(E_ABORT); 
		STRING_CASE(E_FAIL); 
		STRING_CASE(E_ACCESSDENIED); 
	 
		STRING_CASE(CLASS_E_NOAGGREGATION); 
	 
		STRING_CASE(CO_E_NOTINITIALIZED); 
		STRING_CASE(CO_E_ALREADYINITIALIZED); 
		STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED); 
	 
		STRING_CASE(REGDB_E_INVALIDVALUE); 
		STRING_CASE(REGDB_E_CLASSNOTREG); 
		STRING_CASE(REGDB_E_IIDNOTREG); 
		 
		STRING_CASE(DV_E_DVASPECT);
      
      STRING_CASE(E_ADS_BAD_PATHNAME);
      STRING_CASE(E_ADS_INVALID_DOMAIN_OBJECT);
      STRING_CASE(E_ADS_INVALID_USER_OBJECT);
      STRING_CASE(E_ADS_INVALID_COMPUTER_OBJECT);
      STRING_CASE(E_ADS_UNKNOWN_OBJECT);
      STRING_CASE(E_ADS_PROPERTY_NOT_SET);
      STRING_CASE(E_ADS_PROPERTY_NOT_SUPPORTED);
      STRING_CASE(E_ADS_PROPERTY_INVALID);
      STRING_CASE(E_ADS_BAD_PARAMETER);
      STRING_CASE(E_ADS_OBJECT_UNBOUND);
      STRING_CASE(E_ADS_PROPERTY_NOT_MODIFIED);
      STRING_CASE(E_ADS_PROPERTY_MODIFIED);
      STRING_CASE(E_ADS_CANT_CONVERT_DATATYPE);
      STRING_CASE(E_ADS_PROPERTY_NOT_FOUND);
      STRING_CASE(E_ADS_OBJECT_EXISTS);
      STRING_CASE(E_ADS_SCHEMA_VIOLATION);
      STRING_CASE(E_ADS_COLUMN_NOT_SET);
      STRING_CASE(S_ADS_ERRORSOCCURRED);
      STRING_CASE(S_ADS_NOMORE_ROWS);
      STRING_CASE(S_ADS_NOMORE_COLUMNS);
      STRING_CASE(E_ADS_INVALID_FILTER);


	}
   printf("HRESULT = 0x%x : %s\n", hr, err_name);

	return 3;
}

#undef STRING_CASE


using namespace MCSENUMTRUSTRELATIONSLib;
using namespace MCSVARSETMINLib;

extern "C"
int
   wmain(
      int                    argc         ,
      WCHAR const          * argv[]        // The name of a server
   )
{
   if( argc <= 1 || wcsncmp(argv[1], L"/?", 2) == 0 )
   {
      usage(argv[0]);
      return 1;
   }
   if( FAILED( CoInitialize(NULL) ) )
   {
      printf("Couldn't initialize the COM library"); return 4;
   }
   CComPtr<ITrustEnumerator>  pIEnumerator = NULL;
   IVarSetPtr                 pIVarSet = NULL;
   HRESULT                    hr;
   hr = pIEnumerator.CoCreateInstance(__uuidof(TrustEnumerator));
   if( FAILED(hr) )
   {
      printNameHresult(hr);
      printf("Couldn't create an instance of the TrustEnumerator\n");
      return 2;
   }
   hr = pIEnumerator->raw_getTrustRelations( _bstr_t(argv[1]), reinterpret_cast<IUnknown **>(& pIVarSet) );
   if( FAILED(hr) )
   {
      printNameHresult(hr);
      printf("Couldn't getTrustRelations\n");
      return 3;
   }
   hr = pIVarSet->DumpToFile(L"dump.txt");
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__2A6F6589_8B08_4F92_9B5E_CA4211040357__INCLUDED_)
#define AFX_DLLDATAX_H__2A6F6589_8B08_4F92_9B5E_CA4211040357__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__2A6F6589_8B08_4F92_9B5E_CA4211040357__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "ExEnum_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\mcs.h ===
//---------------------------------------------------------------------------
// MCS.h 
//
// Main header file for all MCS applications.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_Mcs_h
#define MCSINC_Mcs_h
#ifdef __cplusplus

// Mandatory Pragma Definitions.
// #pragma warning( 3 : 4706 ) // assignment within if, while, etc.

// Header Files Common To All MCS Modules.
#include "McsDebug.h"   // contains debug macros, it depends on
                        // the following files: McsDebug.cpp,
                        // McsDebugUtil.h and McsDebugUtil.cpp.

#endif /* __cplusplus */
#endif /* MCSINC_Mcs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\mcsdbgu.cpp ===
//---------------------------------------------------------------------------
// McsDebugUtil.cpp
//
// The classes declared in MCSDebugUtil.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++  */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "McsDbgU.h"

// -----------
// McsDebugLog
// ----------- 
void McsDebugUtil::McsDebugLog::write 
			(const char *messageIn) {
   if (m_outStream) {
      *(m_outStream) << messageIn;
      m_outStream->flush(); 
   }
}

#endif 	/* Not WIN16_VERSION */
#endif	/* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\mcsdebug.cpp ===
//---------------------------------------------------------------------------
// MCSDebug.cpp
//
// The classes declared in MCSDebug.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include <time.h>
#include <strstrea.h>
#include "UString.hpp"
#include "McsDebug.h"

// -----------------
// McsDebugException
// -----------------
McsDebugException::McsDebugException 
      (const McsDebugException &t) 
: m_message (0), m_fileName (0), m_lineNum (t.m_lineNum) {
	if (t.m_message) { 
		m_message = new char [UStrLen(t.m_message)+1];
      if (m_message) { UStrCpy (m_message, t.m_message); }
    }
    if (t.m_fileName) {
		m_fileName = new char [UStrLen(t.m_fileName)+1];
      if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
    }
}

McsDebugException::McsDebugException 
                           (const char *messageIn,
						          const char *fileNameIn,
							       int        lineNumIn) 
: m_lineNum (lineNumIn) {
   if (messageIn) { 
      m_message = new char [UStrLen (messageIn)+1];
      if (m_message) { UStrCpy (m_message, messageIn); }
   }
   if (fileNameIn) {
      m_fileName = new char [UStrLen(fileNameIn)+1];
      UStrCpy (m_fileName, fileNameIn);
   }
}

McsDebugException& McsDebugException::operator= 
         (const McsDebugException &t) {
   if (this != &t) {
      if (t.m_message) { 
         m_message = new char [UStrLen(t.m_message)+1];
         if (m_message) { UStrCpy (m_message, t.m_message); }
      }
      if (t.m_fileName) {
         m_fileName = new char [UStrLen(t.m_fileName)+1];
         if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
      }
      m_lineNum = t.m_lineNum;
   }
   return *this;
}

// ------------
// McsVerifyLog
// ------------
static McsVerifyLog *pVerifyLog;
static LONG         verifyInitFlag;

McsVerifyLog* McsVerifyLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pVerifyLog) {
      while (::InterlockedExchange 
               (&verifyInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pVerifyLog) {
         static McsVerifyLog verifyLog;
         pVerifyLog = &verifyLog;
      }
      ::InterlockedExchange (&verifyInitFlag, 0);
   }
   return pVerifyLog;
}

void McsVerifyLog::changeLog (ostream *outStreamIn) {
   m_logSec.enter();
   m_log.changeLog (outStreamIn);
   delete m_outLog;
   m_outLog = 0;
   m_logSec.leave();
}

void McsVerifyLog::log (const char *messageIn,
                        const char *fileNameIn,
                        int        lineNumIn) {
   m_logSec.enter();
   // If the log file has not been set, set it
   // to the module name log file.
   if (!m_log.isLogSet()) {
      m_outLog = new fstream (getLogFileName(), 
         ios::app);
      m_log.changeLog (m_outLog);
   }
   // Format and write the message.
   formatMsg (messageIn, fileNameIn, lineNumIn);
   m_log.write (m_msgBuf);
   m_logSec.leave();
}

const char* McsVerifyLog::getLogFileName (void) {
   const char  *MCS_LOG_ENV  = "MCS_LOG";
   const char  *DIR_SEP      = "\\";
   const char  *EXT          = ".err";
   const char  *DEFAULT_NAME = "MCSDEBUG";
   static char logFileName[MAX_PATH];

   // Get MCS_LOG_ENV, or temp directory path, 
   // NULL means current directory.
   logFileName[0] = 0;
   char *mcs_log_path = getenv (MCS_LOG_ENV);
   bool isLogPath = false;
   if (mcs_log_path) {
      DWORD attrib = ::GetFileAttributesA (mcs_log_path);
      if ((attrib != 0xFFFFFFFF)
          && (attrib & FILE_ATTRIBUTE_DIRECTORY)) {
         UStrCpy (logFileName, mcs_log_path);
         isLogPath = true;
      }
   }
   if (!isLogPath) { 
      ::GetTempPathA (MAX_PATH, logFileName);
   }

   // Get file name from the module name.  If error
   // generate fixed filename. 
   char fullFilePath [MAX_PATH];
   char fileName[MAX_PATH];
   if (::GetModuleFileNameA (NULL, fullFilePath, 
                  MAX_PATH)) {
      // Get file name out of the path
      _splitpath (fullFilePath, NULL, NULL, fileName, 
                        NULL);

      // Generate full path name with extension.
      int len = UStrLen (logFileName);
      if (len) {
         UStrCpy (logFileName + len, DIR_SEP);
         UStrCpy (logFileName + UStrLen (logFileName), 
                     fileName);
      } else {
         UStrCpy (logFileName, fileName);
      }
   } else {
      UStrCpy (logFileName, DEFAULT_NAME);
   }
   strcat (logFileName + UStrLen (logFileName), EXT);

   return logFileName;
}

void McsVerifyLog::formatMsg (const char *messageIn,
                              const char *fileNameIn,
                              int         lineNumIn) {
   const char  *TIME        = "TIME : ";
   const char  *MSG         = "MSG  : ";
   const char  *FILE        = "FILE : ";
   const char  *LINE        = "LINE : ";
   const char  *SPACER      = ", ";

   // Create stream buf object.
   strstream msgBufStream (m_msgBuf, MSG_BUF_LEN, ios::out);

   // Write time stamp.
   time_t cur;
   time (&cur);
   struct tm *curTm = localtime (&cur);
   if (curTm) {
      char *tstr = asctime (curTm);
      if (tstr) {
         msgBufStream << TIME << tstr << SPACER;
      }
   }

   // Write message.
   if (messageIn) {
      msgBufStream << MSG << messageIn << SPACER;
   }

   // Write file name.
   if (fileNameIn) {
      msgBufStream << FILE << fileNameIn << SPACER;
   }

   // Write line number.
   msgBufStream << LINE << lineNumIn << endl;
}

// ----------
// McsTestLog
// ----------
static McsTestLog *pTestLog;
static LONG       testInitFlag;

McsTestLog* McsTestLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pTestLog) {
      while (::InterlockedExchange 
               (&testInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pTestLog) {
         static McsTestLog testLog;
         pTestLog = &testLog;
      }
      ::InterlockedExchange (&testInitFlag, 0);
   }
   return pTestLog;
}

bool McsTestLog::isTestMode (void) {
   const char *TEST_ENV = "MCS_TEST";
   const char *PRE_FIX  = "MCS";

   // Check if tested.
   if (!m_isTested) {
      // If not tested lock, test again, and
      // initialize test mode flag.
      m_testSec.enter();
      if (!m_isTested) {
         m_isTested    = true;
         m_isTestMode_ = getenv (TEST_ENV) != NULL;
      }
      m_testSec.leave();
   }

   return m_isTestMode_;
}

#endif 	/* Not WIN16_VERSION */
#endif  /* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\enumexch.cpp ===
// EnumExch.cpp : Implementation of CExEnumApp and DLL registration.

#include "stdafx.h"
#include "ExLdap.h"
#include "ExEnum.h"
#include "EnumExch.h"

#import "\bin\McsVarSetMin.tlb" no_namespace

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP CEnumExch::OpenServer(BSTR exchangeServer,BSTR cred,BSTR password)
{
   DWORD                     rc = 0;
   

   m_e.m_connection.SetCredentials(cred,password);
   
   if ( ! rc )
   {
      rc = m_e.InitConnection(exchangeServer,LDAP_PORT);
   }
   return HRESULT_FROM_WIN32(rc);
 
}

STDMETHODIMP CEnumExch::DoQuery(BSTR query, ULONG scope, BSTR basepoint, IUnknown **pVS)
{
	// build the attribute list
   IVarSetPtr           pVarSet = (*pVS);
   _bstr_t              attrName;
   long                 nAttributes = pVarSet->get(L"EnumExch.NumAttributes");
   WCHAR             ** ppAttributes = new PWCHAR[nAttributes + 1];
   long                 i;
   WCHAR                key[100];
   WCHAR             ** vals = NULL;
   DWORD                rc = 0;

   for ( i = 0 ;i <= nAttributes ; i++ )
      ppAttributes[i] = NULL;

   for ( i = 0 ; i < nAttributes ; i++ )
   {
      swprintf(key,L"EnumExch.Attributes.%ld",i);
      attrName = pVarSet->get(key);
      
      ppAttributes[i] = new WCHAR[attrName.length() + 1];

      UStrCpy(ppAttributes[i],(WCHAR*)attrName);
   }

   // Call the enumerator
   rc = m_e.Open(query,basepoint,(SHORT)scope,100,nAttributes,ppAttributes);
   long                  count = 0;
   if (! rc )
   {
      while ( 0 == ( rc = m_e.Next(&vals)) )
      {
         for ( i = 0 ; i < nAttributes ; i++ )
         {
            swprintf(key,L"EnumExch.Values.%ld.%ld",count,i);
            pVarSet->put(key,vals[i]);
         }
         count++;
      }
      if ( rc == ERROR_NOT_FOUND )
      {
         rc = 0;
      }
   }
	return HRESULT_FROM_WIN32(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\enumexch.h ===
// EnumExch.h: Definition of the CEnumExch class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMEXCH_H__3EA6884B_3C71_4E6B_90C2_154BD2BB553F__INCLUDED_)
#define AFX_ENUMEXCH_H__3EA6884B_3C71_4E6B_90C2_154BD2BB553F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "ExLdap.h"
/////////////////////////////////////////////////////////////////////////////
// CEnumExch

class CEnumExch : 
	public IEnumExch,
	public CComObjectRoot,
	public CComCoClass<CEnumExch,&CLSID_EnumExch>
{
public:
	CEnumExch() {}
BEGIN_COM_MAP(CEnumExch)
	COM_INTERFACE_ENTRY(IEnumExch)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CEnumExch) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_EnumExch)

// IEnumExch
public:
	STDMETHOD(DoQuery)(BSTR query, ULONG scope,BSTR basepoint,/*[in,out]*/ IUnknown ** pVarSet);
	STDMETHOD(OpenServer)(BSTR exchangeServer,BSTR credentials,BSTR password);
private:
   CLdapEnum         m_e;
};

#endif // !defined(AFX_ENUMEXCH_H__3EA6884B_3C71_4E6B_90C2_154BD2BB553F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\exenum.cpp ===
// ExEnum.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ExEnum.idl by adding the following 
//      files to the Outputs.
//          ExEnum_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ExEnumps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ExEnum.h"
#include "dlldatax.h"

#include "ExEnum_i.c"
#include "EnumExch.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_EnumExch, CEnumExch)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_EXENUMLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\enumtrst\ustring.hpp ===
//#pragma title( "UString.hpp - Common string and character functions" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  UString.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-08-25
Description -  Common string and character functions.
      Many string and character functions defined in "string.h" are redefined
         here as overloaded inline functions with several extensions:
      o  Both ANSI and UNICODE strings are supported.
      o  Both ANSI and UNICODE characters are supported.
      o  For ANSI, characters can be "char signed" or "char unsigned".
      o  Functions that allow a length field, such as "lstrcpy" vs "lstrcpyn",
         are implemented as overloaded functions with optional arguments.
      o  Some functions, UStrCpy in particular, can perform conversion between
         ANSI and UNICODE strings.
      The function names defined here consist of "U" concatenated to the base
         name from "string.h".  The first letter of words or word abbreviations
         are capitalized, e.g. "strcpy" becomes "UStrCpy".
Updates     -
===============================================================================
*/

#ifndef  MCSINC_UString_hpp
#define  MCSINC_UString_hpp

#define safecopy(trg,src) (UStrCpy(trg,src,DIM(trg)))

#ifdef  WIN16_VERSION
   #ifndef  UCHAR
      #define  UCHAR  unsigned char
   #endif

   #include <string.h>
   #include <ctype.h>
#endif  // WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      char           const * s1            // in -ANSI string
   )
{
   return strlen( s1 );
}


int _inline                                // ret-length in chars
   UStrLen(
      UCHAR          const * s1            // in -ANSI string
   )
{
   return strlen( (char const *) s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   strcpy( aTarget, aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      strncpy( aTarget, aSource, copylen );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( aTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource, len );
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

char _inline *
   UStrLwr(
      char                 * s             // i/o-ANSI string
   )
{
   return strlwr( s );
}

UCHAR _inline *
   UStrLwr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strlwr( (char *) s );
}

char _inline *
   UStrUpr(
      char                 * s             // i/o-ANSI string
   )
{
   return strupr( s );
}

UCHAR _inline *
   UStrUpr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strupr( (char *) s );
}

char _inline
   UToLower(
      char                   c             // in -ANSI char
   )
{
   return tolower( c );
}

UCHAR _inline
   UToLower(
      UCHAR                  c             // in -ANSI char
   )
{
   return tolower( (char) c );
}

char _inline
   UToUpper(
      char                   c             // in -ANSI char
   )
{
   return toupper( c );
}

UCHAR _inline
   UToUpper(
      UCHAR                  c             // in -ANSI char
   )
{
   return toupper( (char) c );
}

// Left-trim string in place
_inline UCHAR *
   LTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strorg = s;

   while ( *strorg == ' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

_inline char *
   LTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) LTrim( (UCHAR *) s );
}

// Right-trim string in place
_inline UCHAR *
   RTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == ' ') )
      strend--;
   *strend = '\0';
   return s;
}

_inline char *
   RTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) RTrim( (UCHAR *) s );
}

// Trim string in place
_inline UCHAR *
   Trim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

_inline char *
   Trim(
      char                 * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

#ifndef  WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      WCHAR          const * s1            // in -UNICODE string
   )
{
   return lstrlenW( s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   UStrCpy( (char *) aTarget, wSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource       // in -ANSI source string
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( wTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   lstrcpyW( wTarget, wSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, wSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( wTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      lstrcpynW( wTarget, wSource, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcscmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsncmp( s1, s2, len );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcsicmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsnicmp( s1, s2, len );
}

WCHAR _inline *
   UStrLwr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcslwr( s );
}

WCHAR _inline *
   UStrUpr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcsupr( s );
}

WCHAR _inline
   UToLower(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towlower( c );
}

WCHAR _inline
   UToUpper(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towupper( c );
}

// Left-trim string in place
_inline WCHAR *
   LTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strorg = s;

   while ( *strorg == L' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

// Right-trim string in place
_inline WCHAR *
   RTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == L' ') )
      strend--;
   *strend = L'\0';
   return s;
}

// Trim string in place
_inline WCHAR *
   Trim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return LTrim( RTrim( s ) );
}

char * _cdecl                             // ret-target string
   UStrJoin(
      char                 * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      char const           * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

WCHAR * _cdecl                            // ret-target string
   UStrJoin(
      WCHAR                * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      WCHAR const          * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

#endif  // WIN16_VERSION

#endif  // MCSINC_UString_hpp

// UString.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\exldap.cpp ===
#include "stdafx.h"
#include <winldap.h>

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"

#include "exldap.h"


CLdapConnection::CLdapConnection()
{ 
   m_exchServer[0] = 0; 
   m_LD = NULL; 
   m_port = LDAP_PORT;
   m_bUseSSL = FALSE;
   
   // try to dynamically load the LDAP DLL
   m_hDll = LoadLibrary(L"wldap32.dll");
   ldap_open = NULL;
   ldap_parse_result = NULL;
   ldap_parse_page_control = NULL;
   ldap_controls_free = NULL;
   ber_bvfree = NULL;
   ldap_first_entry = NULL;
   ldap_next_entry = NULL;
   ldap_value_free = NULL;
   ldap_get_values = NULL;
   ldap_create_page_control = NULL;
   ldap_search_ext_s = NULL;
   ldap_count_entries = NULL;
   ldap_msgfree = NULL;
   ldap_modify_s = NULL;
   LdapGetLastError = NULL;
   ldap_bind_sW = NULL;
   ldap_unbind = NULL;
   ldap_get_option = NULL;
   ldap_set_option = NULL;
   LdapMapErrorToWin32 = NULL;

   if ( m_hDll )
   {
      ldap_open = (LDAP_OPEN *)GetProcAddress(m_hDll,"ldap_openW");
      ldap_parse_result = (LDAP_PARSE_RESULT *)GetProcAddress(m_hDll,"ldap_parse_resultW");
      ldap_parse_page_control = (LDAP_PARSE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_parse_page_controlW");
      ldap_controls_free = (LDAP_CONTROLS_FREE*)GetProcAddress(m_hDll,"ldap_controls_freeW");
      ber_bvfree = (BER_BVFREE*)GetProcAddress(m_hDll,"ber_bvfree");
      ldap_first_entry = (LDAP_FIRST_ENTRY*)GetProcAddress(m_hDll,"ldap_first_entry");
      ldap_next_entry = (LDAP_NEXT_ENTRY*)GetProcAddress(m_hDll,"ldap_next_entry");
      ldap_value_free = (LDAP_VALUE_FREE*)GetProcAddress(m_hDll,"ldap_value_freeW");
      ldap_get_values = (LDAP_GET_VALUES*)GetProcAddress(m_hDll,"ldap_get_valuesW");
      ldap_create_page_control = (LDAP_CREATE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_create_page_controlW");
      ldap_search_ext_s = (LDAP_SEARCH_EXT_S*)GetProcAddress(m_hDll,"ldap_search_ext_sW");
      ldap_count_entries = (LDAP_COUNT_ENTRIES*)GetProcAddress(m_hDll,"ldap_count_entries");
      ldap_msgfree = (LDAP_MSGFREE*)GetProcAddress(m_hDll,"ldap_msgfree");
      ldap_modify_s = (LDAP_MODIFY_S*)GetProcAddress(m_hDll,"ldap_modify_sW");
      LdapGetLastError = (LDAPGETLASTERROR*)GetProcAddress(m_hDll,"LdapGetLastError");
      ldap_bind_sW = (LDAP_BIND*)GetProcAddress(m_hDll,"ldap_bind_sW");
      ldap_unbind = (LDAP_UNBIND*)GetProcAddress(m_hDll,"ldap_unbind");
      ldap_get_option = (LDAP_GET_OPTION*)GetProcAddress(m_hDll,"ldap_get_option");
      ldap_set_option = (LDAP_SET_OPTION*)GetProcAddress(m_hDll,"ldap_set_option");
      LdapMapErrorToWin32 = (LDAPMAPERRORTOWIN32*)GetProcAddress(m_hDll,"LdapMapErrorToWin32");
   }
   
}

CLdapConnection::~CLdapConnection()
{
   Close();
   if ( m_hDll )
   {
      FreeLibrary(m_hDll);
      ldap_open = NULL;
      ldap_parse_result = NULL;
      ldap_parse_page_control = NULL;
      ldap_controls_free = NULL;
      ber_bvfree = NULL;
      ldap_first_entry = NULL;
      ldap_next_entry = NULL;
      ldap_value_free = NULL;
      ldap_get_values = NULL;
      ldap_create_page_control = NULL;
      ldap_search_ext_s = NULL;
      ldap_count_entries = NULL;
      ldap_msgfree = NULL;
      ldap_modify_s = NULL;
      LdapGetLastError = NULL;
      ldap_bind_sW = NULL;
      ldap_unbind = NULL;
      LdapMapErrorToWin32 = NULL;
   }
}


 
DWORD  CLdapConnection::Connect(WCHAR const * server, ULONG port = LDAP_PORT)
{
   DWORD                     rc = 0;

   safecopy(m_exchServer,server);

   m_LD = CLdapConnection::ldap_open(m_exchServer,LDAP_SSL_PORT);
   if (! m_LD )
   {
      // try the non-SSL port
      m_LD = ldap_open(m_exchServer,port);
   }
   if ( ! m_LD )
   {
      rc = CLdapConnection::LdapGetLastError();
   }
   else
   {
      ULONG                   flags = 0;

      // set version to 3
      rc = ldap_get_option(m_LD, LDAP_OPT_VERSION,&flags);

      if ( ! rc )
      {
         flags = LDAP_VERSION3;
    
         
         rc = ldap_set_option(m_LD,LDAP_OPT_VERSION, &flags);
      }

      if (! rc )
      {
         if ( *m_credentials )
         {
            rc = CLdapConnection::ldap_bind_s(m_LD,m_credentials,m_password,LDAP_AUTH_SIMPLE);
            if ( rc )
            {
               rc = CLdapConnection::ldap_bind_s(m_LD,NULL,NULL,LDAP_AUTH_NTLM);
            }
         }
         else
         {
            rc = CLdapConnection::ldap_bind_s(m_LD,NULL,NULL,LDAP_AUTH_NTLM);
         }
      }
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }
   
   return rc;
}

void   CLdapConnection::Close()
{
   if ( m_LD )
   {
      CLdapConnection::ldap_unbind(m_LD);
      m_LD = NULL;
   }
}

DWORD CLdapConnection::UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value)
{
   DWORD             rc = ERROR_NOT_FOUND;

   if ( m_LD )
   {
      LDAPMod         * mods[2];
      LDAPMod           mod1;
      WCHAR           * strVals[] = { const_cast<WCHAR*>(value),NULL };
      mods[0] = &mod1;

      mods[0]->mod_op = LDAP_MOD_REPLACE;
      mods[0]->mod_type = const_cast<WCHAR*>(property);
      mods[0]->mod_vals.modv_strvals = strVals;
      mods[1] = NULL;

      rc = CLdapConnection::ldap_modify_s(m_LD,const_cast<WCHAR*>(dn),mods);
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }

   return rc;
}

// Helper function for SidToString - converts one BYTE of the SID into a string representation
void 
   CLdapConnection::AddByteToString(
      WCHAR               ** string,      // i/o- pointer to current location in string
      BYTE                   value        // in - value (from SID) to add to the string
   )
{
   WCHAR                     hi,
                             lo;
   BYTE                      hiVal, 
                             loVal;

   loVal = value & 0x0F;
   hiVal = value & 0xF0;
   hiVal = hiVal >> 4;

   if  ( hiVal < 10 )
   {
      hi=L'0' + hiVal;
   }
   else
   {
      hi=L'A' + ( hiVal - 10 );
   }

   if ( loVal < 10 )
   {
      lo=L'0' + loVal;
   }
   else
   {
      lo=L'A' + (loVal - 10 );
   }
   swprintf(*string,L"%c%c",hi,lo);

   *string+=2;
}

BYTE                                          // ret- value for the digit, or 0 if value is not a valid hex digit
   CLdapConnection::HexValue(
      WCHAR                  value           // in - character representing a hex digit
   )
{
   BYTE                      val = 0;
   switch ( toupper((char)value) )
   {
   case L'1': val = 1; break;
   case L'2': val = 2; break;
   case L'3': val = 3; break;
   case L'4': val = 4; break;
   case L'5': val = 5; break;
   case L'6': val = 6; break;
   case L'7': val = 7; break;
   case L'8': val = 8; break;
   case L'9': val = 9; break;
   case L'A': val = 0xA; break;
   case L'B': val = 0xB; break;
   case L'C': val = 0xC; break;
   case L'D': val = 0xD; break;
   case L'E': val = 0xE; break;
   case L'F': val = 0xF; break;
   }
   return val;
}


BOOL                                         // ret- 0=success, or ERROR_INSUFFICIENT_BUFFER 
   CLdapConnection::BytesToString(
      BYTE                 * pBytes,         // in - SID to represent as a string
      WCHAR                * sidString,      // out- buffer that will contain the 
      DWORD                  numBytes        // in - number of bytes in the buffer to copy
   )
{
   BOOL                      bSuccess = TRUE;
   WCHAR                   * curr = sidString;

   // add each byte of the SID to the output string
   for ( int i = 0 ; i < (int)numBytes ; i++)
   {  
      AddByteToString(&curr,pBytes[i]);
   }
   return bSuccess;
}

BOOL 
   CLdapConnection::StringToBytes(
      WCHAR          const * pString,     // in - string representing the data
      BYTE                 * pBytes       // out- binary representation of the data
   )
{
   BOOL                      bSuccess = TRUE;
   int                       len = UStrLen(pString) / 2;

   for ( int i = 0 ; i < len ; i++, pString += 2 )
   {
      // each byte is represented by 2 characters
      WCHAR                  str[3];
      BYTE                   hi,lo;

      safecopy(str,pString);
      
      hi = HexValue(str[0]);
      lo = HexValue(str[1]);

      pBytes[i] = ((hi << 4)+lo);
      
   }

   return bSuccess;
}

CLdapEnum::~CLdapEnum()
{
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }
}


DWORD 
   CLdapEnum::Open(
      WCHAR          const * query,          // in - query to execute
      WCHAR          const * basePoint,      // in - basepoint for query
      short                  scope,          // in - scope: 0=base only, 1=one level, 2=recursive
      long                   pageSize,       // in - page size to use for large searches
      int                    numAttributes,  // in - number of attributes to retrieve for each matching item
      WCHAR               ** attrs           // in - array of attribute names to retrieve for each matching item
   )
{
   // open and bind before calling this function
   ULONG                     result;
   PLDAPSearch               searchBlock = NULL;
   PLDAPControl              serverControls[2];
   l_timeval                 timeout = { 1000,1000 };
   ULONG                     totalCount = 0;
   berval                    cookie1 = { 0, NULL };
   DWORD                     numRead = 0;
 
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }

   LDAP                    * ld = m_connection.GetHandle();

   safecopy(m_query,query);
   safecopy(m_basepoint,basePoint);
   m_scope = scope;
   m_pageSize = pageSize;
   m_nAttributes = numAttributes;
   m_AttrNames = attrs;


   result = m_connection.ldap_create_page_control(ld,
                                     pageSize,
                                     &cookie1,
                                     FALSE, // is critical
                                     &serverControls[0]
                                    );

   serverControls[1] = NULL;

   result = m_connection.ldap_search_ext_s(ld,
                     m_basepoint,
                     m_scope,
                     m_query,
                     m_AttrNames,
                     FALSE,
                     serverControls,
                     NULL,
                     NULL,
                     0,
                     &m_message);
  
   if  ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;
      m_bOpen = TRUE;
   }

  
   return m_connection.LdapMapErrorToWin32(result);
}

DWORD 
   CLdapEnum::Next(
      PWCHAR              ** ppAttrs        // out- array of values for the next matching item
   )
{
   DWORD                     rc = 0;

   if ( ! m_bOpen )
   {
      rc = ERROR_NOT_FOUND;
   }
   else
   {
      if ( m_nReturned > m_nCurrent )
      {
         // return the next entry from the current page
         return GetNextEntry(ppAttrs);
      }
      else 
      {
         // see if there are more pages of results to get
         rc = GetNextPage();
         if (! rc )
         {
            return GetNextEntry(ppAttrs);
         }
      }


   }
   return rc;
}

void CLdapEnum::FreeData(WCHAR ** values)
{
   for ( int i = 0 ; m_AttrNames[i] ; i++ )
   {
      if ( values[i] )
      {
         delete [] values[i];
         values[i] = NULL;
      }
   }
   delete [] values;
}

DWORD 
   CLdapEnum::GetNextEntry(
      PWCHAR              ** ppAttrs
   )
{
   DWORD                     rc = 0;
   WCHAR                  ** pValues = new PWCHAR[m_nAttributes+1];

   if ( m_nCurrent == 0 )
   {

      m_currMsg = m_connection.ldap_first_entry(m_connection.GetHandle(),m_message);
   }
   else
   {
      m_currMsg = m_connection.ldap_next_entry(m_connection.GetHandle(),m_currMsg);
      
   }
   if ( m_currMsg )
   {

      int curr;

      for ( curr = 0 ; m_AttrNames[curr] ; curr++ )
      {
         pValues[curr] = NULL;

         WCHAR ** allvals = m_connection.ldap_get_values(m_connection.GetHandle(),m_currMsg,m_AttrNames[curr] );
         if ( allvals )
         {
            pValues[curr] = new WCHAR[UStrLen(allvals[0])+1];

            UStrCpy(pValues[curr],allvals[0]);
            m_connection.ldap_value_free(allvals);
            allvals =NULL;
         }
      }
      
   }
   (*ppAttrs) = pValues;
   m_nCurrent++;
   return rc;
}

DWORD 
   CLdapEnum::GetNextPage()
{
   ULONG                     result = 0;
   LDAP                    * ld = m_connection.GetHandle();
   berval                  * currCookie = NULL;
   berval                  * cookie2 = NULL;
   WCHAR                   * matched = NULL;
   PLDAPControl            * currControls = NULL;
   ULONG                     retcode = 0;    
   PLDAPControl            * clientControls = NULL;
   WCHAR                   * errMsg = NULL;
   PLDAPControl              serverControls[2];
   
 
   
   // Get the server control from the message, and make a new control with the cookie from the server
   result = m_connection.ldap_parse_result(ld,m_message,&retcode,NULL,NULL,NULL,&currControls,FALSE);
   m_connection.ldap_msgfree(m_message);
   m_message = NULL;
   if ( ! result )
   {
      result = m_connection.ldap_parse_page_control(ld,currControls,&m_totalCount,&currCookie);
      // under Exchange 5.5, before SP 2, this will fail with LDAP_CONTROL_NOT_FOUND when there are 
      // no more search results.  With Exchange 5.5 SP 2, this succeeds, and gives us a cookie that will 
      // cause us to start over at the beginning of the search results.

   }
   if ( ! result )
   {
      if ( currCookie->bv_len == 0 && currCookie->bv_val == 0 )
      {
         // under Exchange 5.5, SP 2, this means we're at the end of the results.
         // if we pass in this cookie again, we will start over at the beginning of the search results.
         result = LDAP_CONTROL_NOT_FOUND;
      }
      
      serverControls[0] = NULL;
      serverControls[1] = NULL;
      if ( ! result )
      {
         result = m_connection.ldap_create_page_control(ld,
                                 m_pageSize,
                                 currCookie,
                                 FALSE,
                                 serverControls);
      }
      m_connection.ldap_controls_free(currControls);
      currControls = NULL;
      m_connection.ber_bvfree(currCookie);
      currCookie = NULL;
   }

   // continue the search with the new cookie
   if ( ! result )
   {
      result = m_connection.ldap_search_ext_s(ld,
            m_basepoint,
            m_scope,
            m_query,
            m_AttrNames,
            FALSE,
            serverControls,
            NULL,
            NULL,
            0,
            &m_message);

      if ( result && result != LDAP_CONTROL_NOT_FOUND )
      {
         // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results 
         // in Exchange 5.5, before SP 2 (the server doesn't return a page control when there 
         // are no more pages, so we get LDAP_CONTROL_NOT_FOUND when we try to extract the page 
         // control from the search results).
         
      }
   }
   if ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;

   }
   return m_connection.LdapMapErrorToWin32(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );

#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\exldap.h ===
#ifndef EXLDAP_H
#define EXLDAP_H

#include <winldap.h>

#include "EaLen.hpp"
#include "Common.hpp"
#include "UString.hpp"

typedef WINLDAPAPI LDAP * LDAPAPI LDAP_OPEN( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI ULONG LDAPAPI LDAPMAPERRORTOWIN32( ULONG LdapError );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_UNBIND( LDAP *ld );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_BIND( LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method );
typedef WINLDAPAPI ULONG LDAPAPI LDAPGETLASTERROR( VOID );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MODIFY_S( LDAP *ld, PWCHAR dn, LDAPModW *mods[] );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MSGFREE( LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_COUNT_ENTRIES( LDAP *ld, LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_SEARCH_EXT_S(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_CREATE_PAGE_CONTROL(
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_PAGE_CONTROL (
        PLDAP           ExternalHandle,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie     // Use ber_bvfree to free
        );
typedef WINLDAPAPI PWCHAR *LDAPAPI LDAP_GET_VALUES(
        LDAP            *ld,
        LDAPMessage     *entry,
        PWCHAR          attr
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_VALUE_FREE( PWCHAR *vals );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_NEXT_ENTRY( LDAP *ld, LDAPMessage *entry );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_FIRST_ENTRY( LDAP *ld, LDAPMessage *res );

typedef WINLDAPAPI VOID LDAPAPI BER_BVFREE( struct berval *bv );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_CONTROLS_FREE (
        LDAPControlW **Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_RESULT (
        LDAP *Connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_memfree
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_memfree
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,    // free with ldap_free_controlsW
        BOOLEAN Freeit
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_GET_OPTION( LDAP *ld, int option, void *outvalue );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_SET_OPTION( LDAP *ld, int option, void *invalue );

class CLdapConnection
{
   WCHAR                     m_exchServer[LEN_Computer];
   LDAP                    * m_LD;
   ULONG                     m_port;
   HMODULE                   m_hDll;
   BOOL                      m_bUseSSL;
   WCHAR                     m_credentials[300];
   WCHAR                     m_password[100];
public:
   LDAP_PARSE_RESULT        * ldap_parse_result;
   LDAP_PARSE_PAGE_CONTROL  * ldap_parse_page_control;
   LDAP_CONTROLS_FREE       * ldap_controls_free;
   BER_BVFREE               * ber_bvfree;
   LDAP_FIRST_ENTRY         * ldap_first_entry;
   LDAP_NEXT_ENTRY          * ldap_next_entry;
   LDAP_VALUE_FREE          * ldap_value_free;
   LDAP_GET_VALUES          * ldap_get_values;
   LDAP_CREATE_PAGE_CONTROL * ldap_create_page_control;
   LDAP_SEARCH_EXT_S        * ldap_search_ext_s;
   LDAP_COUNT_ENTRIES       * ldap_count_entries;
   LDAP_MSGFREE             * ldap_msgfree;
   LDAP_MODIFY_S            * ldap_modify_s;
   LDAPGETLASTERROR         * LdapGetLastError;
   LDAP_BIND                * ldap_bind_sW;
   LDAP_UNBIND              * ldap_unbind;
   LDAPMAPERRORTOWIN32      * LdapMapErrorToWin32;
   LDAP_OPEN                * ldap_open;
   LDAP_GET_OPTION          * ldap_get_option;
   LDAP_SET_OPTION          * ldap_set_option;

public:
   CLdapConnection();
   ~CLdapConnection();

   void   SetCredentials(WCHAR const * cred,WCHAR const * pwd) { safecopy(m_credentials,cred); safecopy(m_password,pwd); }
   LDAP * GetHandle() { return m_LD; }
   DWORD  Connect(WCHAR const * server,ULONG port);
   DWORD UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value);
   void   Close();

   BOOL StringToBytes(WCHAR const * pString,BYTE * pBytes);
   BOOL BytesToString(BYTE * pBytes,WCHAR * sidString,DWORD numBytes);
protected:
   // helper functions
   BYTE HexValue(WCHAR value);
   void AddByteToString(WCHAR ** string,BYTE value);
};


class CLdapEnum
{
   BOOL                      m_bOpen;
   ULONG                     m_nReturned;
   ULONG                     m_nCurrent;
   ULONG                     m_totalCount;
   LDAPMessage             * m_message;
   LDAPMessage             * m_currMsg;
   WCHAR                     m_query[1000];
   WCHAR                     m_basepoint[LEN_DistName];
   int                       m_scope;
   long                      m_pageSize;
   int                       m_nAttributes;
   WCHAR                  ** m_AttrNames;
public:
    CLdapConnection           m_connection;
public:
   CLdapEnum() { m_bOpen = FALSE; m_nReturned = 0; m_nCurrent = 0; m_totalCount = 0; m_message = NULL; 
                 m_query[0] = 0; m_basepoint[0] = 0; m_scope = 2; m_pageSize = 100; m_currMsg = NULL;
                 m_nAttributes = 0; m_AttrNames =NULL;}
   ~CLdapEnum();

   DWORD          InitConnection(WCHAR const * server,ULONG port) { return m_connection.Connect(server,port); }
   DWORD          Open(WCHAR const * query,WCHAR const * basePoint,short scope, long pageSize,int numAttributes,
                  WCHAR ** attrs);
   DWORD          Next(PWCHAR ** ppAttrs);
   void           FreeData(PWCHAR* pValues);
protected:

   DWORD          GetNextEntry(PWCHAR ** ppAttrs);
   DWORD          GetNextPage();

};


#endif // EXLDAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ExEnum.rc
//
#define IDS_PROJNAME                    100
#define IDS_ENUMEXCH_DESC               101
#define IDR_EnumExch                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C23EF7ED_10E9_4228_89E3_E1CFF80FDF5A__INCLUDED_)
#define AFX_STDAFX_H__C23EF7ED_10E9_4228_89E3_E1CFF80FDF5A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C23EF7ED_10E9_4228_89E3_E1CFF80FDF5A__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h 
//
// The debug macros and support classes are declared in 
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The 
// usage of these macros is outlined in the MCS Coding 
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they throw an 
// exception McsException The usage of these macros is 
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they log the 
// message using McsVerifyLog class.  The usage of these 
// macros is outlined in the MCS Coding Standards document.  
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.  
// The output log file is created in the directory 
// defined by MCS_LOG environment variable, or in the 
// TEMP directory, or in the current directory.  The name 
// of the output log file is <module name>.err.  
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG 
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG 
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0) 

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException 
// -----------------
inline McsDebugException::McsDebugException () 
: m_message (0), m_fileName (0), m_lineNum (0) 
{ /* EMPTY */ }
   
inline McsDebugException::~McsDebugException() { 
   delete [] m_message; 
   delete [] m_fileName; 
}

inline const char *McsDebugException::getMessage 
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName 
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum 
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void) 
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void) 
: m_isTested (FALSE), m_isTestMode_ (FALSE) 
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\mcs.h ===
//---------------------------------------------------------------------------
// MCS.h 
//
// Main header file for all MCS applications.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_Mcs_h
#define MCSINC_Mcs_h
#ifdef __cplusplus

// Mandatory Pragma Definitions.
// #pragma warning( 3 : 4706 ) // assignment within if, while, etc.

// Header Files Common To All MCS Modules.
#include "McsDebug.h"   // contains debug macros, it depends on
                        // the following files: McsDebug.cpp,
                        // McsDebugUtil.h and McsDebugUtil.cpp.

#endif /* __cplusplus */
#endif /* MCSINC_Mcs_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "McsMapiUtil_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__2AAB3916_DD40_11D2_A1E3_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__2AAB3916_DD40_11D2_A1E3_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__2AAB3916_DD40_11D2_A1E3_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\exenum\ustring.hpp ===
//#pragma title( "UString.hpp - Common string and character functions" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  UString.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-08-25
Description -  Common string and character functions.
      Many string and character functions defined in "string.h" are redefined
         here as overloaded inline functions with several extensions:
      o  Both ANSI and UNICODE strings are supported.
      o  Both ANSI and UNICODE characters are supported.
      o  For ANSI, characters can be "char signed" or "char unsigned".
      o  Functions that allow a length field, such as "lstrcpy" vs "lstrcpyn",
         are implemented as overloaded functions with optional arguments.
      o  Some functions, UStrCpy in particular, can perform conversion between
         ANSI and UNICODE strings.
      The function names defined here consist of "U" concatenated to the base
         name from "string.h".  The first letter of words or word abbreviations
         are capitalized, e.g. "strcpy" becomes "UStrCpy".
Updates     -
===============================================================================
*/

#ifndef  MCSINC_UString_hpp
#define  MCSINC_UString_hpp

#define safecopy(trg,src) (UStrCpy(trg,src,DIM(trg)))

#ifdef  WIN16_VERSION
   #ifndef  UCHAR
      #define  UCHAR  unsigned char
   #endif

   #include <string.h>
   #include <ctype.h>
#endif  // WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      char           const * s1            // in -ANSI string
   )
{
   return strlen( s1 );
}


int _inline                                // ret-length in chars
   UStrLen(
      UCHAR          const * s1            // in -ANSI string
   )
{
   return strlen( (char const *) s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   strcpy( aTarget, aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      strncpy( aTarget, aSource, copylen );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( aTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource, len );
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

char _inline *
   UStrLwr(
      char                 * s             // i/o-ANSI string
   )
{
   return strlwr( s );
}

UCHAR _inline *
   UStrLwr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strlwr( (char *) s );
}

char _inline *
   UStrUpr(
      char                 * s             // i/o-ANSI string
   )
{
   return strupr( s );
}

UCHAR _inline *
   UStrUpr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strupr( (char *) s );
}

char _inline
   UToLower(
      char                   c             // in -ANSI char
   )
{
   return tolower( c );
}

UCHAR _inline
   UToLower(
      UCHAR                  c             // in -ANSI char
   )
{
   return tolower( (char) c );
}

char _inline
   UToUpper(
      char                   c             // in -ANSI char
   )
{
   return toupper( c );
}

UCHAR _inline
   UToUpper(
      UCHAR                  c             // in -ANSI char
   )
{
   return toupper( (char) c );
}

// Left-trim string in place
_inline UCHAR *
   LTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strorg = s;

   while ( *strorg == ' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

_inline char *
   LTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) LTrim( (UCHAR *) s );
}

// Right-trim string in place
_inline UCHAR *
   RTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == ' ') )
      strend--;
   *strend = '\0';
   return s;
}

_inline char *
   RTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) RTrim( (UCHAR *) s );
}

// Trim string in place
_inline UCHAR *
   Trim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

_inline char *
   Trim(
      char                 * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

#ifndef  WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      WCHAR          const * s1            // in -UNICODE string
   )
{
   return lstrlenW( s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   UStrCpy( (char *) aTarget, wSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource       // in -ANSI source string
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( wTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   lstrcpyW( wTarget, wSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, wSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( wTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      lstrcpynW( wTarget, wSource, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcscmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsncmp( s1, s2, len );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcsicmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsnicmp( s1, s2, len );
}

WCHAR _inline *
   UStrLwr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcslwr( s );
}

WCHAR _inline *
   UStrUpr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcsupr( s );
}

WCHAR _inline
   UToLower(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towlower( c );
}

WCHAR _inline
   UToUpper(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towupper( c );
}

// Left-trim string in place
_inline WCHAR *
   LTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strorg = s;

   while ( *strorg == L' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

// Right-trim string in place
_inline WCHAR *
   RTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == L' ') )
      strend--;
   *strend = L'\0';
   return s;
}

// Trim string in place
_inline WCHAR *
   Trim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return LTrim( RTrim( s ) );
}

char * _cdecl                             // ret-target string
   UStrJoin(
      char                 * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      char const           * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

WCHAR * _cdecl                            // ret-target string
   UStrJoin(
      WCHAR                * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      WCHAR const          * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

#endif  // WIN16_VERSION

#endif  // MCSINC_UString_hpp

// UString.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\listprof.cpp ===
/*---------------------------------------------------------------------------
  File: ListProfiles.cpp

  Comments: Helper functions that dynamically load the MAPI library, and 
  enumerate the MAPI profiles on the local machine (for the logged on user)

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/18/99 11:09:53

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "resource.h"
#include "ListProf.h"
#include "Common.hpp"
#include "Ustring.hpp"

#include <edkmdb.h>
#include <emsabtag.h>

HINSTANCE                    hMapi = NULL;

LPMAPIALLOCATEBUFFER         pMAPIAllocateBuffer = NULL;
LPMAPIFREEBUFFER             pMAPIFreeBuffer = NULL;
LPMAPIINITIALIZE             pMAPIInitialize = NULL;
LPMAPIUNINITIALIZE           pMAPIUninitialize = NULL;
LPMAPILOGONEX                pMAPILogonEx = NULL;
LPMAPIADMINPROFILES          pMAPIAdminProfiles = NULL;
LPFREEPADRLIST               pFreePadrlist = NULL;
LPFREEPROWS                  pFreeProws = NULL;
LPSCDUPPROPSET               pScDupPropset = NULL;
LPHRQUERYALLROWS             pHrQueryAllRows = NULL;              
LPULRELEASE                  pUlRelease = NULL;      
BOOL                         bMapiInitialized = FALSE;

#define NOT_PT_ERROR(x) ( PROP_TYPE(x.ulPropTag) != PT_ERROR )

BOOL 
   LoadMAPI(
      IVarSet              * pVarSet
   )
{
   BOOL                      success = TRUE;
   WCHAR                     errString[1000] = L"";

   if ( ! hMapi )
   {
      hMapi = LoadLibrary(_T("MAPI32.DLL"));
      if ( hMapi )
      {
         do { // once    (only show one error message)
            pMAPIAllocateBuffer=(LPMAPIALLOCATEBUFFER)GetProcAddress(hMapi,"MAPIAllocateBuffer");
            if ( ! pMAPIAllocateBuffer )
            {
               LoadString(NULL,IDS_NoMAPIAllocateBuffer,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pMAPIFreeBuffer = (LPMAPIFREEBUFFER)GetProcAddress(hMapi,"MAPIFreeBuffer");
            if ( ! pMAPIFreeBuffer )
            {
               LoadString(NULL,IDS_NoMAPIFreeBuffer,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pMAPIInitialize = (LPMAPIINITIALIZE)GetProcAddress(hMapi,"MAPIInitialize");
            if ( ! pMAPIInitialize )
            {
               LoadString(NULL,IDS_NoMAPIInitialize,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pMAPIUninitialize = (LPMAPIUNINITIALIZE)GetProcAddress(hMapi,"MAPIUninitialize");
            if ( ! pMAPIUninitialize )
            {
               LoadString(NULL,IDS_NoMAPIUninitialize,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pMAPILogonEx = (LPMAPILOGONEX)GetProcAddress(hMapi,"MAPILogonEx");
            if ( ! pMAPILogonEx )
            {
               LoadString(NULL,IDS_NoMAPILogonEx,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pMAPIAdminProfiles = (LPMAPIADMINPROFILES)GetProcAddress(hMapi,"MAPIAdminProfiles");
            if ( ! pMAPIAdminProfiles )
            {
               LoadString(NULL,IDS_NoMAPIAdminProfiles,errString,DIM(errString));
               success = FALSE;
               break;
            }
         
            pFreePadrlist = (LPFREEPADRLIST)GetProcAddress(hMapi,"FreePadrlist@4");
            if ( ! pFreePadrlist )
            {
               LoadString(NULL,IDS_NoFreePadrList,errString,DIM(errString));
               success = FALSE;
               break;
            }

            pFreeProws = (LPFREEPROWS)GetProcAddress(hMapi,"FreeProws@4");
            if ( ! pFreeProws )
            {
               LoadString(NULL,IDS_NoFreeProws,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pScDupPropset = (LPSCDUPPROPSET)GetProcAddress(hMapi,"ScDupPropset@16");
            if ( ! pScDupPropset )
            {
               LoadString(NULL,IDS_NoScDupPropset,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pHrQueryAllRows = (LPHRQUERYALLROWS)GetProcAddress(hMapi,"HrQueryAllRows@24");
            if ( ! pHrQueryAllRows )
            {
               LoadString(NULL,IDS_NoHrQueryAllRows,errString,DIM(errString));
               success = FALSE;
               break;
            }
            pUlRelease = (LPULRELEASE)GetProcAddress(hMapi,"UlRelease@4");
            if ( ! pUlRelease )
            {
               LoadString(NULL,IDS_NoUlRelease,errString,DIM(errString));
               success = FALSE;
               break;
            }
         }
         while (FALSE);
      }
      else
      {
         success = FALSE;
         LoadString(NULL,IDS_NO_MAPI,errString,DIM(errString));
      }
      if ( hMapi && !success )
      {
         ReleaseMAPI();
      }
   }
   if ( !success )
   {
      if ( pVarSet)
      {
         pVarSet->put("McsMapiUtil.ErrorText",errString);
      }
   }
   return (hMapi!=NULL && success);
}

void ReleaseMAPI()
{
   if ( hMapi )
   {
      if ( bMapiInitialized )
      {
         (*pMAPIUninitialize)();
         bMapiInitialized = FALSE;
      }
      FreeLibrary(hMapi);
      hMapi = NULL;
      pMAPIAllocateBuffer = NULL;
      pMAPIFreeBuffer = NULL;
      pMAPIInitialize = NULL;
      pMAPIUninitialize = NULL;
      pMAPILogonEx = NULL;
      pMAPIAdminProfiles = NULL;
      pFreePadrlist = NULL;
      pFreeProws = NULL;
      pScDupPropset = NULL;
      pHrQueryAllRows = NULL;              
      pUlRelease = NULL;     
   }
}

HRESULT ListProfiles(IVarSet * pVarSet)
{
   HRESULT        hr;
   LPPROFADMIN    prof = NULL;
   LPMAPITABLE    table = NULL;
   LPSRowSet      rows = NULL;

   if ( ! LoadMAPI(pVarSet) )
   {
      return E_FAIL;
   }
   if ( ! bMapiInitialized )
   {
      hr = (*pMAPIInitialize)(NULL);
      if ( SUCCEEDED(hr) )
      {
         bMapiInitialized = TRUE;
      }
   }
   if ( SUCCEEDED(hr) )
   {
      hr = (*pMAPIAdminProfiles)(0,&prof);
   }
   if ( SUCCEEDED(hr) )
   {
      hr = prof->GetProfileTable(0,&table);
      if ( SUCCEEDED(hr) )
      {
         hr = (*pHrQueryAllRows)(table,NULL,NULL,NULL,0,&rows);
         if ( SUCCEEDED(hr) )
         {
            for ( UINT i = 0 ; i < rows->cRows ; i ++ )
            {
               if ( PROP_TYPE(rows->aRow[i].lpProps[0].ulPropTag ) == PT_STRING8 )
               {
			         WCHAR                profile[200];
                  WCHAR                key[200];

                  safecopy(profile,rows->aRow[i].lpProps[0].Value.lpszA);
		            swprintf(key,L"Profiles.%ld",i);
                  pVarSet->put(key,profile);
                  if ( rows->aRow[i].lpProps[1].Value.b )
                  {
                     swprintf(key,L"Profiles.%ld.Default",i);
                     pVarSet->put(key,"Yes");
                  }
               }
            }
         }
      }
   }
   if ( rows )
   {
      (*pFreeProws)(rows);
   }
   if ( table )
   {
      table->Release();
   }
   if ( prof )
   {
      prof->Release();
   }
   return hr;
}



// GPSGuid is pbGlobalProfileSectionGuid (defined in edkmdb.h) in a byte[] format
// This is used in GetExchangeServerFromProfile
#define	GPSGuid	    { 0x13, 0xDB, 0xB0, 0xC8,0xAA,0x05,0x10,0x1A,0x9B,0xB0,0x00,0xAA,0x00,0x2F,0xC4,0x5A }

MAPIUID exchSrvrGuid  = { 0xdc, 0xa7, 0x40, 0xc8,0xC0,0x42,0x10,0x1a,0xb4,0xb9,0x08,0x00,0x2b,0x2f,0xe1,0x82 };

HRESULT ProfileGetServer(IVarSet * pVarSet,WCHAR const * profileW, WCHAR * computerName)
{
   HRESULT                   hr;
   MAPIUID                   uid   = GPSGuid;
   LPPROFADMIN               prof  = NULL;
   LPSERVICEADMIN            admin = NULL;
   LPPROFSECT                ps    = NULL;
   char                      profile[200];
   LPSPropValue              pVals = NULL;
   ULONG                     ulCount = 0;
   WCHAR                     errString[1000] = L"";
   
   computerName[0] = 0;
   safecopy(profile,profileW);
   
   if ( ! LoadMAPI(pVarSet) )
   {
      return E_FAIL;
   }
   if ( ! bMapiInitialized )
   {
      hr = (*pMAPIInitialize)(NULL);
      if ( SUCCEEDED(hr) )
      {
         bMapiInitialized = TRUE;
      }
   }

   SizedSPropTagArray(1,prop) = 
   { 
      1, 
      { 
         PR_PROFILE_HOME_SERVER 
      } 
   };

   if ( profile[0] ) 
   {
   
      hr = (*pMAPIAdminProfiles)(0,&prof);
   
      if ( FAILED(hr) ) 
      {
         LoadString(NULL,IDS_CannotAccessProfiles,errString,DIM(errString));
         goto err_continue;
      }
      
      hr = prof->AdminServices((WCHAR *)profile,NULL,NULL,0,&admin); // profile is ANSI, since MAPI_UNICODE flag not set.
   
      if ( FAILED(hr) ) 
      {
         LoadString(NULL,IDS_IProfAdmin_AdminServices,errString,DIM(errString));
         goto err_continue;
      }
      
      hr = admin->OpenProfileSection(&uid,NULL,0,&ps);
   
      if ( FAILED(hr) ) 
      {
         LoadString(NULL,IDS_IServiceAdmin_OpenProfileSection,errString,DIM(errString));;
         goto err_continue;
      }
            
      hr = ps->GetProps((LPSPropTagArray)&prop,0,&ulCount,&pVals);
   
      if ( FAILED(hr) ) 
      {
         LoadString(NULL,IDS_IProfSect_GetProps,errString,DIM(errString));;
         goto err_continue;
      }
            
      if ( ulCount && PROP_TYPE(pVals[0].ulPropTag) != PT_ERROR ) 
      {
         UStrCpy(computerName,pVals[0].Value.lpszA);
      }
      else
      {
         hr = E_FAIL;
         LoadString(NULL,IDS_DidntGetProp,errString,DIM(errString));;
      }
   }
   err_continue:
   if ( pVals )
   {
      (*pMAPIFreeBuffer)(pVals);
   }

   if ( prof )
   {
      prof->Release();
   }

   if ( admin )
   {
      admin->Release();
   }

   if ( ps )
   {
      ps->Release();
   }
   if ( FAILED(hr) )
   {
      if ( pVarSet )
      {
         pVarSet->put("McsMapiUtil.ErrorText",errString);
      }
   }
   return hr;
}

HRESULT ListContainers(WCHAR * profileName,IVarSet * pVarSet)
{
   LPMAPISESSION             sess = NULL;
   HRESULT                   hr = S_OK;
   LPABCONT                  pRootEntry = NULL;  // root of AB
   LPMAPITABLE               pRootTable = NULL;  // root table
   LPSRowSet                 pRootRows = NULL;
   LPADRBOOK                 pAdrBook = NULL;
   ULONG                     ulObjectType = 0;
   FLAGS                     fLogonOptions = MAPI_NO_MAIL | MAPI_EXTENDED | MAPI_NEW_SESSION | MAPI_EXPLICIT_PROFILE;
   char                      title[MAX_PATH];
   char                      key[MAX_PATH];
   char                      containerDN[MAX_PATH] = "";
   long                      lVarSetNdx = 0;

  
   if ( ! LoadMAPI(pVarSet) )
   {
      return E_FAIL;
   }
   if ( ! bMapiInitialized )
   {
      hr = (*pMAPIInitialize)(NULL);
      if ( SUCCEEDED(hr) )
      {
         bMapiInitialized = TRUE;
      }
   }
   if ( SUCCEEDED(hr) )
   {
      hr = (*pMAPILogonEx)(0,profileName,NULL, fLogonOptions | MAPI_UNICODE, &sess);
      if ( SUCCEEDED(hr) )
      {
     
         SizedSPropTagArray(4, rgPropTags) =
         {
            4,
            {
               PR_ENTRYID,
               PR_DISPLAY_NAME_A,
               PR_DEPTH,
               PR_AB_PROVIDER_ID
            }
         };

         hr = sess->OpenAddressBook(0, NULL, AB_NO_DIALOG , &pAdrBook);
         // TODO: error messages for these 
         if ( SUCCEEDED(hr) )
         {
            // Open the root entry.
            hr = pAdrBook->OpenEntry(0, NULL, NULL, 0, &ulObjectType, (LPUNKNOWN*)&pRootEntry);
         }
         // Get its hierarchical table.
         if ( SUCCEEDED(hr) )
         {
            hr = pRootEntry->GetHierarchyTable( CONVENIENT_DEPTH, &pRootTable);
         }
         if ( SUCCEEDED(hr) )
         {
            // Get a list of all rows.
            hr = (*pHrQueryAllRows)(pRootTable, (LPSPropTagArray)&rgPropTags, NULL, NULL, 0, &pRootRows);
         }
         long     lStartRow = -1;   // Current start point for search.
         BOOL     bAborted = FALSE; // Set TRUE if we punt due to mismatch.
         long     lDepth;           // Current depth of search.
         
         for (lDepth = 0; (lDepth < 1) && !bAborted; ++lDepth) 
         {
            ++lStartRow;
            for (ULONG ulRow = (ULONG)lStartRow; ulRow < pRootRows->cRows; ++ulRow) 
            {
               // Only display Exchange server containers
               if ( IsEqualMAPIUID(&exchSrvrGuid,pRootRows->aRow[ulRow].lpProps[3].Value.bin.lpb) )
               {


                  long  lRowDepth = pRootRows->aRow[ulRow].lpProps[2].Value.l;
                  if ( PROP_TYPE(pRootRows->aRow[ulRow].lpProps[1].ulPropTag) == PT_STRING8 )
                  {
                     sprintf(title,"%s",pRootRows->aRow[ulRow].lpProps[1].Value.lpszA);
                     sprintf(key,"Container.%ld",lVarSetNdx);
                     pVarSet->put(key,title);
                     sprintf(key,"Container.%ld.Depth",lVarSetNdx);
                     pVarSet->put(key,lRowDepth);
                     // Try to get the distinguished name, so that we can uniquely identify this container later
                     LPSPropValue            props = NULL;
                     LPABCONT                pEntry = NULL;
                     ULONG                   ulCount;
                     HRESULT                 hr2 = S_OK;
                     ULONG                   ulObjectType;
                     
                     SizedSPropTagArray(2, rgPT2) =
                     {
                        2,
                        {
                           PR_DISPLAY_NAME_A,
                           PR_EMS_AB_OBJ_DIST_NAME_A
                        }
                     };  
                  
                     if ( NOT_PT_ERROR(pRootRows->aRow[ulRow].lpProps[0]) )
                     {
                        hr2  = pAdrBook->OpenEntry(pRootRows->aRow[ulRow].lpProps[0].Value.bin.cb,
                              (LPENTRYID)pRootRows->aRow[ulRow].lpProps[0].Value.bin.lpb,
                              NULL,
                              0,
                              &ulObjectType,
                              (LPUNKNOWN *)&pEntry);
                     }
                     else
                     {
                        hr2 = E_FAIL;
                     }
                     if ( SUCCEEDED(hr2) )
                     {
                        hr2 = pEntry->GetProps((LPSPropTagArray)&rgPT2,0,&ulCount,&props);
                     }
                     if ( SUCCEEDED(hr2) )
                     {
                        if ( ulCount && NOT_PT_ERROR(props[1]) )               
                        {
                           UStrCpy(containerDN,props[1].Value.lpszA);
                        }
                        if ( props )
                        {
                           (*pMAPIFreeBuffer)(props);
                        }
                     }
                     if ( *containerDN )
                     {
                        sprintf(key,"Container.%ld.DistinguishedName",lVarSetNdx);
                        pVarSet->put(key,containerDN);
                     }
                  }
                  lVarSetNdx++;
               }
            }
         }
         sess->Logoff(0,0,0);
      }
   }

   if ( pRootRows )
   {
      (*pFreeProws)(pRootRows);
   }
   if ( pRootEntry )
   {
      pRootEntry->Release();
   }
   if ( pRootTable )
   {
      pRootTable->Release();
   }
   if ( pAdrBook )
   {
      pAdrBook->Release();
   }
   pVarSet->put("Container.NumItems",lVarSetNdx);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\listprof.h ===
/*---------------------------------------------------------------------------
  File: ...

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/18/99 11:13:23

 ---------------------------------------------------------------------------
*/

#include <mapix.h>


#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids


typedef void (STDAPICALLTYPE FREEPADRLIST) (LPADRLIST lpAdrlist);

typedef FREEPADRLIST FAR * LPFREEPADRLIST;

typedef void (STDAPICALLTYPE FREEPROWS) (LPSRowSet lpRows);

typedef FREEPROWS FAR * LPFREEPROWS;

typedef SCODE (STDAPICALLTYPE SCDUPPROPSET)(  int cprop,                           
  LPSPropValue rgprop,LPALLOCATEBUFFER lpAllocateBuffer,LPSPropValue FAR * prgprop);

typedef SCDUPPROPSET FAR * LPSCDUPPROPSET;

typedef HRESULT (STDAPICALLTYPE HRQUERYALLROWS)(LPMAPITABLE lpTable, 
                        LPSPropTagArray lpPropTags,
                        LPSRestriction lpRestriction,
                        LPSSortOrderSet lpSortOrderSet,
                        LONG crowsMax,
                        LPSRowSet FAR *lppRows);

typedef HRQUERYALLROWS FAR * LPHRQUERYALLROWS;

typedef ULONG (STDAPICALLTYPE ULRELEASE)(LPVOID lpunk);

typedef ULRELEASE FAR * LPULRELEASE;

BOOL LoadMAPI(IVarSet * pVarSet);

void ReleaseMAPI();

HRESULT ListProfiles(IVarSet * pVarSet);

HRESULT ProfileGetServer(IVarSet * pVarSet,WCHAR const * profileW, WCHAR * computerName);

HRESULT ListContainers(WCHAR * profileName,IVarSet * pVarSet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\mapiutil.h ===
// MapiUtil.h : Declaration of the CMapiUtil

#ifndef __MAPIUTIL_H_
#define __MAPIUTIL_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMapiUtil
class ATL_NO_VTABLE CMapiUtil : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMapiUtil, &CLSID_MapiUtil>,
	public IDispatchImpl<IMapiUtil, &IID_IMapiUtil, &LIBID_MCSMAPIUTILLib>
{
public:
	CMapiUtil()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_MAPIUTIL)
DECLARE_NOT_AGGREGATABLE(CMapiUtil)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMapiUtil)
	COM_INTERFACE_ENTRY(IMapiUtil)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IMapiUtil
public:
	STDMETHOD(ProfileGetServer)(BSTR profile,/*[out]*/ BSTR * exchangeServer);
	STDMETHOD(ListProfiles)(/*[out]*/ IUnknown ** pUnkOut);
	STDMETHOD(ListContainers)(BSTR profile, /*[out]*/ IUnknown ** pUnkOut);
};

#endif //__MAPIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\mapiutil.cpp ===
/*---------------------------------------------------------------------------
  File: MapiUtil.cpp

  Comments: COM helper object that enumerates MAPI profiles on a computer, and
  containers in the exchange directory.  This is used by the GUI to show the available
  mapi profiles and containers for selection.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 07/01/99 

 ---------------------------------------------------------------------------
*/// MapiUtil.cpp : Implementation of CMapiUtil
#include "stdafx.h"
#include "McsMapi.h"
#include "MapiUtil.h"

#include "ListProf.h"
/////////////////////////////////////////////////////////////////////////////
// CMapiUtil


STDMETHODIMP CMapiUtil::ListContainers(BSTR profile, IUnknown **pUnkOut)
{
   HRESULT                   hr = S_OK;

   IVarSetPtr                pVarSet(CLSID_VarSet);
   IUnknownPtr               pUnk;

   hr = ::ListContainers((WCHAR*)profile,pVarSet);

   if ( FAILED(hr) )
   {
      pVarSet->put("McsMapiUtil.ErrorCode",hr);
      hr = S_OK;
   }
   pUnk = pVarSet;
   (*pUnkOut) = pUnk;
   (*pUnkOut)->AddRef();
   
   return hr;
}

STDMETHODIMP CMapiUtil::ListProfiles(IUnknown **pUnkOut)
{
	HRESULT                   hr = S_OK;

   IVarSetPtr                pVarSet(CLSID_VarSet);
   IUnknownPtr               pUnk;

   hr = ::ListProfiles(pVarSet);

   if ( FAILED(hr) )
   {
      pVarSet->put("McsMapiUtil.ErrorCode",hr);
      hr = S_OK;
   }                            
   pUnk = pVarSet;
   (*pUnkOut) = pUnk;
   (*pUnkOut)->AddRef();
   
   return hr;

}

STDMETHODIMP CMapiUtil::ProfileGetServer(BSTR profile, BSTR *exchangeServer)
{
   WCHAR                     computername[MAX_PATH];
   HRESULT                   hr = S_OK;
   
   hr = ::ProfileGetServer(NULL,(WCHAR*)profile,computername);
   
   if ( SUCCEEDED(hr) )
   {
      (*exchangeServer) = SysAllocString(computername);
   }
   else
   {
      (*exchangeServer) = NULL;
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsMapiUtil.rc
//
#define IDS_PROJNAME                    100
#define IDR_MAPIUTIL                    101
#define IDS_NoMAPIAllocateBuffer        101
#define IDS_NoMAPIFreeBuffer            102
#define IDS_NoMAPIInitialize            103
#define IDS_NoMAPIUninitialize          104
#define IDS_NoMAPILogonEx               105
#define IDS_NoMAPIAdminProfiles         106
#define IDS_NoFreePadrList              107
#define IDS_NoFreeProws                 108
#define IDS_NoScDupPropset              109
#define IDS_NoHrQueryAllRows            110
#define IDS_NoUlRelease                 111
#define IDS_NO_MAPI                     112
#define IDS_CannotAccessProfiles        113
#define IDS_IProfAdmin_AdminServices    114
#define IDS_IServiceAdmin_OpenProfileSection 115
#define IDS_IProfSect_GetProps          116
#define IDS_DidntGetProp                117

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h 
//
// The debug macros and support classes are declared in 
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The 
// usage of these macros is outlined in the MCS Coding 
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they throw an 
// exception McsException The usage of these macros is 
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they log the 
// message using McsVerifyLog class.  The usage of these 
// macros is outlined in the MCS Coding Standards document.  
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.  
// The output log file is created in the directory 
// defined by MCS_LOG environment variable, or in the 
// TEMP directory, or in the current directory.  The name 
// of the output log file is <module name>.err.  
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG 
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG 
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0) 

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException 
// -----------------
inline McsDebugException::McsDebugException () 
: m_message (0), m_fileName (0), m_lineNum (0) 
{ /* EMPTY */ }
   
inline McsDebugException::~McsDebugException() { 
   delete [] m_message; 
   delete [] m_fileName; 
}

inline const char *McsDebugException::getMessage 
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName 
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum 
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void) 
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void) 
: m_isTested (FALSE), m_isTestMode_ (FALSE) 
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\mcsmapi.cpp ===
/*---------------------------------------------------------------------------
  File: McsMapiUtil 

  Comments: DLL Exports for McsMapiUtil helper COM object.
  This file is generated by the ATL wizard.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 07/01/99 

 ---------------------------------------------------------------------------
*/// McsMapiUtil.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsMapiUtil.idl by adding the following 
//      files to the Outputs.
//          McsMapiUtil_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsMapiUtilps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "McsMapi.h"
#include "dlldatax.h"

#include "McsMapi_i.c"
#include "MapiUtil.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_MapiUtil, CMapiUtil)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSMAPIUTILLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__2AAB390E_DD40_11D2_A1E3_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__2AAB390E_DD40_11D2_A1E3_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__2AAB390E_DD40_11D2_A1E3_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\detdlg.cpp ===
/*---------------------------------------------------------------------------
  File: AgentDetailDlg.cpp 

  Comments: This dialog shows the status of the agent on a single machine:
  It can work in one of 3 ways:
  1)  COM connection to the running agent on the local machine
  2)  DCOM connection to a running agent on another machine (this is done 
      with help from the agent service)
  3)  For a remote agent that has finished, it can show the final stats,
      as recorded in the agent's result file.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// AgentDetail.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "DetDlg.h"

#include "Common.hpp"
#include "AgRpcUtl.h"
#include "Monitor.h"
#include "ResStr.h"

//#include "..\AgtSvc\AgSvc.h"
#include "AgSvc.h"
#include "AgSvc_c.c"

//#import "\bin\McsEADCTAgent.tlb" no_namespace , named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace

//#import "Engine.tlb" no_namespace, named_guids //already #imported via DetDlg.h
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


HWND        gSubWnd = NULL;
BOOL        bDetailDone = FALSE;
int         detailInterval = 0;
extern BOOL gbCancelled;

/////////////////////////////////////////////////////////////////////////////
// CAgentDetailDlg dialog


CAgentDetailDlg::CAgentDetailDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAgentDetailDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAgentDetailDlg)
	m_Current = _T("");
	m_Status = _T("");
 	m_FilesChanged = _T("0");
	m_FilesExamined = _T("0");
	m_FilesUnchanged = _T("0");
   m_DirectoriesChanged = _T("0");
	m_DirectoriesExamined = _T("0");
	m_DirectoriesUnchanged = _T("0");
   m_SharesChanged = _T("0");
	m_SharesExamined = _T("0");
	m_SharesUnchanged = _T("0");
	m_Operation = _T("");
	m_RefreshRate = _T("5");
	//}}AFX_DATA_INIT
   m_DirectoryLabelText.LoadString(IDS_DirectoriesLabel);
	m_FilesLabelText.LoadString(IDS_FilesLabel);
	m_SharesLabelText.LoadString(IDS_SharesLabel);
	m_ChangedLabel.LoadString(IDS_ChangedLabel);
	m_ExaminedLabel.LoadString(IDS_ExaminedLabel);
	m_UnchangedLabel.LoadString(IDS_UnchangedLabel);
	m_pNode = NULL;
   detailInterval = _wtoi(m_RefreshRate);
   m_bCoInitialized = FALSE;
   m_format = 0;
   m_AgentAlive = FALSE;
   m_StatusUnknown = FALSE;
   m_hBinding = 0;
   m_pStats = NULL;
   m_bGatheringInfo = FALSE;
   m_bAutoHide = FALSE;
   m_bAutoClose = FALSE;
   m_bAlwaysEnableClose = TRUE;
}

ULONG __stdcall RefreshThread(void * arg)
{
   do { 
      PostMessage(gSubWnd,DCT_DETAIL_REFRESH,NULL,NULL);
      Sleep(detailInterval*1000);
   }
   while (! bDetailDone);
   return 0;
}
void CAgentDetailDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAgentDetailDlg)
	DDX_Control(pDX, IDC_STOPAGENT, m_StopAgentButton);
	DDX_Control(pDX, IDC_BTNREFRESH, m_RefreshButton);
	DDX_Control(pDX, IDC_VIEW_LOG, m_ViewLogButton);
	DDX_Control(pDX, IDC_PLUG_IN_RESULTS, m_PlugInButton);
	DDX_Control(pDX, IDOK, m_OKButton);
	DDX_Control(pDX, IDC_UnchangedLabel, m_UnchangedLabelStatic);
	DDX_Control(pDX, IDC_SharesLabel, m_SharesStatic);
	DDX_Control(pDX, IDC_FilesLabel, m_FilesStatic);
	DDX_Control(pDX, IDC_ExaminedLabel, m_ExaminedStatic);
	DDX_Control(pDX, IDC_DirectoriesLabel, m_DirStatic);
	DDX_Control(pDX, IDC_ChangedLabel, m_ChangedStatic);
	DDX_Text(pDX, IDC_CURRENT, m_Current);
	DDX_Text(pDX, IDC_STATUS, m_Status);
 	DDX_Text(pDX, IDC_FilesChanged, m_FilesChanged);
	DDX_Text(pDX, IDC_FilesExamined, m_FilesExamined);
	DDX_Text(pDX, IDC_FilesU, m_FilesUnchanged);
	DDX_Text(pDX, IDC_DirsChanged, m_DirectoriesChanged);
	DDX_Text(pDX, IDC_DirsExamined, m_DirectoriesExamined);
   DDX_Text(pDX, IDC_DirsU, m_DirectoriesUnchanged);
   DDX_Text(pDX, IDC_SharesChanged, m_SharesChanged);
	DDX_Text(pDX, IDC_SharesExamined, m_SharesExamined);
	DDX_Text(pDX, IDC_SharesU, m_SharesUnchanged);
	DDX_Text(pDX, IDC_DirectoriesLabel, m_DirectoryLabelText);
	DDX_Text(pDX, IDC_FilesLabel, m_FilesLabelText);
	DDX_Text(pDX, IDC_OPERATION, m_Operation);
	DDX_Text(pDX, IDC_SharesLabel, m_SharesLabelText);
	DDX_Text(pDX, IDC_ChangedLabel, m_ChangedLabel);
	DDX_Text(pDX, IDC_ExaminedLabel, m_ExaminedLabel);
	DDX_Text(pDX, IDC_UnchangedLabel, m_UnchangedLabel);
	DDX_Text(pDX, IDC_EDIT2, m_RefreshRate);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAgentDetailDlg, CDialog)
	//{{AFX_MSG_MAP(CAgentDetailDlg)
	ON_WM_NCPAINT()
	ON_BN_CLICKED(IDC_BTNREFRESH, OnRefresh)
	ON_EN_CHANGE(IDC_EDIT2, OnChangeEdit2)
	ON_BN_CLICKED(IDC_STOPAGENT, OnStopAgent)
	ON_BN_CLICKED(IDC_VIEW_LOG, OnViewLog)
	ON_BN_CLICKED(IDC_PLUG_IN_RESULTS, OnPlugInResults)
	ON_WM_CLOSE()
	//}}AFX_MSG_MAP
   ON_MESSAGE(DCT_DETAIL_REFRESH, DoRefresh)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAgentDetailDlg message handlers

BOOL CAgentDetailDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
   CString title;
   if ( m_JobGuid.length() )
   {
      // connect to local agent
      title.LoadString(IDS_PROGRESS_TITLE);
   }
   else
   {
      // connect to agent service on remote machine

      if ( ! m_pNode )
      {
		 // if not auto closing display message box

         if (!m_bAutoClose)
         {
            CString message;
            message.LoadString(IDS_ServerNotFound);
            MessageBox(message);
         }
         OnOK();
      }
      m_ServerName = m_pNode->GetServer();
      title.FormatMessage(IDS_ServerAgentProgressTitle,m_ServerName);
   }
   
   SetWindowText(title);
   UpdateData(FALSE);

     //If not AR operation, set the flag to enable the close button
   if (m_format != 1)
      m_bAlwaysEnableClose = TRUE;
   else
	  m_bAlwaysEnableClose = FALSE;

   switch (m_format)
   {
   // set the format to -1 to force a change
   case -1: m_format = -2; SetupOtherFormat(); break;
   case 0: m_format = -2; SetupFSTFormat();break;
   case 1: m_format = -2; SetupAcctReplFormat(); break;
   case 2: m_format = -2; SetupESTFormat(); break;
   };

   gSubWnd = m_hWnd;
   if ( m_pStats && (m_format>0) )
   {
      bDetailDone = TRUE;
      GetDlgItem(IDC_BTNREFRESH)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDIT2)->EnableWindow(FALSE);
      GetDlgItem(IDC_REFRESH_LABEL)->EnableWindow(FALSE);
      GetDlgItem(IDC_STOPAGENT)->EnableWindow(FALSE);
      m_OKButton.EnableWindow(TRUE);
      // the agent has finished, show files, directories, and shares
      m_FilesExamined.Format(L"%ld",m_pStats->filesExamined);
      m_FilesChanged.Format(L"%ld",m_pStats->filesChanged);
      m_FilesUnchanged.Format(L"%ld",m_pStats->filesUnchanged);

      m_DirectoriesExamined.Format(L"%ld",m_pStats->directoriesExamined);
      m_DirectoriesChanged.Format(L"%ld",m_pStats->directoriesChanged);
      m_DirectoriesUnchanged.Format(L"%ld",m_pStats->directoriesUnchanged);

      m_SharesExamined.Format(L"%ld",m_pStats->sharesExamined);
      m_SharesChanged.Format(L"%ld",m_pStats->sharesChanged);
      m_SharesUnchanged.Format(L"%ld",m_pStats->sharesUnchanged);

      m_Status.LoadString(IDS_StatusCompleted);

      if ( m_PlugInText.GetLength() )
      {
         //Permanently hide the plug-in button, since our plug-ins
         // don't show any useful text
         // m_PlugInButton.ShowWindow(SW_SHOW);
      }
      UpdateData(FALSE);

	  // if auto closing dialog

      if (m_bAutoClose)
      {
         OnOK();
      }
   }
   else
   {

      bDetailDone = FALSE;
      m_hBinding = NULL;
   
      DWORD                     threadID;
      HANDLE                    h = CreateThread(NULL,0,&RefreshThread,NULL,0,&threadID);
   
      CloseHandle(h);
	     
	     //hide the close button until the agent is done or stopped unless the flag is set
	     //due to running this dialog for account replication
	  if (m_bAlwaysEnableClose)
         m_OKButton.EnableWindow(TRUE);
	  else
         m_OKButton.EnableWindow(FALSE);
   }
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

DWORD 
   DoRpcQuery(
      HANDLE                 hBinding,    // in - handle to RPC binding
      LPUNKNOWN            * ppUnk        // out- pointer to remote agent COM object
   )
{
   DWORD                     rc = 0;
   
   RpcTryExcept
   {
      rc = EaxcQueryInterface(hBinding,ppUnk);
   }
   RpcExcept(1)
   {
      rc = RpcExceptionCode();
   }
   RpcEndExcept
   
   if ( rc )
   {
      (*ppUnk ) = NULL;
   }
   return rc;
}

void CAgentDetailDlg::SetupAcctReplFormat()
{
   // Changes the labels to reflect pertinent information when copying accounts
   UpdateData(TRUE);
   if ( m_format != 1 )
   {
      m_ChangedLabel.LoadString(IDS_AccountCopiedLabel);
      m_UnchangedLabel.LoadString(IDS_AccountErrorsLabel);

      m_FilesLabelText.LoadString(IDS_AccountUsersLabel);
      m_DirectoryLabelText.LoadString(IDS_AccountGroupsLabel);
      m_SharesLabelText.LoadString(IDS_AccountComputersLabel);

      m_format = 1;
   }

   UpdateData(FALSE);
}

void CAgentDetailDlg::SetupFSTFormat()
{
   // Changes the labels to reflect pertinent information when translating security
   UpdateData(TRUE);
   if ( m_format != 0 )
   {
      if ( m_bGatheringInfo )
      {
         m_ChangedLabel.LoadString(IDS_Affected);
         m_UnchangedLabel.LoadString(IDS_Unaffected);
      }
      else
      {
         m_ChangedLabel.LoadString(IDS_ChangedLabel);
         m_UnchangedLabel.LoadString(IDS_UnchangedLabel);
      }
      m_FilesLabelText.LoadString(IDS_FilesLabel);
      m_DirectoryLabelText.LoadString(IDS_DirectoriesLabel);
      m_SharesLabelText.LoadString(IDS_SharesLabel);
      m_format = 0;
   }
   UpdateData(FALSE);
}

void CAgentDetailDlg::SetupESTFormat()
{
   // Changes the labels to reflect pertinent information when translating exchange security
   UpdateData(TRUE);
   if ( m_format != 2 )
   {
      m_ChangedLabel.LoadString(IDS_ChangedLabel);
      m_UnchangedLabel.LoadString(IDS_UnchangedLabel);
      m_FilesLabelText.LoadString(IDS_MailboxesLabel);
      m_DirectoryLabelText.LoadString(IDS_ContainersLabel);
      m_SharesLabelText.Empty();

      m_format = 2;
   }
   UpdateData(FALSE);

}

void CAgentDetailDlg::SetupOtherFormat()
{
  // Changes the labels to reflect pertinent information when translating exchange security
   UpdateData(TRUE);
   if ( m_format != -1 )
   {
      m_ExaminedLabel.Empty();
      m_ChangedLabel.Empty();
      m_UnchangedLabel.Empty();
      m_FilesLabelText.Empty();
      m_DirectoryLabelText.Empty();
      m_SharesLabelText.Empty();

      m_FilesExamined.Empty();
      m_DirectoriesExamined.Empty();
      m_SharesExamined.Empty();
      m_FilesChanged.Empty();
      m_DirectoriesChanged.Empty();
      m_SharesChanged.Empty();
      m_FilesUnchanged.Empty();
      m_DirectoriesUnchanged.Empty();
      m_SharesUnchanged.Empty();

      m_format = -1;
   }
   UpdateData(FALSE);
}


void CAgentDetailDlg::OnRefresh() 
{
   DWORD                     rc = 0;
   HRESULT                   hr = S_OK;
   WCHAR                   * sBinding = NULL;
   IUnknown                * pUnk = NULL;
   IVarSetPtr                pVarSet;
   _bstr_t                   jobID;

   try { 
   if ( m_pNode )
   {
      jobID = m_pNode->GetJobID();
   }
   else
   {
      jobID = m_JobGuid; 
   }

   m_AgentAlive = FALSE;
   m_StatusUnknown = FALSE;
   
   UpdateData(TRUE);
   
   if ( m_pAgent == NULL )
   {
      if ( m_pNode )
      {
   
         WCHAR                server[40];
         server[0] = L'\\';
         server[1] = L'\\';
         UStrCpy(server+2,m_pNode->GetServer());
         rc = EaxBindCreate(server,&m_hBinding,&sBinding,TRUE);
         if ( ! rc )
         {
            if ( ! m_bCoInitialized )
            {
               hr = CoInitialize(NULL);
               m_bCoInitialized = TRUE;
            }
            if ( SUCCEEDED(hr) )
            {
               pUnk = NULL;
               rc = DoRpcQuery(m_hBinding,&pUnk);
            }
            else
            {
               rc = hr;
            }
            if ( (!rc) && pUnk )
            {
               try {
                  m_pAgent = pUnk;
               }
               catch(_com_error * e)
               {
                  m_StatusUnknown = TRUE;

				  // if not auto closing display message box

                  if (!m_bAutoClose)
                  {
                     MessageBox(e->Description());
                  }
               }
               catch(...)
               {
                  pUnk = NULL;
               }
               if ( pUnk )
                  pUnk->Release();
            }
            else
            {
               if ( rc == RPC_S_SERVER_UNAVAILABLE )
               {
                  m_Status.LoadString(IDS_AgentNotRunning);   
               }
               else if ( rc == E_NOTIMPL )
               {
                  m_StatusUnknown = TRUE;
                  m_Status.LoadString(IDS_CantMonitorOnNt351);
               }
               else
               {
                  m_StatusUnknown = TRUE;
                  m_Status.LoadString(IDS_CannotConnectToAgent);
               }
            }
         }
         else
         {
            m_StatusUnknown = TRUE;
            m_Status.LoadString(IDS_RPCBindFailed);
         }
         if ( m_StatusUnknown || rc )
         {
            // if we couldn't connect to the agent, check to see if there is a result file 
            // we can get our data from instead
            if ( m_pNode->IsFinished() && *m_pNode->GetJobFile() )
            {
               DetailStats   detailStats;
               WCHAR         directory[MAX_PATH];
               WCHAR         filename[MAX_PATH];
               CString       plugInText;

               gData.GetResultDir(directory);
               
               memset(&detailStats,0,(sizeof detailStats));

               swprintf(filename,GET_STRING(IDS_AgentResultFileFmt),m_pNode->GetJobFile());

               if ( SUCCEEDED(CoInitialize(NULL)) )
               {
                  if ( ReadResults(m_pNode,directory,filename,&detailStats,plugInText,FALSE) )
                  {
                     SetStats(&detailStats);
                     SetPlugInText(plugInText);
                     bDetailDone = TRUE;
                     GetDlgItem(IDC_BTNREFRESH)->EnableWindow(FALSE);
                     GetDlgItem(IDC_EDIT2)->EnableWindow(FALSE);
                     GetDlgItem(IDC_REFRESH_LABEL)->EnableWindow(FALSE);
                     GetDlgItem(IDC_STOPAGENT)->EnableWindow(FALSE);
                     // the agent has finished, show files, directories, and shares
                     m_FilesExamined.Format(L"%ld",m_pStats->filesExamined);
                     m_FilesChanged.Format(L"%ld",m_pStats->filesChanged);
                     m_FilesUnchanged.Format(L"%ld",m_pStats->filesUnchanged);

                     m_DirectoriesExamined.Format(L"%ld",m_pStats->directoriesExamined);
                     m_DirectoriesChanged.Format(L"%ld",m_pStats->directoriesChanged);
                     m_DirectoriesUnchanged.Format(L"%ld",m_pStats->directoriesUnchanged);

                     m_SharesExamined.Format(L"%ld",m_pStats->sharesExamined);
                     m_SharesChanged.Format(L"%ld",m_pStats->sharesChanged);
                     m_SharesUnchanged.Format(L"%ld",m_pStats->sharesUnchanged);

                     m_Status.LoadString(IDS_StatusCompleted);

                     if ( m_PlugInText.GetLength() )
                     {
                        // Permanently hide the plug-in button, because our plug-ins don't 
                        // show any useful text.
                        // m_PlugInButton.ShowWindow(SW_SHOW);
                     }
                     UpdateData(FALSE);
                  }

                  CoUninitialize();
               }
            }
         }
      }
      else
      {
         // local agent
         if ( ! m_bCoInitialized )
         {
            hr = CoInitialize(NULL);
            m_bCoInitialized = TRUE;
         }
         if ( SUCCEEDED(hr) )
         {
            hr = m_pAgent.GetActiveObject(CLSID_DCTAgent);

            if ( FAILED(hr) )
            {
               if ( hr == MK_E_UNAVAILABLE ) 
               {
                  m_Status.LoadString(IDS_AgentNotRunning);
               }
               else
               {
                  m_Status.FormatMessage(IDS_NoActiveAgent,hr);
               }
            }
         }
      }
   }
   if ( m_pAgent != NULL )
   {
      hr = m_pAgent->raw_QueryJobStatus(jobID,&pUnk);
      if ( SUCCEEDED(hr) && pUnk )
      {
         m_AgentAlive = TRUE;
         pVarSet = pUnk;
         pUnk->Release();
         _bstr_t text = pVarSet->get(GET_BSTR(DCTVS_JobStatus));
         m_Status = (LPCWSTR)text;
         text = pVarSet->get(GET_BSTR(DCTVS_CurrentPath));
         m_Current = (LPCWSTR)text;
         text = pVarSet->get(GET_BSTR(DCTVS_CurrentOperation));
         m_Operation = (LPCWSTR)text;
         // Get the stats
         LONG                num1,num2,num3,num4;
         UpdateData(FALSE);
         if ( !UStrICmp(m_Operation,GET_STRING(IDS_ACCT_REPL_OPERATION_TEXT)) )
         {
            // Set up the labels for account replication
            SetupAcctReplFormat();
         }
         else if ( !UStrICmp(m_Operation,GET_STRING(IDS_FST_OPERATION_TEXT)) )
         {
            SetupFSTFormat();
         }
         else if ( ! UStrICmp(m_Operation,GET_STRING(IDS_EST_OPERATION_TEXT)) )
         {
            SetupESTFormat();
         }  
         else
         {
            if ( m_Current.GetLength() && 
               ( _wtoi(m_FilesExamined) + _wtoi(m_DirectoriesExamined) + _wtoi(m_SharesExamined)) == 0 )
            {
               // unless some stats have already been collected, hide the stats, if the operation
               // is not one that we have detailed stats for.
               SetupOtherFormat();
            }
         }
         switch ( m_format )
         {
            

         case 0:  // FST
            
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Changed));
            m_FilesExamined.Format(L"%ld",num1);
            if ( ! m_bGatheringInfo )
            {
               m_FilesChanged.Format(L"%ld",num2);
               m_FilesUnchanged.Format(L"%ld",num1-num2);
            }
            else
            {
               m_FilesChanged.Empty();
               m_FilesUnchanged.Empty();
            }
            
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Changed));
            m_DirectoriesExamined.Format(L"%ld",num1);
            if ( ! m_bGatheringInfo )
            {
               m_DirectoriesChanged.Format(L"%ld",num2);
               m_DirectoriesUnchanged.Format(L"%ld",num1-num2);  
            }
            else
            {
               m_DirectoriesChanged.Empty();
               m_DirectoriesUnchanged.Empty();  
            }
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Changed));
            m_SharesExamined.Format(L"%ld",num1);
            if ( ! m_bGatheringInfo )
            {
               m_SharesChanged.Format(L"%ld",num2);
               m_SharesUnchanged.Format(L"%ld",num1-num2);
            }
            else
            {
               m_SharesChanged.Empty();
               m_SharesUnchanged.Empty();
            }
            break;
         case 1: // AcctRepl
            // files = user accounts
            // dirs  = global groups + local groups
            // shares = computer accounts
            // examined = processed
            // changed = created + replaced
            // unchanged = errors
            // User stats
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Created));
            num3 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Replaced));
            num4 = pVarSet->get(GET_BSTR(DCTVS_Stats_Users_Errors));
            
            m_FilesExamined.Format(L"%ld",num1);
            m_FilesChanged.Format(L"%ld",num2+num3);
            m_FilesUnchanged.Format(L"%ld",num4);
            
            // Global group stats
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Created));
            num3 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Replaced));
            num4 = pVarSet->get(GET_BSTR(DCTVS_Stats_GlobalGroups_Errors));
            // local group stats
            LONG                 num5, num6,num7, num8;

            num5 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Examined));
            num6 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Created));
            num7 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Replaced));
            num8 = pVarSet->get(GET_BSTR(DCTVS_Stats_LocalGroups_Errors));
            
            m_DirectoriesExamined.Format(L"%ld",num1 + num5);
            m_DirectoriesChanged.Format(L"%ld",num2+num3 + num6+num7);
            m_DirectoriesUnchanged.Format(L"%ld",num4 + num8);
            
            // computer account stats
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Created));
            num3 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Replaced));
            num4 = pVarSet->get(GET_BSTR(DCTVS_Stats_Computers_Errors));
            
            m_SharesExamined.Format(L"%ld",num1);
            m_SharesChanged.Format(L"%ld",num2+num3);
            m_SharesUnchanged.Format(L"%ld",num4);
            break;         
         case 2:  // EST
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Mailboxes_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Mailboxes_Changed));
            
            m_FilesExamined.Format(L"%ld",num1);
            m_FilesChanged.Format(L"%ld",num2);
            m_FilesUnchanged.Format(L"%ld",num1-num2);
            
            num1 = pVarSet->get(GET_BSTR(DCTVS_Stats_Containers_Examined));
            num2 = pVarSet->get(GET_BSTR(DCTVS_Stats_Containers_Changed));
            
            m_DirectoriesExamined.Format(L"%ld",num1);
            m_DirectoriesChanged.Format(L"%ld",num2);
            m_DirectoriesUnchanged.Format(L"%ld",num1-num2);  
   
            m_SharesExamined.Empty();
            m_SharesChanged.Empty();
            m_SharesUnchanged.Empty();
            break;

         case -1:  // default (empty)
            m_FilesExamined.Empty();
            m_FilesChanged.Empty();
            m_FilesUnchanged.Empty();
            m_DirectoriesExamined.Empty();
            m_DirectoriesChanged.Empty();
            m_DirectoriesUnchanged.Empty();
            m_SharesExamined.Empty();
            m_SharesChanged.Empty();
            m_SharesUnchanged.Empty();
            break;

         }
      }
      else
      {
         if ( hr == DISP_E_UNKNOWNNAME )
         {
            m_StatusUnknown = TRUE;
            m_Status.FormatMessage(IDS_AgentJobNotFound,(WCHAR*)jobID);
         }
         else if ( hr == HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE) )
         {
            m_Status.LoadString(IDS_AgentNoLongerRunning);
         }
         else
         {
            m_StatusUnknown = TRUE;
            m_Status.FormatMessage(IDS_QueryJobStatusFailed,hr);
         }
      }
   }
   }
   catch ( ... )
   {
      m_StatusUnknown = TRUE;
      m_Status.FormatMessage(IDS_ExceptionConnectingToAgent);
      //m_Current = step;
   }
   if ( m_PlugInText.GetLength() )
   {
      // permanently hide the plug-in button, because our plug-ins 
      // don't show any useful text
      //m_PlugInButton.ShowWindow(SW_SHOW);
   }
      //get the job log file when agent is done
   if ((!m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed))) && (m_pNode))
      SetLogFile(m_pNode->GetLogPath());   

   if ( m_LogFile.GetLength() )
   {
      m_ViewLogButton.ShowWindow(SW_SHOW);
      if ( ! m_AgentAlive || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed)) )
      {

         m_ViewLogButton.EnableWindow(TRUE);
      }
      else
      {
         m_ViewLogButton.EnableWindow(FALSE);
      }
   }
   else
   {
      m_ViewLogButton.ShowWindow(SW_HIDE);
   }
   if ( ! m_AgentAlive || !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed)) )
   {
      // Disable the refresh button when the status changes to Completed.
      if ( !m_Status.CompareNoCase(GET_STRING(IDS_DCT_Status_Completed)) )
      {
         if ( GetDefID() == IDC_BTNREFRESH ) 
         {
            SetDefID(IDOK);
         }
         m_RefreshButton.EnableWindow(FALSE);
      }
      // disable the stop agent button any time the agent is not running
      m_StopAgentButton.EnableWindow(FALSE);

         //enable the close button any time the agent is not running
      m_OKButton.EnableWindow(TRUE);

	  // if auto closing dialog

      if (m_bAutoClose)
      {
         OnOK();
      }
   }
   else
   {
      // enable the refresh and stop agent buttons when the agent is alive and running
      m_RefreshButton.EnableWindow(TRUE);
      m_StopAgentButton.EnableWindow(TRUE);
   }
   UpdateData(FALSE);
}

void CAgentDetailDlg::OnOK() 
{
   UpdateData(TRUE);

   if (!m_bAutoClose)
   {
      CString        str;
      CString        title;

      str = GET_STRING(IDS_DCT_Status_InProgress);
      title.LoadString(IDS_MessageTitle);

      if ( ! m_hBinding )  // only show the warning for the local agent
      {
         if ( str == m_Status )
         {
            str.LoadString(IDS_CannotCloseWhileAgentIsRunning);
            MessageBox(str,title,MB_ICONHAND | MB_OK);
            return;
         }
      }
   }

   bDetailDone = TRUE;

   if ( m_pAgent )
   {
      m_pAgent = NULL;
      CoUninitialize();
   }

   CDialog::OnOK();
}

void CAgentDetailDlg::OnChangeEdit2() 
{
	UpdateData(TRUE);
   detailInterval = _wtoi(m_RefreshRate);
   if ( detailInterval <= 0 )
   {
      detailInterval = 1;
   }
}

LRESULT CAgentDetailDlg::DoRefresh(UINT nID, long x)
{
   OnRefresh();
   return 0;
}
   
DWORD DoRpcShutdown(HANDLE hBinding, DWORD flags)
{
   DWORD                rc = 0;

   RpcTryExcept
   {
      rc = EaxcShutdown(hBinding,flags);
   }
   RpcExcept(1)
   {
      rc = RpcExceptionCode();
   }
   RpcEndExcept
   
   return rc;
}

void CAgentDetailDlg::OnStopAgent() 
{
   DWORD                     rc = 0;
   HRESULT                   hr = S_OK;
   CString                   message;
   CString                   title;


   title.LoadString(IDS_MessageTitle);

   if ( m_hBinding )
   {
      message.LoadString(IDS_ConfirmStopAgent);
      if ( MessageBox(message,title,MB_ICONQUESTION | MB_YESNO) == IDYES )
      {
         _bstr_t             jobID = m_pNode->GetJobID();

         if ( m_pAgent )
         {
            hr = m_pAgent->raw_CancelJob(jobID);
            m_pAgent = NULL;
         }
         else
         {
            message.LoadString(IDS_AgentNotRunning);
            MessageBox(message,NULL,MB_OK);
         }
         if ( SUCCEEDED(hr) )
         {
            //m_AgentAlive = FALSE;
            //rc = DoRpcShutdown(m_hBinding,0);
         }
         else
         {
            message.FormatMessage(IDS_CancelJobFailed,hr);
            MessageBox(message,NULL,MB_ICONERROR | MB_OK);
         }
         if ( rc )
         {
            message.FormatMessage(IDS_StopAgentFailed,rc);
            MessageBox(message,NULL,MB_ICONERROR|MB_OK);
         }
         if ( SUCCEEDED(hr) && !rc )
         {
            OnOK();
         }
      }
   }
   else
   {
      // Local agent here
      if ( m_pAgent )
      {
         message.LoadString(IDS_ConfirmCancelJob);
         if ( MessageBox(message,NULL,MB_ICONQUESTION | MB_YESNO) == IDYES )
         {
            hr = m_pAgent->raw_CancelJob(m_JobGuid);
            if  ( FAILED(hr) )
            {
               message.FormatMessage(IDS_StopAgentFailedHexResult,hr);
               MessageBox(message,NULL,MB_ICONERROR | MB_OK);
            }
 			else
			{
		 	   gbCancelled = TRUE;
			}
        }
      }
      else
      {
         // TODO:error message
      }
   }
   
}

void CAgentDetailDlg::OnViewLog() 
{
   UpdateData(TRUE);
   if ( ! m_LogFile.IsEmpty() )
   {
      // Launch the logfile
      CString                   cmd;
      STARTUPINFO				     startupInfo;
	   PROCESS_INFORMATION		  processInfo;

      memset(&startupInfo,0,(sizeof startupInfo));
   
      startupInfo.cb = (sizeof startupInfo);

      cmd.FormatMessage(IDS_NotepadCommandLine,m_LogFile);

      CreateProcess(NULL,cmd.GetBuffer(0),NULL,NULL,TRUE,0,NULL,NULL,&startupInfo,&processInfo);
   }
}

void CAgentDetailDlg::OnPlugInResults() 
{
   UpdateData(TRUE);
   MessageBox(m_PlugInText);	
}

void CAgentDetailDlg::OnClose() 
{
	UpdateData(TRUE);
   CString        str;
   CString        title;

   str = GET_STRING(IDS_DCT_Status_InProgress);
   title.LoadString(IDS_MessageTitle);

   if ( ! m_hBinding )  // only show the warning for the local agent
   {
      if ( str == m_Status )
      {
         str.LoadString(IDS_ConfirmCloseWhileAgentIsRunning);
         if ( IDYES != MessageBox(str,title,MB_ICONQUESTION | MB_YESNO) )
            return;
      }
   }
   bDetailDone = TRUE;
   if ( m_pAgent )
   {
      m_pAgent = NULL;
      CoUninitialize();
   }
	
	CDialog::OnClose();
}

BOOL CAgentDetailDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
	// TODO: Add your specialized code here and/or call the base class
	TRACE(L"Command(%lx,%lx)\n",wParam,lParam);
	if ( wParam == WM_DESTROY )
   {
      CString        str;
      CString        title;
      CString        str2;

      str = GET_STRING(IDS_DCT_Status_InProgress);
      str2 = GET_STRING(IDS_DCT_Status_NotStarted);
      title.LoadString(IDS_MessageTitle);

      if ( ! m_hBinding )  // only show the warning for the local agent
      {
         if ( str == m_Status )
         {
            str.LoadString(IDS_ConfirmCloseWhileAgentIsRunning);
            if ( IDYES != MessageBox(str,title,MB_ICONQUESTION | MB_YESNO) )
               return 0;
         }
      }
      bDetailDone = TRUE;
      if ( m_pAgent )
      {
         m_pAgent = NULL;
         CoUninitialize();
      }
      return CDialog::OnCommand(wParam, lParam);

	}
   else
   {
      return CDialog::OnCommand(wParam, lParam);
   }
}


// OnNcPaint Handler
//
// This handler is being overridden to handle hiding of the dialog.
// This prevents initial painting of the dialog which causes a flash
// if the dialog is hidden after this message. This is the first message
// where the dialog can be hidden. Trying to hide the dialog before this
// point gets overridden.

void CAgentDetailDlg::OnNcPaint() 
{
	if (m_bAutoHide)
	{
		if (IsWindowVisible())
		{
			ShowWindow(SW_HIDE);
		}
	}
	else
	{
		CDialog::OnNcPaint();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\fparse.hpp ===
#ifndef __FILEPARSER_HPP__
#define __FILEPARSER_HPP__
/*---------------------------------------------------------------------------
  File: FileParser.hpp

  Comments: Classes to parse text files generated by the Domain Admin dispatcher and agent.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 15:16:31

 ---------------------------------------------------------------------------
*/

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include "ServList.hpp"




#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)


class TFileParser
{
protected:
   FILE                    * m_pFile;
   WCHAR                     m_filename[MAX_PATH];
   BOOL                      m_bValidData;        
public:
   TFileParser()
   {
      m_filename[0] = 0;
      m_pFile = NULL;
      m_bValidData = FALSE;
   }
   ~TFileParser()
   {
      if ( m_pFile )
         fclose(m_pFile);
   }

   BOOL Open(WCHAR const * filename)
   {
      safecopy(m_filename,filename);
      
      if ( *m_filename )
      {
         m_pFile = _wfopen(m_filename,L"rb");
      }
      else
      {
         m_pFile = 0;
      }
   
      return ( m_pFile != 0 );
   }

   BOOL IsOpen() { return ( m_pFile != 0 ); }
   void Close() { if ( m_pFile ) { fclose(m_pFile); m_pFile = NULL; } }
   BOOL IsEof() { return m_pFile ? feof(m_pFile) : TRUE; }
   BOOL Restart() 
   { 
      BOOL                   bRc = FALSE;
      if ( m_pFile ) 
      { 
         bRc = ( fseek(m_pFile,0,SEEK_SET) == 0 );
      }
      return bRc;
   }
   virtual BOOL ScanEntry() = 0;
};

class TErrorLogParser:public TFileParser
{
   int                       m_Severity;
   int                       m_SourceLine;         // 
   WCHAR                     m_Timestamp[100];     // the timestamp of the entry
   WCHAR                     m_Message[1000];      // the message text part of the entry
   WCHAR                     m_strBuf[1000];       // a line from the log file
public:                                         
   virtual BOOL ScanEntry() 
   { 
      MCSASSERT(m_pFile);
      m_bValidData = FALSE;
      if ( m_pFile && fgetws(m_strBuf,1000,m_pFile) )
      {
         m_bValidData = ScanFileEntry(m_strBuf,m_Timestamp,&m_Severity,&m_SourceLine,m_Message);
            
      }
      return m_bValidData;
   }
   
   int GetSeverity() { MCSASSERT(m_bValidData); return m_Severity; }
   int GetSourceLine() { MCSASSERT(m_bValidData); return m_SourceLine; }
   WCHAR const * GetTimestamp() { MCSASSERT(m_bValidData); return m_Timestamp; }
   WCHAR const * GetMessage() { MCSASSERT(m_bValidData); return m_Message; }
protected:
   BOOL 
   ScanFileEntry(
      WCHAR                * string,      // in - line from TError log file
      WCHAR                * timestamp,   // out- timestamp from this line
      int                  * pSeverity,   // out- severity level of this message
      int                  * pSourceLine, // out- the source line for this message
      WCHAR                * msgtext      // out- the textual part of the message
   );

};

class TAcctReplStatusFileParser: public TFileParser
{
   WCHAR                    m_sourceAccount[LEN_Account];
   WCHAR                    m_targetAccount[LEN_Account];
   DWORD                    m_sourceRid;
   DWORD                    m_targetRid;
   DWORD                    m_accountType;
   DWORD                    m_status;
public:
   virtual BOOL ScanEntry()
   {
      m_bValidData = FALSE;
      MCSASSERT(m_pFile);
      if ( m_pFile && fwscanf(m_pFile,L"%[^,],%[^,],%lx,%lx,%lx,%lx\r\n",
                           m_sourceAccount,
                           m_targetAccount,
                           &m_accountType,
                           &m_status,
                           &m_sourceRid,
                           &m_targetRid)   == 6 )
      {
         m_bValidData = TRUE;
      }
      return m_bValidData;
   }
   WCHAR const * GetSource() { MCSASSERT(m_bValidData); return m_sourceAccount; }
   WCHAR const * GetTarget() { MCSASSERT(m_bValidData); return m_targetAccount; }
   DWORD     GetSourceRid() { MCSASSERT(m_bValidData); return m_sourceRid;}
   DWORD     GetTargetRid() { MCSASSERT(m_bValidData); return m_targetRid;}
   DWORD        GetStatus() { MCSASSERT(m_bValidData); return m_status; }
   DWORD     GetAccountType() { MCSASSERT(m_bValidData); return m_accountType;}
   
};

class TAccountStatFileParser: public TFileParser
{
   WCHAR                     m_account[LEN_Account];
   DWORD                     m_owners;
   DWORD                     m_groups;
   DWORD                     m_daces;
   DWORD                     m_saces;
public:
   virtual BOOL ScanEntry()
   {
      m_bValidData = FALSE;
      MCSASSERT(m_pFile);
      if ( m_pFile && fwscanf(m_pFile,L"%[^,],%ld,%ld,%ld,%ld\r\n",m_account,&m_owners,&m_groups,&m_daces,&m_saces) == 5 )
      {
         m_bValidData = TRUE;
      }
      return m_bValidData;
   }

   WCHAR const * GetAccount() { MCSASSERT(m_bValidData); return m_account; }
   DWORD GetOwners() { MCSASSERT(m_bValidData); return m_owners;}
   DWORD GetGroups() { MCSASSERT(m_bValidData); return m_groups; }
   DWORD GetDACEs() { MCSASSERT(m_bValidData); return m_daces; }
   DWORD GetSACEs() { MCSASSERT(m_bValidData); return m_saces; }
};


void ParseInputFile(WCHAR const * gLogFile);

void 
   ReadResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename,
      WCHAR          const * dbName
   );


#endif //__FILEPARSER_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mapiutil\ustring.hpp ===
//#pragma title( "UString.hpp - Common string and character functions" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  UString.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-08-25
Description -  Common string and character functions.
      Many string and character functions defined in "string.h" are redefined
         here as overloaded inline functions with several extensions:
      o  Both ANSI and UNICODE strings are supported.
      o  Both ANSI and UNICODE characters are supported.
      o  For ANSI, characters can be "char signed" or "char unsigned".
      o  Functions that allow a length field, such as "lstrcpy" vs "lstrcpyn",
         are implemented as overloaded functions with optional arguments.
      o  Some functions, UStrCpy in particular, can perform conversion between
         ANSI and UNICODE strings.
      The function names defined here consist of "U" concatenated to the base
         name from "string.h".  The first letter of words or word abbreviations
         are capitalized, e.g. "strcpy" becomes "UStrCpy".
Updates     -
===============================================================================
*/

#ifndef  MCSINC_UString_hpp
#define  MCSINC_UString_hpp

#define safecopy(trg,src) (UStrCpy(trg,src,DIM(trg)))

#ifdef  WIN16_VERSION
   #ifndef  UCHAR
      #define  UCHAR  unsigned char
   #endif

   #include <string.h>
   #include <ctype.h>
#endif  // WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      char           const * s1            // in -ANSI string
   )
{
   return strlen( s1 );
}


int _inline                                // ret-length in chars
   UStrLen(
      UCHAR          const * s1            // in -ANSI string
   )
{
   return strlen( (char const *) s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   strcpy( aTarget, aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, aSource );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      strncpy( aTarget, aSource, copylen );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( aTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, aSource, len );
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, (char const *) aSource, len );
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return strcmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrCmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strncmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         0,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2            // in -ANSI string 2
   )
{
#ifdef WIN16_VERSION
   return stricmp( (char const *) s1, (char const *) s2 );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         -1,
         (char const *) s2,
         -1 ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      char           const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      char           const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         s2,
         len ) - 2;
#endif
}

int _inline                                // ret-compare result
   UStrICmp(
      UCHAR          const * s1           ,// in -ANSI string 1
      UCHAR          const * s2           ,// in -ANSI string 2
      int                    len           // in -compare length in chars
   )
{
#ifdef WIN16_VERSION
   return strnicmp( (char const *) s1, (char const *) s2, len );
#else
   return CompareStringA(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         (char const *) s1,
         len,
         (char const *) s2,
         len ) - 2;
#endif
}

char _inline *
   UStrLwr(
      char                 * s             // i/o-ANSI string
   )
{
   return strlwr( s );
}

UCHAR _inline *
   UStrLwr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strlwr( (char *) s );
}

char _inline *
   UStrUpr(
      char                 * s             // i/o-ANSI string
   )
{
   return strupr( s );
}

UCHAR _inline *
   UStrUpr(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return (UCHAR *) strupr( (char *) s );
}

char _inline
   UToLower(
      char                   c             // in -ANSI char
   )
{
   return tolower( c );
}

UCHAR _inline
   UToLower(
      UCHAR                  c             // in -ANSI char
   )
{
   return tolower( (char) c );
}

char _inline
   UToUpper(
      char                   c             // in -ANSI char
   )
{
   return toupper( c );
}

UCHAR _inline
   UToUpper(
      UCHAR                  c             // in -ANSI char
   )
{
   return toupper( (char) c );
}

// Left-trim string in place
_inline UCHAR *
   LTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strorg = s;

   while ( *strorg == ' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

_inline char *
   LTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) LTrim( (UCHAR *) s );
}

// Right-trim string in place
_inline UCHAR *
   RTrim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   UCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == ' ') )
      strend--;
   *strend = '\0';
   return s;
}

_inline char *
   RTrim(
      char                 * s             // i/o-ANSI string
   )
{
   return (char *) RTrim( (UCHAR *) s );
}

// Trim string in place
_inline UCHAR *
   Trim(
      UCHAR                * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

_inline char *
   Trim(
      char                 * s             // i/o-ANSI string
   )
{
   return LTrim( RTrim( s ) );
}

#ifndef  WIN16_VERSION

int _inline                                // ret-length in chars
   UStrLen(
      WCHAR          const * s1            // in -UNICODE string
   )
{
   return lstrlenW( s1 );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   UStrCpy( (char *) aTarget, wSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource       // in -ANSI source string
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource       // in -ANSI source string
   )
{
   UStrCpy( wTarget, (char const *) aSource );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource       // in -UNICODE source string
   )
{
   lstrcpyW( wTarget, wSource );
}

void _inline
   UStrCpy(
      char                 * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      WideCharToMultiByte( CP_ACP, 0, wSource, copylen, aTarget, copylen, NULL, NULL );
      aTarget[copylen-1] = '\0';
   }
}

void _inline
   UStrCpy(
      UCHAR                * aTarget      ,// out-ANSI target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( (char *) aTarget, wSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      char           const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( aSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, aSource, copylen, wTarget, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      UCHAR          const * aSource      ,// in -ANSI source string
      int                    len           // in -copy length in chars
   )
{
   UStrCpy( wTarget, (char const *) aSource, len );
}

void _inline
   UStrCpy(
      WCHAR                * wTarget      ,// out-UNICODE target string
      WCHAR          const * wSource      ,// in -UNICODE source string
      int                    len           // in -copy length in chars
   )
{
   int                       copylen = UStrLen( wSource ) + 1;

   copylen = min( copylen, len );

   if ( copylen )
   {
      lstrcpynW( wTarget, wSource, copylen );
      wTarget[copylen-1] = L'\0';
   }
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcscmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrCmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         0,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsncmp( s1, s2, len );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2            // in -UNICODE string 2
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         -1,
         s2,
         -1 ) - 2;
// return wcsicmp( s1, s2 );
}

int _inline                                // ret-compare result
   UStrICmp(
      WCHAR          const * s1           ,// in -UNICODE string 1
      WCHAR          const * s2           ,// in -UNICODE string 2
      int                    len           // in -compare length in chars
   )
{
   return CompareStringW(
         LOCALE_SYSTEM_DEFAULT,
         NORM_IGNORECASE,
         s1,
         len,
         s2,
         len ) - 2;
// return wcsnicmp( s1, s2, len );
}

WCHAR _inline *
   UStrLwr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcslwr( s );
}

WCHAR _inline *
   UStrUpr(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return wcsupr( s );
}

WCHAR _inline
   UToLower(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towlower( c );
}

WCHAR _inline
   UToUpper(
      WCHAR                  c             // in -UNICODE char
   )
{
   return towupper( c );
}

// Left-trim string in place
_inline WCHAR *
   LTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strorg = s;

   while ( *strorg == L' ' )
      strorg++;
   if ( strorg > s )
   {
      while ( *(strorg-1) )
         *s++ = *strorg++;
   }
   return s;
}

// Right-trim string in place
_inline WCHAR *
   RTrim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   WCHAR                   * strend = s + UStrLen(s);

   while ( (strend > s) && (*(strend-1) == L' ') )
      strend--;
   *strend = L'\0';
   return s;
}

// Trim string in place
_inline WCHAR *
   Trim(
      WCHAR                * s             // i/o-UNICODE string
   )
{
   return LTrim( RTrim( s ) );
}

char * _cdecl                             // ret-target string
   UStrJoin(
      char                 * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      char const           * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

WCHAR * _cdecl                            // ret-target string
   UStrJoin(
      WCHAR                * target      ,// out-target string
      size_t                 sizeTarget  ,// in -maximum size of target in chars
      WCHAR const          * source1     ,// in -first source string or NULL
      ...                                 // in -remainder of source strings
   );

#endif  // WIN16_VERSION

#endif  // MCSINC_UString_hpp

// UString.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\detdlg.h ===
#if !defined(AFX_AGENTDETAIL_H__E50B8967_D321_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_AGENTDETAIL_H__E50B8967_D321_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AgentDetail.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAgentDetail dialog
#include "resource.h"
#include "ServList.hpp"
#include "Globals.h"

class CAgentDetailDlg : public CDialog
{
// Construction
public:
	CAgentDetailDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAgentDetailDlg)
	enum { IDD = IDD_DETAILS };
	CButton	m_StopAgentButton;
	CButton	m_RefreshButton;
	CButton	m_ViewLogButton;
	CButton	m_PlugInButton;
	CButton	m_OKButton;
	CStatic	m_UnchangedLabelStatic;
	CStatic	m_SharesStatic;
	CStatic	m_FilesStatic;
	CStatic	m_ExaminedStatic;
	CStatic	m_DirStatic;
	CStatic	m_ChangedStatic;
	CString	m_Current;
	CString	m_Stats;
	CString	m_Status;
   CString  m_FilesChanged;
   CString  m_FilesExamined;
   CString  m_FilesUnchanged;
   CString  m_DirectoriesChanged;
   CString  m_DirectoriesExamined;
   CString  m_DirectoriesUnchanged;
   CString  m_SharesChanged;
   CString  m_SharesExamined;
   CString  m_SharesUnchanged;
	CString	m_DirectoryLabelText;
	CString	m_FilesLabelText;
	CString	m_Operation;
	CString	m_SharesLabelText;
	CString	m_ChangedLabel;
	CString	m_ExaminedLabel;
	CString	m_UnchangedLabel;
	CString	m_RefreshRate;
	//}}AFX_DATA
   CString  m_ServerName;
   CString  m_LogFile;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAgentDetailDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

   public:
      void SetNode(TServerNode * p) { m_pNode = p; }
      void SetJobID(WCHAR const * job) { m_JobGuid = job; }
      BOOL IsAgentAlive() { return m_AgentAlive; }
      BOOL IsStatusUnknown() { return m_StatusUnknown; }
      void SetStats(DetailStats * pStats) { m_pStats = pStats; }
      void SetPlugInText(CString pText) { m_PlugInText = pText; }
      void SetFormat(int format) { m_format = format;    }
      void SetRefreshInterval(int  interval) { m_RefreshRate.Format(L"%ld",interval); }
      void SetLogFile(CString file) { m_LogFile = file; }
      void SetGatheringInfo(BOOL bValue) { m_bGatheringInfo = bValue;}
      void SetAutoCloseHide(int nValue)
      {
         switch (nValue)
         {
            case 2:
               m_bAutoHide = TRUE;
               m_bAutoClose = TRUE;
               break;
            case 1:
               m_bAutoHide = FALSE;
               m_bAutoClose = TRUE;
               break;
            default:
               m_bAutoHide = FALSE;
               m_bAutoClose = FALSE;
               break;
         }
      }
// Implementation
protected:
   IDCTAgentPtr        m_pAgent;
   TServerNode       * m_pNode;
	HANDLE              m_hBinding;
   _bstr_t             m_JobGuid;
   BOOL                m_bCoInitialized;
   int                 m_format;
   BOOL                m_AgentAlive;
   DetailStats       * m_pStats;
   CString             m_PlugInText;
   BOOL                m_StatusUnknown;
   BOOL                m_bGatheringInfo;
   BOOL                m_bAutoHide;
   BOOL                m_bAutoClose;
   BOOL				   m_bAlwaysEnableClose;
   // Generated message map functions
	//{{AFX_MSG(CAgentDetailDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnRefresh();
	virtual void OnOK();
	afx_msg void OnChangeEdit2();
	afx_msg void OnStopAgent();
	afx_msg void OnViewLog();
	afx_msg void OnPlugInResults();
	afx_msg void OnClose();
	afx_msg void OnNcPaint();
	//}}AFX_MSG
	
   LRESULT DoRefresh(UINT nID, long x);
   
   void SetupAcctReplFormat();
   void SetupFSTFormat();
   void SetupESTFormat();
   void SetupOtherFormat();
  DECLARE_MESSAGE_MAP()
};

DWORD DoRpcQuery(HANDLE hBinding,LPUNKNOWN * ppUnk);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AGENTDETAIL_H__E50B8967_D321_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\globals.h ===
#ifndef __GLOBALS_H__
#define __GLOBALS_H__
/*---------------------------------------------------------------------------
  File: ...

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:13:56

 ---------------------------------------------------------------------------
*/


#include "ServList.hpp"
#include "Monitor.h"
#include "TSync.hpp"

class GlobalData
{
   long                      m_LinesRead;          // number of lines of the dispatch log that have been processed
   WCHAR                     m_LogFile[MAX_PATH];  // full path of dispatch log
   WCHAR                     m_ReadableLogFile[MAX_PATH]; // full path of human-readable log file
   WCHAR                     m_ResultDir[MAX_PATH];// full path of results directory
   WCHAR                     m_ResultShare[MAX_PATH]; // sharename for results share
   WCHAR                     m_DatabasePath[MAX_PATH]; // full path of Access database to write resulting stats to
   WCHAR                     m_CacheFile[MAX_PATH]; // filename of FST cache file generated by dispatcher
   int                       m_IntervalSeconds;    // number of seconds for monitoring threads to wait between passes
   BOOL                      m_Done;               // monitoring threads should check this to see if they should stop
   BOOL                      m_ImportStats;        // indicates whether the monitor should write stats to a database
   BOOL                      m_bFirstPassDone;     // indicates whether we have made a first pass through the log file yet
   HWND                      m_ListWnd;            // handle to the server list window
   HWND                      m_SummaryWnd;         // handle to the summary window
   HWND                      m_DetailWnd;          // handle to the single-server detail window
   ComputerStats             m_ComputerStats;       // stats on number of computers in progress
   DetailStats               m_DetailStats;        // stats on total objects processed (by completed agents)
   TServerList               m_ServerList;         // list containing the  servers where the agent is being dispatched
   TCriticalSection          m_cs;           
   BOOL                      m_LogDone;            // indicates whether the dispatcher has finished writing to the log file
public:
   GlobalData() 
   {
      Initialize();
   }
   void Initialize()
   {
      m_cs.Enter();
      m_LinesRead = 0;
      m_LogFile[0] = 0;
      m_ReadableLogFile[0] = 0;
      m_ResultDir[0] = 0;
      m_ResultShare[0] = 0;
      m_DatabasePath[0] = 0;
      m_CacheFile[0] = 0;
      m_IntervalSeconds = 5;
      m_Done = FALSE;
      m_ImportStats = FALSE;
      m_bFirstPassDone = FALSE;
      m_ListWnd = NULL;
      m_SummaryWnd = NULL;
      m_DetailWnd = NULL;
      memset(&m_ComputerStats,0,sizeof m_ComputerStats);
      memset(&m_DetailStats,0,sizeof m_DetailStats);
      m_ServerList.Clear();
      m_LogDone = FALSE;
      m_cs.Leave();
   }

   void GetLinesRead(long * lines) { m_cs.Enter(); (*lines) = m_LinesRead; m_cs.Leave(); }
   void SetLinesRead(long lines) { m_cs.Enter(); m_LinesRead = lines; m_cs.Leave(); }

   void GetLogPath(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_LogFile); m_cs.Leave(); }
   void SetLogPath(WCHAR const * path) { m_cs.Enter(); safecopy(m_LogFile,path); m_cs.Leave(); }

   void GetReadableLogFile(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_ReadableLogFile); m_cs.Leave(); }
   void SetReadableLogFile(WCHAR const * path) { m_cs.Enter(); safecopy(m_ReadableLogFile,path); m_cs.Leave(); }
   
   void GetResultDir(WCHAR * dir) { m_cs.Enter(); UStrCpy(dir,m_ResultDir); m_cs.Leave() ; }
   void SetResultDir(WCHAR const * dir) { m_cs.Enter(); safecopy(m_ResultDir,dir); m_cs.Leave(); }

   void GetResultShare(WCHAR * share) { m_cs.Enter(); UStrCpy(share,m_ResultShare); m_cs.Leave() ; }
   void SetResultShare(WCHAR const * share) { m_cs.Enter(); safecopy(m_ResultShare,share); m_cs.Leave(); }

   void GetWaitInterval(long * interval) { m_cs.Enter(); (*interval) = m_IntervalSeconds; m_cs.Leave(); }
   void SetWaitInterval(long interval) { m_cs.Enter(); m_IntervalSeconds = interval; m_cs.Leave(); }

   void GetDone(BOOL * bDone) { m_cs.Enter(); (*bDone) = m_Done; m_cs.Leave(); }
   void SetDone(BOOL bDone) { m_cs.Enter(); m_Done = bDone; m_cs.Leave(); }

   void GetLogDone(BOOL * bDone) { m_cs.Enter(); (*bDone) = m_LogDone; m_cs.Leave(); }
   void SetLogDone(BOOL bDone) { m_cs.Enter(); m_LogDone = bDone; m_cs.Leave(); }

   void GetListWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_ListWnd; m_cs.Leave(); }
   void SetListWindow(HWND hWnd) { m_cs.Enter(); m_ListWnd = hWnd; m_cs.Leave(); }

   void GetSummaryWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_SummaryWnd; m_cs.Leave(); }
   void SetSummaryWindow(HWND hWnd) { m_cs.Enter(); m_SummaryWnd = hWnd; m_cs.Leave(); }

   void GetDetailWindow(HWND * hWnd) { m_cs.Enter(); (*hWnd) = m_DetailWnd; m_cs.Leave(); }
   void SetDetailWindow(HWND hWnd) { m_cs.Enter(); m_DetailWnd = hWnd; m_cs.Leave(); }

   void GetComputerStats(ComputerStats * pStats) { m_cs.Enter(); memcpy(pStats,&m_ComputerStats, sizeof m_ComputerStats); m_cs.Leave(); }
   void SetComputerStats(ComputerStats const * pStats) { m_cs.Enter(); memcpy(&m_ComputerStats,pStats,sizeof m_ComputerStats); m_cs.Leave(); }

   void GetDetailStats(DetailStats * pStats) { m_cs.Enter(); memcpy(pStats,&m_DetailStats,sizeof m_DetailStats); m_cs.Leave(); }
   
   void GetImportStats(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_ImportStats; m_cs.Leave(); }
   void SetImportStats(BOOL v) { m_cs.Enter(); m_ImportStats = v; m_cs.Leave(); }

   void GetDatabaseName(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_DatabasePath); m_cs.Leave();  }
   void SetDatabaseName(WCHAR const * path) { m_cs.Enter(); safecopy(m_DatabasePath,path); m_cs.Leave(); }

   void GetFirstPassDone(BOOL * pVal) { m_cs.Enter(); (*pVal) = m_bFirstPassDone; m_cs.Leave(); }
   void SetFirstPassDone(BOOL val) { m_cs.Enter(); m_bFirstPassDone = val; m_cs.Leave(); }

   void GetCacheFile(WCHAR * path) { m_cs.Enter(); UStrCpy(path,m_CacheFile); m_cs.Leave(); }
   void SetCacheFile(WCHAR const * path) { m_cs.Enter(); UStrCpy(m_CacheFile,path); m_cs.Leave(); }

   TServerList * GetUnsafeServerList(){ return &m_ServerList;}

   void Lock() { m_cs.Enter(); }

   void Unlock() { m_cs.Leave(); }

   void AddDetailStats(DetailStats * stats)
   {
      m_cs.Enter();
      m_DetailStats.directoriesChanged += stats->directoriesChanged;
      m_DetailStats.directoriesExamined += stats->directoriesExamined;
      m_DetailStats.directoriesUnchanged += stats->directoriesUnchanged;

      m_DetailStats.filesChanged += stats->filesChanged;
      m_DetailStats.filesExamined += stats->filesExamined;
      m_DetailStats.filesUnchanged += stats->filesUnchanged;

      m_DetailStats.sharesChanged += stats->sharesChanged;
      m_DetailStats.sharesExamined += stats->sharesExamined;
      m_DetailStats.sharesUnchanged += stats->sharesUnchanged;

      m_DetailStats.membersChanged += stats->membersChanged;
      m_DetailStats.membersExamined += stats->membersExamined;
      m_DetailStats.membersUnchanged += stats->membersUnchanged;

      m_DetailStats.rightsChanged += stats->rightsChanged;
      m_DetailStats.rightsExamined += stats->rightsExamined;
      m_DetailStats.rightsUnchanged += stats->rightsUnchanged;

      m_cs.Leave();
   }

};

extern GlobalData       gData;

void helpWrapper(HWND hwndDlg, int t);


#endif //__GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\maindlg.cpp ===
/*---------------------------------------------------------------------------
  File:  MainDlg.cpp

  Comments: This dialog shows the summary statistics, including 
  the number of agents successfully dispatched and completed, and the 
  total number of objects processed for all agents.  The number of objects
  processed is incremented to include the results for each agent when that 
  agent finishes and writes back its result file.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// MainDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MainDlg.h"
#include "Monitor.h"
#include "Globals.h"
#include "ResStr.h"
#include "TReg.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include <htmlhelp.h>
#include "helpid.h"
/////////////////////////////////////////////////////////////////////////////
// CMainDlg dialog


CMainDlg::CMainDlg(CWnd* pParent /*=NULL*/)
: CPropertyPage(CMainDlg::IDD)
{
	//{{AFX_DATA_INIT(CMainDlg)
	m_ErrorCount = _T("0");
	m_FinishedCount = _T("0");
	m_InstalledCount = _T("0");
	m_RunningCount = _T("0");
	m_TotalString = _T("");
	m_DirectoriesChanged = _T("0");
	m_DirectoriesExamined = _T("0");
	m_DirectoriesUnchanged = _T("0");
	m_FilesChanged = _T("0");
	m_FilesExamined = _T("0");
	m_FilesUnchanged = _T("0");
	m_SharesChanged = _T("0");
	m_SharesExamined = _T("0");
	m_SharesUnchanged = _T("0");
	m_MembersChanged = _T("0");
	m_MembersExamined = _T("0");
	m_MembersUnchanged = _T("0");
	m_RightsChanged = _T("0");
	m_RightsExamined = _T("0");
	m_RightsUnchanged = _T("0");
	//}}AFX_DATA_INIT
}


void CMainDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMainDlg)
	DDX_Control(pDX, IDC_INSTALL_PROGRESS, m_InstallProgCtrl);
	DDX_Control(pDX, IDC_COMPLETE_PROGESS, m_FinishProgCtrl);
	DDX_Text(pDX, IDC_ERROR_COUNT, m_ErrorCount);
	DDX_Text(pDX, IDC_FINISHED_COUNT, m_FinishedCount);
	DDX_Text(pDX, IDC_INSTALLED_COUNT, m_InstalledCount);
	DDX_Text(pDX, IDC_RUNNING_COUNT, m_RunningCount);
	DDX_Text(pDX, IDC_TOTAL, m_TotalString);
	DDX_Text(pDX, IDC_DirsChanged2, m_DirectoriesChanged);
	DDX_Text(pDX, IDC_DirsExamined, m_DirectoriesExamined);
	DDX_Text(pDX, IDC_DirsU, m_DirectoriesUnchanged);
	DDX_Text(pDX, IDC_FilesChanged, m_FilesChanged);
	DDX_Text(pDX, IDC_FilesExamined, m_FilesExamined);
	DDX_Text(pDX, IDC_FilesU, m_FilesUnchanged);
	DDX_Text(pDX, IDC_SharesChanged, m_SharesChanged);
	DDX_Text(pDX, IDC_SharesExamined2, m_SharesExamined);
	DDX_Text(pDX, IDC_SharesU, m_SharesUnchanged);
	DDX_Text(pDX, IDC_MembersChanged, m_MembersChanged);
	DDX_Text(pDX, IDC_MembersExamined, m_MembersExamined);
	DDX_Text(pDX, IDC_MembersU, m_MembersUnchanged);
	DDX_Text(pDX, IDC_RightsChanged, m_RightsChanged);
	DDX_Text(pDX, IDC_RightsExamined, m_RightsExamined);
	DDX_Text(pDX, IDC_RightsU, m_RightsUnchanged);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMainDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CMainDlg)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
   ON_MESSAGE(DCT_UPDATE_COUNTS, OnUpdateCounts)
	ON_MESSAGE(DCT_UPDATE_TOTALS, OnUpdateTotals)
	
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDlg message handlers

BOOL CMainDlg::OnSetActive()
{
   BOOL rc = CPropertyPage::OnSetActive();
   
   CancelToClose( );

   return rc;
}

BOOL CMainDlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	ComputerStats             gStat;
   DetailStats               dStat;
   
   gData.GetComputerStats(&gStat);
   gData.GetDetailStats(&dStat);

//   OnUpdateCounts(0,(long)&gStat);
   OnUpdateCounts(0, (LPARAM)&gStat);
//	OnUpdateTotals(0, (long)&dStat);
   OnUpdateTotals(0, (LPARAM)&dStat);
   gData.SetSummaryWindow(m_hWnd);

   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

//LRESULT CMainDlg::OnUpdateCounts(UINT nID, long x)
LRESULT CMainDlg::OnUpdateCounts(UINT nID, LPARAM x)
{
   UpdateData(TRUE);
   ComputerStats               * pStat = (ComputerStats *)x;

   m_TotalString.FormatMessage(IDS_ServerCountMessage,pStat->total);

   m_InstalledCount.Format(L"%ld",pStat->numInstalled);
   m_RunningCount.Format(L"%ld",pStat->numRunning);
   m_FinishedCount.Format(L"%ld",pStat->numFinished);
   m_ErrorCount.Format(L"%ld",pStat->numError);

#if _MFC_VER >= 0x0600
   m_InstallProgCtrl.SetRange32(0,pStat->total - pStat->numError);
#else
   m_InstallProgCtrl.SetRange(0,pStat->total - pStat->numError);
#endif
//   m_InstallProgCtrl.SetRange32(0,pStat->total - pStat->numError);
   m_InstallProgCtrl.SetPos(pStat->numInstalled);

#if _MFC_VER >= 0x0600
   m_FinishProgCtrl.SetRange32(0,pStat->total - pStat->numError);
#else
   m_FinishProgCtrl.SetRange(0,pStat->total - pStat->numError);
#endif
//   m_FinishProgCtrl.SetRange32(0,pStat->total - pStat->numError);
   m_FinishProgCtrl.SetPos(pStat->numFinished);

   UpdateData(FALSE);
   return 0;
}


//LRESULT CMainDlg::OnUpdateTotals(UINT nID, long x)
LRESULT CMainDlg::OnUpdateTotals(UINT nID, LPARAM x)
{
   UpdateData(TRUE);
   
   DetailStats               temp;
   DetailStats             * pStat = &temp;


   gData.GetDetailStats(&temp);
   
   
   m_FilesChanged.Format(L"%ld",pStat->filesChanged);
   m_FilesExamined.Format(L"%ld",pStat->filesExamined);
   m_FilesUnchanged.Format(L"%ld",pStat->filesUnchanged);

   m_DirectoriesChanged.Format(L"%ld",pStat->directoriesChanged);
   m_DirectoriesExamined.Format(L"%ld",pStat->directoriesExamined);
   m_DirectoriesUnchanged.Format(L"%ld",pStat->directoriesUnchanged);

   m_SharesChanged.Format(L"%ld",pStat->sharesChanged);
   m_SharesExamined.Format(L"%ld",pStat->sharesExamined);
   m_SharesUnchanged.Format(L"%ld",pStat->sharesUnchanged);

   m_MembersChanged.Format(L"%ld",pStat->membersChanged);
   m_MembersExamined.Format(L"%ld",pStat->membersExamined);
   m_MembersUnchanged.Format(L"%ld",pStat->membersUnchanged);

   m_RightsChanged.Format(L"%ld",pStat->rightsChanged);
   m_RightsExamined.Format(L"%ld",pStat->rightsExamined);
   m_RightsUnchanged.Format(L"%ld",pStat->rightsUnchanged);

   UpdateData(FALSE);
   return 0;
}

void CMainDlg::OnOK() 
{
	CPropertyPage::OnOK();
   
}

void CMainDlg::WinHelp(DWORD dwData, UINT nCmd) 
{
	// TODO: Add your specialized code here and/or call the base class
	CPropertyPage::WinHelp(dwData, nCmd);
}

BOOL CMainDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   LPNMHDR lpnm = (LPNMHDR) lParam;
	switch (lpnm->code)
	{
	   case PSN_HELP :
	      helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SUMMARY);
         break;
   }
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}


HRESULT GetHelpFileFullPath( BSTR *bstrHelp )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   USES_CONVERSION;

   HRESULT hr = S_OK;

   try
   {
      TRegKey key;

      // open ADMT registry key

      _com_util::CheckError(HRESULT_FROM_WIN32(key.Open(GET_STRING(IDS_DOMAIN_ADMIN_REGKEY), HKEY_LOCAL_MACHINE)));

      // query ADMT folder path from registry value

      _TCHAR szPath[_MAX_PATH];

      _com_util::CheckError(HRESULT_FROM_WIN32(key.ValueGetStr(_T("Directory"), szPath, DIM(szPath))));

      // if no path separator concatenate

      if (szPath[_tcslen(szPath) - 1] != _T('\\'))
      {
         _tcscat(szPath, _T("\\"));
      }

      // concatenate help file name

      CComBSTR bstrName;
      bstrName.LoadString(IDS_HELPFILE);

      _tcscat(szPath, OLE2CT(bstrName));

      *bstrHelp = SysAllocString(T2COLE(szPath));
   }
   catch (_com_error& ce)
   {
      hr = ce.Error();
   }
   catch (...)
   {
      hr = E_FAIL;
   }

   return hr;
}

void helpWrapper(HWND hwndDlg, int t)
{
   
   CComBSTR    bstrTopic;
	HRESULT     hr = GetHelpFileFullPath( &bstrTopic);
   if ( SUCCEEDED(hr) )
   {
	    HWND h = HtmlHelp(hwndDlg,  bstrTopic,  HH_HELP_CONTEXT, t );	
   }
   else
   {
		CString r,e;
		r.LoadString(IDS_MSG_HELP);
		e.LoadString(IDS_MSG_ERROR);
		MessageBox(hwndDlg,r,e,MB_OK|MB_ICONSTOP);
   }
}

BOOL CMainDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	
   helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SUMMARY);
	return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\maindlg.h ===
#if !defined(AFX_MAINDLG_H__62C9BAC6_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_MAINDLG_H__62C9BAC6_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// MainDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMainDlg dialog

class CMainDlg : public CPropertyPage
{
// Construction
public:
	CMainDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CMainDlg)
	enum { IDD = IDD_AGENTMONITOR_MAIN };
	CProgressCtrl	m_InstallProgCtrl;
	CProgressCtrl	m_FinishProgCtrl;
	CString	m_ErrorCount;
	CString	m_FinishedCount;
	CString	m_InstalledCount;
	CString	m_RunningCount;
	CString	m_TotalString;
	CString	m_DirectoriesChanged;
	CString	m_DirectoriesExamined;
	CString	m_DirectoriesUnchanged;
	CString	m_FilesChanged;
	CString	m_FilesExamined;
	CString	m_FilesUnchanged;
	CString	m_SharesChanged;
	CString	m_SharesExamined;
	CString	m_SharesUnchanged;
	CString	m_MembersChanged;
	CString	m_MembersExamined;
	CString	m_MembersUnchanged;
	CString	m_RightsChanged;
	CString	m_RightsExamined;
	CString	m_RightsUnchanged;
	//}}AFX_DATA
   virtual BOOL OnSetActive( );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainDlg)
	public:
	virtual void OnOK();
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMainDlg)
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
   
//   LRESULT OnUpdateCounts(UINT nID, long x);
   LRESULT OnUpdateCounts(UINT nID, LPARAM x);
//   LRESULT OnUpdateTotals(UINT nID, long x);
   LRESULT OnUpdateTotals(UINT nID, LPARAM x);
   
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINDLG_H__62C9BAC6_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\migdrvr.cpp ===
/*---------------------------------------------------------------------------
  File:  McsMigrationDriver.cpp

  Comments: Main program for COM object that drives the migration process.
  This file is mostly generated by the ATL wizard.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// McsMigrationDriver.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsMigrationDriverps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <locale.h>
#include "MigDrvr.h"

#include "MigDrvr_i.c"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#include "Migrator.h"
#include "ErrDct.hpp"
#include "ResStr.h"

TErrorDct         errTrace;
TError          & errCommon = errTrace;
StringLoader      gString;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Migrator, CMigrator)
END_OBJECT_MAP()




class CMcsMigrationDriverApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMcsMigrationDriverApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CMcsMigrationDriverApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMcsMigrationDriverApp, CWinApp)
	//{{AFX_MSG_MAP(CMcsMigrationDriverApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CMcsMigrationDriverApp theApp;

BOOL CMcsMigrationDriverApp::InitInstance()
{
	ATLTRACE(_T("{McsMigrationDriver.dll}CDomMigSIApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _wsetlocale( LC_ALL, L".ACP" );
    _Module.Init(ObjectMap, m_hInstance, &LIBID_MCSMIGRATIONDRIVERLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CMcsMigrationDriverApp::ExitInstance()
{
	ATLTRACE(_T("{McsMigrationDriver.dll}CDomMigSIApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\mondlg.h ===
// AgentMonitorDlg.h : header file
//

#if !defined(AFX_AGENTMONITORDLG_H__5A5901FB_D179_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_AGENTMONITORDLG_H__5A5901FB_D179_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CAgentMonitorDlg dialog

class CAgentMonitorDlg : public CPropertyPage
{
// Construction
public:
	CAgentMonitorDlg(CWnd* pParent = NULL);	// standard constructor
   virtual BOOL OnSetActive( );
// Dialog Data
	//{{AFX_DATA(CAgentMonitorDlg)
	enum { IDD = IDD_AGENTMONITOR_DIALOG };
	CButton	m_DetailsButton;
	CListCtrl	m_ServerList;
	CString	m_DispatchLog;
	int		m_Interval;
	CString	m_ServerCount;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAgentMonitorDlg)
	public:
	virtual void OnOK();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL
   public:
      void SetSecurityTranslationFlag(BOOL bIsIt){ m_bSecTrans = bIsIt; }
      void SetReportingFlag(BOOL bIsIt){ m_bReporting = bIsIt; }
// Implementation
protected:
	HICON m_hIcon;
   int   m_SortColumn;
   BOOL  m_bReverseSort;
   BOOL  m_bSecTrans;
   BOOL  m_bReporting;
   // Generated message map functions
	//{{AFX_MSG(CAgentMonitorDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnDblclkServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnViewDispatch();
	afx_msg void OnDetails();
	afx_msg void OnColumnclickServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClickServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnGetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnHeaderItemClickServerlist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
//	LRESULT OnUpdateServerEntry(UINT nID, long x);
	LRESULT OnUpdateServerEntry(UINT nID, LPARAM x);
//	LRESULT OnServerError(UINT nID, long x);
	LRESULT OnServerError(UINT nID, LPARAM x);
   
   DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_AGENTMONITORDLG_H__5A5901FB_D179_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\migrator.h ===
// Migrator.h: Definition of the CMigrator class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MIGRATOR_H__1AA3D2E2_2B15_11D3_8AE5_00A0C9AFE114__INCLUDED_)
#define AFX_MIGRATOR_H__1AA3D2E2_2B15_11D3_8AE5_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#import "DBMgr.tlb" no_namespace, named_guids

#define MAX_DB_FIELD 255

/////////////////////////////////////////////////////////////////////////////
// CMigrator

class CMigrator : 
	public IDispatchImpl<IPerformMigrationTask, &IID_IPerformMigrationTask, &LIBID_MCSMIGRATIONDRIVERLib>, 
	public ISupportErrorInfoImpl<&IID_IPerformMigrationTask>,
	public CComObjectRoot,
	public CComCoClass<CMigrator,&CLSID_Migrator>
{
public:
	CMigrator() {}
BEGIN_COM_MAP(CMigrator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IPerformMigrationTask)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CMigrator) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_Migrator)

protected:
   // these helper functions are implemented in StrDesc.cpp
   void BuildGeneralDesc(IVarSet * pVarSet,CString & str);
   void BuildAcctReplDesc(IVarSet * pVarSet,CString & str);
   void BuildSecTransDesc(IVarSet * pVarSet,CString & str, BOOL bLocal);
   void BuildDispatchDesc(IVarSet * pVarSet,CString & str);
   void BuildReportDesc(IVarSet * pVarSet, CString & str);
   void BuildUndoDesc(IVarSet * pVarSet, CString & str);
   void BuildGroupMappingDesc(IVarSet * pVarSet, CString & str);
  
   void PreProcessForReporting(IVarSet * pVarSet);
   void PreProcessDispatcher(IVarSet * pVarSet);
   void PostProcessDispatcher(IVarSet * pVarSet);
   HRESULT BuildAccountListForUndo(IVarSet * pVarSet,long actionID);
   HRESULT ProcessServerListForUndo(IVarSet * pVarSet);
   HRESULT ConstructUndoVarSet(IVarSet * pVarSetIn,IVarSet * pVarSetOut);
   HRESULT TrimMigratingComputerList(IVarSet * pVarSetIn, bool* bAnyToDispatch);
   HRESULT RunReports(IVarSet * pVarSet);
   HRESULT SetReportDataInRegistry(WCHAR const * reportName,WCHAR const * filename);
   HRESULT ViewPreviousDispatchResults();


// IPerformMigrationTask
public:
	STDMETHOD(GetTaskDescription)(IUnknown * pVarSet,/*[out]*/BSTR * pDescription);
	STDMETHOD(PerformMigrationTask)(IUnknown * pVarSet,LONG_PTR HWND);
   STDMETHOD(GetUndoTask)(IUnknown * pVarSet,/*[out]*/ IUnknown ** ppVarSetOut);
private:
   typedef struct _DATABASE_ENTRY {
		_bstr_t	m_domain;
        _bstr_t	m_sSAMName;
        _bstr_t	m_sRDN;
        _bstr_t	m_sCanonicalName;
        _bstr_t	m_sObjectClass;
		BOOL	m_bSource;
   }DATABASE_ENTRY, *PDATABASE_ENTRY;
   CList<DATABASE_ENTRY,DATABASE_ENTRY&> mUserList;

   HRESULT PopulateAccounts(IVarSetPtr pVs);
   bool PopulateDomainDBs(IVarSet * pVarSet);
   bool PopulateADomainDB(WCHAR const *domain, WCHAR const *domainDNS, BOOL bSource);
   DWORD GetOSVersionForDomain(WCHAR const * domain);
   BOOL DeleteItemFromList(WCHAR const * aName);
   void RetrieveSrcDomainSid(IVarSet * pVarSet, IIManageDBPtr pDb);
};

#endif // !defined(AFX_MIGRATOR_H__1AA3D2E2_2B15_11D3_8AE5_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\scanlog.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\mondlg.cpp ===
/*---------------------------------------------------------------------------
  File: AgentMonitorDlg.cpp 

  Comments: This dialog shows a list of the computers the agent is being dispatched to
  along with their status.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// AgentMonitorDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "MonDlg.h"
#include "DetDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "Common.hpp"
#include "UString.hpp"                    
#include "TNode.hpp"
#include "ServList.hpp"
#include "Monitor.h"
#include "Globals.h"
#include "ResStr.h"

#include <htmlhelp.h>
#include "helpid.h"


#define COLUMN_COMPUTER             0
#define COLUMN_TIMESTAMP            1
#define COLUMN_STATUS               2
#define COLUMN_MESSAGE              3

#define SORT_COLUMN_BITS            0x03
#define SORT_REVERSE                0x80000000

BOOL              bWaiting = FALSE;

// This is the sort function for the CListView
int CALLBACK SortFunction(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
   int                       result = 0;
   TServerNode             * n1 = (TServerNode*)lParam1;
   TServerNode             * n2 = (TServerNode*)lParam2;

   if ( n1 && n2 )
   {
      switch ( lParamSort & SORT_COLUMN_BITS )
      {
      case COLUMN_COMPUTER:
         // Sort by names
         result = UStrICmp(n1->GetServer(),n2->GetServer());
         break;
      case COLUMN_TIMESTAMP:
         result = UStrICmp(n1->GetTimeStamp(),n2->GetTimeStamp());
         break;
      case COLUMN_STATUS:
         if ( n1->GetStatus() == n2->GetStatus() )
            result = 0;
         else if ( n1->GetStatus() < n2->GetStatus() )
            result = -1;
         else 
            result = 1;
         break;
      case COLUMN_MESSAGE:
         result = UStrICmp(n1->GetMessageText(),n2->GetMessageText());
         break;
      default:
         MCSVERIFY(FALSE);
         break;
      }
   }
   if ( lParamSort & SORT_REVERSE )
   {
      result *= -1;
   }
   return result;
}




/////////////////////////////////////////////////////////////////////////////
// CAgentMonitorDlg dialog

CAgentMonitorDlg::CAgentMonitorDlg(CWnd* pParent /*=NULL*/)
: CPropertyPage(CAgentMonitorDlg::IDD) 
{
	//{{AFX_DATA_INIT(CAgentMonitorDlg)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
   m_SortColumn = 0;
   m_bReverseSort = FALSE;
   m_bSecTrans = TRUE;
   m_bReporting = FALSE;
}

void CAgentMonitorDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAgentMonitorDlg)
	DDX_Control(pDX, IDC_DETAILS, m_DetailsButton);
	DDX_Control(pDX, IDC_SERVERLIST, m_ServerList);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAgentMonitorDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CAgentMonitorDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(NM_DBLCLK, IDC_SERVERLIST, OnDblclkServerlist)
	ON_BN_CLICKED(IDC_VIEW_DISPATCH, OnViewDispatch)
	ON_BN_CLICKED(IDC_DETAILS, OnDetails)
	ON_NOTIFY(LVN_COLUMNCLICK, IDC_SERVERLIST, OnColumnclickServerlist)
	ON_NOTIFY(NM_CLICK, IDC_SERVERLIST, OnClickServerlist)
	ON_NOTIFY(LVN_GETDISPINFO, IDC_SERVERLIST, OnGetdispinfoServerlist)
	ON_NOTIFY(LVN_SETDISPINFO, IDC_SERVERLIST, OnSetdispinfoServerlist)
	ON_NOTIFY(HDN_ITEMCLICK, IDC_SERVERLIST, OnHeaderItemClickServerlist)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
    ON_MESSAGE(DCT_UPDATE_ENTRY, OnUpdateServerEntry)
	ON_MESSAGE(DCT_ERROR_ENTRY, OnServerError)
   
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAgentMonitorDlg message handlers

BOOL CAgentMonitorDlg::OnInitDialog()
{
	CPropertyPage::OnInitDialog();

	// Setup the columns for the server list
   CString heading;
   
   heading.LoadString(IDS_ComputerColumnHeading);
   m_ServerList.InsertColumn(COLUMN_COMPUTER,heading,LVCFMT_LEFT,120);
   
   heading.LoadString(IDS_TimestampColumnHeading);
   m_ServerList.InsertColumn(COLUMN_TIMESTAMP,heading,LVCFMT_LEFT,120);
   
   heading.LoadString(IDS_StatusColumnHeading);
   m_ServerList.InsertColumn(COLUMN_STATUS,heading,LVCFMT_LEFT,120);
   
   heading.LoadString(IDS_MessageColumnHeading);
   m_ServerList.InsertColumn(COLUMN_MESSAGE,heading,LVCFMT_LEFT,200);
   
   // Read the server list to get any information we may have missed so far
   TNodeListEnum           e;
   TServerList           * pServerList = gData.GetUnsafeServerList();
   TServerNode           * pServer;

   gData.Lock();
   
   for ( pServer = (TServerNode *)e.OpenFirst(pServerList) ; pServer ; pServer = (TServerNode *)e.Next() )
   {
      if ( pServer->Include() )
      {
//         OnUpdateServerEntry(0,(long)pServer);
         OnUpdateServerEntry(0,(LPARAM)pServer);
      }
   }
   e.Close();
   gData.Unlock();

   gData.SetListWindow(m_hWnd);
	
   m_DetailsButton.EnableWindow(m_ServerList.GetSelectedCount());

   CString str;
   str.LoadString(IDS_WaitingMessage);
   m_ServerList.InsertItem(0,str);
   bWaiting = TRUE;

   return TRUE;  // return TRUE  unless you set the focus to a control
}

void CAgentMonitorDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
   CPropertyPage::OnSysCommand(nID, lParam);
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CAgentMonitorDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CPropertyPage::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CAgentMonitorDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

//LRESULT CAgentMonitorDlg::OnUpdateServerEntry(UINT nID, long x)
LRESULT CAgentMonitorDlg::OnUpdateServerEntry(UINT nID, LPARAM x)
{
   TServerNode             * pNode = (TServerNode *)x;
   LVFINDINFO                findInfo;
   CString                   timestamp;
   CWaitCursor               w;
   memset(&findInfo,0,(sizeof findInfo));

      // This turns off the initial hourglass in the dispatch monitor
   if ( bWaiting )
   {
      if ( pNode )
      {
         AfxGetApp()->DoWaitCursor(-1);
         if ( m_ServerList.GetItemCount() == 1 )
         {
            m_ServerList.DeleteItem(0);
         }
         
      }
      else
      {
         BOOL                 bLDone;

         gData.GetLogDone(&bLDone);

         if ( bLDone )
         {
            AfxGetApp()->DoWaitCursor(-1);
            if ( m_ServerList.GetItemCount() == 1 )
            {
               m_ServerList.DeleteItem(0);
               CString str;
               str.LoadString(IDS_NoServersMessage);
               m_ServerList.InsertItem(0,str);
            }
         }
      }
   }
   bWaiting = FALSE;

   if ( pNode )
   {
      findInfo.flags = LVFI_STRING;
      findInfo.psz = pNode->GetServer();
  
      int ndx = m_ServerList.FindItem(&findInfo);
      if ( ndx == -1 )
      {
         // add the server to the list
         ndx = m_ServerList.GetItemCount();
//         m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(long)pNode);
         m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(LPARAM)pNode);
         if ( m_bReverseSort )
         {
            m_ServerList.SortItems(&SortFunction,m_SortColumn | SORT_REVERSE);
         }
         else
         {
            m_ServerList.SortItems(&SortFunction,m_SortColumn);
         }

      }
      m_ServerList.RedrawItems(ndx,ndx);
   }   
   return 0;
}
	
//LRESULT CAgentMonitorDlg::OnServerError(UINT nID, long x)
LRESULT CAgentMonitorDlg::OnServerError(UINT nID, LPARAM x)
{
   TServerNode             * pNode = (TServerNode *)x;
   LVFINDINFO                findInfo;
   CString                   timestamp;
   CWaitCursor               w;

   memset(&findInfo,0,(sizeof findInfo));

      // This turns off the initial hourglass in the dispatch monitor
   if ( bWaiting )
   {
      if ( pNode )
      {
         AfxGetApp()->DoWaitCursor(-1);
         if ( m_ServerList.GetItemCount() == 1 )
         {
            m_ServerList.DeleteItem(0);
         }
         
      }
      else
      {
         BOOL                 bLDone;

         gData.GetLogDone(&bLDone);

         if ( bLDone )
         {
            AfxGetApp()->DoWaitCursor(-1);
            if ( m_ServerList.GetItemCount() == 1 )
            {
               m_ServerList.DeleteItem(0);
               CString str;
               str.LoadString(IDS_NoServersMessage);
               m_ServerList.InsertItem(0,str);
            }
         }
      }
   }
   bWaiting = FALSE;
   
   findInfo.flags = LVFI_STRING;
   findInfo.psz = pNode->GetServer();

   int ndx = m_ServerList.FindItem(&findInfo);
   if ( ndx == -1 )
   {
      // add the server to the list
      ndx = m_ServerList.GetItemCount();
//      m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(long)pNode);
      m_ServerList.InsertItem(LVIF_TEXT | LVIF_PARAM,ndx,pNode->GetServer(),0,0,0,(LPARAM)pNode);
      if ( m_bReverseSort )
      {
         m_ServerList.SortItems(&SortFunction,m_SortColumn | SORT_REVERSE);
      }
      else
      {
         m_ServerList.SortItems(&SortFunction,m_SortColumn);
      }

   }
   timestamp = pNode->GetTimeStamp();
   if ( timestamp.Right(1) == "\n" )
   {
      timestamp = timestamp.Left(timestamp.GetLength() - 1);
   }
   // the subitems will be callbacks
   
   m_ServerList.RedrawItems(ndx,ndx);
   return 0;
}

void CAgentMonitorDlg::OnDblclkServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	OnDetails();
   *pResult = 0;
}

void CAgentMonitorDlg::OnViewDispatch() 
{
   WCHAR                     filename[MAX_PATH];
   CString                   cmd;
   STARTUPINFO				     startupInfo;
	PROCESS_INFORMATION		  processInfo;

   memset(&startupInfo,0,(sizeof startupInfo));
   
   startupInfo.cb = (sizeof startupInfo);

   gData.GetReadableLogFile(filename);

   
   cmd.FormatMessage(IDS_NotepadCommandLine,filename);

   CreateProcess(NULL,cmd.GetBuffer(0),NULL,NULL,TRUE,0,NULL,NULL,&startupInfo,&processInfo);
}

void CAgentMonitorDlg::OnDetails() 
{
   const int NOT_FOUND = -1;  //indicates no match in search - PRT
   const int WHOLE_LIST = -1; //index to start search of whole list - PRT

   UpdateData(TRUE);

//   POSITION p = m_ServerList.GetFirstSelectedItemPosition();
//   if ( p )
//   {
//      int ndx = m_ServerList.GetNextSelectedItem(p);

	  //search whole list control for first (and only) selected item
   int ndx = m_ServerList.GetNextItem(WHOLE_LIST, LVNI_SELECTED); //PRT
	  //if found selected item, disply it's details
   if (ndx != NOT_FOUND)  //PRT
   {   //PRT
      CString serverName;
      serverName = m_ServerList.GetItemText(ndx,0);
      if ( serverName.GetLength() )
      {
         // Launch the details dialog
         CAgentDetailDlg      det;
         
         gData.Lock();

         TServerNode     * s = gData.GetUnsafeServerList()->FindServer((LPCTSTR)serverName);
         
         gData.Unlock();

         if ( s )
         {
            det.SetNode(s);
            if ( ! m_bSecTrans )
            {
               det.SetFormat(-1);
            }
            if ( m_bReporting )
            {
               det.SetGatheringInfo(TRUE);
            }
            if ( s->IsFinished() && *s->GetJobFile() )
            {
               DetailStats   detailStats;
               WCHAR         directory[MAX_PATH];
               WCHAR         filename[MAX_PATH];
               CString       plugInText;

               gData.GetResultDir(directory);
               
               memset(&detailStats,0,(sizeof detailStats));

               swprintf(filename,GET_STRING(IDS_AgentResultFileFmt),s->GetJobFile());

               if ( SUCCEEDED(CoInitialize(NULL)) )
               {
                  if ( ReadResults(s,directory,filename,&detailStats,plugInText,FALSE) )
                  {
                     det.SetStats(&detailStats);
                     det.SetPlugInText(plugInText);
                     det.SetLogFile(s->GetLogPath());
                  }

                  CoUninitialize();
               }
            }
            det.DoModal();
            if ( s->IsRunning() && ! det.IsAgentAlive() )
            {
               // the agent is not really running, update it's status to failed.
               if (! det.IsStatusUnknown() )
               {
                  s->SetSeverity(2);
                  s->SetFailed();
//                  OnServerError(0,(long)s);
                  OnServerError(0,(LPARAM)s);
               }
               // update the counts on the summary screen
               ComputerStats stats;
               HWND          gSummaryWnd;

               gData.GetComputerStats(&stats);
               stats.numError++;
               stats.numRunning--;
               gData.SetComputerStats(&stats);
               gData.GetSummaryWindow(&gSummaryWnd);
//               ::SendMessage(gSummaryWnd,DCT_UPDATE_COUNTS,0,(long)&stats);
               ::SendMessage(gSummaryWnd,DCT_UPDATE_COUNTS,0,(LPARAM)&stats);
            }               
               
         }
      }
   }

   UpdateData(FALSE);
}


void CAgentMonitorDlg::OnColumnclickServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	CWaitCursor               w;
   NM_LISTVIEW             * pNMListView = (NM_LISTVIEW*)pNMHDR;

	// sort by pNMListView->iSubItem
   if ( m_SortColumn == pNMListView->iSubItem )
   {
      m_bReverseSort = ! m_bReverseSort;
   }
   else
   {
      m_bReverseSort = FALSE;
   }
   m_SortColumn = pNMListView->iSubItem;
   if ( m_bReverseSort )
   {
      m_ServerList.SortItems(&SortFunction,m_SortColumn | SORT_REVERSE);
   }
   else
   {
      m_ServerList.SortItems(&SortFunction,m_SortColumn);
   }
   
	*pResult = 0;
}

void CAgentMonitorDlg::OnClickServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
   const int NOT_FOUND = -1;  //indicates no match in search - PRT
   const int WHOLE_LIST = -1; //index to start search of whole list - PRT

   UpdateData(TRUE);
   if ( m_ServerList.GetSelectedCount() )
   {
//      POSITION p = m_ServerList.GetFirstSelectedItemPosition();
//      if ( p )
//      {
		  //search whole list control for first (and only) selected item
	   int ndx = m_ServerList.GetNextItem(WHOLE_LIST, LVNI_SELECTED); //PRT
		  //if found selected item, disply it's details
	   if (ndx != NOT_FOUND)  //PRT
	   {   //PRT
         CString msg1;
         CString msg2;

//         int ndx = m_ServerList.GetNextSelectedItem(p);
         CString serverName;
         serverName = m_ServerList.GetItemText(ndx,0);
         msg1.LoadString(IDS_WaitingMessage);
         msg2.LoadString(IDS_NoServersMessage);
         if ( serverName.Compare(msg1) && serverName.Compare(msg2) )
         {
            m_DetailsButton.EnableWindow(TRUE);
         }
         else
         {
            m_DetailsButton.EnableWindow(FALSE);
         }
      }
   }
   else
   {
      m_DetailsButton.EnableWindow(FALSE);
   }
   UpdateData(FALSE);

	*pResult = 0;
}

WCHAR gMessage[1000];

void CAgentMonitorDlg::OnGetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	// find iItem in the serverList, and set the pszText for the iSubItem appropriately
   CString                   status;
   TServerNode             * pNode = NULL;
   CString                   timestamp;
   WCHAR                   * text = gMessage;
   CString                   serverName;
   
   status.LoadString(IDS_Status_Unknown);

   serverName = m_ServerList.GetItemText(pDispInfo->item.iItem,0);

   if ( serverName.GetLength() )
   {
      gData.Lock();
      pNode = gData.GetUnsafeServerList()->FindServer(serverName.GetBuffer(0));
      gData.Unlock();

      if ( pNode )
      {

         switch ( pDispInfo->item.iSubItem )
         {
         case COLUMN_TIMESTAMP:
            timestamp = pNode->GetTimeStamp();
            if ( timestamp.Right(1) == "\n" )
            {
               timestamp = timestamp.Left(timestamp.GetLength() - 1);
            }
            //text = new char[timestamp.GetLength() + 1];
            UStrCpy(text,timestamp.GetBuffer(0));
            pDispInfo->item.pszText = text;
            break;
         case COLUMN_STATUS:
            
            if ( pNode->HasFailed() )
            {
               status.LoadString(IDS_Status_InstallFailed);
            }
            if ( pNode->IsInstalled() )
            {
               if ( ! pNode->HasFailed() )
                  status.LoadString(IDS_Status_Installed);
               else 
                  status.LoadString(IDS_Status_DidNotStart);
            }
            if ( pNode->GetStatus() & Agent_Status_Started )
            {
               if ( ! pNode->HasFailed() )
                  status.LoadString(IDS_Status_Running);
               else
                  status.LoadString(IDS_Status_Failed);
            }
            if ( pNode->IsFinished() )
            {
               if ( ! pNode->HasFailed() && ! pNode->GetSeverity() )
                  status.LoadString(IDS_Status_Completed);
               else if ( pNode->GetSeverity() )
               {
                  switch ( pNode->GetSeverity() )
                  {
                  case 1:
                     status.LoadString(IDS_Status_Completed_With_Warnings);
                     break;
                  case 2:
                     status.LoadString(IDS_Status_Completed_With_Errors);
                     break;
                  case 3:
                  default:
                     status.LoadString(IDS_Status_Completed_With_SErrors);
                     break;
                  }
               }
               else
                  status.LoadString(IDS_Status_NotRunning);
            }
            
            UStrCpy(text,status);
            pDispInfo->item.pszText = text;
            break;
         case COLUMN_MESSAGE:
            if ( pNode->HasFailed() || pNode->QueryFailed() || pNode->GetSeverity() )
            {
               UStrCpy(text,pNode->GetMessageText());
               pDispInfo->item.pszText = text;
            }
            break;
         }
      }
   }
	*pResult = 0;
}

BOOL CAgentMonitorDlg::OnSetActive()
{
   BOOL rc = CPropertyPage::OnSetActive();
   
   CancelToClose();
   return rc;
}

void CAgentMonitorDlg::OnSetdispinfoServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;
}

void CAgentMonitorDlg::OnHeaderItemClickServerlist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HD_NOTIFY *phdn = (HD_NOTIFY *) pNMHDR;
	// TODO: Add your control notification handler code here
	
	*pResult = 0;
}

void CAgentMonitorDlg::OnOK() 
{
	CPropertyPage::OnOK();
}

BOOL CAgentMonitorDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   LPNMHDR lpnm = (LPNMHDR) lParam;
	switch (lpnm->code)
	{
	   case PSN_HELP :
	      helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SERVER_LIST );
         break;
   }
   
	return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

BOOL CAgentMonitorDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   helpWrapper(m_hWnd, IDH_WINDOW_AGENT_SERVER_LIST );
   return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\monitor.h ===
#ifndef __MONITOR_H__
#define __MONITOR_H__
/*---------------------------------------------------------------------------
  File: Monitor.h

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:12:36

 ---------------------------------------------------------------------------
*/

DWORD __stdcall ResultMonitorFn(void * arg);
DWORD __stdcall LogReaderFn(void * arg);

DWORD __stdcall MonitorRunningAgents(void * arg);



#define DCT_UPDATE_ENTRY   (WM_APP+2)
#define DCT_ERROR_ENTRY    (WM_APP+3)
#define DCT_SERVER_COUNT   (WM_APP+4)
#define DCT_DETAIL_REFRESH (WM_APP+5)
#define DCT_UPDATE_COUNTS  (WM_APP+6)
#define DCT_UPDATE_TOTALS  (WM_APP+7)

struct ComputerStats
{
   DWORD                     total;
   DWORD                     numInstalled;
   DWORD                     numRunning;
   DWORD                     numFinished;
   DWORD                     numError;
};

struct DetailStats
{
   ULONGLONG                 filesExamined;
   ULONGLONG                 filesChanged;
   ULONGLONG                 filesUnchanged;
   ULONGLONG                 directoriesExamined;
   ULONGLONG                 directoriesChanged;
   ULONGLONG                 directoriesUnchanged;
   ULONGLONG                 sharesExamined;
   ULONGLONG                 sharesChanged;
   ULONGLONG                 sharesUnchanged;
   ULONGLONG                 membersExamined;
   ULONGLONG                 membersChanged;
   ULONGLONG                 membersUnchanged;
   ULONGLONG                 rightsExamined;
   ULONGLONG                 rightsChanged;
   ULONGLONG                 rightsUnchanged;
};

class TServerNode;

BOOL                                       // ret- TRUE if successful
   ReadResults(
      TServerNode          * pServer,      // in - pointer to server node containing server name 
      WCHAR          const * directory,    // in - directory where results files are stored
      WCHAR          const * filename,     // in - filename for this agent's job
      DetailStats          * pStats,       // out- counts of items processed by the agent
      CString              & plugInString, // out- description of results from plug-ins
      BOOL                   bSaveResults  // in - flag, whether to call store results for plugins
   );

void 
   ProcessResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename
   );


#endif //__MONITOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\migrator.cpp ===
/*---------------------------------------------------------------------------
  File:  Migrator.cpp

  Comments: Implementation of McsMigrationDriver COM object.
  This object encapsulates the knowledge of when to call the local engine, 
  and when to call the dispatcher.  

  It will also provide a description of the tasks to be performed, for display 
  on the last page of each migration wizard, and will be responsible for calculating
  the actions required to undo an operation (this is not yet implemented).

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// Migrator.cpp : Implementation of CMcsMigrationDriverApp and DLL registration.

#include "stdafx.h"
#include "MigDrvr.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\McsEADCTAgent.tlb" no_namespace, named_guids
//#import "\bin\McsDispatcher.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb"
//#import "\bin\NetEnum.tlb" no_namespace 
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
//#import "Engine.tlb" no_namespace, named_guids //#imported via DetDlg.h below
#import "Dispatch.tlb" no_namespace, named_guids
#import "WorkObj.tlb"
#import "NetEnum.tlb" no_namespace 
#include <iads.h>
#include <adshlp.h>
#include <dsgetdc.h>
#include <Ntdsapi.h>
#include <lm.h>
#include <Psapi.h>
#pragma comment(lib, "Psapi.lib")

#include "Migrator.h"
#include "TaskChk.h"
#include "ResStr.h"
// dialogs used
#include "DetDlg.h"
#include "MonDlg.h"
#include "SetDlg.h"
#include "MainDlg.h"
#include "Working.h"

#include "ErrDct.hpp"
#include "TReg.hpp"
#include "EaLen.hpp"
#include <MigrationMutex.h>

//#define MAX_DB_FIELD 255

typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);

// Opertation flags to be performed on the Account
#define OPS_Create_Account          (0x00000001)
#define OPS_Copy_Properties         (0x00000002)
#define OPS_Process_Members         (0x00000004)
#define OPS_Process_MemberOf        (0x00000008)
#define OPS_Call_Extensions         (0x00000010)
#define OPS_All                     OPS_Create_Account | OPS_Copy_Properties | OPS_Process_Members | OPS_Process_MemberOf | OPS_Call_Extensions
#define OPS_Copy                    OPS_Create_Account | OPS_Copy_Properties

BOOL 		gbCancelled = FALSE;


bool __stdcall IsAgentOrDispatcherProcessRunning();
void __stdcall SetDomainControllers(IVarSetPtr& spVarSet);


/////////////////////////////////////////////////////////////////////////////
//

BOOL                                       // ret - TRUE if found program directory in the registry
   GetProgramDirectory(
      WCHAR                * filename      // out - buffer that will contain path to program directory
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   if ( ! bFound )
   {
      UStrCpy(filename,L"C:\\");    // if all else fails, default to the C: drive
   }
   return bFound;
}

BOOL                                       // ret - TRUE if found program directory in the registry
   GetLogLevel(
      DWORD                * level         // out - value that should be used for log level
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetDWORD(L"TranslationLogLevel",level);
      if ( ! rc )
      {
         bFound = TRUE;
      }
   }
   return bFound;
}

HRESULT CMigrator::ViewPreviousDispatchResults()
{  
   _bstr_t          logFile;
   if ( logFile.length() == 0 )
   {
      WCHAR                   path[MAX_PATH];

      GetProgramDirectory(path);
      logFile = path;
      logFile += L"Logs\\Dispatcher.csv";
   }
   
   // reset the stats, so that we don't see anything left over from the previous run
   gData.Initialize();

   CPropertySheet   mdlg;
   CAgentMonitorDlg listDlg;
   CMainDlg         summaryDlg;
   CLogSettingsDlg  settingsDlg;
   

   listDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
   summaryDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
   settingsDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;

   mdlg.AddPage(&summaryDlg);
   mdlg.AddPage(&listDlg);
   mdlg.AddPage(&settingsDlg);

   settingsDlg.SetImmediateStart(TRUE);
   settingsDlg.SetDispatchLog(logFile);

   mdlg.SetActivePage(&listDlg);
   
//   UINT nResponse = mdlg.DoModal();
   UINT_PTR nResponse = mdlg.DoModal();

   return S_OK;
}


// WaitForAgentsToFinish Method
//
// Waits for dispatcher and all dispatched agents to complete
// their tasks.
// Used when ADMT is run from script or command line.

static void WaitForAgentsToFinish(_bstr_t strLogPath)
{
	gData.SetLogPath(strLogPath);

	CloseHandle(CreateThread(NULL, 0, &ResultMonitorFn,      NULL, 0, NULL));
	CloseHandle(CreateThread(NULL, 0, &LogReaderFn,          NULL, 0, NULL));
	CloseHandle(CreateThread(NULL, 0, &MonitorRunningAgents, NULL, 0, NULL));

	LARGE_INTEGER liDueTime;
	liDueTime.QuadPart = -50000000; // 5 sec

	HANDLE hTimer = CreateWaitableTimer(NULL, TRUE, NULL);

	for (int nState = 0; nState < 3;)
	{
		SetWaitableTimer(hTimer, &liDueTime, 0, NULL, NULL, FALSE);

		if (WaitForSingleObject(hTimer, INFINITE) == WAIT_OBJECT_0)
		{
			BOOL bDone = FALSE;

			switch (nState)
			{
				case 0: // first pass of dispatcher log
				{
					gData.GetFirstPassDone(&bDone);
					break;
				}
				case 1: // dispatcher finished
				{
					gData.GetLogDone(&bDone);
					break;
				}
				case 2: // agents finished
				{
					ComputerStats stats;
					gData.GetComputerStats(&stats);

					if (stats.numRunning == 0)
					{
						bDone = TRUE;
					}
					break;
				}
			}

			if (bDone)
			{
				++nState;
			}
		}
		else
		{
			break;
		}
	}

	CloseHandle(hTimer);

	gData.SetDone(TRUE);
}


STDMETHODIMP CMigrator::PerformMigrationTask(IUnknown* punkVarSet, LONG_PTR hWnd)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVS = punkVarSet;
   BSTR                      jobID = NULL;
   CWnd                      wnd;
   long                      lActionID = -2;
   IIManageDBPtr             pDb;
   _bstr_t                   wizard = pVS->get(L"Options.Wizard");
   _bstr_t                   undo;
   _bstr_t                   viewPreviousResults = pVS->get(L"MigrationDriver.ViewPreviousResults");
   bool						 bAnyToDispatch = true;
   long                      lAutoCloseHideDialogs = pVS->get(GET_BSTR(DCTVS_Options_AutoCloseHideDialogs));

   // if agent or dispatcher process still running...

   if (IsAgentOrDispatcherProcessRunning())
   {
      // return error result
      return MIGRATOR_E_PROCESSES_STILL_RUNNING;
   }

   hr = pDb.CreateInstance(__uuidof(IManageDB));

   if (FAILED(hr))
   {
      return hr;
   }

   gbCancelled = FALSE;
   // This provides an easy way to view the previous dispatch results
   if ( !UStrICmp(viewPreviousResults,GET_STRING(IDS_YES)) )
   {
      ViewPreviousDispatchResults();
      return S_OK;
   }

   if (_bstr_t(pVS->get(GET_BSTR(DCTVS_Options_DontBeginNewLog))) != GET_BSTR(IDS_YES))
   {
      // begin a new log
      TError err;
      err.LogOpen(_bstr_t(pVS->get(GET_BSTR(DCTVS_Options_Logfile))), 0, 0, true);
      err.LogClose();
   }

   // update the log level, if needed
   DWORD                level = 0;

   if( GetLogLevel(&level) )
   {
      pVS->put(GET_BSTR(DCTVS_Options_LogLevel),(long)level);
   }

   undo = pVS->get(GET_BSTR(DCTVS_Options_Undo));
//*   if ( !_wcsicmp((WCHAR*) undo, L"Yes") )
   if ( !_wcsicmp((WCHAR*) undo, GET_STRING(IDS_YES)) )
   {
      hr = pDb->raw_GetCurrentActionID(&lActionID);
      if ( SUCCEEDED(hr) )
         pVS->put(L"UndoAction", lActionID);
      hr = pDb->raw_GetNextActionID(&lActionID);
      hr = 0;
   }
   else
   {
      hr = pDb->raw_GetNextActionID(&lActionID);
      if ( SUCCEEDED(hr) )
      {
         pVS->put(L"ActionID",lActionID);
         _bstr_t password1 = pVS->get(GET_BSTR(DCTVS_Options_Credentials_Password));
         _bstr_t password2 = pVS->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));
      
         pVS->put(GET_BSTR(DCTVS_Options_Credentials_Password),L"");
         pVS->put(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),L"");

         hr = pDb->raw_SetActionHistory(lActionID, punkVarSet);
      
         pVS->put(GET_BSTR(DCTVS_Options_Credentials_Password),password1);
         pVS->put(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password),password2);
         if ( FAILED(hr) ) 
         {
            // log a message, but don't abort the whole operation
            hr = S_OK;
            //return hr;
         }
      }
   }
   // This sets up any varset keys needed internally for reports to be generated
   PreProcessForReporting(pVS);
   wnd.Attach((HWND)hWnd);
      //for scripting, we need to make sure we have the source domain sid in the varset
   RetrieveSrcDomainSid(pVS, pDb);

   // set preferred domain controllers to be used
   // by the account replicator and dispatched agents

   SetDomainControllers(pVS);

   // Run the local agent first, if needed to copy any accounts
   if ( NeedToRunLocalAgent(pVS) )
   {
      IDCTAgentPtr pAgent;

      hr = pAgent.CreateInstance(__uuidof(DCTAgent));

      if (SUCCEEDED(hr))
      {
         hr = pAgent->raw_SubmitJob(punkVarSet,&jobID);

         if ( SUCCEEDED(hr) )
         {
            CAgentDetailDlg  detailDlg(&wnd);
            
            detailDlg.SetJobID(jobID);
            detailDlg.SetFormat(1); // acct repl stats
            
            
            // if we're only copying a few accounts, default the refresh rate to a lower value, since the 
            // process may finish before the refresh can happen
            long             nAccounts = pVS->get(GET_BSTR(DCTVS_Accounts_NumItems));
            
            if ( nAccounts <= 20 )
            {
               detailDlg.SetRefreshInterval(1);
            }
            else
            {
               detailDlg.SetRefreshInterval(5);
            }

            _bstr_t        logfile = pVS->get(GET_BSTR(DCTVS_Options_Logfile));
            
            detailDlg.SetLogFile((WCHAR*)logfile);
            detailDlg.SetAutoCloseHide(lAutoCloseHideDialogs);

            UINT_PTR  nResponse = detailDlg.DoModal();
         }
      }
   } 
   if ( gbCancelled )
   {
      // if the local operation was cancelled, don't dispatch the agents
      wnd.Detach();
      return S_OK;
   }
   // now run the dispatcher
   if ( SUCCEEDED(hr) )
   {
      // there's no need to dispatch agents to do translation or migration 
      // if we were not able to copy the accounts
      if ( NeedToDispatch(pVS) )
      {
         IDCTDispatcherPtr   pDispatcher;

         hr = pDispatcher.CreateInstance(CLSID_DCTDispatcher);
         if ( SUCCEEDED(hr) )
         {
            // Call the dispatch preprocessor.
            PreProcessDispatcher(pVS);

            // make sure we're not going to lock out any computers by migrating them to a domain where they
            // don't have a good computer account
            TrimMigratingComputerList(pVS, &bAnyToDispatch);
            if (bAnyToDispatch)
			{
				CWorking          tempDlg(IDS_DISPATCHING);

				if (lAutoCloseHideDialogs == 0)
				{
					tempDlg.Create(IDD_PLEASEWAIT);
					tempDlg.ShowWindow(SW_SHOW);
				}
				// give the dialog a change to process messages
				CWnd                    * wnd = AfxGetMainWnd();
				MSG                       msg;

            // Call the dispatch preprocessor.
//	            PreProcessDispatcher(pVS);

				while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) ) 
				{ 
				   if ( ! AfxGetApp()->PumpMessage() ) 
				   {
				      break;
				   } 
				}
				AfxGetApp()->DoWaitCursor(0);
                  
				_bstr_t          logFile = pVS->get(GET_BSTR(DCTVS_Options_DispatchCSV));
				WCHAR            path[MAX_PATH] = L"";
            
				GetProgramDirectory(path);
               
				if ( logFile.length() == 0 )
				{
				   logFile = path;
				   logFile += L"Logs\\Dispatcher.csv";
				   pVS->put(GET_BSTR(DCTVS_Options_DispatchCSV),logFile);
				}
				// clear the CSV log file if it exists, so we will not get old information in it
				if ( ! DeleteFile(logFile) )
				{
				   hr = GetLastError();
				}
				// set up the location for the agents to write back their results
				logFile = path;
				logFile += L"Logs\\Agents";
				_bstr_t logsPath = path;
				logsPath += L"Logs";
				CreateDirectory(logsPath,NULL);
				if ( ! CreateDirectory(logFile,NULL) )
				{
				   DWORD rc = GetLastError();
				}
				pVS->put(GET_BSTR(DCTVS_Dispatcher_ResultPath),logFile);
            
//            if (bAnyToDispatch)
//			  {
				punkVarSet->AddRef();
				hr = pDispatcher->raw_DispatchToServers(&punkVarSet);
				if (lAutoCloseHideDialogs == 0)
				{
					tempDlg.ShowWindow(SW_HIDE);
				}
				if ( SUCCEEDED(hr) )
				{
					// reset the stats, so that we don't see anything left over from the previous run
					gData.Initialize();

					logFile = pVS->get(GET_BSTR(DCTVS_Options_DispatchCSV));

					if (lAutoCloseHideDialogs == 0)
					{
						CPropertySheet   mdlg;
						CAgentMonitorDlg listDlg;
						CMainDlg         summaryDlg;
						CLogSettingsDlg  settingsDlg;
						CString          title;

						title.LoadString(IDS_MainWindowTitle);

						listDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
						summaryDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;
						settingsDlg.m_psp.dwFlags |= PSP_PREMATURE | PSP_HASHELP;

						mdlg.AddPage(&summaryDlg);
						mdlg.AddPage(&listDlg);
						mdlg.AddPage(&settingsDlg);

						settingsDlg.SetImmediateStart(TRUE);
						settingsDlg.SetDispatchLog(logFile);

						// this determines whether the stats for security translation will be displayed in the agent detail
						if ( NeedToUseST(pVS,TRUE) ) 
						{
						  listDlg.SetSecurityTranslationFlag(TRUE);
						}
						else
						{
						  listDlg.SetSecurityTranslationFlag(FALSE);
						}

						if( !UStrICmp(wizard,L"reporting") )
						{
						  listDlg.SetReportingFlag(TRUE);
						}
						mdlg.SetActivePage(&listDlg);

						mdlg.SetTitle(title);

						UINT_PTR nResponse = mdlg.DoModal();
					}
					else
					{
						WaitForAgentsToFinish(logFile);
					}

			       // store results to database
			       TNodeListEnum        e;
			       TServerNode        * pNode;

			       // if we are retrying an operation, don't save it to the database again!
			       for ( pNode = (TServerNode*)e.OpenFirst(gData.GetUnsafeServerList()) ; pNode ; pNode = (TServerNode*)e.Next() )
			       {
			          if ( UStrICmp(wizard,L"retry") ) 
			          {
               
			             hr = pDb->raw_AddDistributedAction(SysAllocString(pNode->GetServer()),SysAllocString(pNode->GetJobPath()),pNode->GetStatus(),pNode->GetMessageText());
			             if ( FAILED(hr) )
			             {
			                hr = S_OK;
			             }
			          }
			          else
			          {
			             hr = pDb->raw_SetDistActionStatus(-1,pNode->GetJobPath(),pNode->GetStatus(),pNode->GetMessageText());
			             if ( FAILED(hr) )
			             {
			                hr = S_OK;
			             }
			          }
			       }
			    }
			}
			// Call the Dispatcher post processor
			PostProcessDispatcher(pVS);
		 }
      }
      if ( NeedToRunReports(pVS) )
      {
         RunReports(pVS);
      }
   }
   wnd.Detach();
   // Reset the undo flag so that next wizard does not have to deal with it.
//*   pVS->put(GET_BSTR(DCTVS_Options_Undo), L"No");
   pVS->put(GET_BSTR(DCTVS_Options_Undo), GET_BSTR(IDS_No));
   return hr;
}

STDMETHODIMP CMigrator::GetTaskDescription(IUnknown *pVarSet,/*[out]*/BSTR * pDescription)
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());
   
   IVarSetPtr                pVS = pVarSet;
   CString                   str;
   _bstr_t                   wizard = pVS->get(L"Options.Wizard");
   _bstr_t                   undo   = pVS->get(GET_BSTR(DCTVS_Options_Undo));
//*   if ( !_wcsicmp((WCHAR*) undo, L"Yes") )
   if ( !_wcsicmp((WCHAR*) undo, GET_STRING(IDS_YES)) )
   {
      str.FormatMessage(IDS_Undo);
      BuildGeneralDesc(pVS, str);
      BuildUndoDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"user") )
   {
      str.FormatMessage(IDS_UserMigration);
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"group") )
   {
      str.FormatMessage(IDS_GroupMigration);
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"computer") )
   {
      str.FormatMessage(IDS_ComputerMigration);
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
      BuildSecTransDesc(pVS,str,TRUE);
      BuildDispatchDesc(pVS,str);
  
   }
   else if ( !UStrICmp(wizard,L"security") )
   {
      str.FormatMessage(IDS_SecurityTranslation);
      BuildSecTransDesc(pVS,str,TRUE);
      BuildDispatchDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"reporting") )
   {
      str.FormatMessage(IDS_ReportGeneration);
      BuildReportDesc(pVS,str);
   }
   else if ( !UStrICmp(wizard,L"retry") )
   {
      str.FormatMessage(IDS_RetryTasks);
   }
   else if ( ! UStrICmp(wizard,L"service") )
   {
      str.FormatMessage(IDS_Service);
   }
   else if ( ! UStrICmp(wizard,L"trust") )
   {
      str.FormatMessage(IDS_TrustManagement);
   }
   else if ( !UStrICmp(wizard,L"exchangeDir") )
   {
      BuildSecTransDesc(pVS,str,TRUE);
   }
   else if ( !UStrICmp(wizard,L"groupmapping") )
   {
      BuildGeneralDesc(pVS,str);
      BuildAcctReplDesc(pVS,str);
      BuildGroupMappingDesc(pVS,str);
   }
   (*pDescription) = str.AllocSysString();
   return S_OK;
}



STDMETHODIMP CMigrator::GetUndoTask(IUnknown * pVarSet,/*[out]*/ IUnknown ** ppVarSetOut)
{
   HRESULT                   hr = S_OK;
   IVarSetPtr                pVarSetIn = pVarSet;
   IVarSetPtr                pVarSetOut;
   
   (*ppVarSetOut) = NULL;
   
   hr = pVarSetOut.CreateInstance(CLSID_VarSet);
   if ( SUCCEEDED(hr) )
   {
      hr = ConstructUndoVarSet(pVarSetIn,pVarSetOut);
      
      pVarSetOut->AddRef();
      (*ppVarSetOut) = pVarSetOut;
   }
    
   return hr;
}

HRESULT CMigrator::ProcessServerListForUndo(IVarSet * pVarSet)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   srcName;
   _bstr_t                   tgtName;
   WCHAR                     keySrc[100];
   WCHAR                     keyTgt[100];
   WCHAR                     keyTmp[100];
   long                      ndx,numItems;

   numItems = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));

   for ( ndx = 0 ; ndx < numItems ; ndx++ )
   {
      // if the computer was renamed, swap the source and target names
      swprintf(keySrc,GET_STRING(DCTVSFmt_Servers_D),ndx);
      swprintf(keyTgt,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),ndx);
      srcName = pVarSet->get(keySrc);
      tgtName = pVarSet->get(keyTgt);

      if ( tgtName.length() )
      {
         if ( ((WCHAR*)tgtName)[0] != L'\\' )
		   { 
            // ensure that tgtName has \\ prefix
            tgtName = L"\\\\" + tgtName;
         }
         if ( ((WCHAR*)srcName)[0] == L'\\' )
         {
            // remove the \\ prefix from the new name
            srcName = ((WCHAR*)srcName)+2;
         }
		   pVarSet->put(keySrc,tgtName);
         pVarSet->put(keyTgt,srcName);
      }
      swprintf(keyTmp,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),ndx);
      pVarSet->put(keyTmp,GET_BSTR(IDS_YES));
      swprintf(keyTmp,GET_STRING(IDS_DCTVSFmt_Servers_MigrateOnly_D),ndx);
      pVarSet->put(keyTmp,GET_BSTR(IDS_YES));
   }

   return hr;
}
HRESULT CMigrator::BuildAccountListForUndo(IVarSet * pVarSet,long actionID)
{
   HRESULT                   hr = S_OK;
   WCHAR                     key[200];
   long                      ndx;
   _bstr_t                   srcPath;
   IIManageDBPtr             pDB;
   IVarSetPtr                pVarSetTemp(CLSID_VarSet);
   IUnknown                * pUnk = NULL;

   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetTemp.QueryInterface(IID_IUnknown,&pUnk);
      if ( SUCCEEDED(hr) )
      {
         hr = pDB->raw_GetMigratedObjects(actionID,&pUnk);
      }
      if ( SUCCEEDED(hr) )
      {
         pUnk->Release();
         srcPath = L"Test";
         swprintf(key,L"MigratedObjects");
         long numMigrated = pVarSetTemp->get(key);
         for ( ndx = 0 ; srcPath.length() ; ndx++ )
         {
            swprintf(key,L"MigratedObjects.%d.%s",ndx,GET_STRING(DB_SourceAdsPath));
            srcPath = pVarSetTemp->get(key);

            if ( srcPath.length() )
            {
               // get the object type 
               swprintf(key,L"MigratedObjects.%d.%s",ndx,GET_STRING(DB_Type));
               _bstr_t text = pVarSetTemp->get(key);
               swprintf(key,L"Accounts.%ld.Type",ndx);

			      //work-around a fix that places the sourcepath for an
			      //NT 4.0 computer migration
			   if ((text != _bstr_t(L"computer")) || (wcsncmp(L"WinNT://", (WCHAR*)srcPath, 8)))
			   {
                  // set the object type in the account list
                  pVarSet->put(key,text);
                  // copy the source path to the account list
                  swprintf(key,L"Accounts.%ld",ndx);
                  pVarSet->put(key,srcPath);
                  // set the target path in the account list
                  swprintf(key,L"MigratedObjects.%d.%s",ndx,GET_STRING(DB_TargetAdsPath));
                  text = pVarSetTemp->get(key);
                  swprintf(key,L"Accounts.%ld.TargetName",ndx);
                  pVarSet->put(key,text);
			   }
            }
         }
         swprintf(key,GET_STRING(DCTVS_Accounts_NumItems));
         pVarSet->put(key,numMigrated);
      }
   }
   return hr;
}
HRESULT CMigrator::ConstructUndoVarSet(IVarSet * pVarSetIn,IVarSet * pVarSetOut)
{
   HRESULT                hr = S_OK;
   IVarSet              * pTemp = NULL;
   _bstr_t                origSource;
   _bstr_t                origTarget;
   _bstr_t                origSourceDns;
   _bstr_t                origTargetDns;
   _bstr_t                temp;
   _bstr_t                temp2;
   long                   actionID = pVarSetIn->get(L"ActionID");

   // general options
   // mark the varset as an undo operation
   pVarSetOut->put(GET_BSTR(DCTVS_Options_Undo),GET_BSTR(IDS_YES));
   
   temp = pVarSetIn->get(GET_BSTR(DCTVS_Options_NoChange));
   if ( !UStrICmp(temp,GET_STRING(IDS_YES)) )
   {
      // for a no-change mode operation, there's nothing to undo!
      return hr;
   }

   // swap the source and target domains
   origSource = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomain));
   origTarget = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomain));
   origSourceDns = pVarSetIn->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
   origTargetDns = pVarSetIn->get(GET_BSTR(DCTVS_Options_TargetDomainDns));

   temp = pVarSetIn->get(GET_BSTR(DCTVS_Options_Logfile));
   temp2 = pVarSetIn->get(GET_BSTR(DCTVS_Options_DispatchLog));
   
   pVarSetOut->put(GET_BSTR(DCTVS_Options_Logfile),temp);
   // For inter-forest, leave the domain names as they were
   pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origSource);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origTarget);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainDns),origSourceDns);
   pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainDns),origTargetDns);

   // copy the account list
   hr = pVarSetIn->raw_getReference(GET_BSTR(DCTVS_Accounts),&pTemp);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetOut->raw_ImportSubTree(GET_BSTR(DCTVS_Accounts),pTemp);
      if ( SUCCEEDED(hr) )
      {
         BuildAccountListForUndo(pVarSetOut,actionID);
      }
      pTemp->Release();
   }

   hr = pVarSetIn->raw_getReference(SysAllocString(L"AccountOptions"),&pTemp);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetOut->raw_ImportSubTree(SysAllocString(L"AccountOptions"),pTemp);
      pTemp->Release();
   }

   // and the server list
   hr = pVarSetIn->raw_getReference(GET_BSTR(DCTVS_Servers),&pTemp);
   if ( SUCCEEDED(hr) )
   {
      hr = pVarSetOut->raw_ImportSubTree(GET_BSTR(DCTVS_Servers),pTemp);
      if ( SUCCEEDED(hr) )
      {
         ProcessServerListForUndo(pVarSetOut);
         pTemp->Release();
      }
   }

   LONG                       bSameForest = FALSE;
   MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr          pAccess;
   
   hr = pAccess.CreateInstance(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));

   if ( SUCCEEDED(hr) )
   {
      hr = pAccess->raw_IsInSameForest(origSourceDns,origTargetDns,&bSameForest);
      if ( hr == 8250 )
      {
         hr = 0;
         bSameForest = FALSE;
      }
   }
   if ( SUCCEEDED(hr) )
   {
      // for account migration, need to check whether we're cloning, or moving accounts
      if ( ! bSameForest ) // cloning accounts
      {
         // Since we cloned the accounts we need to delete the target accounts.
         // We will call the account replicator to do this. We will also call 
         // the undo function on all the registered extensions. This way the extensions
         // will have a chance to cleanup after themselves in cases of UNDO.
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origSource);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origTarget);
      }
      else     // moving, using moveObject
      {
         // swap the source and target, and move them back, using the same options as before
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origTarget);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origSource);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomainDns),origTargetDns);
         pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomainDns),origSourceDns);


      }
   }
   // if migrating computers, swap the source and target domains, and call the dispatcher again to move them back to the source domain
   _bstr_t           comp = pVarSetIn->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(comp,GET_STRING(IDS_YES)) )
   {
      pVarSetOut->put(GET_BSTR(DCTVS_Options_SourceDomain),origTarget);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_TargetDomain),origSource);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_DispatchLog),temp2);
      pVarSetOut->put(GET_BSTR(DCTVS_Options_Wizard),L"computer");
   }
   
   // security translation - don't undo


   return S_OK;
}

HRESULT CMigrator::SetReportDataInRegistry(WCHAR const * reportName,WCHAR const * filename)
{
   TRegKey                   hKeyReports;
   DWORD                     rc;

   rc = hKeyReports.Open(GET_STRING(IDS_REGKEY_REPORTS));
 
   // if the "Reports" registry key does not already exist, create it
   if ( rc == ERROR_FILE_NOT_FOUND )
   {
      rc = hKeyReports.Create(GET_STRING(IDS_REGKEY_REPORTS));   
   }
   if ( ! rc )
   {
      rc =  hKeyReports.ValueSetStr(reportName,filename);
   }
   return HRESULT_FROM_WIN32(rc);
}   

HRESULT CMigrator::RunReports(IVarSet * pVarSet)
{
   HRESULT                   hr = S_OK;
   _bstr_t                   directory = pVarSet->get(GET_BSTR(DCTVS_Reports_Directory));
   _bstr_t					 srcdm = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t					 tgtdm = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
   _bstr_t					 srcdomainDNS = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
   long                      lAutoCloseHideDialogs = pVarSet->get(GET_BSTR(DCTVS_Options_AutoCloseHideDialogs));
   IIManageDBPtr             pDB;
   int						 ver;
   BOOL					     bNT4Dom = FALSE;
   CWorking					 tempDlg(IDS_NAMECONFLICTS);
   CWnd                    * wnd = NULL;
   MSG                       msg;

   if (lAutoCloseHideDialogs == 0)
   {
      tempDlg.Create(IDD_PLEASEWAIT);

      tempDlg.ShowWindow(SW_SHOW);
      tempDlg.m_strMessage.LoadString(IDS_STATUS_GeneratingReports);
      tempDlg.UpdateData(FALSE);

      wnd = AfxGetMainWnd();

      while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) ) 
      { 
         if ( ! AfxGetApp()->PumpMessage() ) 
         {
            break;
         } 
      }
      AfxGetApp()->DoWaitCursor(0);
   }


      //get the source domain OS version
   ver = GetOSVersionForDomain(srcdomainDNS);
   if (ver < 5)
	  bNT4Dom = TRUE;

   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {

      // Migrated users and groups report
      _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedAccounts));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the migrated users and groups report
         CString           filename;

         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"MigrAcct.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"MigratedAccounts"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"MigratedAccounts",filename);
         }

      }
      
      // migrated computers report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedComputers));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the migrated computers report
         CString           filename;

         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"MigrComp.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"MigratedComputers"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"MigratedComputers",filename);
         }

      }

      // expired computers report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_ExpiredComputers));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the expired computers report
         CString           filename;

         // clear the extra settings from the varset 
         pVarSet->put(GET_BSTR(DCTVS_GatherInformation_ComputerPasswordAge),SysAllocString(L""));

         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"ExpComp.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"ExpiredComputers"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"ExpiredComputers",filename);
         }

      }

          // account references report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_AccountReferences));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // run the account references report
         CString           filename;
         filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"AcctRefs.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"AccountReferences"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"AccountReferences",filename);
         }
         // clear the extra settings from the varset
         pVarSet->put(GET_BSTR(DCTVS_Security_GatherInformation),GET_BSTR(IDS_No));
         pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences),GET_BSTR(IDS_No));
      }

      // name conflict report
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_NameConflicts));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         if (lAutoCloseHideDialogs == 0)
         {
            AfxGetApp()->DoWaitCursor(1);
            // run the name conflicts report
            tempDlg.m_strMessage.LoadString(IDS_STATUS_Gathering_NameConf);
            tempDlg.UpdateData(FALSE);

            while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) )
            {
               if ( ! AfxGetApp()->PumpMessage() )
               {
                  break;
               }
            }
         }

		    //fill the account table in the database
         PopulateDomainDBs(pVarSet);

         if (lAutoCloseHideDialogs == 0)
         {
            tempDlg.m_strMessage.LoadString(IDS_STATUS_GeneratingReports);
            tempDlg.UpdateData(FALSE);

            while ( wnd &&  PeekMessage( &msg, wnd->m_hWnd, 0, 0, PM_NOREMOVE ) ) 
            { 
               if ( ! AfxGetApp()->PumpMessage() ) 
               {
                  break;
               } 
            }
            AfxGetApp()->DoWaitCursor(0);
         }

         CString filename = (WCHAR*)directory;
         if ( filename[filename.GetLength()-1] != L'\\' )
            filename += L"\\";
         filename += L"NameConf.htm";
         
         hr = pDB->raw_GenerateReport(SysAllocString(L"NameConflicts"),filename.AllocSysString(), srcdm, tgtdm, bNT4Dom);
         if ( SUCCEEDED(hr) )
         {
            SetReportDataInRegistry(L"NameConflicts",filename);
         }
      }

      if (lAutoCloseHideDialogs == 0)
      {
         tempDlg.ShowWindow(SW_HIDE);
      }
   }

   if (lAutoCloseHideDialogs == 0)
   {
      AfxGetApp()->DoWaitCursor(-1);
   }

   return hr;
}

//--------------------------------------------------------------------------
// PreProcessDispatcher : Pre processor swaps the source and target domains
//                        in case of UNDO so that the computers can be 
//                        joined back to the source domain.
//--------------------------------------------------------------------------
void CMigrator::PreProcessDispatcher(IVarSet * pVarSet)
{
   _bstr_t  sUndo = pVarSet->get(L"Options.Wizard");
   
   // In the service account migration wizard, turn off any security translation tasks
   if ( !_wcsicmp(sUndo,L"service") )
   {
      IVarSet * pVS2 = NULL;
      
      HRESULT hr = pVarSet->raw_getReference(L"Security",&pVS2);
      if ( SUCCEEDED(hr) )
      {
         pVS2->Clear();
         pVS2->Release();
      }
   }
}

//--------------------------------------------------------------------------
// PostProcessDispatcher : Swaps the source and target domains back. Also sets
//                         the Undo option to no.
//--------------------------------------------------------------------------
void CMigrator::PostProcessDispatcher(IVarSet * pVarSet)
{
   _bstr_t  sUndo = pVarSet->get(L"Options.Wizard");
   _bstr_t  origSource = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t  origTarget = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
   if ( !_wcsicmp(sUndo, L"undo") )
   {
      pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomain), origTarget);
      pVarSet->put(GET_BSTR(DCTVS_Options_TargetDomain), origSource);
   }
}

void CMigrator::PreProcessForReporting(IVarSet * pVarSet)
{
   _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Reports_Generate));

   IVarSet * pVs = NULL;

   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      // we are generating reports
      // some reports require additional information gathering.  We will set up the necessary varset
      // keys to gather the information
      text = pVarSet->get(GET_BSTR(DCTVS_Reports_ExpiredComputers));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)))
      {
         // we need to gather the computer password age from the computers in the domain
         pVarSet->put(GET_BSTR(DCTVS_GatherInformation_ComputerPasswordAge),GET_BSTR(IDS_YES));
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Reports_AccountReferences));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)))
      {
         // clean up all the Security translation flags so that we dont end up doing 
         // something that we were not supposed to.
         HRESULT hr = pVarSet->raw_getReference(GET_BSTR(DCTVS_Security), &pVs);
         if ( pVs )
         {
            pVs->Clear();
            pVs->Release();
         }
         // for this one, we need to gather information from the selected computers
         pVarSet->put(GET_BSTR(DCTVS_Security_GatherInformation),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_ReportAccountReferences),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateFiles),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateShares),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslatePrinters),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateLocalGroups),GET_BSTR(IDS_YES));
         pVarSet->put(GET_BSTR(DCTVS_Security_TranslateRegistry),GET_BSTR(IDS_YES));
      }
   }
}

HRESULT CMigrator::TrimMigratingComputerList(IVarSet * pVarSet, bool* bAnyToDispatch)
{
   // this functions checks each computer to be migrated, and does not migrate it if the account was not successfully copied
   HRESULT                   hr = S_OK;
   _bstr_t                   text;
   WCHAR                     key[100];
   long                      val,i;
   IIManageDBPtr             pDB;
   _bstr_t                   srcDomain;
   _bstr_t                   tgtDomain;
   _bstr_t                   computer;
   long                      actionID = pVarSet->get(L"ActionID");
   CString                   temp;

   _bstr_t                   origSource = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t                   origTarget = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

   *bAnyToDispatch = false;
   text = pVarSet->get(GET_BSTR(DCTVS_Options_Undo));
   if (! UStrICmp(text,GET_STRING(IDS_YES)))
   {
      // don't trim on undo's, just reverse the domain affiliations
//      return S_OK;
	  bool bFound = false;
	  long numServers = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
		//for each server, see if it is in the account list (only successfully
		//migrated computers are listed in the account list)
	  for (i = 0; i < numServers; i++)
	  {
		 bFound = false;
			//get this servers name
		 swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);
		 text = pVarSet->get(key);
			//get rid of leading "\\"
		 temp = (WCHAR*)text;
		 wcscpy((WCHAR*)text, temp.Right(temp.GetLength()-2));
		 long numAccts = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
			//see if that name is in the accounts list
		 _bstr_t                   text2;
		 for (val = 0; ((val < numAccts) && (!bFound)); val++)
		 {
			swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),val);
			text2 = pVarSet->get(key);
				//W2K machine accounts are LDAP paths, so check for the actual name
				//in that path and compare with it
			if ( !wcsncmp(L"LDAP://", text2, 7))
			{
				CString sAccount = (WCHAR*)text2;
				int nIndex;
				if ((nIndex = sAccount.Find(L"/CN=")) != -1)//if found
				{
					sAccount = sAccount.Right(sAccount.GetLength() - nIndex - wcslen(L"/CN="));
					if ((nIndex = sAccount.Find(L',')) != -1)
						text2 = sAccount.Left(nIndex);
				}
			}
			if (! UStrICmp((WCHAR*)text,(WCHAR*)text2))
				bFound = true;
		 }

		 swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
		 if (!bFound)
			pVarSet->put(key,GET_BSTR(IDS_YES));
		 else
		 {
			*bAnyToDispatch = true;
			pVarSet->put(key,GET_BSTR(IDS_No));
		 }
	  }
      return S_OK;
   }
   text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
   if (! UStrICmp(text,GET_STRING(IDS_YES)))
   {
      // don't need to trim in nochange mode
      *bAnyToDispatch = true; //say yes run dispatcher if Nochange
      return S_OK;
   }
   hr = pDB.CreateInstance(CLSID_IManageDB);
   if ( FAILED(hr) )
   {
      return hr;
   }
   srcDomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   tgtDomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
   *bAnyToDispatch = false; //indicate that so far no accounts to dispatch

   val = pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
   
   for ( i = 0 ; i < val ; i++ )
   {
	   //init the skipDispath flag to "No"
      swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
      pVarSet->put(key,GET_BSTR(IDS_No));

      swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);
      computer = pVarSet->get(key);

      swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),i);
      text = pVarSet->get(key);
      if (! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         // we are migrating this computer to a different domain
         // check our database to verify that the computer account has been
         // successfully migrated
         computer += L"$";
         
         IVarSetPtr          pVS(CLSID_VarSet);
         IUnknown          * pUnk = NULL;

         hr = pVS->QueryInterface(IID_IUnknown,(void**)&pUnk);
         if ( SUCCEEDED(hr) )
         {
            if ( ((WCHAR*)computer)[0] == L'\\' )
            {
               // leave off the leading \\'s 
               hr = pDB->raw_GetAMigratedObject(SysAllocString(((WCHAR*)computer) + 2),srcDomain,tgtDomain,&pUnk);  
            }
            else
            {
               hr = pDB->raw_GetAMigratedObject(computer,srcDomain,tgtDomain,&pUnk);
            }
            if ( hr == S_OK )
            {
               // the computer was found in the migrated objects table
               // make sure we are using its correct target name, if it has been renamed
               swprintf(key,L"MigratedObjects.TargetSamName");
               _bstr_t targetName = pVS->get(key);
               swprintf(key,L"MigratedObjects.SourceSamName");
               _bstr_t sourceName = pVS->get(key);
               long id = pVS->get(L"MigratedObjects.ActionID");

               if ( UStrICmp((WCHAR*)sourceName,(WCHAR*)targetName) )
               {
                  // the computer is being renamed
                  swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_RenameTo_D),i);
                  // strip off the $ from the end of the target name, if specified
                  WCHAR             target[LEN_Account];

                  safecopy(target,(WCHAR*)targetName);

                  if ( target[UStrLen(target)-1] == L'$' )
                  {
                     target[UStrLen(target)-1] = 0;
                  }
                  pVarSet->put(key,target);
               }
                  
			   if ( id != actionID )
               {
                   // the migration failed, but this computer had been migrated before
                   // don't migrate the computer because it's account in the target domain, won't be reset
                   // and it will therefore be locked out of the domain
				  swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_ChangeDomain_D),i);
                  pVarSet->put(key,GET_BSTR(IDS_No));
                  swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),i);
                  pVarSet->put(key,GET_BSTR(IDS_No));
				  swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
				  pVarSet->put(key,GET_BSTR(IDS_YES));
               }
			   else
			     *bAnyToDispatch = true; //atleast one server for dispatcher

            }
            else
            {
               // the computer migration failed!
               // don't migrate the computer because it won't have it's account in the target domain,
               // and will therefore be locked out of the domain
               pVarSet->put(key,GET_BSTR(IDS_No));
               swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_Reboot_D),i);
               pVarSet->put(key,GET_BSTR(IDS_No));
			   swprintf(key,GET_STRING(IDS_DCTVSFmt_Servers_SkipDispatch_D),i);
			   pVarSet->put(key,GET_BSTR(IDS_YES));
           }
            pUnk->Release();
         }
      }
	  else
	     *bAnyToDispatch = true; //atleast one server for dispatcher
   }
   
   return hr;
}

HRESULT CMigrator::PopulateAccounts(IVarSetPtr pVs)
{
   _bstr_t  origSource = pVs->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t  origTarget = pVs->get(GET_BSTR(DCTVS_Options_TargetDomain));

   // Check if the source domain is NT4 or win2k
   // if NT4 then call the NetObjEnum to enumerate the domain. 
   return S_OK;
}

//----------------------------------------------------------------------------
// PopulateDomainDBs : This function coordinates the populating of the Access
//                     DBs for both the source and target domains with the
//                     necessary fields from the AD. 
//----------------------------------------------------------------------------
bool CMigrator::PopulateDomainDBs(
                              IVarSet * pVarSet      //in- varset with domain names.
                            )
{
/* local variables */
	_bstr_t srcdomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
	_bstr_t tgtdomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
	_bstr_t srcdomainDNS = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
	_bstr_t tgtdomainDNS = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainDns));

/* function body */
	//populate the DB for the source domain
   PopulateADomainDB(srcdomain, srcdomainDNS, TRUE);
	//populate the DB for the target domain
   PopulateADomainDB(tgtdomain, tgtdomainDNS, FALSE);

   return true;
}

//----------------------------------------------------------------------------
// PopulateADomainDB : This function looks up the necessary fields from the AD, 
//                    using an MCSNetObjectEnum object, for the given domain 
//                    and populates the corresponding Access DB with that info. 
//----------------------------------------------------------------------------
bool CMigrator::PopulateADomainDB(
							           WCHAR const *domain,       // in- NetBIOS name of domain to enumerate
							           WCHAR const *domainDNS,    // in- DSN name of domain to enumerate
									   BOOL bSource
                                 )
{
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   IIManageDBPtr             pDb;
   WCHAR                     sPath[MAX_PATH];
   WCHAR                     sQuery[MAX_PATH];
   LPWSTR                    sData[] = { L"sAMAccountName", L"ADsPath" };
   HRESULT                   hr;
   long                      nElt = DIM(sData);
// int						 nobjectType;
   BSTR  HUGEP             * pData = NULL;
   SAFEARRAY               * pszColNames;
   IEnumVARIANT            * pEnum = NULL;
   _variant_t                var;
   DWORD                     dwFetch = 1;
   bool						 bSuccess = false;
   BSTR                      iterator[] = { L"USER", L"GROUP", L"COMPUTER" };
   int                       i = 0;
   int                       ver = 0;
   bool						 bW2KDom = false;

   // create instance of database manager

   hr = pDb.CreateInstance(__uuidof(IManageDB));

   if (FAILED(hr))
      return false;

   if ( bSource )
      pDb->raw_ClearTable(L"SourceAccounts");
   else
      pDb->raw_ClearTable(L"TargetAccounts");

   pDb->raw_OpenAccountsTable(bSource);

   ver = GetOSVersionForDomain(domainDNS);

   // iterate three times once to get USERS, GROUPS, COMPUTERS (mainly for WinNT)
   while ( i < 3 )
   {
      // Set the LDAP path to the whole domain and then the query everything
      if ( ver > 4 )
      {
         wsprintf(sPath, L"LDAP://%s", domainDNS);
         wsprintf(sQuery, L"(objectClass=%s)", (WCHAR*) iterator[i]);
		 bW2KDom = true;
      }
      else
      { 
         wsprintf(sPath, L"CN=%sS", (WCHAR*)iterator[i]);
         wcscpy(sQuery, L"(objectClass=*)");
		 bW2KDom = false;
      }

      // Set the enumerator query
      hr = pQuery->raw_SetQuery(sPath, const_cast<WCHAR*>(domainDNS), sQuery, ADS_SCOPE_SUBTREE, FALSE);

      if (SUCCEEDED(hr))
      {
         // Create a safearray of columns we need from the enumerator.
         SAFEARRAYBOUND bd = { nElt, 0 };
   
         pszColNames = ::SafeArrayCreate(VT_BSTR, 1, &bd);
         HRESULT hr = ::SafeArrayAccessData(pszColNames, (void HUGEP **)&pData);
         if ( SUCCEEDED(hr) )
         {
            for( long i = 0; i < nElt; i++)
            {
               pData[i] = SysAllocString(sData[i]);
            }
   
            hr = ::SafeArrayUnaccessData(pszColNames);
         }

         if (SUCCEEDED(hr))
         {
            // Set the columns on the enumerator object.
            hr = pQuery->raw_SetColumns(pszColNames);
         }
      }

      if (SUCCEEDED(hr))
      {
         // Now execute.
         hr = pQuery->raw_Execute(&pEnum);
      }

	     //while we have more enumerated objects, get the enumerated fields
	     //for that object, save them in local variables, and add them to
	     //the appropriate DB
      HRESULT  hrEnum = S_OK;
      while (hrEnum == S_OK && dwFetch > 0)
      {
          //get the enumerated fields for this current object
         hrEnum = pEnum->Next(1, &var, &dwFetch);

         if ( dwFetch > 0 && hrEnum == S_OK && ( var.vt & VT_ARRAY) )
         {
			_bstr_t					sAdsPath;
			_bstr_t					sDN = L"";
			_bstr_t					sSAMName;
			_bstr_t					sRDN = L"";
			_bstr_t					sCanonicalName = L"";
			_bstr_t					sObjectClass;
			BOOL					bSave = TRUE;

            // We now have a Variant containing an array of variants so we access the data
            _variant_t		* pVar;
            pszColNames = V_ARRAY(&var);
            SafeArrayAccessData(pszColNames, (void HUGEP **)&pVar);

            //get the sAMAccountName field
            sSAMName = pVar[0].bstrVal;

			//create an RDN from the SAM name, will be replaced below with real RDN
			//if not NT4.0 source domain
			sRDN = L"CN=" + sSAMName;

            //get the ADsPath field
            sAdsPath = pVar[1].bstrVal;

            //get the objectClass field
            sObjectClass = (WCHAR*) iterator[i];

            SafeArrayUnaccessData(pszColNames);

				//for W2K domains, computers get enumerated twice, once as a computer
				//and once as a user, so for any item of type computer we will not add
				//it to the database, place the computer account name in a string list,
				//and when we see that name again change it's type from user to computer.
				//this code assumes the enumeration above enumerates users prior to computers
			if (bW2KDom)
			{
				/* for W2K domain, get the RDN and Canonical Name of this object */
				   //connect to the object
				IADs		* pAds = NULL;
				hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
				if ( SUCCEEDED(hr) )
				{
					  //get the CN
                   BSTR  sName = NULL;
                   hr = pAds->get_Name(&sName);
                   if (SUCCEEDED(hr))
					  sRDN = _bstr_t(sName, false);
				      //get the DN
				   _variant_t varDN;
                   hr = pAds->Get(L"distinguishedName", &varDN);
                   if (SUCCEEDED(hr))
					  sDN = varDN.bstrVal;
				   pAds->Release();
				}

				   //convert from DN to canonical name
				if (sDN.length())
				{
				   HANDLE  hDs = NULL;
				      //bind to the domain
                   hr = DsBind(NULL, domainDNS, &hDs);
                   if (SUCCEEDED(hr))
				   {
                      PDS_NAME_RESULT         pNamesOut = NULL;
                      WCHAR                 * pNamesIn[1];

                      pNamesIn[0] = (WCHAR *)sDN;

					     //convert the name
                      hr = DsCrackNames(hDs,
										DS_NAME_FLAG_SYNTACTICAL_ONLY,
										DS_FQDN_1779_NAME,
										DS_CANONICAL_NAME,
										1,
										pNamesIn,
										&pNamesOut);
	                  DsUnBind(&hDs); //unbind
                      if (SUCCEEDED(hr))
					  {
 					        //if name converted, get it
                         if (pNamesOut->rItems[0].status == DS_NAME_NO_ERROR)
				            sCanonicalName = pNamesOut->rItems[0].pName;
		                 DsFreeNameResult(pNamesOut); //release the buffer
					  }
				   }//end if Bound
				}//end if got DN

				/* adjust for computer issue */
					//if computer, delete from user list so it will not be created again later
				if (!_wcsicmp((WCHAR*)sObjectClass, L"computer"))
					DeleteItemFromList(sSAMName);

					//if user see if the name is in the computer list, if so,
					//don't store in database
				if ((!_wcsicmp((WCHAR*)sObjectClass, L"user")) && (((WCHAR*)sSAMName)[sSAMName.length() - 1] == L'$'))
				{
						//store fields for database entry in struct for later inclusion
					DATABASE_ENTRY aListItem;
					aListItem.m_domain = domain;
					aListItem.m_sSAMName = sSAMName;
					aListItem.m_sObjectClass = sObjectClass;
					aListItem.m_sRDN = sRDN;
					aListItem.m_sCanonicalName = sCanonicalName;
					aListItem.m_bSource = bSource;

					mUserList.AddTail(aListItem); //add item to user list
					bSave = FALSE;
				}
			}

             //use the  DBManager Interface to store this object's fields
             //in the appropriate database
			if (bSave)
			{
				hr = pDb->raw_AddSourceObject(const_cast<WCHAR*>(domain), sSAMName, sObjectClass, sRDN, sCanonicalName, bSource);
				if ( FAILED(hr) )
				   int x = 0;
			}
            VariantInit(&var);
         }
      }
   
      if ( pEnum ) pEnum->Release();
      i++;
   }  // while
   
	//add each user in the user list to the database since it was not
	//matched with a computer name already entered
   POSITION pos = mUserList.GetHeadPosition();
   DATABASE_ENTRY aListItem;
   while (pos != NULL)
   {
		aListItem = mUserList.GetNext(pos);
		hr = pDb->raw_AddSourceObject(aListItem.m_domain, 
									  aListItem.m_sSAMName, 
									  aListItem.m_sObjectClass, 
									  aListItem.m_sRDN, 
									  aListItem.m_sCanonicalName, 
									  aListItem.m_bSource);
		if ( FAILED(hr) )
		   int x = 0;
   }
	
   mUserList.RemoveAll();

   pDb->raw_CloseAccountsTable();
   return SUCCEEDED(hr);
}
                         
DWORD CMigrator::GetOSVersionForDomain(WCHAR const * domain)
{
   // Load DsGetDcName dynamically
   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   WKSTA_INFO_100          * pInfo = NULL;
   DWORD             retVal = 0;
   DSGETDCNAME DsGetDcName = NULL;

   HMODULE hPro = LoadLibrary(L"NetApi32.dll");
   if ( hPro )
   {
      DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
	   if ( DsGetDcName )
	   {
		  DWORD rc = DsGetDcName(
								  NULL                                  ,// LPCTSTR ComputerName ?
								  const_cast<WCHAR*>(domain)            ,// LPCTSTR DomainName
								  NULL                                  ,// GUID *DomainGuid ?
								  NULL                                  ,// LPCTSTR SiteName ?
								  0                                     ,// ULONG Flags ?
								  &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
							   );

		  if ( !rc ) 
		  {
			 rc = NetWkstaGetInfo(pSrcDomCtrlInfo->DomainControllerName,100,(LPBYTE*)&pInfo);
			  if ( ! rc )
			  {
				  retVal = pInfo->wki100_ver_major;
				  NetApiBufferFree(pInfo);
			  }

			 NetApiBufferFree(pSrcDomCtrlInfo);
		  }
	   }

	   FreeLibrary(hPro);
   }
   return retVal;
}

BOOL CMigrator::DeleteItemFromList(WCHAR const * aName)
{
	DATABASE_ENTRY aListItem;
	CString itemName;
	POSITION pos, lastpos;
	BOOL bFound = FALSE;

	pos = mUserList.GetHeadPosition();
	while ((pos != NULL) && (!bFound))
	{
		lastpos = pos;
		aListItem = mUserList.GetNext(pos);
		itemName = (WCHAR*)(aListItem.m_sSAMName);
		if (itemName == aName)
		{
			mUserList.RemoveAt(lastpos);
			bFound = TRUE;
		}
	}
	return bFound;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for opening the sid mapping file *
 * whether it is anm ANSI or UNICODE file and return the file        *
 * pointer.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveSrcDomainSid
void CMigrator::RetrieveSrcDomainSid(
                              IVarSet * pVarSet,     //in- varset with domain names.
							  IIManageDBPtr pDb      //in - pointer to the DB manager class
                            )
{
/* local variables */
   IVarSetPtr  pVarSetTemp(CLSID_VarSet);
   IUnknown  * pUnk = NULL;
   HRESULT hr;
   WCHAR key[200];
   _bstr_t srcdomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t sSrcDomain;

/* function body */
   hr = pVarSetTemp.QueryInterface(IID_IUnknown,&pUnk);
   if ( SUCCEEDED(hr) )
   {
      hr = pDb->raw_GetMigratedObjects(-1,&pUnk);
   }
   if ( SUCCEEDED(hr) )
   {
      pUnk->Release();
      long lCnt = pVarSetTemp->get("MigratedObjects");
	  bool bFound = false;
	  for ( long l = 0; (l < lCnt) && (!bFound); l++)
      {
            //get the source domain
		 swprintf(key,L"MigratedObjects.%ld.%s",l,GET_STRING(DB_SourceDomain));
         sSrcDomain = pVarSetTemp->get(key);
			//if source domain matches, see if the sid was stored
	     if (!UStrICmp((WCHAR*)srcdomain, (WCHAR*)sSrcDomain))
		 {
		       //get the source domain Sid
            swprintf(key,L"MigratedObjects.%ld.%s",l,GET_STRING(DB_SourceDomainSid));
			_variant_t varSid = pVarSetTemp->get(key);
			if (varSid.vt != VT_NULL)
			{
               _bstr_t txtSid = pVarSetTemp->get(key);
               pVarSet->put(GET_BSTR(DCTVS_Options_SourceDomainSid),txtSid);
			   bFound = true;
			}
		 }
      }
   }
}//END RetrieveSrcDomainSid


// IsAgentOrDispatcherProcessRunning

bool __stdcall IsAgentOrDispatcherProcessRunning()
{
	bool bIsRunning = true;

	CMigrationMutex mutexAgent(AGENT_MUTEX);
	CMigrationMutex mutexDispatcher(DISPATCHER_MUTEX);

	if (mutexAgent.ObtainOwnership(30000) && mutexDispatcher.ObtainOwnership(30000))
	{
		bIsRunning = false;
	}

	return bIsRunning;
}


// SetDomainControllers
//
// Sets preferred domain controllers to be used
// by the account replicator and dispatched agents

void __stdcall SetDomainControllers(IVarSetPtr& spVarSet)
{
	// set source domain controller

	_bstr_t strSourceServer = spVarSet->get(GET_BSTR(DCTVS_Options_SourceServerOverride));

	if (strSourceServer.length() == 0)
	{
		_bstr_t strSourceDomain = spVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));

		PDOMAIN_CONTROLLER_INFO pdci;

		DWORD dwError = DsGetDcName(
			NULL,
			strSourceDomain,
			NULL,
			NULL,
			DS_IS_FLAT_NAME|DS_RETURN_FLAT_NAME,
			&pdci
		);

		if (dwError == ERROR_SUCCESS)
		{
			strSourceServer = pdci->DomainControllerName;

			NetApiBufferFree(pdci);
		}
	}

	spVarSet->put(GET_BSTR(DCTVS_Options_SourceServer), strSourceServer);

	// set target domain controller

	_bstr_t strTargetServer = spVarSet->get(GET_BSTR(DCTVS_Options_TargetServerOverride));

	if (strTargetServer.length() == 0)
	{
		_bstr_t strTargetDomain = spVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

		PDOMAIN_CONTROLLER_INFO pdci;

		DWORD dwError = DsGetDcName(
			NULL,
			strTargetDomain,
			NULL,
			NULL,
			DS_IS_FLAT_NAME|DS_RETURN_FLAT_NAME,
			&pdci
		);

		if (dwError == ERROR_SUCCESS)
		{
			strTargetServer = pdci->DomainControllerName;

			NetApiBufferFree(pdci);
		}
	}

	spVarSet->put(GET_BSTR(DCTVS_Options_TargetServer), strTargetServer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\monitor.cpp ===
/*---------------------------------------------------------------------------
  File: Monitor.cpp  

  Comments: Functions to monitor the status of the DCT Agents.

  This involves spawning a thread which periodically reads the dispatch log,
  and scans the result directory for result files.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/15/99 15:43:35

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Resource.h"
#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "TNode.hpp"
#include "ServList.hpp"
#include "Globals.h"
#include "Monitor.h"
#include "ResStr.h"
#include <lm.h>  // to remove result share


//#import "\bin\McsVarSetMin.tlb" no_namespace , named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace , named_guids rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids

//#include "..\Common\Include\McsPI.h"
#include "McsPI.h"
#include "McsPI_i.c"

#include "afxdao.h"

void LookForResults(WCHAR * dir = NULL);
void WaitForMoreResults(WCHAR * dir);
void ProcessResults(TServerNode * pServer, WCHAR const * directory, WCHAR const * filename);

GlobalData        gData;

DWORD __stdcall ResultMonitorFn(void * arg)
{
   WCHAR            logdir[MAX_PATH] = L"";
   BOOL             bFirstPassDone;

   CoInitialize(NULL);
   
   gData.GetFirstPassDone(&bFirstPassDone);

   // wait until the other monitoring thread has  a chance to build the server list,
   // so we can check for pre-existing input files before using the changenotify mechanism
   
   while ( ! bFirstPassDone || !*logdir )
   {
      Sleep(500);
      gData.GetFirstPassDone(&bFirstPassDone);
      gData.GetResultDir(logdir);
   }
   LookForResults(logdir);
   WaitForMoreResults(logdir);

   CoUninitialize();

   return 0;
}

void WaitForMoreResults(WCHAR * logdir)
{
   WCHAR                     resultWC[MAX_PATH];
   HANDLE                    hFind;
   DWORD                     rc = 0;
   BOOL                      bDone;
   long                      nIntervalSeconds;

   safecopy(resultWC,logdir);
      
   hFind = FindFirstChangeNotification(resultWC,FALSE,FILE_NOTIFY_CHANGE_FILE_NAME);
   if ( hFind == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      return;
   }
   
   gData.GetDone(&bDone);
   gData.GetWaitInterval(&nIntervalSeconds);
   while (! bDone && !rc)
   {
      if ( WAIT_OBJECT_0 == WaitForSingleObject(hFind,nIntervalSeconds * 1000 ) )
      {
         LookForResults(logdir);
      }
      else
      {
         LookForResults(logdir);
      }
      if ( ! FindNextChangeNotification(hFind) )
      {
         rc = GetLastError();
      }
      gData.GetDone(&bDone);
      gData.GetWaitInterval(&nIntervalSeconds);
   }
   
   FindCloseChangeNotification(hFind);
}


void LookForResults(WCHAR * arglogdir)
{
   TNodeListEnum             e;
   TServerNode             * s;
   DWORD                     nInstalled = 0;
   DWORD                     nRunning = 0;
   DWORD                     nFinished = 0;
   DWORD                     nError = 0;
   HWND                      gListWnd;
   HWND                      gSummaryWnd;
   WCHAR                     logdir[MAX_PATH];

   if ( ! (arglogdir && *arglogdir) )
   {
      gData.GetResultDir(logdir);
   }
   else
   {
      safecopy(logdir,arglogdir);
   }
   
   for ( s = (TServerNode*)e.OpenFirst(gData.GetUnsafeServerList()) ; s ; gData.Lock(),s = (TServerNode*)e.Next(),gData.Unlock() )
   {
      if ( s->IsInstalled() )
         nInstalled++;
      if ( s->IsFinished() )
         nFinished++;
      if ( s->HasFailed() )
         nError++;

      
      // Check  jobs that were running but not finished
      if ( *s->GetJobFile() && s->IsRunning() )
      {
         nRunning++;
         // Look for results 
         WCHAR               resultWC[MAX_PATH];
         HANDLE              hFind;
         WIN32_FIND_DATA     fdata;
         WCHAR               sTime[32];

         if ( logdir[UStrLen(logdir)-1] == L'\\' )
         {
            swprintf(resultWC,L"%s%s.result",logdir,s->GetJobFile());
         }
         else
         {
            swprintf(resultWC,L"%s\\%s.result",logdir,s->GetJobFile());
         }
         hFind = FindFirstFile(resultWC,&fdata);
         
         s->SetTimeStamp(gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ));
         
         if ( hFind != INVALID_HANDLE_VALUE )
         {
            // found something
            gData.Lock();
            if ( ! s->IsFinished() )
            {
               gData.Unlock();
               ProcessResults(s,logdir,fdata.cFileName);
            }
            else
            {
               gData.Unlock();
            }
            nRunning--;
            nFinished++;
            FindClose(hFind);
         }
         gData.GetListWindow(&gListWnd);
//         SendMessage(gListWnd,DCT_UPDATE_ENTRY,NULL,(long)s);
         SendMessage(gListWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)s);
      }
   }
   e.Close();
   // Update the summary window
   ComputerStats        stat;

   // get the total servers number
   gData.GetComputerStats(&stat);
   stat.numError = nError;
   stat.numFinished = nFinished;
   stat.numRunning = nRunning;
   stat.numInstalled = nInstalled;
   
   gData.SetComputerStats(&stat);

   gData.GetSummaryWindow(&gSummaryWnd);
   
//   SendMessage(gSummaryWnd,DCT_UPDATE_COUNTS,0,(long)&stat);
   SendMessage(gSummaryWnd,DCT_UPDATE_COUNTS,0,(LPARAM)&stat);
}

BOOL                                       // ret- TRUE if successful
   ReadResults(
      TServerNode          * pServer,      // in - pointer to server node containing server name 
      WCHAR          const * directory,    // in - directory where results files are stored
      WCHAR          const * filename,     // in - filename for this agent's job
      DetailStats          * pStats,       // out- counts of items processed by the agent
      CString              & plugInText,   // out- text results from plug-ins
      BOOL                   bStore        // in - bool, whether to store plug-in text
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   WCHAR                     path[MAX_PATH];
   HRESULT                   hr = S_OK;
   BOOL                      bSuccess = FALSE;

   if ( directory[UStrLen(directory)-1] == '\\' )
   {
      swprintf(path,L"%ls%ls",directory,filename);
   }
   else
   {
      swprintf(path,L"%ls\\%ls",directory,filename);
   }

   // Read the varset data from the file
   IVarSetPtr             pVarSet;
   IStoragePtr            store = NULL;

   // Try to create the COM objects
   hr = pVarSet.CreateInstance(CLSID_VarSet);
   if ( SUCCEEDED(hr) )
   {
      
      // Read the VarSet from the data file
      int tries = 0;
      do 
      {
         tries++;
         hr = StgOpenStorage(path,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&store);
         if ( SUCCEEDED(hr) )
         {                  
            // Load the data into a new varset
            hr = OleLoad(store,IID_IUnknown,NULL,(void **)&pVarSet);
         }
         if ( tries > 2 ) 
            break;
         Sleep(500);
      } while ( hr == STG_E_SHAREVIOLATION || hr == STG_E_LOCKVIOLATION );

   }

   if ( SUCCEEDED(hr) )
   {
      pStats->directoriesChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Changed));
      pStats->directoriesExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Directories_Examined));
      pStats->directoriesUnchanged = (pStats->directoriesExamined - pStats->directoriesChanged);

      pStats->filesChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Changed));
      pStats->filesExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Files_Examined));
      pStats->filesUnchanged = (pStats->filesExamined - pStats->filesChanged );

      pStats->sharesChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Changed));
      pStats->sharesExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Shares_Examined));
      pStats->sharesUnchanged = (pStats->sharesExamined - pStats->sharesChanged );

      pStats->membersChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Members_Changed));
      pStats->membersExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_Members_Examined));
      pStats->membersUnchanged = (pStats->membersExamined - pStats->membersChanged );

      pStats->rightsChanged = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_UserRights_Changed));
      pStats->rightsExamined = (long)pVarSet->get(GET_BSTR(DCTVS_Stats_UserRights_Examined));
      pStats->rightsUnchanged = (pStats->rightsExamined - pStats->rightsChanged );

      
      long           level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
      _bstr_t        logfile = pVarSet->get(GET_BSTR(DCTVS_Results_LogFile));

      if ( level > 2 )
      {
         CString message;

         message.FormatMessage(IDS_SeeLogForAgentErrors_S,(WCHAR*)logfile);

         pServer->SetMessageText(message.GetBuffer(0));
      }
      pServer->SetSeverity(level);
         
      // build the UNC path for the log file
      WCHAR             logPath[MAX_PATH];
      
      swprintf(logPath,L"\\\\%s\\%c$\\%s",pServer->GetServer(),((WCHAR*)logfile)[0],((WCHAR*)logfile) + 3);

      pServer->SetLogPath(logPath);
      bSuccess = TRUE;
      
      // Try to get information from any plug-ins that ran
      // create the COM object for each plug-in
      _bstr_t                   bStrGuid;
      WCHAR                     key[300];
      CLSID                     clsid;

      for ( int i = 0 ; ; i++ )
      {
         swprintf(key,L"Plugin.%ld",i);
         bStrGuid = pVarSet->get(key);
      
         if ( bStrGuid.length() == 0 )
            break;

         IMcsDomPlugIn        * pPlugIn = NULL;
      
         hr = CLSIDFromString(bStrGuid,&clsid);
         if ( SUCCEEDED(hr) )
         {
            hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
            if ( SUCCEEDED(hr) )
            {
               BSTR           name = NULL;
               BSTR           result = NULL;
               
               hr = pPlugIn->GetName(&name);
               if ( SUCCEEDED(hr) )
               {
                  hr = pPlugIn->GetResultString(pVarSet,&result);
                  if ( SUCCEEDED(hr) )
                  {
                     plugInText += (WCHAR*)name;
                     plugInText += L"\n";
                     plugInText += (WCHAR*)result;
                     plugInText += L"\n\n";
                     SysFreeString(result);
                  }
                  SysFreeString(name);
                  if ( bStore )
                  {
                     pVarSet->put(L"LocalServer",pServer->GetServer());
                     pPlugIn->StoreResults(pVarSet);
                  }
               }
               pPlugIn->Release();
            }
         }
      }

   }
   else
   {
      CString  message;
      CString  title;

      if ( hr != STG_E_SHAREVIOLATION && hr != STG_E_LOCKVIOLATION )
      {
         message.FormatMessage(IDS_FailedToLoadResults,filename,hr);
         title.LoadString(IDS_MessageTitle);   
         if ( hr != STG_E_FILENOTFOUND )
            MessageBox(NULL,message,title,MB_OK | MB_ICONERROR);
      }
      else
      {
         // the agent has still not finished writing its results file, for some reason
         // we'll check it again later
         pServer->SetStatus(pServer->GetStatus() & ~Agent_Status_Finished);
      }
   }
   return bSuccess;
}

void 
   ProcessSecRefs(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename
   )
{
   AFX_MANAGE_STATE(AfxGetStaticModuleState());

   WCHAR                     path[MAX_PATH];
   DWORD                     rc = 0;
   BOOL                      bSuccess = FALSE;
   FILE                    * pFile;
   WCHAR                   * pDot;

   if ( directory[UStrLen(directory)-1] == '\\' )
   {
      swprintf(path,L"%ls%ls",directory,filename);
   }
   else
   {
      swprintf(path,L"%ls\\%ls",directory,filename);
   }
   // check to see if a secrefs file was written
   pDot = wcsrchr(path,L'.');
   if ( pDot )
   {
      UStrCpy(pDot,L".secrefs");
      pFile = _wfopen(path,L"rb");
      if ( pFile )
      {
         IIManageDBPtr        pDB;

         rc = pDB.CreateInstance(CLSID_IManageDB);
         if ( SUCCEEDED(rc) )
         {
            // there are some secrefs here, load them into the database
            WCHAR                account[300] = L"";
            WCHAR                type[100] = L"";
            DWORD                nOwner = 0;
            DWORD                nGroup = 0;
            DWORD                nDacl = 0;
            DWORD                nSacl = 0;
            WCHAR                domPart[300];
            WCHAR                acctPart[300];
            WCHAR                acctSid[300] = L"";
            WCHAR              * slash;
            CString              typeString;


			   //move past the UNICODE Byte Order Mark
			fgetwc(pFile);

			   //get entries
            while ( 7 == fwscanf(pFile,L"%[^,],%[^,],%[^,],%ld,%ld,%ld,%ld\r\n",account,acctSid,type,&nOwner,&nGroup,&nDacl,&nSacl) )
            {
         
               safecopy(domPart,account);
               slash = wcschr(domPart,L'\\');
               if ( slash )
               {
                  *slash = 0;
                  UStrCpy(acctPart,slash+1);
               }
               else
               {
                  domPart[0] = 0;
                  safecopy(acctPart,account);
               }

			      //for sIDs with no resolvable account, change domain and account to (Unknown)
			   if ((wcsstr(account, L"S-") == account) && (domPart[0] == 0))
			   {
				  wcscpy(acctPart, GET_STRING(IDS_UnknownSid));
				  wcscpy(domPart, GET_STRING(IDS_UnknownSid));
			   }

               typeString.FormatMessage(IDS_OwnerRef_S,type);
               rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nOwner,typeString.AllocSysString());
               
               typeString.FormatMessage(IDS_GroupRef_S,type);
               rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nGroup,typeString.AllocSysString());

                  //since local group members are not referenced in DACL, but we use that
			      //field to keep track of reference, use a different type string
			   if (!UStrCmp(type, GET_STRING(IDS_STReference_Member)))
			      typeString.FormatMessage(IDS_MemberRef_S);
			   else
			      typeString.FormatMessage(IDS_DACLRef_S,type);
               rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nDacl,typeString.AllocSysString());

               typeString.FormatMessage(IDS_SACLRef_S,type);
               rc = pDB->raw_AddAcctRef(domPart,acctPart,acctSid,pServer->GetServer(),nSacl,typeString.AllocSysString());

               // make sure there's not any data left over in these
               account[0] = 0;
               type[0] = 0;
			   acctSid[0] = 0;
               nOwner = 0;
               nGroup = 0;
               nDacl = 0;
               nSacl = 0;
            }
         }
         fclose(pFile);
      }
   }

}

void 
   ProcessResults(
      TServerNode          * pServer,
      WCHAR          const * directory,
      WCHAR          const * filename
   )
{
   HRESULT                   hr = S_OK;
   DetailStats               stats;
   HWND                      hWnd;
   CString                   PLText;

   memset(&stats,0,(sizeof stats));

   if ( ReadResults(pServer,directory,filename,&stats,PLText,TRUE) )
   {
      pServer->SetFinished();
      if ( ! pServer->HasFailed() && ! pServer->GetSeverity() )
      {
         pServer->SetMessageText(L"");
      }
      gData.AddDetailStats(&stats);
      gData.GetSummaryWindow(&hWnd);
     // get the stats for this job, and send them to the summary window
//      SendMessage(hWnd, DCT_UPDATE_TOTALS, 0, (long)&stats);
      SendMessage(hWnd, DCT_UPDATE_TOTALS, 0, (LPARAM)&stats);
      // also get import the security references
      ProcessSecRefs(pServer,directory,filename);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MigDrvr.rc
//
#define ID_DIALOG_FONTSIZE              8
#define IDS_PROJNAME                    100
#define IDS_MIGRATOR_DESC               101
#define IDR_Migrator                    102
#define IDD_AGENTMONITOR_DIALOG         102
#define IDS_ABOUTBOX                    102
#define IDS_PROGRESS_TITLE              103
#define IDS_ServerNotFound              104
#define IDS_ServerAgentProgressTitle    105
#define IDS_StatusCompleted             106
#define IDS_AccountCopiedLabel          107
#define IDS_AccountErrorsLabel          108
#define IDS_AccountUsersLabel           109
#define IDS_AccountGroupsLabel          110
#define IDS_AccountComputersLabel       111
#define IDS_ChangedLabel                112
#define IDS_UnchangedLabel              113
#define IDS_FilesLabel                  114
#define IDS_SharesLabel                 115
#define IDS_DirectoriesLabel            116
#define IDS_MailboxesLabel              117
#define IDS_ContainersLabel             118
#define IDS_AgentNotRunning             119
#define IDS_CantMonitorOnNt351          120
#define IDS_CannotConnectToAgent        121
#define IDS_RPCBindFailed               122
#define IDS_NoActiveAgent               123
#define IDS_AgentJobNotFound            124
#define IDS_AgentNoLongerRunning        125
#define IDS_QueryJobStatusFailed        126
#define IDS_ExceptionConnectingToAgent  127
#define IDS_ConfirmStopAgent            128
#define IDD_DETAILS                     129
#define IDS_CancelJobFailed             129
#define IDD_AGENTMONITOR_MAIN           130
#define IDS_StopAgentFailed             130
#define IDS_ConfirmCancelJob            131
#define IDD_STARTSTOP                   131
#define IDS_StopAgentFailedHexResult    132
#define IDS_CLIOption_Log               133
#define IDS_CLIOption_Import            134
#define IDS_CLIOption_Start             135
#define IDS_CLIOption_LocalJob          136
#define IDS_MainWindowTitle             137
#define IDS_ConfirmExitAgentsRunning    138
#define IDS_MessageTitle                139
#define IDS_ComputerColumnHeading       140
#define IDS_TimestampColumnHeading      141
#define IDS_StatusColumnHeading         142
#define IDS_MessageColumnHeading        143
#define IDS_NotepadCommandLine          144
#define IDS_ServerNotInServerList       145
#define IDS_Status_Unknown              146
#define IDS_Status_InstallFailed        147
#define IDS_Status_Installed            148
#define IDS_Status_DidNotStart          149
#define IDS_Status_Running              150
#define IDS_Status_Failed               151
#define IDS_Status_Completed            152
#define IDS_Status_NotRunning           153
#define IDS_PromptEnterDispatchLogName  154
#define IDS_ServerCountMessage          155
#define IDS_FailedToLoadResults         156
#define IDS_AgentFinishedNoResults      157
#define IDS_AgentNoResults              158
#define IDS_AccessDenied                159
#define IDS_CopyAccounts                160
#define IDS_TranslateSecurity           161
#define IDS_ExaminedLabel               162
#define IDS_DispatchToServers           163
#define IDS_DescDomains                 164
#define IDS_DescLogfile                 165
#define IDS_DescCredentials             166
#define IDS_DescCopyUsers               167
#define IDS_DescCopyGroups              168
#define IDS_DescCopyComputers           169
#define IDS_DescCopyOUs                 170
#define IDS_DescWriteChanges            171
#define IDS_DescNoChange                172
#define IDS_DescNoReplaceExisting       173
#define IDS_DescReplaceExisting         174
#define IDS_DescRenameWithPrefix        175
#define IDS_DescRenameWithSuffix        176
#define IDS_DescAccountCount            177
#define IDS_DescAccountMigration        178
#define IDS_DescGeneral                 179
#define IDS_DescMailboxTranslation      180
#define IDS_DescContainerTranslation    181
#define IDS_DescFileTrans               182
#define IDS_DescSecurityTranslationFor  183
#define IDS_DescShareTrans              184
#define IDS_DescPrinterTrans            185
#define IDS_DescLGTrans                 186
#define IDS_DescRightsTrans             187
#define IDS_DescProfileTrans            188
#define IDS_DescCopyAccountTypes        189
#define IDS_TranslationMode             190
#define IDS_GenerateMigratedAccountsReport 191
#define IDS_GenerateMigratedComputersReport 192
#define IDS_GenerateExpiredComputersReport 193
#define IDS_GenerateAccountReferencesReport 194
#define IDS_GenerateNameConflictReport  195
#define IDS_UserMigration               196
#define IDS_GroupMigration              197
#define IDS_ComputerMigration           198
#define IDS_SecurityTranslation         199
#define IDS_ReportGeneration            200
#define IDD_PLEASEWAIT                  201
#define IDS_RetryTasks                  201
#define IDC_STATIC_MESSAGE              201
#define IDS_Service                     202
#define IDC_VIEW_LOG                    202
#define IDS_TrustManagement             203
#define IDS_Exchange                    204
#define IDS_Undo                        205
#define IDS_CannotCloseWhileAgentIsRunning 206
#define IDS_DescUndo                    207
#define IDS_DescAccountCountForDelete   208
#define IDS_DescRegistryTrans           209
#define IDS_GroupsWillBeMapped          210
#define IDS_SIDHistory_Yes              211
#define IDS_SIDHistory_No               212
#define IDS_HELPFILE                    213
#define IDS_MSG_HELP                    214
#define IDS_MSG_ERROR                   215
#define IDS_SeeLogForAgentErrors_S      216
#define IDS_Status_Completed_With_Errors 217
#define IDS_Status_Completed_With_Warnings 218
#define IDS_Status_Completed_With_SErrors 219
#define IDS_JustStartingConfirmExit     220
#define IDS_AgentsStillRunningConfirmExit 221
#define IDS_OwnerRef_S                  222
#define IDS_GroupRef_S                  223
#define IDS_DACLRef_S                   224
#define IDS_SACLRef_S                   225
#define IDS_WaitingMessage              226
#define IDS_NoServersMessage            227
#define IDS_ConfirmCloseWhileAgentIsRunning 228
#define IDS_STATUS_Gathering_NameConf   229
#define IDS_STATUS_GeneratingReports    230
#define IDS_Affected                    231
#define IDS_Unaffected                  232
#define IDS_DescDisableSrcAccts         233
#define IDS_DescExpireSrcAccts          234
#define IDS_DescDisableTgtAccts         235
#define IDS_DescLeaveAcctsActive        236
#define IDS_DescTranslateRoaming        238
#define IDS_DescUpdateUserRights        239
#define IDS_DescStrongPassword          240
#define IDS_DescSimplePassword          241
#define IDS_MemberRef_S                 242
#define IDS_DescTransInputFile          243
#define IDS_DescTransInputMOT           244
#define IDS_DescCopyPassword            245
#define IDS_DescExUserProps             246
#define IDS_DescExGrpProps              247
#define IDS_DescExCmpProps              248
#define IDS_DescExcludedProp            249
#define IDS_DescTgtSameAsSrc            250
#define IDS_DescRenameWithPrefixOnConf  251
#define IDS_DescRenameWithSuffixOnConf  252
#define IDC_LOGFILE                     1000
#define IDC_SERVERLIST                  1001
#define IDC_INTERVAL                    1002
#define IDC_STARTMONITOR                1003
#define IDC_STOPMONITOR                 1004
#define IDC_STATUS                      1006
#define IDC_CURRENT                     1007
#define IDC_FilesExamined               1008
#define IDC_DirsExamined                1009
#define IDC_OPERATION                   1010
#define IDC_BTNREFRESH                  1011
#define IDC_EDIT2                       1012
#define IDC_STOPAGENT                   1013
#define IDC_FilesChanged                1014
#define IDC_DirsChanged                 1015
#define IDC_INSTALL_PROGRESS            1015
#define IDC_COMPLETE_PROGESS            1016
#define IDC_INSTALLED_COUNT             1017
#define IDC_RUNNING_COUNT               1018
#define IDC_FINISHED_COUNT              1019
#define IDC_ERROR_COUNT                 1020
#define IDC_TOTAL                       1021
#define IDC_SharesExamined              1022
#define IDC_DirsChanged2                1022
#define IDC_SharesExamined2             1023
#define IDC_SharesChanged               1024
#define IDC_VIEW_DISPATCH               1024
#define IDC_MembersExamined             1025
#define IDC_DB                          1025
#define IDC_MembersChanged              1026
#define IDC_LOG_LABEL                   1026
#define IDC_REFRESH_LABEL               1027
#define IDC_RightsExamined              1027
#define IDC_RightsChanged               1028
#define IDC_DB_LABEL                    1028
#define IDC_IMPORT                      1029
#define IDC_FilesU                      1040
#define IDC_DirsU                       1041
#define IDC_SharesU                     1042
#define IDC_ExaminedLabel               1043
#define IDC_MembersU                    1043
#define IDC_FilesLabel                  1044
#define IDC_RightsU                     1044
#define IDC_DirectoriesLabel            1045
#define IDC_SharesLabel                 1046
#define IDC_ChangedLabel                1047
#define IDC_UnchangedLabel              1048
#define IDC_DETAILS                     1049
#define IDC_PLUG_IN_RESULTS             1051

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         203
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\monrung.cpp ===
/*---------------------------------------------------------------------------
  File:  MonitorRunning.cpp

  Comments: This is the entry point for a thread which will periodically try to connect 
  to the agents that the monitor thinks are running, to see if they are really still running. 

  This will keep the monitor from getting into a state where it thinks agents 
  are still running, when they are not.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "DetDlg.h"

#include "Common.hpp"
#include "AgRpcUtl.h"
#include "Monitor.h"
#include "ServList.hpp"

#include "ResStr.h"

//#include "..\AgtSvc\AgSvc.h"
#include "AgSvc.h"

/*#import "\bin\McsEADCTAgent.tlb" no_namespace , named_guids
//#import "\bin\McsVarSetMin.tlb" no_namespace */

//#import "Engine.tlb" no_namespace , named_guids //already #imported via DetDlg.h
#import "VarSet.tlb" no_namespace rename("property", "aproperty")


DWORD 
   TryConnectAgent(
      TServerNode          * node
   )
{
   DWORD                     rc;
   HRESULT                   hr;
   HANDLE                    hBinding = NULL;
   WCHAR                   * sBinding = NULL;
   WCHAR                     server[40];
   IUnknown                * pUnk = NULL;
   IVarSetPtr                pVarSet;
   IDCTAgentPtr              pAgent;
   _bstr_t                   jobID;
   BOOL                      bSuccess = FALSE;
   BOOL                      bQueryFailed = TRUE;
   BOOL                      bFinished = FALSE;
   CString                   status;

   server[0] = L'\\';
   server[1] = L'\\';
   UStrCpy(server+2,node->GetServer());

   rc = EaxBindCreate(server,&hBinding,&sBinding,TRUE);
   if ( ! rc )
   {
      hr = CoInitialize(NULL);
      if ( SUCCEEDED(hr) )
      {
         rc = DoRpcQuery(hBinding,&pUnk);
      }
      else
      {
         rc = hr;
      }

      if ( ! rc && pUnk )
      {
      try { 
            // we got an interface pointer to the agent:  try to query it
            pAgent = pUnk;
            pUnk->Release();
            pUnk = NULL;

            hr = pAgent->raw_QueryJobStatus(jobID,&pUnk);
            if ( SUCCEEDED(hr) )
            {
               bQueryFailed = FALSE;
               pVarSet = pUnk;
               pUnk->Release();
               _bstr_t text = pVarSet->get(GET_BSTR(DCTVS_JobStatus));

               if ( !UStrICmp(text,GET_STRING(IDS_DCT_Status_Completed)) )
               {
                  // the agent is really finished
                  status.LoadString(IDS_AgentFinishedNoResults);
                  bFinished = TRUE;
               }
            }
         }
         catch ( ... )
         {
            // the DCOM connection didn't work
            // This means we can't tell whether the agent is running or not
            bQueryFailed = TRUE;
         }

      }
      else
      {
         if ( rc == RPC_S_SERVER_UNAVAILABLE )
         {
            status.LoadString(IDS_AgentNoResults);
            bFinished = TRUE;
         }
         else if ( rc == E_NOTIMPL )
         {
            status.LoadString(IDS_CantMonitorOnNt351);
         }
         else
         {
            status.LoadString(IDS_CannotConnectToAgent);
         }
         bQueryFailed = TRUE;
      }
   }
   EaxBindDestroy(&hBinding,&sBinding);

   node->SetMessageText(status.GetBuffer(0));
   if ( bFinished )
   {
      node->SetFinished();
      // make sure the results can be read
      WCHAR                  directory[MAX_PATH];
      WCHAR                  filename[MAX_PATH];
      
      gData.GetResultDir(directory);
      swprintf(filename,GET_STRING(IDS_AgentResultFileFmt),node->GetJobFile());
      ProcessResults(node,directory,filename);
      if ( *node->GetMessageText() )
         node->SetFailed();
      
   }
   else if ( bQueryFailed )
   {
      node->SetQueryFailed();
   }
   if( bFinished || bQueryFailed )
   {
      // send a message to the server list 
      HWND                   listWnd;

      gData.GetListWindow(&listWnd);

//      SendMessage(listWnd,DCT_UPDATE_ENTRY,NULL,(long)node);
      SendMessage(listWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)node);
   }
   return rc;
}

typedef TServerNode * PSERVERNODE;

DWORD __stdcall 
   MonitorRunningAgents(void * /*arg*/)
{
   int                       nRunning = 0;
   DWORD                     rc = 0;
   BOOL                      bDone;

   do 
   {
      // twenty minutes
      for ( long l = 0 ; l < 20 * 60 ; l++ )
      {
         Sleep( 1000 ); 
         // Check to see how many agents are running
         gData.GetDone(&bDone);
         if ( bDone )
            break;
      }

      if ( bDone )
         break;

      gData.Lock();
      
      TServerList          * sList = gData.GetUnsafeServerList();
      TNodeListEnum          e;
      TServerNode         ** Running = new PSERVERNODE[sList->Count()];
      TServerNode          * node;
      
      nRunning = 0;

      for ( node = (TServerNode*)e.OpenFirst(sList) ; node ; node = (TServerNode*)e.Next() )
      {
         if ( node->IsRunning() )
         {
            Running[nRunning] = node;
            nRunning++;
         }
      }
      
      gData.Unlock();

      // for each running agent, check to see if it is really still running
      for ( int i = 0 ; i < nRunning; i++ )
      {
         rc = TryConnectAgent(Running[i]);
      }

      delete [] Running;

      gData.GetDone(&bDone);
      
   } while ( ! bDone );

   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\scanlog.cpp ===
/*---------------------------------------------------------------------------
  File:  ScanLog.cpp

  Comments: Routines to scan the dispatch log for the DCT agents

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/15/99 13:29:18

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"
#include "ServList.hpp"
#include "Globals.h"
#include "Monitor.h"
#include "FParse.hpp"   
#include "afxdao.h"
#include "errDct.hpp"


#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)


#define  BYTE_ORDER_MARK   (0xFEFF)

void ParseInputFile(const WCHAR * filename);

DWORD __stdcall LogReaderFn(void * arg)
{
   WCHAR             logfile[MAX_PATH];
   BOOL              bDone;
   long              nSeconds;

   CoInitialize(NULL);
   
   gData.GetLogPath(logfile);
   gData.GetDone(&bDone);
   gData.GetWaitInterval(&nSeconds);
   
   while ( ! bDone )
   {
      ParseInputFile(logfile);
      Sleep(nSeconds * 1000);
      gData.GetDone(&bDone);
      gData.GetWaitInterval(&nSeconds);
   }
   
   CoUninitialize();
   
   return 0;
}

BOOL 

   TErrorLogParser::ScanFileEntry(
      WCHAR                * string,      // in - line from TError log file
      WCHAR                * timestamp,   // out- timestamp from this line
      int                  * pSeverity,   // out- severity level of this message
      int                  * pSourceLine, // out- the source line for this message
      WCHAR                * msgtext      // out- the textual part of the message
   )
{
   BOOL                      bSuccess = TRUE;
   WCHAR                     cSeverity;
   WCHAR                     cNumber;
   int                       severity = 0;

   (*pSeverity) = 0;
   (*pSourceLine) = 0;

   // extract the timestamp
   if ( string[0] == BYTE_ORDER_MARK )
   {
      string++;
   }
   UStrCpy(timestamp,string,20);
   cSeverity = string[20];
   cNumber = string[21];
   
   severity = 0;

   switch ( cSeverity )
   {
   case L'I' :
      break;
   case L'W':
      if ( cNumber == L'1' ) severity = 1;
      break;
   case L'E':
      if ( cNumber == L'2' ) severity = 2;
      break;
   case L'S':
      if ( cNumber == L'3' ) severity = 3;
      break;
   case L'V':
      if ( cNumber == L'4' ) severity = 4;
      break;
   case L'U':
      if ( cNumber == L'5' ) severity = 5;
      break;
   case L'X':
      if ( cNumber == L'6' ) severity = 6;
      break;
   };

   if ( severity )
   {
      WCHAR                  temp[10];
      
      UStrCpy(temp,string+22,5);
      (*pSourceLine) = _wtoi(temp);
      UStrCpy(msgtext,string+28);
   }
   else
   {
      UStrCpy(msgtext,string+20);
   }
   (*pSeverity) = severity;
   if ( bSuccess )
   {
      msgtext[UStrLen(msgtext)-2] = 0;
   }
   return bSuccess;
}

BOOL GetServerFromMessage(WCHAR const * msg,WCHAR * server)
{
   BOOL                      bSuccess = FALSE;
   int                       ndx = 0;

   for ( ndx = 0 ; msg[ndx] ; ndx++ )
   {
      if ( msg[ndx] == L'\\' && msg[ndx+1] == L'\\' )
      {
         bSuccess = TRUE;
         break;
      }
   }
   if ( bSuccess )
   {
      int                    i = 0;
      ndx+=2; // strip of the backslashes
      for ( i=0; msg[ndx] && msg[ndx] != L'\\' && msg[ndx]!= L' ' && msg[ndx] != L',' && msg[ndx] != L'\t' && msg[ndx] != L'\n'  ; i++,ndx++)
      {
         server[i] = msg[ndx];      
      }
      server[i] = 0;
   }
   else
   {
      server[0] = 0;
   }
   return bSuccess;
}
   

void ParseInputFile(WCHAR const * gLogFile)
{
   FILE                    * pFile = 0;
   WCHAR                     server[200];

   int                       nRead = 0;
   int                       count = 0;
   HWND                      lWnd = NULL;
   long                      totalRead;
   BOOL                      bNeedToCheckResults = FALSE;
   TErrorLogParser           parser;
   TErrorDct                 edct;

   parser.Open(gLogFile);

   gData.GetLinesRead(&totalRead);
   if ( parser.IsOpen() )
   {
      // scan the file
      while ( ! parser.IsEof() )
      {
         if ( parser.ScanEntry() )
         {
            nRead++;
            if ( nRead < totalRead )
               continue;
            // the first three lines each have their own specific format
            if ( nRead == 1 )
            {
               // first comes the name of the human-readable log file
               gData.SetReadableLogFile(parser.GetMessage());
            }
            else if ( nRead == 2 )
            {
               // next, the name and location of the result share - this is needed to look for the result files
               WCHAR const * dirName = parser.GetMessage();

               WCHAR const * colon = wcsrchr(dirName+3,':');
               if ( colon )
               {
                  WCHAR const * sharename = colon+2;
                  WCHAR const * netname = wcschr(sharename+2,L'\\');
                  if ( netname )
                  {
                     gData.SetResultShare(netname+1);
                     WCHAR directory[MAX_PATH];
//                     UStrCpy(directory,dirName,(colon - dirName ));
                     UStrCpy(directory,dirName,(int)(colon - dirName ));
                     gData.SetResultDir(directory);
                  }
               }
               continue;
            }            
            else if ( nRead == 3 )
            {
               // now the count of computers being dispatched to
               count = _wtoi(parser.GetMessage());
               ComputerStats        cStat;
               
               gData.GetComputerStats(&cStat);
               cStat.total = count;
               gData.SetComputerStats(&cStat);
               continue;
            }
            else // all other message have the following format: COMPUTER<tab>Action<tab>RetCode
            { 
               WCHAR                   action[50];
               WCHAR           const * pAction = wcschr(parser.GetMessage(),L'\t');
               WCHAR           const * retcode = wcsrchr(parser.GetMessage(),L'\t');
               TServerNode           * pServer = NULL;

               if ( GetServerFromMessage(parser.GetMessage(),server) 
                     && pAction 
                     && retcode 
                     && pAction != retcode 
                  )
               {
                  
//                  UStrCpy(action,pAction+1,retcode - pAction);
                  UStrCpy(action,pAction+1,(int)(retcode - pAction));
                  // add the server to the list, if it isn't already there
                  gData.Lock();
                  pServer = gData.GetUnsafeServerList()->FindServer(server); 
                  if ( ! pServer )
                     pServer = gData.GetUnsafeServerList()->AddServer(server);
                  gData.Unlock();
                  
                  retcode++;

                  DWORD          rc = _wtoi(retcode);
                  
                  if ( pServer )
                  {
                     if ( UStrICmp(pServer->GetTimeStamp(),parser.GetTimestamp()) < 0 )
                     {
                        pServer->SetTimeStamp(parser.GetTimestamp());
                     }
                     if ( !UStrICmp(action,L"WillInstall") )
                     {
                        pServer->SetIncluded(TRUE);
                     }
                     else if (! UStrICmp(action,L"JobFile") )
                     {
                        pServer->SetJobPath(retcode);
                     }
                     else if (! UStrICmp(action,L"Install") )
                     {
                        if ( rc )
                        {
                           if ( ! *pServer->GetMessageText() )
                           {
                              TErrorDct         errTemp;
                              WCHAR             text[2000];
                              errTemp.ErrorCodeToText(rc,DIM(text),text);
                              
                              pServer->SetMessageText(text);
                           }
                           pServer->SetSeverity(2);
                           pServer->SetFailed();
                           pServer->SetIncluded(TRUE);
                           gData.GetListWindow(&lWnd);
//                           SendMessage(lWnd,DCT_ERROR_ENTRY,NULL,(long)pServer);
                           SendMessage(lWnd,DCT_ERROR_ENTRY,NULL,(LPARAM)pServer);
                        }
                        else
                        {
                           pServer->SetInstalled();
                           pServer->SetIncluded(TRUE);
                           gData.GetListWindow(&lWnd);
//                           SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,(long)pServer);
                           SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)pServer);
                        }
                     }
                     else if ( ! UStrICmp(action,L"Start") )
                     {
                        if ( rc )
                        {
                           if ( ! *pServer->GetMessageText() )
                           {
                              TErrorDct         errTemp;
                              WCHAR             text[2000];
                              errTemp.ErrorCodeToText(rc,DIM(text),text);
                              
                              pServer->SetMessageText(text);
                           }
                           pServer->SetSeverity(2);
                           pServer->SetFailed();
                           pServer->SetIncluded(TRUE);
                           gData.GetListWindow(&lWnd);
//                           SendMessage(lWnd,DCT_ERROR_ENTRY,NULL,(long)pServer);                  
                           SendMessage(lWnd,DCT_ERROR_ENTRY,NULL,(LPARAM)pServer);                  
                        }
                        else
                        {
                           // extract the filename and GUID from the end of the message
                           WCHAR filename[MAX_PATH];
                           WCHAR guid[100];
                           WCHAR * comma1 = wcschr(parser.GetMessage(),L',');
                           WCHAR * comma2 = NULL;
                           if ( comma1 )
                           {
                              comma2 = wcschr(comma1 + 1,L',');
                              if ( comma2 )
                              {
//                                 UStrCpy(filename,comma1+1,(comma2-comma1));  // skip the comma & space before the filename
                                 UStrCpy(filename,comma1+1,(int)(comma2-comma1));  // skip the comma & space before the filename
                                 safecopy(guid,comma2+1);         // skip the comma & space before the guid
                                 pServer->SetJobID(guid);
                                 pServer->SetJobFile(filename);
                                 pServer->SetStarted();
                                 bNeedToCheckResults = TRUE;
                              }
                              gData.GetListWindow(&lWnd);
//                              SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,(long)pServer);
                              SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,(LPARAM)pServer);
                           }
                        }
                     }
                     else if ( ! UStrICmp(action,L"Finished") )
                     {
                        SendMessage(lWnd,DCT_UPDATE_ENTRY,NULL,NULL);
                     }
                  }
               }
			   else
			   {
					// if dispatcher finished dispatching agents set log done

					LPCWSTR psz = parser.GetMessage();

					if (wcsstr(psz, L"All") && wcsstr(psz, L"Finished"))
					{
						gData.SetLogDone(TRUE);
					}
			   }
            }   
         }
      }
      
      // if we don't have the handle from the list window, we couldn't really send the messages
      // in that case we must read the lines again next time, so that we can resend the messages.
      if ( lWnd )
      {
         // if we have sent the messages, we don't need to send them again   
         gData.SetLinesRead(nRead);
      }
      gData.SetFirstPassDone(TRUE);
      parser.Close();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__9287DED1_2A77_11D3_8AE4_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__9287DED1_2A77_11D3_8AE4_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxtempl.h>


#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC Automation classes
#endif // _AFX_NO_OLE_SUPPORT

#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iads.h>
#include <adshlp.h>
#include <comdef.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__9287DED1_2A77_11D3_8AE4_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\servlist.hpp ===
#ifndef __SERVERLIST_HPP__
#define __SERVERLIST_HPP__
/*---------------------------------------------------------------------------
  File: ...

  Comments: ...

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/04/99 17:10:38

 ---------------------------------------------------------------------------
*/
//#import "\bin\MCSEADCTAgent.tlb" no_namespace, named_guids 
#import "Engine.tlb" no_namespace, named_guids 

#include "Common.hpp"
#include "UString.hpp"
#include "TNode.hpp"


#define Agent_Status_Unknown        (0x00000000)
#define Agent_Status_Installed      (0x00000001)
#define Agent_Status_Started        (0x00000002)
#define Agent_Status_Finished       (0x00000004)
#define Agent_Status_Failed         (0x80000000)
#define Agent_Status_QueryFailed    (0x40000000)

class TServerNode : public TNode
{
   BOOL                      bInclude;
   WCHAR                     guid[100];
   WCHAR                     serverName[100];
   WCHAR                     resultpath[MAX_PATH];
   WCHAR                     jobpath[MAX_PATH];
   WCHAR                     logpath[MAX_PATH];
   WCHAR                     timestamp[30];
   IDCTAgent               * pAgent;
   int                       errSeverity;
   DWORD                     status;
   WCHAR                     errMsg[500];
   int                       listNdx;
public:
   TServerNode(WCHAR const * server) 
   {
      safecopy(serverName,server);
      guid[0] = 0;
      pAgent = NULL;
      errSeverity = 0;
      errMsg[0] = 0;
      timestamp[0] = 0;
      resultpath[0] = 0;
      jobpath[0] = 0;
      logpath[0] = 0;
      bInclude = FALSE;
      status = 0;
      listNdx = -1;
   }
   ~TServerNode()
   {
      if ( pAgent )
         pAgent->Release();
   }
   
   WCHAR * GetServer() { return serverName; }
   WCHAR * GetJobID() { return guid; }
   WCHAR * GetMessageText() { return errMsg; } 
   int    GetSeverity() { return errSeverity; }
   
   IDCTAgent * GetInterface() { return pAgent; }
   
   WCHAR * GetTimeStamp() { return timestamp;  }    
   WCHAR * GetJobFile() { return resultpath; }
   WCHAR * GetJobPath() { return jobpath; }
   WCHAR * GetLogPath() { return logpath; }
   BOOL   Include() { return bInclude; }
   DWORD  GetStatus() { return status; }
   BOOL   IsInstalled() { return status & Agent_Status_Installed; }
   BOOL   IsStarted() { return status & Agent_Status_Started; }
   BOOL   IsFinished() { return status & Agent_Status_Finished; }
   BOOL   IsRunning() { return ( (status & Agent_Status_Started) && !(status & (Agent_Status_Finished|Agent_Status_Failed))); }
   BOOL   HasFailed() { return status & Agent_Status_Failed; }
   BOOL   QueryFailed() { return status & Agent_Status_QueryFailed; }

   void SetJobID(WCHAR const * id) { safecopy(guid,id); }
   void SetSeverity(int s) { if ( s > errSeverity ) errSeverity = s; }
   void SetInterface(IDCTAgent* p) { if ( p ) p->AddRef();  pAgent = p; }
   void SetMessageText(WCHAR const * txt) { safecopy(errMsg,txt); }
   void SetTimeStamp(WCHAR const * t) { safecopy(timestamp,t); }
   void SetJobFile(WCHAR const * filename) { safecopy(resultpath,filename); }
   void SetJobPath(WCHAR const * filename) { safecopy(jobpath,filename); safecopy(resultpath,filename); }
   void SetLogPath(WCHAR const * filename) { safecopy(logpath,filename); }
   void SetIncluded(BOOL v) { bInclude = v; }
   void SetStatus(DWORD val) { status = val; }
   
   void SetInstalled() { status |= Agent_Status_Installed; }
   void SetStarted() { status |= Agent_Status_Started; }
   void SetFinished() { status |= Agent_Status_Finished; }
   void SetFailed() { status |= Agent_Status_Failed; }
   void SetQueryFailed() { status |= Agent_Status_QueryFailed; }
};

int static CompareNames(TNode const * t1, TNode const * t2)
{
   TServerNode             * server1 = (TServerNode*)t1;
   TServerNode             * server2 = (TServerNode*)t2;
   WCHAR                   * name1 = server1->GetServer();
   WCHAR                   * name2 = server2->GetServer();
   
   return UStrICmp(name1,name2);
}

int static CompareVal(TNode const * t, void const * v)
{
   TServerNode             * server = (TServerNode*)t;
   WCHAR                   * name1 = server->GetServer();
   WCHAR                   * name2 = (WCHAR*)v;

   return UStrICmp(name1,name2);
}

class TServerList : public TNodeListSortable
{
public:
   TServerList() 
   {
      TypeSetSorted();
      CompareSet(&CompareNames);
   }
   ~TServerList()
   {
      DeleteAllListItems(TServerNode);
   }
   void Clear() { DeleteAllListItems(TServerNode); }
   TServerNode * FindServer(WCHAR const * serverName) { return (TServerNode*)Find(&CompareVal,(void*)serverName); }
   TServerNode * AddServer(WCHAR const * serverName) { TServerNode * p = new TServerNode(serverName); Insert(p); return p; }
};

#endif //__SERVERLIST_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\strdesc.cpp ===
/*---------------------------------------------------------------------------
  File:  StrDesc.cpp

  Comments: Implementation of CMigrator member functions that build string descriptions
  of the operations to be performed.  These are implemented in this seperate file to avoid cluttering 
  Migrator.cpp.
  
  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// Migrator.cpp : Implementation of CMcsMigrationDriverApp and DLL registration.

#include "stdafx.h"
#include "MigDrvr.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

#include "Migrator.h"
#include "TaskChk.h"
#include "ResStr.h"
#include "Common.hpp"
#include "UString.hpp"

void CMigrator::BuildGeneralDesc(IVarSet * pVarSet,CString & str)
{
   CString                   temp;
   _bstr_t                   str1;
   _bstr_t                   str2;

   temp.FormatMessage(IDS_DescGeneral);
   str += temp;
   // Migrate from %ls to %ls
   str1 = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   str2 = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

   temp.FormatMessage(IDS_DescDomains,(WCHAR*)str1,(WCHAR*)str2);
   //str += temp;
   // Logfile: %ls
   str1 = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
   temp.FormatMessage(IDS_DescLogfile,(WCHAR*)str1);
   str += temp;

   // write changes
   str1 = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
   if ( !UStrICmp(str1,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescNoChange);
   }
   else
   {
      temp.FormatMessage(IDS_DescWriteChanges);
   }
   str += temp;
}

void CMigrator::BuildAcctReplDesc(IVarSet * pVarSet,CString & str)
{
   const WCHAR DELIMITER[3] = L",\0";//used to seperate names in the prop exclusion lists

   CString                   temp;
   _bstr_t                   val;
   _bstr_t                   val2;
   _bstr_t                   val3;
   _bstr_t                   val4;
   LONG_PTR                  nVal;
   BOOL                      bCanUseSIDHistory = FALSE;
   CString                   sPropList;

   temp.FormatMessage(IDS_DescAccountMigration);
   str += temp;
   // count of accounts to be copied
   nVal = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   temp.FormatMessage(IDS_DescAccountCount,nVal);
   str += temp;
   temp.FormatMessage(IDS_DescCopyAccountTypes);
   str += temp;

   // copy users?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyUsers);
      str += temp;
      bCanUseSIDHistory = TRUE;
   }
   
   // copy groups?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyLocalGroups));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) || ! UStrICmp(val2,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyGroups);
      str += temp;
      bCanUseSIDHistory = TRUE;
   }

   // copy ous 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyOUs));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyOUs);
      str += temp;
   }
   
   // copy computers
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyComputers);
      str += temp;
   }

   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_AddSidHistory));
   val2 = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));

   if ( !UStrICmp(val,GET_STRING(IDS_YES)) || !UStrICmp(val2,GET_STRING(IDS_YES)) )  
   {
      temp.FormatMessage(IDS_SIDHistory_Yes);
   }
   else
   {
      temp.FormatMessage(IDS_SIDHistory_No);
   }
   // If SID-History doesn't apply (i.e. Migrating Computers), don't mention it in the summary screen
   if ( bCanUseSIDHistory )
   {
      str += temp;
   }

   //if rename with prefix
   val = pVarSet->get(GET_BSTR(DCTVS_Options_Prefix));
   if (val.length())
   {
      temp.FormatMessage(IDS_DescRenameWithPrefix,(WCHAR*)val);
      str += temp;
   }
   //if rename with suffix
   val = pVarSet->get(GET_BSTR(DCTVS_Options_Suffix));
   if (val.length())
   {
      temp.FormatMessage(IDS_DescRenameWithSuffix,(WCHAR*)val);
      str += temp;
   }
   
   // name collisions
   temp.FormatMessage(IDS_DescNoReplaceExisting);
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescReplaceExisting);
   }
   else
   {
      val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Prefix));
      if ( val.length() )
      {
         temp.FormatMessage(IDS_DescRenameWithPrefixOnConf,(WCHAR*)val);
      }
      else
      {
         val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_Suffix));
         if ( val.length() )
         {
            temp.FormatMessage(IDS_DescRenameWithSuffixOnConf,(WCHAR*)val);
         }
      }
   }
   str += temp;

      // account disabling status
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));
   val4 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
		//if disable source accounts, add to summary
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescDisableSrcAccts);
      str += temp;
   }
		//if expire source accounts, add to summary
   if (wcslen(val3))
   {
	  nVal = _wtol(val3);
	  temp.FormatMessage(IDS_DescExpireSrcAccts,nVal);
      str += temp;
   }
        //else if disable target accounts, add to summary
   if ( !UStrICmp(val2,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescDisableTgtAccts);
      str += temp;
   }
   
   else if ( !UStrICmp(val4,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescTgtSameAsSrc);
      str += temp;
   }
		//else if leave source and target accounts active, add to summary
   else 
   {
      temp.FormatMessage(IDS_DescLeaveAcctsActive);
      str += temp;
   }
   
    // roaming profile translation?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TranslateRoamingProfiles));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescTranslateRoaming);
      str += temp;
   }

    // update user rights?
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_UpdateUserRights));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescUpdateUserRights);
      str += temp;
   }

    // password generation?
      //if copying password, say so
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyPasswords));
   if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_DescCopyPassword);
      str += temp;
   }
   else //else checkfor complex or same as username
   {
      val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords));
      val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));
	     //if complex, say so
      if ( !UStrICmp(val,GET_STRING(IDS_YES)) )
	  {
         temp.FormatMessage(IDS_DescStrongPassword, (WCHAR*)val2);
         str += temp;
	  }
      else //else if same as username, say so
	  {
         temp.FormatMessage(IDS_DescSimplePassword, (WCHAR*)val2);
         str += temp;
	  }
   }

   /* add description of any excluded properties */
     //add user properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyUsers));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedUserProps));
   if (!UStrICmp(val,GET_STRING(IDS_YES)) && !UStrICmp(val2,GET_STRING(IDS_YES)) 
	   && UStrICmp(val3, L""))
   {
      temp.FormatMessage(IDS_DescExUserProps);
      str += temp;
	     //diplay the list of props (currently in a comma-seperated string)
	  sPropList = (WCHAR*)val3;
	  if (!sPropList.IsEmpty())
	  {
	     WCHAR* pStr = sPropList.GetBuffer(0);
	     WCHAR* pTemp = wcstok(pStr, DELIMITER);
	     while (pTemp != NULL)
		 {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
			   //get the next item
		    pTemp = wcstok(NULL, DELIMITER);
		 }
	     sPropList.ReleaseBuffer();
	  }
   }
   
     //add group properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyGlobalGroups));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyLocalGroups));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val4 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedGroupProps));
   if ((!UStrICmp(val,GET_STRING(IDS_YES)) || !UStrICmp(val2,GET_STRING(IDS_YES)))
	   && !UStrICmp(val3,GET_STRING(IDS_YES)) && UStrICmp(val4, L""))
   {
      temp.FormatMessage(IDS_DescExGrpProps);
      str += temp;
	     //diplay the list of props (currently in a comma-seperated string)
	  sPropList = (WCHAR*)val4;
	  if (!sPropList.IsEmpty())
	  {
	     WCHAR* pStr = sPropList.GetBuffer(0);
	     WCHAR* pTemp = wcstok(pStr, DELIMITER);
	     while (pTemp != NULL)
		 {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
			   //get the next item
		    pTemp = wcstok(NULL, DELIMITER);
		 }
	     sPropList.ReleaseBuffer();
	  }
   }

     //add computer properties excluded, if any 
   val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyComputers));
   val2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludeProps));
   val3 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExcludedComputerProps));
   if (!UStrICmp(val,GET_STRING(IDS_YES)) && !UStrICmp(val2,GET_STRING(IDS_YES)) 
	   && UStrICmp(val3, L""))
   {
      temp.FormatMessage(IDS_DescExCmpProps);
      str += temp;
	     //diplay the list of props (currently in a comma-seperated string)
	  sPropList = (WCHAR*)val3;
	  if (!sPropList.IsEmpty())
	  {
	     WCHAR* pStr = sPropList.GetBuffer(0);
	     WCHAR* pTemp = wcstok(pStr, DELIMITER);
	     while (pTemp != NULL)
		 {
            temp.FormatMessage(IDS_DescExcludedProp, pTemp);
            str += temp;
			   //get the next item
		    pTemp = wcstok(NULL, DELIMITER);
		 }
	     sPropList.ReleaseBuffer();
	  }
   }
}

void CMigrator::BuildSecTransDesc(IVarSet * pVarSet,CString & str,BOOL bLocal)
{
   CString                   temp;
   CString                   temp2;
   BOOL                      bHeaderShown = FALSE;

   if ( bLocal )
   {
      // exchange translation
      _bstr_t                server = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));

      if ( server.length() )
      {
         temp.FormatMessage(IDS_DescContainerTranslation,(WCHAR*)server);
         str += temp;

               // include the translation mode
         _bstr_t mode = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));
         temp.FormatMessage(IDS_TranslationMode,(WCHAR*)mode);
         str += temp;
      }
   }
   else
   {
      CString               head;
      _bstr_t               val = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
	  _bstr_t				sInput;
      
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         sInput = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
		 CString sInputCap = (WCHAR*)sInput;
		 sInputCap.MakeUpper();
         temp.FormatMessage(IDS_DescTransInputMOT, (LPCTSTR)sInputCap);
         str += temp;
      }
	  else
      {
         sInput = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile));
         temp.FormatMessage(IDS_DescTransInputFile, (WCHAR*)sInput);
         str += temp;
      }

      head.FormatMessage(IDS_DescSecurityTranslationFor);
      // translate files?
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateFiles));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescFileTrans);
         str += temp;
      }
      // translate shares?
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateShares));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescShareTrans);
         str += temp;
      }
      // translate printers?
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslatePrinters));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescPrinterTrans);
         str += temp;
      }
      // Translate local group memberships
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateLocalGroups));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescLGTrans);
         str += temp;
      }
      // Translate user rights
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserRights));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescRightsTrans);
         str += temp;
      }
      // Translate local user profiles
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserProfiles));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescProfileTrans);
         str += temp;
      }
      // Translate Registry
      val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateRegistry));
      if ( !UStrICmp(val,GET_STRING(IDS_YES)))
      {
         if ( ! bHeaderShown )
         {
            str += head;
            bHeaderShown = TRUE;
         }
         temp.FormatMessage(IDS_DescRegistryTrans);
         str += temp;
      }

      if ( bHeaderShown )
      {
         // include the translation mode
         val = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));
         temp.FormatMessage(IDS_TranslationMode,(WCHAR*)val);
         str += temp;
      }
   }

}
void CMigrator::BuildDispatchDesc(IVarSet * pVarSet,CString & str)
{
   BuildSecTransDesc(pVarSet,str,FALSE);
}

void CMigrator::BuildUndoDesc(IVarSet * pVarSet,CString & str)
{
   CString                   temp;
   _bstr_t                   val;
   _bstr_t                   val2;
   long                      nVal;

   temp.FormatMessage(IDS_DescUndo);
   str += temp;
   // count of accounts to be copied
   nVal = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   temp.FormatMessage(IDS_DescAccountCountForDelete,nVal);
   str += temp;
}
void CMigrator::BuildReportDesc(IVarSet * pVarSet, CString & str)
{
   _bstr_t                   text;
   CString                   temp;


   text = pVarSet->get(GET_BSTR(DCTVS_Reports_Generate));
   if ( UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      // not generating any reports
      return;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedAccounts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateMigratedAccountsReport);
      str += temp;
   }

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_MigratedComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateMigratedComputersReport);
      str += temp;
   }
   

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_ExpiredComputers));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateExpiredComputersReport);
      str += temp;
   }


   text = pVarSet->get(GET_BSTR(DCTVS_Reports_AccountReferences));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateAccountReferencesReport);
      str += temp;
   }
   

   text = pVarSet->get(GET_BSTR(DCTVS_Reports_NameConflicts));
   if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
   {
      temp.FormatMessage(IDS_GenerateNameConflictReport);
      str += temp;
   }
   
}

void CMigrator::BuildGroupMappingDesc(IVarSet * pVarSet, CString & str)
{
   long                      nItems;
   CString                   temp;

   nItems = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   
   _bstr_t        tgtGroup = pVarSet->get(L"Accounts.0.TargetName");
   
   temp.FormatMessage(IDS_GroupsWillBeMapped,nItems,(WCHAR*)tgtGroup);

   str += temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\working.cpp ===
// Working.cpp : implementation file
//

#include "stdafx.h"
#include "migdrvr.h"
#include "Working.h"
#include "Resstr.h"
#include <COMDEF.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWorking dialog


CWorking::CWorking(long MSG_ID, CWnd* pParent /*=NULL*/)
	: CDialog(CWorking::IDD, pParent)
{
   _bstr_t x = GET_BSTR(MSG_ID);
   m_strMessage = (WCHAR*)x;
	//{{AFX_DATA_INIT(CWorking)
	//}}AFX_DATA_INIT
}


void CWorking::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWorking)
	DDX_Text(pDX, IDC_STATIC_MESSAGE, m_strMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWorking, CDialog)
	//{{AFX_MSG_MAP(CWorking)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWorking message handlers

BOOL CWorking::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
   CenterWindow();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\setdlg.h ===
#if !defined(AFX_LOGSETTINGSDLG_H__62C9BACD_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
#define AFX_LOGSETTINGSDLG_H__62C9BACD_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// LogSettingsDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CLogSettingsDlg dialog

class CLogSettingsDlg : public CPropertyPage
{
	DECLARE_DYNCREATE(CLogSettingsDlg)

// Construction
public:
	CLogSettingsDlg();
	~CLogSettingsDlg();

   void SetDatabase(WCHAR const * file) { m_Database = file; m_Import = (m_Database.GetLength() > 0); }
   void SetDispatchLog(WCHAR const * logfile) { m_LogFile = logfile; }
   void SetImmediateStart(BOOL bVal) { m_StartImmediately = bVal; }
   virtual BOOL OnSetActive( );
// Dialog Data
	//{{AFX_DATA(CLogSettingsDlg)
	enum { IDD = IDD_STARTSTOP };
	CButton	m_ImportControl;
	CEdit	m_IntervalEditControl;
	CEdit	m_LogEditControl;
	CStatic	m_RefreshLabel;
	CStatic	m_LogLabel;
	CStatic	m_DBLabel;
	CEdit	m_DBEditControl;
	CButton	m_StopButton;
	CButton	m_StartButton;
	long	m_Interval;
	CString	m_LogFile;
	CString	m_Database;
	BOOL	m_Import;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CLogSettingsDlg)
	public:
	virtual void OnOK();
	virtual BOOL OnQueryCancel();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual BOOL OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult);
	//}}AFX_VIRTUAL

// Implementation
protected:
   HANDLE m_ThreadHandle;
   DWORD  m_ThreadID;
   BOOL   m_StartImmediately;

   // Generated message map functions
	//{{AFX_MSG(CLogSettingsDlg)
	afx_msg void OnStartMonitor();
	afx_msg void OnStopMonitor();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeLogfile();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LOGSETTINGSDLG_H__62C9BACD_D7C6_11D2_A1E2_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\setdlg.cpp ===
/*---------------------------------------------------------------------------
  File:  LogSettingsDlg.cpp

  Comments: This dialog allows the user to specify a log file, or to manually
  stop and restart the monitoring thread.  This normally won't be needed, but 
  it is useful for debugging.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles

 ---------------------------------------------------------------------------
*/// LogSettingsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "SetDlg.h"
#include "Monitor.h"
#include "Globals.h"

#include <htmlhelp.h>
#include "helpid.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLogSettingsDlg property page

IMPLEMENT_DYNCREATE(CLogSettingsDlg, CPropertyPage)

CLogSettingsDlg::CLogSettingsDlg() : CPropertyPage(CLogSettingsDlg::IDD)
{
	//{{AFX_DATA_INIT(CLogSettingsDlg)
	m_LogFile = _T("");
	m_Database = _T("");
	m_Import = FALSE;
	//}}AFX_DATA_INIT
   m_ThreadHandle = INVALID_HANDLE_VALUE;
   m_ThreadID = 0;
   gData.GetWaitInterval(&m_Interval);
	m_StartImmediately = FALSE;
}

CLogSettingsDlg::~CLogSettingsDlg()
{
}

void CLogSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CLogSettingsDlg)
	DDX_Control(pDX, IDC_IMPORT, m_ImportControl);
	DDX_Control(pDX, IDC_INTERVAL, m_IntervalEditControl);
	DDX_Control(pDX, IDC_LOGFILE, m_LogEditControl);
	DDX_Control(pDX, IDC_REFRESH_LABEL, m_RefreshLabel);
	DDX_Control(pDX, IDC_LOG_LABEL, m_LogLabel);
	DDX_Control(pDX, IDC_DB_LABEL, m_DBLabel);
	DDX_Control(pDX, IDC_DB, m_DBEditControl);
	DDX_Control(pDX, IDC_STOPMONITOR, m_StopButton);
	DDX_Control(pDX, IDC_STARTMONITOR, m_StartButton);
	DDX_Text(pDX, IDC_INTERVAL, m_Interval);
	DDX_Text(pDX, IDC_LOGFILE, m_LogFile);
	DDX_Text(pDX, IDC_DB, m_Database);
	DDX_Check(pDX, IDC_IMPORT, m_Import);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CLogSettingsDlg, CPropertyPage)
	//{{AFX_MSG_MAP(CLogSettingsDlg)
	ON_BN_CLICKED(IDC_STARTMONITOR, OnStartMonitor)
	ON_BN_CLICKED(IDC_STOPMONITOR, OnStopMonitor)
	ON_EN_CHANGE(IDC_LOGFILE, OnChangeLogfile)
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLogSettingsDlg message handlers


void CLogSettingsDlg::OnStartMonitor() 
{
   UpdateData(TRUE);
   // Kick off a thread to do the monitoring!
   //m_ServerList.DeleteAllItems();
   
   // make sure the filename is not empty
   m_LogFile.TrimLeft();
   m_LogFile.TrimRight();
   if ( m_LogFile.GetLength() == 0 )
   {
      CString message;
      message.LoadString(IDS_PromptEnterDispatchLogName);
      MessageBox(message);
      m_LogEditControl.SetFocus();
      return;
   }
   gData.SetDone(FALSE);
   if ( m_Interval > 0 )
   {
      gData.SetWaitInterval(m_Interval);
   }
   UpdateData(FALSE);
   SetDefID(IDC_STOPMONITOR);
   m_StopButton.EnableWindow(FALSE);      // Disable the buttons, since they don't do anything useful in ADMT
   m_StopButton.SetFocus();
   m_StartButton.EnableWindow(FALSE);

   // disable the interval and other controls
   m_LogLabel.EnableWindow(FALSE);
   m_LogEditControl.EnableWindow(FALSE);
   m_RefreshLabel.EnableWindow(FALSE);
   m_IntervalEditControl.EnableWindow(FALSE);
   m_DBLabel.EnableWindow(FALSE);
   m_DBEditControl.EnableWindow(FALSE);   
   m_ImportControl.EnableWindow(FALSE);

   gData.SetLogPath(m_LogFile.GetBuffer(0));
   gData.SetDatabaseName(m_Database.GetBuffer(0));
   gData.SetImportStats(m_Import);

   m_ThreadHandle = CreateThread(NULL,0,&ResultMonitorFn,NULL,0,&m_ThreadID);
   CloseHandle(m_ThreadHandle);
   m_ThreadHandle = CreateThread(NULL,0,&LogReaderFn,NULL,0,&m_ThreadID);
   CloseHandle(m_ThreadHandle);
   m_ThreadHandle = CreateThread(NULL,0,&MonitorRunningAgents,NULL,0,&m_ThreadID);
   CloseHandle(m_ThreadHandle);
   m_ThreadHandle = INVALID_HANDLE_VALUE;
   
}

void CLogSettingsDlg::OnStopMonitor() 
{
   UpdateData(FALSE);
   SetDefID(IDC_STARTMONITOR);
   m_StartButton.EnableWindow(TRUE);
   m_StartButton.SetFocus();
   m_StopButton.EnableWindow(FALSE);

   // enable the interval and other controls
   m_LogLabel.EnableWindow(TRUE);
   m_LogEditControl.EnableWindow(TRUE);
   m_RefreshLabel.EnableWindow(TRUE);
   m_IntervalEditControl.EnableWindow(TRUE);
   m_DBLabel.EnableWindow(TRUE);
   m_DBEditControl.EnableWindow(TRUE);
   m_ImportControl.EnableWindow(TRUE);


   if( m_ThreadHandle != INVALID_HANDLE_VALUE )
   {
      gData.SetDone(TRUE);
      CloseHandle(m_ThreadHandle);
      m_ThreadID = 0;
   }
}


BOOL CLogSettingsDlg::OnSetActive()
{
   BOOL rc = CPropertyPage::OnSetActive();
   
   CancelToClose( );
   return rc;
}

BOOL CLogSettingsDlg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
   if ( m_StartImmediately )
      OnStartMonitor();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CLogSettingsDlg::OnChangeLogfile() 
{
   UpdateData(TRUE);

   CString temp = m_LogFile;

   temp.TrimLeft();
   temp.TrimRight();

   UpdateData(FALSE);
}

void CLogSettingsDlg::OnOK() 
{
   gData.SetDone(TRUE);
   CPropertyPage::OnOK();
}

BOOL CLogSettingsDlg::OnQueryCancel() 
{
	return CPropertyPage::OnQueryCancel();
}

BOOL CLogSettingsDlg::OnApply() 
{
   BOOL                      bNeedToConfirm = FALSE;
   BOOL                      bFirstPassDone = FALSE;
   ComputerStats             stats;
   CString                   strTitle;
   CString                   strText;
   
   gData.GetFirstPassDone(&bFirstPassDone);
   gData.GetComputerStats(&stats);
   strTitle.LoadString(IDS_MessageTitle);

   if ( !bFirstPassDone )
   {
      strText.LoadString(IDS_JustStartingConfirmExit);
      bNeedToConfirm = TRUE;
   }
   if ( (stats.numError + stats.numFinished) < stats.total )
   {
      strText.LoadString(IDS_AgentsStillRunningConfirmExit);
      bNeedToConfirm = TRUE;
   }
   if ( bNeedToConfirm )
   {
      if ( IDYES == MessageBox(strText,strTitle,MB_ICONWARNING | MB_YESNO) )
      {
         gData.SetDone(TRUE);
         return CPropertyPage::OnApply();
      }
   }
   else
   {
      gData.SetDone(TRUE);
      return CPropertyPage::OnApply();
   }

   return FALSE;
}

BOOL CLogSettingsDlg::OnNotify(WPARAM wParam, LPARAM lParam, LRESULT* pResult) 
{
   LPNMHDR lpnm = (LPNMHDR) lParam;
	switch (lpnm->code)
	{
	   case PSN_HELP :
	      helpWrapper(m_hWnd, IDH_WINDOW_AGENT_MONITOR_SETTING);
         break;
   }
   return CPropertyPage::OnNotify(wParam, lParam, pResult);
}

BOOL CLogSettingsDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
   helpWrapper(m_hWnd, IDH_WINDOW_AGENT_MONITOR_SETTING);
	
	return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "MoveObj_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__B6111B19_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_)
#define AFX_DLLDATAX_H__B6111B19_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__B6111B19_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\migdrvr\working.h ===
#if !defined(AFX_WORKING_H__84F65A5F_1CE3_43D8_B403_1A0DB5F127DC__INCLUDED_)
#define AFX_WORKING_H__84F65A5F_1CE3_43D8_B403_1A0DB5F127DC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Working.h : header file
//
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CWorking dialog

class CWorking : public CDialog
{
// Construction
public:
	CWorking(long l, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWorking)
	enum { IDD = IDD_PLEASEWAIT };
	CString	m_strMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWorking)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWorking)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WORKING_H__84F65A5F_1CE3_43D8_B403_1A0DB5F127DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\moveobj.cpp ===
// MoveObj.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for MoveObj.idl by adding the following 
//      files to the Outputs.
//          MoveObj_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f MoveObjps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MoveObj.h"
#include "dlldatax.h"

#include "MoveObj_i.c"
#include "Mover.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Mover, CMover)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{MoveObj.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MOVEOBJLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{MoveObj.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\admtcrypt.h ===
#pragma once

#include <TChar.h>
#include <Windows.h>
#include <WinCrypt.h>
#include <ComDef.h>


#define ENCRYPTION_KEY_SIZE 16 // in bytes
#define SESSION_KEY_SIZE    16 // in bytes


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------

class CCryptProvider
{
public:

	CCryptProvider();
	CCryptProvider(const CCryptProvider& r);
	~CCryptProvider();

	CCryptProvider& operator =(const CCryptProvider& r);

	HCRYPTHASH CreateHash(ALG_ID aid);
	HCRYPTKEY DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags = 0);

	_variant_t GenerateRandom(DWORD cbData) const;
	void GenerateRandom(BYTE* pbData, DWORD cbData) const;

protected:

	HCRYPTPROV m_hProvider;
};


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------

class CCryptKey
{
public:

	CCryptKey(HCRYPTKEY hKey = NULL);
	~CCryptKey();

	operator HCRYPTKEY()
	{
		return m_hKey;
	}

	void Attach(HCRYPTKEY hKey)
	{
		m_hKey = hKey;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hKey = m_hKey;
		m_hKey = NULL;
		return hKey;
	}

	_variant_t Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);
	_variant_t Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData);

protected:

	CCryptKey(const CCryptKey& key) {}
	CCryptKey& operator =(const CCryptKey& key) { return *this; }

protected:

	HCRYPTKEY m_hKey;
};


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------

class CCryptHash
{
public:

	CCryptHash(HCRYPTHASH hHash = NULL);
	~CCryptHash();

	operator HCRYPTHASH()
	{
		return m_hHash;
	}

	void Attach(HCRYPTHASH hHash)
	{
		m_hHash = hHash;
	}

	HCRYPTKEY Detach()
	{
		HCRYPTKEY hHash = m_hHash;
		m_hHash = NULL;
		return hHash;
	}

	_variant_t GetValue() const;
	void SetValue(const _variant_t& vntValue);

	void Hash(LPCTSTR pszData);
	void Hash(const _variant_t& vntData);
	void Hash(BYTE* pbData, DWORD cbData);

	bool operator ==(const CCryptHash& hash);

	bool operator !=(const CCryptHash& hash)
	{
		return !this->operator ==(hash);
	}

protected:

	CCryptHash(const CCryptKey& hash) {}
	CCryptHash& operator =(const CCryptHash& hash) { return *this; }

protected:

	HCRYPTHASH m_hHash;
};


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------

class CDomainCrypt : public CCryptProvider
{
protected:

	CDomainCrypt();
	~CDomainCrypt();

	HCRYPTKEY GetEncryptionKey(LPCTSTR pszKeyId);

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes);
	void StoreBytes(LPCTSTR pszId, BYTE* pBytes, DWORD cBytes);
	_variant_t RetrieveBytes(LPCTSTR pszId);

protected:

	static _TCHAR m_szIdPrefix[];
};


//---------------------------------------------------------------------------
// Target Crypt Class
//
// CreateEncryptionKey
// - creates encryption key
// - stores encryption key using key identifier
// - returns encryption key encrypted with given password
//---------------------------------------------------------------------------

class CTargetCrypt : public CDomainCrypt
{
public:

	CTargetCrypt();
	~CTargetCrypt();

	_variant_t CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword = NULL);

	_variant_t CreateSession(LPCTSTR pszKeyId);

	_variant_t Encrypt(_bstr_t strData);

protected:

	void StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		CDomainCrypt::StoreBytes(psz, vntBytes);
	}

	_variant_t RetrieveBytes(LPCTSTR pszId)
	{
		LPTSTR psz = (LPTSTR) _alloca((_tcslen(m_szIdPrefix) + 1 + _tcslen(pszId) + 1) * sizeof(_TCHAR));

		_tcscpy(psz, m_szIdPrefix);
		_tcscat(psz, _T("_"));
		_tcscat(psz, pszId);

		return CDomainCrypt::RetrieveBytes(psz);
	}

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------

class CSourceCrypt : public CDomainCrypt
{
public:

	CSourceCrypt();
	~CSourceCrypt();

	void ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword = NULL);

	void ImportSessionKey(const _variant_t& vntEncryptedKey);

	_bstr_t Decrypt(const _variant_t& vntData);

protected:

	CCryptKey m_keySession;
};


//---------------------------------------------------------------------------
// Use Cases
//---------------------------------------------------------------------------
//
// Target Domain Controller
// ------------------------
// Generate Encryption Key
// - given source domain name and optional password
// - generate 128 bit encryption key
// - store encryption key using source domain name
// - if given optional password encrypt key with password
// - return encrypted key
//
// Generate Session Key
// - given source domain name
// - generate 128 bit session key
// - generate hash of session key
// - retrieve encryption key using source domain name
// - encrypt session key and hash with encryption key
// - return encrypted session key/hash
//
// Encrypt Data
// - given data
// - encrypt data using session key
// - return encrypted data
//
// Password Export Server (PES)
// ----------------------------
// Store Encryption Key
// - given encrypted encryption key and password
// - decrypt key using password
// - store key
//
// Decrypt Session Key
// - given an encrypted session key / hash
// - decrypt using encryption key
// - generate hash of decrypted session key
// - compare against decrypted hash
// - store session key
// - return success or failure
//
// Decrypt Data
// - given encrypted data
// - decrypt data using session key
// - return un-encrypted data
//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MoveObj.rc
//
#define IDS_PROJNAME                    100
#define IDS_MOVER_DESC                  101
#define IDR_Mover                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\mover.cpp ===
// Mover.cpp : Implementation of CMoveObjApp and DLL registration.

#include "stdafx.h"
#include <stdio.h>
#include <basetsd.h>
#include <ntdsapi.h>
#include "MoveObj.h"
#include "Mover.h"
#include "UString.hpp"
#include "EaLen.hpp"

#include "ErrDct.hpp"
#include "TReg.hpp"
#include "ResStr.h"

#include "winldap.h"    // use the platform SDK version of winldap.h, which is in the project directory



#define SECURITY_WIN32  1       // Needed for sspi.h

#include <sspi.h>               // Needed for ISC_REQ_DELEGATE


#define LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID     "1.2.840.113556.1.4.521"
#define LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W  L"1.2.840.113556.1.4.521"


TErrorDct      err;
TErrorDct      errLogMain;
StringLoader   gString;

BOOL                                       // ret- whether to perform trace logging to a file
   MoverTraceLogging(   
      WCHAR               * filename       // out- filename to use for trace logging
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;
   WCHAR                     fnW[MAX_PATH];

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),(HKEY)HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"MoveObjectLog",fnW,MAX_PATH);
      if ( ! rc )
      {
         if ( *fnW ) 
         {
            bFound = TRUE;
            UStrCpy(filename,fnW);
         }
         else
         {
            filename[0] = 0;
         }
      }
   }
   return bFound && filename[0];
}


// In the following function we are sending in the logFilename in the tgtCredDomain argument.
// This is done since this is always called with a null value in the ADMT code. To be safe we
// will check if the account value is null then we will treat this as a log file otherwise
// we will need to treat this as credentials.
STDMETHODIMP 
   CMover::Connect(
      BSTR                   sourceComp,        // in - source domain computer to connect to
      BSTR                   targetDSA,         // in - target domain computer to connect to
      BSTR                   srcCredDomain,     // in - credentials to use for source domain
      BSTR                   srcCredAccount,    // in - credentials to use for source domain           
      BSTR                   srcCredPassword,   // in - credentials to use for source domain
      BSTR                   tgtCredDomain,     // in - credentials to use for target domain
      BSTR                   tgtCredAccount,    // in - credentials to use for target domain
      BSTR                   tgtCredPassword    // in - credentials to use for target domain
   )
{

   DWORD                     rc = 0;
   LONG                      value = 0;
   ULONG                     flags = 0;
   ULONG                     result = 0;
   SEC_WINNT_AUTH_IDENTITY   srcCred;
   SEC_WINNT_AUTH_IDENTITY   tgtCred;
   BOOL                      bUseSrcCred = FALSE;
   BOOL                      bUseTgtCred = FALSE;
   BOOL                      bSrcGood = FALSE;
   WCHAR                   * logFileMain;

   // strip off leading \\ if present
   if ( sourceComp && sourceComp[0] == L'\\' )
   {
      UStrCpy(m_sourceDSA,sourceComp + 2);
   }
   else
   {
      UStrCpy(m_sourceDSA,sourceComp);
   }
   if ( targetDSA && targetDSA[0] == L'\\' )
   {
      UStrCpy(m_targetDSA,targetDSA + 2);
   }
   else
   {
      UStrCpy(m_targetDSA,targetDSA);
   }
   
   // set up credentials structure to use for bind, if needed
   if ( srcCredDomain && *srcCredDomain && srcCredAccount && *srcCredAccount )
   {
      srcCred.User = srcCredAccount;
      srcCred.Domain = srcCredDomain;
      srcCred.Password = srcCredPassword;
      srcCred.UserLength = UStrLen(srcCred.User);
      srcCred.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
      srcCred.DomainLength = UStrLen(srcCred.Domain);
      srcCred.PasswordLength = UStrLen(srcCred.Password);
      bUseSrcCred = TRUE;
   }

   if ( tgtCredAccount && *tgtCredAccount )
   {
      tgtCred.User = tgtCredAccount;
      tgtCred.Domain = tgtCredDomain;
      tgtCred.Password = tgtCredPassword;
      tgtCred.UserLength = UStrLen(tgtCred.User);
      tgtCred.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
      tgtCred.DomainLength = UStrLen(tgtCred.Domain);
      tgtCred.PasswordLength = UStrLen(tgtCred.Password);
      bUseTgtCred = TRUE;
   }
   else if ( tgtCredDomain && *tgtCredDomain )
   {
      logFileMain = tgtCredDomain;
      if (*logFileMain)
      {
         errLogMain.LogOpen(logFileMain, 1);
      }
   }

   // Open LDAP connections to the source and target computers

   
   // first, connect to the source computer
   WCHAR                     logFile[LEN_Path];
   
   if ( MoverTraceLogging(logFile) )
   {
      err.LogOpen(logFile,1);
   }
   err.DbgMsgWrite(0,L"\n\nMoveObject::Connect(%ls,%ls)",m_sourceDSA,m_targetDSA);

//   m_srcLD = ldap_openW(m_sourceDSA, LDAP_PORT);
	  //replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
      //flag so that the following ldap calls (i.e. ldap_bind) will not need to 
	  //unnecessarily query for the domain controller
   m_srcLD = ldap_initW(m_sourceDSA, LDAP_PORT);

   if ( m_srcLD == NULL )
   {
      value  = LdapGetLastError();
      if (value == LDAP_SUCCESS )
      {
         rc = ERROR_CONNECTION_REFUSED;
      }
      else
      {
         rc = LdapMapErrorToWin32(result);
      }
      errLogMain.SysMsgWrite(ErrE, rc, DCT_MSG_CONNECT_ERROR_SOURCE_SD, (WCHAR*)m_sourceDSA, rc);
   }

   if ( m_srcLD )
   {
	     //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
	     //ldap_open will not need to unnecessarily query for the domain controller
      flags = PtrToUlong(LDAP_OPT_ON); 
      ldap_set_option(m_srcLD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

      err.DbgMsgWrite(0,L"Setting source options");
      flags = 0;
      // set the delegation flag for the source handle
      result = ldap_get_option(m_srcLD, LDAP_OPT_SSPI_FLAGS,&flags);

      if ( result )
      {
         rc = LdapMapErrorToWin32(result);
      }
      else
      {
         flags |= ISC_REQ_DELEGATE;
    
         
         result = ldap_set_option(m_srcLD,LDAP_OPT_SSPI_FLAGS, &flags);
         if ( result )
         {
            rc = LdapMapErrorToWin32(result);
         }
      }
   }

   if ( ! rc )
   {
      err.DbgMsgWrite(0,L"Binding to source");
      // try to bind to the source LDAP server
      if( bUseSrcCred )
      {
         result = ldap_bind_s(m_srcLD,NULL,(WCHAR*)&srcCred, LDAP_AUTH_SSPI);
      }
      else
      {
         result = ldap_bind_s(m_srcLD,NULL,NULL, LDAP_AUTH_SSPI);
      }
      
                         
      if ( result )
      {
         rc = LdapMapErrorToWin32(result);
      }
      else
      {
         bSrcGood = TRUE;
      }
   }
                 
   if ( ! rc )
   {
      err.DbgMsgWrite(0,L"Connecting to target");
      // now try to connect to the target server
//      m_tgtLD = ldap_openW(m_targetDSA, LDAP_PORT);
	     //replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
         //flag so that the following ldap calls (i.e. ldap_bind) will not need to 
	     //unnecessarily query for the domain controller
      m_tgtLD = ldap_initW(m_targetDSA, LDAP_PORT);

      if ( m_tgtLD == NULL )
      {
         value  = LdapGetLastError();
         if (value == LDAP_SUCCESS )
         {
            rc = ERROR_CONNECTION_REFUSED;
         }
         else
         {
            rc = LdapMapErrorToWin32(result);
         }
         errLogMain.SysMsgWrite(ErrE, rc, DCT_MSG_CONNECT_ERROR_TARGET_SD, (WCHAR*)m_targetDSA, rc);
      }

      if ( m_tgtLD )
      {
	        //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
	        //ldap_open will not need to unnecessarily query for the domain controller
         flags = PtrToUlong(LDAP_OPT_ON); 
         ldap_set_option(m_tgtLD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

         err.DbgMsgWrite(0,L"Setting target options.");
         flags = 0;
         
         result = ldap_get_option(m_tgtLD,LDAP_OPT_REFERRALS,&flags);
         if ( result )
         {
            rc = LdapMapErrorToWin32(result);
         }
         else
         {
            flags = PtrToUlong(LDAP_OPT_OFF); 
            result = ldap_set_option(m_tgtLD,LDAP_OPT_REFERRALS,&flags);

            if ( result )
            {
               rc = LdapMapErrorToWin32(result);
            }
         }
         if ( ! rc )
         {
            err.DbgMsgWrite(0,L"Binding to target.");
            if ( bUseTgtCred )
            {
               result = ldap_bind_s(m_tgtLD,NULL,(PWCHAR)&tgtCred,LDAP_AUTH_SSPI);
            }
            else
            {
               result = ldap_bind_s(m_tgtLD,NULL,NULL,LDAP_AUTH_SSPI);
            }

            if ( result )
            {
               rc = LdapMapErrorToWin32(result);
            }
            if ( rc )
            {
               err.DbgMsgWrite(0,L"Bind to target failed,rc=%ld, ldapRC=0x%lx",rc,result);
            }
            else
            {
               err.DbgMsgWrite(0,L"Everything succeeded.");
            }
         }
      }
      
   }
   if ( bSrcGood )
   {
      rc = 0;
   }
   if ( rc )
   {
      // if failure, clean up any sessions we may have opened
      Close();
   }
                                        
   err.LogClose();

   if ( logFileMain && *logFileMain )
   {
      errLogMain.LogClose();
   }
   
   if ( SUCCEEDED(rc))
      return HRESULT_FROM_WIN32(rc);
   else 
      return rc;
}

STDMETHODIMP CMover::Close()
{
   // close any open connections	
   if ( m_srcLD )
   {
      ldap_unbind_s(m_srcLD);
      m_srcLD = NULL;
   }
   
   if ( m_tgtLD )
   {
      ldap_unbind_s(m_tgtLD);
      m_tgtLD = NULL;
   }

   return S_OK;
}

char * MakeNarrowString(PWCHAR strInput)
{
    char                   * strResult = NULL;
    ULONG                    len = 0;
    
    if ( strInput )
    {
      len = WideCharToMultiByte(CP_ACP,
                             0,
                             strInput, 
                             wcslen(strInput),
                             NULL,
                             0, 
                             NULL, 
                             NULL);
                             
      strResult = (PCHAR)malloc(len + 1);

      if ( strResult )
      {
         WideCharToMultiByte(CP_ACP,
                            0, 
                            strInput, 
                            wcslen(strInput),
                            strResult, 
                            len, 
                            NULL, 
                            NULL);
         // make sure the resulting string is null terminated
         strResult[len] = 0;            
      }
    }
    
    return strResult;
}

void StripDN(WCHAR * str)
{
   int                       curr=0,i=0;

   for ( curr=0,i=0; str[i] ; i++ )
   {
      if ( str[i] == L'\\' && str[i+1] == L'/' )
      {
         continue;
      }
      str[curr] = str[i];
      curr++;
  }
  str[curr] = 0;
}
         
STDMETHODIMP CMover::MoveObject(BSTR sourcePath, BSTR targetRDN, BSTR targetOUPath )
{
	WCHAR                     sTargetContainer[LEN_Path];
   WCHAR                     sSourceDN[LEN_Path];
   WCHAR                     sTargetRDN[LEN_Path];
   WCHAR                     sTargetDSA[LEN_Path];
   char                    * pTgtDSA = NULL;
   WCHAR             const * prefix = L"LDAP://";
   HRESULT                   hr = S_OK;
   
   // set up the arguments needed to call the interdomain move operation
   UStrCpy(sTargetDSA,m_targetDSA);
   pTgtDSA = MakeNarrowString(sTargetDSA);
   

   // the source path and target OuPath are provided in the LDAP:// format
   
   // get the target container, target DN, and source DN in canonical LDAP format

   if ( !UStrICmp(targetOUPath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(targetOUPath+UStrLen(prefix) + 1,L'/');
      if ( start )
      {
         UStrCpy(sTargetContainer,start + 1);
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }
   if ( !UStrICmp(sourcePath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(sourcePath+UStrLen(prefix)+1,L'/');
      if ( start )
      {
         UStrCpy(sSourceDN,start+1);
         UStrCpy(sTargetRDN,start + 1);
         WCHAR * temp = wcschr(sTargetRDN,L',');
         if ( temp )
         {
            (*temp) = 0;
         }
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }

   StripDN(sSourceDN);
   StripDN(sTargetRDN);
   StripDN(sTargetContainer);
   
   berval  Value;
   Value.bv_val = pTgtDSA;
   Value.bv_len = strlen(pTgtDSA);

   LDAPControl   ServerControl;
   LDAPControl * ServerControls[2];
   LDAPControl * ClientControls = NULL;

   ServerControl.ldctl_oid = LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W;
   ServerControl.ldctl_value = Value;
   ServerControl.ldctl_iscritical = TRUE;

   ServerControls[0] = NULL;
   ServerControls[0] = &ServerControl;
   ServerControls[1] = NULL;
   
   /*
    DstDSA = dns name of dc
    Dn = distinguished name of object to be moved
    NewRdn = relative distinguished name of object 
    NewParent = distinguished name of new parent container
    ServerControls= specify the LDAP operational control for cross domain move
   */ 
   DWORD             ldaprc = ldap_rename_ext_s(m_srcLD, 
                              sSourceDN, 
                              targetRDN, 
                              sTargetContainer, 
                              TRUE,
                              ServerControls, 
                              &ClientControls
                          );

  DWORD            winrc = 0;
  ULONG             error;
  ULONG             result;
  WCHAR             logFile[LEN_Path];

  if ( MoverTraceLogging(logFile) )
  {
     err.LogOpen(logFile,1);
  }
 
  if ( ldaprc )
  {

    result =  ldap_get_option(m_srcLD, LDAP_OPT_SERVER_EXT_ERROR,&error);
    if (! result ) 
    {
       winrc = error;
    }
    else
    {
       err.DbgMsgWrite(0,L"Failed to get extended error, result=%ld",result);
       winrc = LdapMapErrorToWin32(ldaprc);
    }
     
  }

   
  err.DbgMsgWrite(0,L"\nMoveObject(sSourceDN=%ls\n,sTargetRDN=%ls\n,sTargetContainer=%ls\n,pTargetDSA=%S)  rc=%ld,ldapRC=%ld",
                              sSourceDN,targetRDN,sTargetContainer,pTgtDSA,winrc,ldaprc);
                                        
  err.LogClose();
  
  free(pTgtDSA);

   if ( SUCCEEDED(winrc))
      return HRESULT_FROM_WIN32(winrc);
   else 
      return winrc;
}



         
STDMETHODIMP CMover::CheckMove(BSTR sourcePath, BSTR targetRDN, BSTR targetOUPath )
{
	WCHAR                     sTargetContainer[LEN_Path];
   WCHAR                     sSourceDN[LEN_Path];
   WCHAR                     sTargetRDN[LEN_Path];
   WCHAR                     sTargetDSA[LEN_Path];
   char                    * pTgtDSA = NULL;
   WCHAR             const * prefix = L"LDAP://";
   HRESULT                   hr = S_OK;
   
   // set up the arguments needed to call the interdomain move operation
   UStrCpy(sTargetDSA,m_targetDSA);
   pTgtDSA = MakeNarrowString(sTargetDSA);
   

   // the source path and target OuPath are provided in the LDAP:// format
   
   // get the target container, target DN, and source DN in canonical LDAP format

   if ( !UStrICmp(targetOUPath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(targetOUPath+UStrLen(prefix) + 1,L'/');
      if ( start )
      {
         UStrCpy(sTargetContainer,start + 1);
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }
   if ( !UStrICmp(sourcePath,prefix,UStrLen(prefix)) )
   {
      WCHAR * start = wcschr(sourcePath+UStrLen(prefix)+1,L'/');
      if ( start )
      {
         UStrCpy(sSourceDN,start+1);
         UStrCpy(sTargetRDN,start + 1);
         WCHAR * temp = wcschr(sTargetRDN,L',');
         if ( temp )
         {
            (*temp) = 0;
         }
      }
      else
      {
         // error!
         hr = E_INVALIDARG;
      }
   }

   StripDN(sSourceDN);
   StripDN(sTargetRDN);
   StripDN(sTargetContainer);
   
   berval  Value;
   // this call will just do the source domain checks, so pass in NULL for the target domain
   Value.bv_val = NULL;
   Value.bv_len = 0;

   LDAPControl   ServerControl;
   LDAPControl * ServerControls[2];
   LDAPControl * ClientControls = NULL;

   ServerControl.ldctl_oid = LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W;
   ServerControl.ldctl_value = Value;
   ServerControl.ldctl_iscritical = TRUE;

   ServerControls[0] = NULL;
   ServerControls[0] = &ServerControl;
   ServerControls[1] = NULL;
   
   /*
    DstDSA = dns name of dc
    Dn = distinguished name of object to be moved
    NewRdn = relative distinguished name of object 
    NewParent = distinguished name of new parent container
    ServerControls= specify the LDAP operational control for cross domain move
   */ 
   DWORD             ldaprc = ldap_rename_ext_s(m_srcLD, 
                              sSourceDN, 
                              targetRDN, 
                              sTargetContainer, 
                              TRUE,
                              ServerControls, 
                              &ClientControls
                          );

  DWORD            winrc = 0;
  ULONG            error;
  ULONG            result;
  WCHAR            logFile[LEN_Path];

   if ( ldaprc )
   {
      result =  ldap_get_option(m_srcLD, LDAP_OPT_SERVER_EXT_ERROR,&error);
      if (! result ) 
      {
         winrc = error;
      }
      else
      {
         err.DbgMsgWrite(0,L"Failed to get extended error, result=%ld",result);
         winrc = LdapMapErrorToWin32(ldaprc);
      }
   }

   if ( MoverTraceLogging(logFile) )
   {
      err.LogOpen(logFile,1);
   }
 
  err.DbgMsgWrite(0,L"\nMoveObject(sSourceDN=%ls\n,sTargetRDN=%ls\n,sTargetContainer=%ls\n,pTargetDSA=%S)  rc=%ld,ldapRC=%ld,result=%ld",
                              sSourceDN,targetRDN,sTargetContainer,pTgtDSA,winrc,ldaprc,result);
                                        
  err.LogClose();
  
  free(pTgtDSA);

   if ( SUCCEEDED(winrc))
      return HRESULT_FROM_WIN32(winrc);
   else 
      return winrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\mover.h ===
// Mover.h: Definition of the CMover class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MOVER_H__42ADFF02_491E_11D3_8AEE_00A0C9AFE114__INCLUDED_)
#define AFX_MOVER_H__42ADFF02_491E_11D3_8AEE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "winldap.h"


/////////////////////////////////////////////////////////////////////////////
// CMover

class CMover : 
	public IDispatchImpl<IMover, &IID_IMover, &LIBID_MOVEOBJLib>, 
	public ISupportErrorInfoImpl<&IID_IMover>,
	public CComObjectRoot,
	public CComCoClass<CMover,&CLSID_Mover>
{
public:
	CMover() {m_srcLD = NULL; m_tgtLD = NULL;}
   ~CMover() { Close(); }
BEGIN_COM_MAP(CMover)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMover)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CMover) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_Mover)

// IMover
public:
	STDMETHOD(MoveObject)(BSTR sourcePath, BSTR targetRDN,BSTR targetOuPath);
	STDMETHOD(CheckMove)(BSTR sourcePath, BSTR targetRDN,BSTR targetOuPath);
	STDMETHOD(Close)();
	STDMETHOD(Connect)(BSTR sourceComp, BSTR targetComp, BSTR srcCredDomain, BSTR srcCredAccount, BSTR srcCredPassword,
                     BSTR tgtCredDomain, BSTR tgtCredAccount, BSTR tgtCredPassword);
protected:
   LDAP        * m_srcLD;
   LDAP        * m_tgtLD;
   WCHAR         m_sourceDSA[300];
   WCHAR         m_targetDSA[300];
};

#endif // !defined(AFX_MOVER_H__42ADFF02_491E_11D3_8AEE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\moveobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__B6111B11_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__B6111B11_491D_11D3_8AEE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B6111B11_491D_11D3_8AEE_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\admtcrypt.cpp ===
#include <StdAfx.h>
#include "AdmtCrypt.h"

#include <NtSecApi.h>

#pragma comment( lib, "AdvApi32.lib" )


namespace
{

void __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray)
{
	vntByteArray.Clear();

	vntByteArray.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntByteArray.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntByteArray.vt = VT_UI1|VT_ARRAY;
}

_variant_t operator +(const _variant_t& vntByteArrayA, const _variant_t& vntByteArrayB)
{
	_variant_t vntByteArrayC;

	// validate parameters

	if ((vntByteArrayA.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayA.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntByteArrayB.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayB.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// concatenate byte arrays

	DWORD cbA = vntByteArrayA.parray->rgsabound[0].cElements;
	DWORD cbB = vntByteArrayB.parray->rgsabound[0].cElements;

	CreateByteArray(cbA + cbB, vntByteArrayC);

	memcpy(vntByteArrayC.parray->pvData, vntByteArrayA.parray->pvData, cbA);
	memcpy((BYTE*)vntByteArrayC.parray->pvData + cbA, vntByteArrayB.parray->pvData, cbB);

	return vntByteArrayC;
}

#ifdef _DEBUG

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	_bstr_t strArray;

	if ((vnt.vt == (VT_UI1|VT_ARRAY)) && ((vnt.parray != NULL)))
	{
		_TCHAR szArray[256] = _T("");

		DWORD c = vnt.parray->rgsabound[0].cElements;
		BYTE* pb = (BYTE*) vnt.parray->pvData;

		for (DWORD i = 0; i < c; i++, pb++)
		{
			_TCHAR sz[48];
			wsprintf(sz, _T("%02X"), (UINT)(USHORT)*pb);

			if (i > 0)
			{
				_tcscat(szArray, _T(" "));
			}

			_tcscat(szArray, sz);
		}

		strArray = szArray;
	}

	return strArray;
}

#define TRACE_BUFFER_SIZE 1024

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
	_TCHAR szMessage[TRACE_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);

		_vsntprintf(szMessage, TRACE_BUFFER_SIZE, pszFormat, args);

		va_end(args);

	#if 0
		OutputDebugString(szMessage);
	#else
		HANDLE hFile = CreateFile(L"C:\\AdmtCrypt.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(hFile, 0, NULL, FILE_END);
			DWORD dwWritten;
			WriteFile(hFile, szMessage, _tcslen(szMessage) * sizeof(_TCHAR), &dwWritten, NULL);
			CloseHandle(hFile);
		}
	#endif
	}
}

#else

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	return _T("");
}

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
}

#endif

}


//---------------------------------------------------------------------------
// Target Crypt Class
//---------------------------------------------------------------------------


// Constructor

CTargetCrypt::CTargetCrypt()
{
	Trace(_T("CTargetCrypt::CTargetCrypt()\r\n"));
}


// Destructor

CTargetCrypt::~CTargetCrypt()
{
	Trace(_T("CTargetCrypt::~CTargetCrypt()\r\n"));
}


// CreateEncryptionKey Method

_variant_t CTargetCrypt::CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword)
{
	Trace(_T("CreateEncryptionKey(pszKeyId='%s', pszPassword='%s')\r\n"), pszKeyId, pszPassword);

	// generate encryption key bytes

	_variant_t vntBytes = GenerateRandom(ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// store encryption key bytes

	StoreBytes(pszKeyId, vntBytes);

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	_variant_t vntPasswordFlag;
	CreateByteArray(1, vntPasswordFlag);
	*((BYTE*)vntPasswordFlag.parray->pvData) = (pszPassword && pszPassword[0]) ? 0xFF : 0x00;

	// concatenate encryption key bytes and hash of encryption key bytes

	CCryptHash hashBytes(CreateHash(CALG_SHA1));
	hashBytes.Hash(vntBytes);

	_variant_t vntDecrypted = vntBytes + hashBytes.GetValue();

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// encrypt bytes / hash pair

	_variant_t vntEncrypted = keyPassword.Encrypt(NULL, true, vntDecrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	return vntPasswordFlag + vntEncrypted;
}


// CreateSession Method

_variant_t CTargetCrypt::CreateSession(LPCTSTR pszKeyId)
{
	Trace(_T("CreateSession(pszKeyId='%s')\r\n"), pszKeyId);

	// get encryption key

	CCryptHash hashEncryption(CreateHash(CALG_SHA1));
	hashEncryption.Hash(RetrieveBytes(pszKeyId));

	CCryptKey keyEncryption(DeriveKey(CALG_3DES, hashEncryption));

	// generate session key bytes

	_variant_t vntBytes = GenerateRandom(SESSION_KEY_SIZE);

	// create session key

	CCryptHash hash(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	m_keySession.Attach(DeriveKey(CALG_3DES, hash));

	// concatenate session key bytes and hash of session key bytes

	_variant_t vntDecrypted = vntBytes + hash.GetValue();

	// encrypt session bytes and include hash

	return keyEncryption.Encrypt(NULL, true, vntDecrypted);
}


// Encrypt Method

_variant_t CTargetCrypt::Encrypt(_bstr_t strData)
{
	Trace(_T("Encrypt(strData='%s')\r\n"), (LPCTSTR)strData);

	// convert string to byte array

	_variant_t vnt;

	HRESULT hr = VectorFromBstr(strData, &vnt.parray);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	vnt.vt = VT_UI1|VT_ARRAY;

	// encrypt data

	return m_keySession.Encrypt(NULL, true, vnt);
}


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------


// Constructor

CSourceCrypt::CSourceCrypt()
{
	Trace(_T("CSourceCrypt::CSourceCrypt()\r\n"));
}


// Destructor

CSourceCrypt::~CSourceCrypt()
{
	Trace(_T("CSourceCrypt::~CSourceCrypt()\r\n"));
}


// ImportEncryptionKey Method

void CSourceCrypt::ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword)
{
	Trace(_T("ImportEncryptionKey(vntEncryptedKey={ %s }, pszPassword='%s')\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey), pszPassword);

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// extract password flag and verify with password

	bool bPassword = *((BYTE*)vntEncryptedKey.parray->pvData) ? true : false;

	if (bPassword)
	{
		if ((pszPassword == NULL) || (pszPassword[0] == NULL))
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}
	else
	{
		if (pszPassword && pszPassword[0])
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	// encrypted data

	_variant_t vntEncrypted;
	DWORD cbEncrypted = vntEncryptedKey.parray->rgsabound[0].cElements - 1;
	CreateByteArray(cbEncrypted, vntEncrypted);
	memcpy(vntEncrypted.parray->pvData, (BYTE*)vntEncryptedKey.parray->pvData + 1, cbEncrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	// decrypt encryption key bytes plus hash

	_variant_t vntDecrypted = keyPassword.Decrypt(NULL, true, vntEncrypted);

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// extract encryption key bytes

	_variant_t vntBytes;
	CreateByteArray(ENCRYPTION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, (BYTE*)vntDecrypted.parray->pvData, ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// extract hash of encryption key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - ENCRYPTION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + ENCRYPTION_KEY_SIZE, cbHashValue);

//	Trace(_T(" vntHashValue={ %s }\n"), (LPCTSTR)DebugByteArray(vntHashValue));

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare store encryption key bytes

	if (hashA == hashB)
	{
		StoreBytes(m_szIdPrefix, vntBytes);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}
}


// ImportSessionKey Method

void CSourceCrypt::ImportSessionKey(const _variant_t& vntEncryptedKey)
{
	Trace(_T("ImportSessionKey(vntEncryptedKey={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey));

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encryption key

	CCryptKey keyEncryption(GetEncryptionKey(m_szIdPrefix));

	// decrypt session key bytes plus hash

	_variant_t vntDecrypted = keyEncryption.Decrypt(NULL, true, vntEncryptedKey);

	// extract session key bytes

	_variant_t vntBytes;
	CreateByteArray(SESSION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, vntDecrypted.parray->pvData, SESSION_KEY_SIZE);

	// extract hash of session key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - SESSION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + SESSION_KEY_SIZE, cbHashValue);

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare

	if (hashA == hashB)
	{
		// derive session key from session key bytes hash

		m_keySession.Attach(DeriveKey(CALG_3DES, hashA));
	}
	else
	{
		_com_issue_error(E_FAIL);
	}
}


// Decrypt Method

_bstr_t CSourceCrypt::Decrypt(const _variant_t& vntData)
{
	Trace(_T("Decrypt(vntData={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntData));

	// decrypt data

	_variant_t vnt = m_keySession.Decrypt(NULL, true, vntData);

	// convert into string

	BSTR bstr;

	HRESULT hr = BstrFromVector(vnt.parray, &bstr);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	return bstr;
}


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------


// Constructor

CDomainCrypt::CDomainCrypt()
{
	Trace(_T("CDomainCrypt::CDomainCrypt()\r\n"));
}


// Destructor

CDomainCrypt::~CDomainCrypt()
{
	Trace(_T("CDomainCrypt::~CDomainCrypt()\r\n"));
}


// GetEncryptionKey Method

HCRYPTKEY CDomainCrypt::GetEncryptionKey(LPCTSTR pszKeyId)
{
	// retrieve bytes

	_variant_t vntBytes = RetrieveBytes(pszKeyId);

	// set hash value

	CCryptHash hash;
	hash.Attach(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	// create encryption key derived from bytes

	return DeriveKey(CALG_3DES, hash);
}


// StoreBytes Method

void CDomainCrypt::StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
{
	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt != VT_EMPTY) && (vntBytes.vt != (VT_UI1|VT_ARRAY)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt == (VT_UI1|VT_ARRAY)) && (vntBytes.parray == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_CREATE_SECRET, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// store data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		PWSTR pwsData = NULL;
		USHORT cbData = 0;

		if (vntBytes.vt != VT_EMPTY)
		{
			pwsData = reinterpret_cast<PWSTR>(vntBytes.parray->pvData);
			cbData = (USHORT) vntBytes.parray->rgsabound[0].cElements;
		}

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		LSA_UNICODE_STRING lusData = { cbData, cbData, pwsData };

		ntsStatus = LsaStorePrivateData(hPolicy, &lusKey, &lusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}
}


// RetrievePrivateData Method

_variant_t CDomainCrypt::RetrieveBytes(LPCTSTR pszId)
{
	_variant_t vntBytes;

	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// retrieve data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		PLSA_UNICODE_STRING plusData;

		ntsStatus = LsaRetrievePrivateData(hPolicy, &lusKey, &plusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		vntBytes.parray = SafeArrayCreateVector(VT_UI1, 0, plusData->Length);

		if (vntBytes.parray == NULL)
		{
			LsaFreeMemory(plusData);
			_com_issue_error(E_OUTOFMEMORY);
		}

		vntBytes.vt = VT_UI1|VT_ARRAY;

		memcpy(vntBytes.parray->pvData, plusData->Buffer, plusData->Length);

		LsaFreeMemory(plusData);

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}

	return vntBytes;
}


// private data key identifier

_TCHAR CDomainCrypt::m_szIdPrefix[] = _T("L$6A2899C0-CECE-459A-B5EB-7ED04DE61388");


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------


// Constructors
//
// Notes:
// If the enhanced provider is not installed, CryptAcquireContext() generates
// the following error: (0x80090019) The keyset is not defined.

CCryptProvider::CCryptProvider() :
	m_hProvider(NULL)
{
	Trace(_T("E CCryptProvider::CCryptProvider(this=0x%p)\r\n"), this);

	if (!CryptAcquireContext(&m_hProvider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

#ifdef _DEBUG
	char szProvider[256];
	DWORD cbProvider = sizeof(szProvider);

	if (CryptGetProvParam(m_hProvider, PP_NAME, (BYTE*) szProvider, &cbProvider, 0))
	{
	}

	DWORD dwVersion;
	DWORD cbVersion = sizeof(dwVersion);

	if (CryptGetProvParam(m_hProvider, PP_VERSION, (BYTE*) &dwVersion, &cbVersion, 0))
	{
	}

//	char szContainer[256];
//	DWORD cbContainer = sizeof(szContainer);

//	if (CryptGetProvParam(m_hProvider, PP_CONTAINER, (BYTE*) szContainer, &cbContainer, 0))
//	{
//	}
#endif

	Trace(_T("L CCryptProvider::CCryptProvider()\r\n"));
}

CCryptProvider::CCryptProvider(const CCryptProvider& r) :
	m_hProvider(r.m_hProvider)
{
//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}
}


// Destructor

CCryptProvider::~CCryptProvider()
{
	Trace(_T("E CCryptProvider::~CCryptProvider()\r\n"));

	if (m_hProvider)
	{
		if (!CryptReleaseContext(m_hProvider, 0))
		{
			#ifdef _DEBUG
			DebugBreak();
			#endif
		}
	}

	Trace(_T("L CCryptProvider::~CCryptProvider()\r\n"));
}


// assignment operators

CCryptProvider& CCryptProvider::operator =(const CCryptProvider& r)
{
	m_hProvider = r.m_hProvider;

//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}

	return *this;
}


// CreateHash Method

HCRYPTHASH CCryptProvider::CreateHash(ALG_ID aid)
{
	HCRYPTHASH hHash;

	if (!CryptCreateHash(m_hProvider, aid, 0, 0, &hHash))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hHash;
}


// DeriveKey Method

HCRYPTKEY CCryptProvider::DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags)
{
	HCRYPTKEY hKey;

	if (!CryptDeriveKey(m_hProvider, aid, hHash, dwFlags, &hKey))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hKey;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

_variant_t CCryptProvider::GenerateRandom(DWORD dwNumberOfBytes) const
{
	_variant_t vntRandom;

	// create byte array of specified length

	vntRandom.parray = SafeArrayCreateVector(VT_UI1, 0, dwNumberOfBytes);

	if (vntRandom.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntRandom.vt = VT_UI1|VT_ARRAY;

	// generate specified number of random bytes

	GenerateRandom((BYTE*)vntRandom.parray->pvData, dwNumberOfBytes);

	return vntRandom;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

void CCryptProvider::GenerateRandom(BYTE* pbData, DWORD cbData) const
{
	// generate specified number of random bytes

	if (!CryptGenRandom(m_hProvider, cbData, pbData))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}
}


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------


// Constructor

CCryptKey::CCryptKey(HCRYPTKEY hKey) :
	m_hKey(hKey)
{
}


// Destructor

CCryptKey::~CCryptKey()
{
	if (m_hKey)
	{
		if (!CryptDestroyKey(m_hKey))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// Encrypt Method

_variant_t CCryptKey::Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntEncrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encrypted data size

	DWORD cbData = vntData.parray->rgsabound[0].cElements;
	DWORD cbBuffer = cbData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, NULL, &cbBuffer, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create encrypted data buffer

	vntEncrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cbBuffer);

	if (vntEncrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntEncrypted.vt = VT_UI1|VT_ARRAY;

	// copy data to encrypted buffer

	memcpy(vntEncrypted.parray->pvData, vntData.parray->pvData, cbData);

	// encrypt data

	BYTE* pbData = (BYTE*) vntEncrypted.parray->pvData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pbData, &cbData, cbBuffer))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntEncrypted;
}


// Decrypt Method

_variant_t CCryptKey::Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntDecrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// decrypt data

	_variant_t vnt = vntData;

	BYTE* pb = (BYTE*) vnt.parray->pvData;
	DWORD cb = vnt.parray->rgsabound[0].cElements;

	if (!CryptDecrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pb, &cb))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create decrypted byte array
	// the number of decrypted bytes may be less than
	// the number of encrypted bytes

	vntDecrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntDecrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntDecrypted.vt = VT_UI1|VT_ARRAY;

	memcpy(vntDecrypted.parray->pvData, vnt.parray->pvData, cb);

	return vntDecrypted;
}


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------


// Constructor

CCryptHash::CCryptHash(HCRYPTHASH hHash) :
	m_hHash(hHash)
{
}


// Destructor

CCryptHash::~CCryptHash()
{
	if (m_hHash)
	{
		if (!CryptDestroyHash(m_hHash))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// GetValue Method

_variant_t CCryptHash::GetValue() const
{
	_variant_t vntValue;

	// get hash size

	DWORD dwHashSize;
	DWORD cbHashSize = sizeof(DWORD);

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// allocate buffer

	vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, dwHashSize);

	if (vntValue.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntValue.vt = VT_UI1|VT_ARRAY;

	// get hash value

	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, (BYTE*)vntValue.parray->pvData, &dwHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntValue;
}


// SetValue Method

void CCryptHash::SetValue(const _variant_t& vntValue)
{
	// if parameter is valid

	if ((vntValue.vt == (VT_UI1|VT_ARRAY)) && ((vntValue.parray != NULL)))
	{
		// get hash size

		DWORD dwHashSize;
		DWORD cbHashSize = sizeof(DWORD);

		if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		// validate hash size

		BYTE* pbValue = (BYTE*)vntValue.parray->pvData;
		DWORD cbValue = vntValue.parray->rgsabound[0].cElements;

		if (cbValue != dwHashSize)
		{
			_com_issue_error(E_INVALIDARG);
		}

		// set hash value

		if (!CryptSetHashParam(m_hHash, HP_HASHVAL, (BYTE*)pbValue, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(LPCTSTR pszData)
{
	if (pszData && pszData[0])
	{
		Hash((BYTE*)pszData, _tcslen(pszData) * sizeof(_TCHAR));
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(const _variant_t& vntData)
{
	if ((vntData.vt == (VT_UI1|VT_ARRAY)) && ((vntData.parray != NULL)))
	{
		Hash((BYTE*)vntData.parray->pvData, vntData.parray->rgsabound[0].cElements);
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(BYTE* pbData, DWORD cbData)
{
	if ((pbData != NULL) && (cbData > 0))
	{
		if (!CryptHashData(m_hHash, pbData, cbData, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


bool CCryptHash::operator ==(const CCryptHash& hash)
{
	bool bEqual = false;

	DWORD cbSize = sizeof(DWORD);

	// compare hash sizes

	DWORD dwSizeA;
	DWORD dwSizeB;

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeA, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	if (!CryptGetHashParam(hash.m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeB, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// if sizes are equal

	if (dwSizeA == dwSizeB)
	{
		// compare hashes

		BYTE* pbA;
		BYTE* pbB;

		try
		{
			pbA = (BYTE*) _alloca(dwSizeA);
			pbB = (BYTE*) _alloca(dwSizeB);
		}
		catch (...)
		{
			_com_issue_error(E_OUTOFMEMORY);
		}

		if (!CryptGetHashParam(m_hHash, HP_HASHVAL, pbA, &dwSizeA, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (!CryptGetHashParam(hash.m_hHash, HP_HASHVAL, pbB, &dwSizeB, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (memcmp(pbA, pbB, dwSizeA) == 0)
		{
			bEqual = true;
		}
	}

	return bEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\mspwdmig.cpp ===
// MsPwdMig.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MsPwdMigps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MsPwdMig.h"

#include "MsPwdMig_i.c"
#include "PasswordMigration.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_PasswordMigration, CPasswordMigration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_MsPwdMig);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\error.h ===
#pragma once

#include <ComDef.h>


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


void __cdecl ThrowError(_com_error ce, UINT uId, ...);
void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat = NULL, ...);
void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);


HRESULT __cdecl SetError(_com_error ce, UINT uId, ...);
HRESULT __cdecl SetError(_com_error ce, LPCTSTR pszFormat = NULL, ...);
HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...);
HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat = NULL, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\stdafx.h ===
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <ComDef.h>

//{{AFX_INSERT_LOCATION}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\passwordmigration.h ===
#pragma once

#include <memory>
#include "Resource.h"
#include "ADMTCrypt.h"


//---------------------------------------------------------------------------
// CPasswordMigration
//---------------------------------------------------------------------------

class ATL_NO_VTABLE CPasswordMigration : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPasswordMigration, &CLSID_PasswordMigration>,
	public ISupportErrorInfoImpl<&IID_IPasswordMigration>,
	public IDispatchImpl<IPasswordMigration, &IID_IPasswordMigration, &LIBID_MsPwdMig>
{
public:

	CPasswordMigration();
	~CPasswordMigration();

	DECLARE_REGISTRY_RESOURCEID(IDR_PASSWORDMIGRATION)
	DECLARE_NOT_AGGREGATABLE(CPasswordMigration)
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	BEGIN_COM_MAP(CPasswordMigration)
		COM_INTERFACE_ENTRY(IPasswordMigration)
		COM_INTERFACE_ENTRY(IDispatch)
		COM_INTERFACE_ENTRY(ISupportErrorInfo)
	END_COM_MAP()

	// IPasswordMigration
	STDMETHOD(EstablishSession)(BSTR bstrSourceServer, BSTR bstrTargetServer);
	STDMETHOD(CopyPassword)(BSTR bstrSourceAccount, BSTR bstrTargetAccount, BSTR bstrTargetPassword);
	STDMETHOD(GenerateKey)(BSTR bstrSourceDomainFlatName, BSTR bstrKeyFilePath, BSTR bstrPassword);

protected:

	void GenerateKeyImpl(LPCTSTR pszDomain, LPCTSTR pszFile, LPCTSTR pszPassword);
	void CheckPasswordDC(LPCWSTR srcServer, LPCWSTR tgtServer);
	void CopyPasswordImpl(LPCTSTR pszSourceAccount, LPCTSTR pszTargetAccount, LPCTSTR pszPassword);

	static void GetDomainName(LPCTSTR pszServer, _bstr_t& strNameDNS, _bstr_t& strNameFlat);
	static BOOL IsEveryoneInPW2KCAGroup(LPCWSTR sTgtDomainDNS);
	static _bstr_t GetPathToPreW2KCAGroup();
	static BOOL DoesAnonymousHaveEveryoneAccess(LPCWSTR tgtServer);

protected:

	bool m_bSessionEstablished;

	_bstr_t m_strSourceServer;
	_bstr_t m_strTargetServer;

	_bstr_t m_strSourceDomainDNS;
	_bstr_t m_strSourceDomainFlat;
	_bstr_t m_strTargetDomainDNS;
	_bstr_t m_strTargetDomainFlat;

	std::auto_ptr<CTargetCrypt> m_pTargetCrypt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\error.cpp ===
#include "StdAfx.h"
#include "Error.h"


using namespace _com_util;

#define FORMAT_BUFFER_SIZE	    1024
#define DESCRIPTION_BUFFER_SIZE 2048

#define COUNT_OF(a) (sizeof(a) / sizeof(a[0]))
#define LENGTH_OF(a) (sizeof(a) / sizeof(a[0]) - sizeof(a[0]))


namespace
{


// AdmtCreateErrorInfo Method

IErrorInfoPtr __stdcall AdmtCreateErrorInfo(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	ICreateErrorInfoPtr spCreateErrorInfo;

	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
		IErrorInfoPtr spErrorInfo = ce.ErrorInfo();

//		if (spErrorInfo == NULL)
//		{
//			GetErrorInfo(0, &spErrorInfo);
//		}

		// source

		if (IsEqualCLSID(clsid, GUID_NULL) == FALSE)
		{
			LPOLESTR pszProgId;

			if (ProgIDFromCLSID(clsid, &pszProgId) == S_OK)
			{
				spCreateErrorInfo->SetSource(pszProgId);
				CoTaskMemFree(pszProgId);
			}
			else
			{
				spCreateErrorInfo->SetSource(L"");
			}
		}
		else if (spErrorInfo)
		{
			BSTR bstrSource;
			spErrorInfo->GetSource(&bstrSource);
			spCreateErrorInfo->SetSource(bstrSource);
			SysFreeString(bstrSource);
		}
		else
		{
			spCreateErrorInfo->SetSource(L"");
		}

		// GUID

		bool bInterfaceSpecified = false;

		if (IsEqualIID(iid, GUID_NULL) == FALSE)
		{
			spCreateErrorInfo->SetGUID(iid);
			bInterfaceSpecified = true;
		}
		else if (spErrorInfo)
		{
			GUID guid;
			spErrorInfo->GetGUID(&guid);
			spCreateErrorInfo->SetGUID(guid);
		}
		else
		{
			spCreateErrorInfo->SetGUID(GUID_NULL);
		}

		// description

		_bstr_t strDescription = pszDescription;

		if (spErrorInfo)
		{
/*
			BSTR bstrSource;
			spErrorInfo->GetSource(&bstrSource);

			if (SysStringLen(bstrSource) > 0)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" : ");
				}

				strDescription += bstrSource;
			}

			SysFreeString(bstrSource);
*/
			BSTR bstrDescription;
			spErrorInfo->GetDescription(&bstrDescription);

			if (SysStringLen(bstrDescription) > 0)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" ");
				}

				strDescription += bstrDescription;
			}
			else if (bInterfaceSpecified == false)
			{
				LPCTSTR pszErrorMessage = ce.ErrorMessage();

				if (pszErrorMessage)
				{
					if (strDescription.length() > 0)
					{
						strDescription += _T(" ");
					}

					strDescription += pszErrorMessage;
				}
			}

			SysFreeString(bstrDescription);
		}
		else if (bInterfaceSpecified == false)
		{
			LPCTSTR pszErrorMessage = ce.ErrorMessage();

			if (pszErrorMessage)
			{
				if (strDescription.length() > 0)
				{
					strDescription += _T(" ");
				}

				strDescription += pszErrorMessage;
			}
		}

		spCreateErrorInfo->SetDescription(strDescription);

		// help file

		if (spErrorInfo)
		{
			BSTR bstrHelpFile;
			spErrorInfo->GetHelpFile(&bstrHelpFile);
			spCreateErrorInfo->SetHelpFile(bstrHelpFile);
			SysFreeString(bstrHelpFile);
		}
		else
		{
			spCreateErrorInfo->SetHelpFile(L"");
		}

		// help context

		DWORD dwHelpContext = 0;

		if (spErrorInfo)
		{
			spErrorInfo->GetHelpContext(&dwHelpContext);
		}

		spCreateErrorInfo->SetHelpContext(dwHelpContext);
	}

	return IErrorInfoPtr(spCreateErrorInfo);
}


// ThrowErrorImpl Method

inline void __stdcall ThrowErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	IErrorInfoPtr spErrorInfo = AdmtCreateErrorInfo(clsid, iid, ce, pszDescription);

	if (spErrorInfo)
	{
		_com_raise_error(ce.Error(), spErrorInfo.Detach());
	}
	else
	{
		_com_raise_error(ce.Error());
	}
}


// SetErrorImpl Method

inline HRESULT __stdcall SetErrorImpl(const CLSID& clsid, const IID& iid, const _com_error& ce, LPCTSTR pszDescription)
{
	SetErrorInfo(0, AdmtCreateErrorInfo(clsid, iid, ce, pszDescription));

	return ce.Error();
}


} // namespace


//---------------------------------------------------------------------------
// Error Methods
//---------------------------------------------------------------------------


//
// ThrowError Methods
//


void __cdecl ThrowError(_com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[FORMAT_BUFFER_SIZE];
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[FORMAT_BUFFER_SIZE];
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(clsid, iid, ce, szDescription);
}


void __cdecl ThrowError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(clsid, iid, ce, szDescription);
}


//
// SetError Methods
//


HRESULT __cdecl SetError(_com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[FORMAT_BUFFER_SIZE];
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return SetErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


HRESULT __cdecl SetError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return SetErrorImpl(GUID_NULL, GUID_NULL, ce, szDescription);
}


HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[FORMAT_BUFFER_SIZE];
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (LoadString(_Module.GetResourceInstance(), uId, szFormat, COUNT_OF(szFormat)))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, COUNT_OF(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return SetErrorImpl(clsid, iid, ce, szDescription);
}


HRESULT __cdecl SetError(const CLSID& clsid, const IID& iid, _com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[DESCRIPTION_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, COUNT_OF(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	return SetErrorImpl(clsid, iid, ce, szDescription);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MsPwdMig.rc
//
#define IDS_PROJNAME                    100
#define IDR_PASSWORDMIGRATION           101
#define IDS_E_CANNOT_ESTABLISH_SESSION  101
#define IDS_E_CANNOT_COPY_PASSWORD      102
#define IDS_E_CANNOT_GENERATE_KEY       103
#define IDS_E_KEY_DOMAIN_NOT_SPECIFIED  104
#define IDS_E_KEY_FILE_NOT_SPECIFIED    105
#define IDS_E_KEY_FILE_NOT_LOCAL_DRIVE  106
#define IDS_E_KEY_FILE_EXTENSION_INVALID 107
#define IDS_E_KEY_CANT_CREATE_FILE      108
#define IDS_E_KEY_CANT_WRITE_FILE       109
#define IDS_E_CANNOT_GET_DOMAIN_NAME    110
#define IDS_E_EVERYONE_NOT_MEMBEROF_GROUP 111
#define IDS_E_EVERYONE_DOES_NOT_INCLUDE_ANONYMOUS 112
#define IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED 113
#define IDS_E_ENCRYPTION_OBJECT_FAILURE 114
#define IDS_E_GENERATE_SESSION_KEY_FAILED 115
#define IDS_E_GENERATE_SESSION_PASSWORD_FAILED 116
#define IDS_E_PASSWORD_MIGRATION_NOT_ENABLED 117
#define IDS_E_ENCRYPTION_KEYS_DO_NOT_MATCH 118
#define IDS_E_PASSWORD_MIGRATION_NOT_RUNNING 119
#define IDS_E_SESSION_NOT_ESTABLISHED   120
#define IDS_E_PASSWORD_MIGRATION_NOT_FUNCTIONING 121
#define IDS_E_SOURCE_SERVER_NOT_SPECIFIED 122
#define IDS_E_TARGET_SERVER_NOT_SPECIFIED 123
#define IDS_E_SOURCE_ACCOUNT_NOT_SPECIFIED 124
#define IDS_E_TARGET_ACCOUNT_NOT_SPECIFIED 125
#define IDS_E_NO_ENCRYPTION_KEY_FOR_DOMAIN 126

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\mspwdmig\passwordmigration.cpp ===
#include "stdafx.h"
#include "MsPwdMig.h"
#include "PasswordMigration.h"

#include <NtSecApi.h>
#include <io.h>
#include <winioctl.h>
#include <lm.h>
#include <eh.h>
#include <ActiveDS.h>
#include <Dsrole.h>
#include "TReg.hpp"
#include "pwdfuncs.h"
#include "PWGen.hpp"
#include "UString.hpp"
#include "PwRpcUtl.h"
#include "PwdSvc.h"
#include "PwdSvc_c.c"
#include "Error.h"

#pragma comment(lib, "netapi32.lib")
#pragma comment(lib, "adsiid.lib")
#pragma comment(lib, "activeds.lib")
#pragma comment(lib, "commonlib.lib")


namespace 
{

#define GET_BYTE_ARRAY_DATA(v) ((char*)((v).parray->pvData))
#define GET_BYTE_ARRAY_SIZE(v) ((unsigned long)((v).parray->rgsabound[0].cElements))

struct SSeException
{
	SSeException(UINT uCode) :
		uCode(uCode)
	{
	}

	UINT uCode;
};

void SeTranslator(unsigned int u, EXCEPTION_POINTERS* pepExceptions)
{
	throw SSeException(u);
}

}
// namespace


//---------------------------------------------------------------------------
// CPasswordMigration
//---------------------------------------------------------------------------


// Constructor

CPasswordMigration::CPasswordMigration() :
	m_bSessionEstablished(false)
{
}


// Destructor

CPasswordMigration::~CPasswordMigration()
{
}


//
// IPasswordMigration Implementation ----------------------------------------
//


// EstablishSession Method

STDMETHODIMP CPasswordMigration::EstablishSession(BSTR bstrSourceServer, BSTR bstrTargetServer)
{
	HRESULT hr = S_OK;

	USES_CONVERSION;

	try
	{
		m_bSessionEstablished = false;

		CheckPasswordDC(OLE2CW(bstrSourceServer), OLE2CW(bstrTargetServer));

		m_bSessionEstablished = true;
	}
	catch (_com_error& ce)
	{
		hr = SetError(ce, IDS_E_CANNOT_ESTABLISH_SESSION);
	}

	return hr;
}


// CopyPassword Method

STDMETHODIMP CPasswordMigration::CopyPassword(BSTR bstrSourceAccount, BSTR bstrTargetAccount, BSTR bstrTargetPassword)
{
	HRESULT hr = S_OK;

	USES_CONVERSION;

	try
	{
		// if session established then...

		if (m_bSessionEstablished)
		{
			// copy password
			CopyPasswordImpl(OLE2CT(bstrSourceAccount), OLE2CT(bstrTargetAccount), OLE2CT(bstrTargetPassword));
		}
		else
		{
			// else return error
			ThrowError(PM_E_SESSION_NOT_ESTABLISHED, IDS_E_SESSION_NOT_ESTABLISHED);
		}
	}
	catch (_com_error& ce)
	{
		hr = SetError(ce, IDS_E_CANNOT_COPY_PASSWORD);
	}

	return hr;
}


// GenerateKey Method

STDMETHODIMP CPasswordMigration::GenerateKey(BSTR bstrSourceDomainFlatName, BSTR bstrKeyFilePath, BSTR bstrPassword)
{
	HRESULT hr = S_OK;

	USES_CONVERSION;

	try
	{
		GenerateKeyImpl(OLE2CT(bstrSourceDomainFlatName), OLE2CT(bstrKeyFilePath), OLE2CT(bstrPassword));
	}
	catch (_com_error& ce)
	{
		hr = SetError(ce, IDS_E_CANNOT_GENERATE_KEY);
	}

	return hr;
}


//
// Implementation -----------------------------------------------------------
//


// GenerateKeyImpl Method

void CPasswordMigration::GenerateKeyImpl(LPCTSTR pszDomain, LPCTSTR pszFile, LPCTSTR pszPassword)
{
	//
	// validate source domain name
	//

	if ((pszDomain == NULL) || (pszDomain[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_DOMAIN_NOT_SPECIFIED);
	}

	//
	// validate key file path
	//

	if ((pszFile == NULL) || (pszFile[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_FILE_NOT_SPECIFIED);
	}

	_TCHAR szDrive[_MAX_DRIVE];
	_TCHAR szExt[_MAX_EXT];

	_tsplitpath(pszFile, szDrive, NULL, NULL, szExt);

	// verify drive is a local drive

	_TCHAR szDrivePath[_MAX_PATH];
	_tmakepath(szDrivePath, szDrive, _T("\\"), NULL, NULL);

	if (GetDriveType(szDrivePath) == DRIVE_REMOTE)
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_FILE_NOT_LOCAL_DRIVE, pszFile);
	}

	// verify file extension is correct

	if (_tcsicmp(szExt, _T(".pes")) != 0)
	{
		ThrowError(E_INVALIDARG, IDS_E_KEY_FILE_EXTENSION_INVALID, szExt);
	}

	//
	// create encryption key and write to specified file
	//

	// create encryption key

	CTargetCrypt crypt;

	_variant_t vntKey = crypt.CreateEncryptionKey(pszDomain, pszPassword);

	// write encrypted key bytes to file

	HANDLE hFile = CreateFile(pszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		ThrowError(HRESULT_FROM_WIN32(GetLastError()), IDS_E_KEY_CANT_CREATE_FILE, pszFile);
	}

	DWORD dwWritten;

	BOOL bWritten = WriteFile(hFile, vntKey.parray->pvData, vntKey.parray->rgsabound[0].cElements, &dwWritten, NULL);

	CloseHandle(hFile);

	if (!bWritten)
	{
		ThrowError(HRESULT_FROM_WIN32(GetLastError()), IDS_E_KEY_CANT_WRITE_FILE, pszFile);
	}
}


#pragma optimize ("", off)

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is a wrapper around a password DC "CheckConfig" *
 * call that can be used by the GUI and scripting to test the given  *
 * DC.                                                               *
 *     First we connect to a remote Lsa notification package dll,    *
 * which should be installed on a DC in the source domain.  The      *
 * connect will be encrypted RPC.  The configuration check, which    *
 * establishes a temporary session for this check.                   *
 *     We will also check anonymous user right access on the target  *
 * domain.                                                           *
 *                                                                   *
 * 2001-04-19 Mark Oluper - updated for client component             *
 *********************************************************************/

//BEGIN CheckPasswordDC
void CPasswordMigration::CheckPasswordDC(LPCWSTR srcServer, LPCWSTR tgtServer)
{
/* local constants */
	const DWORD c_dwMinUC = 3;
	const DWORD c_dwMinLC = 3;
	const DWORD c_dwMinDigits = 3;
	const DWORD c_dwMinSpecial = 3;
	const DWORD c_dwMaxAlpha = 0;
	const DWORD c_dwMinLen = 14;

/* local variables */
	DWORD                     rc = 0;
	WCHAR                   * sBinding = NULL;
	HANDLE					 hBinding = NULL;
	WCHAR                     testPwd[PASSWORD_BUFFER_SIZE];
	WCHAR                     tempPwd[PASSWORD_BUFFER_SIZE];
	_variant_t				 varSession;
	_variant_t				 varTestPwd;

/* function body */
//	USES_CONVERSION;

	if ((srcServer == NULL) || (srcServer[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_SOURCE_SERVER_NOT_SPECIFIED);
	}

	if ((tgtServer == NULL) || (tgtServer[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_TARGET_SERVER_NOT_SPECIFIED);
	}

	  //make sure the server names start with "\\"
	if ((srcServer[0] != L'\\') && (srcServer[1] != L'\\'))
	{
		m_strSourceServer = L"\\\\";
		m_strSourceServer += srcServer;
	}
	else
		m_strSourceServer = srcServer;
	if ((tgtServer[0] != L'\\') && (tgtServer[1] != L'\\'))
	{
		m_strTargetServer = L"\\\\";
		m_strTargetServer += tgtServer;
	}
	else
		m_strTargetServer = tgtServer;

	//get the password DC's domain NETBIOS name
	GetDomainName(m_strSourceServer, m_strSourceDomainDNS, m_strSourceDomainFlat);

	//get the target DC's domain DNS name
	GetDomainName(m_strTargetServer, m_strTargetDomainDNS, m_strTargetDomainFlat);

	//check if "Everyone" has been added to the "Pre-Windows 2000 Compatible
	//Access" group
	if (!IsEveryoneInPW2KCAGroup(m_strTargetDomainDNS))
		ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_EVERYONE_NOT_MEMBEROF_COMPATIBILITY_GROUP, IDS_E_EVERYONE_NOT_MEMBEROF_GROUP, (LPCTSTR)m_strTargetDomainDNS);

	//check if anonymous user has been granted "Everyone" access, if the target
	//DC is Whistler or newer
	if (!DoesAnonymousHaveEveryoneAccess(m_strTargetServer))
		ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_EVERYONE_DOES_NOT_INCLUDE_ANONYMOUS, IDS_E_EVERYONE_DOES_NOT_INCLUDE_ANONYMOUS, (LPCTSTR)m_strTargetServer);

	//if the high encryption pack has not been installed on this target
	//DC, then return that information
	try
	{
		m_pTargetCrypt = std::auto_ptr<CTargetCrypt>(new CTargetCrypt);
	}
	catch (_com_error& ce)
	{
		if (ce.Error() == 0x80090019)
			ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_HIGH_ENCRYPTION_NOT_INSTALLED, IDS_E_HIGH_ENCRYPTION_NOT_INSTALLED);
		else
			throw;
	}

	rc = PwdBindCreate(m_strSourceServer,&hBinding,&sBinding,TRUE);

	if(rc != ERROR_SUCCESS)
	{
		_com_issue_error(HRESULT_FROM_WIN32(rc));
	}

	try
	{
		try
		{
			//create a session key that will be used to encrypt the user's
			//password for this set of accounts
			varSession = m_pTargetCrypt->CreateSession(m_strSourceDomainFlat);
		}
		catch (_com_error& ce)
		{
			if (ce.Error() == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
			{
				ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_NO_ENCRYPTION_KEY_FOR_DOMAIN, IDS_E_NO_ENCRYPTION_KEY_FOR_DOMAIN, (LPCTSTR)m_strTargetServer, (LPCTSTR)m_strSourceDomainFlat);
			}
			else
			{
				ThrowError(ce, IDS_E_GENERATE_SESSION_KEY_FAILED);
			}
		}

		//now create a complex password used by the "CheckConfig" call in
		//a challenge response.  If the returned password matches, then
		//the source DC has the proper encryption key.
		if (EaPasswordGenerate(c_dwMinUC, c_dwMinLC, c_dwMinDigits, c_dwMinSpecial, c_dwMaxAlpha, c_dwMinLen, testPwd, PASSWORD_BUFFER_SIZE))
		{
			ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_GENERATE_SESSION_PASSWORD_FAILED, IDS_E_GENERATE_SESSION_PASSWORD_FAILED);
		}

		//encrypt the password with the session key
		try
		{
			varTestPwd = m_pTargetCrypt->Encrypt(_bstr_t(testPwd));
		}
		catch (...)
		{
			ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_GENERATE_SESSION_PASSWORD_FAILED, IDS_E_GENERATE_SESSION_PASSWORD_FAILED);
		}

		_se_translator_function pfnSeTranslatorOld = _set_se_translator((_se_translator_function)SeTranslator);

		HRESULT hr;

		try
		{
			//check to see if the server-side DLL is ready to process
			//password migration requests
			hr = PwdcCheckConfig(
				hBinding,
				GET_BYTE_ARRAY_SIZE(varSession),
				GET_BYTE_ARRAY_DATA(varSession),
				GET_BYTE_ARRAY_SIZE(varTestPwd),
				GET_BYTE_ARRAY_DATA(varTestPwd),
				tempPwd
			);
		}
		catch (SSeException& e)
		{
			if (e.uCode == RPC_S_SERVER_UNAVAILABLE)
				ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_PASSWORD_MIGRATION_NOT_RUNNING, IDS_E_PASSWORD_MIGRATION_NOT_RUNNING);
			else
				_com_issue_error(HRESULT_FROM_WIN32(e.uCode));
		}

		_set_se_translator(pfnSeTranslatorOld);

		if (SUCCEEDED(hr))
		{
			if (UStrICmp(tempPwd,testPwd))
				ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_ENCRYPTION_KEYS_DO_NOT_MATCH, IDS_E_ENCRYPTION_KEYS_DO_NOT_MATCH);
		}
		else if (hr == PM_E_PASSWORD_MIGRATION_NOT_ENABLED)
		{
			ThrowError(__uuidof(PasswordMigration), __uuidof(IPasswordMigration), PM_E_PASSWORD_MIGRATION_NOT_ENABLED, IDS_E_PASSWORD_MIGRATION_NOT_ENABLED);
		}
		else
		{
			_com_issue_error(hr);
		}

		PwdBindDestroy(&hBinding,&sBinding);
	}
	catch (...)
	{
		PwdBindDestroy(&hBinding,&sBinding);
		throw;
	}
}
//END CheckPasswordDC

#pragma optimize ("", on)


//---------------------------------------------------------------------------
// CopyPassword Method
//
// Copies password via password migration server component installed on a
// password export server.
//
// 2001-04-19 Mark Oluper - re-wrote original written by Paul Thompson to
// incorporate changes required for client component
//---------------------------------------------------------------------------

void CPasswordMigration::CopyPasswordImpl(LPCTSTR pszSourceAccount, LPCTSTR pszTargetAccount, LPCTSTR pszPassword)
{
	if ((pszSourceAccount == NULL) || (pszSourceAccount[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_SOURCE_ACCOUNT_NOT_SPECIFIED);
	}

	if ((pszTargetAccount == NULL) || (pszTargetAccount[0] == NULL))
	{
		ThrowError(E_INVALIDARG, IDS_E_TARGET_ACCOUNT_NOT_SPECIFIED);
	}

	handle_t hBinding = 0;
	_TCHAR* sBinding = 0;

	try
	{
		// create binding to password export server

		DWORD dwError = PwdBindCreate(m_strSourceServer, &hBinding, &sBinding, TRUE);

		if (dwError != NO_ERROR)
		{
			_com_issue_error(HRESULT_FROM_WIN32(dwError));
		}

		// encrypt password

		_variant_t vntEncryptedPassword = m_pTargetCrypt->Encrypt(pszPassword);

		// copy password

		HRESULT hr = PwdcCopyPassword(
			hBinding,
			m_strTargetServer,
			pszSourceAccount,
			pszTargetAccount,
			GET_BYTE_ARRAY_SIZE(vntEncryptedPassword),
			GET_BYTE_ARRAY_DATA(vntEncryptedPassword)
		);

		if (FAILED(hr))
		{
			_com_issue_error(hr);
		}

		// destroy binding

		PwdBindDestroy(&hBinding, &sBinding);
	}
	catch (...)
	{
		if (hBinding)
		{
			PwdBindDestroy(&hBinding, &sBinding);
		}

		throw;
	}
}


//---------------------------------------------------------------------------
// GetDomainName Function
//
// Retrieves both the domain DNS name if available and the domain flat or
// NetBIOS name for the specified server.
//
// 2001-04-19 Mark Oluper - initial
//---------------------------------------------------------------------------

void CPasswordMigration::GetDomainName(LPCTSTR pszServer, _bstr_t& strNameDNS, _bstr_t& strNameFlat)
{
	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC ppdib;

	DWORD dwError = DsRoleGetPrimaryDomainInformation(pszServer, DsRolePrimaryDomainInfoBasic, (BYTE**)&ppdib);

	if (dwError != NO_ERROR)
	{
		ThrowError(HRESULT_FROM_WIN32(dwError), IDS_E_CANNOT_GET_DOMAIN_NAME, pszServer);
	}

	strNameDNS = ppdib->DomainNameDns;
	strNameFlat = ppdib->DomainNameFlat;

	DsRoleFreeMemory(ppdib);
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 APR 2001                                                  *
 *                                                                   *
 *     This function is responsible for checking if "Everyone" has   *
 * been added as a member of the "Pre-Windows 2000 Compatible Access"*
 * builtin group.  If not then anonymous user will not be able to    *
 * change a password on the target domain.  This function is a helper*
 * function for "CheckPasswordDC".                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN IsEveryoneInPW2KCAGroup
BOOL CPasswordMigration::IsEveryoneInPW2KCAGroup(LPCWSTR sTgtDomainDNS)
{
/* local constants */
   const LPWSTR		   sPreWindowsCont = L"CN=Pre-Windows 2000 Compatible Access,CN=Builtin";
   const LPWSTR		   sEveryOne = L"CN=S-1-1-0,CN=ForeignSecurityPrincipals";

/* local variables */
   IADs              * pAds = NULL;
   IADsGroup         * pGroup = NULL;
   HRESULT			   hr;
   WCHAR               sPath[1000];
   _variant_t          varNC;
   BOOL				   bSuccess = TRUE;
   BOOL				   bContinue = FALSE;
   _bstr_t			   sRDN;

/* function body */
      //get the RDN of the "Pre-Windows 2000 Compatible Access" group
   sRDN = GetPathToPreW2KCAGroup();
   if (sRDN.length() == 0)
      sRDN = sPreWindowsCont;

      //get the default naming context for this target domain
   wsprintf(sPath, L"LDAP://%s/rootDSE", (WCHAR*)sTgtDomainDNS);
   hr = ADsGetObject(sPath, IID_IADs, (void**)&pAds);
   if ( SUCCEEDED(hr) )
   {
      hr = pAds->Get(L"defaultNamingContext", &varNC);
	  if ( SUCCEEDED(hr) )
         bContinue = TRUE;
      pAds->Release();
   }

      //if we got the naming context, try to connect to the 
      //"Pre-Windows 2000 Compatible Access" group
   if (bContinue)
   {
      wsprintf(sPath, L"LDAP://%s/%s,%s", (WCHAR*)sTgtDomainDNS, (WCHAR*)sRDN, (WCHAR*) V_BSTR(&varNC));
      hr = ADsGetObject(sPath, IID_IADsGroup, (void**)&pGroup);
      if ( SUCCEEDED(hr) )
	  {
         VARIANT_BOOL bIsMem = VARIANT_FALSE;
	        //see if "Everyone" is a member
         wsprintf(sPath, L"LDAP://%s/%s,%s", (WCHAR*)sTgtDomainDNS, sEveryOne, (WCHAR*) V_BSTR(&varNC));
         hr = pGroup->IsMember(sPath, &bIsMem);
         if (( SUCCEEDED(hr) ) && (!bIsMem))
		 {
		    bSuccess = FALSE;
		 }
         pGroup->Release();
	  }
   }

   return bSuccess;
}
//END IsEveryoneInPW2KCAGroup


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 12 APR 2001                                                 *
 *                                                                   *
 *     This function is responsible for creating a path to the       *
 * "Pre-Windows 2000 Compatible Access" builtin group from its well- *
 * known RID.  This path will then be used by                        *
 * "IsEveryoneInPW2KCAGroup" to see if "Everyone" is in that group.  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetPathToPreW2KCAGroup
_bstr_t CPasswordMigration::GetPathToPreW2KCAGroup()
{
/* local constants */
   const LPWSTR		   sPreWindowsCont = L",CN=Builtin";

/* local variables */
   SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;
   PSID                      psidPreW2KCAGroup;
   _bstr_t					 sPath = L"";
   WCHAR                     account[MAX_PATH];
   WCHAR                     domain[MAX_PATH];
   DWORD                     lenAccount = MAX_PATH;
   DWORD                     lenDomain = MAX_PATH;
   SID_NAME_USE              snu;

/* function body */
      //create the SID for the "Pre-Windows 2000 Compatible Access" group
   if (!AllocateAndInitializeSid(&siaNtAuthority,
								 2,
								 SECURITY_BUILTIN_DOMAIN_RID,
								 DOMAIN_ALIAS_RID_PREW2KCOMPACCESS,
								 0, 0, 0, 0, 0, 0,
								 &psidPreW2KCAGroup))
      return sPath;

      //lookup the name attached to this SID
   if (!LookupAccountSid(NULL, psidPreW2KCAGroup, account, &lenAccount, domain, &lenDomain, &snu))
      return sPath;

   sPath = _bstr_t(L"CN=") + _bstr_t(account) + _bstr_t(sPreWindowsCont);
   FreeSid(psidPreW2KCAGroup); //free the SID

   return sPath;
}
//END GetPathToPreW2KCAGroup


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 APR 2001                                                  *
 *                                                                   *
 *     This function is responsible for checking if anonymous user   *
 * has been granted Everyone access if the target domain is Whistler *
 * or newer.  This function is a helper function for                 *
 * "CheckPasswordDC".                                                *
 *     If the "Let Everyone permissions apply to anonymous users"    *
 * security option has been enabled, then the LSA registry value of  *
 * "everyoneincludesanonymous" will be set to 0x1.  We will check    *
 * registry value.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN DoesAnonymousHaveEveryoneAccess
BOOL CPasswordMigration::DoesAnonymousHaveEveryoneAccess(LPCWSTR tgtServer)
{
/* local constants */
   const int	WINDOWS_2000_BUILD_NUMBER = 2195;

/* local variables */
   TRegKey		verKey, lsaKey, regComputer;
   BOOL			bAccess = TRUE;
   DWORD		rc = 0;
   DWORD		rval;
   WCHAR		sBuildNum[MAX_PATH];

/* function body */
	  //connect to the DC's HKLM registry key
   rc = regComputer.Connect(HKEY_LOCAL_MACHINE, tgtServer);
   if (rc == ERROR_SUCCESS)
   {
         //see if this machine is running Windows XP or newer by checking the
		 //build number in the registry.  If not, then we don't need to check
		 //for the new security option
      rc = verKey.OpenRead(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",&regComputer);
	  if (rc == ERROR_SUCCESS)
	  {
			//get the CurrentBuildNumber string
	     rc = verKey.ValueGetStr(L"CurrentBuildNumber", sBuildNum, MAX_PATH);
		 if (rc == ERROR_SUCCESS) 
		 {
			int nBuild = _wtoi(sBuildNum);
		    if (nBuild <= WINDOWS_2000_BUILD_NUMBER)
               return bAccess;
		 }
	  }
		 
	     //if Windows XP or greater, check for the option being enabled
	     //open the LSA key
      rc = lsaKey.OpenRead(L"System\\CurrentControlSet\\Control\\Lsa",&regComputer);
	  if (rc == ERROR_SUCCESS)
	  {
			//get the value of the "everyoneincludesanonymous" value
	     rc = lsaKey.ValueGetDWORD(L"everyoneincludesanonymous",&rval);
		 if (rc == ERROR_SUCCESS) 
		 {
		    if (rval == 0)
               bAccess = FALSE;
		 }
		 else
            bAccess = FALSE;
	  }
   }
   return bAccess;
}
//END DoesAnonymousHaveEveryoneAccess
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\attrnode.h ===
/*---------------------------------------------------------------------------
  File: TAttrNode.h

  Comments: interface for the TAttrNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_TATTRNODE_H__BE06D000_268B_11D3_8C89_0090270D48D1__INCLUDED_)
#define AFX_TATTRNODE_H__BE06D000_268B_11D3_8C89_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TNode.hpp"

class TAttrNode : public TNode  
{
public:
	HRESULT Add( long nOrigCol, long nCol, _variant_t val[]);
	TAttrNode(long nCnt, _variant_t val[]);
	virtual ~TAttrNode();

	_variant_t m_Val;
private:
   long * m_nElts;
};

#endif // !defined(AFX_TATTRNODE_H__BE06D000_268B_11D3_8C89_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\attrnode.cpp ===
/*---------------------------------------------------------------------------
  File: TAttrNode.cpp

  Comments: implementation of the TAttrNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "AttrNode.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

TAttrNode::TAttrNode(
                        long nCnt,              //in -Number of columns to set
                        _variant_t val[]        //in -Array of column values
                        )
{
   SAFEARRAY               * pArray;
   SAFEARRAYBOUND            bd = { nCnt, 0 };
   _variant_t        HUGEP * pData;

   pArray = ::SafeArrayCreate(VT_VARIANT, 1, &bd);
   ::SafeArrayAccessData(pArray, (void**)&pData);
   
   for ( long i = 0; i < nCnt; i++ )
      pData[i] = val[i];

   ::SafeArrayUnaccessData(pArray);
   m_Val.vt = VT_ARRAY | VT_VARIANT;
   m_Val.parray = pArray;

   m_nElts = new long[nCnt];
   if (!m_nElts)
      return;
   for (int ndx = 0; ndx < nCnt; ndx++)
   {
      m_nElts[ndx] = 0;
   }
}

TAttrNode::~TAttrNode()
{
   if (m_nElts)
      delete [] m_nElts;
}

HRESULT TAttrNode::Add(long nOrigCol, long nCol, _variant_t val[])
{
   if (!m_nElts)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   SAFEARRAY               * pArray = NULL;
   SAFEARRAYBOUND            bd = { m_nElts[nOrigCol], 0 };
   _variant_t        HUGEP * pData;
   HRESULT                   hr;
   SAFEARRAY               * pVars;
   SAFEARRAY               * psaTemp;
   _variant_t        HUGEP * pTemp;
   long						 nCnt;
   pVars = m_Val.parray;
   
   hr = ::SafeArrayAccessData(pVars, (void HUGEP **) &pData);
   if(SUCCEEDED(hr) )
   {
      if ( pData->vt & VT_ARRAY )
         pArray = pData[nOrigCol].parray;
      else
         hr = E_INVALIDARG;
   }

   if(SUCCEEDED(hr) )
      hr = ::SafeArrayUnaccessData(pVars);

   if ( SUCCEEDED(hr) )
   {
      if ( val[nCol].vt & VT_ARRAY )
      {
         // Get the current number of elts
         m_nElts[nOrigCol] = pArray->rgsabound->cElements;
         // Get the number of new elts
         nCnt = val[nCol].parray->rgsabound->cElements;
         // Get the array to transfer data.
         psaTemp = val[nCol].parray;

         // Extend the array to support the new values.
         bd.cElements = m_nElts[nOrigCol] + nCnt;
         hr = ::SafeArrayRedim(pArray, &bd);

         if ( SUCCEEDED(hr) )
            hr = ::SafeArrayAccessData(pArray, (void HUGEP **)&pData);
   
         if ( SUCCEEDED(hr) )
		 {
            hr = ::SafeArrayAccessData(psaTemp, (void HUGEP **)&pTemp);

            if ( SUCCEEDED(hr) )
			{
               for ( long i = m_nElts[nOrigCol]; i < m_nElts[nOrigCol] + nCnt; i++ )
                  pData[i] = pTemp[i - m_nElts[nOrigCol]];

               hr = ::SafeArrayUnaccessData(psaTemp);
			}
            hr = ::SafeArrayUnaccessData(pArray);
         }
      }
   }

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\domain.h ===
/*---------------------------------------------------------------------------
  File: Domain.h

  Comments: interface for the CDomain abstract class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#if !defined(AFX_DOMAIN_H__B310F880_19F9_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_DOMAIN_H__B310F880_19F9_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CDomain  
{
public:
   CDomain() {}
   virtual ~CDomain() {}
   
   //All our interfaces. These are implemented by the individual objects depending on NT4.0 v/s Win2000 domains.
   virtual HRESULT  GetContainerEnum(BSTR sContainerName, BSTR sDomainName, IEnumVARIANT **& pVarEnum) = 0;
   virtual HRESULT  GetEnumeration(BSTR sContainerName, BSTR sDomainName, BSTR m_sQuery, long attrCnt, LPWSTR * sAttr, ADS_SEARCHPREF_INFO prefInfo,BOOL  bMultiVal,IEnumVARIANT **& pVarEnum) = 0;
};

#endif // !defined(AFX_DOMAIN_H__B310F880_19F9_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\netnode.cpp ===
/*---------------------------------------------------------------------------
  File: TNetObjNode.cpp

  Comments: implementation of the TNetObjNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "NetNode.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

TNetObjNode::TNetObjNode()
{

}

TNetObjNode::~TNetObjNode()
{
   ::SysFreeString(m_strObjName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\netnode.h ===
/*---------------------------------------------------------------------------
  File: TNetObjNode.h

  Comments: interface for the TNetObjNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_TNETOBJNODE_H__3D7EBCD0_1AB6_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_TNETOBJNODE_H__3D7EBCD0_1AB6_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "TNode.hpp"

class TNetObjNode : public TNode  
{
public:
	TNetObjNode();
	virtual ~TNetObjNode();
   WCHAR        m_strObjName[255];
};

#endif // !defined(AFX_TNETOBJNODE_H__3D7EBCD0_1AB6_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\nt4dom.h ===
/*---------------------------------------------------------------------------
  File: NT4Dom.h

  Comments: interface for the NT4 Domain class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_NT4DOM_H__62E14C50_1AAC_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_NT4DOM_H__62E14C50_1AAC_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "Domain.h"

class CNT4Dom : public CDomain  
{
public:
	CNT4Dom();
	virtual ~CNT4Dom();
   HRESULT GetContainerEnum(BSTR sContainerName, BSTR sDomainName, IEnumVARIANT **& ppVarEnum);
   HRESULT  GetEnumeration(BSTR sContainerName, BSTR sDomainName, BSTR m_sQuery, long attrCnt, LPWSTR * sAttr, ADS_SEARCHPREF_INFO prefInfo,BOOL  bMultiVal, IEnumVARIANT **& pVarEnum);
};

#endif // !defined(AFX_NT4DOM_H__62E14C50_1AAC_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\nt4dom.cpp ===
/*---------------------------------------------------------------------------
  File: NT4Dom.cpp

  Comments: Implementation of NT4 object enumeration. This object enumerates
            members in USERS,GROUPS,COMPUTERS container for NT4 domain. It
            returns a fixed set of columns. For more information please refer
            to the code below.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "TNode.hpp"
#include "NetNode.h"
#include "AttrNode.h"
#include <lm.h>
#include "NT4Dom.h"
#include "NT4Enum.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define     MAX_BUF     100
#define     LEN_Path    255
CNT4Dom::CNT4Dom()
{

}

CNT4Dom::~CNT4Dom()
{

}

bool GetSamNameFromInfo( WCHAR * sInfo, WCHAR * sDomain, WCHAR * sName)
{
   WCHAR domain[LEN_Path];
   WCHAR * temp;
   bool rc = false;

   wcscpy(domain, sInfo);
   temp = wcschr(domain, L'\\');
   if ( temp )
   {
      *temp = 0;
      if (!_wcsicmp(domain, sDomain) || !wcsncmp(sDomain, L"\\\\", 2))
      {
         rc = true;
         wcscpy(sName, ++temp);
      }
   }
   return rc;
}

//---------------------------------------------------------------------------
// GetContainerEnum: This function returns the enumeration for an NT4 domain
//                   container. 
//---------------------------------------------------------------------------
HRESULT CNT4Dom::GetContainerEnum(
                                    BSTR sContainerName,          //in -Container name to enumerate
                                    BSTR sDomainName,             //in -Domain name to enumerate
                                    IEnumVARIANT **& ppVarEnum    //out -Pointer to the Enumaration object.
                                 )
{
   // This function enumerates three types of containers
   // USERS, COMPUTERS, GROUPS
   // if the container parameter specifies anything other than the three containers then
   // we returns UNEXPECTED.

   DWORD                  ulCount;
   DWORD                  rc=0;
   DWORD                  ndx = 0;
   IEnumVARIANT         * pEnum;
   TNodeList            * pNodeList = new TNodeList();
   LPBYTE                sServerName;
   
   if (!pNodeList)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   rc = NetGetDCName(NULL, sDomainName, &sServerName);
   if ( ! rc )
   {

      for (UINT i = 0; i < wcslen(sContainerName); i++)
         sContainerName[i] = towupper(sContainerName[i]);

      if ( wcscmp(sContainerName,L"CN=USERS") &&
           wcscmp(sContainerName,L"CN=COMPUTERS") &&
           wcscmp(sContainerName,L"CN=GROUPS") )
      {
         // if they selected a group we enumerate the membership of that group.
         WCHAR * sTemp = wcstok( sContainerName, L",");
         WCHAR * ndx = wcstok( NULL, L",");

         if ( wcscmp(ndx, L"CN=GROUPS") )
		 {
			delete pNodeList;
			pNodeList = NULL;
            NetApiBufferFree(sServerName);
            return E_UNEXPECTED;
		 }
         else
         {
            // Get the members of the global group and add them to the List,
            GROUP_USERS_INFO_0            * pbufNetUser;
//            DWORD                           resume=0, total=0;
            DWORD                           total=0;
            DWORD_PTR                       resume=0;
            // Get the first set of Members from the Group
            rc = NetGroupGetUsers((WCHAR*) sServerName, sTemp, 0, (LPBYTE*) &pbufNetUser, sizeof(GROUP_USERS_INFO_0) * MAX_BUF, &ulCount, &total, &resume);
            while ( ulCount > 0 )
            {
               // For each user create a node set the value of the node to the object name and add it to the list.
               TNetObjNode             * pNode;
               for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
               {
                  pNode = new TNetObjNode();
				  if (!pNode)
				  {
					 delete pNodeList;
                     NetApiBufferFree(sServerName);
                     NetApiBufferFree(pbufNetUser);
					 return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
                  wcscpy(pNode->m_strObjName, pbufNetUser[dwIdx].grui0_name);
                  pNodeList->InsertBottom(pNode);
               }
               NetApiBufferFree(pbufNetUser);
               // Get the next set of objects
               if ( rc == ERROR_MORE_DATA )
                  rc = NetGroupGetUsers((WCHAR*) sServerName, sTemp, 0, (LPBYTE*) &pbufNetUser, sizeof(GROUP_USERS_INFO_0) * MAX_BUF, &ulCount, &total, &resume);
               else
                  ulCount = 0;
            }
            // Get the members of the local group and add them to the List,
            LOCALGROUP_MEMBERS_INFO_3     * pbufNetInfo;
            resume=0;
            total=0;
            WCHAR                           sTempName[LEN_Path];
            WCHAR                           sName[LEN_Path];
            // Get the first set of Members from the Group
            rc = NetLocalGroupGetMembers((WCHAR*) sServerName, sTemp, 3, (LPBYTE*) &pbufNetInfo, sizeof(LOCALGROUP_MEMBERS_INFO_3) * MAX_BUF, &ulCount, &total, &resume);
            while ( ulCount > 0 )
            {
               // For each user create a node set the value of the node to the object name and add it to the list.
               TNetObjNode             * pNode;
               for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
               {
                  wcscpy(sTempName, pbufNetUser[dwIdx].grui0_name);
                  if (GetSamNameFromInfo(sTempName, (WCHAR*)sDomainName, sName))
                  {
                     pNode = new TNetObjNode();
				     if (!pNode)
					 {
			            delete pNodeList;
                        NetApiBufferFree(sServerName);
                        NetApiBufferFree(pbufNetInfo);
					    return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
					 }
                     wcscpy(pNode->m_strObjName, sName);
                     pNodeList->InsertBottom(pNode);
                  }  
               }
               NetApiBufferFree(pbufNetInfo);
               // Get the next set of objects
               if ( rc == ERROR_MORE_DATA )
                  rc = NetLocalGroupGetMembers((WCHAR*) sServerName, sTemp, 3, (LPBYTE*) &pbufNetInfo, sizeof(LOCALGROUP_MEMBERS_INFO_3) * MAX_BUF, &ulCount, &total, &resume);
               else
                  ulCount = 0;
            }
         }
      }

      if (!wcscmp(sContainerName,L"CN=USERS"))
      {
         // Build User enumeration
         NET_DISPLAY_USER           * pbufNetUser;
   
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 1, ndx, MAX_BUF, sizeof(NET_DISPLAY_USER) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TNetObjNode             * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               pNode = new TNetObjNode();
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(sServerName);
                  NetApiBufferFree(pbufNetUser);
				  return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               wcscpy(pNode->m_strObjName, pbufNetUser[dwIdx].usri1_name);
               pNodeList->InsertBottom(pNode);
            }
            
            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].usri1_next_index;
            
            NetApiBufferFree(pbufNetUser);
            
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 1, ndx, MAX_BUF, sizeof(NET_DISPLAY_USER) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
            else
               ulCount = 0;
         }
      }

      else if (!wcscmp(sContainerName,L"CN=COMPUTERS"))
      {
         // Build Computers enumeration
         NET_DISPLAY_MACHINE      * pbufNetUser;
   
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 2, ndx, MAX_BUF, sizeof(NET_DISPLAY_MACHINE) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TNetObjNode             * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               pNode = new TNetObjNode();
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(sServerName);
                  NetApiBufferFree(pbufNetUser);
			      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               wcscpy(pNode->m_strObjName, pbufNetUser[dwIdx].usri2_name);
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].usri2_next_index;
            
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 2, ndx, MAX_BUF, sizeof(NET_DISPLAY_MACHINE) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
            else
               ulCount = 0;
         }
      }

      else if (!wcscmp(sContainerName,L"CN=GROUPS"))
      {
         // Build Groups enumeration
         // Build Computers enumeration
         NET_DISPLAY_GROUP      * pbufNetUser;
   
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 3, ndx, MAX_BUF, sizeof(NET_DISPLAY_GROUP) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TNetObjNode             * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               pNode = new TNetObjNode();
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(sServerName);
                  NetApiBufferFree(pbufNetUser);
			      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               wcscpy(pNode->m_strObjName, pbufNetUser[dwIdx].grpi3_name);
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].grpi3_next_index;
            
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 3, ndx, MAX_BUF, sizeof(NET_DISPLAY_GROUP) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
            else
               ulCount = 0;
         }
      }
      // Build an enumerator and return it to the caller.
      pEnum = new CNT4Enum(pNodeList);
	  if (!pEnum)
	  {
	     delete pNodeList;
         NetApiBufferFree(sServerName);
		 return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	  }
      * ppVarEnum = pEnum;
      NetApiBufferFree(sServerName);
   }
   else
	  delete pNodeList;

   return S_OK;
}

//-----------------------------------------------------------------------------
// GetEnumeration: This function Enumerates all objects in the above specified
//                 containers and their 6 standard values which are
//                 'name,comment,user/groupID,flags,FullName,description'
//-----------------------------------------------------------------------------
HRESULT  CNT4Dom::GetEnumeration(
                                    BSTR sContainerName,             //in -Container path
                                    BSTR sDomainName,                //in -Domain name
                                    BSTR m_sQuery,                   //in -IGNORED...
                                    long attrCnt,                    //in -IGNORED...
                                    LPWSTR * sAttr,                  //in -IGNORED...
                                    ADS_SEARCHPREF_INFO prefInfo,    //in -IGNORED...
                                    BOOL  bMultiVal,                 //in -IGNORED...
                                    IEnumVARIANT **& pVarEnum        //out -Pointer to the enumeration object
                                )
{
   // From the full LDAP path truncate to appropriate LDAP subpath
   // This function enumerates four types of containers
   // USERS, COMPUTERS, GROUPS, DOMAIN CONTROLLERS
   // if the container parameter specifies anything other than the three containers then
   // we returns UNEXPECTED.

   DWORD                  ulCount;
   DWORD                  rc=0; 
   DWORD                  ndx = 0;
   TNodeList            * pNodeList = new TNodeList();

   LPBYTE                sServer = NULL;
   WCHAR                 sServerName[LEN_Path];
   
   if (!pNodeList)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   if ( wcsncmp((WCHAR*)sDomainName, L"\\\\", 2) )
   {
	  rc = NetGetDCName(NULL, sDomainName, &sServer);
      if (rc == NERR_Success)
	  {
         wcscpy(sServerName, (WCHAR*) sServer);
         NetApiBufferFree(sServer);
	  }
   }
   else
      wcscpy((WCHAR*)sServerName, (WCHAR*) sDomainName);

   if ( ! rc )
   {
      for (UINT i = 0; i < wcslen(sContainerName); i++)
         sContainerName[i] = towupper(sContainerName[i]);

      if ( wcscmp(sContainerName,L"CN=USERS") &&
           wcscmp(sContainerName,L"CN=COMPUTERS") &&
           wcscmp(sContainerName,L"CN=GROUPS") &&
           wcscmp(sContainerName,L"CN=DOMAIN CONTROLLERS") )
      {
         // if they selected a group we enumerate the membership of that group.
         WCHAR * sTemp = wcstok( sContainerName, L",");
         WCHAR * ndx = wcstok( NULL, L",");

         if ( ndx && wcscmp(ndx, L"CN=GROUPS") )
		 {
			delete pNodeList;
            return E_UNEXPECTED;
		 }
         else
         {
            // Get the members of the group and add them to the List,
            GROUP_USERS_INFO_0            * pbufNetUser;
//            DWORD                           resume=0, total=0;
            DWORD                           total=0;
            DWORD_PTR                       resume=0;
            // Get the first set of Members from the Group
            rc = NetGroupGetUsers((WCHAR*) sServerName, sTemp, 0, (LPBYTE*) &pbufNetUser, sizeof(GROUP_USERS_INFO_0) * MAX_BUF, &ulCount, &total, &resume);
            while ( ulCount > 0 )
            {
               // For each user construnct the array of the properties that they asked for. Then construct a node of that
               // array and stuff that into the List.
               for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
               {
                  _variant_t varArr[6] = { pbufNetUser[dwIdx].grui0_name, (long)0, (long)0, (long)0, (long)0, (long)0 } ;
                  TAttrNode * pNode = new TAttrNode(6, varArr);
			      if (!pNode)
				  {
				     delete pNodeList;
                     NetApiBufferFree(pbufNetUser);
			         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
                  pNodeList->InsertBottom(pNode);
               }
               NetApiBufferFree(pbufNetUser);
               // Get the next set of objects
               if ( rc == ERROR_MORE_DATA )
                  rc = NetGroupGetUsers((WCHAR*) sServerName, sTemp, 0, (LPBYTE*) &pbufNetUser, sizeof(GROUP_USERS_INFO_0) * MAX_BUF, &ulCount, &total, &resume);
               else
                  ulCount = 0;
            }
            // Get the members of the local group and add them to the List,
            LOCALGROUP_MEMBERS_INFO_3     * pbufNetInfo;
            resume=0;
            total=0;
            WCHAR                           sTempName[LEN_Path];
            WCHAR                           sName[LEN_Path];
            // Get the first set of Members from the Group
            rc = NetLocalGroupGetMembers((WCHAR*) sServerName, sTemp, 3, (LPBYTE*) &pbufNetInfo, sizeof(LOCALGROUP_MEMBERS_INFO_3) * MAX_BUF, &ulCount, &total, &resume);
            while ( ulCount > 0 )
            {
               // For each user create a node set the value of the node to the object name and add it to the list.
               for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
               {
                  wcscpy(sTempName, pbufNetInfo[dwIdx].lgrmi3_domainandname);
                  if (GetSamNameFromInfo(sTempName, (WCHAR*)sDomainName, sName))
                  {
                     _variant_t varArr[6] = { sName, (long)0, (long)0, (long)0, (long)0, (long)0 } ;
                     TAttrNode * pNode = new TAttrNode(6, varArr);
			         if (!pNode)
					 {
				        delete pNodeList;
                        NetApiBufferFree(pbufNetInfo);
			            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
					 }
                     pNodeList->InsertBottom(pNode);
                  }  
               }
               NetApiBufferFree(pbufNetInfo);
               // Get the next set of objects
               if ( rc == ERROR_MORE_DATA )
               {
                  rc = NetLocalGroupGetMembers((WCHAR*) sServerName, sTemp, 3, (LPBYTE*) &pbufNetInfo, sizeof(LOCALGROUP_MEMBERS_INFO_3) * MAX_BUF, &ulCount, &total, &resume);
               }
               else
                  ulCount = 0;
            }
         }
      }

      if (!wcscmp(sContainerName,L"CN=USERS"))
      {
         // Build User enumeration
         NET_DISPLAY_USER           * pbufNetUser;
      
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 1, ndx, MAX_BUF, sizeof(NET_DISPLAY_USER) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TAttrNode         * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               {
                  _variant_t val[6] = { pbufNetUser[dwIdx].usri1_name,
                                     pbufNetUser[dwIdx].usri1_comment,
                                     (long)0,
                                     (long)0,
                                     pbufNetUser[dwIdx].usri1_full_name,
                                     L"" };
                  val[2].vt = VT_UI4;
                  val[2].ulVal = pbufNetUser[dwIdx].usri1_user_id;

                  val[3].vt = VT_UI4;
                  val[3].ulVal = pbufNetUser[dwIdx].usri1_flags;

                     
                  pNode = new TAttrNode(6, val);
			      if (!pNode)
				  {
				     delete pNodeList;
                     NetApiBufferFree(pbufNetUser);
			         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
               }
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].usri1_next_index;
            
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 1, ndx, MAX_BUF, sizeof(NET_DISPLAY_USER) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
            else
               ulCount = 0;
         }
      }
 
      else if (!wcscmp(sContainerName,L"CN=COMPUTERS"))
      {
         // Build Computers enumeration
         NET_DISPLAY_MACHINE      * pbufNetUser;
      
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 2, ndx, MAX_BUF, sizeof(NET_DISPLAY_MACHINE) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
      
         // Build the PDC account name.
         WCHAR          server[LEN_Path];
         WCHAR          name[LEN_Path];
         BOOL           bPDCFound = FALSE;
         wcscpy(server, (WCHAR*)(sServerName + (2*sizeof(WCHAR))));
         wsprintf(name, L"%s$", server);

         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TAttrNode         * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               // if we process the PDC then we need to let the function know.
               if ( wcscmp(pbufNetUser[dwIdx].usri2_name, name) == 0 )
                  bPDCFound = TRUE;

               _variant_t val[6] = { pbufNetUser[dwIdx].usri2_name,
                                     pbufNetUser[dwIdx].usri2_comment,
                                     (long)0,
                                     (long)0,
                                     (long)0,
                                     L"" };

               val[2].vt = VT_UI4;
               val[2].ulVal = pbufNetUser[dwIdx].usri2_user_id;

               val[3].vt = VT_UI4;
               val[3].ulVal = pbufNetUser[dwIdx].usri2_flags;
            
               pNode = new TAttrNode(6, val);
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(pbufNetUser);
			      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].usri2_next_index;
         
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 2, ndx, MAX_BUF, sizeof(NET_DISPLAY_MACHINE) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
            else
               ulCount = 0;
         }
         // if pdc is already added then we dont need to do any of this.
         if ( !bPDCFound )
         {
            // we will fake all other attributes other than the name
            _variant_t val[6] = { name,
                                  L"",
                                  L"",
                                  L"",
                                  L"",
                                  L"" };

            val[2].vt = VT_UI4;
            val[2].ulVal = 0;

            val[3].vt = VT_UI4;
            val[3].ulVal = UF_SERVER_TRUST_ACCOUNT | UF_SCRIPT;
      
            TAttrNode * pNode = new TAttrNode(6, val);
			if (!pNode)
			{
			   delete pNodeList;
			   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			}
            pNodeList->InsertBottom(pNode);
         }
      }
   
      else if (!wcscmp(sContainerName,L"CN=GROUPS"))
      {
         // Build Groups enumeration
         // Build Computers enumeration
         NET_DISPLAY_GROUP      * pbufNetUser;
      
         // Get the first set of users from the domain
         rc = NetQueryDisplayInformation((WCHAR *)sServerName, 3, ndx, MAX_BUF, sizeof(NET_DISPLAY_GROUP) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
         while ( ulCount > 0 )
         {
            // For each user create a node set the value of the node to the object name and add it to the list.
            TAttrNode             * pNode;
            for ( DWORD dwIdx = 0; dwIdx < ulCount; dwIdx++ )
            {
               _variant_t val[6] = { pbufNetUser[dwIdx].grpi3_name,
                                     pbufNetUser[dwIdx].grpi3_comment,
                                     L"",
                                     L"",
                                     L"",
                                     L"" };
            
               val[2].vt = VT_UI4;
               val[2].ulVal = pbufNetUser[dwIdx].grpi3_group_id;

               val[3].vt = VT_UI4;
               val[3].ulVal = pbufNetUser[dwIdx].grpi3_attributes;
            
               pNode = new TAttrNode(6, val);
			   if (!pNode)
			   {
				  delete pNodeList;
                  NetApiBufferFree(pbufNetUser);
			      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
			   }
               pNodeList->InsertBottom(pNode);
            }

            // Set the index for next set of users.
            if ( ulCount > 0 )
               ndx = pbufNetUser[ulCount-1].grpi3_next_index;
            
            NetApiBufferFree(pbufNetUser);
            // Get the next set of objects
            if ( rc == ERROR_MORE_DATA )
               rc = NetQueryDisplayInformation((WCHAR *)sServerName, 3, ndx, MAX_BUF, sizeof(NET_DISPLAY_GROUP) * MAX_BUF, &ulCount, (void **)&pbufNetUser);
            else
               ulCount = 0;
         }
      }
      else if (!wcscmp(sContainerName,L"CN=DOMAIN CONTROLLERS"))
      {
            // Build Domain Controller enumeration
		 LPSERVER_INFO_101 pBuf = NULL;
         DWORD dwLevel = 101;
         DWORD dwSize = MAX_PREFERRED_LENGTH;
         DWORD dwEntriesRead = 0L;
         DWORD dwTotalEntries = 0L;
         DWORD dwTotalCount = 0L;
         DWORD dwServerType = SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL; // domain controllers
         DWORD dwResumeHandle = 0L;
         NET_API_STATUS nStatus;
         DWORD dw;

		    //enumerate the primary and backup domain controllers
         nStatus = NetServerEnum(NULL,
								 dwLevel,
								 (LPBYTE *) &pBuf,
								 dwSize,
								 &dwEntriesRead,
								 &dwTotalEntries,
								 dwServerType,
								 (WCHAR*) sDomainName,
								 &dwResumeHandle);

		    //if we need a bigger buffer, increase it and try again
	     if( nStatus != NERR_Success && nStatus == ERROR_MORE_DATA )
		 {
		    dwSize = sizeof(SERVER_INFO_100)*dwTotalEntries*MAX_PATH;
            NetApiBufferFree(pBuf);
		    pBuf = NULL;
		    dwTotalEntries = 0L;
		    dwEntriesRead = 0L;
		    dwResumeHandle = 0L;

            nStatus = NetServerEnum(NULL,
								    dwLevel,
								    (LPBYTE *) &pBuf,
								    dwSize,
								    &dwEntriesRead,
								    &dwTotalEntries,
								    dwServerType,
								    (WCHAR*) sDomainName,
								    &dwResumeHandle);
		 }
         if ((nStatus == NERR_Success) || (nStatus == ERROR_MORE_DATA))
		 {
            if (pBuf != NULL)
			{
                  // For each DC create a node set the value of the node to the object name and add it to the list.
               for (dw = 0; dw < dwEntriesRead; dw++)
			   {
                  _variant_t varArr[6] = { pBuf[dw].sv101_name, (long)0, (long)0, (long)0, (long)0, (long)0 } ;
                  TAttrNode * pNode = new TAttrNode(6, varArr);
			      if (!pNode)
				  {
				     delete pNodeList;
                     NetApiBufferFree(pBuf);
			         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
                  pNodeList->InsertBottom(pNode);
			   }
               NetApiBufferFree(pBuf);
            }
         }
	  }//end if enum DCs

      // Build an enumerator and return it to the caller.
      *pVarEnum = new CNT4Enum(pNodeList);
   }
   else
      delete pNodeList;
	  

   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\netobjen.cpp ===
/*---------------------------------------------------------------------------
  File: MCSNetObjectEnum.cpp

  Comments: Implementation of DLL Exports.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MCSNetObjectEnumps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "NetEnum.h"

#include "NetEnum_i.c"
#include "ObjEnum.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NetObjEnumerator, CNetObjEnumerator)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ATLTRACE(_T("{MCSNetObjectEnum.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSNETOBJECTENUMLib);
        DisableThreadLibraryCalls(hInstance);
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        ATLTRACE(_T("{MCSNetObjectEnum.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\nt4enum.cpp ===
/*---------------------------------------------------------------------------
  File: NT4Enum.cpp

  Comments: Implementation of the enumeration object. This object implements
            IEnumVARIANT interface.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "NetNode.h"
#include "AttrNode.h"
#include "TNode.hpp"
#include "NT4Enum.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNT4Enum::CNT4Enum(TNodeList * pNodeList) : m_listEnum(pNodeList)
{
   m_pNodeList = pNodeList;
}

CNT4Enum::~CNT4Enum()
{
}

//---------------------------------------------------------------------------
// Next : Implements next method of the IEnumVaraint interface. This method
//        returns the next object in the enumeration. It returns S_FALSE when
//        there are no more objects to enumerate.
//---------------------------------------------------------------------------
HRESULT CNT4Enum::Next(
                        unsigned long celt,              //in -Number of elements to return IGNORED.
                        VARIANT FAR* rgvar,              //out-Variant used to return the object information
                        unsigned long FAR* pceltFetched  //out-Number of elements returned (ALWAYS 1).
                      )
{
   TAttrNode     * pNode = (TAttrNode *)m_listEnum.Next();
   if ( pNode == NULL ) 
      return S_FALSE;
//   *rgvar = pNode->m_Val;
   HRESULT hr = VariantCopy(rgvar, &pNode->m_Val);
   if (SUCCEEDED(hr))
   {
      *pceltFetched = 1;
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\objenum.h ===
/*---------------------------------------------------------------------------
  File: NetObjEnumerator.h

  Comments: Declaration of the CNetObjEnumerator COM object. This COM object
            is used to get an enumeration for the members in a container and
            their properties. If user simply needs all the objects in a given
            container then they can use the GetContainerEnum method. If user
            wants to perform some advanced searches/queries then they should
            use the set of three functions (SetQuery, SetColumns, Execute) to
            Setup and execute a query against the container. Both sets of methods
            return IEnumVaraint supporting objects. This object will allow user
            to go through all the values returned by queries.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#ifndef __NETOBJENUMERATOR_H_
#define __NETOBJENUMERATOR_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CNetObjEnumerator
class ATL_NO_VTABLE CNetObjEnumerator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNetObjEnumerator, &CLSID_NetObjEnumerator>,
   public INetObjEnumerator
{
public:
   CNetObjEnumerator() : m_bSetQuery(false), m_bSetCols(false)
	{
      m_nCols = 0;
      m_pszAttr = NULL;
	}
   ~CNetObjEnumerator()
   {
      Cleanup();
   }

DECLARE_REGISTRY_RESOURCEID(IDR_NETOBJENUMERATOR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNetObjEnumerator)
	COM_INTERFACE_ENTRY(INetObjEnumerator)
END_COM_MAP()

// INetObjEnumerator
public:
	STDMETHOD(Execute)(/*[out]*/ IEnumVARIANT ** pEnumerator);
	STDMETHOD(SetColumns)(/*[in]*/ SAFEARRAY * colNames);
	STDMETHOD(SetQuery)(/*[in]*/ BSTR sContainer, /*[in]*/ BSTR sDomain, /*[in,optional]*/ BSTR sQuery=L"(objectClass=*)", /*[in,optional]*/ long nCnt = 1, /*[in,optional]*/ long bMultiVal = FALSE);
	STDMETHOD(GetContainerEnum)(/*[in]*/ BSTR sContainerName, /*[in]*/ BSTR sDomainName, /*[out]*/ IEnumVARIANT ** ppVarEnum);
private:
	void Cleanup();
	long m_nCols;                       // Number of columns requested by the user.
	_bstr_t m_sQuery;                   // Stores the query set by the user. This will be used to query the info from AD.
	_bstr_t m_sContainer;               // Stores the container name of where the search is to be made.
   _bstr_t m_sDomain;                  // Domain name that we are enumerating.
   bool m_bSetQuery;                   // Flag indicating whether SetQuery called or not
   bool m_bSetCols;                    // Similar flag for SetColumn
   LPWSTR *m_pszAttr;                  // Stores the array of columns requested by the user of the object.
   ADS_SEARCHPREF_INFO prefInfo;       // The Search Scope
   BOOL  m_bMultiVal;                  // Flag to indicate whether to return multivalues or not.
};

#endif //__NETOBJENUMERATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by NetObjEn.rc
//
#define IDS_PROJNAME                    100
#define IDR_NETOBJENUMERATOR            101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\nt4enum.h ===
/*---------------------------------------------------------------------------
  File: NT4Enum.h

  Comments: interface for the CNT4Enum class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#if !defined(AFX_NT4ENUM_H__C0171FA0_1AB3_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_NT4ENUM_H__C0171FA0_1AB3_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "AttrNode.h"

class CNT4Enum : public IEnumVARIANT  
{
public:
	TNodeList            * m_pNodeList;
	TNodeListEnum          m_listEnum;
   CNT4Enum(TNodeList * pNodeList);
	virtual ~CNT4Enum();
   HRESULT STDMETHODCALLTYPE Next(unsigned long celt, VARIANT FAR* rgvar, unsigned long FAR* pceltFetched);
   HRESULT STDMETHODCALLTYPE Skip(unsigned long celt){ return E_NOTIMPL; }
   HRESULT STDMETHODCALLTYPE Reset(){ return E_NOTIMPL; }
   HRESULT STDMETHODCALLTYPE Clone(IEnumVARIANT FAR* FAR* ppenum){ return E_NOTIMPL; }
   HRESULT STDMETHODCALLTYPE QueryInterface(const struct _GUID &,void ** ){ return E_NOTIMPL; }
   ULONG   STDMETHODCALLTYPE AddRef(void){ return E_NOTIMPL; }
   ULONG   STDMETHODCALLTYPE Release(void)
   {
      if ( m_pNodeList )
      {
         
         TAttrNode * pNode = (TAttrNode *)m_pNodeList->Head();
         TAttrNode * temp;

         for ( pNode = (TAttrNode*)m_listEnum.OpenFirst(m_pNodeList) ; pNode; pNode = temp )
         {
            temp = (TAttrNode *)m_listEnum.Next();
            m_pNodeList->Remove(pNode);
            delete pNode;
         }
         m_listEnum.Close();
         delete m_pNodeList;
         m_pNodeList = NULL;
         delete this;
      }
      return 0;
   }
};

#endif // !defined(AFX_NT4ENUM_H__C0171FA0_1AB3_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__14B26371_191D_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__14B26371_191D_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__14B26371_191D_11D3_8C7F_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\win2kdom.h ===
/*---------------------------------------------------------------------------
  File: Win2000Dom.h

  Comments: interface for the CWin2000Dom class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_WIN2000DOM_H__2DE5B8E0_19FA_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_WIN2000DOM_H__2DE5B8E0_19FA_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "AttrNode.h"
#include "Domain.h"

class CWin2000Dom : public CDomain  
{
public:
	CWin2000Dom();
	virtual ~CWin2000Dom();
   virtual HRESULT  GetContainerEnum(BSTR sContainerName, BSTR sDomainName, IEnumVARIANT **& ppVarEnum);
   HRESULT  GetEnumeration(BSTR sContainerName, BSTR sDomainName, BSTR m_sQuery, long attrCnt, LPWSTR * sAttr, ADS_SEARCHPREF_INFO prefInfo,BOOL  bMultiVal, IEnumVARIANT **& pVarEnum);
private:
//	void UpdateAccountInList( TNodeList * pList, BSTR sDomainName);
	bool AttrToVariant(ADSVALUE adsVal, _variant_t& var);
   HRESULT  DoRangeQuery(BSTR sDomainName, BSTR sQuery, LPWSTR * sAttr, int attrCnt, ADS_SEARCH_HANDLE hSearch, IDirectorySearch * pSearch, BOOL bMultiVal, TNodeList * pNode);
    bool IsPropMultiValued(const WCHAR * sPropName, const WCHAR * sDomain);
};

#endif // !defined(AFX_WIN2000DOM_H__2DE5B8E0_19FA_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\objenum.cpp ===
/*---------------------------------------------------------------------------
  File: NetObjEnumerator.cpp

  Comments: Implementation of NetObjectEnumerator COM object.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "NetEnum.h"
#include "ObjEnum.h"
#include "Win2KDom.h"
#include "NT4DOm.h"
#include <lmaccess.h>
#include <lmwksta.h>
#include <lmapibuf.h>
#include <dsgetdc.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNetObjEnumerator
typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);

//---------------------------------------------------------------------------
// GetContainerEnum: This function returns the enumeration of all objects
//                   in a given container for a specified domain. It returns
//                   all objects in an enumeration object.
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::GetContainerEnum(
													            BSTR sContainerName,          //in -LDAP path to the container which we want to Enum
													            BSTR sDomainName,             //in -Domain name where we want to look
													            IEnumVARIANT ** ppVarEnum     //out -Enumeration object. It contains all members of
                                                                                 //     the container specified above.
												            )
{
   LPBYTE              sTargetMachine;
   WKSTA_INFO_100    * pInfo;

   DWORD rc = NetGetDCName( NULL, sDomainName, &sTargetMachine);
   if ( !rc ) 
   {
      rc = NetWkstaGetInfo((unsigned short *)sTargetMachine,100,(LPBYTE*)&pInfo);
	   if ( ! rc )
	   {
	      HRESULT hr;

	      if ( pInfo->wki100_ver_major < 5 )
		  {
             CNT4Dom dom;
			 hr = dom.GetContainerEnum(sContainerName, sDomainName, ppVarEnum);
		  }
          else
		  {
             CWin2000Dom dom;
			 hr = dom.GetContainerEnum(sContainerName, sDomainName, ppVarEnum);
		  }

		   NetApiBufferFree(pInfo);
		   return hr;
	   }
	   NetApiBufferFree(sTargetMachine);
   }
   return S_FALSE;
}

//---------------------------------------------------------------------------
// SetQuery: This function sets all the parameters necessary for a query
//           to be executed. User can not call Execute without first calling
//           this method.
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::SetQuery(
                                          BSTR sContainer,     //in -Container name
                                          BSTR sDomain,        //in -Domain name
                                          BSTR sQuery,         //in -Query in LDAP syntax
                                          long nSearchScope,   //in -Scope of the search. ADS_ATTR_SUBTREE/ADS_ATTR_ONELEVEL
                                          long bMultiVal       //in- Do we need to return multivalued properties?
                                        )
{
   Cleanup();
   // Save all the settings in member variables.
   m_sDomain = sDomain;
   m_sContainer = sContainer;
   m_sQuery = sQuery;
   m_bSetQuery = true;
   m_bMultiVal = bMultiVal;
   if ( nSearchScope < 0 || nSearchScope > 2 )
      return E_INVALIDARG;
   prefInfo.dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
   prefInfo.vValue.dwType = ADSTYPE_INTEGER;
   prefInfo.vValue.Integer = nSearchScope;

	return S_OK;
}

//---------------------------------------------------------------------------
// SetColumns: This function sets all the columns that the user wants to be
//             returned when query is executed. 
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::SetColumns(
                                            SAFEARRAY * colNames      //in -Pointer to a SafeArray that contains all the columns
                                          )
{
   // We require that the SetQuery method be called before SetColumns is called. Hence we will return E_FAIL
   // If we expose these interface we should document this.
   if (!m_bSetQuery)
      return E_FAIL;

   if ( m_bSetCols )
   {
      Cleanup();
      m_bSetQuery = true;
   }

   SAFEARRAY               * pcolNames = colNames;
   long                      dwLB;
   long                      dwUB;
   BSTR              HUGEP * pBSTR;
   HRESULT                   hr;

   // Get the bounds of the column Array
   hr = ::SafeArrayGetLBound(pcolNames, 1, &dwLB);
   if (FAILED(hr))
      return hr;

   hr = ::SafeArrayGetUBound(pcolNames, 1, &dwUB);
   if (FAILED(hr))
      return hr;

   m_nCols = dwUB-dwLB + 1;

   // We dont support empty columns request atleast one column.
   if ( m_nCols == 0 )
      return E_FAIL;

   hr = ::SafeArrayAccessData(pcolNames, (void **) &pBSTR);
   if ( FAILED(hr) )
      return hr;

   // Allocate space for the array. It is deallocated by Cleanup()
   m_pszAttr = new LPWSTR[m_nCols];

   if (m_pszAttr == NULL)
   {
      ::SafeArrayUnaccessData(pcolNames);
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   // Each column is now put into the Array
   for ( long dw = 0; dw < m_nCols; dw++)
   {
      m_pszAttr[dw] = SysAllocString(pBSTR[dw]);
   }
   hr = ::SafeArrayUnaccessData(pcolNames);
   m_bSetCols = true;
   return hr;
}

//---------------------------------------------------------------------------
// Cleanup: This function cleans up all the allocations and the member vars.
//---------------------------------------------------------------------------
void CNetObjEnumerator::Cleanup()
{
   if ( m_nCols > 0 )
   {
      if ( m_pszAttr )
      {
         // delete the contents of the array
         for ( int i = 0 ; i < m_nCols ; i++ )
         {
            SysFreeString(m_pszAttr[i]);
         }
         // Dealloc the array itself
         delete [] m_pszAttr;
         m_pszAttr = NULL;
      }
      // Reset all counts and flags.
      m_nCols = 0;
      m_bSetQuery = false;
      m_bSetCols = false;
   }
}

//---------------------------------------------------------------------------
// Execute: This function actually executes the query and then builds an
//          enumerator object and returns it.
//---------------------------------------------------------------------------
STDMETHODIMP CNetObjEnumerator::Execute(
                                          IEnumVARIANT **pEnumerator    //out -Pointer to the enumerator object.
                                       )
{
   // This function will take the options set in SetQuery and SetColumns to enumerate objects
   // for the given domain. This could be a NT4 domain or a Win2K domain. Although at the moment
   // NT4 domains simply enumerate all objects in the given container, we could later implement
   // certain features to support queries etc.

   DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   
   if ( !m_bSetCols )
      return E_FAIL;

   CDomain                 * pDom;
   WKSTA_INFO_100          * pInfo = NULL;
   HRESULT                   hr = S_FALSE;

   *pEnumerator = NULL;

   // Load DsGetDcName dynamically
   DSGETDCNAME DsGetDcName = NULL;
   HMODULE hPro = LoadLibrary(L"NetApi32.dll");
   if ( hPro )
      DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");
   if ( DsGetDcName )
   {
      DWORD rc = DsGetDcName(
                              NULL                                  ,// LPCTSTR ComputerName ?
                              m_sDomain                             ,// LPCTSTR DomainName
                              NULL                                  ,// GUID *DomainGuid ?
                              NULL                                  ,// LPCTSTR SiteName ?
                              0                                     ,// ULONG Flags ?
                              &pSrcDomCtrlInfo                       // PDOMAIN_CONTROLLER_INFO *DomainControllerInfo
                           );

      if ( !rc ) 
      {
         rc = NetWkstaGetInfo(pSrcDomCtrlInfo->DomainControllerName,100,(LPBYTE*)&pInfo);
	      if ( ! rc )
	      {
		      if ( pInfo->wki100_ver_major < 5 )
                pDom = new CNT4Dom();
              else 
                pDom = new CWin2000Dom();
              if (!pDom)
                 return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

		      NetApiBufferFree(pInfo);
		      try{
			      hr = pDom->GetEnumeration(m_sContainer, m_sDomain, m_sQuery, m_nCols, m_pszAttr, prefInfo, m_bMultiVal, pEnumerator);
		      }
		      catch ( _com_error &e)
		      {
                  delete pDom;
			      return e.Error();
		      }
              delete pDom;
	      }
	      else
         {
            hr = HRESULT_FROM_WIN32(rc);
         }
         NetApiBufferFree(pSrcDomCtrlInfo);
      }
      else
      {
	      hr = HRESULT_FROM_WIN32(rc);
      }
   }
   else
   {
      hr = HRESULT_FROM_WIN32(GetLastError());
   }

   if ( hPro )
      FreeLibrary(hPro);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\win2kdom.cpp ===
// Win2000Dom.cpp: implementation of the CWin2000Dom class.
/*---------------------------------------------------------------------------
  File: Win2000Dom.cpp

  Comments: Implementation of Win2K object enumeration. This object enumerates
            members in any given container for Win2k domain. It
            returns all information about the object that user requested.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY

  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#include "stdafx.h"
#include "EaLen.hpp"
#include <adserr.h>
#include "NT4Enum.h"
#include "Win2KDom.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWin2000Dom::CWin2000Dom()
{

}

CWin2000Dom::~CWin2000Dom()
{

}
//---------------------------------------------------------------------------
// GetContainerEnum : Enumerates all the objects in a Container for a Domain.
//                    It returns a pointer to IEnumVARIANT supporting object. 
//                    The object enumerates through variants that contain 
//                    BSTR's for the name of the objects.
//---------------------------------------------------------------------------
HRESULT  CWin2000Dom::GetContainerEnum(
                                          BSTR sContainerName,             //in- LDAP subpath of the container to enumerate
                                          BSTR sDomainName,                //in- Domain where the container resides
                                          IEnumVARIANT **& ppVarEnum       //out-IEnumVariant object that enumerates all objects.
                                      )
{
   // Build the enumerator and go with it.
    IADs            *pRoot=NULL;
    IADsContainer   *pCont=NULL;
    IEnumVARIANT    *pEnum=NULL,*pMbrEnum=NULL;
//    IDispatch       *pDisp = NULL;
    BSTR             bstrPath;
    VARIANT          varDSRoot;
//    ULONG            ulFetch=0;
    IADsMembers     *pMbr;
    TCHAR            adspath[MAX_PATH];
    
    WCHAR            sPath[LEN_Path];
    VARIANT          var;
    HRESULT hr;
 
    //Get the name of the root container for this domain.  
    //Read the Root DSE from the default DS, which will be the DS for 
    //the local domain.  This will get us the name of the schema container,
    //which is stored in the "defaultNamingContext" operational attribute.
 
    wsprintf(sPath,L"LDAP://%ls/RootDSE", sDomainName);
    hr = ADsGetObject(sPath,
                      IID_IADs,
                      (void**)&pRoot);
 
    hr = pRoot->Get(TEXT("defaultNamingContext"),&varDSRoot);
    pRoot->Release();
 
    //Now bind to the builtin container.
 
    _tcscpy(adspath,TEXT("LDAP://"));
    wsprintf(sPath, L"%ls/%ls", sDomainName, sContainerName);
    _tcscat(adspath,sPath);
    if (wcslen(sContainerName))
         _tcscat(adspath,L",");
    _tcscat(adspath,varDSRoot.bstrVal);
 
    hr = ADsGetObject(adspath,IID_IADsContainer,(void**)&pCont);
 
    if ( FAILED( hr ) )
       return hr;

    // We are going to hint the container object to return all the stuff that we need in the Enumerator class
    LPWSTR pszArray[] = { L"name", L"objectClass", L"sAMAccountName", L"groupType"  };
    DWORD dwNumber = sizeof(pszArray)/sizeof(LPWSTR);
    hr = ADsBuildVarArrayStr( pszArray, dwNumber, &var);
    hr = pCont->put_Hints( var );
    VariantClear(&var);
 

    hr = ADsBuildEnumerator(pCont,&pEnum);
    if ( SUCCEEDED(hr) ) 
    {
      *ppVarEnum = pEnum;
    }

    IADs                   * pADs = NULL;
    IADsGroup              * pGrp = NULL;
    BSTR                     bstrClass;

    hr = pCont->QueryInterface(IID_IADs, (void**)&pADs);
    hr = pADs->get_Class(&bstrClass);
    if ( wcscmp(bstrClass, L"group") == 0)
    {
         hr = pADs->get_ADsPath(&bstrPath);
         if SUCCEEDED(hr) {
             //Enumerate the members of this group. Bind to the 
             //group requesting IADsGroup
             //
             hr = ADsGetObject(bstrPath,IID_IADsGroup,(void**)&pGrp);
             //Retrieve the Members property - this is a container
             //that holds IADs objects for the members
             //
             hr = pGrp->Members(&pMbr);
             //Create another enumerator and enumerate the members of
             //the group.
             //
             hr = ADsBuildEnumerator((IADsContainer*)pMbr,&pMbrEnum);
             if ( SUCCEEDED(hr) ) 
             {
               *ppVarEnum = pMbrEnum;
             }
             ADsFreeEnumerator(pEnum);
         }
    }
    pCont->Release();
 	 return S_OK;
}

//---------------------------------------------------------------------------
// GetEnumeration : Given the information this method returns all requested
//                  values for a given object in a VARIANT containing 
//                  SAFEARRAY containing each of the property value that was 
//                  requested by the caller.
//---------------------------------------------------------------------------
HRESULT  CWin2000Dom::GetEnumeration(
                                       BSTR sContainerName,             //in- Container to enumerate ( LDAP sub path )
                                       BSTR sDomainName,                //in- Domain where the container resides
                                       BSTR m_sQuery,                   //in- LDAP query string (for filtering)
                                       long attrCnt,                    //in- Number of properties requested.
                                       LPWSTR * sAttr,                  //in- Pointer to array of Property names.
                                       ADS_SEARCHPREF_INFO prefInfo,    //in- Search preference info.
                                       BOOL  bMultiVal,                 //in- Indicates whether to return multivalue props or not.
                                       IEnumVARIANT **& pVarEnum        //out- IEnumVARIANT object that will enumerate all returned objects.
                                    )
{
   // First get the full path to the container from the subpath that we have here.
   _bstr_t                   sAdsPath;
   _bstr_t                   sGrpDN;
   _bstr_t                   sQuery;
   _variant_t                var, var2;
   IADs                    * pAds = NULL;
   int                       nCnt = 0;
//   IADsMembers             * pMbr = NULL;
//   IADsGroup               * pGrp = NULL;
   HRESULT                   hr;
   IDirectorySearch        * pSearch = NULL;
   ADS_SEARCH_HANDLE         hSearch = NULL;
   TNodeList               * pList = new TNodeList();
//   int                       cnt = 0;
   bool                      cont = true;
   ADS_SEARCH_COLUMN         col;
   BSTR                      sClass = NULL;
   
   if (!pList)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   // Get the dwfault naming context for this domain
   sAdsPath = L"LDAP://";
   sAdsPath += sDomainName;
   sAdsPath += L"/rootDSE";
   hr = ADsGetObject(sAdsPath, IID_IADs, (void**) &pAds);
   
   if ( SUCCEEDED(hr))
   {
      hr = pAds->Get(L"defaultNamingContext", &var);
      if ( SUCCEEDED(hr) )
      {

         if ( (wcsncmp(sContainerName, L"LDAP://", 7) != 0) && (wcsncmp(sContainerName, L"GC://", 5) != 0) )
         {
            // Partial path supplied so we will build the rest.

            if ( sContainerName && *sContainerName )
            {
               sAdsPath = L"LDAP://";
               sAdsPath += sDomainName;
               sAdsPath += L"/";
               sAdsPath += sContainerName;
               sAdsPath += L",";
               sAdsPath += var.bstrVal;
            }
            else
            {
               sAdsPath = L"LDAP://";
               sAdsPath += sDomainName;
               sAdsPath += L"/";
               sAdsPath += var.bstrVal;
            }
         }
         else
            // Full path so no need to build anything.
            sAdsPath = sContainerName; 
      }
   
      if ( SUCCEEDED(hr) )
      {
         pAds->Release();
         pAds = NULL;
         hr = ADsGetObject(sAdsPath, IID_IADs, (void**) &pAds);
      }
      if (SUCCEEDED(hr) )
      {
         hr = pAds->get_Class(&sClass);
      }
      if ( SUCCEEDED(hr) )
      {
         if ( sClass && wcscmp(sClass, L"group") == 0 && prefInfo.vValue.Integer != ADS_SCOPE_BASE )
         {
            // If we're trying to enumerate the contents of a group, 
            // Construct the DN for group and the LDAP path to whole directory
	         hr = pAds->Get(L"distinguishedName", &var2);
	         if ( SUCCEEDED(hr) )
            {
               sGrpDN = var2.bstrVal;
               sAdsPath = L"LDAP://";
               sAdsPath += sDomainName;
               sAdsPath += L"/";
               sAdsPath += var.bstrVal;

               // modify the query so that we have (& (memberOf=%s) (...) ) query
               sQuery = L"(&(memberOf=";
               sQuery += sGrpDN;
               sQuery += L") ";
               sQuery += m_sQuery;
               sQuery += L")";
               // Also the scope changes since we need to search the whole domain
               prefInfo.vValue.Integer = ADS_SCOPE_SUBTREE;
               hr = ADsGetObject(sAdsPath, IID_IDirectorySearch, (void**) &pSearch);
            }
         }
         else
         {
            sQuery = m_sQuery;
            hr = pAds->QueryInterface(IID_IDirectorySearch, (void**)&pSearch);
         }
         SysFreeString(sClass);
      }
      
      if ( SUCCEEDED(hr) )
      {
         hr = pSearch->SetSearchPreference(&prefInfo, 1);
         // Set the query to be paged query so that we can get the data larger than a 1000.
         ADS_SEARCHPREF_INFO prefInfo2;
         prefInfo2.dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
         prefInfo2.vValue.dwType = ADSTYPE_INTEGER;
         prefInfo2.vValue.Integer = 999;
         hr = pSearch->SetSearchPreference(&prefInfo2, 1);
      }

      if ( SUCCEEDED(hr) )
      {
         if ( (prefInfo.vValue.Integer == ADS_SCOPE_BASE) && (bMultiVal) && 
			  (_wcsicmp(L"member", sAttr[0]) == 0) || (_wcsicmp(L"memberOf", sAttr[0]) == 0) || 
			  (_wcsicmp(L"directReports", sAttr[0]) == 0) || (_wcsicmp(L"managedObjects", sAttr[0]) == 0))
         {
            DoRangeQuery(sDomainName, sQuery, sAttr, attrCnt, hSearch, pSearch, bMultiVal, pList);
         }
         else
         {
            hr = pSearch->ExecuteSearch(sQuery, sAttr, attrCnt, &hSearch);
            if ( SUCCEEDED(hr) )
            {
               hr = pSearch->GetFirstRow(hSearch);
            }
            if ( hr == S_OK )
            {
               while( cont )
               {
                  _variant_t        * varAr = new _variant_t[attrCnt];
	              if (!varAr)
				  {
                     if ( pSearch )
					 {
                        pSearch->CloseSearchHandle(hSearch);
                        pSearch->Release();
					 }
                     if ( pAds )
                        pAds->Release();
					 delete pList;
                     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
//                  int ncol = 0;
                  for ( long dw = 0; dw < attrCnt; dw++ )
                  {
                     hr = pSearch->GetColumn( hSearch, sAttr[dw], &col );
                     if ( SUCCEEDED(hr) )
                     {
                        if ( col.dwNumValues > 0 )
                        {
                           // Get the type of attribute and put the value into the variant
                           // and then into the Enumerator object. 
					            if ( col.dwNumValues < 2 || !bMultiVal )
   					            // put the last item into the enumeration.(memberOf=CN=DNSAdmins,CN=USERS,DC=devblewerg,DC=com)
                              AttrToVariant(col.pADsValues[col.dwNumValues - 1], varAr[dw]);
                           else
                           {
                              // Build a VARIANT array of all the values.
                              SAFEARRAY            * pArray;
                              SAFEARRAYBOUND         bd = {col.dwNumValues, 0};
                              _variant_t             var;
                              _bstr_t                strTemp;  
                              _variant_t  HUGEP    * vArray;
                              pArray = SafeArrayCreate(VT_VARIANT|VT_BSTR, 1, &bd);
                  
                              // Fill up the VARIANT Array
                              SafeArrayAccessData(pArray, (void HUGEP **) &vArray);
                              for ( DWORD x = 0; x < col.dwNumValues; x++ )
                              {
                                 nCnt++;
                                 AttrToVariant(col.pADsValues[x], var);
                                 strTemp = var;
                                 vArray[x] = _variant_t(strTemp);
                              }
                              SafeArrayUnaccessData(pArray);
                              varAr[dw].vt = VT_ARRAY | VT_VARIANT;
                              SafeArrayCopy(pArray, &varAr[dw].parray);
                           }
                        }
                        else
                        {
                           // Put an empty string here.
                           varAr[dw] = (BSTR)NULL;
                        }
                        pSearch->FreeColumn( &col );
                     }
                     else 
                     {
                        // Put an empty string here.
                        varAr[dw] = (BSTR)NULL;
                     }
                  }
                  TAttrNode * pNode = new TAttrNode(attrCnt, varAr);
	              if (!pNode)
				  {
                     delete [] varAr;
                     if ( pSearch )
					 {
                        pSearch->CloseSearchHandle(hSearch);
                        pSearch->Release();
					 }
                     if ( pAds )
                        pAds->Release();
					 delete pList;
                     return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
				  }
			         // Clear the array
                  delete [] varAr;
                  if ( pSearch->GetNextRow(hSearch)  == S_ADS_NOMORE_ROWS )
                     cont = false;
                  pList->InsertBottom(pNode);
               }
            }
            pSearch->CloseSearchHandle(hSearch);
         }
      }
   }
   if ( pSearch )
      pSearch->Release();

   if ( pAds )
      pAds->Release();
   
//   UpdateAccountInList(pList, sDomainName);
   *pVarEnum = (IEnumVARIANT *) new CNT4Enum(pList);
   if (!(*pVarEnum))
   {
	  delete pList;
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }
   return S_OK;
}

//--------------------------------------------------------------------
// AttrToVariant : This function stores a value from ADSValue struct
//                 into a variant in a appropriate type.
//--------------------------------------------------------------------
bool CWin2000Dom::AttrToVariant(
                                 ADSVALUE pADsValues,    //in- Value for a property in ADSVALUE struct
                                 _variant_t& var         //out-Variant filled with info from the in parameter.
                               )
{
   HRESULT hr = S_OK;
      // Fill in the values as per the varset.
      switch (pADsValues.dwType)
      {
         case ADSTYPE_INVALID             :  break;

         case ADSTYPE_DN_STRING           :  var = pADsValues.DNString;
                                             break;
         case ADSTYPE_CASE_EXACT_STRING   :  var = pADsValues.CaseExactString;
                                             break;
         case ADSTYPE_CASE_IGNORE_STRING  :  var = pADsValues.CaseIgnoreString;
                                             break;
         case ADSTYPE_PRINTABLE_STRING    :  var = pADsValues.PrintableString;
                                             break;
         case ADSTYPE_NUMERIC_STRING      :  var = pADsValues.NumericString;
                                             break;
         case ADSTYPE_INTEGER             :  var.vt = VT_I4;
                                             var.lVal = pADsValues.Integer;
                                             break; 
         case ADSTYPE_OCTET_STRING        :  {
                                                var.vt = VT_ARRAY | VT_UI1;
                                                var.parray = NULL;
                                                byte           * pData;
                                                DWORD            dwLength = pADsValues.OctetString.dwLength;
                                                SAFEARRAY      * sA;
                                                SAFEARRAYBOUND   rgBound = {dwLength, 0}; 
                                                sA = ::SafeArrayCreate(VT_UI1, 1, &rgBound);
                                                ::SafeArrayAccessData( sA, (void**)&pData);
                                                for ( DWORD i = 0; i < dwLength; i++ )
                                                   pData[i] = pADsValues.OctetString.lpValue[i];
                                                hr = ::SafeArrayUnaccessData(sA);
                                                hr = ::SafeArrayCopy(sA, &var.parray);
												            hr = ::SafeArrayDestroy(sA);
                                             }
                                             break;
/*         case ADSTYPE_UTC_TIME            :  var = L"Date not supported.";
                                             break;
         case ADSTYPE_LARGE_INTEGER       :  var = L"Large Integer not supported.";
                                             break;
         case ADSTYPE_PROV_SPECIFIC       :  var = L"Provider specific strings not supported.";
                                             break;
         case ADSTYPE_OBJECT_CLASS        :  var = pADsValues.ClassName;
                                             break;
         case ADSTYPE_CASEIGNORE_LIST     :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Case ignore lists are not supported.";
                                             break;
         case ADSTYPE_OCTET_LIST          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Octet lists are not supported.";
                                             break;
         case ADSTYPE_PATH                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Path type not supported.";
                                             break;
         case ADSTYPE_POSTALADDRESS       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Postal addresses are not supported.";
                                             break;
         case ADSTYPE_TIMESTAMP           :  var.vt = VT_UI4;
                                             var.lVal = attrInfo.pADsValues[dw].UTCTime;
                                             break;
         case ADSTYPE_BACKLINK            :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Backlink is not supported.";
                                             break;
         case ADSTYPE_TYPEDNAME           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Typed name not supported.";
                                             break;
         case ADSTYPE_HOLD                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Hold not supported.";
                                             break;
         case ADSTYPE_NETADDRESS          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"NetAddress not supported.";
                                             break;
         case ADSTYPE_REPLICAPOINTER      :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Replica pointer not supported.";
                                             break;
         case ADSTYPE_FAXNUMBER           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Faxnumber not supported.";
                                             break;
         case ADSTYPE_EMAIL               :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Email not supported.";
                                             break;
         case ADSTYPE_NT_SECURITY_DESCRIPTOR : wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Security Descriptor not supported.";
                                             break;
                                             */
         default                          :  return false;
   }
   return true;
}

/*void CWin2000Dom::UpdateAccountInList(TNodeList *pList, BSTR sDomainName)
{
	bool found = false;
	for ( TAttrNode * pNode = (TAttrNode *)pList->Head(); pNode; pNode = (TAttrNode *)pNode->Next())
	{
		if ( _bstr_t(pNode->m_Val) == _bstr_t(sPDC) )
		{
			found = true;
			break;
		}
	}

	if ( !found )
	{
		TAttrNode * pNode = new TAttrNode(attrCnt, varAr);
		pList->InsertBottom(pNode);
	}
}
*/

HRESULT  CWin2000Dom::DoRangeQuery(BSTR sDomainName, BSTR sQuery, LPWSTR * sAttr, int attrCnt, ADS_SEARCH_HANDLE hSearch, IDirectorySearch * pSearch, BOOL bMultiVal, TNodeList * pList)
{
   HRESULT                   hr;
   bool                      cont = true;
   ADS_SEARCH_COLUMN         col;
   int                       nCnt = 0;
   int                     * pStartWith;
   int                     * pEndWith;
   WCHAR                     sAttrRange[LEN_Path];
   int                       tryCols = 0;
   LPWSTR                  * sAttrs = NULL;
   _variant_t              * varAr;
   TAttrNode               * pNode;
   LPWSTR				   * psAttrNames;
   BOOL					   * pDone;
   BOOL					     bAllDone = FALSE;
   int						 nOrigCnt = attrCnt;
   int						 ndx;

   pStartWith = new int[attrCnt];
   pEndWith = new int[attrCnt];
   psAttrNames = new LPWSTR[attrCnt];
   sAttrs = new LPWSTR[attrCnt];
   pDone = new BOOL[attrCnt];

   if ((!pStartWith) || (!pEndWith) || (!psAttrNames) || (!sAttrs) || (!pDone))
   {
	  if (pStartWith)
         delete [] pStartWith;
	  if (pEndWith)
         delete [] pEndWith;
	  if (psAttrNames)
         delete [] psAttrNames;
	  if (sAttrs)
         delete [] sAttrs;
	  if (pDone)
         delete [] pDone;
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   }

   for (ndx = 0; ndx < attrCnt; ndx++)
   {
	  pStartWith[ndx] = 0;
	  pEndWith[ndx] = 0;
	  psAttrNames[ndx] = sAttr[ndx];
	  sAttrs[ndx] = _wcsdup(sAttr[ndx]);
	  pDone[ndx] = FALSE;
   }

   // continue to retrieve field's values in MAX chunks until done
   while (!bAllDone)
   {
	  int last = 0;
      for (ndx = 0; ndx < attrCnt; ndx++)
	  {
		 if (pDone[ndx] == FALSE)
		 {
			if (IsPropMultiValued((WCHAR*)psAttrNames[ndx], (WCHAR*)sDomainName) == true)
               wsprintf(sAttrRange, L"%s;range=%d-*", (WCHAR*)(psAttrNames[ndx]), pStartWith[ndx]);
			else
			   wcscpy(sAttrRange, (WCHAR*)psAttrNames[ndx]);

			free(sAttrs[ndx]);
            sAttrs[last] = _wcsdup(sAttrRange);
            psAttrNames[last] = psAttrNames[ndx];
			pStartWith[last] = pStartWith[ndx];
			pEndWith[last] = pEndWith[ndx];
			pDone[last] = pDone[ndx];
			last++;
		 }
		 else
            free(sAttrs[ndx]);
	  }
	  attrCnt = last;
      varAr = new _variant_t[attrCnt];
	  if (!varAr)
	  {
         delete [] pStartWith;
         delete [] pEndWith;
         delete [] psAttrNames;
         delete [] pDone;
         for (ndx = 0; ndx < attrCnt; ndx++)
		 {
            free(sAttrs[ndx]);
		 }
         delete [] sAttrs;
         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	  }

	  for (ndx=0; ndx<attrCnt; ndx++)
	  {
         varAr[ndx] = (BSTR)NULL;
	     pDone[ndx] = TRUE;
	  }

      hr = pSearch->ExecuteSearch(sQuery, sAttrs, attrCnt, &hSearch);
      if ( SUCCEEDED(hr) )
      {
         hr = pSearch->GetFirstRow(hSearch);
      }
      if ( hr == S_OK )
      {
         while( cont )
         {
			LPWSTR pszColumn;
			_bstr_t sTemp;
			   //since the column name could have changed (in the case that there are
			   //more values to enumerate than IDirectorySearch can in a single call : 
			   //default is 1000) we need to find the column's new name
            hr = pSearch->GetNextColumnName(hSearch, &pszColumn);
			while (pszColumn != NULL)
			{
			   int current = -1;
               if ((SUCCEEDED(hr)) && (hr != S_ADS_NOMORE_COLUMNS))
			   {
				     //get the new column name
				  do
				  {
				     current++;
				     sTemp = psAttrNames[current];
				     if (wcslen(psAttrNames[current]) != (wcslen(pszColumn)))
				        sTemp += L";range=";
				  }
				  while ((current < attrCnt) && (wcsstr(pszColumn, (WCHAR*)sTemp) == NULL));

	              pDone[current] = FALSE;

				  if (wcsstr(pszColumn, (WCHAR*)sTemp) != NULL)
				  {
				     _bstr_t oldName = psAttrNames[current];
				     oldName += L";range=";
				     if ((wcsstr(pszColumn, oldName) != NULL) && 
					     (wcsstr(pszColumn, L"-*") == NULL))
					 {
					    WCHAR  sName[MAX_PATH];
				           //now get the new range max retrieved so far
                        swscanf(pszColumn, L"%[^;];range=%d-%d", sName, &pStartWith[current], &pEndWith[current]);
                        free(sAttrs[current]);
                        sAttrs[current] = _wcsdup(pszColumn); //save the new column name
					 }
				     else if ((wcsstr(pszColumn, L"-*") != NULL) || (!wcscmp(pszColumn, psAttrNames[current])))
					    pDone[current] = TRUE;
				     FreeADsMem(pszColumn);
				  }
			   }

               hr = pSearch->GetColumn( hSearch, sAttrs[current], &col );
               if ( SUCCEEDED(hr) )
               {
                  if ( col.dwNumValues > 0 )
                  {
                     // Build a VARIANT array of all the values.
                     SAFEARRAY            * pArray;
                     SAFEARRAYBOUND         bd = {col.dwNumValues, 0};
                     _variant_t             var;
                     _bstr_t                strTemp;  
                     _variant_t  HUGEP    * vArray;
                     pArray = SafeArrayCreate(VT_VARIANT|VT_BSTR, 1, &bd);
      
                     // Fill up the VARIANT Array
                     SafeArrayAccessData(pArray, (void HUGEP **) &vArray);
                     for ( DWORD x = 0; x < col.dwNumValues; x++ )
                     {
                        nCnt++;
                        AttrToVariant(col.pADsValues[x], var);
                        strTemp = var;
                        vArray[x] = _variant_t(strTemp);
                     }
                     SafeArrayUnaccessData(pArray);
                     varAr[current].vt = VT_ARRAY | VT_VARIANT;
                     SafeArrayCopy(pArray, &varAr[current].parray);
                  }
                  pSearch->FreeColumn( &col );
               }
               hr = pSearch->GetNextColumnName(hSearch, &pszColumn);
            }//end while more columns
            if ( pSearch->GetNextRow(hSearch)  == S_ADS_NOMORE_ROWS )
            {
               hr = S_OK;
               cont = false;
            }
         }
      }
      else
      {
         bAllDone = TRUE;
      }

      if ( pStartWith[0] == 0 )
	  {
         pNode = new TAttrNode((long)attrCnt, varAr);
	     if (!pNode)
		 {
            delete [] varAr;
            delete [] pStartWith;
            delete [] pEndWith;
            delete [] psAttrNames;
            delete [] pDone;
            for (ndx = 0; ndx < attrCnt; ndx++)
			{
               free(sAttrs[ndx]);
			}
            delete [] sAttrs;
            pSearch->CloseSearchHandle(hSearch);
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		 }
	  }
      else  //else add the new values for any remaining attributes
	  {
	     for (int i=0; i<attrCnt; i++)
		 {
			int j=-1;
			bool bFound = false;
			  //find the original column of this attribute for the 'Add' call
		    while ((j < nOrigCnt) && (!bFound))
			{
			   j++;
			   if (wcscmp(psAttrNames[i], sAttr[j]) == 0)
			      bFound = true; //original column number
			}
			if (bFound) //if found, add the new values for that column
               pNode->Add((long)j, (long)i, varAr);
		 }
	  }

      // Clear the array
      delete [] varAr;

      pSearch->CloseSearchHandle(hSearch);
      cont = true;
      
	  bAllDone = TRUE;
      for (ndx = 0; ndx < attrCnt; ndx++)
	  {
		 pStartWith[ndx] = pEndWith[ndx] + 1;  //start the next query
		 bAllDone = ((bAllDone) && (pDone[ndx])) ? TRUE : FALSE; //see if done with all properties
	  }
   }

   delete [] pStartWith;
   delete [] pEndWith;
   delete [] psAttrNames;
   delete [] pDone;

   for (ndx = 0; ndx < attrCnt; ndx++)
   {
      free(sAttrs[ndx]);
   }

   delete [] sAttrs;

   pList->InsertBottom(pNode);

   return hr;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 10 NOV 2000                                                 *
 *                                                                   *
 *     This function is responsible for checking a property's schema *
 * to see if that property is multi-valued or not.                   *
 *                                                                   *
 *********************************************************************/

//BEGIN IsPropMultiValued
bool CWin2000Dom::IsPropMultiValued(const WCHAR * sPropName, const WCHAR * sDomain)
{
   HRESULT                         hr;
   VARIANT_BOOL                    bMulti = VARIANT_FALSE;
   WCHAR                           sAdsPath[LEN_Path];
   IADsProperty                  * pProp = NULL;

   if ( wcslen(sPropName) == 0 )
      return false;

      //prepare to call the property's schema
   wcscpy(sAdsPath, L"LDAP://");
   wcscat(sAdsPath, sDomain);
   wcscat(sAdsPath, L"/");
   wcscat(sAdsPath, sPropName);
   wcscat(sAdsPath, L", schema");

   hr = ADsGetObject(sAdsPath, IID_IADsProperty, (void **)&pProp);

   // Get the Multi-Valued flag for the property
   if (SUCCEEDED(hr))
   {
      hr = pProp->get_MultiValued(&bMulti);
      pProp->Release();
   }

   if (bMulti == VARIANT_TRUE)
      return true;
   else
      return false;
}
//END IsPropMultiValued
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\enumvar.h ===
// EnumVar.h: interface for the CEnumVar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define UNLEN        255

// The follwing flags make up a bitmask used to define what values the Enumerator fills up
// for a given object.

// TODO :: We can add more attributes in order to get the appropriate information from the Object
//         when we enumerate it. To add items simply add a flag and then add an item to the struct.
#define  F_Name              0x00000001
#define  F_Class             0x00000002
#define  F_SamName           0x00000004
#define  F_GroupType         0x00000008

// Structure used to fill out information about the object
typedef struct _Obj {
   WCHAR                     sName[UNLEN];    // Common Name of the object
   WCHAR                     sClass[UNLEN];   // The type of the object
   WCHAR                     sSamName[UNLEN]; // SamAccountName of the object
   long                      groupType;       // The type of a group object (UNIVERSAL etc)
} SAttrInfo;

class CEnumVar  
{
public:
	BOOL Next( long flag, SAttrInfo * pAttr );
	IEnumVARIANT  * m_pEnum;
	CEnumVar(IEnumVARIANT  * pEnum);
	virtual ~CEnumVar();
};

#endif // !defined(AFX_ENUMVAR_H__EFC2C760_1A9F_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\enumtest.h ===
// EnumTest.h : main header file for the ENUMTEST application
//

#if !defined(AFX_ENUMTEST_H__36AFC712_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_ENUMTEST_H__36AFC712_1921_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp:
// See EnumTest.cpp for the implementation of this class
//

class CEnumTestApp : public CWinApp
{
public:
	CEnumTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumTestApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CEnumTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENUMTEST_H__36AFC712_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\enumtest.cpp ===
// EnumTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "EnumTest.h"
#include "EnumTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp

BEGIN_MESSAGE_MAP(CEnumTestApp, CWinApp)
	//{{AFX_MSG_MAP(CEnumTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp construction

CEnumTestApp::CEnumTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CEnumTestApp object

CEnumTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CEnumTestApp initialization

BOOL CEnumTestApp::InitInstance()
{
	AfxEnableControlContainer();
   CoInitialize(NULL);

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CEnumTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}

int CEnumTestApp::ExitInstance() 
{
   CoUninitialize();	
	return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\enumvar.cpp ===
// EnumVar.cpp: implementation of the CEnumVar class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <COMDEF.h>
#include "EnumTest.h"
#include "EnumVar.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumVar::CEnumVar(IEnumVARIANT  * pEnum)
{
   m_pEnum = pEnum;
   m_pEnum->AddRef();
}

CEnumVar::~CEnumVar()
{
   m_pEnum->Release();
}

BOOL CEnumVar::Next(long flag, SAttrInfo * pAttr)
{
   // This function enumerates through and gets name strings for the Values
   ULONG                     ulFetched=0;
   IADs                    * pADs=NULL;
   _variant_t                var;
   BSTR                      bstrName;
   
   if ( !m_pEnum )
   {
      return FALSE;
   }

   HRESULT hr = m_pEnum->Next(1, &var, &ulFetched);

   if ( ulFetched == 0 || FAILED(hr) )
      return FALSE;

   if ( var.vt == VT_BSTR )
   {
      // We have a bstring so lets just return that as names
      wcscpy(pAttr->sName, var.bstrVal);
      wcscpy(pAttr->sSamName, var.bstrVal);
   }
   else
   {
      if ( flag == NULL )
         return FALSE;
      // We have a Dispatch Pointer
      IDispatch * pDisp = V_DISPATCH(&var);
      // We ask for a IAds pointer
      hr = pDisp->QueryInterface( IID_IADs, (void**)&pADs); 
      // and Ask IAds pointer to give us the name of the container.

      // Now fill up information that they need.
      
      // Common Name
      if ( flag | F_Name )
      {
         hr = pADs->get_Name(&bstrName);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sName, bstrName);
      }

      // SAM Account Name
      if ( flag | F_SamName )
      {
         hr = pADs->Get(L"sAMAccountName", &var);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sSamName, var.bstrVal);
      }

      // Class name of the object.
      if ( flag | F_Class )
      {
         hr = pADs->get_Class(&bstrName);
         if ( FAILED(hr) )
            return FALSE;
         wcscpy( pAttr->sClass, bstrName);
      }

      // Group Type
 /*     if ( flag | F_GroupType )
      {
         hr = pADs->Get(L"groupType", &var);
         if ( FAILED(hr) )
         {
            var.vt = VT_I4;
            var.lVal = -1;
         }
         pAttr->groupType = var.lVal;
      }
*/   }
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\enumtestdlg.h ===
// EnumTestDlg.h : header file
//

#if !defined(AFX_ENUMTESTDLG_H__36AFC714_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_ENUMTESTDLG_H__36AFC714_1921_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CEnumTestDlg dialog

class CEnumTestDlg : public CDialog
{
// Construction
public:
	CEnumTestDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CEnumTestDlg)
	enum { IDD = IDD_ENUMTEST_DIALOG };
	CListCtrl	m_listBox;
	CString	m_strContainer;
	CString	m_strDomain;
   CString  m_strQuery;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEnumTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CEnumTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	afx_msg void OnDblclkListMembers(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnBacktrack();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
   char * GetSidFromVar(_variant_t var);

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ENUMTESTDLG_H__36AFC714_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\enumtestdlg.cpp ===
// EnumTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "EnumTest.h"
#include "EnumTestDlg.h"
#include "EnumVar.h"
#include <sddl.h>

#import "\bin\NetEnum.tlb"  no_namespace
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumTestDlg dialog

CEnumTestDlg::CEnumTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEnumTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEnumTestDlg)
	m_strContainer = _T("");
	m_strDomain = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CEnumTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnumTestDlg)
	DDX_Control(pDX, IDC_LIST_MEMBERS, m_listBox);
	DDX_Text(pDX, IDC_EDIT_Container, m_strContainer);
	DDX_Text(pDX, IDC_EDIT_DOMAIN, m_strDomain);
	DDX_Text(pDX, IDC_EDIT_QUERY, m_strQuery);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEnumTestDlg, CDialog)
	//{{AFX_MSG_MAP(CEnumTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_MEMBERS, OnDblclkListMembers)
	ON_BN_CLICKED(IDC_BACKTRACK, OnBacktrack)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnumTestDlg message handlers

BOOL CEnumTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	m_strContainer = L"OU=ShamTest";
	m_strDomain    = L"devblewerg";
   m_strQuery     = L"(objectClass=*)";
	UpdateData(FALSE);
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CEnumTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CEnumTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CEnumTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CEnumTestDlg::OnOK() 
{
/*   m_listBox.DeleteAllItems();
   UpdateData();
   INetObjEnumeratorPtr           pNetObj(__uuidof(NetObjEnumerator));
   BSTR                           sContName = m_strContainer.AllocSysString();
   BSTR                           sDomain = m_strDomain.AllocSysString();
   IEnumVARIANT					  * pEnum;
   HRESULT                        hr;
   VARIANT                        varEnum;
   ULONG                          ulFetch = 0;
   VariantInit(&varEnum);

   m_listBox.InsertItem(0, "====================");
   hr = pNetObj->raw_GetContainerEnum( sContName, sDomain, &pEnum);
   if ( FAILED(hr) )
   {
      m_listBox.InsertItem(0, "Invalid Container");
      return;
   }

   ::SysFreeString(sContName);
   ::SysFreeString(sDomain);
   hr = S_OK;
   SAttrInfo      sInfo;
   CString        disp;
   long           flag = 15;  // Get all four values.
   if (pEnum)
   {
      CEnumVar          enumVar(pEnum);
      while ( enumVar.Next(flag, &sInfo) )
      {
         disp.Format("%ls<%ls>", sInfo.sName, sInfo.sClass);
         m_listBox.InsertItem(0, disp);
      }
      ADsFreeEnumerator(pEnum); 
   }
   */
   m_listBox.DeleteAllItems();
   bool	bFullPath;
   UpdateData();
   BSTR                           sContName = m_strContainer.AllocSysString();
   if ( m_strDomain.Left(5) == L"GC://" )
	   bFullPath = true;
   BSTR                           sDomain = m_strDomain.AllocSysString();
   BSTR                           sQuery = m_strQuery.AllocSysString();
   INetObjEnumeratorPtr           pNetObj(__uuidof(NetObjEnumerator));
   IEnumVARIANT					  * pEnum;
   DWORD                          ulFet=0;
   _variant_t                     var, var2;
   _variant_t                   * pVars;
   CString						  sX;
   CString                       strDisp;
   BSTR HUGEP * pData;
//   BSTR   pBSTR[] = { L"name", L"accountExpires", L"sAMAccountName", L"objectClass", L"objectSID", L"ou", L"cn"  };
   BSTR   pBSTR[] = { L"name", L"dc"};
   long   ind = sizeof(pBSTR)/sizeof(BSTR);
   SAFEARRAYBOUND b = { ind, 0 };
   SAFEARRAY * pArray = NULL;
   pArray = ::SafeArrayCreate(VT_BSTR, 1, &b);

   ::SafeArrayAccessData(pArray, (void HUGEP **)&pData);
   for (long i = 0; i < ind; i++)
      pData[i] = pBSTR[i];
   ::SafeArrayUnaccessData(pArray);
   try
   {
//      pNetObj->SetQuery(sContName, sDomain, sQuery, ADS_SCOPE_ONELEVEL );
      pNetObj->SetQuery(sContName, sDomain, sQuery, ADS_SCOPE_SUBTREE );
      pNetObj->SetColumns((long) pArray);
      pNetObj->Execute(&pEnum);
   }
   catch (const _com_error &e)
   {
      ::AfxMessageBox(e.ErrorMessage());
      return;
   }
   if (pEnum)
   {
      while (pEnum->Next(1, &var, &ulFet) == S_OK)
      {
         if ( ulFet )
         {
            pArray = var.parray;
            long ub, lb;
            ::SafeArrayGetUBound(pArray, 1, &ub);
            ::SafeArrayGetLBound(pArray, 1, &lb);

            ::SafeArrayAccessData(pArray, (void HUGEP **)&pVars);
//            for ( long x = lb; x <= ub - 2; x++)
			for ( long x = lb; x <= ub ; x++)
            {
               if ( x > lb )
               {
                  if ( pVars[x].vt == VT_BSTR)
                     strDisp = strDisp + "<" + CString(pVars[x].bstrVal) + ">";
                  else
                     if ( pVars[x].vt == (VT_ARRAY | VT_UI4) )
                        // Octet string 
                        strDisp = strDisp + "<" + CString(GetSidFromVar(pVars[x])) + ">";
                     else
					 {
						// an integer
                        sX.Format("%s<%d>", strDisp, pVars[x].lVal);
						strDisp = sX;
					 }
               }
               else
               {
                  if ( !CString(pVars[ub-1].bstrVal).IsEmpty() )
                     strDisp = "OU=";
                  else
                     // it is a CN
                     strDisp = "CN=";
                  strDisp = strDisp + CString(pVars[x].bstrVal);
               }
            }
            m_listBox.InsertItem(0, strDisp);
            ::SafeArrayUnaccessData(pArray);
         }
      }
   }
   ::SysFreeString(sDomain);
   ::SysFreeString(sQuery);
   ::SysFreeString(sContName);
}

void CEnumTestDlg::OnDblclkListMembers(NMHDR* pNMHDR, LRESULT* pResult) 
{
   int len = m_strContainer.GetLength();
   UpdateData();
   CString str = m_listBox.GetItemText(m_listBox.GetSelectionMark(),0);	
   str = str.Left(str.Find("<"));
   if ( len )
      m_strContainer = str + "," + m_strContainer;
   else
      m_strContainer = str;
   UpdateData(FALSE);
   OnOK();
	*pResult = 0;
}

void CEnumTestDlg::OnBacktrack() 
{
   UpdateData();
   int ndx = m_strContainer.Find(",");
   if ( ndx != -1 )
      m_strContainer = m_strContainer.Mid(ndx + 1);
   else
      m_strContainer = "";
   UpdateData(FALSE);
   OnOK();
}

char * CEnumTestDlg::GetSidFromVar(_variant_t var)
{
   void HUGEP *pArray;
   PSID        pSid;
   char        * sSid;
   HRESULT hr = SafeArrayAccessData( V_ARRAY(&var), &pArray );
   if ( SUCCEEDED(hr) ) 
      pSid = (PSID)pArray;
   ::ConvertSidToStringSid(pSid, &sSid);
   hr = ::SafeArrayUnaccessData(V_ARRAY(&var));
   return sSid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by EnumTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_ENUMTEST_DIALOG             102
#define IDR_MAINFRAME                   128
#define IDC_LIST_MEMBERS                1000
#define IDC_EDIT_Container              1001
#define IDC_EDIT_DOMAIN                 1002
#define IDC_BACKTRACK                   1003
#define IDC_EDIT_QUERY                  1004

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1004
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	EnumTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\containerselectiondlg.cpp ===
// ContainerSelectionDlg.cpp : implementation file
//

#include "stdafx.h"
#include "OUPicker.h"
#include "ContainerSelectionDlg.h"
#include "iads.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

const BSTR sQuery = L"(|(objectClass=organizationalUnit) (objectClass=container))";
HTREEITEM root;

CContainerSelectionDlg::CContainerSelectionDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CContainerSelectionDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CContainerSelectionDlg)
	m_strCont = _T("");
	//}}AFX_DATA_INIT
}


void CContainerSelectionDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CContainerSelectionDlg)
	DDX_Control(pDX, IDOK, m_btnOK);
	DDX_Control(pDX, IDC_TREE1, m_trOUTree);
	DDX_Text(pDX, IDC_EDIT1, m_strCont);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CContainerSelectionDlg, CDialog)
	//{{AFX_MSG_MAP(CContainerSelectionDlg)
	ON_BN_CLICKED(IDOK, OnOk)
	ON_NOTIFY(TVN_SELCHANGED, IDC_TREE1, OnSelchangedTree1)
	ON_NOTIFY(NM_DBLCLK, IDC_TREE1, OnDblclkTree1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg message handlers

void CContainerSelectionDlg::OnOk() 
{
   CDialog::OnOK();	
}

BOOL CContainerSelectionDlg::OnInitDialog() 
{
   CWaitCursor wait;
	CDialog::OnInitDialog();
   if ( m_strDomain.IsEmpty() )
      return TRUE;

   LoadImageList();

   root = m_trOUTree.InsertItem(m_strDomain, 0, 1);
   ExpandCompletely(root, L"");
   FindContainer();
   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

}

HRESULT CContainerSelectionDlg::PopulateContainer(
                                                  HTREEITEM tvItemParent,        //in- Item to expand
                                                  BSTR      sContName,           //in- Name of the container.
                                                  INetObjEnumeratorPtr pQuery    //in- Query Object
                                                 )
{
   HRESULT                   hr = E_FAIL;
   IEnumVARIANT            * pEnum = NULL;
   SAFEARRAY               * psaCols = NULL;
   SAFEARRAYBOUND            bd = { 2, 0 };
   BSTR                      pCols[] = { L"name", L"objectClass" };
   BSTR  HUGEP             * pData;
   _variant_t                var;
   DWORD                     dwFetch = 0;
   BSTR                      domain = m_strDomain.AllocSysString();
   SAFEARRAY               * psaVals;
   _bstr_t                   sValName;
   _bstr_t                   sType;
   _variant_t              * pDataVar;
   _variant_t                varVal;
   WCHAR                     sTempName[255];
   int                       img = 0;

   psaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
   if ( psaCols )
   {
      hr = SafeArrayAccessData(psaCols, (void HUGEP **)&pData);
      if ( SUCCEEDED(hr) )
      {
         pData[0] = pCols[0];
         pData[1] = pCols[1];
      }
      SafeArrayUnaccessData(psaCols);
   }


   if ( SUCCEEDED(hr))
      hr = pQuery->raw_SetQuery(sContName, domain, sQuery, ADS_SCOPE_ONELEVEL, FALSE);

   if ( SUCCEEDED(hr) )
      hr = pQuery->raw_SetColumns(psaCols);

   if ( SUCCEEDED(hr))
      hr = pQuery->raw_Execute(&pEnum);

   if ( pEnum )
   {
      while ( pEnum->Next(1, &var, &dwFetch) == S_OK )
      {
         psaVals = V_ARRAY(&var);
         hr = SafeArrayAccessData(psaVals, (void**)&pDataVar);
         if ( SUCCEEDED(hr) )
         {
            varVal = pDataVar[0];
            if ( varVal.vt == VT_BSTR ) sValName = V_BSTR(&varVal);
            varVal = pDataVar[1];
            if ( varVal.vt == VT_BSTR ) sType = V_BSTR(&varVal);
            SafeArrayUnaccessData(psaVals);
         }


         if ( SUCCEEDED(hr) )
         {
            // 
            if ( wcsicmp(sType, L"organizationalUnit") == 0 )
            {
               wsprintf(sTempName, L"OU=%s", (WCHAR*)sValName);
               img = 4;
            }
            else
            {
               wsprintf(sTempName, L"CN=%s", (WCHAR*)sValName);
               img = 2;
            }
            if ( wcsicmp(sTempName, L"CN=System") != 0 )
               m_trOUTree.InsertItem(sTempName, img, img+1, tvItemParent);
         }
      }
   }
   
   // Clean up
   ::SysFreeString(domain);
   if ( pEnum ) pEnum->Release();
   VariantInit(&var);
   return hr;
}


HRESULT CContainerSelectionDlg::ExpandCompletely(HTREEITEM tvItem, BSTR parentCont)
{
   HTREEITEM                 tvChild;
   WCHAR                     currCont[255];
   CString                   sContName;
   HRESULT                   hr = S_OK;
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));

   // First populate this container
   hr = PopulateContainer( tvItem, parentCont, pQuery);

   // Check if it has children. If it does then for each child call this function recursively
   if ( m_trOUTree.ItemHasChildren(tvItem) )
   {
      tvChild = m_trOUTree.GetChildItem(tvItem);
      while ( tvChild )
      {
         // Get the name of the 
         sContName = m_trOUTree.GetItemText(tvChild);
         if ( wcslen(parentCont) > 0 )
            wsprintf(currCont, L"%s,%s", sContName, (WCHAR*)parentCont);
         else
            wcscpy(currCont, sContName.AllocSysString());
         ExpandCompletely(tvChild, currCont);
         tvChild = m_trOUTree.GetNextSiblingItem(tvChild);
      }
   }
   return hr;
}

BOOL CContainerSelectionDlg::LoadImageList()
{
	// set up icon list for list box
   // use bitmaps 
   CBitmap           cont;
   CBitmap           ou;
   CBitmap           openCont;
   CBitmap           openOU;
   CBitmap           dir;
   CBitmap           dirOpen;
   
   COLORREF          cr = 0x000000;
   if (
      dir.LoadBitmap(IDB_DIR)
      && dirOpen.LoadBitmap(IDB_OPEN_DIR)
      && cont.LoadBitmap(IDB_CONT)
      && ou.LoadBitmap(IDB_OU)
      && openCont.LoadBitmap(IDB_OPEN_CONT)
      && openOU.LoadBitmap(IDB_OPEN_OU)
   )
   {
      cr = GetFirstBitmapPixel(this,IDB_CONT);
      ilist.Create(IDB_DIR, 16, 16, cr);
      ilist.Add(&dirOpen, cr);
      ilist.Add(&cont,cr);
      ilist.Add(&openCont,cr);
      ilist.Add(&ou,cr);
      ilist.Add(&openOU,cr);
      m_trOUTree.SetImageList(&ilist,TVSIL_NORMAL);
   }
   return TRUE;
}

COLORREF CContainerSelectionDlg::GetFirstBitmapPixel(CWnd * window,UINT idbBitmap)
{
   CBitmap     bmp;
   COLORREF    color = 0x00ffffff;
   
   if ( bmp.LoadBitmap(idbBitmap) )
   {
      // Get Device context       
      CDC                  * windowDC = window->GetDC();
      HDC                    hdcImage = ::CreateCompatibleDC(windowDC->m_hDC);
      CBitmap              * tempBmp = (CBitmap *)::SelectObject(hdcImage,(HBITMAP)bmp);
      // now get the pixel
      if ( windowDC && hdcImage && tempBmp )
      {
         color = GetPixel(hdcImage,0, 0);
      }
      if ( tempBmp )
         ::SelectObject(hdcImage,tempBmp);
      if ( hdcImage )
         ::DeleteObject(hdcImage);
   }
   return color;
}

void CContainerSelectionDlg::OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
   m_strCont = L"";
	HTREEITEM                 tvSelected, tvParent;
   NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   tvSelected = m_trOUTree.GetSelectedItem();
   if ( tvSelected )
   {
      // We dont want to process the domain name in the Container name so go upto
      // the point where we have a parent. i.e. Child of the domain node.
      while( tvParent = m_trOUTree.GetParentItem(tvSelected) )
      {
         // Build the container list by walking up the tree.
         if ( m_strCont.IsEmpty() )
            m_strCont = m_trOUTree.GetItemText(tvSelected);
         else
            m_strCont = m_strCont + CString(L",") + m_trOUTree.GetItemText(tvSelected);
         tvSelected = tvParent;
      }
   }
   m_btnOK.EnableWindow(!m_strCont.IsEmpty());
   UpdateData(FALSE);
	*pResult = 0;
}

void CContainerSelectionDlg::OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult) 
{
   UpdateData();
   if ( !m_strCont.IsEmpty() )
      OnOk();	
	*pResult = 0;
}

HRESULT CContainerSelectionDlg::FindContainer()
{
   CString                   strName;
   int                       ndx = 0, oldNdx = -1;
   // We can find the container iff there is one specified.
   if (!m_strCont.IsEmpty())
   {
      OpenContainer(m_strCont, root);
   }
   return S_OK;
}

HTREEITEM CContainerSelectionDlg::OpenContainer(CString strCont, HTREEITEM rootSub)
{
   int                       ndx = -1;
   CString                   strLeft, strRight;
   HTREEITEM                 tvItem = NULL;

   if ( !strCont.IsEmpty() && rootSub ) 
   {
      ndx = strCont.Find(L",", 0);
      if ( ndx > -1 )
      {
         // Get the right side of the comma string and Call this again to open the parent container.
         strLeft = strCont.Left(ndx);
         strRight = strCont.Mid(ndx + 1);
         tvItem = OpenContainer(strRight, rootSub);
         tvItem = OpenContainer(strLeft, tvItem);
      }
      else
      {
         // We have a container name so lets find it below rootSub node.
         tvItem = m_trOUTree.GetChildItem(rootSub);
         while (tvItem)
         {
            if ( m_trOUTree.GetItemText(tvItem) == strCont )
            {
               //m_trOUTree.Expand(tvItem, 0);
               m_trOUTree.Select(tvItem, TVGN_CARET);
               break;
            }
            tvItem = m_trOUTree.GetNextSiblingItem(tvItem);
         }
      }
   }
   return tvItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\netobjen\enumtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__36AFC716_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__36AFC716_1921_11D3_8C7F_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <iads.h>
#include <adshlp.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__36AFC716_1921_11D3_8C7F_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "OUPicker.h"

#include "MainFrm.h"

#include "ContainerSelectionDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_COMMAND(ID_FILE_NEW, OnFileNew)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


void CMainFrame::OnFileNew() 
{
 	CContainerSelectionDlg  dlg;
   dlg.m_strDomain = CString("devraptorw2k");
   dlg.m_strCont = CString("OU=THANKS,OU=MAWLA,OU=TRIAL,OU=HELLO");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\containerselectiondlg.h ===
#if !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
#define AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ContainerSelectionDlg.h : header file
//
#import "\bin\NetEnum.tlb" no_namespace

/////////////////////////////////////////////////////////////////////////////
// CContainerSelectionDlg dialog

class CContainerSelectionDlg : public CDialog
{
// Construction
public:
	HRESULT FindContainer();
	CImageList ilist;
	BOOL LoadImageList();
	HRESULT ExpandCompletely(HTREEITEM tvItem, BSTR parentCont);
	HRESULT PopulateContainer(HTREEITEM tvItemParent,BSTR sContName, INetObjEnumeratorPtr pQuery);
	CString m_strDomain;
	CContainerSelectionDlg(CWnd* pParent = NULL);   // standard constructor
   COLORREF GetFirstBitmapPixel(CWnd * window,UINT idbBitmap);
   HTREEITEM OpenContainer(CString strCont, HTREEITEM root);

// Dialog Data
	//{{AFX_DATA(CContainerSelectionDlg)
	enum { IDD = IDD_CONT_SELECTION };
	CButton	m_btnOK;
	CTreeCtrl	m_trOUTree;
	CString	m_strCont;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CContainerSelectionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CContainerSelectionDlg)
	afx_msg void OnOk();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkTree1(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONTAINERSELECTIONDLG_H__D8C6E4B2_0256_48FA_8B27_8B3EE88AC24E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\oupickerdoc.cpp ===
// OUPickerDoc.cpp : implementation of the COUPickerDoc class
//

#include "stdafx.h"
#include "OUPicker.h"

#include "OUPickerDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COUPickerDoc

IMPLEMENT_DYNCREATE(COUPickerDoc, CDocument)

BEGIN_MESSAGE_MAP(COUPickerDoc, CDocument)
	//{{AFX_MSG_MAP(COUPickerDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COUPickerDoc construction/destruction

COUPickerDoc::COUPickerDoc()
{
	// TODO: add one-time construction code here

}

COUPickerDoc::~COUPickerDoc()
{
}

BOOL COUPickerDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// COUPickerDoc serialization

void COUPickerDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// COUPickerDoc diagnostics

#ifdef _DEBUG
void COUPickerDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void COUPickerDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COUPickerDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__0691ACEE_9532_4F8F_9730_EA1A9D459725__INCLUDED_)
#define AFX_MAINFRM_H__0691ACEE_9532_4F8F_9730_EA1A9D459725__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnFileNew();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__0691ACEE_9532_4F8F_9730_EA1A9D459725__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\oupicker.cpp ===
// OUPicker.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "OUPicker.h"

#include "MainFrm.h"
#include "OUPickerDoc.h"
#include "OUPickerView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp

BEGIN_MESSAGE_MAP(COUPickerApp, CWinApp)
	//{{AFX_MSG_MAP(COUPickerApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp construction

COUPickerApp::COUPickerApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COUPickerApp object

COUPickerApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp initialization

BOOL COUPickerApp::InitInstance()
{
	AfxEnableControlContainer();
   CoInitialize(NULL);
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(COUPickerDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(COUPickerView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void COUPickerApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp message handlers


int COUPickerApp::ExitInstance() 
{
	// TODO: Add your specialized code here and/or call the base class
	CoUninitialize();
	return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\oupicker.h ===
// OUPicker.h : main header file for the OUPICKER application
//

#if !defined(AFX_OUPICKER_H__5C1F291C_01A6_425B_A0A7_8CED36B6E817__INCLUDED_)
#define AFX_OUPICKER_H__5C1F291C_01A6_425B_A0A7_8CED36B6E817__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COUPickerApp:
// See OUPicker.cpp for the implementation of this class
//

class COUPickerApp : public CWinApp
{
public:
	COUPickerApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COUPickerApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(COUPickerApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUPICKER_H__5C1F291C_01A6_425B_A0A7_8CED36B6E817__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\oupickerdoc.h ===
// OUPickerDoc.h : interface of the COUPickerDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OUPICKERDOC_H__8A267B0C_578D_4135_9566_E0350CC4CB0D__INCLUDED_)
#define AFX_OUPICKERDOC_H__8A267B0C_578D_4135_9566_E0350CC4CB0D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class COUPickerDoc : public CDocument
{
protected: // create from serialization only
	COUPickerDoc();
	DECLARE_DYNCREATE(COUPickerDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COUPickerDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~COUPickerDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(COUPickerDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUPICKERDOC_H__8A267B0C_578D_4135_9566_E0350CC4CB0D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\oupickerview.h ===
// OUPickerView.h : interface of the COUPickerView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_OUPICKERVIEW_H__A0B3535C_4E19_47E3_B49D_1DC89C883FD4__INCLUDED_)
#define AFX_OUPICKERVIEW_H__A0B3535C_4E19_47E3_B49D_1DC89C883FD4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class COUPickerView : public CView
{
protected: // create from serialization only
	COUPickerView();
	DECLARE_DYNCREATE(COUPickerView)

// Attributes
public:
	COUPickerDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COUPickerView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~COUPickerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(COUPickerView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in OUPickerView.cpp
inline COUPickerDoc* COUPickerView::GetDocument()
   { return (COUPickerDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUPICKERVIEW_H__A0B3535C_4E19_47E3_B49D_1DC89C883FD4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\oupickerview.cpp ===
// OUPickerView.cpp : implementation of the COUPickerView class
//

#include "stdafx.h"
#include "OUPicker.h"

#include "OUPickerDoc.h"
#include "OUPickerView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COUPickerView

IMPLEMENT_DYNCREATE(COUPickerView, CView)

BEGIN_MESSAGE_MAP(COUPickerView, CView)
	//{{AFX_MSG_MAP(COUPickerView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COUPickerView construction/destruction

COUPickerView::COUPickerView()
{
	// TODO: add construction code here

}

COUPickerView::~COUPickerView()
{
}

BOOL COUPickerView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// COUPickerView drawing

void COUPickerView::OnDraw(CDC* pDC)
{
	COUPickerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// COUPickerView printing

BOOL COUPickerView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void COUPickerView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void COUPickerView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// COUPickerView diagnostics

#ifdef _DEBUG
void COUPickerView::AssertValid() const
{
	CView::AssertValid();
}

void COUPickerView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

COUPickerDoc* COUPickerView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(COUPickerDoc)));
	return (COUPickerDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// COUPickerView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OUPicker.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_OUPICKTYPE                  129
#define IDD_CONT_SELECTION              130
#define IDB_CONT                        132
#define IDB_OU                          133
#define IDB_OPEN_CONT                   134
#define IDB_OPEN_DIR                    135
#define IDB_OPEN_OU                     136
#define IDB_DIR                         237
#define IDC_TREE1                       1000
#define IDC_EDIT1                       1001
#define IDR_OUS                         4098

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        137
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	OUPicker.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\oupicker\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__5F158273_586C_4640_A4A8_CC4132E3FBFE__INCLUDED_)
#define AFX_STDAFX_H__5F158273_586C_4640_A4A8_CC4132E3FBFE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5F158273_586C_4640_A4A8_CC4132E3FBFE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "McsPiPfl_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__7EF4A24C_413B_404E_990B_468537451850__INCLUDED_)
#define AFX_DLLDATAX_H__7EF4A24C_413B_404E_990B_468537451850__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__7EF4A24C_413B_404E_990B_468537451850__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsPiPfl.rc
//
#define IDS_PROJNAME                    100
#define IDS_PROFMMGR_DESC               101
#define IDR_ProfMMgr                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\profmmgr.h ===
// ProfMMgr.h: Definition of the CProfMMgr class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_PROFMMGR_H__A20E4BA9_0CF9_4BE9_9530_B41E844C56C2__INCLUDED_)
#define AFX_PROFMMGR_H__A20E4BA9_0CF9_4BE9_9530_B41E844C56C2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "TNode.hpp"
#include "UString.hpp"

class TFileNode : public TNode
{
   WCHAR        fileName[MAX_PATH];
public:
   TFileNode(WCHAR const * name) { safecopy(fileName,name); }

   WCHAR const * GetName() const { return fileName; }

};


class TFileList : public TNodeList
{
public:
   ~TFileList() { DeleteAllListItems(TFileNode); }
};
/////////////////////////////////////////////////////////////////////////////
// CProfMMgr

class CProfMMgr : 
	public IDispatchImpl<IMcsDomPlugIn, &IID_IMcsDomPlugIn, &LIBID_MCSPIPFLLib>, 
	public ISupportErrorInfoImpl<&IID_IMcsDomPlugIn>,
	public CComObjectRoot,
	public CComCoClass<CProfMMgr,&CLSID_ProfMMgr>,
   public ISecPlugIn
{
public:
	CProfMMgr() {}
BEGIN_COM_MAP(CProfMMgr)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMcsDomPlugIn)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
   COM_INTERFACE_ENTRY(ISecPlugIn)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CProfMMgr) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_ProfMMgr)

// IMcsDomPlugIn
public:
   STDMETHOD(GetRequiredFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetRegisterableFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetDescription)(/* [out] */ BSTR * description);
   STDMETHOD(PreMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(PostMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(GetName)(/* [out] */BSTR * name);
   STDMETHOD(GetResultString)(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text);
   STDMETHOD(StoreResults)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(ConfigureSettings)(/*[in]*/IUnknown * pVarSet);	
// ISecPlugIn
public:
   STDMETHOD(Verify)(/*[in,out]*/ULONG * data,/*[in]*/ULONG cbData);
   
protected:
   void BuildFileLists(TFileList * pRequired,TFileList * pRegisterable);
   void AddFilesToList(SAFEARRAY * pFileArray, TFileList * pList);
   
};

#endif // !defined(AFX_PROFMMGR_H__A20E4BA9_0CF9_4BE9_9530_B41E844C56C2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D28351CD_4B73_4226_8B7A_CB1B08463E45__INCLUDED_)
#define AFX_STDAFX_H__D28351CD_4B73_4226_8B7A_CB1B08463E45__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D28351CD_4B73_4226_8B7A_CB1B08463E45__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\mcspipfl.cpp ===
// McsPiPfl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsPiPfl.idl by adding the following 
//      files to the Outputs.
//          McsPiPfl_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsPiPflps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "McsPiPfl.h"
#include "dlldatax.h"

#include "McsPI_i.c"
#include "McsPiPfl_i.c"
#include "ProfMMgr.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ProfMMgr, CProfMMgr)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsPiPfl.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSPIPFLLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsPiPfl.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\csvcinf.cpp ===
// CSvcInf.cpp : Implementation of CCSvcAcctInfo
#include "stdafx.h"
#include "McsPISag.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids
#include "CSvcInf.h"
#include "ResStr.h"
#include "ErrDct.hpp"

#include <ntdsapi.h>
#include <lm.h>
#include <dsgetdc.h>

// these are needed for ISecPlugIn
#include "cipher.hpp"
#include "SecPI.h"

#define EXCHANGE_SERVICE_NAME       L"MSExchangeSA"
#define SvcAcctStatus_DoNotUpdate			   1
#define SvcAcctStatus_NeverAllowUpdate       8

TErrorDct err;
/////////////////////////////////////////////////////////////////////////////
// CCSvcAcctInfo


typedef UINT (CALLBACK* DSBINDFUNC)(TCHAR*, TCHAR*, HANDLE*);
typedef UINT (CALLBACK* DSUNBINDFUNC)(HANDLE*);
// Win2k function
typedef HRESULT (CALLBACK * DSGETDCNAME)(LPWSTR, LPWSTR, GUID*, LPWSTR, DWORD, PDOMAIN_CONTROLLER_INFO*);

typedef NTDSAPI
DWORD
WINAPI
 DSCRACKNAMES(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult);         // out

typedef NTDSAPI
void
WINAPI
 DSFREENAMERESULT(
  DS_NAME_RESULTW *pResult
);

// This method is called by the dispatcher to verify that this is a valid plug-in
// Only valid plug-ins will be sent out with the agents
// The purpose of this check is to make it more difficult for unauthorized parties 
// to use our plug-in interface, since it is currently undocumented.
STDMETHODIMP CCSvcAcctInfo::Verify(/*[in,out]*/ULONG * pData,/*[in]*/ULONG size)
{
   
   McsChallenge            * pMcsChallenge;
   long                      lTemp1;
   long                      lTemp2;

   if( size == sizeof(McsChallenge)  )
   {
      pMcsChallenge = (McsChallenge*)(pData);
      
      SimpleCipher((LPBYTE)pMcsChallenge,size);
      
      pMcsChallenge->MCS[0] = 'M';
      pMcsChallenge->MCS[1] = 'C';
      pMcsChallenge->MCS[2] = 'S';
      pMcsChallenge->MCS[3] = 0;

   
      lTemp1 = pMcsChallenge->lRand1 + pMcsChallenge->lRand2;
      lTemp2 = pMcsChallenge->lRand2 - pMcsChallenge->lRand1;
      pMcsChallenge->lRand1 = lTemp1;
      pMcsChallenge->lRand2 = lTemp2;
      pMcsChallenge->lTime += 100;

      SimpleCipher((LPBYTE)pMcsChallenge,size);
   }
   else
      return E_FAIL;


   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetRegisterableFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   SafeArrayPutElement(*pArray,ndx,SysAllocString(L"McsPISag.DLL"));
   
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetRequiredFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   SafeArrayPutElement(*pArray,ndx,SysAllocString(L"McsPISag.DLL"));

   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetDescription(/* [out] */ BSTR * description)
{
   (*description) = SysAllocString(L"");

   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::PreMigrationTask(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::PostMigrationTask(/* [in] */IUnknown * pVarSet)
{
//   DWORD                     rc = 0;
   IVarSetPtr                pVS;
   
   pVS = pVarSet;

   _bstr_t                   log = pVS->get(GET_BSTR(DCTVS_Options_Logfile));

   err.LogOpen((WCHAR*)log,1);

   err.MsgWrite(0,DCT_MSG_MCSPISAG_STARTING);

   pVS->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_Gathering_SvcAcct));

   ProcessServices(pVS);

   pVS->put(GET_BSTR(DCTVS_CurrentOperation),L"");
   
   err.MsgWrite(0,DCT_MSG_MCSPISAG_DONE);

   err.LogClose();
   return S_OK;
}


STDMETHODIMP CCSvcAcctInfo::GetName(/* [out] */BSTR * name)
{
   (*name) = SysAllocString(L"");
   
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::GetResultString(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text)
{
   WCHAR                     buffer[1000] = L"";
   IVarSetPtr                pVS;

   pVS = pVarSet;

   
   (*text) = SysAllocString(buffer);
   
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::StoreResults(/* [in] */IUnknown * pVarSet)
{
   IVarSetPtr                pVS = pVarSet;
   IIManageDBPtr             pDatabase;
   HRESULT                   hr;
   WCHAR                     key[200];
   _bstr_t                   service;
   _bstr_t                   account;
   _bstr_t                   computer;
   _bstr_t                   display;
   long                      ndx = 0;
   _bstr_t                   exchangeAccount;
   HINSTANCE                 hLibrary = NULL;
   DSCRACKNAMES            * DsCrackNames = NULL;
   DSFREENAMERESULT        * DsFreeNameResult = NULL;
   DSBINDFUNC                DsBind = NULL;
   DSUNBINDFUNC              DsUnBind = NULL;
   _bstr_t                   sourceDomainDns = pVS->get(GET_BSTR(DCTVS_Options_SourceDomainDns));
   WCHAR				   * atPtr = NULL;
   HANDLE                    hDs = NULL;
   bool						 bWin2K = false;

      //find out the OS version of this system to determine which GetDCName
      //function to use
   WKSTA_INFO_100       * pInfo = NULL;
   NET_API_STATUS		  nStatus;

   nStatus = NetWkstaGetInfo(NULL,100,(LPBYTE*)&pInfo);
   if (nStatus == NERR_Success)
   {
      if ( pInfo->wki100_ver_major > 4 )
         bWin2K = true;
      NetApiBufferFree(pInfo);
   }  

   computer = pVS->get("LocalServer");
   hr = pDatabase.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(hr) )
   {
      // make a pre-pass through the data
      do 
      {
         swprintf(key,L"ServiceAccounts.%ld.Service",ndx);
         service = pVS->get(key);
         
         swprintf(key,L"ServiceAccounts.%ld.Account",ndx);
         account = pVS->get(key);
         
         // make sure the account names are not in UPN format
         if ( NULL == wcschr((WCHAR*)account,L'\\') )
         {
			if (! hDs )
            {
               if (! hLibrary )
               {
                  hLibrary = LoadLibrary(L"NTDSAPI.DLL"); 
               }
               if ( hLibrary )
               {
                  DsBind = (DSBINDFUNC)GetProcAddress(hLibrary,"DsBindW");
                  DsUnBind = (DSUNBINDFUNC)GetProcAddress(hLibrary,"DsUnBindW");
                  DsCrackNames = (DSCRACKNAMES *)GetProcAddress(hLibrary,"DsCrackNamesW");
                  DsFreeNameResult = (DSFREENAMERESULT *)GetProcAddress(hLibrary,"DsFreeNameResultW");
               }
            
               if ( DsBind && DsUnBind && DsCrackNames && DsFreeNameResult)
               {
                  hr = (*DsBind)(NULL,(WCHAR*)sourceDomainDns,&hDs);
                  if ( hr )
                  {
                     hDs = NULL;
                  }
               }
            }
            if ( hDs )
            {
               PDS_NAME_RESULT         pNamesOut = NULL;
               WCHAR                 * pNamesIn[1];

               pNamesIn[0] = (WCHAR*)account;
               hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
			   (*DsUnBind)(&hDs);
			   hDs = NULL;
               if ( !hr )
               {
                  if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
                  {
                     account = pNamesOut->rItems[0].pName;
                     pVS->put(key,account);
                  }
					//if from another domain try connecting to that domain's DC and 
				    //retry DSCrackNames
                  else if ( pNamesOut->rItems[0].status == DS_NAME_ERROR_DOMAIN_ONLY )
				  {
					  WCHAR                     dc[MAX_PATH];
					  HRESULT					res;
					  bool						bGotDC = false;

					     //else if win2k, load and use DSGetDCName
					  if (bWin2K)
					  {
	                     PDOMAIN_CONTROLLER_INFOW  pdomc;
                            //load DSGetDCName
                         DSGETDCNAME DsGetDcName = NULL;
                         DOMAIN_CONTROLLER_INFO  * pSrcDomCtrlInfo = NULL;
   
                         HMODULE hPro = LoadLibrary(L"NetApi32.dll");
                         if ( hPro )
                            DsGetDcName = (DSGETDCNAME)GetProcAddress(hPro, "DsGetDcNameW");

                         if (DsGetDcName)   
						 {
					        res = DsGetDcName(NULL,pNamesOut->rItems[0].pDomain,NULL,NULL,DS_DIRECTORY_SERVICE_PREFERRED,&pdomc);
	                        if (res==NERR_Success)
							{
							   bGotDC = true;
						       safecopy(dc,pdomc->DomainControllerName);
						       NetApiBufferFree(pdomc);
							}
						 }
					  }//end if Win2K machine

					     //if this is an NT 4.0 or earlier machine or DSGetDCName failed, 
	                     //use NetGetDCName
					  if (!bGotDC)
					  {
	                     LPWSTR   pdomc;	
					     res = NetGetDCName(NULL,pNamesOut->rItems[0].pDomain,(LPBYTE *)&pdomc);
	                     if (res==NERR_Success)
						 {
						    safecopy(dc,pdomc);
						    NetApiBufferFree(pdomc);
						 }
					  }
	                  
					  if (res==NERR_Success)
					  {
							//bind to that domain DC
						  hr = (*DsBind)(dc,NULL,&hDs);
						  if ( !hr )
						  {
							 (*DsFreeNameResult)(pNamesOut);//release the old info
							 pNamesOut = NULL;
							   //retry DSCrackNames again
			                 hr = (*DsCrackNames)(hDs,DS_NAME_NO_FLAGS,DS_USER_PRINCIPAL_NAME,DS_NT4_ACCOUNT_NAME,1,pNamesIn,&pNamesOut);
							 if ( !hr )
							 {
								 if ( pNamesOut->rItems[0].status == DS_NAME_NO_ERROR )
								 {
									 account = pNamesOut->rItems[0].pName;
									 pVS->put(key,account);
								 }
							 }
			                 (*DsUnBind)(&hDs);
			                 hDs = NULL;
						  }
					  }
				  }
				  if (pNamesOut)
                     (*DsFreeNameResult)(pNamesOut);
               }
            }
         }
         // also, look for the exchange server service account
         if ( !UStrICmp(service,EXCHANGE_SERVICE_NAME) )
         {
            exchangeAccount = account;
            break;
         }
         ndx++;
      } while ( service.length() );

      ndx = 0;
      WCHAR                serverFilter[300];

      // clear any old entries from the table for this computer
      swprintf(serverFilter,L"System = '%ls'",(WCHAR*)computer);
	  _variant_t Filter = serverFilter;
      hr = pDatabase->raw_ClearTable(SysAllocString(L"ServiceAccounts"), Filter);
      do 
      {
         swprintf(key,L"ServiceAccounts.%ld.Service",ndx);
         service = pVS->get(key);
         swprintf(key,L"ServiceAccounts.%ld.DisplayName",ndx);
         display = pVS->get(key);
         swprintf(key,L"ServiceAccounts.%ld.Account",ndx);
         account = pVS->get(key);
         if ( service.length() && account.length() )
         {
            hr = pDatabase->raw_SetServiceAccount(computer,service,display,account);   
            if ( SUCCEEDED(hr) && !UStrICmp((WCHAR*)account,(WCHAR*)exchangeAccount) )
            {
               // mark this account to be excluded from the processing
               hr = pDatabase->raw_SetServiceAcctEntryStatus(computer,service,account,SvcAcctStatus_NeverAllowUpdate);
            }
         }
         ndx++;
      } while ( service.length() );
   }
   if ( hLibrary )
   {
      FreeLibrary(hLibrary);
   }
   return S_OK;
}

STDMETHODIMP CCSvcAcctInfo::ConfigureSettings(/*[in]*/IUnknown * pVarSet)
{
   IVarSetPtr                pVS = pVarSet;

   MessageBox(NULL,L"This is a test",L"McsPISag PlugIn",MB_OK);

   return S_OK;
}

void CCSvcAcctInfo::ProcessServices(IVarSet * pVarSet)
{
   // Connect to the SCM on the local computer
   SC_HANDLE                 pScm = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS );
   DWORD                     rc = 0;
   WCHAR                     domain[200];
   WKSTA_INFO_100          * info;

   // Get the name of the domain that this computer is in, so we can resolve any accounts that are
   // specified as .\Account to DOMAIN\account format

   rc = NetWkstaGetInfo(NULL,100,(BYTE**)&info);
   if ( ! rc )
   {
      UStrCpy(domain,info->wki100_langroup);
      NetApiBufferFree(info);
   }
   else
   {
      // if we can't get the domain name, just leave the .
      UStrCpy(domain,L".");
   }
   if ( pScm )
   {
      // Enumerate the services on the computer
      ENUM_SERVICE_STATUS    servStatus[1000];
      DWORD                  cbBufSize = (sizeof servStatus);
      DWORD                  cbBytesNeeded = 0;
      DWORD                  nReturned = 0;
      DWORD                  hResume = 0;
      WCHAR                  string[1000];
      long                   count = 0;

      if (! EnumServicesStatus(pScm,SERVICE_WIN32,SERVICE_STATE_ALL,servStatus,cbBufSize,&cbBytesNeeded,&nReturned,&hResume) )
      {
         rc = GetLastError();
         err.SysMsgWrite(ErrE,rc,DCT_MSG_SERVICE_ENUM_FAILED_D,rc);
      }
      else
      {
         rc = 0;
      }
      
      if ( rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA )
      {

         for ( UINT i = 0 ; i < nReturned ; i++ )
         {
            SC_HANDLE               pService = OpenService(pScm,servStatus[i].lpServiceName,SERVICE_ALL_ACCESS );
            BYTE                    buf[3000];
            QUERY_SERVICE_CONFIG  * pConfig = (QUERY_SERVICE_CONFIG *)buf; 
//            BOOL                    bIncluded = FALSE;
            DWORD                   lenNeeded = 0;

            
            if ( pService )
            {
               // get the information about this service
               if ( QueryServiceConfig(pService,pConfig,sizeof buf, &lenNeeded) )
               {
                  err.MsgWrite(0,DCT_MSG_SERVICE_USES_ACCOUNT_SS,servStatus[i].lpServiceName,pConfig->lpServiceStartName);
                  // add the account to the list if it is not using LocalSystem
                  if ( UStrICmp(pConfig->lpServiceStartName,L"LocalSystem"))
                  {   
                     swprintf(string,L"ServiceAccounts.%ld.Service",count);
                     pVarSet->put(string,servStatus[i].lpServiceName);
                     swprintf(string,L"ServiceAccounts.%ld.DisplayName",count);
                     pVarSet->put(string,servStatus[i].lpDisplayName);
                     swprintf(string,L"ServiceAccounts.%ld.Account",count);
                     if ( pConfig->lpServiceStartName[0] == L'.' && pConfig->lpServiceStartName[1] == L'\\' )
                     {
                        WCHAR          domAcct[500];
                        
                        // set domAcct to DOMAIN + \Account 
                        UStrCpy(domAcct,domain);
                        UStrCpy(domAcct+UStrLen(domAcct),pConfig->lpServiceStartName + 1 );
         
                        pVarSet->put(string,domAcct);
         
                     }
                     else
                     {
                        pVarSet->put(string,pConfig->lpServiceStartName);
                     }
                     count++;
                  }

               }
               CloseServiceHandle(pService);               
            }
            else
            {
               err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_OPEN_SERVICE_FAILED_SD,servStatus[i].lpServiceName,rc);
            }
         }
      }
      CloseServiceHandle(pScm);
   }
   else
   {
      rc = GetLastError();   
      err.SysMsgWrite(ErrE,rc,DCT_MSG_SCM_OPEN_FAILED_D,rc);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspipfl\profmmgr.cpp ===
// ProfMMgr.cpp : Implementation of CMcsPiPflApp and DLL registration.

#include "stdafx.h"
#include "McsPiPfl.h"
#include "ProfMMgr.h"

#include "ErrDct.hpp"
#include "TReg.hpp"
#include "ResStr.h"
#include "EaLen.hpp"

#include "cipher.hpp"
#include "SecPI.h"

TErrorDct                    err;
TError                     & errCommon = err;
StringLoader                 gString;

// This method is called by the dispatcher to verify that this is a valid plug-in
// Only valid plug-ins will be sent out with the agents
// The purpose of this check is to make it more difficult for unauthorized parties 
// to use our plug-in interface, since it is currently undocumented.
STDMETHODIMP CProfMMgr::Verify(/*[in,out]*/ULONG * pData,/*[in]*/ULONG size)
{
   
   McsChallenge            * pMcsChallenge;
   long                      lTemp1;
   long                      lTemp2;

   if( size == sizeof(McsChallenge)  )
   {
      pMcsChallenge = (McsChallenge*)(pData);
      
      SimpleCipher((LPBYTE)pMcsChallenge,size);
      
      pMcsChallenge->MCS[0] = 'M';
      pMcsChallenge->MCS[1] = 'C';
      pMcsChallenge->MCS[2] = 'S';
      pMcsChallenge->MCS[3] = 0;

   
      lTemp1 = pMcsChallenge->lRand1 + pMcsChallenge->lRand2;
      lTemp2 = pMcsChallenge->lRand2 - pMcsChallenge->lRand1;
      pMcsChallenge->lRand1 = lTemp1;
      pMcsChallenge->lRand2 = lTemp2;
      pMcsChallenge->lTime += 100;

      SimpleCipher((LPBYTE)pMcsChallenge,size);
   }
   else
      return E_FAIL;


   return S_OK;
}


STDMETHODIMP CProfMMgr::GetRegisterableFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };
   TNodeListEnum             e;
   TFileList                 list;
   TFileNode               * pNode;
   LONG                      i;

   BuildFileLists(NULL,&list);
   bound[0].cElements = list.Count();

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   for (i = 0, pNode=(TFileNode*)e.OpenFirst(&list) ; pNode ; i++, pNode=(TFileNode*)e.Next() )
   {
      ndx[0] = i;
      SafeArrayPutElement(*pArray,ndx,SysAllocString(pNode->GetName()));
   }
   e.Close();
   
   return S_OK;
}

STDMETHODIMP CProfMMgr::GetRequiredFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };
   TNodeListEnum             e;
   TFileList                 list;
   TFileNode               * pNode;
   LONG                      i;

   BuildFileLists(&list,NULL);
   bound[0].cElements = list.Count();

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   for (i = 0, pNode=(TFileNode*)e.OpenFirst(&list) ; pNode ; i++, pNode=(TFileNode*)e.Next() )
   {
      ndx[0] = i;
      SafeArrayPutElement(*pArray,ndx,SysAllocString(pNode->GetName()));
   }
   e.Close();
   
   return S_OK;
}

STDMETHODIMP CProfMMgr::GetDescription(/* [out] */ BSTR * description)
{
   (*description) = SysAllocString(L"");

   return S_OK;
}

STDMETHODIMP CProfMMgr::PreMigrationTask(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CProfMMgr::PostMigrationTask(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}


STDMETHODIMP CProfMMgr::GetName(/* [out] */BSTR * name)
{
   (*name) = SysAllocString(L"");
   
   return S_OK;
}

STDMETHODIMP CProfMMgr::GetResultString(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text)
{
   (*text) = SysAllocString(L"");
   
   return S_OK;
}

STDMETHODIMP CProfMMgr::StoreResults(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CProfMMgr::ConfigureSettings(/*[in]*/IUnknown * pVarSet)
{
   return S_OK;
}


void CProfMMgr::BuildFileLists(TFileList * pRequired,TFileList * pRegisterable)
{
   // Enumerate the profile extensions defined in the registry
   TRegKey                   profExt;
   DWORD                     rc;
   WCHAR                     subkey[LEN_Path];
   CLSID                     clsid;

   rc = profExt.Open(GET_STRING(IDS_REGKEY_PROFILE_EXTENSIONS));

   if ( ! rc )
   {
      for ( int i = 0 ; ! rc ; i++ )
      {
         rc = profExt.SubKeyEnum(i,subkey,DIM(subkey));
         if (! rc )
         {
            HRESULT          hr = CLSIDFromString(subkey,&clsid);
            IMcsDomPlugIn  * pExt = NULL;
            SAFEARRAY      * pArray = NULL;

            if ( SUCCEEDED(hr) )
            {
               hr = CoCreateInstance(clsid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pExt);
               if ( SUCCEEDED(hr) )
               {
                  
                  if ( pRequired )
                  {
                     hr = pExt->GetRequiredFiles(&pArray);
                     if ( SUCCEEDED(hr) )
                     {
                        AddFilesToList(pArray,pRequired);
                        SafeArrayDestroy(pArray);
                     }
                  }
                  if ( pRegisterable )
                  {
                     hr = pExt->GetRegisterableFiles(&pArray);
                     if (SUCCEEDED(hr) )
                     {
                        AddFilesToList(pArray,pRegisterable);
                        SafeArrayDestroy(pArray);
                     }
                  }
                  pExt->Release();
               }
            }
         }
      }
   }
}

void CProfMMgr::AddFilesToList(SAFEARRAY * pFileArray, TFileList * pList)
{
   LONG                      bound = 0;
   LONG                      ndx[1];
   TFileNode               * pNode = NULL;

   SafeArrayGetUBound(pFileArray,1,&bound);

   for ( ndx[0] = 0 ; ndx[0] <= bound ; ndx[0]++ )
   {
      BSTR           val = NULL;

      SafeArrayGetElement(pFileArray,ndx,&val);
      pNode = new TFileNode(val);
      pList->InsertBottom(pNode);
      SysFreeString(val);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "McsPISag_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\csvcinf.h ===
// CSvcInf.h : Declaration of the CCSvcAcctInfo

#ifndef __CSVCACCTINFO_H_
#define __CSVCACCTINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CCSvcAcctInfo
class ATL_NO_VTABLE CCSvcAcctInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CCSvcAcctInfo, &CLSID_CSvcAcctInfo>,
	public IDispatchImpl<IMcsDomPlugIn, &IID_IMcsDomPlugIn, &LIBID_MCSPISAGLib>,
   public ISecPlugIn
{
public:
	CCSvcAcctInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CSVCACCTINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CCSvcAcctInfo)
	COM_INTERFACE_ENTRY(IMcsDomPlugIn)
   COM_INTERFACE_ENTRY(ISecPlugIn)
END_COM_MAP()

// IMcsDomPlugIn
public:
   STDMETHOD(GetRequiredFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetRegisterableFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetDescription)(/* [out] */ BSTR * description);
   STDMETHOD(PreMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(PostMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(GetName)(/* [out] */BSTR * name);
   STDMETHOD(GetResultString)(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text);
   STDMETHOD(StoreResults)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(ConfigureSettings)(/*[in]*/IUnknown * pVarSet);	

   // ISecPlugIn
public:
   STDMETHOD(Verify)(/*[in,out]*/ULONG * data,/*[in]*/ULONG cbData);
   
protected:
   // Helper functions
   void ProcessServices(IVarSet * pVarSet);

};

#endif //__CSVCACCTINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__34934D09_461D_11D3_99F3_0010A4F77383__INCLUDED_)
#define AFX_DLLDATAX_H__34934D09_461D_11D3_99F3_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__34934D09_461D_11D3_99F3_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\mcspisag.cpp ===
// McsPISag.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for McsPISag.idl by adding the following 
//      files to the Outputs.
//          McsPISag_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsPISagps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "McsPISag.h"
#include "dlldatax.h"

#include "McsPI_i.c"
#include "McsPISag_i.c"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

#include "CSvcInf.h"
#include "ResStr.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CSvcAcctInfo, CCSvcAcctInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

StringLoader gString;

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsPISag.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSPISAGLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsPISag.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by McsPISag.rc
//
#define IDS_PROJNAME                    100
#define IDR_CSVCACCTINFO                101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TrustMgr.rc
//
#define IDS_PROJNAME                    100
#define IDS_TRUST_DESC                  101
#define IDR_Trust                       102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__52BFB1C6_A22F_4786_9752_A130DC59ABB4__INCLUDED_)
#define AFX_DLLDATAX_H__52BFB1C6_A22F_4786_9752_A130DC59ABB4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__52BFB1C6_A22F_4786_9752_A130DC59ABB4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\mcspisag\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__34934D01_461D_11D3_99F3_0010A4F77383__INCLUDED_)
#define AFX_STDAFX_H__34934D01_461D_11D3_99F3_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__34934D01_461D_11D3_99F3_0010A4F77383__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\common.cpp ===
//#pragma title( "Common.cpp - Common class implementations" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common class implementations.
Updates     -  1997-09-09 RED ErrorCodeToText moved to Err.cpp
            -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"

///////////////////////////////////////////////////////////////////////////////
// TTime class member functions
///////////////////////////////////////////////////////////////////////////////

   TTime                     gTTime;       // global instance of TTime

time_t                                     // ret-current time
   TTime::Now(
      time_t               * pTime         // out-optional current time
   )  const
{
   time_t                    tTime;        // work copy of current time

   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   tTime = ConvertFiletimeToTimet( wTime.intTime );

   if ( pTime ) *pTime = tTime;
   return tTime;
}

__int64                                    // ret-current time
   TTime::NowAsFiletime(
      __int64              * pTime         // out-optional current time
   )  const
{
   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   if ( pTime ) *pTime = wTime.intTime;
   return wTime.intTime;
}

time_t                                     // ret-time_t representation
   TTime::ConvertFiletimeToTimet(
      __int64                fileTime      // in -filetime representation
   )  const
{
   __int64                   wTime;        // intermediate work area
   time_t                    retTime;      // returned time

   // If the source date/time is less than the minimum date/time supported
   // by time_t, then zero is returned.
   // If the source date/time is more that the maximum date/time supported
   // by time_t, then ULONG_MAX is returned.

   wTime = fileTime / 10000000;

   if ( wTime < 11644473600 )
   {
      retTime = 0;
   }
   else
   {
      wTime -= 11644473600;
      if ( wTime > ULONG_MAX )
      {
         retTime = ULONG_MAX;
      }
      else
      {
         retTime = (time_t) wTime;
      }
   }

   return retTime;
}


WCHAR *                                     // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoUtc(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   tmTime = gmtime( &tTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

WCHAR *                                    // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoLcl(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   TIME_ZONE_INFORMATION     infoTime;     // WIN32 time zone info
   time_t                    wTime;        // workarea
   switch ( GetTimeZoneInformation( &infoTime ) )
   {
      case TIME_ZONE_ID_STANDARD:
         wTime = infoTime.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         wTime = infoTime.DaylightBias;
         break;
      default:
         wTime = 0;
         break;
   }
   wTime = (infoTime.Bias + wTime) * 60;
   wTime = tTime - wTime;
   if ( wTime < 0 )
   {
      wTime = 0;
   }
   tmTime = gmtime( &wTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) plus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   )
{
   memset( pTimeZoneInfo, 0, sizeof *pTimeZoneInfo );
   BOOL                      retval=TRUE;  // returned value
   DWORD                     OsRc;         // OS return code
   TIME_ZONE_INFORMATION     TimeZoneInfo; // WIN32 time zone info

   OsRc = GetTimeZoneInformation( &TimeZoneInfo );
   switch ( OsRc )
   {
      case TIME_ZONE_ID_STANDARD:
         pTimeZoneInfo->dst = TimeZoneInfo.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         pTimeZoneInfo->dst = TimeZoneInfo.DaylightBias;
         break;
      case TIME_ZONE_ID_UNKNOWN:
         retval = TimeZoneInfo.Bias;
         break;
      default:
         retval = FALSE;
         break;
   }
   if ( retval )
   {
      pTimeZoneInfo->bias = TimeZoneInfo.Bias * 60;
      pTimeZoneInfo->dst *= 60;
      pTimeZoneInfo->biasdst = pTimeZoneInfo->bias + pTimeZoneInfo->dst;
   }
   return retval;
}

// Common.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "TrustMgr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\common.hpp ===
//#pragma title( "Common.hpp - Common classes of general utility" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common classes of general utility.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Common_hpp
#define  MCSINC_Common_hpp

// Start of header file dependencies

#ifndef _INC_LIMITS
#include <limits.h>
#endif

#ifndef  _INC_STDIO
#include <stdio.h>
#endif

#ifndef _INC_TIME
#include <time.h>
#endif

#ifndef MCSINC_Mcs_h
#include "Mcs.h"
#endif

// End of header file dependencies

#define SECS(n) (n * 1000)
#define DIM(array) (sizeof (array) / sizeof (array[0]))
#ifdef  UNICODE
   typedef  unsigned short  UTCHAR;
   #define  UTEXT(quote)  ((unsigned short *) (L##quote))
#else
   typedef  unsigned char  UTCHAR;
   #define  UTEXT(quote)  ((unsigned char *) (quote))
#endif  // UNICODE

#define  UnNull(ptr)  ( (ptr) ? (ptr) : (UCHAR *) "" )

#define  DAYSECS  (24*60*60)

class TTime
{
private:
protected:
public:
   time_t Now(                             // ret-current time
      time_t               * pTime         // out-optional current time
   )  const;
#ifndef  WIN16_VERSION
   __int64 NowAsFiletime(                  // ret-current time
      __int64              * pTime         // out-optional current time
   )  const;
   time_t ConvertFiletimeToTimet(          // ret-time_t representation
      __int64                fileTime      // in -filetime representation
   )  const;
#endif  // WIN16_VERSION
   WCHAR * FormatIsoUtc(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
   WCHAR * FormatIsoLcl(                    // ret-YYYY-MM-DD HH:MM:SS string
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const;
};

extern
   TTime                     gTTime;       // global instance of TTime

#ifndef  WIN16_VERSION
__int64                                    // ret-numeric value of string
   TextToInt64(
      TCHAR          const * str          ,// in-string value to parse
      __int64                minVal       ,// in -min allowed value for result
      __int64                maxVal       ,// in -max allowed value for result
      char          const ** errMsg        // out-error message pointer or NULL
   );
#endif  // WIN16_VERSION

typedef  struct  EaTimeZoneInfo
{  // all values are in seconds
   long                      bias;         // time zone bias
   long                      dst;          // daylight savings time bias
   long                      biasdst;      // time zone bias including possible DST
}  EaTimeZoneInfo;

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) minus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   );

#endif  // MCSINC_Common_hpp

// Common.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__94D89238_AFE4_4CDA_AFE4_0F411D17E9E9__INCLUDED_)
#define AFX_STDAFX_H__94D89238_AFE4_4CDA_AFE4_0F411D17E9E9__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__94D89238_AFE4_4CDA_AFE4_0F411D17E9E9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\errdct.hpp ===
#ifndef __ERRDCT_HPP__
#define __ERRDCT_HPP__
/*---------------------------------------------------------------------------
  File: ErrDct.hpp

  Comments: TError derived class that specifies a numeric code for each message 
  format.  The goal is to make it easy to convert this to a real message file 
  later.

  This class also improves on the behavior of the TError class by returning text
  for HRESULT error codes.
  

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 03/26/99 13:04:51

 ---------------------------------------------------------------------------
*/
#include "Err.hpp"
#include "Common.hpp"
#include "UString.hpp"    
#include "McsDmMsg.h"

// These codes are passed as the messageNumber argument to MsgWrite and SysMsgWrite.


// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   );

class TErrorDct : public TError
{
public:
   TErrorDct(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
      ) : TError(displevel,loglevel,NULL,logmode,beeplevel)
   {}
   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );   

   WCHAR const * LookupMessage(UINT msgNumber);

   virtual void __cdecl
   SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   );

   virtual void __cdecl
   MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   );

   void __cdecl
      DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      );

   virtual BOOL         LogOpen(
      WCHAR          const * fileName     ,// in -name of file including any path
      int                    mode = 0     ,// in -0=overwrite, 1=append
      int                    level = 0     // in -minimum level to log
   )
   {
      WCHAR                  directory[MAX_PATH];

      safecopy(directory,fileName);

      WCHAR                * x = wcsrchr(directory,'\\');
      
      if ( x )
      {
         (*x) = 0;
         DirectoryCreateR(directory);
      }
      
      return TError::LogOpen(fileName,mode,level);
   }

};

#endif //__ERRDCT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\trust.h ===
// Trust.h: Definition of the CTrust class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_TRUST_H__BB315DAC_1A59_4EAC_99A0_2BFEFE6F1501__INCLUDED_)
#define AFX_TRUST_H__BB315DAC_1A59_4EAC_99A0_2BFEFE6F1501__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CTrust
#include "ErrDct.hpp"

typedef void (*PPROCESSFN)(void * arg,void * data);

class CTrust : 
	public ITrust,
	public CComObjectRoot,
   public IDispatchImpl<IMcsDomPlugIn, &IID_IMcsDomPlugIn, &LIBID_TRUSTMGRLib>,
	public CComCoClass<CTrust,&CLSID_Trust>,
   public ISecPlugIn
{
public:
	CTrust() {}
BEGIN_COM_MAP(CTrust)
	COM_INTERFACE_ENTRY(ITrust)
   COM_INTERFACE_ENTRY(IMcsDomPlugIn)
   COM_INTERFACE_ENTRY(ISecPlugIn)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CTrust) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_Trust)

// ITrust
public:
	STDMETHOD(CreateTrust)(BSTR domTrusting, BSTR domTrusted, BOOL bBidirectional);
	STDMETHOD(QueryTrust)(BSTR domainSource, BSTR domainTrust, /*[out]*/IUnknown ** pVarSet);
   STDMETHOD(QueryTrusts)(BSTR domainSource,BSTR domainTarget,/*[in]*/BSTR sLogFile,/*out*/IUnknown ** pVarSet);
   STDMETHOD(CreateTrustWithCreds)(BSTR domTrusting, BSTR domTrusted,
                     BSTR credTrustingDomain, BSTR credTrustingAccount, BSTR credTrustingPassword,
                     BSTR credTrustedDomain, BSTR credTrustedAccount, BSTR credTrustedPassword, BOOL bBidirectional);


   // IMcsDomPlugIn
public:
   STDMETHOD(GetRequiredFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetRegisterableFiles)(/* [out] */SAFEARRAY ** pArray);
   STDMETHOD(GetDescription)(/* [out] */ BSTR * description);
   STDMETHOD(PreMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(PostMigrationTask)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(GetName)(/* [out] */BSTR * name);
   STDMETHOD(GetResultString)(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text);
   STDMETHOD(StoreResults)(/* [in] */IUnknown * pVarSet);
   STDMETHOD(ConfigureSettings)(/*[in]*/IUnknown * pVarSet);	
// ISecPlugIn
public:
   STDMETHOD(Verify)(/*[in,out]*/ULONG * data,/*[in]*/ULONG cbData);
protected:
   long EnumerateTrustingDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet,long ndxStart);
   long EnumerateTrustedDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet, long ndxStart);
   LONG FindInboundTrust(IVarSet * pVarSet,WCHAR * sName,LONG max);

   HRESULT 
   CTrust::CheckAndCreate(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * credDomainTrusting,
      WCHAR                * credAccountTrusting,
      WCHAR                * credPasswordTrusting,
      WCHAR                * credDomainTrusted,
      WCHAR                * credAccountTrusted,
      WCHAR                * credPasswordTrusted,
      BOOL                   bCreate,
      BOOL                   bBidirectional
   );

   HRESULT 
   CTrust::CheckAndCreateTrustingSide(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustedDNSName,
      BYTE                 * trustedSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional

   );
   HRESULT 
   CTrust::CheckAndCreateTrustedSide(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustingDNSName,
      BYTE                 * trustingSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional
   );

   
};

#endif // !defined(AFX_TRUST_H__BB315DAC_1A59_4EAC_99A0_2BFEFE6F1501__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\err.hpp ===
//#pragma title( "Err.hpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifndef  MCSINC_Err_hpp
#define  MCSINC_Err_hpp

// Start of header file dependencies

#ifndef  MCSINC_Common_hpp
#include "Common.hpp"
#endif

// End of header file dependencies

// ErrMsg error level constants
#define ErrT            (      - __LINE__) // Testing
#define ErrI            (00000 + __LINE__) // Information
#define ErrW            (10000 + __LINE__) // Warning
#define ErrE            (20000 + __LINE__) // Error
#define ErrS            (30000 + __LINE__) // Severe error
#define ErrV            (40000 + __LINE__) // Very sever error
#define ErrU            (50000 + __LINE__) // Unrecoverable error
#define ErrX            (60000 + __LINE__) // extremely unrecoverable <g>

#define ErrNone         (0)

class TError
{
protected:
   int                       level;
   int                       lastError;
   int                       maxError;
   int                       logLevel;     // minimum level to log
   int                       dispLevel;    // minimum level to display
   FILE                    * logFile;
   int                       beepLevel;
public:
                        TError(
      int                    displevel = 0,// in -mimimum severity level to display
      int                    loglevel = 0 ,// in -mimimum severity level to log
      WCHAR          const * filename = L"",// in -file name of log (NULL if none)
      int                    logmode = 0  ,// in -0=replace, 1=append
      int                    beeplevel = 100 // in -min error level for beeping
                                             //     Some people dont like the beeps so we turned it off by default.

                        );
                        ~TError();

   void __cdecl         MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   );
#ifndef WIN16_VERSION

   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
   void __cdecl         SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   );
#endif

   void __stdcall       MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   );

   virtual void __stdcall StrWrite(int level, WCHAR const * str) const { wprintf(L"%ls\n", str); };

   virtual BOOL         LogOpen(
      WCHAR          const * fileName     ,// in -name of file including any path
      int                    mode = 0     ,// in -0=overwrite, 1=append
      int                    level = 0     // in -minimum level to log
   );
   virtual void         LogClose() { if ( logFile ) fclose(logFile); };
   virtual void         LogWrite(WCHAR const * msg);
   void                 LevelSet(int displevel=0, int loglevel=-1, int beeplevel=2)
                           { dispLevel = displevel; logLevel = loglevel; beepLevel = beeplevel; };
   void                 LevelDispSet(int  displevel=0)
                           { dispLevel = displevel; };
   void                 LevelLogSet(int  loglevel=-1)
                           { logLevel = loglevel; };
   void                 LevelBeepSet(int  beeplevel=-1)
                           { beepLevel = beeplevel; };
   DWORD                MaxError()  const { return maxError; };
   DWORD                LastError() const { return lastError; };

   int                  GetMaxSeverityLevel () { return maxError / 10000; }

   virtual WCHAR * ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   );
};

extern TError              & errCommon;

#endif  // MCSINC_Err_hpp

// Err.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\trust.cpp ===
// Trust.cpp : Implementation of CTrustMgrApp and DLL registration.

#include "stdafx.h"
//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#include "TrustMgr.h"
#include "Trust.h"
#include "Common.hpp"
#include "UString.hpp"
#include "ResStr.h"
#include "ErrDct.hpp"
#include "EaLen.hpp"
#include "LSAUtils.h"

#include <lm.h>
#include <dsgetdc.h>
#include <iads.h>
#include <adshlp.h>
#include "ntsecapi.h"

#include "SecPI.h"
#include "cipher.hpp"

#ifndef TRUST_ATTRIBUTE_FOREST_TRANSITIVE
#define TRUST_ATTRIBUTE_FOREST_TRANSITIVE  0x00000008  // This link may contain forest trust information
#endif

StringLoader gString;
TErrorDct    err;

// This method is called by the dispatcher to verify that this is a valid plug-in
// Only valid plug-ins will be sent out with the agents
// The purpose of this check is to make it more difficult for unauthorized parties 
// to use our plug-in interface, since it is currently undocumented.
STDMETHODIMP CTrust::Verify(/*[in,out]*/ULONG * pData,/*[in]*/ULONG size)
{
   
   McsChallenge            * pMcsChallenge;
   long                      lTemp1;
   long                      lTemp2;

   if( size == sizeof(McsChallenge)  )
   {
      pMcsChallenge = (McsChallenge*)(pData);
      
      SimpleCipher((LPBYTE)pMcsChallenge,size);
      
      pMcsChallenge->MCS[0] = 'M';
      pMcsChallenge->MCS[1] = 'C';
      pMcsChallenge->MCS[2] = 'S';
      pMcsChallenge->MCS[3] = 0;

   
      lTemp1 = pMcsChallenge->lRand1 + pMcsChallenge->lRand2;
      lTemp2 = pMcsChallenge->lRand2 - pMcsChallenge->lRand1;
      pMcsChallenge->lRand1 = lTemp1;
      pMcsChallenge->lRand2 = lTemp2;
      pMcsChallenge->lTime += 100;

      SimpleCipher((LPBYTE)pMcsChallenge,size);
   }
   else
      return E_FAIL;


   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP CTrust::QueryTrust(BSTR domTrusting, BSTR domTrusted, IUnknown **pVarSet)
{
   HRESULT                   hr = S_OK;

   return hr;
}

STDMETHODIMP CTrust::CreateTrust(BSTR domTrusting, BSTR domTrusted, BOOL bBidirectional)
{
   HRESULT                  hr = S_OK;
   
   hr = CheckAndCreate(domTrusting,domTrusted,NULL,NULL,NULL,NULL,NULL,NULL,TRUE,bBidirectional);
   
   return HRESULT_FROM_WIN32(hr);
}

STDMETHODIMP 
   CTrust::CreateTrustWithCreds(
      BSTR                   domTrusting,
      BSTR                   domTrusted,
      BSTR                   credTrustingDomain, 
      BSTR                   credTrustingAccount, 
      BSTR                   credTrustingPassword,
      BSTR                   credTrustedDomain, 
      BSTR                   credTrustedAccount, 
      BSTR                   credTrustedPassword,
      BOOL                   bBidirectional
   )
{
   HRESULT                   hr = S_OK;
   
   hr = CheckAndCreate(domTrusting,domTrusted,credTrustingDomain,credTrustingAccount,credTrustingPassword,
                        credTrustedDomain,credTrustedAccount,credTrustedPassword,TRUE,bBidirectional);
   return hr;
}


STDMETHODIMP CTrust::GetRegisterableFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 0, 0 };
  
   // this plug-in runs locally, no files to distribute
   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   return S_OK;
}

STDMETHODIMP CTrust::GetRequiredFiles(/* [out] */SAFEARRAY ** pArray)
{
   SAFEARRAYBOUND            bound[1] = { 0, 0 };
   
   // this plug-in runs locally, no files to distribute
   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   return S_OK;
}

STDMETHODIMP CTrust::GetDescription(/* [out] */ BSTR * description)
{
   (*description) = SysAllocString(L"Sets up needed trusts between domains.");

   return S_OK;
}


BOOL IsDownLevel(WCHAR  * sComputer)
{
   BOOL                      bDownlevel = TRUE;
   WKSTA_INFO_100          * pInfo;
   
   long rc = NetWkstaGetInfo(sComputer,100,(LPBYTE*)&pInfo);
	if ( ! rc )
	{
      if ( pInfo->wki100_ver_major >= 5 )
      {
         bDownlevel = FALSE;
      }
      NetApiBufferFree(pInfo);
	}  
   return bDownlevel;
}

// Helper function that finds a trusts in our varset list
LONG CTrust::FindInboundTrust(IVarSet * pVarSet,WCHAR * sName,LONG max)
{
   LONG              ndx = -1;
   LONG              curr = 0;
   WCHAR             key[100];
   _bstr_t           tName;

   for ( curr = 0 ; curr < max ; curr++ ) 
   {
      swprintf(key,L"Trusts.%ld",curr);
      tName = pVarSet->get(key);

      if ( ! UStrICmp(tName,sName) )
      {
         // found it!
         ndx = curr;
         break;
      }
   } 
   
   return ndx;
}

HRESULT 
   CTrust::CheckAndCreateTrustingSide(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustedDNSName,
      BYTE                 * trustedSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional
   )
{
   DWORD                     rc = S_OK;
   
   // if credentials are specified, use them
 
   LSA_HANDLE                hTrusting = NULL;
   NTSTATUS                  status;
   LSA_AUTH_INFORMATION      curr;
   LSA_AUTH_INFORMATION      prev;
   WCHAR                     password[] = L"password";
   

   if ( ! rc && bCreate )
   {
      status = OpenPolicy(trustingComp,POLICY_VIEW_LOCAL_INFORMATION 
                                          | POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET,&hTrusting);
      rc = LsaNtStatusToWinError(status);
      

      if ( ! rc )
      {
         // set up the auth information for the trust relationship
         curr.AuthInfo = (LPBYTE)password;
         curr.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
         curr.AuthType = TRUST_AUTH_TYPE_CLEAR;
         curr.LastUpdateTime.QuadPart = 0;

         prev.AuthInfo = (LPBYTE)password;
         prev.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
         prev.AuthType = TRUST_AUTH_TYPE_CLEAR;
         prev.LastUpdateTime.QuadPart = 0;
    
         // set up the trusting side of the relationship
         if ( IsDownLevel(trustingComp) )
         {
            TRUSTED_DOMAIN_NAME_INFO               nameInfo;
      
            InitLsaString(&nameInfo.Name,const_cast<WCHAR*>(trustedDomain));
      
            status = LsaSetTrustedDomainInformation(hTrusting,trustedSid,TrustedDomainNameInformation,&nameInfo);
            rc = LsaNtStatusToWinError(status);
            if ( ! rc || rc == ERROR_ALREADY_EXISTS )
            {
               // set the password for the new trust
               TRUSTED_PASSWORD_INFO     pwdInfo;

               InitLsaString(&pwdInfo.Password,password);
               InitLsaString(&pwdInfo.OldPassword,NULL);

               status = LsaSetTrustedDomainInformation(hTrusting,trustedSid,TrustedPasswordInformation,&pwdInfo);
               rc = LsaNtStatusToWinError(status);
            }

         }
         else
         {
            
           // for Win2K domain, use LsaCreateTrustedDomainEx
            // to create the trustedDomain object.
            LSA_UNICODE_STRING                  sTemp;
            TRUSTED_DOMAIN_INFORMATION_EX       trustedInfo;
            TRUSTED_DOMAIN_AUTH_INFORMATION     trustAuth;
   
            InitLsaString(&sTemp, const_cast<WCHAR*>(trustedDomain));
            trustedInfo.FlatName = sTemp;

            InitLsaString(&sTemp, trustedDNSName);
            trustedInfo.Name = sTemp;

            trustedInfo.Sid = trustedSid;

            if ( IsDownLevel(trustedComp) )
            {
               trustedInfo.TrustAttributes = TRUST_TYPE_DOWNLEVEL;
            }
            else
            {
               trustedInfo.TrustAttributes = 0;
            }
   
            if ( bBidirectional )
               trustedInfo.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
            else
               trustedInfo.TrustDirection = TRUST_DIRECTION_OUTBOUND;
   
            trustedInfo.TrustType = TRUST_ATTRIBUTE_NON_TRANSITIVE;

            trustAuth.IncomingAuthInfos = bBidirectional ? 1 : 0;
            trustAuth.OutgoingAuthInfos = 1;
            trustAuth.IncomingAuthenticationInformation = bBidirectional ? &curr : NULL;
            trustAuth.IncomingPreviousAuthenticationInformation = NULL;
            trustAuth.OutgoingAuthenticationInformation = &curr;
            trustAuth.OutgoingPreviousAuthenticationInformation = NULL;

            LSA_HANDLE           hTemp = NULL;
   
            status = LsaCreateTrustedDomainEx( hTrusting, &trustedInfo, &trustAuth, 0, &hTemp );
            rc = LsaNtStatusToWinError(status);

            // if the trust already exists, update its password
            if ( status == STATUS_OBJECT_NAME_COLLISION )
            {
               TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;
               
               status = LsaQueryTrustedDomainInfo(hTrusting,trustedSid,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
               if ( ! status )
               {
                  pTrustedInfo->TrustDirection |= trustedInfo.TrustDirection;
                  status = LsaSetTrustedDomainInfoByName(hTrusting,&trustedInfo.Name,TrustedDomainInformationEx,(LPVOID*)pTrustedInfo);
                  
                  if ( ! status )
                  {
                     status = LsaSetTrustedDomainInfoByName(hTrusting,&trustedInfo.Name,TrustedDomainAuthInformation,(LPVOID*)&trustAuth);
                  }
               }
               rc = LsaNtStatusToWinError(status);
            
            }
            if( ! rc )
            {
			   if (hTemp)
                  LsaClose(hTemp);
            }
         }
      }
   }
   if ( hTrusting )
      LsaClose(hTrusting);
   
   return rc;
}

HRESULT 
   CTrust::CheckAndCreateTrustedSide(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * trustingComp,
      WCHAR                * trustedComp,
      WCHAR                * trustingDNSName,
      BYTE                 * trustingSid,
      BOOL                   bCreate,
      BOOL                   bBidirectional
   )
{
   DWORD                     rc = S_OK;
   LSA_HANDLE                hTrusted = NULL;
   LSA_HANDLE                hTrusting = NULL;
   NTSTATUS                  status;
   LSA_AUTH_INFORMATION      curr;
   LSA_AUTH_INFORMATION      prev;
   WCHAR                     password[] = L"password";
   
   // if credentials are specified, use them
   // open an LSA handle to the trusted domain
   status = OpenPolicy(trustedComp,POLICY_VIEW_LOCAL_INFORMATION | POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET,&hTrusted);
   rc = LsaNtStatusToWinError(status);
   if ( ! rc )
   {
      // set up the auth information for the trust relationship
      curr.AuthInfo = (LPBYTE)password;
      curr.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
      curr.AuthType = TRUST_AUTH_TYPE_CLEAR;
      curr.LastUpdateTime.QuadPart = 0;

      prev.AuthInfo = (LPBYTE)password;
      prev.AuthInfoLength = UStrLen(password) * sizeof(WCHAR);
      prev.AuthType = TRUST_AUTH_TYPE_CLEAR;
      prev.LastUpdateTime.QuadPart = 0;
      // set up the trusted side of the relationship
      if ( IsDownLevel(trustedComp) )
      {
            // create an inter-domain trust account for the trusting domain on the trusted domain
         USER_INFO_1          uInfo;
         DWORD                parmErr;
         WCHAR                name[LEN_Account];
   
         memset(&uInfo,0,(sizeof uInfo));

         UStrCpy(name,trustingDomain);
         name[UStrLen(name) + 1] = 0;
         name[UStrLen(name)] = L'$';

         if ( ! bCreate )
         {
            USER_INFO_1       * tempInfo = NULL;

            rc = NetUserGetInfo(trustedComp,name,1,(LPBYTE*)&tempInfo);
            if ( ! rc )
            {
               // the trust exists
               NetApiBufferFree(tempInfo);
               rc = NERR_UserExists;
            }
            else
            {
               if ( rc != NERR_UserNotFound )
               {
                  err.SysMsgWrite(ErrE,rc,DCT_MSG_TRUSTING_DOM_GETINFO_FAILED_SSD,trustingDomain,trustedComp,rc);
               }
            }
         }
         else
         {
            // this creates the trust account if it doesn't already exist
            // if the account does exist, reset its password
            uInfo.usri1_flags = UF_SCRIPT | UF_INTERDOMAIN_TRUST_ACCOUNT;
            uInfo.usri1_name = name;
            uInfo.usri1_password = password;
            uInfo.usri1_priv = 1;

            rc = NetUserAdd(trustedComp,1,(LPBYTE)&uInfo,&parmErr);
            if ( rc && rc != NERR_UserExists )
            {
               err.SysMsgWrite(ErrE,rc,DCT_MSG_TRUSTING_DOM_CREATE_FAILED_SSD,trustingDomain,trustedDomain,rc);
            }
            else if ( rc == NERR_UserExists )
            {
               // reset the password for the existing trust account
               USER_INFO_1003    pwdInfo;
               DWORD             parmErr;

               pwdInfo.usri1003_password = password;
               rc = NetUserSetInfo(trustedComp,name,1003,(LPBYTE)&pwdInfo,&parmErr);
            }

         }
      }
      else
      {
         // Win2K, all trusts exist as trusted domain objects
         // Create the trustedDomain object.
         LSA_UNICODE_STRING                  sTemp;
         TRUSTED_DOMAIN_INFORMATION_EX       trustedInfo;
         TRUSTED_DOMAIN_AUTH_INFORMATION     trustAuth;
      
         InitLsaString(&sTemp, const_cast<WCHAR*>(trustingDomain));
         trustedInfo.FlatName = sTemp;

         InitLsaString(&sTemp, trustingDNSName);
         trustedInfo.Name = sTemp;

         trustedInfo.Sid = trustingSid;

         if ( IsDownLevel(trustingComp) )
         {
            trustedInfo.TrustAttributes = TRUST_TYPE_DOWNLEVEL;
         }
         else
         {
            trustedInfo.TrustAttributes = 0;
         }
      
         if ( bBidirectional )
            trustedInfo.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
         else
            trustedInfo.TrustDirection = TRUST_DIRECTION_INBOUND;
      
         trustedInfo.TrustType = TRUST_ATTRIBUTE_NON_TRANSITIVE;

         trustAuth.IncomingAuthInfos = 1;
         trustAuth.OutgoingAuthInfos = bBidirectional ? 1 : 0;
         trustAuth.OutgoingAuthenticationInformation = bBidirectional ? &curr : NULL;
         trustAuth.OutgoingPreviousAuthenticationInformation = NULL;
         trustAuth.IncomingAuthenticationInformation = &curr;
         trustAuth.IncomingPreviousAuthenticationInformation = NULL;

         if ( bCreate )
         {
            status = LsaCreateTrustedDomainEx( hTrusted, &trustedInfo, &trustAuth, POLICY_VIEW_LOCAL_INFORMATION | 
                                          POLICY_TRUST_ADMIN | POLICY_CREATE_SECRET, &hTrusting );
            if ( status == STATUS_OBJECT_NAME_COLLISION )
            {
               TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;

               // Get the old information
               status = LsaQueryTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
               if ( ! status )
               {
                  pTrustedInfo->TrustAttributes |= trustedInfo.TrustAttributes;
                  pTrustedInfo->TrustDirection |= trustedInfo.TrustDirection;

                  status = LsaSetTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainInformationEx,pTrustedInfo);

                  if (! status )
                  {
                     status = LsaSetTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainAuthInformation,&trustAuth);
                  }
                  LsaFreeMemory(pTrustedInfo);
               }

            }
         }
         else
         {
            TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;

            status = LsaQueryTrustedDomainInfoByName(hTrusted,&sTemp,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
            if ( ! status )
            {
               LsaFreeMemory(pTrustedInfo);
            }

         }
         rc = LsaNtStatusToWinError(status);
         if ( ! rc )
         {
            LsaClose(hTrusting);
            hTrusting = NULL;
         }
      }
      if ( bCreate && bBidirectional && IsDownLevel(trustingComp) )
      {
         // set up the trust account for the other side of the relationship 
         // For Win2K, both sides of the bidirectional trust are handled together,
         // but NT4 bidirectional trusts require 2 separate actions
         USER_INFO_1          uInfo;
         DWORD                parmErr;
         WCHAR                name2[LEN_Account];
   
         memset(&uInfo,0,(sizeof uInfo));

         UStrCpy(name2,trustedDomain);
         name2[UStrLen(name2) + 1] = 0;
         name2[UStrLen(name2)] = L'$';

         uInfo.usri1_flags = UF_SCRIPT | UF_INTERDOMAIN_TRUST_ACCOUNT;
         uInfo.usri1_name = name2;
         uInfo.usri1_password = password;
         uInfo.usri1_priv = 1;

         
         rc = NetUserAdd(trustingComp,1,(LPBYTE)&uInfo,&parmErr);
         if ( rc == NERR_UserExists )
         {
            LPUSER_INFO_1          puInfo;
            rc = NetUserGetInfo(trustingComp, name2, 1, (LPBYTE*)&puInfo);
            if ( !rc ) 
            {
               puInfo->usri1_flags &= UF_INTERDOMAIN_TRUST_ACCOUNT;
               puInfo->usri1_password = password;
               rc = NetUserSetInfo(trustingComp,name2,1,(LPBYTE)puInfo,&parmErr);   
               NetApiBufferFree(puInfo);
            }
            else
            {
               err.MsgWrite(0, DCT_MSG_INVALID_ACCOUNT_S, name2);
            }
         }
         else if ( rc )
         {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_TRUSTING_DOM_CREATE_FAILED_SSD,trustingDomain,trustedDomain,rc);
         }
      }
   }      
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_LSA_OPEN_FAILED_SD,trustedComp,rc);
   }
   
   if( hTrusted )
      LsaClose(hTrusted);
   return rc;
}

// Helper function that gets DNS and NETBIOS domain names
void GetDnsAndNetbiosFromName(WCHAR const * name,WCHAR * netBios, WCHAR * dns)
{
   IADs      * pDomain = NULL;
   WCHAR       strText[1000];
   _bstr_t     distinguishedName;
   // try to connect to the AD, using the specified name
   swprintf(strText,L"LDAP://%ls",name);

   netBios[0] = 0;
   dns[0] = 0;

   HRESULT hr = ADsGetObject(strText,IID_IADs,(void**)&pDomain);
   if ( SUCCEEDED(hr) )
   {
      _variant_t        var;

      // get the DNS name from the LDAP provider
      hr = pDomain->Get(L"distinguishedName",&var);
      if ( SUCCEEDED(hr) )
      {
         WCHAR * dn = (WCHAR*)var.bstrVal;
         WCHAR * curr = dns;
         distinguishedName = dn;

         if ( !UStrICmp(dn,L"DC=",3) )
         {
            
            // for each ",DC=" in the name, replace it with a .
            for ( curr = dns, dn = dn+3 ;    // skip the leading "DC="
                  *dn       ;    // until the end of the string is reached
                  curr++         // 
                )
            {
               if ( (L',' == *dn)  && (L'D' == *(dn+1)) && (L'C' == *(dn+2)) && (L'=' == *(dn+3)) )
               {
                  (*curr) = L'.';
                  dn+=4;
               }
               else
               {
                  // just copy the character
                  (*curr) = (*dn);
                  dn++;
               }
            }
            *(curr) = 0;
         }
      
         // get the NETBIOS name from the LDAP provider
         hr = pDomain->Get(L"nETBIOSName",&var);
         if ( SUCCEEDED(hr) )
         {
            UStrCpy(netBios,(WCHAR*)var.bstrVal);
         }
         else
         {
            // currently, the netbiosName property is not filled in
            // so we will use a different method to get the flat-name for the domain
            // Here is our strategy to get the netbios name:
            // Enumerate the partitions container under the configuration container
            // look for a CrossRef object whose nCName property matches the distinguished name
            // we have for the domain.  This object's CN property is the flat-name for the domain

            // get the name of the configuration container
            IADs        * pDSE = NULL;
            swprintf(strText,L"LDAP://%ls/RootDSE",name);
            hr = ADsGetObject(strText,IID_IADs,(void**)&pDSE);
            if ( SUCCEEDED(hr) )
            {
               hr = pDSE->Get(L"configurationNamingContext",&var);
               if ( SUCCEEDED(hr) )
               {
                  IADsContainer     * pPart = NULL;
                  swprintf(strText,L"LDAP://%ls/CN=Partitions,%ls",name,var.bstrVal);
                  hr = ADsGetObject(strText,IID_IADsContainer,(void**)&pPart);
                  if ( SUCCEEDED(hr) )
                  {
                     IUnknown       * pUnk = NULL;
                     IEnumVARIANT   * pEnum = NULL;
                     IADs           * pItem = NULL;
                     ULONG            lFetch = 0;
                     // enumerate the contents of the Partitions container
                     hr = pPart->get__NewEnum(&pUnk);
                     if ( SUCCEEDED(hr) )
                     {
                        hr = pUnk->QueryInterface(IID_IEnumVARIANT,(void**)&pEnum);
                        pUnk->Release();
                     }
                     if ( SUCCEEDED(hr) )
                     {
                        hr = pEnum->Next(1,&var,&lFetch);
                     }
                     while ( hr == S_OK )
                     {
                        if (lFetch == 1 )
                        {
                           IDispatch * pDisp = V_DISPATCH(&var);
                           BSTR        bstr;

                           if ( pDisp )
                           {
                              hr = pDisp->QueryInterface(IID_IADs, (void**)&pItem); 
                              pDisp->Release();
                              if ( SUCCEEDED(hr) )
                              {
                                 hr = pItem->get_Class(&bstr);
                                 if ( !UStrICmp(bstr,L"crossRef") )
                                 {
                                    // see if this is the one we are looking for
                                    hr = pItem->Get(L"nCName",&var);
                                    if ( SUCCEEDED(hr) )
                                    {
                                       if ( !UStrICmp(var.bstrVal,(WCHAR*)distinguishedName) )
                                       {
                                          // this is the one we want!
                                          hr = pItem->Get(L"cn",&var);
                                          if ( SUCCEEDED(hr) )
                                          {
                                             UStrCpy(netBios,var.bstrVal);
                                             pItem->Release();
                                             SysFreeString(bstr);
                                             break;
                                          }
                                       }
                                    }
                                 }
                                 SysFreeString(bstr);
                                 pItem->Release();
                              }
                           }
                         }
                         hr = pEnum->Next(1, &var, &lFetch);
                     }
                     pPart->Release();
                     if ( pEnum )
                        pEnum->Release();
                  }
               }
               pDSE->Release();
            }
         }
      }
      pDomain->Release();
   }
   else
   {
      // default to using the specified name as both DNS and NETBIOS
      // this will work for NT 4 domains
      UStrCpy(netBios,name);
      UStrCpy(dns,name);
   }
   if ( ! (*netBios) )
   {
      UStrCpy(netBios,name);
      WCHAR          * temp = wcschr(netBios,L'.');
      if ( temp )
         *temp = 0;
   }
   if (! (*dns) )
   {
      UStrCpy(dns,name);
   }

}

// Main function used to create trusts
HRESULT 
   CTrust::CheckAndCreate(
      WCHAR                * trustingDomain, 
      WCHAR                * trustedDomain, 
      WCHAR                * credDomainTrusting,
      WCHAR                * credAccountTrusting,
      WCHAR                * credPasswordTrusting,
      WCHAR                * credDomainTrusted,
      WCHAR                * credAccountTrusted,
      WCHAR                * credPasswordTrusted,
      BOOL                   bCreate,
      BOOL                   bBidirectional
   )
{
//   HRESULT                   hr = S_OK;
   DWORD                     rc = 0;
   WCHAR                     trustingDom[LEN_Domain];
   WCHAR                     trustedDom[LEN_Domain];
   WCHAR                     trustingComp[LEN_Computer];
   WCHAR                     trustedComp[LEN_Computer];
   WCHAR                     trustingDNSName[LEN_Path];
   WCHAR                     trustedDNSName[LEN_Path];
   BYTE                      trustingSid[200];
   BYTE                      trustedSid[200];
   WCHAR                     name[LEN_Account];
   DWORD                     lenName = DIM(name);
   DWORD                     lenSid = DIM(trustingSid);
   SID_NAME_USE              snu;
   DOMAIN_CONTROLLER_INFO  * pInfo;
   WCHAR                   * curr = NULL;     
   BOOL                      bConnectTrusted = FALSE;
   BOOL                      bConnectTrusting = FALSE;

   // Get the DC names, and domain SIDs for the source and target domains
   GetDnsAndNetbiosFromName(trustingDomain,trustingDom,trustingDNSName);
   GetDnsAndNetbiosFromName(trustedDomain,trustedDom,trustedDNSName);

   
   // make sure the NETBIOS domain names are in lower case
   for ( curr = trustingDom ; *curr ; curr++ )
   {
      (*curr) = towupper(*curr);
   }

   for ( curr = trustedDom ; *curr ; curr++ )
   {
      (*curr) = towupper(*curr);
   }

   rc = DsGetDcName(NULL, trustingDom, NULL, NULL, DS_PDC_REQUIRED, &pInfo);
   if ( !rc )
   {
      wcscpy(trustingComp,pInfo->DomainControllerName);
      //wcscpy(trustingDNSName,pInfo->DomainName);
      NetApiBufferFree(pInfo);
   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DCNAME_FAILED_SD,trustingDom,rc);
   }

   if ( ! rc )
   {
      rc = DsGetDcName(NULL, trustedDom, NULL, NULL, DS_PDC_REQUIRED, &pInfo);
      if ( !rc )
      {
         wcscpy(trustedComp,pInfo->DomainControllerName);
        // wcscpy(trustedDNSName,pInfo->DomainName);
         NetApiBufferFree(pInfo);
      }
      else
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DCNAME_FAILED_SD,trustedDom,rc);
      }
   }   
   
   if ( credAccountTrusted && *credAccountTrusted )
   {
      if ( EstablishSession(trustedComp,credDomainTrusted,credAccountTrusted,credPasswordTrusted,TRUE) )
      {
         bConnectTrusted = TRUE;
      }
      else
      {
         rc = GetLastError();
      }
   }

   if ( credAccountTrusting && *credAccountTrusting )
   {
      if ( EstablishSession(trustingComp,credDomainTrusting,credAccountTrusting,credPasswordTrusting,TRUE) )
      {
         bConnectTrusting = TRUE;
      }
      else
      {
         rc = GetLastError();
      }
   }

   // Need to get the computer name and the SIDs for the domains.
   if ( ! rc && ! LookupAccountName(trustingComp,trustingDom,trustingSid,&lenSid,name,&lenName,&snu) )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DOMAIN_SID_FAILED_1,trustingDom,rc);
   }
   lenSid = DIM(trustedSid);
   lenName = DIM(name);
   if (! rc && ! LookupAccountName(trustedComp,trustedDom,trustedSid,&lenSid,name,&lenName,&snu) )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DOMAIN_SID_FAILED_1,trustedDom,rc);
   }
         

   // check the trusted side of the trust first
   if ( ! rc )
   {
      rc = CheckAndCreateTrustedSide(trustingDom,trustedDom,trustingComp,trustedComp,trustingDNSName,trustingSid,
                                       bCreate,bBidirectional);
   }
   if ( ! rc )
   {
      rc = CheckAndCreateTrustingSide(trustingDom,trustedDom,trustingComp,trustedComp,trustedDNSName,trustedSid,
                                       bCreate,bBidirectional);
   }

   if ( bConnectTrusted )
   {
      EstablishSession(trustedComp,credDomainTrusted,credAccountTrusted,credPasswordTrusted,FALSE);
   }

   if ( bConnectTrusting )
   {
      EstablishSession(trustingComp,credDomainTrusting,credAccountTrusting,credPasswordTrusting,FALSE);
   }
   
   
   return HRESULT_FROM_WIN32(rc);
}

long CTrust::EnumerateTrustedDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet,long ndxStart)
{
   DWORD                     rcOs;         // OS return code
   LSA_HANDLE                hPolicy;
   NTSTATUS                  status;
   WCHAR                     computer[LEN_Computer];
   DOMAIN_CONTROLLER_INFO  * pInfo;
   WCHAR                     sName[LEN_Domain];
   WCHAR                     key[100];
   long                      ndxTrust = ndxStart;
/*   PDS_DOMAIN_TRUSTS		 *ChildDomains;
   ULONG					 numChilds;
*/
   err.MsgWrite(0,DCT_MSG_ENUMERATING_TRUSTED_DOMAINS_S,domain);

   // open a handle to the source domain
   rcOs = DsGetDcName(NULL, domain, NULL, NULL, 0, &pInfo);
   if ( !rcOs )
   {
      wcscpy(computer,pInfo->DomainControllerName);
      NetApiBufferFree(pInfo);
   }
   else
   {
      err.SysMsgWrite(ErrE,rcOs,DCT_MSG_GET_DCNAME_FAILED_SD,domain,rcOs);
   }
  
   if ( ! rcOs )
   {
      if ( IsDownLevel(computer) )
      {
		  //Enumerate the trusted domains until there are no more to return.
		  status = OpenPolicy(computer,POLICY_ALL_ACCESS | POLICY_VIEW_LOCAL_INFORMATION ,&hPolicy);
		  if ( status == STATUS_SUCCESS )
		  {
         
			 LSA_ENUMERATION_HANDLE    lsaEnumHandle=0; // start an enum
			 PLSA_TRUST_INFORMATION    trustInfo = NULL;
			 ULONG                     ulReturned;               // number of items returned
			 NTSTATUS                  status;
			 DWORD                     rc;   

			 do {
   
				status = LsaEnumerateTrustedDomains(
							  hPolicy,        // open policy handle
							  &lsaEnumHandle, // enumeration tracker
							  (void**)&trustInfo,     // buffer to receive data
							  32000,          // recommended buffer size
							  &ulReturned     // number of items returned
							  );

				 //Check the return status for error.
				rc = LsaNtStatusToWinError(status);
				if( (rc != ERROR_SUCCESS) &&
					 (rc != ERROR_MORE_DATA) &&
					 (rc != ERROR_NO_MORE_ITEMS)
					 ) 
				 {
					 err.SysMsgWrite(ErrE,rcOs,DCT_MSG_TRUSTED_ENUM_FAILED_SD,domain,rcOs);
				 } 
				 else 
				 {
				   // . . . Code to use the Trusted Domain information
				   for ( ULONG ndx = 0 ; ndx < ulReturned ; ndx++ )
				   {
					  _bstr_t        direction;

					  UStrCpy(sName,trustInfo[ndx].Name.Buffer, ( trustInfo[ndx].Name.Length / (sizeof WCHAR)) + 1);

                  
					  TRUSTED_DOMAIN_INFORMATION_EX       * pTrustedInfo = NULL;

					  status = LsaQueryTrustedDomainInfo(hPolicy,trustInfo[ndx].Sid,TrustedDomainInformationEx,(LPVOID*)&pTrustedInfo);
					  if ( ! status )
					  {
						 switch ( pTrustedInfo->TrustDirection )
						 {
						 case TRUST_DIRECTION_DISABLED:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_DISABLED);
							break;
						 case TRUST_DIRECTION_INBOUND:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_INBOUND);
							break;
						 case TRUST_DIRECTION_OUTBOUND:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_OUTBOUND);
							break;
						 case TRUST_DIRECTION_BIDIRECTIONAL:
							direction = GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL);
							break;
						 default:
							break;
                        
						 };
						 if ( ! bIsTarget )
						 {
							swprintf(key,L"Trusts.%ld.Type",ndxTrust);
							pVarSet->put(key, GET_BSTR(IDS_TRUST_RELATION_EXTERNAL));
						 }
						 LsaFreeMemory(pTrustedInfo);

					  }
					  else
					  {
						 rcOs = LsaNtStatusToWinError(status);
						 // My logic here is that we are checking Trusted domains here so this is atleast true
						 // check whether this trust is already listed as an inbound trust
	//*                     direction = L"Outbound";
						 direction = GET_BSTR(IDS_TRUST_DIRECTION_OUTBOUND);
					  }
					  if ( ! bIsTarget )
					  {
						 swprintf(key,L"Trusts.%ld",ndxTrust);
						 pVarSet->put(key,sName);
                     
						 swprintf(key,L"Trusts.%ld.Direction",ndxTrust);
						 pVarSet->put(key,direction);
						 swprintf(key,L"Trusts.%ld.ExistsForTarget",ndxTrust);
	//*                     pVarSet->put(key,L"No");
						 pVarSet->put(key,GET_BSTR(IDS_No));
                        
						 err.MsgWrite(0,DCT_MSG_SOURCE_TRUSTS_THIS_SS,sName,domain);
					  }
					  long ndx2 = FindInboundTrust(pVarSet,sName,ndxTrust);
					  if ( ndx2 != -1 )
					  {
						 if ( ! bIsTarget )
						 {
							// we've already seen this trust as an inbound trust
							// update the existing record!
							WCHAR key2[1000];
							swprintf(key2,L"Trusts.%ld.Direction",ndx2);
	//*                        pVarSet->put(key2,L"Bidirectional");
							pVarSet->put(key2,GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL));
							continue;  // don't update the trust entry index, since we used the existing 
							// entry instead of creating a new one
						 }
						 else
						 {
							swprintf(key,L"Trusts.%ld.ExistsForTarget",ndx2);
	//*                        pVarSet->put(key,L"Yes");
							pVarSet->put(key,GET_BSTR(IDS_YES));
							err.MsgWrite(0,DCT_MSG_TARGET_TRUSTS_THIS_SS,domain,sName);
						 }

					  }
					  swprintf(key,L"Trusts.%ld.ExistsForTarget",ndxTrust);
                  
					  // check the trusted domain, to see if the target already trusts it
					  //if ( UStrICmp(sName,target) )
					 // {
					 //    continue;
					 // }
					  if ( ! bIsTarget )
						 ndxTrust++;
				   }
				   // Free the buffer.
				   LsaFreeMemory(trustInfo);
				 }
			 } while (rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA );
			 LsaClose(hPolicy);
		  }
		}
		else
		{
			ULONG ulCount;
			PDS_DOMAIN_TRUSTS pDomainTrusts;

			DWORD dwError = DsEnumerateDomainTrusts(
				computer,
				DS_DOMAIN_IN_FOREST|DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND,
				&pDomainTrusts,
				&ulCount
			);

			if (dwError == NO_ERROR)
			{
				ULONG ulIndex;
				ULONG ulDomainIndex = (ULONG)-1L;
				ULONG ulParentIndex = (ULONG)-1L;

				// find local domain

				for (ulIndex = 0; ulIndex < ulCount; ulIndex++)
				{
					if (pDomainTrusts[ulIndex].Flags & DS_DOMAIN_PRIMARY)
					{
						ulDomainIndex = ulIndex;

						if (!(pDomainTrusts[ulIndex].Flags & DS_DOMAIN_TREE_ROOT))
						{
							ulParentIndex = pDomainTrusts[ulIndex].ParentIndex;
						}
						break;
					}
				}

				for (ulIndex = 0; ulIndex < ulCount; ulIndex++)
				{
					DS_DOMAIN_TRUSTS& rDomainTrust = pDomainTrusts[ulIndex];

					// filter out indirect trusts

					if (!(rDomainTrust.Flags & (DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND)))
					{
						continue;
					}

					// trusted or trusting domain name

					_bstr_t bstrName(rDomainTrust.NetbiosDomainName);

					// trust direction

					_bstr_t bstrDirection;

					switch (rDomainTrust.Flags & (DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND))
					{
						case DS_DOMAIN_DIRECT_INBOUND:
							bstrDirection = GET_BSTR(IDS_TRUST_DIRECTION_INBOUND);
							break;
						case DS_DOMAIN_DIRECT_OUTBOUND:
							bstrDirection = GET_BSTR(IDS_TRUST_DIRECTION_OUTBOUND);
							break;
						case DS_DOMAIN_DIRECT_INBOUND|DS_DOMAIN_DIRECT_OUTBOUND:
							bstrDirection = GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL);
							break;
						default:
						//	bstrDirection = ;
							break;
					}

					// trust relationship

					_bstr_t bstrRelationship;

					if (ulIndex == ulParentIndex)
					{
						bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_PARENT);
					}
					else if (rDomainTrust.Flags & DS_DOMAIN_IN_FOREST)
					{
						if (rDomainTrust.ParentIndex == ulDomainIndex)
						{
							bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_CHILD);
						}
						else if ((rDomainTrust.Flags & DS_DOMAIN_TREE_ROOT) && (pDomainTrusts[ulDomainIndex].Flags & DS_DOMAIN_TREE_ROOT))
						{
							bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_ROOT);
						}
						else
						{
							bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_SHORTCUT);
						}
					}
					else
					{
						switch (rDomainTrust.TrustType)
						{
							case TRUST_TYPE_DOWNLEVEL:
							case TRUST_TYPE_UPLEVEL:
								bstrRelationship = (rDomainTrust.TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE) ? GET_BSTR(IDS_TRUST_RELATION_FOREST) : GET_BSTR(IDS_TRUST_RELATION_EXTERNAL);
								break;
							case TRUST_TYPE_MIT:
								bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_MIT);
								break;
							case TRUST_TYPE_DCE:
								bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_DCE);
								break;
							default:
								bstrRelationship = GET_BSTR(IDS_TRUST_RELATION_UNKNOWN);
								break;
						}
					}

					if (bIsTarget)
					{
						// if same trust was found on source domain and the trust
						// directions match update exists for target to yes

						LONG lSourceIndex = FindInboundTrust(pVarSet, bstrName, ndxTrust);

						if (lSourceIndex >= 0)
						{
							// get source trust direction

							swprintf(key, L"Trusts.%ld.Direction", lSourceIndex);

							_bstr_t bstrSourceDirection = pVarSet->get(key);

							// if target trust direction is bi-directional or
							// target trust direction equals source trust direction
							// then set exists for target to yes

							bool bExists = false;

							if (bstrDirection == GET_BSTR(IDS_TRUST_DIRECTION_BIDIRECTIONAL))
							{
								bExists = true;
							}
							else if (bstrDirection == bstrSourceDirection)
							{
								bExists = true;
							}

							if (bExists)
							{
								swprintf(key, L"Trusts.%ld.ExistsForTarget", lSourceIndex);

								pVarSet->put(key, GET_BSTR(IDS_YES));

								// write trust directions to log

								if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_OUTBOUND)
								{
									err.MsgWrite(0, DCT_MSG_TARGET_TRUSTS_THIS_SS, domain, (LPCTSTR)bstrName); 
								}

								if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_INBOUND)
								{
									err.MsgWrite(0, DCT_MSG_TARGET_TRUSTED_BY_THIS_SS, domain, (LPCTSTR)bstrName);
								}
							}
						}
					}
					else
					{
						// domain name
						swprintf(key, L"Trusts.%ld", ndxTrust);
						pVarSet->put(key, bstrName);

						// trust direction
						swprintf(key, L"Trusts.%ld.Direction", ndxTrust);
						pVarSet->put(key, bstrDirection);

						// trust relationship

						if (bstrRelationship.length() > 0)
						{
							swprintf(key, L"Trusts.%ld.Type", ndxTrust);
							pVarSet->put(key, bstrRelationship);
						}

						// trust exists on target
						// initially set to no until target domain is enumerated
						swprintf(key, L"Trusts.%ld.ExistsForTarget", ndxTrust);
						pVarSet->put(key, GET_BSTR(IDS_No));

						// write trust directions to log

						if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_OUTBOUND)
						{
							err.MsgWrite(0, DCT_MSG_SOURCE_TRUSTS_THIS_SS, (LPCTSTR)bstrName, domain);
						}

						if (rDomainTrust.Flags & DS_DOMAIN_DIRECT_INBOUND)
						{
							err.MsgWrite(0, DCT_MSG_SOURCE_IS_TRUSTED_BY_THIS_SS, (LPCTSTR)bstrName, domain);
						}

						++ndxTrust;
					}
				}

				NetApiBufferFree(pDomainTrusts);
			}
			else
			{
				 err.SysMsgWrite(ErrE, dwError, DCT_MSG_TRUSTED_ENUM_FAILED_SD, domain, dwError);
			}
		}
   }
   if ( bIsTarget )
   {
      // make sure we have "Yes" for the target domain itself
      long ndx2 = FindInboundTrust(pVarSet,domain,ndxTrust);
      if ( ndx2 != -1 )
      {
         swprintf(key,L"Trusts.%ld.ExistsForTarget",ndx2);
//*         pVarSet->put(key,L"Yes");
         pVarSet->put(key,GET_BSTR(IDS_YES));
      }
   }
   return ndxTrust;
}

long CTrust::EnumerateTrustingDomains(WCHAR * domain,BOOL bIsTarget,IVarSet * pVarSet,long ndxStart)
{
   DWORD                     rcOs;         // OS return code
   DWORD                     hEnum=0;      // enumeration handle
   USER_INFO_1             * pNetUsers=NULL; // NetUserEnum array buffer
   USER_INFO_1             * pNetUser;     // NetUserEnum array item
   DWORD                     nRead;        // Entries read.
   DWORD                     nTotal;       // Entries total.
   WCHAR                     sName[LEN_Domain]; // Domain name
   WCHAR                   * pNameEnd;     // Null at end
   WCHAR                     computer[LEN_Computer];
   DOMAIN_CONTROLLER_INFO  * pInfo;
   long                      ndx = ndxStart;
   WCHAR                     key[100];

   err.MsgWrite(0,DCT_MSG_ENUMERATING_TRUSTING_DOMAINS_S,domain);
   do
   {
      rcOs = DsGetDcName(NULL, domain, NULL, NULL, 0, &pInfo);
      if ( !rcOs )
      {
         wcscpy(computer,pInfo->DomainControllerName);
         NetApiBufferFree(pInfo);
      }
      else
      {
         break;
      }

      // get the trusting domains for the NT 4 domain
      // for Win2K domains, the trusting domains will be listed as Incoming in the Trusted Domain enumeration
      if ( IsDownLevel(computer) )
      {
         nRead = 0;
         nTotal = 0;
         rcOs = NetUserEnum(
               computer,
               1,
               FILTER_INTERDOMAIN_TRUST_ACCOUNT,
               (BYTE **) &pNetUsers,
               10240,
               &nRead,
               &nTotal,
               &hEnum );
         switch ( rcOs )
         {
            case 0:
            case ERROR_MORE_DATA:
               for ( pNetUser = pNetUsers;
                     pNetUser < pNetUsers + nRead;
                     pNetUser++ )
               {
                  // skip trust accounts whose password age is older than 30 days to avoid
                  // delays caused by trying to enumerate defunct trusts
                  if ( pNetUser->usri1_password_age > 60 * 60 * 24 * 30 ) // 30 days (age is in seconds)
                  {
                     err.MsgWrite(0,DCT_MSG_SKIPPING_OLD_TRUST_SD,pNetUser->usri1_name,
                        pNetUser->usri1_password_age / ( 60*60*24) );
                     continue;
                  }

                  safecopy( sName, pNetUser->usri1_name );
                  pNameEnd = sName + UStrLen( sName );
                  if ( (pNameEnd > sName) && (pNameEnd[-1] == L'$') )
                  {
                     pNameEnd[-1] = L'\0';
                  }
                  if ( *sName )
                  {
                     // Found a (probably) valid trust!
                     if ( ! bIsTarget )
                     {
                        // for the source domain, simply add the trusts to the list in the varset
                        swprintf(key,L"Trusts.%ld",ndx);
                        pVarSet->put(key,sName);
                        swprintf(key,L"Trusts.%ld.Direction",ndx);
//*                        pVarSet->put(key,L"Inbound");
                        pVarSet->put(key,GET_BSTR(IDS_TRUST_DIRECTION_INBOUND));
						swprintf(key,L"Trusts.%ld.Type",ndx);
						pVarSet->put(key, GET_BSTR(IDS_TRUST_RELATION_EXTERNAL));
                        swprintf(key,L"Trusts.%ld.ExistsForTarget",ndx);
//*                        pVarSet->put(key,L"No");
                        pVarSet->put(key,GET_BSTR(IDS_No));
                        err.MsgWrite(0,DCT_MSG_SOURCE_IS_TRUSTED_BY_THIS_SS,sName,domain);
                        ndx++;
                     }
                     else
                     {
                        // for the target domain, look for this trust in the varset 
                        // and if it is there, mark that it exists on the target
                        long ndxTemp = FindInboundTrust(pVarSet,sName,ndxStart);
                        if ( ndxTemp != -1  )
                        {
                           swprintf(key,L"Trusts.%ld.ExistsForTarget",ndxTemp);
//*                           pVarSet->put(key,L"Yes");
                           pVarSet->put(key,GET_BSTR(IDS_YES));
                           err.MsgWrite(0,DCT_MSG_TARGET_TRUSTS_THIS_SS,sName,domain);
                        }
                     }
                  }
               }
               break;
            default:
               break;
         }
         if ( pNetUsers )
         {
            NetApiBufferFree( pNetUsers );
            pNetUsers = NULL;
         }
      }
      else // if IsDownLevel()
      {
         // Win2K domain, don't need to enumerate the trusting domains here - they will all be included in the
         // trusted domain enum
         break;
      }
   }  while ( rcOs == ERROR_MORE_DATA );
   return ndx;
}

/*void CheckProc(void * arg,void * data)
{
   CTrust                  * tr = (CTrust*)arg;
}*/


STDMETHODIMP CTrust::PreMigrationTask(/* [in] */IUnknown * pVarSet)
{
/* IVarSetPtr              pVS = pVarSet;
   BOOL                    bCreate;
   _bstr_t                 source = pVS->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t                 target = pVS->get(GET_BSTR(DCTVS_Options_TargetDomain));
   _bstr_t                 logfile = pVS->get(GET_BSTR(DCTVS_Options_Logfile));
   _bstr_t                 localOnly = pVS->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));
   _bstr_t                 docreate = pVS->get(L"Options.CreateTrusts");

   if ( !UStrICmp(localOnly,GET_STRING(IDS_YES)) )
   {
      // don't do anything in local agent mode
      return S_OK;
   }
   
   if ( !UStrICmp(docreate,GET_STRING(IDS_YES)) )
   {
      bCreate = TRUE;
   }
   else
   {
      bCreate = FALSE;
   }
   pVS->put(GET_BSTR(DCTVS_CurrentOperation),L"Verifying trust relationships");
   

   err.LogOpen(logfile,1);
   err.LevelBeepSet(1000);
  
   err.LogClose();
*/ 
   return S_OK;
}

STDMETHODIMP CTrust::PostMigrationTask(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}


STDMETHODIMP CTrust::GetName(/* [out] */BSTR * name)
{
   (*name) = SysAllocString(L"Trust Manager");
   
   return S_OK;
}

STDMETHODIMP CTrust::GetResultString(/* [in] */IUnknown * pVarSet,/* [out] */ BSTR * text)
{
   WCHAR                     buffer[100] = L"";
   IVarSetPtr                pVS;

   pVS = pVarSet;

   
   (*text) = SysAllocString(buffer);
   
   return S_OK;
}

STDMETHODIMP CTrust::StoreResults(/* [in] */IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CTrust::ConfigureSettings(/*[in]*/IUnknown * pVarSet)
{
   return S_OK;
}

STDMETHODIMP CTrust::QueryTrusts(BSTR domainSource,BSTR domainTarget, BSTR sLogFile, IUnknown **pVarSet)
{
   HRESULT              hr = S_OK;
   IVarSetPtr           pVS(CLSID_VarSet);
   long                 ndx;

   _bstr_t sFile = sLogFile;
   err.LogOpen((WCHAR*) sFile, 1);
   err.LevelBeepSet(1000);
   hr = pVS.QueryInterface(IID_IUnknown,(long**)pVarSet);
   
   // Add a blank line to help differentiate different runs
   err.MsgWrite(0,DCT_MSG_GENERIC_S,L"");
   ndx = EnumerateTrustingDomains(domainSource,FALSE,pVS,0);
   EnumerateTrustingDomains(domainTarget,TRUE,pVS,0);
   ndx = EnumerateTrustedDomains(domainSource,FALSE,pVS,ndx);
   EnumerateTrustedDomains(domainTarget,TRUE,pVS,ndx);
   
   //err.LogClose();
   pVS->put(L"Trusts",ndx);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\plugins\trustmgr\trustmgr.cpp ===
// TrustMgr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for TrustMgr.idl by adding the following 
//      files to the Outputs.
//          TrustMgr_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f TrustMgrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TrustMgr.h"
#include "dlldatax.h"

#include "TrustMgr_i.c"
#include "McsPI_i.c"

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")

#include "Trust.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Trust, CTrust)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TRUSTMGRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\mcsdbgu.cpp ===
//---------------------------------------------------------------------------
// McsDebugUtil.cpp
//
// The classes declared in MCSDebugUtil.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++  */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "McsDbgU.h"

// -----------
// McsDebugLog
// ----------- 
void McsDebugUtil::McsDebugLog::write 
			(const char *messageIn) {
   if (m_outStream) {
      *(m_outStream) << messageIn;
      m_outStream->flush(); 
   }
}

#endif 	/* Not WIN16_VERSION */
#endif	/* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\mcsdbgu.h ===
//---------------------------------------------------------------------------
// McsDebugUtil.h
//
// The MCS Debug utility classes are declared in this file.
// The utility classes are:
//
// McsDebugException:
// This class is the exception class that is thrown by
// MCSEXCEPTION(SZ) macros and MCSASSERT(SZ) macros in
// test mode.
//
// McsDebugCritSec:
// Critical section class to support multi-threaded calls
// to the logger classes.
//
// McsDebugLog:
// Writes to ostream object.
// 
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebugUtil_h
#define MCSINC_McsDebugUtil_h

#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#include <iostream.h>
#include <fstream.h>

namespace McsDebugUtil {
   // ---------------
   // McsDebugCritSec
   // ---------------
   class McsDebugCritSec {
      public:
         McsDebugCritSec (void);
         ~McsDebugCritSec (void);
         void enter (void);
         void leave (void);

      private:
         McsDebugCritSec (const McsDebugCritSec&);
         McsDebugCritSec& operator= (const McsDebugCritSec&);

      private:
         CRITICAL_SECTION m_section;
   };

   // -----------
   // McsDebugLog
   // -----------
   class McsDebugLog {
      public:
         McsDebugLog (void);
         ~McsDebugLog (void);
         bool isLogSet (void) const;
         void changeLog (ostream *outStreamIn);
         void write (const char *messageIn);

      private:
         // Do not allow copy ctor & operator=.
         McsDebugLog (const McsDebugLog&);
         McsDebugLog& operator= (const McsDebugLog&);

      private: 
         ostream *m_outStream;
   };

   // --- INLINES ---
   // ---------------------
   // McsDebugCritSec
   // ---------------------
   inline McsDebugCritSec::McsDebugCritSec (void){
      ::InitializeCriticalSection (&m_section);
   }

   inline McsDebugCritSec::~McsDebugCritSec (void) {
      ::DeleteCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::enter (void) {
      ::EnterCriticalSection (&m_section);
   }

   inline void McsDebugCritSec::leave (void) {
      ::LeaveCriticalSection (&m_section);
   }

   // -----------
   // McsDebugLog
   // ----------- 
   inline McsDebugLog::McsDebugLog (void)
   : m_outStream (NULL)
   { /* EMPTY */ }

   // outStream object is set and owned by the
   // user of this class do not delete.
   inline McsDebugLog::~McsDebugLog (void) { /* EMPTY */ }

   inline bool McsDebugLog::isLogSet (void) const
   { return m_outStream != NULL; }

   inline void McsDebugLog::changeLog 
                  (ostream *outStreamIn) {
      m_outStream = outStreamIn;
   }
}

#endif	/* Not WIN16_VERSION */
#endif	/* C++ */
#endif	/* MCSINC_Mcs_Debug_Util_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\mcsdebug.cpp ===
//---------------------------------------------------------------------------
// MCSDebug.cpp
//
// The classes declared in MCSDebug.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include <time.h>
#include <strstrea.h>
#include "UString.hpp"
#include "McsDebug.h"

// -----------------
// McsDebugException
// -----------------
McsDebugException::McsDebugException 
      (const McsDebugException &t) 
: m_message (0), m_fileName (0), m_lineNum (t.m_lineNum) {
	if (t.m_message) { 
		m_message = new char [UStrLen(t.m_message)+1];
      if (m_message) { UStrCpy (m_message, t.m_message); }
    }
    if (t.m_fileName) {
		m_fileName = new char [UStrLen(t.m_fileName)+1];
      if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
    }
}

McsDebugException::McsDebugException 
                           (const char *messageIn,
						          const char *fileNameIn,
							       int        lineNumIn) 
: m_lineNum (lineNumIn) {
   if (messageIn) { 
      m_message = new char [UStrLen (messageIn)+1];
      if (m_message) { UStrCpy (m_message, messageIn); }
   }
   if (fileNameIn) {
      m_fileName = new char [UStrLen(fileNameIn)+1];
      UStrCpy (m_fileName, fileNameIn);
   }
}

McsDebugException& McsDebugException::operator= 
         (const McsDebugException &t) {
   if (this != &t) {
      if (t.m_message) { 
         m_message = new char [UStrLen(t.m_message)+1];
         if (m_message) { UStrCpy (m_message, t.m_message); }
      }
      if (t.m_fileName) {
         m_fileName = new char [UStrLen(t.m_fileName)+1];
         if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
      }
      m_lineNum = t.m_lineNum;
   }
   return *this;
}

// ------------
// McsVerifyLog
// ------------
static McsVerifyLog *pVerifyLog;
static LONG         verifyInitFlag;

McsVerifyLog* McsVerifyLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pVerifyLog) {
      while (::InterlockedExchange 
               (&verifyInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pVerifyLog) {
         static McsVerifyLog verifyLog;
         pVerifyLog = &verifyLog;
      }
      ::InterlockedExchange (&verifyInitFlag, 0);
   }
   return pVerifyLog;
}

void McsVerifyLog::changeLog (ostream *outStreamIn) {
   m_logSec.enter();
   m_log.changeLog (outStreamIn);
   delete m_outLog;
   m_outLog = 0;
   m_logSec.leave();
}

void McsVerifyLog::log (const char *messageIn,
                        const char *fileNameIn,
                        int        lineNumIn) {
   m_logSec.enter();
   // If the log file has not been set, set it
   // to the module name log file.
   if (!m_log.isLogSet()) {
      m_outLog = new fstream (getLogFileName(), 
         ios::app);
      m_log.changeLog (m_outLog);
   }
   // Format and write the message.
   formatMsg (messageIn, fileNameIn, lineNumIn);
   m_log.write (m_msgBuf);
   m_logSec.leave();
}

const char* McsVerifyLog::getLogFileName (void) {
   const char  *MCS_LOG_ENV  = "MCS_LOG";
   const char  *DIR_SEP      = "\\";
   const char  *EXT          = ".err";
   const char  *DEFAULT_NAME = "MCSDEBUG";
   static char logFileName[MAX_PATH];

   // Get MCS_LOG_ENV, or temp directory path, 
   // NULL means current directory.
   logFileName[0] = 0;
   char *mcs_log_path = getenv (MCS_LOG_ENV);
   bool isLogPath = false;
   if (mcs_log_path) {
      DWORD attrib = ::GetFileAttributesA (mcs_log_path);
      if ((attrib != 0xFFFFFFFF)
          && (attrib & FILE_ATTRIBUTE_DIRECTORY)) {
         UStrCpy (logFileName, mcs_log_path);
         isLogPath = true;
      }
   }
   if (!isLogPath) { 
      ::GetTempPathA (MAX_PATH, logFileName);
   }

   // Get file name from the module name.  If error
   // generate fixed filename. 
   char fullFilePath [MAX_PATH];
   char fileName[MAX_PATH];
   if (::GetModuleFileNameA (NULL, fullFilePath, 
                  MAX_PATH)) {
      // Get file name out of the path
      _splitpath (fullFilePath, NULL, NULL, fileName, 
                        NULL);

      // Generate full path name with extension.
      int len = UStrLen (logFileName);
      if (len) {
         UStrCpy (logFileName + len, DIR_SEP);
         UStrCpy (logFileName + UStrLen (logFileName), 
                     fileName);
      } else {
         UStrCpy (logFileName, fileName);
      }
   } else {
      UStrCpy (logFileName, DEFAULT_NAME);
   }
   strcat (logFileName + UStrLen (logFileName), EXT);

   return logFileName;
}

void McsVerifyLog::formatMsg (const char *messageIn,
                              const char *fileNameIn,
                              int         lineNumIn) {
   const char  *TIME        = "TIME : ";
   const char  *MSG         = "MSG  : ";
   const char  *FILE        = "FILE : ";
   const char  *LINE        = "LINE : ";
   const char  *SPACER      = ", ";

   // Create stream buf object.
   strstream msgBufStream (m_msgBuf, MSG_BUF_LEN, ios::out);

   // Write time stamp.
   time_t cur;
   time (&cur);
   struct tm *curTm = localtime (&cur);
   if (curTm) {
      char *tstr = asctime (curTm);
      if (tstr) {
         msgBufStream << TIME << tstr << SPACER;
      }
   }

   // Write message.
   if (messageIn) {
      msgBufStream << MSG << messageIn << SPACER;
   }

   // Write file name.
   if (fileNameIn) {
      msgBufStream << FILE << fileNameIn << SPACER;
   }

   // Write line number.
   msgBufStream << LINE << lineNumIn << endl;
}

// ----------
// McsTestLog
// ----------
static McsTestLog *pTestLog;
static LONG       testInitFlag;

McsTestLog* McsTestLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pTestLog) {
      while (::InterlockedExchange 
               (&testInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pTestLog) {
         static McsTestLog testLog;
         pTestLog = &testLog;
      }
      ::InterlockedExchange (&testInitFlag, 0);
   }
   return pTestLog;
}

bool McsTestLog::isTestMode (void) {
   const char *TEST_ENV = "MCS_TEST";
   const char *PRE_FIX  = "MCS";

   // Check if tested.
   if (!m_isTested) {
      // If not tested lock, test again, and
      // initialize test mode flag.
      m_testSec.enter();
      if (!m_isTested) {
         m_isTested    = true;
         m_isTestMode_ = getenv (TEST_ENV) != NULL;
      }
      m_testSec.leave();
   }

   return m_isTestMode_;
}

#endif 	/* Not WIN16_VERSION */
#endif  /* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ProfExt.rc
//
#define IDS_PROJNAME                    100
#define IDR_EXTENDPROFILEMIGRATION      101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\mcsdebug.h ===
//---------------------------------------------------------------------------
// MCSDebug.h 
//
// The debug macros and support classes are declared in 
// this file, they are:
//
// MCSASSERT & MCSASSERTSZ:
// These macros are only valid for a debug build. The 
// usage of these macros is outlined in the MCS Coding 
// Standards document. To support automated testing these
// macros look to the environment variable MCS_TEST, if
// this variable is defined a McsDebugException is generated.
//
// MCSEXCEPTION & MCSEXCEPTIONSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they throw an 
// exception McsException The usage of these macros is 
// outlined in the MCS Coding Standards document.
//
// MCSVERIFY & MCSVERIFYSZ
// These macros are valid for debug and release builds.  
// In the debug mode these macros are the same as 
// MCSASSERT(SZ).  In the release mode they log the 
// message using McsVerifyLog class.  The usage of these 
// macros is outlined in the MCS Coding Standards document.  
//
// MCSASSERTVALID
// This macro is based on MCSASSERT(SZ) macros, and is
// available only in debug mode.  The usage of this macro
// is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSEXCEPTIONVALID
// This macro is based on MCSEXCEPTION(SZ) macros, and is
// available in debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.  
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// MCSVERIFYVALID
// This macro is based on MCSVERIFY(SZ) macros, and is
// available debug and release modes.  The usage of this 
// macro is outlined in the MCS Coding Standards document.
// IMPORTANT: The macro expects the string allocation done
//            in the Validate function uses new operator.
//
// McsVerifyLog:
// The McsVerifyLog class is used by MCSVERIFY(SZ) macros
// to log verify messages.  This class uses the McsDebugLog
// class to log messages.  The user can change the ostream
// object to log messages else where.  
// The output log file is created in the directory 
// defined by MCS_LOG environment variable, or in the 
// TEMP directory, or in the current directory.  The name 
// of the output log file is <module name>.err.  
//
// McsTestLog:
// The McsTestLog class is used by MCSASSERT(SZ) macros
// to log messages in test mode. This class currently
// generates an exception.  This may have to be modified
// to support any new functionality required for unit
// testing.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef MCSINC_McsDebug_h
#define MCSINC_McsDebug_h

#ifdef __cplusplus		/* C++ */
#ifdef WIN16_VERSION	/* WIN16_VERSION */

#include <assert.h>

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#define MCSASSERT(expr) assert(expr)

#define MCSASSERTSZ(expr,msg) assert(expr)

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#define MCSEXCEPTION(expr) MCSASSERT(expr)

#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#define MCSVERIFY(expr) MCSASSERT(expr)

#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = 0; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

#else /* WIN16_VERSION */

#include <crtdbg.h>
#include "McsDbgU.h"

// ------------
// McsException
// ------------
class McsDebugException {
   public:
      McsDebugException ();
      McsDebugException (const McsDebugException &sourceIn);
      McsDebugException (const char *messageIn,
                         const char *fileNameIn,
                         int        lineNumIn);
      ~McsDebugException();
      McsDebugException& operator= (const McsDebugException &rhsIn);

      const char *getMessage (void) const;
      const char *getFileName (void) const;
      getLineNum (void) const;

   private:
      char *m_message;
      char *m_fileName;
      int  m_lineNum;
};

// ------------
// McsVerifyLog
// ------------
class McsVerifyLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsVerifyLog* getLog (void);
      ~McsVerifyLog (void);
      void changeLog (ostream *outStreamIn);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsVerifyLog (void);
      const char* getLogFileName (void);
      void formatMsg (const char *messageIn,
                      const char *fileNameIn,
                      int        lineNumIn);

      // Do not allow dflt ctor, copy ctor & operator=.
      McsVerifyLog (const McsVerifyLog&);
      McsVerifyLog& operator= (const McsVerifyLog&);

   private:
      enum { MSG_BUF_LEN = 2048 };
      char							      m_msgBuf[MSG_BUF_LEN];
	   McsDebugUtil::McsDebugCritSec m_logSec;
	   McsDebugUtil::McsDebugLog     m_log;
      fstream						      *m_outLog;
};

// ----------
// McsTestLog
// ----------
class McsTestLog {
   public:
      // No public ctors only way to access
      // an object of this class by using the
      // getLog function.  This required for
      // the correct static initializations.
      static McsTestLog* getLog (void);
      ~McsTestLog (void);
      bool isTestMode (void);
      void log (const char *messageIn,
                const char *fileNameIn,
                int        lineNumIn);

   private:
      McsTestLog (void);

      // Do not allow copy ctor & operator=.
      McsTestLog (const McsTestLog&);
      McsTestLog& operator= (const McsTestLog&);

   private:
      bool							m_isTested;
      bool							m_isTestMode_;
	  McsDebugUtil::McsDebugCritSec m_testSec;
};

// -------------------------------
// MCSASSERT & MCSASSERTSZ macros.
// ------------------------------- 
#ifdef  _DEBUG
#define MCSASSERT(expr) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (#expr, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else  // _DEBUG 
#define MCSASSERT(expr) ((void)0)
#endif // _DEBUG

#ifdef  _DEBUG
#define MCSASSERTSZ(expr,msg) \
   do { \
      if (!(expr)) { \
         if (McsTestLog::getLog()->isTestMode()) { \
            McsTestLog::getLog()->log (msg, __FILE__, __LINE__); \
         } else { \
            if (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, \
                  __LINE__, NULL, msg)) { \
                  _CrtDbgBreak(); \
            } \
         } \
      } \
   } while (0)
#else // _DEBUG 
#define MCSASSERTSZ(expr,msg) ((void)0)
#endif // _DEBUG

// -----------------------------
// MCSEXCEPTION & MCSEXCEPTIONSZ
// -----------------------------
#ifdef _DEBUG
#define MCSEXCEPTION(expr) MCSASSERT(expr)
#else
#define MCSEXCEPTION(expr) \
   do { \
      if (!(expr)) { \
         throw new McsDebugException (#expr, __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSEXCEPTIONSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSEXCEPTIONSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         throw new McsDebugException ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// -----------------------
// MCSVERIFY & MCSVERIFYSZ
// -----------------------
#ifdef _DEBUG
#define MCSVERIFY(expr) MCSASSERT(expr)
#else
#define MCSVERIFY(expr) \
   do { \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log (#expr, __FILE__, __LINE__); \
      } \
   } while (0)
#endif

#ifdef _DEBUG
#define MCSVERIFYSZ(expr,msg) MCSASSERTSZ(expr,msg)
#else
#define MCSVERIFYSZ(expr,msg) \
   do {  \
      if (!(expr)) { \
         McsVerifyLog::getLog()->log ((msg), __FILE__, \
               __LINE__); \
      } \
   } while (0)
#endif

// --------------
// MCSASSERTVALID
// --------------
#define MCSASSERTVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSASSERTSZ(flag, msg); \
      delete [] msg; \
   } while (0) 

// -----------------
// MCSEXCEPTIONVALID
// -----------------
#define MCSEXCEPTIONVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSEXCEPTIONSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// --------------
// MCSVERIFYVALID
// --------------
#define MCSVERIFYVALID() \
   do { \
      char *msg = NULL; \
      int flag = Validate(&msg); \
      MCSVERIFYSZ(flag, msg); \
      delete [] msg; \
   } while (0)

// ---------------
// --- INLINES ---
// ---------------

// -----------------
// McsDebugException 
// -----------------
inline McsDebugException::McsDebugException () 
: m_message (0), m_fileName (0), m_lineNum (0) 
{ /* EMPTY */ }
   
inline McsDebugException::~McsDebugException() { 
   delete [] m_message; 
   delete [] m_fileName; 
}

inline const char *McsDebugException::getMessage 
               (void) const {
   return m_message;
}

inline const char *McsDebugException::getFileName 
               (void) const {
   return m_fileName;
}

inline int McsDebugException::getLineNum 
               (void) const {
   return m_lineNum;
}

// ------------
// McsVerifyLog
// ------------
inline McsVerifyLog::McsVerifyLog (void) 
{ /* EMPTY */ }

inline McsVerifyLog::~McsVerifyLog (void) {
   delete m_outLog;
}

// ----------
// McsTestLog
// ----------
inline McsTestLog::McsTestLog (void) 
: m_isTested (FALSE), m_isTestMode_ (FALSE) 
{ /* EMPTY */ }

inline McsTestLog::~McsTestLog (void) { /* EMPTY */ }


inline void McsTestLog::log (const char *messageIn,
                             const char *fileNameIn,
                             int        lineNumIn) {
   throw new McsDebugException (messageIn, fileNameIn,
               lineNumIn);
}

#endif /* WIN16_VERSION */
#endif /* C++ */
#endif /* MCSINC_McsDebug_h */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6A1AE92F_5EBD_4D3A_A025_719D6EB4D1FF__INCLUDED_)
#define AFX_STDAFX_H__6A1AE92F_5EBD_4D3A_A025_719D6EB4D1FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6A1AE92F_5EBD_4D3A_A025_719D6EB4D1FF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\err.cpp ===
//#pragma title( "Err.cpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#ifndef WIN16_VERSION
   #include <lm.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <stdarg.h>
#include <share.h>
#include <time.h>
#include <rpc.h>
#include <rpcdce.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"

#define  TERR_MAX_MSG_LEN  (2000)
#define  BYTE_ORDER_MARK   (0xFEFF)


TError::TError(
      int                    displevel    ,// in -mimimum severity level to display
      int                    loglevel     ,// in -mimimum severity level to log
      WCHAR          const * filename     ,// in -file name of log (NULL if none)
      int                    logmode      ,// in -0=replace, 1=append
      int                    beeplevel     // in -min error level for beeping
   )
{
   lastError = 0;
   maxError = 0;
   logLevel = loglevel;
   dispLevel = displevel;
   logFile = NULL;
   beepLevel = beeplevel;
   LogOpen(filename, logmode, loglevel);
}


TError::~TError()
{
   LogClose();
}

// Closes any existing open logFile and opens a new log file if the fileName is
// not null.  If it is a null string, then a default fileName of "Temp.log" is
// used.
BOOL
   TError::LogOpen(
      WCHAR           const * fileName    ,// in -name of file including any path
      int                     mode        ,// in -0=overwrite, 1=append
      int                     level        // in -minimum level to log
   )
{
   BOOL                       retval=TRUE;

   if ( logFile )
   {
      fclose(logFile);
      logFile = NULL;
   }

   if ( fileName && fileName[0] )
   {
      // Check to see if the file already exists
      WIN32_FIND_DATA      fDat;
      HANDLE               hFind;
      BOOL                 bExisted = FALSE;

      hFind = FindFirstFile(fileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         FindClose(hFind);
         bExisted = TRUE;   
      }

      logFile = _wfsopen( fileName, mode == 0 ? L"wb" : L"ab", _SH_DENYNO );
      if ( !logFile )
      {
         MsgWrite( 4101, L"Log Open(%s) failed", fileName );
         retval = FALSE;
      }
      else
      {
         if (! bExisted )
         {
            // this is a new file we've just created
            // we need to write the byte order mark to the beginning of the file
            WCHAR x = BYTE_ORDER_MARK;
            fwprintf(logFile,L"%lc",x);
         }
      }
   }

   logLevel = level;

   return retval;
}


//-----------------------------------------------------------------------------
// Writes formatted message to log file and flushes buffers
//-----------------------------------------------------------------------------
void TError::LogWrite(WCHAR const * msg)
{
   WCHAR                     sTime[32];
   WCHAR                     sTemp[TERR_MAX_MSG_LEN];   
   
   // Get rid of the <CR> from the end of the message because it causes things
   // to run together in the logs
   wcscpy(sTemp, msg);
   DWORD dwLen = wcslen(sTemp);
   if ( sTemp[dwLen-1] == 0x0d )
      sTemp[dwLen-1] = 0x00;

   if ( logFile )
   {
      fwprintf(
            logFile,
            L"%s-%s\r\n",
            gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ),
            sTemp );
      fflush( logFile );
   }
}

//-----------------------------------------------------------------------------
// Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr, msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

#ifndef WIN16_VERSION
//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start(argPtr, msg);
   len = _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;
   DWORD                     lastRc = GetLastError();

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start( argPtr, msg );
   len = _vsnwprintf( suffix, DIM(suffix) - 1, msg, argPtr );

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}
#endif

//-----------------------------------------------------------------------------
// Error message format, display and exception processing function
//-----------------------------------------------------------------------------
void __stdcall
   TError::MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   )
{
   static WCHAR      const   prefLetter[] = L"TIWESVUXXXXX"; // These form the status code that appears at the start of each error message
   WCHAR                     fullmsg[TERR_MAX_MSG_LEN];
   struct
   {
      USHORT                 frequency;    // audio frequency
      USHORT                 duration;     // duration in mSec
   }                         audio[] = {{ 300,  20},{ 500,  50},{ 700, 100},
                                        { 800, 200},{1000, 300},{1500, 400},
                                        {2500, 750},{2500,1000},{2500,1000}};

   if ( num >= 0 )
      level = num / 10000;                 // 10000's position of error number
   else
      level = -1;
   if ( num == 0 )
   {
      wcsncpy(fullmsg, str, DIM(fullmsg));
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }
   else
   {
      if ( num > maxError )
         maxError = num;
      _snwprintf(fullmsg, DIM(fullmsg), L"%c%05d: %-s", prefLetter[level+1], num, str);
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }

   lastError = num;
   StrWrite(level, fullmsg);

   if ( level >= beepLevel )
      Beep(audio[level].frequency, audio[level].duration);

   if ( level >= logLevel )
      LogWrite(fullmsg);

   if ( level > 4 )
   {
      exit(level);
   }
}

//-----------------------------------------------------------------------------
// Return text for error code
//-----------------------------------------------------------------------------

WCHAR *        
   TError::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   static HMODULE            hNetMsg = NULL;
   DWORD                     rc;
   WCHAR                   * pMsg;

   msg[0] = '\0'; // force to null

   if ( code >= NERR_BASE && code < MAX_NERR )
   {
      if ( !hNetMsg )
         hNetMsg = LoadLibrary(L"netmsg.dll");
      rc = 1;
   }
   else
   {
      rc = DceErrorInqText( code, msg );
      // Change any imbedded CR or LF to blank.
      for ( pMsg = msg;
            *pMsg;
            pMsg++ )
      {
         if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
            *pMsg = L' ';
      }
      // Remove trailing blanks
      for ( pMsg--;
            pMsg >= msg;
            pMsg-- )
      {
         if ( *pMsg == L' ' )
            *pMsg = L'\0';
         else
            break;
      }
   }
   if ( rc )
   {
      if ( code >= NERR_BASE && code < MAX_NERR && hNetMsg )
      {
         FormatMessage(FORMAT_MESSAGE_FROM_HMODULE
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        hNetMsg,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
      else
      {
         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        NULL,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
   }
   return msg;
}

// Err.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\profmig.h ===
// ProfMig.h : Declaration of the CExtendProfileMigration

#ifndef __EXTENDPROFILEMIGRATION_H_
#define __EXTENDPROFILEMIGRATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CExtendProfileMigration
class ATL_NO_VTABLE CExtendProfileMigration : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CExtendProfileMigration, &CLSID_ExtendProfileMigration>,
	public IDispatchImpl<IExtendProfileMigration, &IID_IExtendProfileMigration, &LIBID_PROFEXTLib>
{
public:
	CExtendProfileMigration()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_EXTENDPROFILEMIGRATION)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtendProfileMigration)
	COM_INTERFACE_ENTRY(IExtendProfileMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendProfileMigration
public:
	STDMETHOD(UpdateProfile)(/*[in]*/ IUnknown * pVarSet);
	STDMETHOD(GetRegisterableFiles)(/*[out]*/ SAFEARRAY ** pArray);
	STDMETHOD(GetRequiredFiles)(/*[out]*/ SAFEARRAY ** pArray);
private:
	HRESULT UpdateMappedDrives(BSTR sSourceSam, BSTR sSourceDomain, BSTR sRegistryKey);
};

#endif //__EXTENDPROFILEMIGRATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\errdct.cpp ===
/*---------------------------------------------------------------------------
  File: ErrDct.cpp

  Comments: TError derived class for OnePoint Domain Administrator messages

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "ErrDct.hpp"
#include "AdsErr.h"

#define  TERR_MAX_MSG_LEN  (2000)

// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   )
{
   WCHAR                   * c;
   WCHAR                   * end;
   BOOL                      error = FALSE;
   DWORD                     rcOs;
   WCHAR                     dirName[MAX_PATH+1];
   BOOL                      isUNC = FALSE;
   BOOL                      skipShareName = FALSE;

   if ( !dirName )
      return ERROR_INVALID_PARAMETER;

   safecopy(dirName,dirToCreate);

   // Note: if the string is empty, that's ok - we will catch it when we don't see C:\ or C$\ below
   // walk through the string, and try to create at each step along the way

   do { // once
      c = dirName;
      end = dirName + UStrLen(dirName);
          // skip computer-name if UNC
      if ( *c == L'\\' && *(c + 1) == L'\\' )
      {
         isUNC = TRUE;
         for ( c=c+2 ; *c && *c != L'\\' ; c++ )
         ;
         if ( ! *c )
         {
            error = TRUE;
            rcOs = ERROR_INVALID_PARAMETER;
            break;
         }
         c++;
      }
      // skip C:\ or C$\.
      if ( *(c) &&  ( *(c+1)==L'$' || *(c+1)==L':' ) && *(c+2)==L'\\' )
      {
         c = c + 3;
         if ( c == end ) // They put in the root directory for some volume
            break;

      }
      else
      {
         if ( isUNC )
         {
            skipShareName = TRUE;
         }
         else
         {
            rcOs = ERROR_INVALID_PARAMETER;
            error = TRUE;
            break;
         }
      }
      // scan through the string looking for '\'
      for ( ; c <= end ; c++ )
      {
         if ( !*c || *c == L'\\' )
         {
            if ( skipShareName )
            {
               skipShareName = FALSE;
               continue;
            }
            // try to create at this level
            *c = L'\0';
            if ( ! CreateDirectory(dirName,NULL) )
            {
               rcOs = GetLastError();
               switch ( rcOs )
               {
               case 0:
               case ERROR_ALREADY_EXISTS:
                  break;
               default:
                  error = TRUE;
               }
            }
            if (c != end )
               *c = L'\\';
            if ( error )
                  break;
         }
      }
   } while ( FALSE );
   if ( !error )
      rcOs = 0;

   return rcOs;
}


WCHAR const *                               // ret- text for DCT message
   TErrorDct::LookupMessage(
      UINT                   msgNumber     // in - message number DCT_MSG_???
   )
{
   WCHAR             const * msg = NULL;

   return msg;
}

WCHAR *                                     // ret-text for system or EA error
   TErrorDct::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   if ( SUCCEEDED(code) )
   {
      return TError::ErrorCodeToText(code,lenMsg,msg);
   }
   else
   {
      if ( HRESULT_FACILITY(code) == FACILITY_WIN32 )
      {
         return TError::ErrorCodeToText(HRESULT_CODE(code),lenMsg,msg);
      }
      else
      {
         //Translate ADSI errors to DCT errors so message can be written.
         DWORD msgId = 0;
         switch ( code )
         {
            case (E_ADS_BAD_PATHNAME)              :   msgId = DCT_MSG_E_MSG_ADS_BAD_PATHNAME;
                                                      break;
            case (E_ADS_INVALID_DOMAIN_OBJECT)     :   msgId = DCT_MSG_E_ADS_INVALID_DOMAIN_OBJECT;
                                                      break;
            case (E_ADS_INVALID_USER_OBJECT)       :   msgId = DCT_MSG_E_ADS_INVALID_USER_OBJECT;
                                                      break;
            case (E_ADS_INVALID_COMPUTER_OBJECT)   :   msgId = DCT_MSG_E_ADS_INVALID_COMPUTER_OBJECT;
                                                      break;
            case (E_ADS_UNKNOWN_OBJECT)            :   msgId = DCT_MSG_E_ADS_UNKNOWN_OBJECT;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SET)          :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SET;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SUPPORTED)    :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SUPPORTED;
                                                      break;
            case (E_ADS_PROPERTY_INVALID)          :   msgId = DCT_MSG_E_ADS_PROPERTY_INVALID;
                                                      break;
            case (E_ADS_BAD_PARAMETER)             :   msgId = DCT_MSG_E_ADS_BAD_PARAMETER;
                                                      break;
            case (E_ADS_OBJECT_UNBOUND)            :   msgId = DCT_MSG_E_ADS_OBJECT_UNBOUND;
                                                      break;
            case (E_ADS_PROPERTY_NOT_MODIFIED)     :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_MODIFIED;
                                                      break;
            case (E_ADS_PROPERTY_MODIFIED)         :   msgId = DCT_MSG_E_ADS_PROPERTY_MODIFIED;
                                                      break;
            case (E_ADS_CANT_CONVERT_DATATYPE)     :   msgId = DCT_MSG_E_ADS_CANT_CONVERT_DATATYPE;
                                                      break;
            case (E_ADS_PROPERTY_NOT_FOUND)        :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_FOUND;
                                                      break;
            case (E_ADS_OBJECT_EXISTS)             :   msgId = DCT_MSG_E_ADS_OBJECT_EXISTS;
                                                      break;
            case (E_ADS_SCHEMA_VIOLATION)          :   msgId = DCT_MSG_E_ADS_SCHEMA_VIOLATION;
                                                      break;
            case (E_ADS_COLUMN_NOT_SET)            :   msgId = DCT_MSG_E_ADS_COLUMN_NOT_SET;
                                                      break;
            case (E_ADS_INVALID_FILTER)            :   msgId = DCT_MSG_E_ADS_INVALID_FILTER;
                                                      break;
            default                                :   msgId = 0;
         }

         if ( !msgId )
         {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         | FORMAT_MESSAGE_MAX_WIDTH_MASK
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | 80,
                           NULL,
                           code,
                           0,
                           msg,
                           lenMsg,
                           NULL );
         }
         else
         {
            static HMODULE            hDctMsg = NULL;
            DWORD                     rc = 0;   
            if ( ! hDctMsg )
            {
               hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
               if ( ! hDctMsg )
               {
                  rc = GetLastError();
               }
            }

            if ( ! rc )
            {
               FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                          hDctMsg,
                          msgId,
                          0,
                          msg,
                          lenMsg,
                          NULL);
            }
            else
            {
               swprintf(msg,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgId);
            }
            
         }
      }
   }
   return msg;
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   WCHAR                   * pMsg = NULL;
   va_list                   argPtr;
   int                       len;
   
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
      hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
      if ( ! hDctMsg )
      {
         rc = GetLastError();
      }
   }
   
   va_start(argPtr,msgNumber);
   
   if ( ! rc )
   {
      len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   va_end(argPtr);
   
   // Change any imbedded CR or LF to blank.
   for ( pMsg = suffix;
         *pMsg;
         pMsg++ )
   {
      if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
         *pMsg = L' ';
   }
   // append the system message for the lastRc at the end.
   len = UStrLen(suffix);
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len );
   }
   suffix[DIM(suffix) - 1] = '\0';
   
   va_end(argPtr);
   
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;
   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
     hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
	  if ( ! hDctMsg )
	  {
		  DWORD rc = GetLastError();
	  }

   }
   
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   va_list                   argPtr;

   va_start(argPtr,msgNumber);
   
   if ( rc == 0 )
   {
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   if ( suffix[UStrLen(suffix)-1] == L'\n' )
   {
		suffix[UStrLen(suffix)-1] = L'\0';
   }
   
   va_end(argPtr);
   
   MsgProcess(num, suffix);

}

void __cdecl
   TErrorDct::DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr,msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);

   MsgProcess(num, suffix);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\profext.cpp ===
// ProfExt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ProfExtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ProfExt.h"

#include "ProfExt_i.c"
#include "ProfMig.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ExtendProfileMigration, CExtendProfileMigration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_PROFEXTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\profmig.cpp ===
// ProfMig.cpp : Implementation of CExtendProfileMigration
#include "stdafx.h"

#import "\bin\McsVarSetMin.tlb" no_namespace

#include "ProfExt.h"
#include "ProfMig.h"
#include "TReg.hpp"
#include "ErrDct.hpp"

#define LEN_Path 255
TErrorDct err;
TError&  errCommon = err;
/////////////////////////////////////////////////////////////////////////////
// CExtendProfileMigration

STDMETHODIMP CExtendProfileMigration::GetRequiredFiles(SAFEARRAY **pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   SafeArrayPutElement(*pArray,ndx,SysAllocString(L"ProfExt.DLL"));
   
	return S_OK;
}

STDMETHODIMP CExtendProfileMigration::GetRegisterableFiles(SAFEARRAY **pArray)
{
   SAFEARRAYBOUND            bound[1] = { 1, 0 };
   LONG                      ndx[1] = { 0 };

   (*pArray) = SafeArrayCreate(VT_BSTR,1,bound);

   SafeArrayPutElement(*pArray,ndx,SysAllocString(L"ProfExt.DLL"));
   
	return S_OK;
}

STDMETHODIMP CExtendProfileMigration::UpdateProfile(IUnknown *pVarSet)
{
   HRESULT                   hr = S_OK;
   _variant_t                varSourceSam;
   _variant_t                varSourceDom;
   _variant_t                varRegKey;
   IVarSetPtr                pVs = pVarSet;

   varSourceSam = pVs->get(L"Account.SourceSam");
   varSourceDom = pVs->get(L"SourceDomain");
   varRegKey    = pVs->get(L"Profile.RegKey");
   hr = UpdateMappedDrives( V_BSTR(&varSourceSam), V_BSTR(&varSourceDom), V_BSTR(&varRegKey) );
	return hr;
}

// UpdateMappedDrives : This function looks in the Network key to find all the mapped drives and for the drives that have 
//                      sourceDomain\sourceAccount as the user account we set it to "".
HRESULT CExtendProfileMigration::UpdateMappedDrives(BSTR sSourceSam, BSTR sSourceDomain, BSTR sRegistryKey)
{
   TRegKey                   reg;
   TRegKey                   regDrive;
   DWORD                     rc = 0;
   WCHAR                     netKey[LEN_Path];
   int                       len = LEN_Path;
   int                       ndx = 0;
   HRESULT                   hr = S_OK;
   WCHAR                     sValue[LEN_Path];
   WCHAR                     sAcct[LEN_Path];
   WCHAR                     keyname[LEN_Path];

   // Build the account name string that we need to check for
   wsprintf(sAcct, L"%s\\%s", (WCHAR*) sSourceDomain, (WCHAR*) sSourceSam);
   // Get the path to the Network subkey for this users profile.
   wsprintf(netKey, L"%s\\%s", (WCHAR*) sRegistryKey, L"Network");
   rc = reg.Open(netKey, HKEY_USERS);
   if ( !rc ) 
   {
      while ( !reg.SubKeyEnum(ndx, keyname, len) )
      {
         rc = regDrive.Open(keyname, reg.KeyGet());
         if ( !rc ) 
         {
            // Get the user name value that we need to check.
            rc = regDrive.ValueGetStr(L"UserName", sValue, LEN_Path);
            if ( !rc )
            {
               if ( !wcsicmp(sAcct, sValue) )
               {
                  // Found this account name in the mapped drive user name.so we will set the key to ""
                  regDrive.ValueSetStr(L"UserName", L"");
               }
            }
            else
               hr = HRESULT_FROM_WIN32(GetLastError());
         }
         else
            hr = HRESULT_FROM_WIN32(GetLastError());
         ndx++;
      }
      reg.Close();
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\tsync.cpp ===
//#pragma title( "TSync.cpp - Common synchronization classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes
               TCriticalSection
               TSemaphoreNamed
Updates     -
===============================================================================
*/

#include <stdio.h>
#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <time.h>

#include "Common.hpp"
#include "Err.hpp"
#include "TSync.hpp"

///////////////////////////////////////////////////////////////////////////////
// TSemaphoreNamed member functions
///////////////////////////////////////////////////////////////////////////////

// Create named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Create(
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted     // out-TRUE=previously existed
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = CreateSemaphore( NULL, nInitial, nMaximum, sNameT );
   if ( handle == NULL )
   {
      rcOs = GetLastError();
   }
   else if ( pbExisted )
   {
      rcOs = GetLastError();
      switch ( rcOs )
      {
         case 0:
            *pbExisted = FALSE;
            break;
         case ERROR_ALREADY_EXISTS:
            *pbExisted = TRUE;
            rcOs = 0;
            break;
         default:
            break;
      }
   }
   return rcOs;
}

// Open named semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Open(
      TCHAR          const * sNameT        // in -semaphore name
   )
{
   DWORD                     rcOs=0;       // OS return code
   handle = OpenSemaphore( SEMAPHORE_ALL_ACCESS, FALSE, sNameT );
   if ( handle == NULL ) rcOs = GetLastError();
   return rcOs;
}

// Release semaphore
DWORD                                      // ret-OS return code
   TSemaphoreNamed::Release(
      long                   nRelease      // in -number to release
   )
{
   DWORD                     rcOs;         // OS return code
   long                      nPrevious=0;  // previous count
   rcOs = ReleaseSemaphore( Handle(), nRelease, &nPrevious )
         ? 0 : GetLastError();
   return rcOs;
}


// TSync.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\tsync.hpp ===
//#pragma title( "TSync.hpp - Common synchronization classes header file" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TSync.hpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-11-08
Description -  Common synchronization classes header file
               This includes TCriticalSection, and TNamedSemaphore
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TSync_hpp
#define  MCSINC_TSync_hpp

#ifndef _INC_TIME
#include <time.h>
#endif

class TCriticalSection
{
   CRITICAL_SECTION          cs;
public:
                        TCriticalSection() { InitializeCriticalSection(&cs); }
                        ~TCriticalSection() { DeleteCriticalSection(&cs); }
   void                 Enter() { EnterCriticalSection(&cs); }
   void                 Leave() { LeaveCriticalSection(&cs); }
};

class TSynchObject
{
public:
   HANDLE                    handle;
   TSynchObject()
   { handle = NULL; }
   ~TSynchObject()
   { Close(); }
   void Close()
   { if ( handle != NULL ) { CloseHandle( handle ); handle = NULL; } }

   DWORD                WaitSingle(DWORD msec) const { return WaitForSingleObject(handle, msec); }
   DWORD                WaitSingle()           const { return WaitForSingleObject(handle, INFINITE); }
   HANDLE               Handle() { return handle; }
};

///////////////////////////////////////////////////////////////////////////////
// Named semaphores
///////////////////////////////////////////////////////////////////////////////

class TSemaphoreNamed : public TSynchObject
{
public:
   TSemaphoreNamed() {};
   ~TSemaphoreNamed() {};
   DWORD Create(                           // ret-OS return code
      TCHAR          const * sNameT       ,// in -semaphore name
      DWORD                  nInitial     ,// in -initial count
      DWORD                  nMaximum     ,// in -maximum count
      BOOL                 * pbExisted=NULL // out-TRUE=previously existed
   );
   DWORD Open(                             // ret-OS return code
      TCHAR          const * sNameT        // in -semaphore name
   );
   DWORD Release(                          // ret-OS return code
      long                   nRelease=1    // in -number to release
   );
};


#endif  // MCSINC_TSync_hpp

// TSync.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\tnode.cpp ===
//#pragma title( "TNode.cpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      - TNode.cpp
System      - Common
Author      - Tom Bernhardt
Created     - 1989-11-19
Description - List/Tree base classes.
              TNode is a base class to define a collection element.  It
              contains a left and right pointer to another TNode item and
              these may be organized as a double-linked linear list or
              binary tree in the collection classes that use TNode items.

              Central to its utility are member functions to convert between
              binary tree, sorted 2-way linear linked lists, and unsorted 2-way
              linked linear lists.

 Collection and enum classes
   TNodeList         A simple collection of TNode elements.
   TNodeListSortable A TNodeList that is sortable by one or more compare functions.


 Conversion member functions for TNodeListSortable:
   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
Updates     -
1995-05-01 TPB Converted to C++ classes.
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include "TNode.hpp"
#include "common.hpp"


#pragma page()
//------------------------------------------------------------------------------
// Warning: Must not pass top == NULL
//------------------------------------------------------------------------------
TNode *                                    // ret-head of sorted list
   TNodeListSortable::TreeToSortedList(
      TNode                * top          ,// i/o-top of [sub]tree to squash
      TNode               ** newhead      ,// out-leftmost branch from tree
      TNode               ** newtail       // out-rightmost branch from tree
   )
{
   TNode                   * temp;         // temporary pointer placeholder

   if ( top->left == NULL )
      *newhead = top;                      // this is leftmost of parent node
   else
   {
      TreeToSortedList(top->left, newhead, &temp);
      top->left = temp;                    // left = tail of sub-list
      top->left->right = top;
   }
   if ( top->right == NULL )
      *newtail = top;                      // tree is rightmost of parent node
   else
   {
      TreeToSortedList(top->right, &temp, newtail);
      top->right = temp;                   // right = head of sub-list
      top->right->left = top;
   }
   return *newhead;
}


//------------------------------------------------------------------------------
// converts sorted 2-linked list into balanced binary tree
//------------------------------------------------------------------------------
TNode *                                    // ret-middle of list (head of Btree)
   TNodeListSortable::ListSortedToTree(
      TNode                * top           // i/o-top of [sub]list to tree-ify
   )
{
   TNode                   * mid = top    ,// middle of list
                           * curr;
   int                       odd = 1;

   if ( top == NULL )
      return NULL;
   for ( curr = top;  curr;  curr = curr->right ) // find list middle
   {
      if ( odd ^= 1 )
         mid = mid->right;
   }
   if ( mid->left )                        // split list around mid point
   {
      mid->left->right = NULL;             // right terminate new sublist
      mid->left = ListSortedToTree(top);   // recursive call to set left side
   }
   if ( mid->right )
   {
      mid->right->left = NULL;             // left terminate new sublist
      mid->right = ListSortedToTree(mid->right);// recursive call to set right side
   }
   return mid;
}


#pragma page()
TNode *                                    // ret-new head of tree
   TNodeListSortable::UnsortedToTree()
{
   TNode                   * treehead = NULL,
                           * tree,
                           * curr,
                           * next;

   MCSASSERTSZ( !IsTree(), "TNodeListSortable::UnsortedToTree - list is already a tree" );

   if ( !IsTree() )
   {
      for ( curr = head;  curr;  curr = next )// insert each node into BinTree
      {
         next = curr->right;                  // save right pointer
         curr->right = curr->left = NULL;     // break chains for insertion node
         if ( treehead == NULL )
            treehead = curr;                  // first node become BinTree head
         else
         {
            for ( tree = treehead;  ; )       // iterative BinTree insert algorithm
            {
               if ( PCompare(curr, tree) <=0 )// if belongs left of current node
                  if ( tree->left == NULL )   //    if left tree empty
                  {
                     tree->left = curr;       //       insert here
                     break;                   //       and process right node
                  }
                  else                        //    else
                     tree = tree->left;       //       go down left side 1 level
               else                           // must be right side
               {
                  if ( tree->right == NULL )
                  {
                     tree->right = curr;
                     break;
                  }
                  else
                     tree = tree->right;
               }
            }
         }
      }
      TypeSetTree();
   }
   return treehead;
}

#pragma page()

//------------------------------------------------------------------------------
// comparison function used for scrambling a sorted linked list
//------------------------------------------------------------------------------
TNodeCompare(ScrambledCompare)
{
   return (rand() - RAND_MAX/2);
}

//------------------------------------------------------------------------------
// converts sorted 2-linked list into a scrambled random binary tree
//------------------------------------------------------------------------------
void
   TNodeListSortable::SortedToScrambledTree()
{
   MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToScrambledTree - list is already a tree" );

   if ( !IsTree() )
   {
      TNodeCompare((*pOldCompare));
      pOldCompare = PCompare;
      CompareSet(ScrambledCompare);
      UnsortedToTree();
      CompareSet(pOldCompare);
   }
}

#pragma page()
TNodeList::~TNodeList()
{

// _ASSERTE( (count == 0) && (head == NULL) );

   if ( (count == 0) && (head == NULL) )
      ;
   else
   {
      //printf( "\aTNodeList destructor failure - list is not empty!\a\n" );
   }
}

void
   TNodeList::InsertTop(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = head;
   eIns->left  = NULL;
   if ( head )
      head->left = eIns;
   else
      tail = eIns;
   head = eIns;
   count++;
   return;
}

void
   TNodeList::InsertBottom(
      TNode                * eIns          // i/o-element to be inserted
   )
{
   MCSVERIFY(this);
   MCSVERIFY(eIns);

   eIns->right = NULL;
   eIns->left  = tail;
   if ( tail )
      tail->right = eIns;
   else
      head = eIns;
   tail = eIns;
   count++;
   return;
}

void
   TNodeList::InsertAfter(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eAft          // i/o-element insert point
   )
{
   TNode                   * eFwd;         // element after inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eAft )
      InsertTop( eIns );
   else
   {
      eFwd = eAft->right;
      eIns->right = eFwd;
      eIns->left  = eAft;
      if ( eFwd )
         eFwd->left  = eIns;
      else
         tail = eIns;
      eAft->right = eIns;
      count++;
   }
}

void
   TNodeList::InsertBefore(
      TNode                * eIns         ,// i/o-element to be inserted
      TNode                * eBef          // i/o-element insert point
   )
{
   TNode                   * eBwd;         // element before inserted element

   MCSVERIFY(this);
   MCSVERIFY(eIns);

   if ( !eBef )
      InsertBottom( eIns );
   else
   {
      eBwd = eBef->left;
      eIns->right = eBef;
      eIns->left  = eBwd;
      if ( eBwd )
         eBwd->right = eIns;
      else
         head = eIns;
      eBef->left = eIns;
      count++;
   }
   return;
}

void
   TNodeList::Remove(
      TNode          const * t             // i/o-new node to remove from list but not delete
   )
{
   MCSVERIFY(this);
   MCSVERIFY(t);

   if ( t->left )
      t->left->right = t->right;
   else
      head = t->right;

   if ( t->right )
      t->right->left = t->left;
   else
      tail = t->left;
   count--;

   //Remove links to the list from t. We cant do this because
   // t is a const *
   //t->left = t->right = NULL;
}


void
   TNodeList::Reverse()
{
   TNode                   * node;
   TNode                   * swap;

   MCSVERIFY(this);

   for ( node = head;  node;  node = node->left )
   {
       swap        = node->left;
       node->left  = node->right;
       node->right = swap;
   }
   swap = head;
   head = tail;
   tail = swap;
}


TNode *
   TNodeList::Find(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr;

   MCSASSERT(this);

   for ( curr = head;  curr;  curr = curr->right )
   {
      if ( !Compare( curr, findval ) )
         break;
   }
   return curr;
}

BOOL                                       // ret-TRUE if valid
   TNodeListSortable::CountTree(
      TNode                * pCurrentTop  ,// i/o-top of [sub]tree to count nodes
      DWORD                * pCount        // i/o-Number of nodes encountered in the tree
   )
{
   if ( !pCurrentTop )
      return TRUE;

   (*pCount)++;

   if( (*pCount) > count )
      return FALSE;

   if(!CountTree(pCurrentTop->left,pCount))
      return FALSE;

   if(!CountTree(pCurrentTop->right,pCount))
      return FALSE;

   return TRUE;
}


BOOL                                       // TRUE if Valid and FALSE if not
   TNodeListSortable::ValidateTree()
{
   DWORD                     dwTempCount=0;
   DWORD                     bValid;

   MCSVERIFY(listType == TNodeTypeTree);

   bValid = CountTree(head,&dwTempCount);

   return bValid;
}

// Routine to validate the state of the list
DWORD
   TNodeList::Validate(
      TNode               ** pErrorNode
   )
{
   DWORD                     dwError=0;
   DWORD                     nNodesVisited=0;
   TNode                   * pCurrentNode;
   DWORD                     dwNodeCount = Count();

   if(pErrorNode)
      *pErrorNode = NULL;

#ifndef WIN16_VERSION
   try
   {
#endif
      pCurrentNode = head;

      if ( pCurrentNode)  // If the list is not empty
      {
         if ( pCurrentNode->left)
         {
            dwError = MCS_ListError_InvalidHead;
         }
         else
         {
            while ( pCurrentNode->right )
            {
               if(pCurrentNode->right->left != pCurrentNode)
               {
                  dwError = MCS_ListError_InvalidPtr;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
                  break;
               }

               nNodesVisited++;

               if ( nNodesVisited > dwNodeCount )
               {
                  dwError = MCS_ListError_InvalidCount;
                  break;
               }
               pCurrentNode = pCurrentNode->right;
            }

            if ( (!dwError) && (!pCurrentNode->right) )
            {
               if ( pCurrentNode != tail)
               {
                  dwError = MCS_ListError_InvalidTail;
                  if(pErrorNode)
                     *pErrorNode = pCurrentNode->right;
               }
            }
         }
      }
      else  // if the list is empty
      {
         if(dwNodeCount)
         {
            dwError = MCS_ListError_InvalidCount;
         }
      }
#ifndef WIN16_VERSION
   }
   catch(...)
   {
      dwError = MCS_ListError_Exception;
   }
#endif

   return dwError;
}

void
   TNodeListSortable::TreeRemove(
      TNode                * item          // i/o-node to remove from binary tree
   )
{
   TNode                  ** prevNext = &head,
                           * rep,
                           * repLeft,
                           * temp;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   while ( *prevNext )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
      {
         // we've found a matching 'name' (they compare equal)
         if ( *prevNext == item )
         {
            // we've found the address we're looking for
            if ( (*prevNext)->right )
            {
               rep = repLeft = (*prevNext)->right;
               for ( temp = rep->left;  temp;  temp = temp->left )
                  repLeft = temp;
               repLeft->left = (*prevNext)->left;
               temp = *prevNext;
               *prevNext = rep;
            }
            else
            {
               temp = *prevNext;
               *prevNext = (*prevNext)->left; // simple case
            }

            // break removed nodes links to existing tree
            temp->left = temp->right = NULL;
            count--;
            break;
         }
      }
   }
   return;
}

// returns the insert point in a sorted list for a prospective node
TNode *                                    // ret-insert before point or NULL
   TNodeListSortable::SortedFindInsertBefore(
      TNode                * item         ,// i/o-node to insert into TNode
      BOOL                 * exists        // out-TRUE if already exists
   )
{
   int                       c;
   TNode                   * curr;

   *exists = FALSE;
   if ( !lastInsert )
   {
      if ( !head )           // if null head, empty list, return NULL
         return NULL;
      lastInsert = head;
   }

   c = PCompare(item, lastInsert);
   if ( c < 0 )
      lastInsert = head;

   for ( curr = lastInsert;  curr;  curr = curr->right )
   {
      c = PCompare(item, curr);
      if ( c <= 0 )
         if ( c == 0 )
            *exists = TRUE;
         else
            break;
   }

   return curr;
}

// inserts node into sorted linear list
void
   TNodeListSortable::SortedInsert(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;

   MCSVERIFY(listType != TNodeTypeTree);

   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   InsertBefore(item, insertPoint);
   lastInsert = item;
}


BOOL
   TNodeListSortable::SortedInsertIfNew(
      TNode                * item          // i/o-node to insert into TNode
   )
{
   BOOL                      exists;
   TNode                   * insertPoint = SortedFindInsertBefore(item, &exists);

   if ( !exists )
   {
      InsertBefore(item, insertPoint);
      lastInsert = item;
   }
   return !exists;
}


void
   TNodeListSortable::TreeInsert(
      TNode                * item         ,// i/o-node to insert into binary tree
      short                * depth         // out-tree/recursion depth of new item
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   MCSVERIFY(listType == TNodeTypeTree);

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( item, *prevNext );
      if ( cmp <= 0 )
         prevNext = &(*prevNext)->left;
      else
         prevNext = &(*prevNext)->right;
   }
   *prevNext = item;
   item->left = item->right = NULL;
   count++;
   return;
}


TNode *
   TNodeListSortable::TreeFind(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void const           * findval
   ) const
{
   TNode                   * curr = head;
   int                       cmp;

   while ( curr )
   {
      cmp = Compare( curr, findval );
      if ( cmp > 0 )
         curr = curr->left;
      else if ( cmp < 0 )
         curr = curr->right;
      else   // cmp == 0
         break;
   }
   return curr;
}


TNode *                                    // ret-TNode at pos n or NULL
   TNodeListOrdEnum::Get(
      long                   n             // in -new position
   )
{
   long                 disCurr = n - nCurr, // distance to curr
                        disTop  = n < (long)list->Count()/2 ? n : n - list->Count();

#ifdef WIN16_VERSION
   long absDisTop  = (disTop<0)  ? -disTop  : disTop;
   long absDisCurr = (disCurr<0) ? -disCurr : disCurr;
   if ( absDisTop < absDisCurr )
#else
   if ( abs(disTop) < abs(disCurr) )
#endif
   {
      Top();
      disCurr = disTop;
   }
   if ( disCurr < 0 )
      for ( Prev();  n < nCurr  &&  Prev(); );
   else
      for (       ;  n > nCurr  &&  Next(); );

   return curr;
}

// returns the first node of the tree
TNode *
   TNodeTreeEnum::First()
{
   stackPos = stackBase;
   if ( top )
      Push(top);
   return Next();
}

// Returns the tree node logically following the value per the sort organization
// specified by Compare, and sets up the enumeration to continue from that point.
TNode *
   TNodeTreeEnum::FirstAfter(
      TNodeCompareValue(  (* Compare) )   ,// in -compares value in TNode to other value
      void  const          * findVal       // in -findVal to position after
   )
{
   TNode                   * tn;
   int                       cmp;

   stackPos = stackBase;
   for ( tn = top;  tn;  )
   {
      Push(tn);
      cmp = Compare( tn, findVal );
      if ( cmp < 0 )
      {
         stackPos->state = Sright;
         if ( tn->right )
            tn = tn->right;
         else
            return Next();
      }
      else if ( cmp > 0 )
      {
         stackPos->state = Sleft;
         if ( tn->left )
            tn = tn->left;
         else
         {
            stackPos->state = Sused;
            return tn;
         }
      }
      else
      {
         stackPos->state = Sused;
         return Next();
      }
   }

   return NULL;
}


// returns the Next logical node of the tree ending with NULL when complete
TNode *
   TNodeTreeEnum::Next()
{
   for ( ;; )
   {
      switch ( stackPos->state )
      {
         case Snone:                       // we've done nothing here
            stackPos->state = Sleft;
            if ( stackPos->save->left )
               Push(stackPos->save->left);
            break;
         case Sleft:                       // we've gone left and are back
            stackPos->state = Sused;
            return stackPos->save;
         case Sused:                       // we've used the node
            stackPos->state = Sright;
            if ( stackPos->save->right )
               Push(stackPos->save->right);// process right side of branch
            break;
         case Sright:                      // we've gone right and are back
            if ( !Pop() )
               return NULL;
            break;
         case SComplete:
            return NULL;
            break;                         // Do we need this?
         default:                          // bad error
            MCSASSERT(FALSE);
            return NULL;
      }
   }

   return NULL;   // can't get here
}

// Returns the address of the forward (left/right) pointer where the find node
// already exists or would be inserted.  If the singly deferenced result is not
// null, the node's key value already exists in the tree.
// If, after obtaining the insertion point, you want to insert the node, just
// assign its address to the singly deferenced return value.  The following inserts
// the node "f" if it is not alread in the tree:
//    TNode **r = tree.TreeFindInsert(f);
//    if ( !*r )
//       *r = f;
TNode **                                   // ret-pointer forward pointer to find
   TNodeListSortable::TreeFindInsert(
      TNode const          * find         ,// in -node to find
      short                * depth         // out-tree depth of insertion point
   )
{
   TNode                  ** prevNext = &head;
   int                       cmp;

   for ( *depth = 0;  *prevNext;  (*depth)++ )
   {
      cmp = PCompare( find, *prevNext );
      if ( cmp < 0 )
         prevNext = &(*prevNext)->left;
      else if ( cmp > 0 )
         prevNext = &(*prevNext)->right;
      else
         break;
   }

   return prevNext;
}

// TNode.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\tnode.hpp ===
//#pragma title( "TNode.hpp - List/Tree base classes" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TNode.hpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  1989-11-19
Description -  List/Tree base classes.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TNode_hpp
#define  MCSINC_TNode_hpp

#include "common.hpp"

#define MCS_ListError_InvalidHead       0x00000001
#define MCS_ListError_InvalidTail       0x00000002
#define MCS_ListError_InvalidCount      0x00000004
#define MCS_ListError_InvalidPtr        0x00000008
#define MCS_ListError_Exception         0x00000010

#define TNodeCompare(name)                                                     \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                    \
         TNode       const * v1          ,/* in -value1 to compare           */\
         TNode       const * v2           /* in -value2 to compare           */\
      )

#define TNodeCompareValue(name)                                               \
   int                                    /* ret-0(v1==v2) >0(v1>v2) <0(v1<v2)*/\
      name(                                                                   \
         TNode       const * tnode       ,/* in -value1 to compare           */\
         void        const * value        /* in -value2 to compare           */\
      )

#define DeleteAllListItems(datatype)                                          \
   TNodeListEnum             tenum;        /* enumerate values             */ \
   datatype                * tnode;        /* this node                    */ \
   datatype                * tnext;        /* next node                    */ \
   for ( tnode = (datatype *) tenum.OpenFirst( this );                        \
         tnode;                                                               \
         tnode = tnext )                                                      \
   {                                                                          \
      tnext = (datatype *) tenum.Next();                                      \
      Remove( tnode );                                                        \
      delete tnode;                                                           \
   }                                                                          \
   tenum.Close()

// TNode is a a base class for any derived object to be put into one of the
// TNodeList classes.
class TNode
{
   friend class TNodeList;
   friend class TNodeListSortable;
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
   TNode                   * left;
   TNode                   * right;
public:
   TNode                * Next() const { MCSASSERT(this); return right; }
// virtual ~TNode() {}
};


class TNodeList
{
   friend class TNodeListEnum;
   friend class TNodeListOrdEnum;
   friend class TNodeTreeEnum;
protected:
   TNode                   * head,
                           * tail;
   DWORD                     count;
public:
                        TNodeList() { head = tail = NULL; count = 0; };
                        ~TNodeList();
   void                 InsertTop( TNode * eIns );
   void                 InsertBottom( TNode * eIns );
   void                 InsertAfter( TNode * eIns, TNode * eAft );
   void                 InsertBefore( TNode * eIns, TNode * eBef );
   void                 Remove(TNode const * t);
// void                 Delete(TNode * t) { Remove(t); delete t; };
   void                 Reverse();
   TNode *              Find(TNodeCompareValue((* Compare)), void const * findval) const;
   long                 Pos(TNode const * t) const
                        {
                           long n;
                           TNode * c;
                           MCSASSERT(this);
                           for (c=head, n=0; c!=t; c=c->right,n++);
                           return c ? n : -1;
                        }
   TNode              * Head() const { MCSASSERT(this); return head; }
   DWORD                Count() const { MCSASSERT (this); return count; }

protected:
   DWORD                Validate( TNode  ** pErrorNode );
};

/*
   A dynamically sortable collection of TNode entries.  The TNodes are arranged
   in either of two forms: a sorted linked linear list or a binary tree.  The
   current data data structure (form) is stored in the listType member.

   The form of the list may be easily changed from binary tree to sorted list or
   vice versa.  The following member functions support these transformations:
      ToSorted       Converts the tree form into a sorted linear list form without
                     need for comparisons; the order is preserved.
      SortedToTree   Converts the sorted linear list form into a perfectly
                     balanced binary tree without comparisons; the order is preserved.
      UnsortedToTree Converts the sorted linear list form into a binary tree
                     that is not necesarily balanced.  It uses the PCompare function
                     to form the order of the tree.  Thus if the list order closely
                     matches the PCompare directed order, the resulting tree will be
                     grossly unbalanced.  This has a bearing on the performance and
                     memory requirements of the ToSorted function which is recursive.
                     So be careful, especially with large lists.
      Sort           This resorts either a tree or list form according to the argument
                     pCompare function pointer provided.  Note the above admonition.

   In either form, exposed are also Insert and Remove member functions.  The functions
   are wrappers for TreeInsert and SortedInsert function depending upon the current
   list type.
*/
enum TNodeListType { TNodeTypeError, TNodeTypeUnsorted, TNodeTypeLinear, TNodeTypeTree };

class TNodeListSortable : public TNodeList
{
private:
   TNode                   * lastInsert;
   static TNode *                          // ret-head of sorted list
                        TreeToSortedList(
         TNode                * top       ,// i/o-top of [sub]tree to squash
         TNode               ** newhead   ,// out-leftmost branch from tree
         TNode               ** newtail    // out-rightmost branch from tree
      );
   static TNode *                          // ret-middle of list (head of Btree)
                        ListSortedToTree(
         TNode                * top        // i/o-top of [sub]list to tree-ify
      );

   BOOL                 CountTree( TNode * pCurrentTop, DWORD * pCount);

protected:
   TNodeListType        listType;
                        TNodeCompare((* PCompare));
public:
                        TNodeListSortable(TNodeCompare((* pCompare)) = NULL, TNodeListType t = TNodeTypeLinear)
                           { lastInsert = NULL; listType = t; PCompare = pCompare; };
                                                      ~TNodeListSortable() { if ( IsTree() ) ToSorted(); }

   void                 CompareSet(TNodeCompare((* pCompare))) { PCompare = pCompare; }
   void                 TypeSetTree()   { listType = TNodeTypeTree; }
   void                 TypeSetSorted() { listType = TNodeTypeLinear; }

   void                 TreeInsert(TNode * item, short * depth);
   TNode **             TreeFindInsert(TNode const * item, short * depth);
   BOOL                 TreeInsertIfNew(TNode * item, short * depth)
   {
      TNode ** r=TreeFindInsert(item,depth);
      if (*r) return FALSE;
      *r=item;
      item->left = item->right = NULL;
      count++;
      return TRUE;
   }
   void                 TreeInsert(TNode * item) { short discard; TreeInsert(item, &discard); };
   void                 TreeRemove(TNode * item);
   TNode *              TreeFind(TNodeCompareValue((* pCompare)), void const * findval) const;

   void                 SortedInsert(TNode * t);
   BOOL                 SortedInsertIfNew(TNode * t);
   TNode *              SortedFindInsertBefore(TNode * item, BOOL * exists);

   void                 Insert(TNode * t) { if (IsTree()) TreeInsert(t); else SortedInsert(t); }
   BOOL                 InsertIfNew(TNode * t) { short depth; if (IsTree()) return TreeInsertIfNew(t,&depth);
                                                              else return SortedInsertIfNew(t); }
   virtual void         Remove(TNode * t) { if (t==lastInsert) lastInsert = NULL;
                                            if (IsTree()) TreeRemove(t);
                                            else TNodeList::Remove(t); };
// void                 Delete(TNode * t) { Remove(t); delete t; };
   TNode *              Find(TNodeCompareValue((* pCompare)), void const * findval) const
                           { if (IsTree()) return TreeFind(pCompare,findval); return TNodeList::Find(pCompare,findval); }

   void                 SortedToTree()
   {
      MCSASSERTSZ( !IsTree(), "TNodeListSortable::SortedToTree - list is already a tree" );
      if ( !IsTree() )
      {
         head = ListSortedToTree( head );
         tail = NULL;
         listType = TNodeTypeTree;
      }
   }
   TNode *              UnsortedToTree();
   void                 ToSorted()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::ToSorted - list is not a tree" );
      if ( IsTree() )
      {
         MCSASSERT( ValidateTree() );
         if ( head )
            TreeToSortedList( head, &head, &tail );
         listType = TNodeTypeLinear;
      }
   }
   void                 Balance()
   {
      MCSASSERTSZ( IsTree(), "TNodeListSortable::Balance - list is not a tree" );
      if ( IsTree() )
      {
         ToSorted();
         SortedToTree();
      }
   }
   void                 Sort(TNodeCompare((* pCompare))) { TNodeListType lt = listType;
                                          if (lt == TNodeTypeTree) ToSorted();
                                          CompareSet(pCompare);
                                          UnsortedToTree();
                                          if (lt != TNodeTypeTree) ToSorted(); }
   void                 SortedToScrambledTree();
   BOOL                 IsTree() const { return listType == TNodeTypeTree; };

   BOOL                 ValidateTree( );
   DWORD                ValidateList( TNode  ** pErrorNode = NULL)
                        {
                           MCSASSERT(listType != TNodeTypeTree);
                           return Validate(pErrorNode);
                        }
};


/*
   TNodeListEnum is a 'friend' of TNode used to enumerate/iterate through
   TNodeList in linear list form.  It is an error to give it a TNodeList in
   tree form.
*/
class TNodeListEnum
{
protected:
   TNodeList         const * list;   // list for which enums are carried out
   TNode                   * curr;   // last node processed by enum functions
public:
                        TNodeListEnum() { list = NULL; curr = NULL; };
                        TNodeListEnum(TNodeList const * tlist) { Open(tlist); }
                        ~TNodeListEnum() { };

   void                 Open(TNodeList const * tlist) { list = tlist; Top(); };
   TNode              * OpenFirst(TNodeList const * tlist) { list = tlist; return First(); }
   TNode              * First() { return curr = list->head; };
   TNode              * Next() { return curr = (curr ? curr->right : list->head); }
   TNode              * Prev() { return curr = (curr ? curr->left  : list->tail); }
   TNode              * Last() { return curr = list->tail; };
   TNode *              Get() { return curr; }
   TNode *              Get(long n) { TNode * c; Top(); while ( n-->=0 && (c=Next()) ); return c; }
   void                 Close() { curr = NULL; }
   void                 Top() { curr = NULL; };
};

// provides optimized direct accessibility by ordinal to TNodeList at some
// expense to sequential traversal performance
class TNodeListOrdEnum : public TNodeListEnum
{
private:
   long                 nCurr;
public:
                        TNodeListOrdEnum() : TNodeListEnum() { nCurr = -1; };
                        TNodeListOrdEnum(TNodeList const * tlist) { Open(tlist); };

   void                 Open(TNodeList const * tlist) { TNodeListEnum::Open(tlist); nCurr = -1; };
   TNode              * OpenFirst(TNodeList const * tlist) { Open(tlist); return First(); }
   TNode              * First() { nCurr = list->head ? 0 : -1; return TNodeListEnum::First(); };
   TNode              * Next() { TNode * t = TNodeListEnum::Next(); if (curr) nCurr++; else nCurr=-1; return t; }
   TNode              * Prev() { TNode * t = TNodeListEnum::Prev(); if (curr) if (nCurr>0) nCurr--; else nCurr=list->Count()-1; else nCurr=-1; return t; }
   void                 Close() { nCurr=-1; TNodeListEnum::Close(); }
   void                 Top() { nCurr=-1; TNodeListEnum::Top(); };

   long                 Pos() const { return nCurr; };
   long                 Pos(TNode const * t) { long n; TNode * c;
                                               for (c=list->head, n=0; c!=t; c=c->right,n++);
                                               if (c) nCurr=n; else nCurr=-1; curr=c; return nCurr; }
   TNode *              Get(long n);
};


/*
   TNodeTreeEnum enumerates a TNodeListSortable that is in tree form.  It is an error
   to give it a TNodeListSortable that is in linear list form.
*/
enum TNodeTreeStackEntryState {Snone, Sleft, Sused, Sright, SComplete};
struct TNodeTreeStackEntry
{
   TNode                * save;
   TNodeTreeStackEntryState state;
};

const TREE_STACKSIZE = 200;            // default maximum recursion depth
class TNodeTreeEnum
{
private:
   TNodeTreeStackEntry     * stackBase,
                           * stackPos;
   int                       stackSize;
   void                 Push(TNode * item) { (++stackPos)->save = item; stackPos->state = Snone; };
   BOOL                 Pop() { return --stackPos >= stackBase; };
   void                 StackAlloc(int stacksize)
                           { stackSize = stacksize;
                             stackBase = new TNodeTreeStackEntry[stacksize]; };
protected:
   TNode                   * top;    // tree top for which enums are carried out
   TNode                   * curr;   // next node processed by enum functions
public:
                        TNodeTreeEnum(int stacksize = TREE_STACKSIZE) { top = NULL; StackAlloc(stacksize); };
                        TNodeTreeEnum(TNodeListSortable const * tlist, int stacksize = TREE_STACKSIZE) { StackAlloc(stacksize); Open(tlist); };
                        ~TNodeTreeEnum() { Close(); delete [] stackBase; };

   void                 Open(TNodeListSortable const * tlist)
                           {
                              top = tlist->head;
                              stackPos = stackBase;
                              stackPos->save = NULL;
                              stackPos->state = SComplete;
                              if ( top )
                                 Push(top);
                           }

   TNode              * First();
   TNode              * FirstAfter(TNodeCompareValue((* Compare) ), void const * findVal);
   TNode              * OpenFirst(TNodeListSortable const * tlist) {  Open(tlist);  return Next(); }

   TNode              * Next();
   TNode              * StackTop() { return stackPos->save; }
   void                 Close() { stackPos = stackBase; }
};

#endif  // MCSINC_TNode_hpp

// TNode.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\treg.cpp ===
//#pragma title( "TReg.cpp - NT registry class" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TReg.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1995-09-01
Description -  NT registry class.
Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <time.h>

#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "TNode.hpp"

#include "TReg.hpp"

// Short term solution
#define MAX_REG_NAMELEN    512
#define MAX_REG_VALUELEN   2048


// Destructor function was formerly inline.
// It is here to facilitate handle leak tracing.

   TRegKey::~TRegKey()
{
   Close();
};

// Close function was formerly inline.
// It is here to facilitate handle leak tracing.
void
   TRegKey::Close()
{
   if ( hKey != INVALID_HANDLE_VALUE )
   {
      RegCloseKey( hKey );
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

};

// open registry on remote computer
DWORD
   TRegKey::Connect(
      HKEY                  hPreDefined   ,// in -must be HKEY_LOCAL_MACHINE or HKEY_USERS
      TCHAR         const * machineName    // in -remote computer name
   )
{
   DWORD                     rc;           // return code

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegConnectRegistry( const_cast<TCHAR *>(machineName), hPreDefined, &hKey );

   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return rc;
}

// create new key
DWORD
   TRegKey::Create(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                * pDisp        ,// out-disposition of create
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     disp;
   DWORD                     rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegCreateKeyEx( hParent,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       access,
                       NULL,
                       &hKey,
                       (pDisp!=NULL) ? pDisp : &disp );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return rc;
}

// create new key (using backup/restore)
DWORD
   TRegKey::CreateBR(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                * pDisp        ,// out-disposition of create
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     disp;
   DWORD                     rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegCreateKeyEx( hParent,
                       keyname,
                       0,
                       NULL,
                       REG_OPTION_BACKUP_RESTORE,
                       access,
                       NULL,
                       &hKey,
                       (pDisp!=NULL) ? pDisp : &disp );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return rc;
}

// open existing key
DWORD
   TRegKey::Open(
      TCHAR          const * keyname      ,// in -name/path of key to create/open
      HKEY                   hParent      ,// in -handle of parent key
      DWORD                  access        // in -security access mask for key
   )
{
   DWORD                     rc;

   if ( hKey != INVALID_HANDLE_VALUE )
   {
      Close();
   }

   rc = RegOpenKeyEx( hParent,
                       keyname,
                       0,
                       access,
                       &hKey );
   if ( rc )
   {
      hKey = (HKEY) INVALID_HANDLE_VALUE;
   }

   return rc;
}

// Gets the subkey value of the specified index number
DWORD                                      // ret-os return code
   TRegKey::SubKeyEnum(
      DWORD                  n            ,// in -ordinal number of subkey
      TCHAR                * keyname      ,// out-key name
      DWORD                  keylen        // in -max length of key name
   ) const
{
   DWORD                     rc;
   DWORD                     keyLen = keylen;
   FILETIME                  lastWrite;

   rc = RegEnumKeyEx( hKey,
                      n,
                      keyname,
                      &keyLen,
                      0,
                      NULL,
                      NULL,
                      &lastWrite );

   return rc;
}

// Enumerate value
// Note that "namelen" must be "sizeof name", not "DIM(name)"
// Same for "valuelen"
DWORD                                      // ret-0 or error code
   TRegKey::ValueEnum(
      DWORD                  index        ,// in -ordinal number of subkey
      TCHAR                * name         ,// out-name
      DWORD                  namelen      ,// in -name length
      void                 * value        ,// out-value
      DWORD                * valuelen     ,// i/o-value length
      DWORD                * type          // out-value type code
   ) const
{
   return RegEnumValue( hKey, index, name, &namelen, NULL, type, (BYTE *) value, valuelen );
}

// Get REG_DWORD value
DWORD                                      // ret-OS return code
   TRegKey::ValueGetDWORD(
      TCHAR          const * name         ,// in -value name
      DWORD                * value         // out-returned DWORD value
   ) const
{
   DWORD                     osRc;         // OS return code
   DWORD                     type;         // type of value
   DWORD                     len = sizeof *value; // value length

   osRc = RegQueryValueEx( hKey, name, NULL, &type, (BYTE *) value, &len );

   if ( !osRc && (type != REG_DWORD) )
   {
      osRc = ERROR_FILE_NOT_FOUND;
   }

   return osRc;
}

// Get REG_SZ value
DWORD                                      // ret-OS return code
   TRegKey::ValueGetStr(
      TCHAR          const * name         ,// in -value name
      TCHAR                * value        ,// out-value buffer
      DWORD                  maxlen        // in -sizeof value buffer
   ) const
{
   DWORD                     osRc;         // OS return code
   DWORD                     type;         // type of value
   DWORD                     len;          // value length

   // force maxlen to an integral number of TEXT characters
   maxlen = maxlen / (sizeof value[0]) * (sizeof value[0]);

   if ( !maxlen )
   {
      osRc = ERROR_FILE_NOT_FOUND;
   }
   else
   {
      len = maxlen;
      osRc = RegQueryValueEx( hKey, name, NULL, &type, (BYTE *) value, &len );
      len = len / (sizeof value[0]) * (sizeof value[0]);
      if ( !osRc && (type != REG_SZ) )
      {
         osRc = ERROR_FILE_NOT_FOUND;
      }
      if ( osRc )
      {
         value[0] = TEXT('\0');
      }
      else
      {  // return of a null-terminated string is not guaranteed by API!
         // force null-terminated string, truncate string if necessary.
         if ( len >= maxlen )
         {
            len = maxlen - sizeof value[0];
         }
         value[len/(sizeof value[0])] = TEXT('\0');
      }
   }

   return osRc;
}

DWORD
   TRegKey::ValueGet(
      TCHAR          const * name         ,// in -name
      void                 * value        ,// out-value
      DWORD                * lenvalue     ,// i/o-length of value
      DWORD                * typevalue     // out-type of value
   ) const
{
   return RegQueryValueEx( hKey, name, 0, typevalue, (UCHAR *) value, lenvalue );
}

// Set REG_SZ value
DWORD
   TRegKey::ValueSetStr(
      TCHAR          const * name         ,// in -value name
      TCHAR          const * value        ,// out-value
      DWORD                  type          // in -value type
   ) const
{
   return RegSetValueEx( hKey,
                         name,
                         NULL,
                         type,
                         (LPBYTE) value,
                         (UStrLen(value) + 1) * sizeof value[0] );
}

DWORD
   TRegKey::ValueSet(
      TCHAR          const * name         ,// in -name
      void           const * value        ,// in -value
      DWORD                  lenvalue     ,// in -length of value
      DWORD                  typevalue     // in -type of value
   ) const
{
   return RegSetValueEx( hKey,
                         name,
                         0,
                         typevalue,
                         (UCHAR const *) value,
                         lenvalue );
}

DWORD                                      // ret-0 or error code
   TRegKey::ValueDel(
      TCHAR          const * name          // in -value name
   ) const
{
   DWORD                     rc;

   rc = RegDeleteValue(hKey, name);

   return rc;
}

DWORD                                      // ret-OS return code
   TRegKey::HiveCopy(
      TRegKey        const * source        // in -source hive
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // key/value index
   TCHAR                     name[MAX_REG_NAMELEN];    // key name
   TCHAR                     value[MAX_REG_VALUELEN];   // value name
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type
   TRegKey                   srcNest;      // nested source registry
   TRegKey                   trgNest;      // nested target registry

   // process values at this level
   for ( index = 0;
         !retval;
         index++ )
   {
      valuelen = sizeof value;
      retval = source->ValueEnum( index, name, sizeof name, value, &valuelen, &type );
      if ( !retval )
      {
         retval = this->ValueSet( name, value, valuelen, type );
      }
      else if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   // process keys at this level; for each key make a recursive call
   for ( index = 0;
         !retval;
         index++ )
   {
      retval = source->SubKeyEnum( index, name, sizeof name );
      if ( !retval )
      {
         retval = srcNest.Open( name, source );
         if ( !retval )
         {
            retval = trgNest.Create( name, this );
            if ( !retval )
            {
               retval = trgNest.HiveCopy( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

DWORD                                      // ret-OS return code
   TRegKey::HiveDel()
{
   DWORD                     retval = 0;   // returned value
   DWORD                     index;        // value/key index
   TCHAR                     name[300];    // name
   DWORD                     namelen;      // name length
   BYTE                      value[300];   // value
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type code
   TRegKey                   trgNest;      // nested target registry

   // delete values at this level
   for ( index = 0;
         !retval;
         /* index++ */ ) // note that index remains at zero
   {
      namelen = sizeof name;
      valuelen = sizeof value;
      retval = ValueEnum( index, name, namelen, value, &valuelen, &type );
      if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
      if ( !retval )
      {
         retval = ValueDel( name );
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   // process keys at this level; for each key make a recursive call
   for ( index = 0;
         !retval;
         /* index++ */ ) // note that index remains at zero
   {
      retval = SubKeyEnum( index, name, sizeof name );
      if ( !retval )
      {
         retval = trgNest.Open( name, this );
         if ( !retval )
         {
            retval = trgNest.HiveDel();
            trgNest.Close();
         }
         retval = SubKeyDel( name );
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// These four classes are used only by TRegReplicate
// Class to represent one registry key
class RKey : public TNode
{
   friend class RKeyList;
private:
   TCHAR                   * name;         // key name
protected:
public:
   RKey() { name = NULL; };
   ~RKey() { if ( name ) delete name; };
   BOOL New( TCHAR const * aname );
   TCHAR const * GetName() const { return name; };
};

BOOL
   RKey::New(
      TCHAR          const * aname         // in -key name
   )
{
   name = new TCHAR[UStrLen(aname)+1];

   if ( name )
   {
      UStrCpy( name, aname );
   }

   return !!name;
}

// Class to represent the set of registry keys at one level
class RKeyList : public TNodeListSortable
{
private:
   static TNodeCompare( Compare ) { return UStrICmp(
         ((RKey const *) v1)->name,
         ((RKey const *) v2)->name ); }
protected:
public:
   RKeyList() : TNodeListSortable( Compare ) {}
   ~RKeyList();
};

// RKeyList object destructor
   RKeyList::~RKeyList()
{
   DeleteAllListItems( RKey );
}

// Class to represent one registry value
class RValue : public TNode
{
   friend class RValueList;
private:
   TCHAR                   * name;         // value's name
   BYTE                    * value;        // value's value
   DWORD                     valuelen;     // value's value length
   DWORD                     type;         // value's type
protected:
public:
   RValue() { name = NULL; value = NULL; valuelen = type = 0; };
   ~RValue() { if ( name ) delete name;
               if ( value ) delete value; };
   BOOL New( TCHAR const * aname, BYTE const * avalue, DWORD valuelen, DWORD type );
   TCHAR const * GetName() const { return name; };
   BYTE const * GetValue() const { return value; };
   DWORD GetValueLen() const { return valuelen; };
   DWORD GetType() const { return type; };
};

BOOL
   RValue::New(
      TCHAR          const * aname        ,// in -value's name
      BYTE           const * avalue       ,// in -value's value
      DWORD                  avaluelen    ,// in -value's value length
      DWORD                  atype         // in -value's type
   )
{
   name = new TCHAR[UStrLen(aname)+1];

   if ( name )
   {
      UStrCpy( name, aname );
   }

   value = new BYTE[avaluelen];

   if ( value )
   {
      memcpy( value, avalue, avaluelen );
   }

   valuelen = avaluelen;
   type = atype;

   return name && value;
}

// Class to represent the set of registry values at one level
class RValueList : public TNodeListSortable
{
private:
   static TNodeCompare( Compare ) { return UStrICmp(
         ((RValue const *)v1)->name,
         ((RValue const *)v2)->name ); }
protected:
public:
   RValueList() : TNodeListSortable( Compare ) {}
   ~RValueList();
};

// RValueList object destructor
   RValueList::~RValueList()
{
   DeleteAllListItems( RValue );
}

// Static subroutine used only by TRegReplicate
// collect all values at one registry level into a RValueList
DWORD static
   CollectValues(
      RValueList           * pValueList   ,// out-value list to be built
      TRegKey        const * pRegKey       // in -registry key
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // value enum index
   TCHAR                     name[MAX_REG_NAMELEN];    // value name
   BYTE                      value[MAX_REG_VALUELEN];   // value value
   DWORD                     valuelen;     // value length
   DWORD                     type;         // value type
   RValue                  * pValue;       // new value

   for ( index = 0;
         !retval;
         index++ )
   {
      valuelen = sizeof value;
      retval = pRegKey->ValueEnum( index, name, sizeof name, value, &valuelen, &type );
      if ( !retval )
      {
         pValue = new RValue;
         if ( pValue )
         {
            if ( pValue->New( name, value, valuelen, type ) )
            {
               pValueList->Insert( pValue );
            }
            else
            {
               delete pValue;
               pValue = NULL;
            }
         }
         if ( !pValue )
         {
            retval = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
      else if ( retval == ERROR_MORE_DATA )
      {
         retval = 0;
      }
   }
   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// Static subroutine used only by TRegReplicate
// collect all keys at one registry level into a RKeyList
DWORD static
   CollectKeys(
      RKeyList             * pKeyList     ,// out-key list to be built
      TRegKey        const * pRegKey       // in -registry key
   )
{
   DWORD                     retval=0;     // returned value
   DWORD                     index;        // key enum index
   TCHAR                     name[MAX_REG_NAMELEN];    // key name
   RKey                    * pKey;         // new key object

   for ( index = 0;
         !retval;
         index++ )
   {
      retval = pRegKey->SubKeyEnum( index, name, sizeof name );
      if ( !retval )
      {
         pKey = new RKey;
         if ( pKey )
         {
            if ( pKey->New( name ) )
            {
               pKeyList->Insert( pKey );
            }
            else
            {
               delete pKey;
               pKey = NULL;
            }
         }
         if ( !pKey )
         {
            retval = ERROR_NOT_ENOUGH_MEMORY;
         }
      }
   }

   if ( retval == ERROR_NO_MORE_ITEMS )
   {
      retval = 0;
   }

   return retval;
}

// Replicate registry hive
DWORD                                      // ret-OS return code
   TRegKey::HiveReplicate(
      TRegKey        const * source        // in -source hive
   )
{
   DWORD                     retval=0;     // returned value
   RValueList                srcValues;    // source values
   RValueList                trgValues;    // target values
   TNodeListEnum             eSrcValue;    // enumerate source values
   RValue            const * pSrcValue;    // source value
   TNodeListEnum             eTrgValue;    // enumerate target values
   RValue            const * pTrgValue;    // target value
   RKeyList                  srcKeys;      // source keys
   RKeyList                  trgKeys;      // target keys
   TNodeListEnum             eSrcKey;      // enumerate source keys
   RKey              const * pSrcKey;      // source key
   TNodeListEnum             eTrgKey;      // enumerate target keys
   RKey              const * pTrgKey;      // target key
   int                       cmpRc;        // compare return code
   TRegKey                   srcNest;      // nested source registry
   TRegKey                   trgNest;      // nested target registry

   // handle replication of values at this level
   CollectValues( &srcValues, source );
   CollectValues( &trgValues, this );

   // now merge the values
   pSrcValue = (RValue const *) eSrcValue.OpenFirst( &srcValues );
   pTrgValue = (RValue const *) eTrgValue.OpenFirst( &trgValues );
   while ( !retval && (pSrcValue || pTrgValue) )
   {
      if ( !pTrgValue )
      {
         cmpRc = -1;
      }
      else if ( !pSrcValue )
      {
         cmpRc = 1;
      }
      else
      {
         cmpRc = UStrICmp( pSrcValue->GetName(), pTrgValue->GetName() );
      }
      if ( cmpRc < 0 )
      {  // source value only (copy)
         retval = this->ValueSet( pSrcValue->GetName(), pSrcValue->GetValue(),
               pSrcValue->GetValueLen(), pSrcValue->GetType() );
         pSrcValue = (RValue const *) eSrcValue.Next();
      }
      else if ( cmpRc > 0 )
      {  // target value only (delete)
         retval = this->ValueDel( pTrgValue->GetName() );
         pTrgValue = (RValue const *) eTrgValue.Next();
      }
      else /* if ( cmpRc == 0 ) */
      {  // identical value names (replicate)
         retval = this->ValueSet( pSrcValue->GetName(), pSrcValue->GetValue(),
               pSrcValue->GetValueLen(), pSrcValue->GetType() );
         pSrcValue = (RValue const *) eSrcValue.Next();
         pTrgValue = (RValue const *) eTrgValue.Next();
      }
   }

   eSrcValue.Close();
   eTrgValue.Close();

   // handle replication of keys at this level
   CollectKeys( &srcKeys, source );
   CollectKeys( &trgKeys, this );

   // now merge the values
   pSrcKey = (RKey const *) eSrcKey.OpenFirst( &srcKeys );
   pTrgKey = (RKey const *) eTrgKey.OpenFirst( &trgKeys );

   while ( !retval && (pSrcKey || pTrgKey) )
   {
      if ( !pTrgKey )
      {
         cmpRc = -1;
      }
      else if ( !pSrcKey )
      {
         cmpRc = 1;
      }
      else
      {
         cmpRc = UStrICmp( pSrcKey->GetName(), pTrgKey->GetName() );
      }
      if ( cmpRc < 0 )
      {  // source key only (copy hive)
         retval = srcNest.Open( pSrcKey->GetName(), source );
         if ( !retval )
         {
            retval = trgNest.Create( pSrcKey->GetName(), this );
            if ( !retval )
            {
               retval = trgNest.HiveCopy( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
         pSrcKey = (RKey const *) eSrcKey.Next();
      }
      else if ( cmpRc > 0 )
      {  // target key only (delete hive)
         retval = trgNest.Open( pTrgKey->GetName(), this );
         if ( !retval )
         {
            retval = trgNest.HiveDel();
            trgNest.Close();
         }
         retval = SubKeyDel( pTrgKey->GetName() );
         pTrgKey = (RKey const *) eTrgKey.Next();
      }
      else /* if ( cmpRc == 0 ) */
      {  // identical keys (replicate hive)
         retval = srcNest.Open( pSrcKey->GetName(), source );
         if ( !retval )
         {
            retval = trgNest.Open( pSrcKey->GetName(), this );
            if ( !retval )
            {
               retval = trgNest.HiveReplicate( &srcNest );
               trgNest.Close();
            }
            srcNest.Close();
         }
         pSrcKey = (RKey const *) eSrcKey.Next();
         pTrgKey = (RKey const *) eTrgKey.Next();
      }
   }

   eSrcKey.Close();
   eTrgKey.Close();

   return retval;
}

// TReg.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\lsaparammacros.h ===
//
// Macros for setting fields in an SE_AUDIT_PARAMETERS array.
//
// These must be kept in sync with identical macros in ds\security\base\lsa\server\adtp.h.
//


#define LsapSetParmTypeSid( AuditParameters, Index, Sid )                      \
    {                                                                          \
        if( Sid ) {                                                            \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeSid;         \
        (AuditParameters).Parameters[(Index)].Length = RtlLengthSid( (Sid) );  \
        (AuditParameters).Parameters[(Index)].Address = (Sid);                 \
                                                                               \
        } else {                                                               \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNone;        \
        (AuditParameters).Parameters[(Index)].Length = 0;                      \
        (AuditParameters).Parameters[(Index)].Address = NULL;                  \
                                                                               \
        }                                                                      \
    }


#define LsapSetParmTypeAccessMask( AuditParameters, Index, AccessMask, ObjectTypeIndex ) \
    {                                                                                    \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeAccessMask;            \
        (AuditParameters).Parameters[(Index)].Length = sizeof( ACCESS_MASK );            \
        (AuditParameters).Parameters[(Index)].Data[0] = (AccessMask);                    \
        (AuditParameters).Parameters[(Index)].Data[1] = (ObjectTypeIndex);               \
    }



#define LsapSetParmTypeString( AuditParameters, Index, String )                \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeString;      \
        (AuditParameters).Parameters[(Index)].Length =                         \
                sizeof(UNICODE_STRING)+(String)->Length;                       \
        (AuditParameters).Parameters[(Index)].Address = (String);              \
    }



#define LsapSetParmTypeUlong( AuditParameters, Index, Ulong )                  \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define LsapSetParmTypeHexUlong( AuditParameters, Index, Ulong )                  \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeHexUlong;       \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (Ulong) );     \
        (AuditParameters).Parameters[(Index)].Data[0] = (ULONG)(Ulong);        \
    }

#define LsapSetParmTypeNoLogon( AuditParameters, Index )                       \
    {                                                                          \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeNoLogonId;   \
    }



#define LsapSetParmTypeLogonId( AuditParameters, Index, LogonId )              \
    {                                                                          \
        PLUID TmpLuid;                                                         \
                                                                               \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypeLogonId;     \
        (AuditParameters).Parameters[(Index)].Length =  sizeof( (LogonId) );   \
        TmpLuid = (PLUID)(&(AuditParameters).Parameters[(Index)].Data[0]);     \
        *TmpLuid = (LogonId);                                                  \
    }


#define LsapSetParmTypePrivileges( AuditParameters, Index, Privileges )                      \
    {                                                                                        \
        (AuditParameters).Parameters[(Index)].Type = SeAdtParmTypePrivs;                     \
        (AuditParameters).Parameters[(Index)].Length = LsapPrivilegeSetSize( (Privileges) ); \
        (AuditParameters).Parameters[(Index)].Address = (Privileges);                        \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\admtcrypt2.h ===
#pragma once

#include <TChar.h>
#include <Windows.h>
#include <WinCrypt.h>
#include <ComDef.h>


HCRYPTPROV __stdcall AdmtAcquireContext();
void __stdcall AdmtReleaseContext(HCRYPTPROV hProvider);

HCRYPTKEY __stdcall AdmtImportSessionKey(HCRYPTPROV hProvider, const _variant_t& vntEncryptedSessionBytes);

_bstr_t __stdcall AdmtDecrypt(HCRYPTKEY hKey, const _variant_t& vntEncrypted);
void __stdcall AdmtDestroyKey(HCRYPTKEY hKey);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\mschapp.h ===
/*++

Copyright (C) Microsoft Corporation, 1999

Module Name:

    mschapp - MS-CHAP Password Change API

Abstract:

    These APIs correspond to the MS-CHAP RFC -2433 sections 9 and 10. In order
    to develop an MS-CHAP RAS server that works with an NT domain, these APIs
    are required.

    The MS-CHAP change password APIs are exposed through a DLL that is obtained
    from PSS. This DLL is not distributed with NT4.0 or Win2000. It is up to
    the ISV to install this with their product. The DLL name is MSCHAPP.DLL.

    Only wide (Unicode) versions of these apis will be available. These are the
    2 callable APIs:

    *   MSChapSrvChangePassword
    *   MsChapSrvChangePassword2

Author:

    Doug Barlow (dbarlow) 10/12/1999

Remarks:

    Per original definition by John Brezak

Notes:

    ?Notes?

--*/

#ifndef _MSCHAPP_H_
#define _MSCHAPP_H_
#ifdef __cplusplus
extern "C" {
#endif


//
// The following definitions are copied from the crypt.h internal header
// file.  The definitions are duplicated here to simplify linkages.
//

#ifndef _NTCRYPT_
#define CYPHER_BLOCK_LENGTH         8

typedef struct _CYPHER_BLOCK {
    CHAR    data[CYPHER_BLOCK_LENGTH];
}                                   CYPHER_BLOCK;
typedef struct _LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
}                                   LM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
//#endif

#define SAM_MAX_PASSWORD_LENGTH     (256)
typedef struct _SAMPR_ENCRYPTED_USER_PASSWORD {
    UCHAR Buffer[ (SAM_MAX_PASSWORD_LENGTH * 2) + 4 ];
} SAMPR_ENCRYPTED_USER_PASSWORD, *PSAMPR_ENCRYPTED_USER_PASSWORD;

typedef struct _ENCRYPTED_LM_OWF_PASSWORD {
    CYPHER_BLOCK data[2];
} ENCRYPTED_LM_OWF_PASSWORD;
typedef ENCRYPTED_LM_OWF_PASSWORD * PENCRYPTED_LM_OWF_PASSWORD;

typedef ENCRYPTED_LM_OWF_PASSWORD   ENCRYPTED_NT_OWF_PASSWORD;
typedef ENCRYPTED_NT_OWF_PASSWORD * PENCRYPTED_NT_OWF_PASSWORD;
#endif


//
// Change a password.
//

extern NTSTATUS WINAPI
MSChapSrvChangePassword(
   IN LPWSTR ServerName,
   IN LPWSTR UserName,
   IN BOOLEAN LmOldPresent,
   IN PLM_OWF_PASSWORD LmOldOwfPassword,
   IN PLM_OWF_PASSWORD LmNewOwfPassword,
   IN PNT_OWF_PASSWORD NtOldOwfPassword,
   IN PNT_OWF_PASSWORD NtNewOwfPassword);


//
// Change a password using mutual encryption.
//

extern NTSTATUS WINAPI
MSChapSrvChangePassword2(
    IN LPWSTR ServerName,
    IN LPWSTR UserName,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldNt,
    IN PENCRYPTED_NT_OWF_PASSWORD OldNtOwfPasswordEncryptedWithNewNt,
    IN BOOLEAN LmPresent,
    IN PSAMPR_ENCRYPTED_USER_PASSWORD NewPasswordEncryptedWithOldLm,
    IN PENCRYPTED_LM_OWF_PASSWORD OldLmOwfPasswordEncryptedWithNewLmOrNt);

#ifdef __cplusplus
}
#endif
#endif // _MSCHAPP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\admtcrypt2.cpp ===
//#include <StdAfx.h>
#include "AdmtCrypt.h"

#include <NtSecApi.h>

#pragma comment( lib, "AdvApi32.lib" )


namespace AdmtCrypt2
{

#define SESSION_KEY_SIZE    16 // in bytes

HCRYPTKEY __stdcall DeriveEncryptionKey(HCRYPTPROV hProvider);
bool __stdcall IsDataMatchHash(HCRYPTPROV hProvider, const _variant_t& vntData, const _variant_t& vntHash);

// Provider Methods

HCRYPTKEY __stdcall DeriveKey(HCRYPTPROV hProvider, const _variant_t& vntBytes);
HCRYPTHASH __stdcall CreateHash(HCRYPTPROV hProvider);
bool __stdcall GenRandom(HCRYPTPROV hProvider, BYTE* pbData, DWORD cbData);

// Key Methods

void __stdcall DestroyKey(HCRYPTKEY hKey);
bool __stdcall Decrypt(HCRYPTKEY hKey, const _variant_t& vntEncrypted, _variant_t& vntDecrypted);

// Hash Methods

void __stdcall DestroyHash(HCRYPTHASH hHash);
bool __stdcall HashData(HCRYPTHASH hHash, const _variant_t& vntData);

// Miscellaneous Helpers

bool __stdcall RetrieveEncryptionBytes(_variant_t& vntBytes);

// Variant Helpers

bool __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray);

}

using namespace AdmtCrypt2;


//---------------------------------------------------------------------------
// Source Crypt API
//---------------------------------------------------------------------------


// AdmtAcquireContext Method

HCRYPTPROV __stdcall AdmtAcquireContext()
{
	HCRYPTPROV hProvider = 0;

	BOOL bAcquire = CryptAcquireContext(
		&hProvider,
		NULL,
		MS_ENHANCED_PROV,
		PROV_RSA_FULL,
		CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT
	);

	if (!bAcquire)
	{
		hProvider = 0;
	}

	return hProvider;
}


// AdmtReleaseContext Method

void __stdcall AdmtReleaseContext(HCRYPTPROV hProvider)
{
	if (hProvider)
	{
		CryptReleaseContext(hProvider, 0);
	}
}


// AdmtImportSessionKey Method

HCRYPTKEY __stdcall AdmtImportSessionKey(HCRYPTPROV hProvider, const _variant_t& vntEncryptedSessionBytes)
{
	HCRYPTKEY hSessionKey = 0;

	if (hProvider && (vntEncryptedSessionBytes.vt == (VT_UI1|VT_ARRAY)) && ((vntEncryptedSessionBytes.parray != NULL)))
	{
		HCRYPTKEY hEncryptionKey = DeriveEncryptionKey(hProvider);

		if (hEncryptionKey)
		{
			_variant_t vntDecryptedSessionBytes;

			if (Decrypt(hEncryptionKey, vntEncryptedSessionBytes, vntDecryptedSessionBytes))
			{
				if (vntDecryptedSessionBytes.parray->rgsabound[0].cElements > SESSION_KEY_SIZE)
				{
					// extract session key bytes

					_variant_t vntBytes;

					if (CreateByteArray(SESSION_KEY_SIZE, vntBytes))
					{
						memcpy(vntBytes.parray->pvData, vntDecryptedSessionBytes.parray->pvData, SESSION_KEY_SIZE);

						// extract hash of session key bytes

						_variant_t vntHashValue;

						DWORD cbHashValue = vntDecryptedSessionBytes.parray->rgsabound[0].cElements - SESSION_KEY_SIZE;

						if (CreateByteArray(cbHashValue, vntHashValue))
						{
							memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecryptedSessionBytes.parray->pvData + SESSION_KEY_SIZE, cbHashValue);

							if (IsDataMatchHash(hProvider, vntBytes, vntHashValue))
							{
								hSessionKey = DeriveKey(hProvider, vntBytes);
							}
						}
					}
				}
				else
				{
					SetLastError(ERROR_INVALID_PARAMETER);
				}
			}

			DestroyKey(hEncryptionKey);
		}
	}
	else
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}

	return hSessionKey;
}


// AdmtDecrypt Method

_bstr_t __stdcall AdmtDecrypt(HCRYPTKEY hSessionKey, const _variant_t& vntEncrypted)
{
	BSTR bstr = NULL;

	_variant_t vntDecrypted;

	if (Decrypt(hSessionKey, vntEncrypted, vntDecrypted))
	{
		HRESULT hr = BstrFromVector(vntDecrypted.parray, &bstr);

		if (FAILED(hr))
		{
			SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		}
	}

	return bstr;
}


// AdmtDestroyKey Method

void __stdcall AdmtDestroyKey(HCRYPTKEY hKey)
{
	DestroyKey(hKey);
}


//---------------------------------------------------------------------------
// Private Helpers
//---------------------------------------------------------------------------


namespace AdmtCrypt2
{


HCRYPTKEY __stdcall DeriveEncryptionKey(HCRYPTPROV hProvider)
{
	HCRYPTKEY hKey = 0;

	_variant_t vntBytes;

	if (RetrieveEncryptionBytes(vntBytes))
	{
		hKey = DeriveKey(hProvider, vntBytes);
	}

	return hKey;
}


bool __stdcall IsDataMatchHash(HCRYPTPROV hProvider, const _variant_t& vntData, const _variant_t& vntHash)
{
	bool bMatch = false;

	HCRYPTHASH hHash = CreateHash(hProvider);

	if (hHash)
	{
		if (HashData(hHash, vntData))
		{
			DWORD dwSizeA;
			DWORD cbSize = sizeof(DWORD);

			if (CryptGetHashParam(hHash, HP_HASHSIZE, (BYTE*)&dwSizeA, &cbSize, 0))
			{
				DWORD dwSizeB = vntHash.parray->rgsabound[0].cElements;

				if (dwSizeA == dwSizeB)
				{
					try
					{
						BYTE* pbA = (BYTE*) _alloca(dwSizeA);

						if (CryptGetHashParam(hHash, HP_HASHVAL, pbA, &dwSizeA, 0))
						{
							BYTE* pbB = (BYTE*) vntHash.parray->pvData;

							if (memcmp(pbA, pbB, dwSizeA) == 0)
							{
								bMatch = true;
							}
						}
					}
					catch (...)
					{
						SetLastError(ERROR_NOT_ENOUGH_MEMORY);
					}
				}
			}
		}
	}

	return bMatch;
}


// Provider Methods


HCRYPTKEY __stdcall DeriveKey(HCRYPTPROV hProvider, const _variant_t& vntBytes)
{
	HCRYPTKEY hKey = 0;

	HCRYPTHASH hHash = CreateHash(hProvider);

	if (hHash)
	{
		if (HashData(hHash, vntBytes))
		{
			if (!CryptDeriveKey(hProvider, CALG_3DES, hHash, 0, &hKey))
			{
				hKey = 0;
			}
		}

		DestroyHash(hHash);
	}

	return hKey;
}


HCRYPTHASH __stdcall CreateHash(HCRYPTPROV hProvider)
{
	HCRYPTHASH hHash;

	if (!CryptCreateHash(hProvider, CALG_SHA1, 0, 0, &hHash))
	{
		hHash = 0;
	}

	return hHash;
}


bool __stdcall GenRandom(HCRYPTPROV hProvider, BYTE* pbData, DWORD cbData)
{
	return CryptGenRandom(hProvider, cbData, pbData) ? true : false;
}


// Key Methods --------------------------------------------------------------


// DestroyKey Method

void __stdcall DestroyKey(HCRYPTKEY hKey)
{
	if (hKey)
	{
		CryptDestroyKey(hKey);
	}
}


// Decrypt Method

bool __stdcall Decrypt(HCRYPTKEY hKey, const _variant_t& vntEncrypted, _variant_t& vntDecrypted)
{
	bool bDecrypted = false;

	_variant_t vnt = vntEncrypted;

	if ((vnt.vt == (VT_UI1|VT_ARRAY)) && (vnt.parray != NULL))
	{
		// decrypt data

		BYTE* pb = (BYTE*) vnt.parray->pvData;
		DWORD cb = vnt.parray->rgsabound[0].cElements;

		if (CryptDecrypt(hKey, NULL, TRUE, 0, pb, &cb))
		{
			// create decrypted byte array
			// the number of decrypted bytes may be less than
			// the number of encrypted bytes

			vntDecrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

			if (vntDecrypted.parray != NULL)
			{
				vntDecrypted.vt = VT_UI1|VT_ARRAY;

				memcpy(vntDecrypted.parray->pvData, vnt.parray->pvData, cb);

				bDecrypted = true;
			}
			else
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			}
		}
	}
	else
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}

	return bDecrypted;
}


// Hash Methods -------------------------------------------------------------


// DestroyHash Method

void __stdcall DestroyHash(HCRYPTHASH hHash)
{
	if (hHash)
	{
		CryptDestroyHash(hHash);
	}
}


// HashData Method

bool __stdcall HashData(HCRYPTHASH hHash, const _variant_t& vntData)
{
	bool bHash = false;

	if ((vntData.vt == (VT_UI1|VT_ARRAY)) && ((vntData.parray != NULL)))
	{
		if (CryptHashData(hHash, (BYTE*)vntData.parray->pvData, vntData.parray->rgsabound[0].cElements, 0))
		{
			bHash = true;
		}
	}
	else
	{
		SetLastError(ERROR_INVALID_PARAMETER);
	}

	return bHash;
}


// Miscellaneous Helpers ----------------------------------------------------


// RetrieveEncryptionBytes Method

bool __stdcall RetrieveEncryptionBytes(_variant_t& vntBytes)
{
	// private data key identifier
	_TCHAR c_szIdPrefix[] = _T("L$6A2899C0-CECE-459A-B5EB-7ED04DE61388");
	const USHORT c_cbIdPrefix = sizeof(c_szIdPrefix) - sizeof(_TCHAR);

	bool bRetrieve = false;

	// open policy object

	LSA_HANDLE hPolicy;

	LSA_OBJECT_ATTRIBUTES lsaoa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

	NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &lsaoa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

	if (LSA_SUCCESS(ntsStatus))
	{
		// retrieve data

		LSA_UNICODE_STRING lsausKey = { c_cbIdPrefix, c_cbIdPrefix, c_szIdPrefix };
		PLSA_UNICODE_STRING plsausData;

		ntsStatus = LsaRetrievePrivateData(hPolicy, &lsausKey, &plsausData);

		if (LSA_SUCCESS(ntsStatus))
		{
			vntBytes.Clear();

			vntBytes.parray = SafeArrayCreateVector(VT_UI1, 0, plsausData->Length);

			if (vntBytes.parray != NULL)
			{
				vntBytes.vt = VT_UI1|VT_ARRAY;

				memcpy(vntBytes.parray->pvData, plsausData->Buffer, plsausData->Length);

				bRetrieve = true;
			}
			else
			{
				SetLastError(ERROR_NOT_ENOUGH_MEMORY);
			}

			LsaFreeMemory(plsausData);
		}
		else
		{
			SetLastError(LsaNtStatusToWinError(ntsStatus));
		}

		// close policy object

		LsaClose(hPolicy);
	}
	else
	{
		SetLastError(LsaNtStatusToWinError(ntsStatus));
	}

	return bRetrieve;
}


// Variant Helpers ----------------------------------------------------------


// CreateByteArray Method

bool __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray)
{
	bool bCreate = false;

	vntByteArray.Clear();

	vntByteArray.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntByteArray.parray)
	{
		bCreate = true;
	}
	else
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
	}

	vntByteArray.vt = VT_UI1|VT_ARRAY;

	return bCreate;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\profext\treg.hpp ===
//#pragma title( "TReg.hpp - Registry class" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  TReg.hpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham, Jay Berlin
Created     -  1995-09-01
Description -  Registry class.
Updates     -
===============================================================================
*/

#ifndef  MCSINC_TReg_hpp
#define  MCSINC_TReg_hpp


class TRegKey
{
private:

   HKEY                      hKey;

public:

   TRegKey() { hKey = (HKEY)INVALID_HANDLE_VALUE; };
   TRegKey( HKEY hPreDefined, TCHAR const * machineName ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Connect( hPreDefined, machineName ); };
   TRegKey( TCHAR const * keyname, HKEY hParent = HKEY_LOCAL_MACHINE ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Open( keyname, hParent ); };
   TRegKey( TCHAR const * keyname, TRegKey const * regParent ) : hKey((HKEY)INVALID_HANDLE_VALUE) { Open( keyname, regParent->hKey ); };
   ~TRegKey();

   DWORD Connect( HKEY hPreDefined, TCHAR const * machineName );

   DWORD Open( TCHAR const * keyname, TRegKey const * regParent, DWORD access = KEY_ALL_ACCESS ) { return Open( keyname, regParent->hKey, access ); };
   DWORD Open( TCHAR const * keyname, HKEY hParent = HKEY_LOCAL_MACHINE, DWORD access = KEY_ALL_ACCESS );
   DWORD OpenRead( TCHAR const * keyname, TRegKey const * regParent ) { return Open( keyname, regParent->hKey, KEY_READ ); };
   DWORD OpenRead( TCHAR const * keyname, HKEY hParent = HKEY_LOCAL_MACHINE ) { return Open( keyname, hParent, KEY_READ ); };

   DWORD Create( TCHAR const * keyname, TRegKey const * regParent, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS ) { return Create( keyname, regParent->hKey, pDisp, access ); };
   DWORD Create( TCHAR const * keyname, HKEY hParent = HKEY_LOCAL_MACHINE, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS );
   DWORD CreateBR( TCHAR const * keyname, TRegKey const * regParent, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS ) { return CreateBR( keyname, regParent->hKey, pDisp, access ); };
   DWORD CreateBR( TCHAR const * keyname, HKEY hParent = HKEY_LOCAL_MACHINE, DWORD * pDisp = NULL, DWORD access = KEY_ALL_ACCESS );

   HKEY KeyGet() { return hKey; }

   void Close();

   DWORD SubKeyDel( TCHAR const * keyname ) const { return RegDeleteKey( hKey, keyname ); };
   DWORD SubKeyEnum( DWORD index, TCHAR * keyname, DWORD keylen ) const;

// Note that "namelen" must be "sizeof name", not "DIM(name)"
// Same for "valuelen"

   DWORD ValueEnum( DWORD index, TCHAR * name, DWORD namelen, void * value, DWORD * valuelen, DWORD * valuetype ) const;

   DWORD ValueGet( TCHAR const * name, void * value, DWORD * lenvalue, DWORD * typevalue ) const;
   DWORD ValueGetDWORD( TCHAR const * name, DWORD * value ) const;
   DWORD ValueGetStr( TCHAR const * name, TCHAR * value, DWORD maxlen ) const;

   DWORD ValueSet( TCHAR const * name, void const * value, DWORD lenvalue, DWORD typevalue ) const;
   DWORD ValueSetDWORD( TCHAR const * name, DWORD value) const { return ValueSet(name, &value, sizeof value, REG_DWORD); }
   DWORD ValueSetStr( TCHAR const * name, TCHAR const * value, DWORD type = REG_SZ ) const;

   DWORD ValueDel( TCHAR const * name = NULL ) const;

   DWORD HiveCopy( TRegKey const * source );
   DWORD HiveDel();
   DWORD HiveReplicate( TRegKey const * source );
};

#endif // MCSINC_TReg.hpp

// TReg.hpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\pwd.h ===
/* common includes for this dll */
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#include <nt.h>
#include <ntrtl.h>      // DbgPrint prototype
#include <nturtl.h>     // needed for winbase.h
#include <rpc.h>        // DataTypes and runtime APIs
#include <string.h>     // strlen
#include <stdio.h>      // sprintf
//#include <ntrpcp.h>     // prototypes for MIDL user functions
#include <samrpc.h>     // midl generated SAM RPC definitions
#include <ntlsa.h>
#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
extern "C"{
#include <samisrv.h>    // SamIConnect()
}

#include <ntsam.h>
#include <ntsamp.h>
#include <samsrv.h>     // prototypes available to security process

#include <lsarpc.h>
//#include <lsaisrv.h>
#include <ntrmlsa.h>
#include <ntseapi.h>
#include <ntpsapi.h>
#include <ntobapi.h>
#include <rpcdcep.h>
#include <ntexapi.h>
#include <ntregapi.h>
#include "msaudite.h"
#include "LsaParamMacros.h"

extern "C"{
#include "mschapp.h"
}

#pragma comment(lib, "vccomsup.lib")

/* common functions for this dll */
//NTSTATUS __stdcall GetDomainHandle(SAMPR_HANDLE *pDomainHandle);

extern CRITICAL_SECTION	csADMTCriticalSection; //critical sectio to protect concurrent first-time access
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by PwdSvc.rc
//
#define IDS_EVENT_PWD_HASH_RETRIEVAL    1
#define IDS_EVENT_PWD_HASH_W2K_EXPLAIN  2

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\pwdrpc.cpp ===
/*---------------------------------------------------------------------------
  File: PwdRpc.cpp

  Comments:  RPC interface for Password Migration Lsa Notification Package
             and other internal functions.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/04/00

 ---------------------------------------------------------------------------
*/


#include "Pwd.h"
#include <lmcons.h>
#include <comdef.h>
#include <malloc.h>
#include "PwdSvc.h"
#include "McsDmMsg.h"
#include "AdmtCrypt2.h"
#include "pwdfuncs.h"
#include "TReg.hpp"
#include "IsAdmin.hpp"
#include "ResStr.h"
#include "TxtSid.h"
#include "resource.h"
#include <MsPwdMig.h>

/* global definitions */
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
#define STATUS_NULL_LM_PASSWORD          ((NTSTATUS)0x4000000DL)
#define LM_BUFFER_LENGTH    (LM20_PWLEN + 1)
typedef NTSTATUS (CALLBACK * LSAIWRITEAUDITEVENT)(PSE_ADT_PARAMETER_ARRAY, ULONG);

/* global variables */
CRITICAL_SECTION	csADMTCriticalSection; //critical sectio to protect concurrent first-time access
SAMPR_HANDLE		hgDomainHandle = NULL; //domain handle used in password calls
LM_OWF_PASSWORD		NullLmOwfPassword; //NULL representation of an LM Owf Password
NT_OWF_PASSWORD		NullNtOwfPassword; //NULL representation of an NT Owf Password
HCRYPTPROV g_hProvider = 0;
HCRYPTKEY g_hSessionKey = 0;
HANDLE	hEventSource;
HMODULE hLsaDLL = NULL;
LSAIWRITEAUDITEVENT LsaIWriteAuditEvent = NULL;
PWCHAR	pDomain = NULL;
BOOL LsapCrashOnAuditFail = TRUE;
int nOSVer = 4;
BOOL bWhistlerDC = FALSE;


/* Checks if this machine is running Whistler OS or something even newer and the OS major verison number, sets global variables accordingly */
void GetOS()
{
/* local constants */
   const int	WINDOWS_2000_BUILD_NUMBER = 2195;

/* local variables */
   TRegKey		verKey, regComputer;
   DWORD		rc = 0;
   WCHAR		sBuildNum[MAX_PATH];

/* function body */
	  //connect to the DC's HKLM registry key
   rc = regComputer.Connect(HKEY_LOCAL_MACHINE, NULL);
   if (rc == ERROR_SUCCESS)
   {
         //see if this machine is running Windows XP or newer by checking the
		 //build number in the registry.  If not, then we don't need to check
		 //for the new security option
      rc = verKey.OpenRead(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion",&regComputer);
	  if (rc == ERROR_SUCCESS)
	  {
			//get the CurrentBuildNumber string
	     rc = verKey.ValueGetStr(L"CurrentBuildNumber", sBuildNum, MAX_PATH);
		 if (rc == ERROR_SUCCESS) 
		 {
			int nBuild = _wtoi(sBuildNum);
		    if (nBuild <= WINDOWS_2000_BUILD_NUMBER)
               bWhistlerDC = FALSE;
			else
               bWhistlerDC = TRUE;
		 }
			//get the Version Number
	     rc = verKey.ValueGetStr(L"CurrentVersion", sBuildNum, MAX_PATH);
		 if (rc == ERROR_SUCCESS) 
			nOSVer = _wtoi(sBuildNum);
	  }
   }
   return;
}


_bstr_t GetString(DWORD dwID)
{
/* local variables */
	HINSTANCE		m_hInstance = NULL;
	WCHAR			sBuffer[1000];
	int				len;
	_bstr_t			bstrRet;
	
/* function body */
	m_hInstance = LoadLibrary(L"PwMig.dll");

    len = LoadString(m_hInstance, dwID, sBuffer, 1000);
	bstrRet = sBuffer;
	if (m_hInstance)
		FreeLibrary(m_hInstance);
	return bstrRet;
}


/***************************
 * Event Logging Functions *
 ***************************/

 
/*++

Routine Description:

    Implements current policy of how to deal with a failed audit.

Arguments:

    None.

Return Value:

    None.

--*/
void LsapAuditFailed(NTSTATUS AuditStatus)
{
/* local variables */
    NTSTATUS	Status;
    ULONG		Response;
    ULONG_PTR	HardErrorParam;
    BOOLEAN		PrivWasEnabled;
	TRegKey		verKey, regComputer;
	DWORD		rc = 0;
	WCHAR		sBuildNum[MAX_PATH];
	DWORD		crashVal;
	BOOL		bRaiseError = FALSE;


/* function body */
		//connect to this machine's HKLM registry key
	rc = regComputer.Connect(HKEY_LOCAL_MACHINE, NULL);
	if (rc == ERROR_SUCCESS)
	{
         //open the LSA key and see if crash on audit failed is turned on
		rc = verKey.Open(L"SYSTEM\\CurrentControlSet\\Control\\Lsa",&regComputer);
		if (rc == ERROR_SUCCESS)
		{
				//get the CrashOnAuditFail value
			rc = verKey.ValueGetDWORD(CRASH_ON_AUDIT_FAIL_VALUE, &crashVal);
			if (rc == ERROR_SUCCESS) 
			{ 
				   //if crash on audit fail is set, turn off the flag
				if (crashVal == LSAP_CRASH_ON_AUDIT_FAIL)
				{
					bRaiseError = TRUE; //set flag to raise hard error
					rc = verKey.ValueSetDWORD(CRASH_ON_AUDIT_FAIL_VALUE, LSAP_ALLOW_ADIMIN_LOGONS_ONLY);
					if (rc == ERROR_SUCCESS)
					{
							//flush the key to disk
						do 
						{
							Status = NtFlushKey(verKey.KeyGet());
						} while ((Status == STATUS_INSUFFICIENT_RESOURCES) || (Status == STATUS_NO_MEMORY));
						ASSERT(NT_SUCCESS(Status));
					}
				}
			}
		}
	}

		//if needed,  raise a hard error
	if (bRaiseError)
	{
		HardErrorParam = AuditStatus;

			// enable the shutdown privilege so that we can bugcheck
		Status = RtlAdjustPrivilege(SE_SHUTDOWN_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled);

		Status = NtRaiseHardError(
						 STATUS_AUDIT_FAILED,
						 1,
						 0,
						 &HardErrorParam,
						 OptionShutdownSystem,
						 &Response);
	}
	return;
}


/*Routine Description:

    Find out if auditing is enabled for a certain event category and
    event success/failure case.

Arguments:

    AuditCategory - Category of event to be audited.
        e.g. AuditCategoryPolicyChange

    AuditEventType - status type of event
        e.g. EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE

Return Value:

    TRUE or FALSE
*/
BOOL LsapAdtIsAuditingEnabledForCategory(POLICY_AUDIT_EVENT_TYPE AuditCategory,
										 UINT AuditEventType)
{
   BOOL						 bSuccess = FALSE;
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   NTSTATUS                  status = 0;
   LSA_HANDLE                hPolicy;
    
   ASSERT((AuditEventType == EVENTLOG_AUDIT_SUCCESS) ||
          (AuditEventType == EVENTLOG_AUDIT_FAILURE));

      //attempt to open the policy.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));//object attributes are reserved, so initalize to zeroes.
   status = LsaOpenPolicy(	NULL,
							&ObjectAttributes,
							POLICY_ALL_ACCESS, 
							&hPolicy);  //recieves the policy handle

   if (NT_SUCCESS(status))
   {
         //ask for audit event policy information
      PPOLICY_AUDIT_EVENTS_INFO   info;
      status = LsaQueryInformationPolicy(hPolicy, PolicyAuditEventsInformation, (PVOID *)&info);
      if (NT_SUCCESS(status))
      {
		    //if auditing is enabled, see if enable for this type
		 if (info->AuditingMode)
		 {
			POLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
			EventAuditingOptions = info->EventAuditingOptions[AuditCategory];

			bSuccess = (AuditEventType == EVENTLOG_AUDIT_SUCCESS) ?
						(BOOL) (EventAuditingOptions & POLICY_AUDIT_EVENT_SUCCESS):
						(BOOL) (EventAuditingOptions & POLICY_AUDIT_EVENT_FAILURE);
		 }

		 LsaFreeMemory((PVOID) info); //free policy info structure
      }
      
      LsaClose(hPolicy); //Freeing the policy object handle
   }
    
   return bSuccess;
}


/*++

Routine Description:

    This routine impersonates our client, opens the thread token, and
    extracts the User Sid.  It puts the Sid in memory allocated via
    LsapAllocateLsaHeap, which must be freed by the caller.

Arguments:

    None.

Return Value:

    Returns a pointer to heap memory containing a copy of the Sid, or
    NULL.

--*/
NTSTATUS LsapQueryClientInfo(PTOKEN_USER *UserSid, PLUID AuthenticationId)
{
	NTSTATUS Status = STATUS_SUCCESS;
    HANDLE TokenHandle;
    ULONG ReturnLength;
    TOKEN_STATISTICS TokenStats;

	   //impersonate the caller
    Status = I_RpcMapWin32Status(RpcImpersonateClient(NULL));

    if (!NT_SUCCESS(Status))
        return( Status );

	   //open the thread token
    Status = NtOpenThreadToken(
                     NtCurrentThread(),
                     TOKEN_QUERY,
                     TRUE,                    // OpenAsSelf
                     &TokenHandle);

    if (!NT_SUCCESS(Status))
	{
		I_RpcMapWin32Status(RpcRevertToSelf());
        return( Status );
	}

	   //revert to self
    Status = I_RpcMapWin32Status(RpcRevertToSelf());
	ASSERT(NT_SUCCESS(Status));

	   //get the size of the token information
    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 NULL,
                 0,
                 &ReturnLength);

    if (Status != STATUS_BUFFER_TOO_SMALL) 
	{
        NtClose(TokenHandle);
        return( Status );
    }

	   //allocate memory to hold the token info
    *UserSid = (PTOKEN_USER)malloc(ReturnLength);

    if (*UserSid == NULL) 
	{
        NtClose(TokenHandle);
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

	   //get the token info
    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenUser,
                 *UserSid,
                 ReturnLength,
                 &ReturnLength);


    if (!NT_SUCCESS(Status)) 
	{
        NtClose(TokenHandle);
        free(*UserSid);
        *UserSid = NULL;
        return( Status );
    }

	   //get the authentication ID
	ReturnLength = 0;
    Status = NtQueryInformationToken (
                 TokenHandle,
                 TokenStatistics,
                 (PVOID)&TokenStats,
                 sizeof(TOKEN_STATISTICS),
                 &ReturnLength);

    NtClose(TokenHandle);

    if (!NT_SUCCESS(Status)) 
	{
        free(*UserSid);
        *UserSid = NULL;
        return( Status );
    }

    *AuthenticationId = TokenStats.AuthenticationId;

	return Status;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 23 APR 2001                                                 *
 *                                                                   *
 *     This function is responsible for generating a                 *
 * SE_AUDITID_PASSWORD_HASH_ACCESS event in the security log. This   *
 * function is called to generate that message when a user password  *
 * hash is retrieved by the ADMT password filter DLL.                *
 * All these event logging functions are copied and modified from LSA*
 * code written by others.                                           *
 *                                                                   *
 * Parameters:                                                       *
 * EventType - EVENTLOG_AUDIT_SUCCESS or EVENTLOG_AUDIT_FAILURE      *
 * pszTargetUserName - name of user whose password is being retrieved*
 * pszTargetUserDomain - domain of user whose password is being      *
 *                       retrieved                                   *
 *                                                                   *
 * Return Value:                                                     *
 * HRESULT - Standard Return Result                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN LsaAuditPasswordAccessEvent
HRESULT LsaAuditPasswordAccessEvent(USHORT EventType, 
									PCWSTR pszTargetUserName,
									PCWSTR pszTargetUserDomain)
{
/* local constants */
	const int W2K_VERSION_NUMBER = 5;

/* local variables */
	HRESULT hr = S_OK;   
    NTSTATUS Status = STATUS_SUCCESS;
    LUID ClientAuthenticationId;
    PTOKEN_USER TokenUserInformation=NULL;
    SE_ADT_PARAMETER_ARRAY AuditParameters = { 0 };
    PSE_ADT_PARAMETER_ARRAY_ENTRY Parameter;
    UNICODE_STRING TargetUser;
    UNICODE_STRING TargetDomain;
    UNICODE_STRING SubsystemName;
    UNICODE_STRING Explanation;
	_bstr_t sExplainText;

/* function body */
		//if parameters are invalid, return
    if ( !((EventType == EVENTLOG_AUDIT_SUCCESS) ||
           (EventType == EVENTLOG_AUDIT_FAILURE))   ||
         !pszTargetUserName  || !pszTargetUserDomain ||
         !*pszTargetUserName || !*pszTargetUserDomain )
    {
		return (HRESULT_FROM_WIN32(LsaNtStatusToWinError(STATUS_INVALID_PARAMETER)));
    }

		//if auditing is not enabled, return asap
    if (!LsapAdtIsAuditingEnabledForCategory(AuditCategoryAccountManagement, EventType))
		return S_OK;

    // get caller info from the thread token
    Status = LsapQueryClientInfo( &TokenUserInformation, &ClientAuthenticationId );
    if (!NT_SUCCESS( Status ))
    {
        LsapAuditFailed(Status);
		return (HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status)));
    }

	   //If Whistler, init parameters and write event
	if (bWhistlerDC)
	{
			//init UNICODE_STRINGS
		RtlInitUnicodeString(&TargetUser, pszTargetUserName);
		RtlInitUnicodeString(&TargetDomain, pszTargetUserDomain);
		RtlInitUnicodeString(&SubsystemName, L"Security");

			//set the audit paramter header information
		RtlZeroMemory((PVOID) &AuditParameters, sizeof(AuditParameters));
//		AuditParameters.CategoryId     = SE_CATEGID_ACCOUNT_MANAGEMENT;
		AuditParameters.CategoryId     = AuditCategoryAccountManagement;
		AuditParameters.AuditId        = SE_AUDITID_PASSWORD_HASH_ACCESS;
		AuditParameters.Type           = EventType;

			//now set the audit parameters for this OS.  Parameters are added to the structure using macros 
			//defined in LsaParamMacros.h
		AuditParameters.ParameterCount = 0;
		LsapSetParmTypeSid(AuditParameters, AuditParameters.ParameterCount, TokenUserInformation->User.Sid);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &SubsystemName);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &TargetUser);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &TargetDomain);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeLogonId(AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId);
		AuditParameters.ParameterCount++;

			//Write to the security log
	    Status = LsaIWriteAuditEvent(&AuditParameters, 0);
	    if (!NT_SUCCESS(Status))
		      LsapAuditFailed(Status);

		//do not free the TargetUser string since it is still being used
		//do not free the TargetDomain string since it is a global variable
		RtlFreeUnicodeString(&SubsystemName);
	}//end if Whistler

	   //else if W2K, init parameters and write event
	else if ((!bWhistlerDC) && (nOSVer == W2K_VERSION_NUMBER))
	{
			//init UNICODE_STRINGS
		RtlInitUnicodeString(&TargetUser, pszTargetUserName);
		RtlInitUnicodeString(&TargetDomain, pszTargetUserDomain);
		RtlInitUnicodeString(&SubsystemName, L"Security");
			//if not Whistler the audit message will be vague as to its intent, therefore we will add some 
			//explanation text
		sExplainText = GetString(IDS_EVENT_PWD_HASH_W2K_EXPLAIN);
		RtlInitUnicodeString(&Explanation, (WCHAR*)sExplainText);

			//set the audit paramter header information
		RtlZeroMemory((PVOID) &AuditParameters, sizeof(AuditParameters));
//		AuditParameters.CategoryId     = SE_CATEGID_ACCOUNT_MANAGEMENT;
		AuditParameters.CategoryId     = AuditCategoryAccountManagement;
		AuditParameters.AuditId        = SE_AUDITID_PASSWORD_HASH_ACCESS;
		AuditParameters.Type           = EventType;

			//now set the audit parameters for this OS.  Parameters are added to the structure using macros 
			//defined in LsaParamMacros.h
		AuditParameters.ParameterCount = 0;
		LsapSetParmTypeSid(AuditParameters, AuditParameters.ParameterCount, TokenUserInformation->User.Sid);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &SubsystemName);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &TargetUser);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &TargetDomain);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeLogonId(AuditParameters, AuditParameters.ParameterCount, ClientAuthenticationId);
		AuditParameters.ParameterCount++;
		LsapSetParmTypeString(AuditParameters, AuditParameters.ParameterCount, &Explanation);
		AuditParameters.ParameterCount++;

			//Write to the security log
	    Status = LsaIWriteAuditEvent(&AuditParameters, 0);
	    if (!NT_SUCCESS(Status))
		      LsapAuditFailed(Status);

		//do not free the TargetUser string since it is still being used
		//do not free the TargetDomain string since it is a global variable
		RtlFreeUnicodeString(&SubsystemName);
		RtlFreeUnicodeString(&Explanation);
	}//end if Whistler


    if (TokenUserInformation != NULL) 
        free(TokenUserInformation);
		      
	return (HRESULT_FROM_WIN32(LsaNtStatusToWinError(Status)));
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the caller's sid. *
 * We will use this prior to logging an event log.                   *
 *                                                                   *
 *********************************************************************/

//BEGIN GetCallerSid
DWORD GetCallerSid(PSID *pCallerSid)
{
/* local variables */
   DWORD                     rc, rc2;
   HANDLE                    hToken = NULL;
   TOKEN_USER                tUser[10];
   ULONG                     len;
   
/* function body */
   rc = (DWORD)RpcImpersonateClient(NULL);
   if (!rc)
   {
      if ( OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken) )
	  {
         if ( GetTokenInformation(hToken,TokenUser,tUser,10*(sizeof TOKEN_USER),&len) )
            *pCallerSid = (SID*)tUser[0].User.Sid;
         else
            rc = GetLastError();

         CloseHandle(hToken);
	  }
      else
         rc = GetLastError();

      rc2 = (DWORD)RpcRevertToSelf();
	  if (rc2)
	     rc = rc2;
   }

   return rc;
}
//END GetCallerSid


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 19 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for logging major events in Event*
 * Viewer.                                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN LogEvent
void LogPwdEvent(const WCHAR* srcName, bool bAuditSuccess)
{
/* local variables */
   USHORT					wType;
   DWORD					rc = 0;
   BOOL						rcBool;

/* function body */
   if (bAuditSuccess)
	  wType = EVENTLOG_AUDIT_SUCCESS;
   else
	  wType = EVENTLOG_AUDIT_FAILURE;

      //if NT4.0, write to the Security Event Log as you would any log
   if (nOSVer == 4)
   {
      PSID	pCallerSid = NULL;
	  GetCallerSid(&pCallerSid); //get the caller's SID
      if ((pCallerSid) && (hEventSource))
	  {
		 LPTSTR pStringArray[1];
		 WCHAR  msg[2000];
		 WCHAR  txtSid[MAX_PATH];
         DWORD  lenTxt = MAX_PATH;

		    //prepare the msg to display
         if (!GetTextualSid(pCallerSid,txtSid,&lenTxt))
			 wcscpy(txtSid, L"");
		 swprintf(msg, GetString(IDS_EVENT_PWD_HASH_RETRIEVAL), srcName, pDomain, txtSid);
		 pStringArray[0] = msg;

			//log the event
	     rcBool = ReportEventW(hEventSource,            // handle of event source
                            wType,                      // event type
							SE_CATEGID_ACCOUNT_MANAGEMENT,// event category
							SE_AUDITID_PASSWORD_HASH_ACCESS,// event ID
							NULL,                       // current user's SID
							1,                          // strings in lpszStrings
							0,                          // no bytes of raw data
							(LPCTSTR *)pStringArray,    // array of error strings
							NULL );                     // no raw data
         if ( !rcBool )
            rc = GetLastError();
	  }
   }
   else  //else write the event by requesting LSA to do it for us
   {
	     //if not already done, late bind to LsaIWriteAuditEvent since it is not present on an NT 4.0 box
	  if (!LsaIWriteAuditEvent)
	  {
	     hLsaDLL = LoadLibrary(L"LsaSrv.dll");
         if ( hLsaDLL )
            LsaIWriteAuditEvent = (LSAIWRITEAUDITEVENT)GetProcAddress(hLsaDLL, "LsaIWriteAuditEvent");
	  }

	  if (LsaIWriteAuditEvent)
         LsaAuditPasswordAccessEvent(wType, srcName, pDomain);
   }
}
//END LogEvent

/*******************************
 * Event Logging Functions End *
 *******************************/

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for obtaining the account domain *
 * sid.  This sid will be later used to Open the domain via SAM.     *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDomainSid
NTSTATUS GetDomainSid(PSID * pDomainSid)
{
/* local variables */
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   NTSTATUS                  status = 0;
   LSA_HANDLE                hPolicy;
   HRESULT                   hr = 0;

/* function body */
      //object attributes are reserved, so initalize to zeroes.
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
   

      //attempt to open the policy.
   status = LsaOpenPolicy(
                NULL,
                &ObjectAttributes,
                POLICY_ALL_ACCESS, 
                &hPolicy  //recieves the policy handle
                );

   if (NT_SUCCESS(status))
   {
         //ask for account domain policy information
      PPOLICY_ACCOUNT_DOMAIN_INFO   info;
      status = LsaQueryInformationPolicy(hPolicy, PolicyAccountDomainInformation, (PVOID *)&info);
      if (NT_SUCCESS(status))
      {
            //save the domain sid
         DWORD sidLen = GetLengthSid(info->DomainSid);
         *pDomainSid = new BYTE[sidLen];
		 if (*pDomainSid)
	        CopySid(sidLen, *pDomainSid, info->DomainSid);
		 else
		    status = STATUS_INSUFFICIENT_RESOURCES;

		    //save the domain name
		 USHORT uLen = info->DomainName.Length / sizeof(WCHAR);
		 pDomain = new WCHAR[uLen + sizeof(WCHAR)];
		 if (pDomain)
		 {
		    wcsncpy(pDomain, info->DomainName.Buffer, uLen);
			pDomain[uLen] = L'\0';
		 }

            //free policy info structure
         LsaFreeMemory((PVOID) info);
      }
      
      //Freeing the policy object handle
      LsaClose(hPolicy);
   }

   return status;
}
//END GetDomainSid


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for obtaining a domain handle    *
 * used repeatedly by our interface function CopyPassword.           *
 *     For optimization, this function should only be called once per*
 * the life of this dll.                                             *
 *      This function also gets an Event Handle to the event log.    *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDomainHandle
NTSTATUS GetDomainHandle(SAMPR_HANDLE *pDomainHandle)
{
/* local variables */
   PSID           pDomainSid;
   NTSTATUS       status;
   SAMPR_HANDLE   hServerHandle;
   SAMPR_HANDLE   hDomainHandle;

/* function body */
      //get the account domain sid
   status = GetDomainSid(&pDomainSid);

   if (NT_SUCCESS(status))
   {
	     //connect to the Sam and get a server handle
      status = SamIConnect(NULL, 
						   &hServerHandle, 
						   POLICY_ALL_ACCESS, 
						   TRUE);
      if (NT_SUCCESS(status))
	  {
		    //get the account domain handle
         status = SamrOpenDomain(hServerHandle,
								 POLICY_ALL_ACCESS,
								 (PRPC_SID)pDomainSid,
								 &hDomainHandle);
		 if (NT_SUCCESS(status))
		    *pDomainHandle = hDomainHandle;
		    //close the SamIConnect server handle
		 SamrCloseHandle(&hServerHandle);
	  }
      FreeSid(pDomainSid);
   }

   return status;
}
//END GetDomainHandle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the global domain *
 * handle.  If we don't have the handle yet, it calls the externally *
 * defined GetDomainHandle funtion to get the handle.  The handle    *
 * retrieval code is placed in a critical section.  Subsequent       *
 * calls to this functin merely return the handle.                   *
 *     I will also use this function to fill the global NULL         *
 * LmOwfPassword structure for possible use.  This should be done    *
 * one time only.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveDomainHandle
HRESULT RetrieveDomainHandle(SAMPR_HANDLE *pDomainHandle)
{
/* local constants */
  const WCHAR * svcName = L"Security";

/* local variables */
  NTSTATUS			status = 0;
  HRESULT			hr = ERROR_SUCCESS;

/* function body */
  __try
  {
	    //enter the critical section
     EnterCriticalSection(&csADMTCriticalSection);

	    //if not yet retrieved, get the global handle and fill the NULL
	    //LmOwfPassword structure
	 if (hgDomainHandle == NULL)
	 {
		   //get the domain handle
		status = GetDomainHandle(&hgDomainHandle);
	    if (NT_SUCCESS(status))
		   pDomainHandle = &hgDomainHandle;

		GetOS(); //set global variable as to whether this DC's OS

		   //if NT4.0 OS on this DC, then set the event handle for logging events
		if (nOSVer == 4)
		{
		   NTSTATUS Status;
		   BOOLEAN PrivWasEnabled;
			  //make sure we have audit and debug privileges
		   RtlAdjustPrivilege( SE_SECURITY_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );
		   RtlAdjustPrivilege( SE_DEBUG_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );
		   RtlAdjustPrivilege( SE_AUDIT_PRIVILEGE, TRUE, FALSE, &PrivWasEnabled );
		   //register this dll with the eventlog, get a handle, and store globally
		   hEventSource = RegisterEventSourceW(NULL, svcName);
		   if (!hEventSource)
			   DWORD rc = GetLastError();
		}


           //fill a global NULL LmOwfPassword in case we need it later
        WCHAR			sNtPwd[MAX_PATH] = L"";
        UNICODE_STRING	UnicodePwd;
        ANSI_STRING     LmPassword;
		CHAR			sBuf[LM_BUFFER_LENGTH];
        
        RtlInitUnicodeString(&UnicodePwd, sNtPwd);

           //fill LmOwf NULL password
        LmPassword.Buffer = (PCHAR)&sBuf;
        LmPassword.MaximumLength = LmPassword.Length = LM_BUFFER_LENGTH;
        RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );

        status = RtlUpcaseUnicodeStringToOemString( &LmPassword, &UnicodePwd, FALSE );
        if ( !NT_SUCCESS(status) ) 
		{
              //the password is longer than the max LM password length
           status = STATUS_NULL_LM_PASSWORD;
           RtlZeroMemory( LmPassword.Buffer, LM_BUFFER_LENGTH );
           RtlCalculateLmOwfPassword((PLM_PASSWORD)&LmPassword, &NullLmOwfPassword);
		}
		else
		{
           RtlCalculateLmOwfPassword((PLM_PASSWORD)&LmPassword, &NullLmOwfPassword);
	       RtlFreeOemString(&LmPassword);
		}

		   //fill NtOwf NULL password
        RtlCalculateNtOwfPassword((PNT_PASSWORD)&UnicodePwd, &NullNtOwfPassword);

        RtlFreeUnicodeString(&UnicodePwd);
	 }
  }
  __finally
  {
        // Release ownership and delete of the critical section
     LeaveCriticalSection(&csADMTCriticalSection);
  }

      //convert any error to a win error
  if (!NT_SUCCESS(status))
     hr = LsaNtStatusToWinError(status);

  return hr;
}
//END RetrieveDomainHandle


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for retrieving the passwords for *
 * the given user's source domain account.  We use SAM APIs to       *
 * retrieve the LmOwf and NtOwf formats of the password.             *
 *                                                                   *
 *********************************************************************/

//BEGIN RetrieveEncrytedSourcePasswords
HRESULT RetrieveEncrytedSourcePasswords(const WCHAR* srcName, 
										 PLM_OWF_PASSWORD pSrcLmOwfPwd,
										 PNT_OWF_PASSWORD pSrcNtOwfPwd)
{
/* local variables */
   NTSTATUS				status = 0;
   HRESULT				hr = ERROR_SUCCESS;
   SAMPR_HANDLE			hUserHandle = NULL;
   ULONG				ulCount = 1;
   ULONG				userID;
   RPC_UNICODE_STRING	sNames[1];
   SAMPR_ULONG_ARRAY	ulIDs;
   SAMPR_ULONG_ARRAY	ulUse;
   PSAMPR_USER_INFO_BUFFER pInfoBuf = NULL;
   WCHAR			*   pName;

/* function body */
   pName = new WCHAR[wcslen(srcName)+1];
   if (!pName)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      //get the user's ID
   sNames[0].Length = sNames[0].MaximumLength = (USHORT)((wcslen(srcName)) * sizeof(WCHAR));
   wcscpy(pName, srcName);
   sNames[0].Buffer = pName;
   ulIDs.Element = NULL;
   ulUse.Element = NULL;
   status = SamrLookupNamesInDomain(hgDomainHandle,
								    ulCount,
									sNames,
									&ulIDs,
									&ulUse);
   delete [] pName;
   if (!NT_SUCCESS(status))
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

   userID = *(ulIDs.Element);

      //get a user handle
   status = SamrOpenUser(hgDomainHandle,
						 POLICY_ALL_ACCESS,
						 userID,
						 &hUserHandle);
   if (!NT_SUCCESS(status))
   {
	  SamIFree_SAMPR_ULONG_ARRAY(&ulIDs);
	  SamIFree_SAMPR_ULONG_ARRAY(&ulUse);
      return HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));
   }

      //get the user's password
   status = SamrQueryInformationUser(hUserHandle,
									 UserInternal3Information,
									 &pInfoBuf);
   if (NT_SUCCESS(status)) //if success, get LmOwf and NtOwf versions of the password
   {
	  if (pInfoBuf->Internal3.I1.NtPasswordPresent)
         memcpy(pSrcNtOwfPwd, pInfoBuf->Internal3.I1.NtOwfPassword.Buffer, sizeof(NT_OWF_PASSWORD));
	  else
         memcpy(pSrcNtOwfPwd, &NullNtOwfPassword, sizeof(NT_OWF_PASSWORD));
	  if (pInfoBuf->Internal3.I1.LmPasswordPresent)
         memcpy(pSrcLmOwfPwd, pInfoBuf->Internal3.I1.LmOwfPassword.Buffer, sizeof(LM_OWF_PASSWORD));
	  else //else we need to use the global NULL LmOwfPassword
         memcpy(pSrcLmOwfPwd, &NullLmOwfPassword, sizeof(LM_OWF_PASSWORD));
      SamIFree_SAMPR_USER_INFO_BUFFER (pInfoBuf, UserInternal3Information);
      LogPwdEvent(srcName, true);
   }
   else
      LogPwdEvent(srcName, false);


   SamIFree_SAMPR_ULONG_ARRAY(&ulIDs);
   SamIFree_SAMPR_ULONG_ARRAY(&ulUse);
   SamrCloseHandle(&hUserHandle);

   if (!NT_SUCCESS(status))
      hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

   return hr;
}
//END RetrieveEncrytedSourcePasswords


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 SEPT 2000                                                *
 *                                                                   *
 *     This function is responsible for using the MSCHAP dll to      *
 * change the given target user's password.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN SetTargetPassword
HRESULT SetTargetPassword(handle_t hBinding, const WCHAR* tgtServer, 
						  const WCHAR* tgtName, WCHAR* currentPwd, 
						  LM_OWF_PASSWORD newLmOwfPwd, NT_OWF_PASSWORD newNtOwfPwd)
{
/* local variables */ 
   NTSTATUS				status;
   HRESULT				hr = ERROR_SUCCESS;
   RPC_STATUS           rcpStatus;
   UNICODE_STRING       UnicodePwd;
   OEM_STRING			oemString;
   LM_OWF_PASSWORD		OldLmOwfPassword;
   NT_OWF_PASSWORD		OldNtOwfPassword;
   BOOLEAN				LmOldPresent = TRUE;
   int					nConvert;
   char					oldLmPwd[MAX_PATH];
   WCHAR			  * pTemp;


/* function body */
   pTemp = new WCHAR[wcslen(currentPwd)+1];
   if (!pTemp)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

      //convert the old LmOwf password
   wcscpy(pTemp, currentPwd);
   _wcsupr(pTemp);
   RtlInitUnicodeString(&UnicodePwd, pTemp);
   status = RtlUpcaseUnicodeStringToOemString(&oemString, &UnicodePwd, TRUE);
   delete [] pTemp;
   if (NT_SUCCESS(status))
   {
	  if (status == STATUS_NULL_LM_PASSWORD)
	     LmOldPresent = FALSE;
	  else
	  {
	     strcpy(oldLmPwd, oemString.Buffer);
         status = RtlCalculateLmOwfPassword((PLM_PASSWORD)oldLmPwd, &OldLmOwfPassword);
	  }
	  RtlFreeOemString(&oemString);
   }

      //convert the old NtOwf password
//   RtlFreeUnicodeString(&UnicodePwd);
   RtlInitUnicodeString(&UnicodePwd, currentPwd);
   status = RtlCalculateNtOwfPassword(&UnicodePwd, &OldNtOwfPassword);
//   RtlFreeUnicodeString(&UnicodePwd);
   if (!NT_SUCCESS(status)) //if failed, leave
	  return HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

      //impersonate the caller when setting the password
   rcpStatus = RpcImpersonateClient(hBinding);

      //change the Password!
   status = MSChapSrvChangePassword(const_cast<WCHAR*>(tgtServer),
									const_cast<WCHAR*>(tgtName),
									LmOldPresent,
									&OldLmOwfPassword,
									&newLmOwfPwd,
									&OldNtOwfPassword,
									&newNtOwfPwd);

   if (rcpStatus == RPC_S_OK)
   {
      rcpStatus = RpcRevertToSelf();
      hr = HRESULT_FROM_WIN32(rcpStatus);
   }

   if (!NT_SUCCESS(status))
      hr = HRESULT_FROM_WIN32(LsaNtStatusToWinError(status));

   return hr;
}
//END SetTargetPassword


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 8 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for checking to make sure that   *
 * the calling client has the proper access on this machine and      *
 * domain to change someone's password.  We use a helper function to *
 * do the actual check.                                              *
 *                                                                   *
 *********************************************************************/

//BEGIN AuthenticateClient
DWORD 
   AuthenticateClient(
      handle_t               hBinding        // in - binding for client call
   )
{
/* local variables */
   DWORD                     rc;
   DWORD                     rc2;
   
/* function body */
   rc = (DWORD)RpcImpersonateClient(hBinding);
   if (!rc)
   {
      rc = IsAdminLocal();
      rc2 = (DWORD)RpcRevertToSelf();
	  if (rc2)
	     rc = rc2;
   }
   return rc;
}
//END AuthenticateClient


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for migrating the given user's   *
 * password from the source domain, in which this dll is running, to *
 * the given migrated target domain account.  We will retrieve the   *
 * old user's current password and set the new user's password to    *
 * match.                                                            *
 *                                                                   *
 *********************************************************************/

//BEGIN CopyPassword
DWORD __stdcall 
   CopyPassword( 
      /* [in] */         handle_t              hBinding,
      /* [string][in] */ const WCHAR __RPC_FAR *tgtServer,
      /* [string][in] */ const WCHAR __RPC_FAR *srcName,
      /* [string][in] */ const WCHAR __RPC_FAR *tgtName,
      /* [in] */         unsigned long          dwPwd,
      /* [size_is][in] */const char __RPC_FAR  *currentPwd
   )
{
   HRESULT                   hr = ERROR_SUCCESS;
   SAMPR_HANDLE              hDomain = NULL;
   LM_OWF_PASSWORD			 NewLmOwfPassword;
   NT_OWF_PASSWORD			 NewNtOwfPassword;
   NTSTATUS				     status;
   DWORD					 rc=0;
   PSID						 pCallerSid = NULL;
   _variant_t				 varPwd;
   _bstr_t					 bstrPwd;

      // validate parameters
   if ((tgtServer == NULL) || (srcName == NULL) || (tgtName == NULL) || 
	   (currentPwd == NULL) || (dwPwd <= 0))
   {
      return E_INVALIDARG;
   }

      //validate the buffer and the reported size
   if (IsBadReadPtr(currentPwd, dwPwd))
      return E_INVALIDARG;

      //make sure the client is an admin on the local machine, otherwise, forget it
   rc = AuthenticateClient(hBinding);
   if ( rc )
      return HRESULT_FROM_WIN32(rc); 

   try
   {
		  //convert the incoming byte array into a variant
	   varPwd = SetVariantWithBinaryArray(const_cast<char*>(currentPwd), dwPwd);
	   if ((varPwd.vt != (VT_UI1|VT_ARRAY)) || (varPwd.parray == NULL))
		  return E_INVALIDARG;

         //try to decrypt the password
		bstrPwd = AdmtDecrypt(g_hSessionKey, varPwd);
		if (!bstrPwd)
		   return GetLastError();
   }
   catch (_com_error& ce)
   {
	  return ce.Error();
   }
   catch (...)
   {
	  return E_FAIL;
   }

      //get the domain handle
   hr = RetrieveDomainHandle(&hDomain);
   if (hr == ERROR_SUCCESS)
   {
         //get the user's password from the source domain
      hr = RetrieveEncrytedSourcePasswords(srcName, &NewLmOwfPassword, &NewNtOwfPassword);
	  if (hr == ERROR_SUCCESS)
	  {
	        //set the target user's password to the source user's
	     hr = SetTargetPassword(hBinding, tgtServer, tgtName, (WCHAR*)bstrPwd, 
			                    NewLmOwfPassword, NewNtOwfPassword);
	  }
   }

   return hr;
}
//END CopyPassword


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 6 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for checking a registry value to *
 * make sure that the ADMT password migration Lsa notification       *
 * package is installed, running, and ready to migrate passwords.    *
 *                                                                   *
 *********************************************************************/

//BEGIN CheckConfig
DWORD __stdcall
   CheckConfig(
      /* [in] */         handle_t               hBinding,
      /* [in] */         unsigned long          dwSession,
      /* [size_is][in] */const char __RPC_FAR  *aSession,
      /* [in] */         unsigned long          dwPwd,
      /* [size_is][in] */const char __RPC_FAR  *aTestPwd,
      /* [out] */        WCHAR __RPC_FAR        tempPwd[PASSWORD_BUFFER_SIZE]
   )
{
   DWORD                     rc;
   DWORD				     rval;
   DWORD                     type;         // type of value
   DWORD                     len = sizeof rval; // value length
   HKEY						 hKey;
   _variant_t			     varPwd;
   _variant_t			     varSession;
   _bstr_t					 bstrPwd = L"";
   
      // validate parameters
   if ((aSession == NULL) || (aTestPwd == NULL) || (tempPwd == NULL) || 
	   (dwSession <= 0) || (dwPwd <= 0))
   {
      return E_INVALIDARG;
   }

      //validate the buffer and the reported size
   if ((IsBadReadPtr(aSession, dwSession)) || (IsBadReadPtr(aTestPwd, dwPwd)) || 
	   (IsBadWritePtr((LPVOID)tempPwd, PASSWORD_BUFFER_SIZE * sizeof(WCHAR))))
   {
      return E_INVALIDARG;
   }

      //make sure the client is an admin on the local machine, otherwise, forget it
   rc = AuthenticateClient(hBinding);
   if ( rc )
      return HRESULT_FROM_WIN32(rc); 

      //make sure the registry value is set for password migration
   rc = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     L"System\\CurrentControlSet\\Control\\Lsa",
                     0,
                     KEY_READ,
                     &hKey);
   if (rc == ERROR_SUCCESS)
   {
      rc = RegQueryValueEx(hKey, L"AllowPasswordExport", NULL, &type, (BYTE *)&rval, &len);
	  RegCloseKey(hKey);
      if ((rc == ERROR_SUCCESS) && (type == REG_DWORD) && (rval == 1))
         rc = ERROR_SUCCESS;
	  else
	     return PM_E_PASSWORD_MIGRATION_NOT_ENABLED;
   }

  try
   {
		//convert the incoming byte arrays into variants
		varSession = SetVariantWithBinaryArray(const_cast<char*>(aSession), dwSession);
		varPwd = SetVariantWithBinaryArray(const_cast<char*>(aTestPwd), dwPwd);
		if ((varSession.vt != (VT_UI1|VT_ARRAY)) || (varSession.parray == NULL) || 
			(varPwd.vt != (VT_UI1|VT_ARRAY)) || (varPwd.parray == NULL))
			return E_INVALIDARG;

		// acquire cryptographic service provider context

		if (g_hProvider == 0)
		{
			g_hProvider = AdmtAcquireContext();
		}

		// destroy any existing session key

		if (g_hSessionKey)
		{
			AdmtDestroyKey(g_hSessionKey);

			g_hSessionKey = 0;
		}

		// import new session key

		g_hSessionKey = AdmtImportSessionKey(g_hProvider, varSession);

		// decrypt password

		if (g_hSessionKey)
		{
			bstrPwd = AdmtDecrypt(g_hSessionKey, varPwd);
			if (!bstrPwd)
				return GetLastError();
		}
		else
			return GetLastError();
   
		  //send back the decrypted password
	   if (bstrPwd.length() > 0)
	   {
		  wcsncpy(tempPwd, bstrPwd, PASSWORD_BUFFER_SIZE);
		  tempPwd[PASSWORD_BUFFER_SIZE - 1] = L'\0';
	   }
	   else
	   {
		  tempPwd[0] = L'\0';
	   }
   }
   catch (_com_error& ce)
   {
	  return ce.Error();
   }
   catch (...)
   {
	  return E_FAIL;
   }

   return rc;
}
//END CheckConfig
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\script\admtscript.cpp ===
// ADMTScript.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f ADMTScriptps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ADMTScript.h"
#include "ADMTScript_i.c"
#include "Migration.h"


CAdmtModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Migration, CMigration)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{ADMTScript.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_ADMT);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{ADMTScript.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\pwdsvc\pwdsvc.cpp ===
/*---------------------------------------------------------------------------
  File: PwdSvc.cpp

  Comments:  entry point functions and other exported functions for ADMT's 
             password migration Lsa notification package.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/06/00

 ---------------------------------------------------------------------------
*/

#include "Pwd.h"
#include "PwdSvc.h"
#include "PwdSvc_s.c"

// These global variables can be changed if required
#define gsPwdProtoSeq TEXT("ncacn_np")
#define gsPwdEndPoint TEXT("\\pipe\\PwdMigRpc")
DWORD                    gPwdRpcMinThreads = 1;
DWORD                    gPwdRpcMaxThreads = RPC_C_LISTEN_MAX_CALLS_DEFAULT;

#ifndef STATUS_SUCCESS
#define STATUS_SUCCESS   ((NTSTATUS) 0x00000000L)
#endif

extern "C"
{
    BOOL WINAPI _CRT_INIT( HANDLE hInstance, DWORD  nReason, LPVOID pReserved );
}



/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 SEPT 2000                                                 *
 *                                                                   *
 *     This function is called by Lsa when trying to load all        *
 * registered Lsa password filter notification dlls.  Here we will   *
 * initialize the RPC run-time library to handle our ADMT password   *
 * migration RPC interface and to begin looking for RPC calls.  If we*
 * fail to successfully setup our RPC, we will return FALSE from this*
 * function which will cause Lsa not to load this password filter    *
 * Dll.                                                              *
 *     Note that the other two password filter dll functions:        *
 * PasswordChangeNotify and PasswordFilter do nothing at this point  *
 * in time.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN InitializeChangeNotify
BOOLEAN __stdcall InitializeChangeNotify()
{
/* local variables */
   RPC_STATUS                 rc = 0;
   BOOLEAN				      bSuccess = FALSE;
//   FILE						* dbgFile;

/* function body */
//   dbgFile = _wfopen(L"c:\\aa.txt", L"w+");
//   fwprintf(dbgFile, L"Entering InitializeChangeNotify\n");
//   MessageBeep(-1);
      // specify protocol sequence and endpoint
      // for receiving remote procedure calls
   rc = RpcServerUseProtseqEp(gsPwdProtoSeq,
							  RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
							  gsPwdEndPoint,
							  NULL );
   if (rc == RPC_S_OK)
   {
//      fwprintf(dbgFile, L"RpcServerUseProtseqEp Succeeded!\n");
         // register an interface with the RPC run-time library
      rc = RpcServerRegisterIf(PwdMigRpc_ServerIfHandle, NULL, NULL);
      if (rc == RPC_S_OK)
	  {
//         fwprintf(dbgFile, L"RpcServerRegisterIf Succeeded!\n");
	        //set the authenification for this RPC interface
         rc = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_WINNT, NULL, NULL);
         if (rc == RPC_S_OK)
		 {
//	        fwprintf(dbgFile, L"RpcServerRegisterAuthInfo Succeeded!\n");
               // listen for remote procedure calls
            rc = RpcServerListen(gPwdRpcMinThreads, 
				                 gPwdRpcMaxThreads, 
								 FALSE );
			if (rc != RPC_S_OK)
			{
//	           fwprintf(dbgFile, L"RpcServerListen Failed!\n");
               switch (rc)
			   {
	              case RPC_S_ALREADY_LISTENING:
//	                 fwprintf(dbgFile, L"RPC_S_ALREADY_LISTENING\n");
					    //if already listening, that's fine
			         bSuccess = TRUE;
		             break;
	              case RPC_S_NO_PROTSEQS_REGISTERED:
//	                 fwprintf(dbgFile, L"RPC_S_NO_PROTSEQS_REGISTERED\n");
		             break;
	              case RPC_S_MAX_CALLS_TOO_SMALL:
//	                 fwprintf(dbgFile, L"RPC_S_MAX_CALLS_TOO_SMALL\n");
		             break;
	              default:
//	                 fwprintf(dbgFile, L"Unknown\n");
                     break;
			   }
			}
			   //else success, set return value to load this dll as an
			   //Lsa password filter dll
			else
//			{
//	           fwprintf(dbgFile, L"RpcServerListen Succeeded!\n");
			   bSuccess = TRUE;
//			}
		 }
//		 else
//	        fwprintf(dbgFile, L"RpcServerRegisterAuthInfo Failed!\n");

            // unregister an interface with the RPC run-time library
//         rc = RpcServerUnregisterIf(PwdMigRpc_ServerIfHandle, NULL, NULL);
	  }
//	  else
//	     fwprintf(dbgFile, L"RpcServerRegisterIf Failed!\n");
   }//end if set protocal sequence and end point set
   else
   {
//       fwprintf(dbgFile, L"RpcServerUseProtseqEp Failed!\n");
	   switch (rc)
	   {
	      case RPC_S_PROTSEQ_NOT_SUPPORTED:
//	         fwprintf(dbgFile, L"RPC_S_PROTSEQ_NOT_SUPPORTED\n");
		     break;
	      case RPC_S_INVALID_RPC_PROTSEQ:
//	         fwprintf(dbgFile, L"RPC_S_INVALID_RPC_PROTSEQ\n");
		     break;
	      case RPC_S_INVALID_ENDPOINT_FORMAT:
//	         fwprintf(dbgFile, L"RPC_S_INVALID_ENDPOINT_FORMAT\n");
		     break;
	      case RPC_S_OUT_OF_MEMORY:
//	         fwprintf(dbgFile, L"RPC_S_OUT_OF_MEMORY\n");
		     break;
	      case RPC_S_DUPLICATE_ENDPOINT:
//	         fwprintf(dbgFile, L"RPC_S_DUPLICATE_ENDPOINT\n");
		     break;
	      case RPC_S_INVALID_SECURITY_DESC:
//	         fwprintf(dbgFile, L"RPC_S_INVALID_SECURITY_DESC\n");
		     break;
	      default:
//	         fwprintf(dbgFile, L"Unknown\n");
             break;
	   }
   }

      //if we successfully initialized our RPC interface, now open SAM
      //handles used later in our Interface function CopyPassword
//   if (bSuccess)
//      bSuccess = ConnectToSam();

//   fwprintf(dbgFile, L"Leaving InitializeChangeNotify\n");
//   fclose(dbgFile);

      //initialize a critical section to be used on the very first RPC call
   __try
   {
      InitializeCriticalSection (&csADMTCriticalSection);
   }
   __except (EXCEPTION_EXECUTE_HANDLER)
   {
	  ;
   }

   return bSuccess;
}
//END InitializeChangeNotify

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 SEPT 2000                                                 *
 *                                                                   *
 *     This function is called by Lsa for all registered Lsa password*
 * filter notification dlls when a password in the domain has been   *
 * modified.  We will simply return STATUS_SUCCESS and do nothing.   *
 *                                                                   *
 *********************************************************************/

//BEGIN PasswordChangeNotify
NTSTATUS __stdcall PasswordChangeNotify(PUNICODE_STRING UserName, ULONG RelativeId,
							  PUNICODE_STRING NewPassword)
{
	return STATUS_SUCCESS;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 SEPT 2000                                                 *
 *                                                                   *
 *     This function is called by Lsa for all registered Lsa password*
 * filter notification dlls when a password in the domain is being   *
 * modified.  This function i