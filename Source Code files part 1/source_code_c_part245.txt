 built for space and debug info is included for all builds
#
$(TARGETNAME): .\ISymWrapper.cpp .\ISymWrapper.h $(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscorlib.dll $(ISYMWRAPPER_RESOURCE_FILE:.rc=.res)
!IF ("$(DDKBUILDENV)" == "checked" || "$(DDKBUILDENV)" == "fastchecked")
        $(MANAGED_VCDIR)\cl /nologo /Bx$(MANAGED_VCDIR)\c1xx.dll /B2$(MANAGED_VCDIR)\c2.dll /c /Zi /clr /Fd$(TARGETPATH)\ISymWrapper.pdb $(INCPATH0) /Fo$(O)\ .\ISymWrapper.cpp
!ELSE
        $(MANAGED_VCDIR)\cl /nologo /Bx$(MANAGED_VCDIR)\c1xx.dll /B2$(MANAGED_VCDIR)\c2.dll /c /Zi /clr /O1 /Fd$(TARGETPATH)\ISymWrapper.pdb $(INCPATH0) /Fo$(O)\ .\ISymWrapper.cpp
!ENDIF
        $(MANAGED_VCDIR)\link /SAFESEH /nologo /nodefaultlib /DEBUG /DLL /NOENTRY $(BASE_OPT) $(O)\ISymWrapper.obj .\ISymWrapper.res /OUT:$(TARGETPATH)\ISymWrapper.dll $(SDK_LIB_PATH)\msvcrt$(DCRT).lib $(SDK_LIB_PATH)\ole32.lib $(TARGETCORLIB)\$(TARGET_DIRECTORY)\$(DDKBUILDENV)\mscoree.lib 
        sn -T $(TARGETPATH)\ISymWrapper.dll > $(O)\pubkey.tmp
        sn -e $(TARGETPATH)\ISymWrapper.dll   $(O)\pubkey.snk
        -perl $(CORENV)\bin\genpubpol.pl pubkey.snk ISymWrapper $(O)\pubkey.tmp $(O)\al.rsp $(O)\placepol.bat
        $(CORENV)\Bin\devlkg\al.exe /delaysign+ /keyf:$(O)\pubkey.snk @$(O)\al.rsp
        $(O)\placepol.bat


# 
# copy ISymWrapper to the complus target dir
#
!IF "$(TARGETCOMPLUS)" != ""
        copy $(TARGETNAME) $(TARGETCOMPLUS)
!ENDIF


TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\ISymWrapper.pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc

        gacutil -i $(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\iehost\secureiefactory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.IE 
{
    using System;
    using AssemblyName = System.Reflection.AssemblyName;
    using System.Security.Policy;
    using SecurityManager = System.Security.SecurityManager;
    using System.IO;
    using System.Text;
    using System.Reflection;
    using System.Globalization;
    using System.Security;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.Runtime.InteropServices;
    using Hashtable = System.Collections.Hashtable;
    using AssemblyHashAlgorithm = System.Configuration.Assemblies.AssemblyHashAlgorithm;
    
    
    public class SecureFactory: ISecureFactory
    {
        // These must match the values in IEHost.idl
        public static readonly int CORIESECURITY_ZONE = 0x01;
        public static readonly int CORIESECURITY_SITE = 0x02;
        
        Manager _host;
        
        int    _flags;
        int    _zone;
        string _URL;
        AssemblyName _assemblyName;
        string _typeName;
        byte[]  _uniqueId;
        byte[]  _fileHash;

        public enum WININET_CACHE_ENTRY 
        {
            NORMAL_CACHE_ENTRY = 0x00000001,
            COOKIE_CACHE_ENTRY = 0x00100000,
            URLHISTORY_CACHE_ENTRY = 0x00200000,
            TRACK_OFFLINE_CACHE_ENTRY = 0x00000010,
            TRACK_ONLINE_CACHE_ENTRY = 0x00000020,
            STICKY_CACHE_ENTRY = 0x00000004,
            SPARSE_CACHE_ENTRY = 0x00010000,
        }
        
        [DllImport("WININET", CharSet=CharSet.Auto)]
        internal static extern bool CreateUrlCacheEntry(string lpszUrlName, 
                                                        int dwExpectedFileSize, 
                                                        string lpszFileExtension, 
                                                        StringBuilder lpszFileName, 
                                                        int dwReserved);
        

        [DllImport("WININET", CharSet=CharSet.Auto)]
        internal static extern bool CommitUrlCacheEntry(string lpszUrlName,
                                                        string lpszLocalFileName,
                                                        long ExpireTime,
                                                        long LastModifiedTime,
                                                        int CacheEntryType,
                                                        string lpHeaderInfo,
                                                        int dwHeaderSize,
                                                        string lpszFileExtension,
                                                        string  lpszOriginalUrl); 

        internal SecureFactory(Manager host,
                               int flags,
                               int zone,
                               string URL,
                               byte[] uniqueId,
                               byte[] fileHash,
                               string assemblyName,
                               string typeName)
        {
            _host = host;
            _flags = flags;
            _zone = zone;
            _URL = URL;
            
            if(uniqueId != null && uniqueId.Length > 0) {
                _uniqueId = new byte[uniqueId.Length];
                Array.Copy(uniqueId, _uniqueId, uniqueId.Length);
            }

            if(fileHash != null && fileHash.Length > 0) {
                _fileHash = new byte[fileHash.Length];
                Array.Copy(fileHash, _fileHash, fileHash.Length);
            }

            _assemblyName = new AssemblyName();
            _assemblyName.CodeBase = URL;
            _typeName = typeName;
            
            Manager.Log(this, true, "Create SecureFactory() with security information", "");
        }
        
        internal SecureFactory(Manager host,
                               string assemblyName,
                               string typeName)
        {
            _host = host;
            _assemblyName = new AssemblyName();
            _assemblyName.Name = assemblyName;
            _typeName = typeName;
        }
        
        public void RemoteCreateInstance(Guid riid, out Object ppvObject)
        {
            ppvObject = null;
            return;
        }
        
        public void RemoteLockServer(int fLock)
        {
            return;
        }
        
        private static bool FailRebinds(PermissionSet psAllowed)
        {
            bool noRebinds = true;  
            if(psAllowed != null) {
                if(psAllowed.IsUnrestricted())
                    noRebinds = false;
                else {
                    SecurityPermission sp = (SecurityPermission) psAllowed.GetPermission(typeof(SecurityPermission));
                    if(sp != null && ((sp.Flags & SecurityPermissionFlag.BindingRedirects) != 0))
                        noRebinds = false;
                }
            }
            return noRebinds;
        }

        // dwFlag - indicates whether dwZone and pSite are valid
        //          values: CORIESECURITY_ZONE, CORIESECURITY_SITE
        // dwZone - Document Zone
        // pURL   - URL for Document
        // uniqueIdString - Unique id for site.

        [SecurityPermissionAttribute( SecurityAction.Demand, 
                                      Flags = SecurityPermissionFlag.ControlEvidence | 
                                      SecurityPermissionFlag.ControlPolicy) ]
        public virtual Object CreateInstanceWithSecurity(int dwFlag, 
                                                         int dwZone, 
                                                         string pURL, 
                                                         string uniqueIdString,
                                                         string link,
                                                         string licenses)
        {
            if (pURL==null || Manager.UrlIs(pURL,Manager.URL_IS.URLIS_FILEURL))
                throw new ArgumentException("pURL");
            if ((dwFlag&CORIESECURITY_ZONE)==CORIESECURITY_ZONE && dwZone==0)
                throw new SecurityException();
            new PermissionSet(PermissionState.Unrestricted).Assert();
            AppDomain proxy = null;
            Object result = null; 
            string CodeBase;
            string Application = null;
            
            try {
                
                Manager.CanonizeURL(link,Manager.URL_CANONFLAGS.URL_WININET_COMPATIBILITY);                              
                if(!Manager.IsValidURL(pURL))
                    throw new ArgumentException("pURL");

                Manager.Log(this, true, "Creating instance of the object in the correct domain", "");
                Manager.Log(this, true, "pUrl = " + pURL, "");
                Manager.Log(this, true, "id = " + uniqueIdString, "");
                Manager.Log(this, true, "link = " + link, "");
                Manager.Log(this, true, "licenses = " + licenses, "");
                
                
                // Hack to convert unique id back into byte array;
                byte[] uniqueId = Manager.DecodeDomainId(uniqueIdString);

                if(uniqueId == null) {
                    Manager.Log(this, true, "No unqiue id was sent", "");
                    return null;
                }

                // Get the codebase from the URL, it will be a protocol or a file location. File locations
                // do not have CodeBase set
                bool fHasCodeBase = Manager.GetCodeBase(pURL, out CodeBase, out Application);
                if (CodeBase!=null)
                      CodeBase=Manager.CanonizeURL(CodeBase,Manager.URL_CANONFLAGS.URL_UNESCAPE);

                if (Application!=null)
                    Application = Application.Replace('\\', '/');

                Manager.Log(this, 
                              CodeBase != null, 
                              "URL codeBase: " + CodeBase, 
                              "URL codeBase: <null>");
                Manager.Log(this, 
                              Application != null, 
                              "URL application: " + Application, 
                              "URL application: <null>");

                // If we have a link tag then get the code base from that.
                string configSite = null;      // Site where the configuration file is located
                string configLocation = null;  // Path from the site to the configuration file
                string configFile = null;      // Name of the configuration file
                bool   fFoundConfigurationSite = false;

                // If there is no link tag then the Application base is always the site.
                // When there is a link tag then the Application base is where the config
                // file is relative to the page.
                if(licenses != null && licenses.Length >0 ) 
                    licenses=Manager.MakeFullLink(licenses,CodeBase,Application);


                if(link != null && link.Length >0 ) {

                    link=Manager.MakeFullLink(link,CodeBase,Application);
                    
                    if (!Manager.IsValidURL(link))
                        throw new ArgumentException("link");
                                        
                    Manager.Log(this, true, "final link = " + link, "");

                    fFoundConfigurationSite = Manager.GetCodeBase(link, 
                                                                  out configSite, 
                                                                  out configLocation);
                    if (configSite!=null)
                          configSite=Manager.CanonizeURL(configSite,Manager.URL_CANONFLAGS.URL_UNESCAPE);
                    
                    Manager.GetConfigurationFile(link, out configLocation, out configFile);
                    
                    Manager.Log(this, 
                                configSite != null, 
                                "Configuration site: " + configSite, 
                                "Configuration site: <null>");
                    
                    Manager.Log(this, 
                                configLocation != null, 
                                "Configuration location: " + configLocation, 
                                "Configuration location: <null>");
                    
                    Manager.Log(this, 
                                configFile != null, 
                                "Configuration fileName: " + configFile, 
                                "Configuration fileName: <null>");

                    // We have a configuration site then it must match the pages site
                    if(configSite != null) {
                        if(CodeBase == null ||
                           !Manager.AreTheSame(CodeBase,configSite)) 
                            throw new TypeLoadException(_typeName);
                    }
                    
                    // If they put a site on the configuration file then the code base is set to the configFile
                    // location.
                    //                    if(fFoundConfigurationSite) 
                    CodeBase = configLocation;
                    //                    else {
                    //                        StringBuilder sb = new StringBuilder();
                    //                        if(fHasCodeBase) {
                    //                            sb.Append(CodeBase);
                    //                            sb.Append("/");
                    //                        }
                    //                        sb.Append(Application);
                    //                        sb.Append("/");
                    //                        sb.Append(configLocation);
                    //                        CodeBase = sb.ToString();
                    //                    }
                }
                else if(!fHasCodeBase)
                    CodeBase = Application;

                // Rules:
                // 1. If we have a directory associated with the configuration file
                //    then application base is the codebase plus the directory
                string domainName = null;
                Manager.Log(this, true, 
                            "Locating domain for " + CodeBase, 
                            "");
                domainName = CodeBase;

                proxy = _host.LocateDomain(uniqueId, domainName);
                if(proxy == null) {
                    lock(_host) {
                        proxy = _host.LocateDomain(uniqueId, domainName);
                        if(proxy == null) {
                            proxy = CreateProxy(dwZone,
                                                dwFlag,
                                                domainName,
                                                fHasCodeBase,
                                                CodeBase,
                                                pURL,
                                                configFile,
                                                uniqueId,
                                                licenses);
                        }
                        else
                            Manager.Log(this, true, "SOME ONE CREATED THE DOMAIN BEFORE I HAD a CHANCE", "");
                    }
                }
                else {
                    Manager.Log(this, true, "Do not have to create new domain", "");
                    Manager.Log(this, true, "Existing Domain:", "");
                    Manager.Log(this, true, proxy.ToString(), "");
                }

                // The assembly is assigned the attributes stored with this factory.
                // There is a new factory for each assembly downloaded from the web
                // so the attributes are unique to a specific assembly.
            
                Manager.Log(this, true, "Trying to create instance of type " + _assemblyName.CodeBase  + "#" + _typeName, "");
                AssemblyHashAlgorithm id = AssemblyHashAlgorithm.SHA1;
                result = proxy.CreateComInstanceFrom(_assemblyName.CodeBase, 
                                                     _typeName,
                                                     _fileHash,
                                                     id);

                Manager.Log(this, result == null, "Unable to create instance of type " + _assemblyName + "::" + _typeName, 
                              "Created instance of type " + _assemblyName.CodeBase + "::" + _typeName);
                // @BUGBUG We need to do this why does it not work???
                if(result == null) 
                    throw new TypeLoadException(_typeName);


#if _DEBUG
                if(configFile != null) {
                    String s = "Configuration file name " + proxy.SetupInformation.ConfigurationFile;
                    Manager.Log(this, true, s, "");
                }
#endif

            }
            catch(Exception e) {
                Manager.Log(this, true, e.ToString(), "");
                string entry = null;
                if(_assemblyName.CodeBase != null) {
                    int k = _assemblyName.CodeBase.LastIndexOf('/');
                    if(k != -1) entry = _assemblyName.CodeBase.Substring(k+1);
                }
                LogException(e, entry);
                throw e;
            }
            return result;
        }

        AppDomain CreateProxy(int dwZone,
                              int dwFlag,
                              string domainName,
                              bool   fHasCodeBase,
                              string CodeBase,
                              string pURL,
                              string configFile,
                              byte[] uniqueId,
                              string licenses
                              )
        {
            Manager.Log(this, true, "Need to create domain", "");
            
            string friendlyName = null;
            // @TODO: CTS, this should allow the security id as well
            
            Evidence documentSecurity = new Evidence();
            
            if((dwFlag & CORIESECURITY_ZONE) != 0)
                documentSecurity.AddHost( new Zone((System.Security.SecurityZone)dwZone) );
            if(pURL != null)
                friendlyName = Manager.GetSiteName(pURL);
            else
                friendlyName = "<Unknown>";
            if((dwFlag & CORIESECURITY_SITE) != 0)
            {
                if(fHasCodeBase) {
                    documentSecurity.AddHost( Site.CreateFromUrl(CodeBase) );
                    documentSecurity.AddHost( new Url( CodeBase ) );
                }
            }

            AppDomainSetup properties = new AppDomainSetup();
            if(configFile != null) {
                properties.ConfigurationFile = configFile;
                Manager.Log(this, true, "Added configuration file: " + configFile, "");
            }
            properties.ApplicationBase = CodeBase;
            Manager.Log(this, true, "Application base: " + CodeBase, "");
            properties.PrivateBinPath = "bin";
            Manager.Log(this, true, "Private Bin Path: bin", "");
            if(licenses != null) {
                properties.LicenseFile = licenses;
                Manager.Log(this, true, "LicenceFile:" + licenses, "");
            }
            
            PermissionSet ps = SecurityManager.ResolvePolicy(documentSecurity);
            if(FailRebinds(ps)) {
                properties.DisallowBindingRedirects = true;
            }
            else {
                properties.DisallowBindingRedirects = false;
            }
            
            AppDomain proxy = AppDomain.CreateDomain(friendlyName,
                                                     documentSecurity, 
                                                     properties);
            
            if(proxy != null) {
                // Add the domain to our global list. 
                _host.AddDomain(uniqueId, domainName, proxy);
            }
            else {
                Manager.Log(this, true, "Unable to create proxy to type", "");
                throw new ExecutionEngineException();
            }

            return proxy;
        }

        void LogException(Exception e, string Application)
        {
            Manager.Log(this, true, "LOG exception", "");
            StringBuilder urlName = new StringBuilder();
            urlName.Append("?FusionBindError!name=");
            urlName.Append(Application != null ? Application : "<Unknown>");
            if(_typeName != null) {
                urlName.Append(" ");
                urlName.Append(_typeName);
            }

            string url = urlName.ToString();
            string extension = "HTM";

            StringBuilder file = new StringBuilder(2048);
            Manager.Log(this, true,"Creating log entry " + url, "");

            if(CreateUrlCacheEntry(url, 0, extension, file, 0)) {
                string fileName = file.ToString();
                Manager.Log(this, true, "Logging to file " + fileName, "");
                if(fileName != null) {
                    DateTime time = DateTime.Now;
                    WriteLogFile(fileName, e, time, Application);
                    long expireTime = 0;
                    if(!CommitUrlCacheEntry(url, fileName, 
                                            expireTime, time.ToFileTime(),
                                            (int) WININET_CACHE_ENTRY.NORMAL_CACHE_ENTRY,
                                            null, 0,
                                            null, null))
                        Manager.Log(this, true, "Unable to commit Cache Entry", "");
                }                                    
            }
            else {
                Manager.Log(this, true, "Unable to create url cache entry", "");
            }
        }                

        void WriteLogFile(string file, Exception e, DateTime time, string application)
        {
            try {
                StreamWriter logFile;
                new FileIOPermission(PermissionState.Unrestricted).Assert();
                FileStream stream = new FileStream(file.ToString(), 
                                                   FileMode.Create, 
                                                   FileAccess.ReadWrite,
                                                   FileShare.ReadWrite, 
                                                   4048);
            
                logFile = new StreamWriter(stream, new UTF8Encoding());
            
                logFile.WriteLine("<html>\n<pre>\n");
                string stime = time.ToString("f", CultureInfo.InvariantCulture);
                logFile.Write("*****\tIEHOST Error Log (");
                logFile.WriteLine(stime +") \t*****\n\n\n");
                logFile.WriteLine("URL: \t\t" + _URL);
                logFile.WriteLine("Zone: \t\t" + (_zone).ToString().Trim()); //BUGBUG: Why is this Trim here?
                logFile.WriteLine("Assembly Name:\t" + application);
                logFile.WriteLine("Type Name:\t" + _typeName);
                logFile.WriteLine("\n\n");
                logFile.WriteLine("----- Thrown Exception -----\n\n");
                logFile.WriteLine(e.ToString());
                logFile.WriteLine("\n</pre>\n</html>\n");
            
                logFile.Flush();
                stream.Close();
            }
            catch(Exception be) {
                Manager.Log(this, true, "Caught an exception while trying to write the log file", "");
                Manager.Log(this, true, be.ToString(), "");
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\isymwrapper\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "ISymWrapper.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Runtime Managed Symbol Wrappers\0"
#define VER_ORIGFILENAME_STR    "ISymWrapper.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\isymwrapper\isymwrapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#include "ISymWrapper.h"
#include "../../inc/version/__file__.ver"

using namespace System;
using namespace System::Threading;
using namespace System::Runtime::InteropServices;
using namespace System::Runtime::CompilerServices;
using namespace System::Security;
using namespace System::Security::Permissions;

//-----------------------------------------------------------------------
// Strong name the assembly (or half sign it, at least).
//-----------------------------------------------------------------------
[assembly:AssemblyDelaySignAttribute(true),
 assembly:AssemblyKeyFileAttribute("../../../bin/FinalPublicKey.snk"),
 assembly:AssemblyVersionAttribute(VER_ASSEMBLYVERSION_STR)];

//-----------------------------------------------------------------------
// SymDocument
//-----------------------------------------------------------------------

SymDocument::SymDocument(ISymUnmanagedDocument *pDocument)
{
    m_pDocument = pDocument;
    m_pDocument->AddRef();
}

SymDocument::~SymDocument()
{
    if (m_pDocument)
        m_pDocument->Release();
}

byte SymDocument::GetCheckSum(void)  __gc []
{
    //
    // @todo: implement this when we have a symbol store that supports
    // checksums.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

int SymDocument::FindClosestLine(int line)
{
    long retVal;

    IfFailThrow(m_pDocument->FindClosestLine(line, &retVal));

    return retVal;
}

byte SymDocument::GetSourceRange(int startLine, int startColumn,
                                 int endLine, int endColumn)  __gc []
{
    //
    // @todo: implement this wrapper when we get a unmanaged symbol
    // store that actually supports embedded source.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}


//-----------------------------------------------------------------------
// SymDocumentWriter
//-----------------------------------------------------------------------

SymDocumentWriter::SymDocumentWriter(ISymUnmanagedDocumentWriter *pDW)
{
    m_pDocumentWriter = pDW;
    m_pDocumentWriter->AddRef();
}

SymDocumentWriter::~SymDocumentWriter()
{
    if (m_pDocumentWriter)
        m_pDocumentWriter->Release();
}

void SymDocumentWriter::SetSource(byte source __gc [])
{
    //
    // @todo: implement this wrapper when we have a symbol store that
    // handled embedded source.
    //
    IfFailThrow(E_NOTIMPL);
    return;
}

void SymDocumentWriter::SetCheckSum(Guid algorithmId, byte source  __gc [])
{
    //
    // @todo: implement this wrapper when we have a symbol store that
    // handles check sums.
    //
    IfFailThrow(E_NOTIMPL);
    return;
}

//-----------------------------------------------------------------------
// SymMethod
//-----------------------------------------------------------------------

SymMethod::SymMethod(ISymUnmanagedMethod *pMethod)
{
    m_pMethod = pMethod;
    m_pMethod->AddRef();
}

SymMethod::~SymMethod()
{
    if (m_pMethod)
        m_pMethod->Release();
}

void SymMethod::GetSequencePoints(int offsets  __gc [],
                                  ISymbolDocument* documents __gc [],
                                  int lines __gc [],
                                  int columns __gc [],
                                  int endLines __gc [],
                                  int endColumns __gc [])
{
    int spCount = 0;

    if (offsets != NULL)
        spCount = offsets.Length;
    else if (documents != NULL)
        spCount = documents.Length;
    else if (lines != NULL)
        spCount = lines.Length;
    else if (columns != NULL)
        spCount = columns.Length;
    else if (endLines != NULL)
        spCount = endLines.Length;
    else if (endColumns != NULL)
        spCount = endColumns.Length;

    // Don't do anything if they're not really asking for anything.
    if (spCount == 0)
        return;

    // Make an unmanaged array to hold the ISymUnmanagedDocuments that
    // we'll be getting back.
    ISymUnmanagedDocument** udocs = new ISymUnmanagedDocument*[spCount];

    // Pin down the offsets, lines, and columns arrays.
    GCHandle oh;
    GCHandle lh;
    GCHandle ch;
    GCHandle elh;
    GCHandle ech;
    int oa = NULL;
    int la = NULL;
    int ca = NULL;
    int ela = NULL;
    int eca = NULL;

    if (offsets != NULL)
    {
        oh = GCHandle::Alloc(offsets, GCHandleType::Pinned);
        oa = (int)oh.AddrOfPinnedObject();
    }

    if (lines != NULL)
    {
        lh = GCHandle::Alloc(lines, GCHandleType::Pinned);
        la = (int)lh.AddrOfPinnedObject();
    }

    if (columns != NULL)
    {
        ch = GCHandle::Alloc(columns, GCHandleType::Pinned);
        ca = (int)ch.AddrOfPinnedObject();
    }

    if (endLines != NULL)
    {
        elh = GCHandle::Alloc(endLines, GCHandleType::Pinned);
        ela = (int)elh.AddrOfPinnedObject();
    }

    if (endColumns != NULL)
    {
        ech = GCHandle::Alloc(endColumns, GCHandleType::Pinned);
        eca = (int)ech.AddrOfPinnedObject();
    }

    unsigned long actualCount;

    // Call the unmanaged method
    IfFailThrow(m_pMethod->GetSequencePoints(spCount,
                                             &actualCount,
                                             (long*)oa,
                                             udocs,
                                             (long*)la,
                                             (long*)ca,
                                             (long*)ela,
                                             (long*)eca));

    // Unpin the managed arrays...
    if (offsets != NULL)
        oh.Free();

    if (lines != NULL)
        lh.Free();

    if (columns != NULL)
        ch.Free();

    if (endLines != NULL)
        elh.Free();

    if (endColumns != NULL)
        ech.Free();

    // Convert all the unmanaged docs to managed docs.
    for (int i = 0; i < spCount; i++)
    {
        documents[i] = new SymDocument(udocs[i]);
        udocs[i]->Release();
    }

    return;
}

ISymbolScope *SymMethod::RootScopeInternal(void)
{
	ISymUnmanagedScope *rs = NULL;

	IfFailThrow(m_pMethod->GetRootScope(&rs));

	ISymbolScope *s = NULL;

	if (rs != NULL)
	{
		s = new SymScope(rs);
		rs->Release();
	}

	return s;

};

ISymbolScope *SymMethod::GetScope(int offset)
{
    ISymUnmanagedScope *rs = NULL;

    IfFailThrow(m_pMethod->GetScopeFromOffset(offset, &rs));

    ISymbolScope *s = new SymScope(rs);
    rs->Release();

    return s;
}

int SymMethod::GetOffset(ISymbolDocument *document,
                         int line,
                         int column)
{
    long offset;

    SymDocument *sd = static_cast<SymDocument*>(document);

    IfFailThrow(m_pMethod->GetOffset(sd->GetUnmanaged(),
                                     line,
                                     column,
                                     &offset));

    return offset;
}

int SymMethod::GetRanges(ISymbolDocument *document,
                         int line,
                         int column) __gc []
{
    SymDocument *sd = static_cast<SymDocument*>(document);

    // Find out how many ranges there will be.
    unsigned long cRanges = 0;

    IfFailThrow(m_pMethod->GetRanges(sd->GetUnmanaged(),
                                     line, column,
                                     0, &cRanges, NULL));

    // If there are ranges, make room for them and call again.
    int ranges __gc [] = NULL ;

    if (cRanges > 0)
    {
        ranges = new  int __gc [cRanges];

        // Pin the managed array.
        GCHandle rh = GCHandle::Alloc(ranges, GCHandleType::Pinned);
        int ra = (int)rh.AddrOfPinnedObject();

        // Get the ranges.
        IfFailThrow(m_pMethod->GetRanges(sd->GetUnmanaged(),
                                         line, column,
                                         cRanges, &cRanges,
                                         (long*)ra));

        // Unpin the managed array.
        rh.Free();
    }

    return ranges;
}

ISymbolVariable* SymMethod::GetParameters(void)  __gc []
{
    // Make the call and find out how many there are.
    SIZE_T paramCount = 0;

    IfFailThrow(m_pMethod->GetParameters(0, &paramCount, NULL));

    // Allocate a managed array for the managed parameter references.
    ISymbolVariable* allParams __gc []=
        new ISymbolVariable* __gc [paramCount];

    if (paramCount > 0)
    {
        // Allocate a unmanaged array for all the unmanaged document
        // references.
        ISymUnmanagedVariable** unParams =
            new ISymUnmanagedVariable*[paramCount];

        // Don't need to pin unParams because its not managed.  Make the
        // call and fill in the unmanaged variable references.
        IfFailThrow(m_pMethod->GetParameters(paramCount, &paramCount,
                                             unParams));

        // Make a managed variable object for each unmanaged reference
        // and place it in the managed variable array.
        for (int i = 0; i < paramCount; i++)
        {
            allParams[i] = new SymVariable(unParams[i]);
            unParams[i]->Release();
        }

        delete [] unParams;
    }

    return allParams;
}

ISymbolNamespace *SymMethod::GetNamespace(void)
{
    //
    // @todo: implement this when a symbol store that supports it exists.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

bool SymMethod::GetSourceStartEnd(ISymbolDocument *docs  __gc [],
                                  int lines __gc [],
                                  int columns __gc [])
{
    //
    // @todo: implement this when a symbol store that supports it exists.
    //
    IfFailThrow(E_NOTIMPL);
    return false;
}

//-----------------------------------------------------------------------
// SymReader
//-----------------------------------------------------------------------

SymReader::SymReader(ISymUnmanagedReader *pReader)
{
    m_pReader = pReader;
    m_pReader->AddRef();
}

SymReader::~SymReader()
{
    if (m_pReader)
        m_pReader->Release();
}

ISymbolDocument *SymReader::GetDocument(String *url,
                                        Guid language,
                                        Guid languageVendor,
                                        Guid documentType)
{
    // Convert the managed Guids to unamanged GUIDS.
    GUID l;
    GUID lv;
    GUID dt;

    byte g  __gc []= language.ToByteArray();
    Marshal::Copy(g, 0, (int)&l, g.Length);
    g = languageVendor.ToByteArray();
    Marshal::Copy(g, 0, (int)&lv, g.Length);
    g = documentType.ToByteArray();
    Marshal::Copy(g, 0, (int)&dt, g.Length);

    // Get a unmanaged unicode copy of the string.
    // @TODO PORTING: For 64 bit port, clean up this cast
    WCHAR *s = (WCHAR*)Marshal::StringToCoTaskMemUni(url).ToInt64();

    // Make the call.
    ISymUnmanagedDocument *ret = NULL;

    IfFailThrow(m_pReader->GetDocument(s, l, lv, dt, &ret));

    // Free up the unmanaged string
    Marshal::FreeCoTaskMem((int)s);

    // Return a managed document.
    ISymbolDocument *d = NULL;

    if (ret != NULL)
    {
        d = new SymDocument(ret);
        ret->Release();
    }

    return d;
}

ISymbolDocument* SymReader::GetDocuments(void) __gc []
{
    // Make the call and find out how many there are.
    SIZE_T docCount = 0;
    IfFailThrow(m_pReader->GetDocuments(0, &docCount, NULL));

    // Allocate a managed array for the managed document references.
    ISymbolDocument* allDocs  __gc []= new  ISymbolDocument* __gc [docCount];

    if (docCount > 0)
    {
        // Allocate a unmanaged array for all the unmanaged document
        // references.
        ISymUnmanagedDocument** unDocs = new ISymUnmanagedDocument*[docCount];

        // Don't need to pin unDocs because its not managed.  Make the
        // call and fill in the unmanaged document references.
        IfFailThrow(m_pReader->GetDocuments(docCount, &docCount, unDocs));

        // Make a managed document object for each unmanaged reference
        // and place it in the managed document array.
        for (int i = 0; i < docCount; i++)
        {
            allDocs[i] = new SymDocument(unDocs[i]);
            unDocs[i]->Release();
        }

        delete [] unDocs;
    }

    return allDocs;
}

ISymbolMethod *SymReader::GetMethod(SymbolToken method)
{
    ISymUnmanagedMethod *meth = NULL;

    IfFailThrow(m_pReader->GetMethod(method.GetToken(), &meth));

    ISymbolMethod *m = new SymMethod(meth);
    meth->Release();

    return m;
}

ISymbolMethod *SymReader::GetMethod(SymbolToken method, int version)
{
    ISymUnmanagedMethod *meth = NULL;

    IfFailThrow(m_pReader->GetMethodByVersion(method.GetToken(), version,
                                              &meth));

    ISymbolMethod *m = new SymMethod(meth);
    meth->Release();

    return m;
}

ISymbolVariable* SymReader::GetVariables(SymbolToken parent) __gc []
{
    //
    // @todo: implement this wrapper when we have a symbol reader that
    // stores non-local variables.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

ISymbolVariable* SymReader::GetGlobalVariables(void) __gc []
{
    //
    // @todo: implement this wrapper when we have a symbol reader that
    // stores non-local variables.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

ISymbolMethod *SymReader::GetMethodFromDocumentPosition(ISymbolDocument *document,
                                                        int line,
                                                        int column)
{
    ISymUnmanagedMethod *meth = NULL;
    SymDocument *sd = static_cast<SymDocument*>(document);

    IfFailThrow(m_pReader->GetMethodFromDocumentPosition(sd->GetUnmanaged(),
                                                         line,
                                                         column,
                                                         &meth));

    ISymbolMethod *m = new SymMethod(meth);
    meth->Release();

    return m;
}

byte SymReader::GetSymAttribute(SymbolToken parent, String *name) __gc []
{
    //
    // @todo: implement this wrapper when we have a symbol reader that
    // stores custom attributes.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

ISymbolNamespace* SymReader::GetNamespaces(void) __gc []
{
    //
    // @todo: implement this wrapper when we have a symbol reader that
    // stores namespaces.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

//-----------------------------------------------------------------------
// SymScope
//-----------------------------------------------------------------------

SymScope::SymScope(ISymUnmanagedScope *pScope)
{
    m_pScope = pScope;
    m_pScope->AddRef();
}

SymScope::~SymScope()
{
    if (m_pScope)
        m_pScope->Release();
}

ISymbolScope* SymScope::GetChildren(void)  __gc []
{
    // Make the call and find out how many there are.
    SIZE_T childCount = 0;

    IfFailThrow(m_pScope->GetChildren(0, &childCount, NULL));

    // Allocate a managed array for the managed child references.
    ISymbolScope* allChildren  __gc []=
        new ISymbolScope* __gc [childCount];

    if (childCount > 0)
    {
        // Allocate a unmanaged array for all the unmanaged document
        // references.
        ISymUnmanagedScope** unChildren =
            new ISymUnmanagedScope*[childCount];

        // Don't need to pin unChildren because its not managed.  Make the
        // call and fill in the unmanaged scope references.
        IfFailThrow(m_pScope->GetChildren(childCount, &childCount,
                                          unChildren));

        // Make a managed scope object for each unmanaged reference
        // and place it in the managed scope array.
        for (int i = 0; i < childCount; i++)
        {
            allChildren[i] = new SymScope(unChildren[i]);
            unChildren[i]->Release();
        }

        delete [] unChildren;
    }

    return allChildren;
}

ISymbolVariable* SymScope::GetLocals(void) __gc []
{
    // Make the call and find out how many there are.
    SIZE_T localCount = 0;

    IfFailThrow(m_pScope->GetLocals(0, &localCount, NULL));

    // Allocate a managed array for the managed local references.
    ISymbolVariable* allLocals  __gc []=
        new ISymbolVariable* __gc [localCount];

    if (localCount > 0)
    {
        // Allocate a unmanaged array for all the unmanaged variable
        // references.
        ISymUnmanagedVariable** unLocals =
            new ISymUnmanagedVariable*[localCount];

        // Don't need to pin unLocals because its not managed.  Make the
        // call and fill in the unmanaged variable references.
        IfFailThrow(m_pScope->GetLocals(localCount, &localCount, unLocals));

        // Make a managed variable object for each unmanaged reference
        // and place it in the managed variable array.
        for (int i = 0; i < localCount; i++)
        {
            allLocals[i] = new SymVariable(unLocals[i]);
            unLocals[i]->Release();
        }

        delete [] unLocals;
    }

    return allLocals;
}

ISymbolNamespace* SymScope::GetNamespaces(void)  __gc []
{
    //
    // @todo: implement this wrapper when we have a symbol reader that
    // stores namespaces.
    //
    IfFailThrow(E_NOTIMPL);
    return NULL;
}

//-----------------------------------------------------------------------
// SymVariable
//-----------------------------------------------------------------------

SymVariable::SymVariable(ISymUnmanagedVariable *pVariable)
{
    m_pVariable = pVariable;
    m_pVariable->AddRef();
}

SymVariable::~SymVariable()
{
    if (m_pVariable)
        m_pVariable->Release();
}

byte SymVariable::GetSignature(void) __gc []
{
    // Find out how big the sig is.
    unsigned long cSig = 0;

    IfFailThrow(m_pVariable->GetSignature(0, &cSig, NULL));

    // If there is a sig, make room for it and call again.
    byte sig  __gc [] = NULL;

    if (cSig > 0)
    {
        throw new Exception("SymVariable::GetSignature broken awaiting new MC++ compiler");
        /*
        sig = new byte __gc [cSig];

        // Pin the managed array.
        GCHandle sh = GCHandle::Alloc(sig, GCHandleType::Pinned);
        int sa = (int)sh.AddrOfPinnedObject();

        // Get the ranges.
        IfFailThrow(m_pVariable->GetSignature(cSig, &cSig, (byte*)sa));

        // Unpin the managed array.
        sh.Free();
        */
    }

    return sig;
}


//-----------------------------------------------------------------------
// SymWriter
//-----------------------------------------------------------------------

CLSID CLSID_CorSymWriter_SxS =
    {0x0AE2DEB0,0xF901,0x478b,{0xBB,0x9F,0x88,0x1E,0xE8,0x06,0x67,0x88}};
    
IID IID_ISymUnmanagedWriter =
    {0x2de91396,0x3844,0x3b1d,{0x8e,0x91,0x41,0xc2,0x4f,0xd6,0x72,0xea}};


SymWriter::SymWriter()
{
    // By default, we don't provide an underlying writer.
    InitWriter(true);
}

SymWriter::SymWriter(bool noUnderlyingWriter)
{
    InitWriter(noUnderlyingWriter);
}

void SymWriter::InitWriter(bool noUnderlyingWriter)
{
    m_ppWriter = NULL;
    m_pUnderlyingWriter = NULL;

    ISymUnmanagedWriter *pWriter = NULL;

    // initialize ole
    Thread *thread = Thread::CurrentThread;
    thread->ApartmentState = ApartmentState::MTA;

    if (!noUnderlyingWriter)
    {
        IfFailThrow(CoCreateInstance(CLSID_CorSymWriter_SxS,
                                     NULL,
                                     CLSCTX_INPROC_SERVER,
                                     IID_ISymUnmanagedWriter,
                                     (LPVOID*)&pWriter));

        m_pUnderlyingWriter = pWriter;
    }
}

ISymUnmanagedWriter *SymWriter::GetWriter(void)
{
    // Return the normal underlying writer for this wrapper if we've
    // got one. Otherwise, return whatever underlying writer was set
    // by SetUnderlyingWriter, if any.
    if (m_ppWriter != NULL)
    {
        return *m_ppWriter;
    }
    else
        return m_pUnderlyingWriter;
}

void SymWriter::SetUnderlyingWriter(IntPtr underlyingWriter)
{
    // Demand the permission to access unmanaged code. We do this since we are casting an int to a COM interface, and
    // this can be used improperly.
    (new SecurityPermission(SecurityPermissionFlag::UnmanagedCode))->Demand();

    // underlyingWriter is the address of the ISymUnmanagedWriter*
    // that this wrapper will use to write symbols.
    m_ppWriter = (ISymUnmanagedWriter**)underlyingWriter.ToPointer();
}

SymWriter::~SymWriter()
{
    if (m_pUnderlyingWriter)
        m_pUnderlyingWriter->Release();
}

void SymWriter::Initialize(IntPtr emitter, String *filename, bool fFullBuild)
{
    // Demand the permission to access unmanaged code. We do this since we are casting an int to a COM interface, and
    // this can be used improperly.
    (new SecurityPermission(SecurityPermissionFlag::UnmanagedCode))->Demand();

    // Get a unmanaged unicode copy of the string.
    WCHAR *s;

    if (filename != NULL)
        // @TODO PORTING: For 64 bit port, clean up this cast
        s = (WCHAR*)Marshal::StringToCoTaskMemUni(filename).ToInt64();
    else
        s = NULL;

    IfFailThrow(GetWriter()->Initialize((IUnknown*)emitter.ToPointer(), s, NULL, fFullBuild));

    // Free up the unmanaged string
    if (s != NULL)
        // @TODO PORTING: For 64 bit port, clean up this cast
        Marshal::FreeCoTaskMem((IntPtr)(INT64)s);

    return;
}

ISymbolDocumentWriter *SymWriter::DefineDocument(String *url,
                                                 Guid language,
                                                 Guid languageVendor,
                                                 Guid documentType)
{
    // Convert the managed Guids to unamanged GUIDS.
    GUID l;
    GUID lv;
    GUID dt;

    byte g  __gc []  = language.ToByteArray();
    Marshal::Copy(g, 0, (int)&l, g.Length);
    g = languageVendor.ToByteArray();
    Marshal::Copy(g, 0, (int)&lv, g.Length);
    g = documentType.ToByteArray();
    Marshal::Copy(g, 0, (int)&dt, g.Length);

    // Get a unmanaged unicode copy of the string.
    // @TODO PORTING: For 64 bit port, clean up this cast
    WCHAR *s = (WCHAR*)Marshal::StringToCoTaskMemUni(url).ToInt64();

    // Make the call.
    ISymUnmanagedDocumentWriter *ret = NULL;

    IfFailThrow(GetWriter()->DefineDocument(s, &l, &lv, &dt, &ret));

    // Free up the unmanaged string
    Marshal::FreeCoTaskMem((int)s);

    // Return a managed document.
    ISymbolDocumentWriter *d = NULL;

    if (ret != NULL)
    {
        d = new SymDocumentWriter(ret);
        ret->Release();
    }

    return d;
}

void SymWriter::SetUserEntryPoint(SymbolToken entryMethod)
{
    IfFailThrow(GetWriter()->SetUserEntryPoint(entryMethod.GetToken()));
    return;
}

void SymWriter::OpenMethod(SymbolToken method)
{
    IfFailThrow(GetWriter()->OpenMethod(method.GetToken()));
    return;
}

void SymWriter::CloseMethod(void)
{
    IfFailThrow(GetWriter()->CloseMethod());
    return;
}

void SymWriter::DefineSequencePoints(ISymbolDocumentWriter *document,
                                     int offsets __gc [],
                                     int lines __gc [],
                                     int columns __gc [],
                                     int endLines __gc [],
                                     int endColumns __gc [])
{
    SymDocumentWriter *sd = static_cast<SymDocumentWriter*>(document);

    int spCount = 0;

    if (offsets != NULL)
        spCount =  offsets.Length;
    else if (lines != NULL)
        spCount =  lines.Length;
    else if (columns != NULL)
        spCount =  columns.Length;
    else if (endLines != NULL)
        spCount =  endLines.Length;
    else if (endColumns != NULL)
        spCount =  endColumns.Length;

    // Don't do anything if they're not really asking for anything.
    if (spCount == 0)
        return;

    // Make sure all arrays are the same length.
    if ((offsets != NULL) && (spCount != offsets.Length))
        IfFailThrow(E_INVALIDARG);

    if ((lines != NULL) && (spCount != lines.Length))
        IfFailThrow(E_INVALIDARG);

    if ((columns != NULL) && (spCount != columns.Length))
        IfFailThrow(E_INVALIDARG);

    if ((endLines != NULL) && (spCount != endLines.Length))
        IfFailThrow(E_INVALIDARG);

    if ((endColumns != NULL) && (spCount != endColumns.Length))
        IfFailThrow(E_INVALIDARG);

    // Pin down the offsets, lines, and columns arrays.
    GCHandle oh;
    GCHandle lh;
    GCHandle ch;
    GCHandle elh;
    GCHandle ech;
    int oa = NULL;
    int la = NULL;
    int ca = NULL;
    int ela = NULL;
    int eca = NULL;

    if (offsets != NULL)
    {
        oh = GCHandle::Alloc(offsets, GCHandleType::Pinned);
        oa = (int)oh.AddrOfPinnedObject();
    }

    if (lines != NULL)
    {
        lh = GCHandle::Alloc(lines, GCHandleType::Pinned);
        la = (int)lh.AddrOfPinnedObject();
    }

    if (columns != NULL)
    {
        ch = GCHandle::Alloc(columns, GCHandleType::Pinned);
        ca = (int)ch.AddrOfPinnedObject();
    }

    if (endLines != NULL)
    {
        elh = GCHandle::Alloc(endLines, GCHandleType::Pinned);
        ela = (int)elh.AddrOfPinnedObject();
    }

    if (endColumns != NULL)
    {
        ech = GCHandle::Alloc(endColumns, GCHandleType::Pinned);
        eca = (int)ech.AddrOfPinnedObject();
    }

    // Call the unmanaged method
    IfFailThrow(GetWriter()->DefineSequencePoints(sd->GetUnmanaged(),
                                                  spCount,
                                                  (long*)oa,
                                                  (long*)la,
                                                  (long*)ca,
                                                  (long*)ela,
                                                  (long*)eca));

    // Unpin the managed arrays...
    if (offsets != NULL)
        oh.Free();

    if (lines != NULL)
        lh.Free();

    if (columns != NULL)
        ch.Free();

    if (endLines != NULL)
        elh.Free();

    if (endColumns != NULL)
        ech.Free();

    return;
}

int SymWriter::OpenScope(int startOffset)
{
    long ret = 0;

    IfFailThrow(GetWriter()->OpenScope(startOffset, &ret));

    return ret;
}

void SymWriter::CloseScope(int endOffset)
{
    IfFailThrow(GetWriter()->CloseScope(endOffset));
    return;
}

void SymWriter::SetScopeRange(int scopeID, int startOffset, int endOffset)
{
    IfFailThrow(GetWriter()->SetScopeRange(scopeID, startOffset, endOffset));
    return;
}

void SymWriter::DefineLocalVariable(String *name,
                                    FieldAttributes attributes,
                                    byte signature __gc [],
                                    SymAddressKind addrKind,
                                    int addr1,
                                    int addr2,
                                    int addr3,
                                    int startOffset,
                                    int endOffset)
{
    // Get a unmanaged string for the call.
    // @TODO PORTING: For 64 bit port, clean up this cast
    WCHAR *s = (WCHAR*)Marshal::StringToCoTaskMemUni(name).ToInt64();

    // Pin the signature array for the call.
    GCHandle sh = GCHandle::Alloc(signature, GCHandleType::Pinned);
    int sa = (int)sh.AddrOfPinnedObject();

    // Define the local
    IfFailThrow(GetWriter()->DefineLocalVariable(s, attributes,
                                                 signature.Length,
                                                 (unsigned char*)sa,
                                                 addrKind,
                                                 addr1,
                                                 addr2,
                                                 addr3,
                                                 startOffset,
                                                 endOffset));

    // Unpin the managed array.
    sh.Free();

    // Free up the unmanaged string
    Marshal::FreeCoTaskMem((int)s);

    return;
}

void SymWriter::DefineParameter(String *name,
                                ParameterAttributes attributes,
                                int sequence,
                                SymAddressKind addrKind,
                                int addr1,
                                int addr2,
                                int addr3)
{
    //
    // @todo: implement this wrapper when we have a symbol writer that
    // supports this method.
    //
    IfFailThrow(E_NOTIMPL);
    return;
}

void SymWriter::DefineField(SymbolToken parent,
                            String *name,
                            FieldAttributes attributes,
                            byte signature __gc [],
                            SymAddressKind addrKind,
                            int addr1,
                            int addr2,
                            int addr3)
{
    //
    // @todo: implement this wrapper when we have a symbol writer that
    // supports this method.
    //
    IfFailThrow(E_NOTIMPL);
    return;
}

void SymWriter::DefineGlobalVariable(String *name,
                                     FieldAttributes attributes,
                                     byte signature __gc [],
                                     SymAddressKind addrKind,
                                     int addr1,
                                     int addr2,
                                     int addr3)
{
    //
    // @todo: implement this wrapper when we have a symbol writer that
    // supports this method.
    //
    IfFailThrow(E_NOTIMPL);
    return;
}

void SymWriter::Close(void)
{
    IfFailThrow(GetWriter()->Close());
    return;
}

void SymWriter::SetSymAttribute(SymbolToken parent, String *name,
                                byte data  __gc [])
{
    // Get a unmanaged string for the call.
    // @TODO PORTING: For 64 bit port, clean up this cast
    WCHAR *s = (WCHAR*)Marshal::StringToCoTaskMemUni(name).ToInt64();

    // Pin the data array for the call.
    GCHandle sh = GCHandle::Alloc(data, GCHandleType::Pinned);
    int sa = (int)sh.AddrOfPinnedObject();

    // Define the local
    IfFailThrow(GetWriter()->SetSymAttribute(parent.GetToken(),
                                             s,
                                             data.Length,
                                             (unsigned char*)sa));

    // Unpin the managed array.
    sh.Free();

    // Free up the unmanaged string
    Marshal::FreeCoTaskMem((int)s);

    return;
}

void SymWriter::OpenNamespace(String *name)
{
    // Get a unmanaged unicode copy of the string.
    // @TODO PORTING: For 64 bit port, clean up this cast
    WCHAR *s = (WCHAR*)Marshal::StringToCoTaskMemUni(name).ToInt64();

    IfFailThrow(GetWriter()->OpenNamespace(s));

    // Free up the unmanaged string
    Marshal::FreeCoTaskMem((int)s);

    return;
}

void SymWriter::CloseNamespace(void)
{
    IfFailThrow(GetWriter()->CloseNamespace());
    return;
}

void SymWriter::UsingNamespace(String *fullName)
{
    // Get a unmanaged unicode copy of the string.
    // @TODO PORTING: For 64 bit port, clean up this cast
    WCHAR *s = (WCHAR*)Marshal::StringToCoTaskMemUni(fullName).ToInt64();

    IfFailThrow(GetWriter()->UsingNamespace(s));

    // Free up the unmanaged string
    Marshal::FreeCoTaskMem((int)s);

    return;
}

void SymWriter::SetMethodSourceRange(ISymbolDocumentWriter *startDoc,
                                     int startLine,
                                     int startColumn,
                                     ISymbolDocumentWriter *endDoc,
                                     int endLine,
                                     int endColumn)
{
    //
    // @todo: implement this when we have a symbol store that supports it.
    //
    IfFailThrow(E_NOTIMPL);
    return;
}

//-----------------------------------------------------------------------
// SymBinder
//-----------------------------------------------------------------------

CLSID CLSID_CorSymBinder_SxS =
    {0x0A29FF9E,0x7F9C,0x4437,{0x8B,0x11,0xF4,0x24,0x49,0x1E,0x39,0x31}};
    
IID IID_ISymUnmanagedBinder =
    {0xAA544d42,0x28CB,0x11d3,{0xbd,0x22,0x00,0x00,0xf8,0x08,0x49,0xbd}};


SymBinder::SymBinder()
{
    m_pBinder = NULL;

    ISymUnmanagedBinder *pBinder = NULL;

    // initialize ole
    Thread *thread = Thread::CurrentThread;
    thread->ApartmentState = ApartmentState::MTA;

    IfFailThrow(CoCreateInstance(CLSID_CorSymBinder_SxS,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_ISymUnmanagedBinder,
                                 (LPVOID*)&pBinder));

    m_pBinder = pBinder;
}

SymBinder::~SymBinder()
{
    if (m_pBinder)
        m_pBinder->Release();
}

ISymbolReader *SymBinder::GetReader(int importer, String *filename,
                                    String *searchPath)
{
    // Demand the permission to access unmanaged code. We do this since we are casting an int to a COM interface, and
    // this can be used improperly.
    (new SecurityPermission(SecurityPermissionFlag::UnmanagedCode))->Demand();

    ISymUnmanagedReader *pReader = NULL;

    // Get a unmanaged unicode copy of the string.
    WCHAR *s;

    if (filename != NULL) {
        // @TODO PORTING: For 64 bit port, clean up this cast
        s = (WCHAR*)Marshal::StringToCoTaskMemUni(filename).ToInt64();
    }
    else
        s = NULL;

    WCHAR *sp;

    if (searchPath != NULL) {
        // @TODO PORTING: For 64 bit port, clean up this cast
        sp = (WCHAR*)Marshal::StringToCoTaskMemUni(searchPath).ToInt64();
    }
    else
        sp = NULL;

    IfFailThrow(m_pBinder->GetReaderForFile((IUnknown*)importer,
                                            s,
                                            sp,
                                            &pReader));

    // Make a reader from this thing.
    SymReader *sr = new SymReader(pReader);

    // Free up the unmanaged string
    if (s != NULL)
        Marshal::FreeCoTaskMem((int)s);

    if (sp != NULL)
        Marshal::FreeCoTaskMem((int)sp);

    return sr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\isymwrapper\isymwrapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#using <mscorlib.dll>
#include <objbase.h>
#include <winerror.h>

using namespace System::Runtime::InteropServices;
using namespace System::Diagnostics::SymbolStore;
using namespace System::Reflection;

#define IfFailThrow(expression) \
    { HRESULT hresult = (expression); \
        if(FAILED(hresult)) { \
            if (hresult == E_NOTIMPL) \
               throw new NotSupportedException; \
            else if (hresult == E_OUTOFMEMORY) \
                throw new OutOfMemoryException; \
            else if (hresult == E_INVALIDARG) \
                throw new ArgumentException; \
            else { \
              String *s("ExceptionOccurred"); \
              COMException* pe = new COMException(s, hresult); \
              throw pe; \
            } \
        } \
    }


//
// Misc unmanaged typedefs.
//
#define NULL 0
#define WCHAR wchar_t
#define byte unsigned char

typedef unsigned long mdToken;
typedef unsigned long mdTypeDef;
typedef unsigned long mdMethodDef;

//
// Unmanaged interfaces
//
__interface ISymUnmanagedDocument;
__interface ISymUnmanagedDocumentWriter;
__interface ISymUnmanagedMethod;
__interface ISymUnmanagedNamespace;
__interface ISymUnmanagedReader;
__interface ISymUnmanagedScope;
__interface ISymUnmanagedVariable;
__interface ISymUnmanagedWriter;
__interface ISymUnmanagedBinder;

__interface ISymUnmanagedDocument : public IUnknown
{
    HRESULT __stdcall GetURL(SIZE_T cchUrl,
                             SIZE_T *pcchUrl,
                             WCHAR szUrl[]);
    HRESULT __stdcall GetDocumentType(GUID* pRetVal);
    HRESULT __stdcall GetLanguage(GUID* pRetVal);
    HRESULT __stdcall GetLanguageVendor(GUID* pRetVal);
    HRESULT __stdcall GetCheckSumAlgorithmId(GUID* pRetVal);
    HRESULT __stdcall GetCheckSum(SIZE_T cData,
                                  SIZE_T *pcData,
                                  BYTE data[]);
    HRESULT __stdcall FindClosestLine(long line,
                                      long* pRetVal);
    HRESULT __stdcall HasEmbeddedSource(BOOL *pRetVal);
    HRESULT __stdcall GetSourceLength(long* pRetVal);
    HRESULT __stdcall GetSourceRange(long startLine,
                                     long startColumn,
                                     long endLine,
                                     long endColumn,
                                     SIZE_T cSourceBytes,
                                     SIZE_T *pcSourceBytes,
                                     BYTE source[]);
};

__interface ISymUnmanagedDocumentWriter : public IUnknown
{
    HRESULT __stdcall SetSource(SIZE_T sourceSize,
                                BYTE source[]);
    HRESULT __stdcall SetCheckSum(GUID algorithmId,
                                  SIZE_T checkSumSize,
                                  BYTE checkSum[]);
};

__interface ISymUnmanagedMethod : public IUnknown
{
    HRESULT __stdcall GetToken(mdMethodDef *pToken);
    HRESULT __stdcall GetSequencePointCount(long* pRetVal);
    HRESULT __stdcall GetRootScope(ISymUnmanagedScope** pRetVal);
    HRESULT __stdcall GetScopeFromOffset(long offset,
                                         ISymUnmanagedScope** pRetVal);
    HRESULT __stdcall GetOffset(ISymUnmanagedDocument* document,
                                long line,
                                long column,
                                long* pRetVal);
    HRESULT __stdcall GetRanges(ISymUnmanagedDocument* document,
                                long line,
                                long column,
                                SIZE_T cRanges,
                                SIZE_T *pcRanges,
                                long ranges[]);
    HRESULT __stdcall GetParameters(SIZE_T cParams,
                                    SIZE_T *pcParams,
                                    ISymUnmanagedVariable* params[]);
    HRESULT __stdcall GetNamespace(ISymUnmanagedNamespace **pRetVal);
    HRESULT __stdcall GetSourceStartEnd(ISymUnmanagedDocument *docs[2],
                                        long lines[2],
                                        long columns[2],
                                        BOOL *pRetVal);
    HRESULT __stdcall GetSequencePoints(SIZE_T cPoints,
                                        SIZE_T *pcPoints,
                                        long offsets[],
                                        ISymUnmanagedDocument* documents[],
                                        long lines[],
                                        long columns[],
                                        long endLines[],
                                        long endColumns[]);
};

__interface ISymUnmanagedReader : public IUnknown
{
    HRESULT __stdcall GetDocument(WCHAR *url,
                                  GUID language,
                                  GUID languageVendor,
                                  GUID documentType,
                                  ISymUnmanagedDocument** pRetVal);
    HRESULT __stdcall GetDocuments(SIZE_T cDocs,
                                   SIZE_T *pcDocs,
                                   ISymUnmanagedDocument *pDocs[]);
    HRESULT __stdcall GetUserEntryPoint(mdMethodDef *pToken);
    HRESULT __stdcall GetMethod(mdMethodDef token,
                                ISymUnmanagedMethod** pRetVal);
    HRESULT __stdcall GetMethodByVersion(mdMethodDef token,
                                         int version,
                                         ISymUnmanagedMethod** pRetVal);
    HRESULT __stdcall GetVariables(mdToken parent,
                                   SIZE_T cVars,
                                   SIZE_T *pcVars,
                                   ISymUnmanagedVariable **pRetVal);
    HRESULT __stdcall GetGlobalVariables(SIZE_T cVars,
                                         SIZE_T *pcVars,
                                         ISymUnmanagedVariable **pRetVal);
    HRESULT __stdcall GetMethodFromDocumentPosition(ISymUnmanagedDocument* document,
                                                    long line,
                                                    long column,
                                                    ISymUnmanagedMethod** pRetVal);
    HRESULT __stdcall GetSymAttribute(mdToken parent,
                                      WCHAR *name,
                                      SIZE_T cBuffer,
                                      SIZE_T *pcBuffer,
                                      BYTE buffer[]);
    HRESULT __stdcall GetNamespaces(SIZE_T cNameSpaces,
                                    SIZE_T *pcNameSpaces,
                                    ISymUnmanagedNamespace *namespaces[]);
    HRESULT __stdcall Initialize(IUnknown *importer,
                                 WCHAR *filename,
                                 WCHAR *searchPath,
                                 IStream *pIStream);
    HRESULT __stdcall UpdateSymbolStore(WCHAR *filename,
                                        IStream *pIStream);
    HRESULT __stdcall ReplaceSymbolStore(WCHAR *filename,
                                         IStream *pIStream);
};

__interface ISymUnmanagedScope : public IUnknown
{
    HRESULT __stdcall GetMethod(ISymUnmanagedMethod** pRetVal);
    HRESULT __stdcall GetParent(ISymUnmanagedScope** pRetVal);
    HRESULT __stdcall GetChildren(SIZE_T cChildren,
                                  SIZE_T *pcChildren,
                                  ISymUnmanagedScope *children[]);
    HRESULT __stdcall GetStartOffset(long *pRetVal);
    HRESULT __stdcall GetEndOffset(long *pRetVal);
    HRESULT __stdcall GetLocalCount(long *pRetVal);
    HRESULT __stdcall GetLocals(SIZE_T cLocals,
                                SIZE_T *pcLocals,
                                ISymUnmanagedVariable* locals[]);
    HRESULT __stdcall GetNamespaces(SIZE_T cNameSpaces,
                                    SIZE_T *pcNameSpaces,
                                    ISymUnmanagedNamespace *namespaces[]);
};

__interface ISymUnmanagedVariable : public IUnknown
{
    HRESULT __stdcall GetName(SIZE_T cchName,
                              SIZE_T *pcchName,
                              WCHAR szName[]);
    HRESULT __stdcall GetAttributes(long* pRetVal);
    HRESULT __stdcall GetSignature(SIZE_T cSig,
                                   SIZE_T *pcSig,
                                   BYTE sig[]);
    HRESULT __stdcall GetAddressKind(long* pRetVal);
    HRESULT __stdcall GetAddressField1(long* pRetVal);
    HRESULT __stdcall GetAddressField2(long* pRetVal);
    HRESULT __stdcall GetAddressField3(long* pRetVal);
    HRESULT __stdcall GetStartOffset(long* pRetVal);
    HRESULT __stdcall GetEndOffset(long* pRetVal);
};

__interface ISymUnmanagedWriter : public IUnknown
{
    HRESULT __stdcall DefineDocument(WCHAR *url,
                           GUID *language,
                           GUID *languageVendor,
                           GUID *documentType,
                           ISymUnmanagedDocumentWriter** pRetVal);
    HRESULT __stdcall SetUserEntryPoint(mdMethodDef entryMethod);
    HRESULT __stdcall OpenMethod(mdMethodDef method);
    HRESULT __stdcall CloseMethod();
    HRESULT __stdcall OpenScope(long startOffset, long* pRetVal);
    HRESULT __stdcall CloseScope(long endOffset);
    HRESULT __stdcall SetScopeRange(long scopeID,
                          long startOffset,
                          long endOffset);
    HRESULT __stdcall DefineLocalVariable(WCHAR *name,
                                long attributes,
                                SIZE_T cSig,
                                unsigned char signature[],
                                long addrKind,
                                long addr1,
                                long addr2,
                                long addr3,
                                long startOffset,
                                long endOffset);
    HRESULT __stdcall DefineParameter(WCHAR *name,
                            long attributes,
                            long sequence,
                            long addrKind,
                            long addr1,
                            long addr2,
                            long addr3);
    HRESULT __stdcall DefineField(mdTypeDef parent,
                        WCHAR *name,
                        long attributes,
                        ULONG cSig,
                        unsigned char signature[],
                        long addrKind,
                        long addr1,
                        long addr2,
                        long addr3);
    HRESULT __stdcall DefineGlobalVariable(WCHAR *name,
                                 long attributes,
                                 SIZE_T cSig,
                                 unsigned char signature[],
                                 long addrKind,
                                 long addr1,
                                 long addr2,
                                 long addr3);
    HRESULT __stdcall Close();
    HRESULT __stdcall SetSymAttribute(mdToken parent,
                            WCHAR *name,
                            SIZE_T cData,
                            unsigned char data[]);
    HRESULT __stdcall OpenNamespace(WCHAR *name);
    HRESULT __stdcall CloseNamespace();
    HRESULT __stdcall UsingNamespace(WCHAR *fullName);
    HRESULT __stdcall SetMethodSourceRange(ISymUnmanagedDocumentWriter *startDoc,
                                 long startLine,
                                 long startColumn,
                                 ISymUnmanagedDocumentWriter *endDoc,
                                 long endLine,
                                 long endColumn);
    HRESULT __stdcall Initialize(IUnknown *emitter,
                       WCHAR *filename,
                       IStream *pIStream,
                       BOOL fFullBuild);
    HRESULT __stdcall GetDebugInfo(IMAGE_DEBUG_DIRECTORY *pIDD,
                         DWORD cData,
                         DWORD *pcData,
                         unsigned char data[]);
    HRESULT __stdcall DefineSequencePoints(ISymUnmanagedDocumentWriter* document,
                                 SIZE_T spCount,
                                 long offsets[],
                                 long lines[],
                                 long columns[],
                                 long endLines[],
                                 long endColumns[]);
};

__interface ISymUnmanagedBinder : public IUnknown
{
    HRESULT __stdcall GetReaderForFile(IUnknown *importer,
                                       WCHAR *fileName,
                                       WCHAR *searchPath,
                                       ISymUnmanagedReader **pRetVal);
};


//
// Our managed wrapper objects are defined in the
// System::Diagnostics::SymbolStore namespace.
//
namespace System
{
namespace Diagnostics
{
namespace SymbolStore
{

//
// ISymUnmanagedDocument wrapper.
//
__gc public class SymDocument : public ISymbolDocument
{
    ISymUnmanagedDocument *m_pDocument;

public:
    SymDocument(ISymUnmanagedDocument *pDocument);
    ~SymDocument();

    ISymUnmanagedDocument *GetUnmanaged(void) {return m_pDocument;}

    __property String *get_URL()
    {
        // Get the size of the URL
        SIZE_T urlSize = 0;

        IfFailThrow(m_pDocument->GetURL(0, &urlSize, NULL));

        // Make room for the unmanaged string.
        WCHAR *us = new WCHAR[urlSize + 1];

        // Grab the URL into the managed string.
        IfFailThrow(m_pDocument->GetURL(urlSize + 1, &urlSize, us));

        // Copy to a managed string.
        String *s = Marshal::PtrToStringUni((int)us);

        delete [] us;

        return s;
    };

    __property Guid get_DocumentType()
    {
        GUID ug;

        IfFailThrow(m_pDocument->GetDocumentType(&ug));

        Guid g(ug.Data1, ug.Data2, ug.Data3,
               ug.Data4[0], ug.Data4[1], ug.Data4[2], ug.Data4[3],
               ug.Data4[4], ug.Data4[5], ug.Data4[6], ug.Data4[7]);

        return g;
    };

    __property Guid get_Language()
    {
        GUID ug;

        IfFailThrow(m_pDocument->GetLanguage(&ug));

        Guid g(ug.Data1, ug.Data2, ug.Data3,
               ug.Data4[0], ug.Data4[1], ug.Data4[2], ug.Data4[3],
               ug.Data4[4], ug.Data4[5], ug.Data4[6], ug.Data4[7]);

        return g;
    };


    __property Guid get_LanguageVendor()
    {
        GUID ug;

        IfFailThrow(m_pDocument->GetLanguageVendor(&ug));

        Guid g(ug.Data1, ug.Data2, ug.Data3,
               ug.Data4[0], ug.Data4[1], ug.Data4[2], ug.Data4[3],
               ug.Data4[4], ug.Data4[5], ug.Data4[6], ug.Data4[7]);

        return g;
    };


    __property Guid get_CheckSumAlgorithmId()
    {
        //
        // @todo: implement this when we have a symbol store that supports
        // checksums.
        //
        IfFailThrow(E_NOTIMPL);
        Guid g;
        return g;
    };

     byte GetCheckSum(void) __gc [];

    int FindClosestLine(int line);

    __property bool get_HasEmbeddedSource()
    {
        BOOL ret;

        IfFailThrow(m_pDocument->HasEmbeddedSource(&ret));

        return (ret == 1);
    };


    __property int get_SourceLength()
    {
        long retVal;

        IfFailThrow(m_pDocument->GetSourceLength(&retVal));

        return retVal;
    };


    byte GetSourceRange(int startLine, int startColumn,
                                    int endLine, int endColumn) __gc [];
};

//
// ISymUnmanagedDocumentWriter wrapper.
//
__gc public class SymDocumentWriter : public ISymbolDocumentWriter
{
    ISymUnmanagedDocumentWriter *m_pDocumentWriter;

public:
    SymDocumentWriter(ISymUnmanagedDocumentWriter *pDocumentWriter);
    ~SymDocumentWriter();

    ISymUnmanagedDocumentWriter *GetUnmanaged(void) {return m_pDocumentWriter;}

    void SetSource(byte source __gc []);
    void SetCheckSum(Guid algorithmId,  byte source __gc []);
};

//
// ISymUnmanagedMethod wrapper.
//
__gc public class SymMethod : public ISymbolMethod
{
    ISymUnmanagedMethod *m_pMethod;

public:
    SymMethod(ISymUnmanagedMethod *pMethod);
    ~SymMethod();

    __property SymbolToken get_Token()
    {
        mdMethodDef tk;

        IfFailThrow(m_pMethod->GetToken(&tk));

        SymbolToken t(tk);
        return t;
    };

    __property int get_SequencePointCount()
    {
        long retVal;

        IfFailThrow(m_pMethod->GetSequencePointCount(&retVal));

        return retVal;
    };

    void GetSequencePoints(int offsets __gc [],
                           ISymbolDocument* documents __gc [],
                           int lines __gc [],
                           int columns __gc [],
                           int endLines __gc [],
                           int endColumns __gc []);

    ISymbolScope *RootScopeInternal(void);

    __property ISymbolScope *get_RootScope()
    {
        return RootScopeInternal();
    };

    ISymbolScope *GetScope(int offset);
    int GetOffset(ISymbolDocument *document,
                  int line,
                  int column);
    int GetRanges(ISymbolDocument *document,
                              int line,
                              int column) __gc [];
    ISymbolVariable* GetParameters(void) __gc [];
    ISymbolNamespace *GetNamespace(void);
    bool GetSourceStartEnd(ISymbolDocument *docs __gc [],
                           int lines __gc [],
                           int columns __gc []);
};

//
// ISymUnmanagedReader wrapper.
//
__gc public class SymReader : public ISymbolReader
{
    ISymUnmanagedReader *m_pReader;

public:
    SymReader(ISymUnmanagedReader *pReader);
    ~SymReader();

    ISymbolDocument *GetDocument(String *url,
                              Guid language,
                              Guid languageVendor,
                              Guid documentType);
    ISymbolDocument* GetDocuments() __gc [];
    __property SymbolToken get_UserEntryPoint()
    {
        mdMethodDef tk;

        IfFailThrow(m_pReader->GetUserEntryPoint(&tk));

        SymbolToken t(tk);
        return t;
    };
    ISymbolMethod *GetMethod(SymbolToken method);
    ISymbolMethod *GetMethod(SymbolToken method, int version);
    ISymbolVariable* GetVariables(SymbolToken parent) __gc [];
    ISymbolVariable* GetGlobalVariables() __gc [];
    ISymbolMethod *GetMethodFromDocumentPosition(ISymbolDocument *document,
                                              int line,
                                              int column);
    byte GetSymAttribute(SymbolToken parent, String *name) __gc [];
    ISymbolNamespace* GetNamespaces(void) __gc [];
};

//
// ISymUnmanagedScope wrapper.
//
__gc public class SymScope : public ISymbolScope
{
    ISymUnmanagedScope *m_pScope;

public:
    SymScope(ISymUnmanagedScope *pScope);
    ~SymScope();

    __property ISymbolMethod *get_Method()
    {
        ISymUnmanagedMethod *meth = NULL;

        IfFailThrow(m_pScope->GetMethod(&meth));

        ISymbolMethod *m = new SymMethod(meth);
        meth->Release();

        return m;
    };

    __property ISymbolScope *get_Parent()
    {
        ISymUnmanagedScope *scope = NULL;

        IfFailThrow(m_pScope->GetParent(&scope));

        ISymbolScope *s = new SymScope(scope);
        scope->Release();

        return s;
    };

    ISymbolScope* GetChildren(void) __gc [];

    __property int get_StartOffset()
    {
        long retVal;

        IfFailThrow(m_pScope->GetStartOffset(&retVal));

        return retVal;
    };

    __property int get_EndOffset()
    {
        long retVal;

        IfFailThrow(m_pScope->GetEndOffset(&retVal));

        return retVal;
    };

    ISymbolVariable* GetLocals(void) __gc [];
    ISymbolNamespace* GetNamespaces(void) __gc [];
};

//
// ISymUnmanagedVariable wrapper.
//
__gc public class SymVariable : public ISymbolVariable
{
    ISymUnmanagedVariable *m_pVariable;

public:
    SymVariable(ISymUnmanagedVariable *pVariable);
    ~SymVariable();

    __property String *get_Name()
    {
        // Get the size of the Name.
        SIZE_T nameSize = 0;

        IfFailThrow(m_pVariable->GetName(0, &nameSize, NULL));

        // Make room for the unmanaged string.
        WCHAR *us = new WCHAR[nameSize + 1];

        // Grab the Name into the managed string.
        IfFailThrow(m_pVariable->GetName(nameSize + 1, &nameSize, us));

        // Copy to a managed string.
        String *s = Marshal::PtrToStringUni((int)us);

        delete [] us;

        return s;
    };

    __property Object* get_Attributes()
    {
        long retVal;

        IfFailThrow(m_pVariable->GetAttributes(&retVal));

        return __box(retVal);
    };

    byte GetSignature(void) __gc [];

    __property SymAddressKind get_AddressKind()
    {
        long retVal;
        SymAddressKind ret;

        IfFailThrow(m_pVariable->GetAddressKind(&retVal));

        switch (retVal)
        {
        case 1:
            ret = ILOffset;
            break;
        case 2:
            ret = NativeRVA;
            break;
        case 3:
            ret = NativeRegister;
            break;
        case 4:
            ret = NativeRegisterRelative;
            break;
        case 5:
            ret = NativeOffset;
            break;
        case 6:
            ret = NativeRegisterRegister;
            break;
        case 7:
            ret = NativeRegisterStack;
            break;
        case 8:
            ret = NativeStackRegister;
            break;
        case 9:
            ret = BitField;
            break;
        }
        return ret;
    };

    __property int get_AddressField1()
    {
        long retVal;

        IfFailThrow(m_pVariable->GetAddressField1(&retVal));

        return retVal;
    };

    __property int get_AddressField2()
    {
        long retVal;

        IfFailThrow(m_pVariable->GetAddressField2(&retVal));

        return retVal;
    };

    __property int get_AddressField3()
    {
        long retVal;

        IfFailThrow(m_pVariable->GetAddressField3(&retVal));

        return retVal;
    };

    __property int get_StartOffset()
    {
        long retVal;

        IfFailThrow(m_pVariable->GetStartOffset(&retVal));

        return retVal;
    };

    __property int get_EndOffset()
    {
        long retVal;

        IfFailThrow(m_pVariable->GetEndOffset(&retVal));

        return retVal;
    };
};

//
// ISymUnmanagedWriter wrapper.
//
__gc public class SymWriter : public ISymbolWriter
{
    ISymUnmanagedWriter **m_ppWriter;
    ISymUnmanagedWriter *m_pUnderlyingWriter;

public:
    SymWriter();

    SymWriter(bool noUnderlyingWriter);

    void InitWriter(bool noUnderlyingWriter);

    ISymUnmanagedWriter *GetWriter(void);

    ~SymWriter();

    ISymbolDocumentWriter *DefineDocument(String *url,
                                          Guid language,
                                          Guid languageVendor,
                                          Guid documentType);

    void SetUserEntryPoint(SymbolToken entryMethod);

    void OpenMethod(SymbolToken method);

    void CloseMethod(void);

    int OpenScope(int startOffset);

    void CloseScope(int endOffset);

    void SetScopeRange(int scopeID, int startOffset, int endOffset);

    void DefineLocalVariable(String *name,
                             FieldAttributes attributes,
                             byte signature __gc [],
                             SymAddressKind addrKind,
                             int addr1,
                             int addr2,
                             int addr3,
                             int startOffset,
                             int endOffset);

    void DefineParameter(String *name,
                         ParameterAttributes attributes,
                         int sequence,
                         SymAddressKind addrKind,
                         int addr1,
                         int addr2,
                         int addr3);

    void DefineField(SymbolToken parent,
                     String *name,
                     FieldAttributes attributes,
                     byte signature __gc [],
                     SymAddressKind addrKind,
                     int addr1,
                     int addr2,
                     int addr3);

    void DefineGlobalVariable(String *name,
                              FieldAttributes attributes,
                              byte signature __gc [],
                              SymAddressKind addrKind,
                              int addr1,
                              int addr2,
                              int addr3);
    void Close();

    void SetSymAttribute(SymbolToken parent, String *name,
                         byte data __gc []);

    void OpenNamespace(String *name);

    void CloseNamespace(void);

    void UsingNamespace(String *fullName);

    void SetMethodSourceRange(ISymbolDocumentWriter *startDoc,
                              int startLine,
                              int startColumn,
                              ISymbolDocumentWriter *endDoc,
                              int endLine,
                              int endColumn);

    void Initialize(IntPtr emitter,
                    String *filename,
                    bool fFullBuild);

    void DefineSequencePoints(ISymbolDocumentWriter *document,
                              int offsets __gc [],
                              int lines __gc [],
                              int columns __gc [],
                              int endLines __gc [],
                              int endColumns __gc []);

    void SetUnderlyingWriter(IntPtr underlyingWriter);
};

//
// ISymUnmanagedBinder wrapper.
//
__gc public class SymBinder : public ISymbolBinder
{
    ISymUnmanagedBinder *m_pBinder;

public:
    SymBinder();
    ~SymBinder();

    ISymbolReader *GetReader(int importer,
                             String *filename,
                             String *searchPath);
};

}; // namespace SymbolStore
}; // namespace Diagnostics
}; // namespace System
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\isymwrapper\ole32def.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*++

Module Name:

	ole32def.h

Abstract:

	This module ...
	...

Author:

	Rudy Opavsky (rudyo) 2-May-1999

Environment:

--*/


typedef long HRESULT;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned char UCHAR;
typedef short SHORT;
typedef unsigned short USHORT;
typedef long BOOL;
typedef long LONG;
typedef long* PLONG;
typedef long* LPLONG;
typedef unsigned long ULONG;
typedef unsigned long DWORD;
typedef char CHAR;
typedef wchar_t WCHAR;
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;
typedef void* LPVOID;

typedef WCHAR OLECHAR;
typedef OLECHAR* LPOLESTR;
typedef const OLECHAR* LPCOLESTR;

#define OLESTR(str) L##str

//
// help macros
//
#define IfFailGo(expression, label)		\
    { HRESULT hresult = (expression);			\
		if(FAILED(hresult))				\
			goto label;					\
    }

#define IfFailRet(expression)			\
    { HRESULT hresult = (expression);	\
		if(FAILED(hresult))				\
			return hresult;				\
    }


struct __GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
};

typedef __GUID GUID;
typedef __GUID *LPGUID;
typedef __GUID IID;
typedef IID *LPIID;
typedef __GUID CLSID;
typedef CLSID *LPCLSID;

typedef __GUID *REFGUID;
typedef IID *REFIID;
typedef CLSID *REFCLSID;


//BOOL  IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
//{
//   return (
//      ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
//      ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
//      ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
//      ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
//}
//
//#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)
//#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)


//
// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
//
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 0x01,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 0x02,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 0x04,    // server exe (runs on same machine; diff proc)
    CLSCTX_INPROC_SERVER16 = 0x08, // 16-bit server dll (runs in same process as caller)
    CLSCTX_REMOTE_SERVER = 0x10,    // remote server exe (runs on different machine)
    CLSCTX_INPROC_HANDLER16 = 0x20, // 16-bit handler dll (runs in same process as caller)
    CLSCTX_INPROC_SERVERX86 = 0x40, // Wx86 server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLERX86 = 0x80, // Wx86 handler dll (runs in same process as caller)
    CLSCTX_ESERVER_HANDLER = 0x100, // handler dll (runs in the server process)
} CLSCTX;

// initialization flags
typedef enum tagCOINIT
{
  COINIT_APARTMENTTHREADED  = 0x2,      // Apartment model
  COINIT_MULTITHREADED      = 0x0,      // OLE calls objects on any thread.
  COINIT_DISABLE_OLE1DDE    = 0x4,      // Don't use DDE for Ole1 support.
  COINIT_SPEED_OVER_MEMORY  = 0x8,      // Trade memory for speed.
} COINIT;

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
	MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2,    // doesn't hold object alive; still must release
    MSHLFLAGS_NOPING = 4        // remote clients dont 'ping' to keep objects alive
} MSHLFLAGS;


// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
    MSHCTX_DIFFERENTMACHINE = 2,// unmarshal context is on a different machine
    MSHCTX_INPROC = 3,          // unmarshal context is on different thread
} MSHCTX;


// This is a helper struct for use in handling currency. 
typedef struct tagCY {
    LONGLONG    int64;
} CY;

typedef CY *LPCY;

typedef struct tagDEC {
    USHORT wReserved;
    BYTE  scale;
    BYTE  sign;
    ULONG Hi32;
    ULONGLONG Lo64;
} DECIMAL;


//
// IUnknown definition
//
__interface IUnknown
{
    virtual HRESULT __stdcall QueryInterface(REFIID riid, void **ppvObject)/* = 0*/;

    virtual ULONG __stdcall AddRef()/* = 0*/;

    virtual ULONG __stdcall Release()/* = 0*/;

};
typedef IUnknown *LPUNKNOWN;



//
// STD Object API
//

[DllImport("ole32")]
extern "C" HRESULT CoInitialize(LPVOID pvReserved);

[DllImport("ole32")]
extern "C" HRESULT CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

[DllImport("ole32")]
extern "C" void CoUninitialize(void);

[DllImport("ole32")]
extern "C" HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv);




//
// Helpers
//

[DllImport("ole32")]
extern "C" HRESULT StringFromCLSID(REFCLSID rclsid, LPOLESTR* lplpsz);

[DllImport("ole32")]
extern "C" HRESULT CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid);

[DllImport("ole32")]
extern "C" HRESULT StringFromIID(REFIID rclsid, LPOLESTR* lplpsz);

[DllImport("ole32")]
extern "C" HRESULT IIDFromString(LPOLESTR lpsz, LPIID lpiid);

[DllImport("ole32")]
extern "C" BOOL CoIsOle1Class(REFCLSID rclsid);

[DllImport("ole32")]
extern "C" HRESULT ProgIDFromCLSID (REFCLSID clsid, LPOLESTR* lplpszProgID);

[DllImport("ole32")]
extern "C" HRESULT CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);

[DllImport("ole32")]
extern "C" int StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\isymwrapper\winerror.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/************************************************************************
*                                                                       *
*   winerror.h --  error code definitions for the Win32 API functions   *
*                                                                       *
************************************************************************/

#ifndef _WINERROR_
#define _WINERROR_


//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_WINDOWS                 8
#define FACILITY_STORAGE                 3
#define FACILITY_SSPI                    9
#define FACILITY_SETUPAPI                15
#define FACILITY_RPC                     1
#define FACILITY_WIN32                   7
#define FACILITY_CONTROL                 10
#define FACILITY_NULL                    0
#define FACILITY_MSMQ                    14
#define FACILITY_MEDIASERVER             13
#define FACILITY_INTERNET                12
#define FACILITY_ITF                     4
#define FACILITY_DISPATCH                2
#define FACILITY_CERT                    11


//
// Define the severity codes
//


//
// MessageId: ERROR_SUCCESS
//
// MessageText:
//
//  The operation completed successfully.
//
#define ERROR_SUCCESS                    0L

#define NO_ERROR 0L                                                 // dderror

//
// MessageId: ERROR_INVALID_FUNCTION
//
// MessageText:
//
//  Incorrect function.
//
#define ERROR_INVALID_FUNCTION           1L    // dderror

//
// MessageId: ERROR_FILE_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the file specified.
//
#define ERROR_FILE_NOT_FOUND             2L

//
// MessageId: ERROR_PATH_NOT_FOUND
//
// MessageText:
//
//  The system cannot find the path specified.
//
#define ERROR_PATH_NOT_FOUND             3L

//
// MessageId: ERROR_TOO_MANY_OPEN_FILES
//
// MessageText:
//
//  The system cannot open the file.
//
#define ERROR_TOO_MANY_OPEN_FILES        4L

//
// MessageId: ERROR_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define ERROR_ACCESS_DENIED              5L

//
// MessageId: ERROR_INVALID_HANDLE
//
// MessageText:
//
//  The handle is invalid.
//
#define ERROR_INVALID_HANDLE             6L

//
// MessageId: ERROR_ARENA_TRASHED
//
// MessageText:
//
//  The storage control blocks were destroyed.
//
#define ERROR_ARENA_TRASHED              7L

//
// MessageId: ERROR_NOT_ENOUGH_MEMORY
//
// MessageText:
//
//  Not enough storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_MEMORY          8L    // dderror

//
// MessageId: ERROR_INVALID_BLOCK
//
// MessageText:
//
//  The storage control block address is invalid.
//
#define ERROR_INVALID_BLOCK              9L

//
// MessageId: ERROR_BAD_ENVIRONMENT
//
// MessageText:
//
//  The environment is incorrect.
//
#define ERROR_BAD_ENVIRONMENT            10L

//
// MessageId: ERROR_BAD_FORMAT
//
// MessageText:
//
//  An attempt was made to load a program with an
//  incorrect format.
//
#define ERROR_BAD_FORMAT                 11L

//
// MessageId: ERROR_INVALID_ACCESS
//
// MessageText:
//
//  The access code is invalid.
//
#define ERROR_INVALID_ACCESS             12L

//
// MessageId: ERROR_INVALID_DATA
//
// MessageText:
//
//  The data is invalid.
//
#define ERROR_INVALID_DATA               13L

//
// MessageId: ERROR_OUTOFMEMORY
//
// MessageText:
//
//  Not enough storage is available to complete this operation.
//
#define ERROR_OUTOFMEMORY                14L

//
// MessageId: ERROR_INVALID_DRIVE
//
// MessageText:
//
//  The system cannot find the drive specified.
//
#define ERROR_INVALID_DRIVE              15L

//
// MessageId: ERROR_CURRENT_DIRECTORY
//
// MessageText:
//
//  The directory cannot be removed.
//
#define ERROR_CURRENT_DIRECTORY          16L

//
// MessageId: ERROR_NOT_SAME_DEVICE
//
// MessageText:
//
//  The system cannot move the file
//  to a different disk drive.
//
#define ERROR_NOT_SAME_DEVICE            17L

//
// MessageId: ERROR_NO_MORE_FILES
//
// MessageText:
//
//  There are no more files.
//
#define ERROR_NO_MORE_FILES              18L

//
// MessageId: ERROR_WRITE_PROTECT
//
// MessageText:
//
//  The media is write protected.
//
#define ERROR_WRITE_PROTECT              19L

//
// MessageId: ERROR_BAD_UNIT
//
// MessageText:
//
//  The system cannot find the device specified.
//
#define ERROR_BAD_UNIT                   20L

//
// MessageId: ERROR_NOT_READY
//
// MessageText:
//
//  The device is not ready.
//
#define ERROR_NOT_READY                  21L

//
// MessageId: ERROR_BAD_COMMAND
//
// MessageText:
//
//  The device does not recognize the command.
//
#define ERROR_BAD_COMMAND                22L

//
// MessageId: ERROR_CRC
//
// MessageText:
//
//  Data error (cyclic redundancy check).
//
#define ERROR_CRC                        23L

//
// MessageId: ERROR_BAD_LENGTH
//
// MessageText:
//
//  The program issued a command but the
//  command length is incorrect.
//
#define ERROR_BAD_LENGTH                 24L

//
// MessageId: ERROR_SEEK
//
// MessageText:
//
//  The drive cannot locate a specific
//  area or track on the disk.
//
#define ERROR_SEEK                       25L

//
// MessageId: ERROR_NOT_DOS_DISK
//
// MessageText:
//
//  The specified disk or diskette cannot be accessed.
//
#define ERROR_NOT_DOS_DISK               26L

//
// MessageId: ERROR_SECTOR_NOT_FOUND
//
// MessageText:
//
//  The drive cannot find the sector requested.
//
#define ERROR_SECTOR_NOT_FOUND           27L

//
// MessageId: ERROR_OUT_OF_PAPER
//
// MessageText:
//
//  The printer is out of paper.
//
#define ERROR_OUT_OF_PAPER               28L

//
// MessageId: ERROR_WRITE_FAULT
//
// MessageText:
//
//  The system cannot write to the specified device.
//
#define ERROR_WRITE_FAULT                29L

//
// MessageId: ERROR_READ_FAULT
//
// MessageText:
//
//  The system cannot read from the specified device.
//
#define ERROR_READ_FAULT                 30L

//
// MessageId: ERROR_GEN_FAILURE
//
// MessageText:
//
//  A device attached to the system is not functioning.
//
#define ERROR_GEN_FAILURE                31L

//
// MessageId: ERROR_SHARING_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  it is being used by another process.
//
#define ERROR_SHARING_VIOLATION          32L

//
// MessageId: ERROR_LOCK_VIOLATION
//
// MessageText:
//
//  The process cannot access the file because
//  another process has locked a portion of the file.
//
#define ERROR_LOCK_VIOLATION             33L

//
// MessageId: ERROR_WRONG_DISK
//
// MessageText:
//
//  The wrong diskette is in the drive.
//  Insert %2 (Volume Serial Number: %3)
//  into drive %1.
//
#define ERROR_WRONG_DISK                 34L

//
// MessageId: ERROR_SHARING_BUFFER_EXCEEDED
//
// MessageText:
//
//  Too many files opened for sharing.
//
#define ERROR_SHARING_BUFFER_EXCEEDED    36L

//
// MessageId: ERROR_HANDLE_EOF
//
// MessageText:
//
//  Reached the end of the file.
//
#define ERROR_HANDLE_EOF                 38L

//
// MessageId: ERROR_HANDLE_DISK_FULL
//
// MessageText:
//
//  The disk is full.
//
#define ERROR_HANDLE_DISK_FULL           39L

//
// MessageId: ERROR_NOT_SUPPORTED
//
// MessageText:
//
//  The network request is not supported.
//
#define ERROR_NOT_SUPPORTED              50L

//
// MessageId: ERROR_REM_NOT_LIST
//
// MessageText:
//
//  The remote computer is not available.
//
#define ERROR_REM_NOT_LIST               51L

//
// MessageId: ERROR_DUP_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define ERROR_DUP_NAME                   52L

//
// MessageId: ERROR_BAD_NETPATH
//
// MessageText:
//
//  The network path was not found.
//
#define ERROR_BAD_NETPATH                53L

//
// MessageId: ERROR_NETWORK_BUSY
//
// MessageText:
//
//  The network is busy.
//
#define ERROR_NETWORK_BUSY               54L

//
// MessageId: ERROR_DEV_NOT_EXIST
//
// MessageText:
//
//  The specified network resource or device is no longer
//  available.
//
#define ERROR_DEV_NOT_EXIST              55L    // dderror

//
// MessageId: ERROR_TOO_MANY_CMDS
//
// MessageText:
//
//  The network BIOS command limit has been reached.
//
#define ERROR_TOO_MANY_CMDS              56L

//
// MessageId: ERROR_ADAP_HDW_ERR
//
// MessageText:
//
//  A network adapter hardware error occurred.
//
#define ERROR_ADAP_HDW_ERR               57L

//
// MessageId: ERROR_BAD_NET_RESP
//
// MessageText:
//
//  The specified server cannot perform the requested
//  operation.
//
#define ERROR_BAD_NET_RESP               58L

//
// MessageId: ERROR_UNEXP_NET_ERR
//
// MessageText:
//
//  An unexpected network error occurred.
//
#define ERROR_UNEXP_NET_ERR              59L

//
// MessageId: ERROR_BAD_REM_ADAP
//
// MessageText:
//
//  The remote adapter is not compatible.
//
#define ERROR_BAD_REM_ADAP               60L

//
// MessageId: ERROR_PRINTQ_FULL
//
// MessageText:
//
//  The printer queue is full.
//
#define ERROR_PRINTQ_FULL                61L

//
// MessageId: ERROR_NO_SPOOL_SPACE
//
// MessageText:
//
//  Space to store the file waiting to be printed is
//  not available on the server.
//
#define ERROR_NO_SPOOL_SPACE             62L

//
// MessageId: ERROR_PRINT_CANCELLED
//
// MessageText:
//
//  Your file waiting to be printed was deleted.
//
#define ERROR_PRINT_CANCELLED            63L

//
// MessageId: ERROR_NETNAME_DELETED
//
// MessageText:
//
//  The specified network name is no longer available.
//
#define ERROR_NETNAME_DELETED            64L

//
// MessageId: ERROR_NETWORK_ACCESS_DENIED
//
// MessageText:
//
//  Network access is denied.
//
#define ERROR_NETWORK_ACCESS_DENIED      65L

//
// MessageId: ERROR_BAD_DEV_TYPE
//
// MessageText:
//
//  The network resource type is not correct.
//
#define ERROR_BAD_DEV_TYPE               66L

//
// MessageId: ERROR_BAD_NET_NAME
//
// MessageText:
//
//  The network name cannot be found.
//
#define ERROR_BAD_NET_NAME               67L

//
// MessageId: ERROR_TOO_MANY_NAMES
//
// MessageText:
//
//  The name limit for the local computer network
//  adapter card was exceeded.
//
#define ERROR_TOO_MANY_NAMES             68L

//
// MessageId: ERROR_TOO_MANY_SESS
//
// MessageText:
//
//  The network BIOS session limit was exceeded.
//
#define ERROR_TOO_MANY_SESS              69L

//
// MessageId: ERROR_SHARING_PAUSED
//
// MessageText:
//
//  The remote server has been paused or is in the
//  process of being started.
//
#define ERROR_SHARING_PAUSED             70L

//
// MessageId: ERROR_REQ_NOT_ACCEP
//
// MessageText:
//
//  No more connections can be made to this remote computer at this time
//  because there are already as many connections as the computer can accept.
//
#define ERROR_REQ_NOT_ACCEP              71L

//
// MessageId: ERROR_REDIR_PAUSED
//
// MessageText:
//
//  The specified printer or disk device has been paused.
//
#define ERROR_REDIR_PAUSED               72L

//
// MessageId: ERROR_FILE_EXISTS
//
// MessageText:
//
//  The file exists.
//
#define ERROR_FILE_EXISTS                80L

//
// MessageId: ERROR_CANNOT_MAKE
//
// MessageText:
//
//  The directory or file cannot be created.
//
#define ERROR_CANNOT_MAKE                82L

//
// MessageId: ERROR_FAIL_I24
//
// MessageText:
//
//  Fail on INT 24.
//
#define ERROR_FAIL_I24                   83L

//
// MessageId: ERROR_OUT_OF_STRUCTURES
//
// MessageText:
//
//  Storage to process this request is not available.
//
#define ERROR_OUT_OF_STRUCTURES          84L

//
// MessageId: ERROR_ALREADY_ASSIGNED
//
// MessageText:
//
//  The local device name is already in use.
//
#define ERROR_ALREADY_ASSIGNED           85L

//
// MessageId: ERROR_INVALID_PASSWORD
//
// MessageText:
//
//  The specified network password is not correct.
//
#define ERROR_INVALID_PASSWORD           86L

//
// MessageId: ERROR_INVALID_PARAMETER
//
// MessageText:
//
//  The parameter is incorrect.
//
#define ERROR_INVALID_PARAMETER          87L    // dderror

//
// MessageId: ERROR_NET_WRITE_FAULT
//
// MessageText:
//
//  A write fault occurred on the network.
//
#define ERROR_NET_WRITE_FAULT            88L

//
// MessageId: ERROR_NO_PROC_SLOTS
//
// MessageText:
//
//  The system cannot start another process at
//  this time.
//
#define ERROR_NO_PROC_SLOTS              89L

//
// MessageId: ERROR_TOO_MANY_SEMAPHORES
//
// MessageText:
//
//  Cannot create another system semaphore.
//
#define ERROR_TOO_MANY_SEMAPHORES        100L

//
// MessageId: ERROR_EXCL_SEM_ALREADY_OWNED
//
// MessageText:
//
//  The exclusive semaphore is owned by another process.
//
#define ERROR_EXCL_SEM_ALREADY_OWNED     101L

//
// MessageId: ERROR_SEM_IS_SET
//
// MessageText:
//
//  The semaphore is set and cannot be closed.
//
#define ERROR_SEM_IS_SET                 102L

//
// MessageId: ERROR_TOO_MANY_SEM_REQUESTS
//
// MessageText:
//
//  The semaphore cannot be set again.
//
#define ERROR_TOO_MANY_SEM_REQUESTS      103L

//
// MessageId: ERROR_INVALID_AT_INTERRUPT_TIME
//
// MessageText:
//
//  Cannot request exclusive semaphores at interrupt time.
//
#define ERROR_INVALID_AT_INTERRUPT_TIME  104L

//
// MessageId: ERROR_SEM_OWNER_DIED
//
// MessageText:
//
//  The previous ownership of this semaphore has ended.
//
#define ERROR_SEM_OWNER_DIED             105L

//
// MessageId: ERROR_SEM_USER_LIMIT
//
// MessageText:
//
//  Insert the diskette for drive %1.
//
#define ERROR_SEM_USER_LIMIT             106L

//
// MessageId: ERROR_DISK_CHANGE
//
// MessageText:
//
//  The program stopped because an alternate diskette was not inserted.
//
#define ERROR_DISK_CHANGE                107L

//
// MessageId: ERROR_DRIVE_LOCKED
//
// MessageText:
//
//  The disk is in use or locked by
//  another process.
//
#define ERROR_DRIVE_LOCKED               108L

//
// MessageId: ERROR_BROKEN_PIPE
//
// MessageText:
//
//  The pipe has been ended.
//
#define ERROR_BROKEN_PIPE                109L

//
// MessageId: ERROR_OPEN_FAILED
//
// MessageText:
//
//  The system cannot open the
//  device or file specified.
//
#define ERROR_OPEN_FAILED                110L

//
// MessageId: ERROR_BUFFER_OVERFLOW
//
// MessageText:
//
//  The file name is too long.
//
#define ERROR_BUFFER_OVERFLOW            111L

//
// MessageId: ERROR_DISK_FULL
//
// MessageText:
//
//  There is not enough space on the disk.
//
#define ERROR_DISK_FULL                  112L

//
// MessageId: ERROR_NO_MORE_SEARCH_HANDLES
//
// MessageText:
//
//  No more internal file identifiers available.
//
#define ERROR_NO_MORE_SEARCH_HANDLES     113L

//
// MessageId: ERROR_INVALID_TARGET_HANDLE
//
// MessageText:
//
//  The target internal file identifier is incorrect.
//
#define ERROR_INVALID_TARGET_HANDLE      114L

//
// MessageId: ERROR_INVALID_CATEGORY
//
// MessageText:
//
//  The IOCTL call made by the application program is
//  not correct.
//
#define ERROR_INVALID_CATEGORY           117L

//
// MessageId: ERROR_INVALID_VERIFY_SWITCH
//
// MessageText:
//
//  The verify-on-write switch parameter value is not
//  correct.
//
#define ERROR_INVALID_VERIFY_SWITCH      118L

//
// MessageId: ERROR_BAD_DRIVER_LEVEL
//
// MessageText:
//
//  The system does not support the command requested.
//
#define ERROR_BAD_DRIVER_LEVEL           119L

//
// MessageId: ERROR_CALL_NOT_IMPLEMENTED
//
// MessageText:
//
//  This function is not supported on this system.
//
#define ERROR_CALL_NOT_IMPLEMENTED       120L

//
// MessageId: ERROR_SEM_TIMEOUT
//
// MessageText:
//
//  The semaphore timeout period has expired.
//
#define ERROR_SEM_TIMEOUT                121L

//
// MessageId: ERROR_INSUFFICIENT_BUFFER
//
// MessageText:
//
//  The data area passed to a system call is too
//  small.
//
#define ERROR_INSUFFICIENT_BUFFER        122L    // dderror

//
// MessageId: ERROR_INVALID_NAME
//
// MessageText:
//
//  The filename, directory name, or volume label syntax is incorrect.
//
#define ERROR_INVALID_NAME               123L

//
// MessageId: ERROR_INVALID_LEVEL
//
// MessageText:
//
//  The system call level is not correct.
//
#define ERROR_INVALID_LEVEL              124L

//
// MessageId: ERROR_NO_VOLUME_LABEL
//
// MessageText:
//
//  The disk has no volume label.
//
#define ERROR_NO_VOLUME_LABEL            125L

//
// MessageId: ERROR_MOD_NOT_FOUND
//
// MessageText:
//
//  The specified module could not be found.
//
#define ERROR_MOD_NOT_FOUND              126L

//
// MessageId: ERROR_PROC_NOT_FOUND
//
// MessageText:
//
//  The specified procedure could not be found.
//
#define ERROR_PROC_NOT_FOUND             127L

//
// MessageId: ERROR_WAIT_NO_CHILDREN
//
// MessageText:
//
//  There are no child processes to wait for.
//
#define ERROR_WAIT_NO_CHILDREN           128L

//
// MessageId: ERROR_CHILD_NOT_COMPLETE
//
// MessageText:
//
//  The %1 application cannot be run in Win32 mode.
//
#define ERROR_CHILD_NOT_COMPLETE         129L

//
// MessageId: ERROR_DIRECT_ACCESS_HANDLE
//
// MessageText:
//
//  Attempt to use a file handle to an open disk partition for an
//  operation other than raw disk I/O.
//
#define ERROR_DIRECT_ACCESS_HANDLE       130L

//
// MessageId: ERROR_NEGATIVE_SEEK
//
// MessageText:
//
//  An attempt was made to move the file pointer before the beginning of the file.
//
#define ERROR_NEGATIVE_SEEK              131L

//
// MessageId: ERROR_SEEK_ON_DEVICE
//
// MessageText:
//
//  The file pointer cannot be set on the specified device or file.
//
#define ERROR_SEEK_ON_DEVICE             132L

//
// MessageId: ERROR_IS_JOIN_TARGET
//
// MessageText:
//
//  A JOIN or SUBST command
//  cannot be used for a drive that
//  contains previously joined drives.
//
#define ERROR_IS_JOIN_TARGET             133L

//
// MessageId: ERROR_IS_JOINED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been joined.
//
#define ERROR_IS_JOINED                  134L

//
// MessageId: ERROR_IS_SUBSTED
//
// MessageText:
//
//  An attempt was made to use a
//  JOIN or SUBST command on a drive that has
//  already been substituted.
//
#define ERROR_IS_SUBSTED                 135L

//
// MessageId: ERROR_NOT_JOINED
//
// MessageText:
//
//  The system tried to delete
//  the JOIN of a drive that is not joined.
//
#define ERROR_NOT_JOINED                 136L

//
// MessageId: ERROR_NOT_SUBSTED
//
// MessageText:
//
//  The system tried to delete the
//  substitution of a drive that is not substituted.
//
#define ERROR_NOT_SUBSTED                137L

//
// MessageId: ERROR_JOIN_TO_JOIN
//
// MessageText:
//
//  The system tried to join a drive
//  to a directory on a joined drive.
//
#define ERROR_JOIN_TO_JOIN               138L

//
// MessageId: ERROR_SUBST_TO_SUBST
//
// MessageText:
//
//  The system tried to substitute a
//  drive to a directory on a substituted drive.
//
#define ERROR_SUBST_TO_SUBST             139L

//
// MessageId: ERROR_JOIN_TO_SUBST
//
// MessageText:
//
//  The system tried to join a drive to
//  a directory on a substituted drive.
//
#define ERROR_JOIN_TO_SUBST              140L

//
// MessageId: ERROR_SUBST_TO_JOIN
//
// MessageText:
//
//  The system tried to SUBST a drive
//  to a directory on a joined drive.
//
#define ERROR_SUBST_TO_JOIN              141L

//
// MessageId: ERROR_BUSY_DRIVE
//
// MessageText:
//
//  The system cannot perform a JOIN or SUBST at this time.
//
#define ERROR_BUSY_DRIVE                 142L

//
// MessageId: ERROR_SAME_DRIVE
//
// MessageText:
//
//  The system cannot join or substitute a
//  drive to or for a directory on the same drive.
//
#define ERROR_SAME_DRIVE                 143L

//
// MessageId: ERROR_DIR_NOT_ROOT
//
// MessageText:
//
//  The directory is not a subdirectory of the root directory.
//
#define ERROR_DIR_NOT_ROOT               144L

//
// MessageId: ERROR_DIR_NOT_EMPTY
//
// MessageText:
//
//  The directory is not empty.
//
#define ERROR_DIR_NOT_EMPTY              145L

//
// MessageId: ERROR_IS_SUBST_PATH
//
// MessageText:
//
//  The path specified is being used in
//  a substitute.
//
#define ERROR_IS_SUBST_PATH              146L

//
// MessageId: ERROR_IS_JOIN_PATH
//
// MessageText:
//
//  Not enough resources are available to
//  process this command.
//
#define ERROR_IS_JOIN_PATH               147L

//
// MessageId: ERROR_PATH_BUSY
//
// MessageText:
//
//  The path specified cannot be used at this time.
//
#define ERROR_PATH_BUSY                  148L

//
// MessageId: ERROR_IS_SUBST_TARGET
//
// MessageText:
//
//  An attempt was made to join
//  or substitute a drive for which a directory
//  on the drive is the target of a previous
//  substitute.
//
#define ERROR_IS_SUBST_TARGET            149L

//
// MessageId: ERROR_SYSTEM_TRACE
//
// MessageText:
//
//  System trace information was not specified in your
//  CONFIG.SYS file, or tracing is disallowed.
//
#define ERROR_SYSTEM_TRACE               150L

//
// MessageId: ERROR_INVALID_EVENT_COUNT
//
// MessageText:
//
//  The number of specified semaphore events for
//  DosMuxSemWait is not correct.
//
#define ERROR_INVALID_EVENT_COUNT        151L

//
// MessageId: ERROR_TOO_MANY_MUXWAITERS
//
// MessageText:
//
//  DosMuxSemWait did not execute; too many semaphores
//  are already set.
//
#define ERROR_TOO_MANY_MUXWAITERS        152L

//
// MessageId: ERROR_INVALID_LIST_FORMAT
//
// MessageText:
//
//  The DosMuxSemWait list is not correct.
//
#define ERROR_INVALID_LIST_FORMAT        153L

//
// MessageId: ERROR_LABEL_TOO_LONG
//
// MessageText:
//
//  The volume label you entered exceeds the label character
//  limit of the target file system.
//
#define ERROR_LABEL_TOO_LONG             154L

//
// MessageId: ERROR_TOO_MANY_TCBS
//
// MessageText:
//
//  Cannot create another thread.
//
#define ERROR_TOO_MANY_TCBS              155L

//
// MessageId: ERROR_SIGNAL_REFUSED
//
// MessageText:
//
//  The recipient process has refused the signal.
//
#define ERROR_SIGNAL_REFUSED             156L

//
// MessageId: ERROR_DISCARDED
//
// MessageText:
//
//  The segment is already discarded and cannot be locked.
//
#define ERROR_DISCARDED                  157L

//
// MessageId: ERROR_NOT_LOCKED
//
// MessageText:
//
//  The segment is already unlocked.
//
#define ERROR_NOT_LOCKED                 158L

//
// MessageId: ERROR_BAD_THREADID_ADDR
//
// MessageText:
//
//  The address for the thread ID is not correct.
//
#define ERROR_BAD_THREADID_ADDR          159L

//
// MessageId: ERROR_BAD_ARGUMENTS
//
// MessageText:
//
//  The argument string passed to DosExecPgm is not correct.
//
#define ERROR_BAD_ARGUMENTS              160L

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//
#define ERROR_BAD_PATHNAME               161L

//
// MessageId: ERROR_SIGNAL_PENDING
//
// MessageText:
//
//  A signal is already pending.
//
#define ERROR_SIGNAL_PENDING             162L

//
// MessageId: ERROR_MAX_THRDS_REACHED
//
// MessageText:
//
//  No more threads can be created in the system.
//
#define ERROR_MAX_THRDS_REACHED          164L

//
// MessageId: ERROR_LOCK_FAILED
//
// MessageText:
//
//  Unable to lock a region of a file.
//
#define ERROR_LOCK_FAILED                167L

//
// MessageId: ERROR_BUSY
//
// MessageText:
//
//  The requested resource is in use.
//
#define ERROR_BUSY                       170L

//
// MessageId: ERROR_CANCEL_VIOLATION
//
// MessageText:
//
//  A lock request was not outstanding for the supplied cancel region.
//
#define ERROR_CANCEL_VIOLATION           173L

//
// MessageId: ERROR_ATOMIC_LOCKS_NOT_SUPPORTED
//
// MessageText:
//
//  The file system does not support atomic changes to the lock type.
//
#define ERROR_ATOMIC_LOCKS_NOT_SUPPORTED 174L

//
// MessageId: ERROR_INVALID_SEGMENT_NUMBER
//
// MessageText:
//
//  The system detected a segment number that was not correct.
//
#define ERROR_INVALID_SEGMENT_NUMBER     180L

//
// MessageId: ERROR_INVALID_ORDINAL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_ORDINAL            182L

//
// MessageId: ERROR_ALREADY_EXISTS
//
// MessageText:
//
//  Cannot create a file when that file already exists.
//
#define ERROR_ALREADY_EXISTS             183L

//
// MessageId: ERROR_INVALID_FLAG_NUMBER
//
// MessageText:
//
//  The flag passed is not correct.
//
#define ERROR_INVALID_FLAG_NUMBER        186L

//
// MessageId: ERROR_SEM_NOT_FOUND
//
// MessageText:
//
//  The specified system semaphore name was not found.
//
#define ERROR_SEM_NOT_FOUND              187L

//
// MessageId: ERROR_INVALID_STARTING_CODESEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STARTING_CODESEG   188L

//
// MessageId: ERROR_INVALID_STACKSEG
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_STACKSEG           189L

//
// MessageId: ERROR_INVALID_MODULETYPE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MODULETYPE         190L

//
// MessageId: ERROR_INVALID_EXE_SIGNATURE
//
// MessageText:
//
//  Cannot run %1 in Win32 mode.
//
#define ERROR_INVALID_EXE_SIGNATURE      191L

//
// MessageId: ERROR_EXE_MARKED_INVALID
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_EXE_MARKED_INVALID         192L

//
// MessageId: ERROR_BAD_EXE_FORMAT
//
// MessageText:
//
//  %1 is not a valid Win32 application.
//
#define ERROR_BAD_EXE_FORMAT             193L

//
// MessageId: ERROR_ITERATED_DATA_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_ITERATED_DATA_EXCEEDS_64k  194L

//
// MessageId: ERROR_INVALID_MINALLOCSIZE
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_MINALLOCSIZE       195L

//
// MessageId: ERROR_DYNLINK_FROM_INVALID_RING
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_DYNLINK_FROM_INVALID_RING  196L

//
// MessageId: ERROR_IOPL_NOT_ENABLED
//
// MessageText:
//
//  The operating system is not presently
//  configured to run this application.
//
#define ERROR_IOPL_NOT_ENABLED           197L

//
// MessageId: ERROR_INVALID_SEGDPL
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INVALID_SEGDPL             198L

//
// MessageId: ERROR_AUTODATASEG_EXCEEDS_64k
//
// MessageText:
//
//  The operating system cannot run this
//  application program.
//
#define ERROR_AUTODATASEG_EXCEEDS_64k    199L

//
// MessageId: ERROR_RING2SEG_MUST_BE_MOVABLE
//
// MessageText:
//
//  The code segment cannot be greater than or equal to 64K.
//
#define ERROR_RING2SEG_MUST_BE_MOVABLE   200L

//
// MessageId: ERROR_RELOC_CHAIN_XEEDS_SEGLIM
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_RELOC_CHAIN_XEEDS_SEGLIM   201L

//
// MessageId: ERROR_INFLOOP_IN_RELOC_CHAIN
//
// MessageText:
//
//  The operating system cannot run %1.
//
#define ERROR_INFLOOP_IN_RELOC_CHAIN     202L

//
// MessageId: ERROR_ENVVAR_NOT_FOUND
//
// MessageText:
//
//  The system could not find the environment
//  option that was entered.
//
#define ERROR_ENVVAR_NOT_FOUND           203L

//
// MessageId: ERROR_NO_SIGNAL_SENT
//
// MessageText:
//
//  No process in the command subtree has a
//  signal handler.
//
#define ERROR_NO_SIGNAL_SENT             205L

//
// MessageId: ERROR_FILENAME_EXCED_RANGE
//
// MessageText:
//
//  The filename or extension is too long.
//
#define ERROR_FILENAME_EXCED_RANGE       206L

//
// MessageId: ERROR_RING2_STACK_IN_USE
//
// MessageText:
//
//  The ring 2 stack is in use.
//
#define ERROR_RING2_STACK_IN_USE         207L

//
// MessageId: ERROR_META_EXPANSION_TOO_LONG
//
// MessageText:
//
//  The global filename characters, * or ?, are entered
//  incorrectly or too many global filename characters are specified.
//
#define ERROR_META_EXPANSION_TOO_LONG    208L

//
// MessageId: ERROR_INVALID_SIGNAL_NUMBER
//
// MessageText:
//
//  The signal being posted is not correct.
//
#define ERROR_INVALID_SIGNAL_NUMBER      209L

//
// MessageId: ERROR_THREAD_1_INACTIVE
//
// MessageText:
//
//  The signal handler cannot be set.
//
#define ERROR_THREAD_1_INACTIVE          210L

//
// MessageId: ERROR_LOCKED
//
// MessageText:
//
//  The segment is locked and cannot be reallocated.
//
#define ERROR_LOCKED                     212L

//
// MessageId: ERROR_TOO_MANY_MODULES
//
// MessageText:
//
//  Too many dynamic-link modules are attached to this
//  program or dynamic-link module.
//
#define ERROR_TOO_MANY_MODULES           214L

//
// MessageId: ERROR_NESTING_NOT_ALLOWED
//
// MessageText:
//
//  Can't nest calls to LoadModule.
//
#define ERROR_NESTING_NOT_ALLOWED        215L

//
// MessageId: ERROR_EXE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
//  The image file %1 is valid, but is for a machine type other
//  than the current machine.
//
#define ERROR_EXE_MACHINE_TYPE_MISMATCH  216L

//
// MessageId: ERROR_BAD_PIPE
//
// MessageText:
//
//  The pipe state is invalid.
//
#define ERROR_BAD_PIPE                   230L

//
// MessageId: ERROR_PIPE_BUSY
//
// MessageText:
//
//  All pipe instances are busy.
//
#define ERROR_PIPE_BUSY                  231L

//
// MessageId: ERROR_NO_DATA
//
// MessageText:
//
//  The pipe is being closed.
//
#define ERROR_NO_DATA                    232L

//
// MessageId: ERROR_PIPE_NOT_CONNECTED
//
// MessageText:
//
//  No process is on the other end of the pipe.
//
#define ERROR_PIPE_NOT_CONNECTED         233L

//
// MessageId: ERROR_MORE_DATA
//
// MessageText:
//
//  More data is available.
//
#define ERROR_MORE_DATA                  234L    // dderror

//
// MessageId: ERROR_VC_DISCONNECTED
//
// MessageText:
//
//  The session was canceled.
//
#define ERROR_VC_DISCONNECTED            240L

//
// MessageId: ERROR_INVALID_EA_NAME
//
// MessageText:
//
//  The specified extended attribute name was invalid.
//
#define ERROR_INVALID_EA_NAME            254L

//
// MessageId: ERROR_EA_LIST_INCONSISTENT
//
// MessageText:
//
//  The extended attributes are inconsistent.
//
#define ERROR_EA_LIST_INCONSISTENT       255L

//
// MessageId: ERROR_NO_MORE_ITEMS
//
// MessageText:
//
//  No more data is available.
//
#define ERROR_NO_MORE_ITEMS              259L

//
// MessageId: ERROR_CANNOT_COPY
//
// MessageText:
//
//  The copy functions cannot be used.
//
#define ERROR_CANNOT_COPY                266L

//
// MessageId: ERROR_DIRECTORY
//
// MessageText:
//
//  The directory name is invalid.
//
#define ERROR_DIRECTORY                  267L

//
// MessageId: ERROR_EAS_DIDNT_FIT
//
// MessageText:
//
//  The extended attributes did not fit in the buffer.
//
#define ERROR_EAS_DIDNT_FIT              275L

//
// MessageId: ERROR_EA_FILE_CORRUPT
//
// MessageText:
//
//  The extended attribute file on the mounted file system is corrupt.
//
#define ERROR_EA_FILE_CORRUPT            276L

//
// MessageId: ERROR_EA_TABLE_FULL
//
// MessageText:
//
//  The extended attribute table file is full.
//
#define ERROR_EA_TABLE_FULL              277L

//
// MessageId: ERROR_INVALID_EA_HANDLE
//
// MessageText:
//
//  The specified extended attribute handle is invalid.
//
#define ERROR_INVALID_EA_HANDLE          278L

//
// MessageId: ERROR_EAS_NOT_SUPPORTED
//
// MessageText:
//
//  The mounted file system does not support extended attributes.
//
#define ERROR_EAS_NOT_SUPPORTED          282L

//
// MessageId: ERROR_NOT_OWNER
//
// MessageText:
//
//  Attempt to release mutex not owned by caller.
//
#define ERROR_NOT_OWNER                  288L

//
// MessageId: ERROR_TOO_MANY_POSTS
//
// MessageText:
//
//  Too many posts were made to a semaphore.
//
#define ERROR_TOO_MANY_POSTS             298L

//
// MessageId: ERROR_PARTIAL_COPY
//
// MessageText:
//
//  Only part of a ReadProcessMemoty or WriteProcessMemory request was completed.
//
#define ERROR_PARTIAL_COPY               299L

//
// MessageId: ERROR_OPLOCK_NOT_GRANTED
//
// MessageText:
//
//  The oplock request is denied.
//
#define ERROR_OPLOCK_NOT_GRANTED         300L

//
// MessageId: ERROR_INVALID_OPLOCK_PROTOCOL
//
// MessageText:
//
//  An invalid oplock acknowledgment was received by the system.
//
#define ERROR_INVALID_OPLOCK_PROTOCOL    301L

//
// MessageId: ERROR_MR_MID_NOT_FOUND
//
// MessageText:
//
//  The system cannot find message text for message number 0x%1
//  in the message file for %2.
//
#define ERROR_MR_MID_NOT_FOUND           317L

//
// MessageId: ERROR_INVALID_ADDRESS
//
// MessageText:
//
//  Attempt to access invalid address.
//
#define ERROR_INVALID_ADDRESS            487L

//
// MessageId: ERROR_ARITHMETIC_OVERFLOW
//
// MessageText:
//
//  Arithmetic result exceeded 32 bits.
//
#define ERROR_ARITHMETIC_OVERFLOW        534L

//
// MessageId: ERROR_PIPE_CONNECTED
//
// MessageText:
//
//  There is a process on other end of the pipe.
//
#define ERROR_PIPE_CONNECTED             535L

//
// MessageId: ERROR_PIPE_LISTENING
//
// MessageText:
//
//  Waiting for a process to open the other end of the pipe.
//
#define ERROR_PIPE_LISTENING             536L

//
// MessageId: ERROR_EA_ACCESS_DENIED
//
// MessageText:
//
//  Access to the extended attribute was denied.
//
#define ERROR_EA_ACCESS_DENIED           994L

//
// MessageId: ERROR_OPERATION_ABORTED
//
// MessageText:
//
//  The I/O operation has been aborted because of either a thread exit
//  or an application request.
//
#define ERROR_OPERATION_ABORTED          995L

//
// MessageId: ERROR_IO_INCOMPLETE
//
// MessageText:
//
//  Overlapped I/O event is not in a signaled state.
//
#define ERROR_IO_INCOMPLETE              996L

//
// MessageId: ERROR_IO_PENDING
//
// MessageText:
//
//  Overlapped I/O operation is in progress.
//
#define ERROR_IO_PENDING                 997L    // dderror

//
// MessageId: ERROR_NOACCESS
//
// MessageText:
//
//  Invalid access to memory location.
//
#define ERROR_NOACCESS                   998L

//
// MessageId: ERROR_SWAPERROR
//
// MessageText:
//
//  Error performing inpage operation.
//
#define ERROR_SWAPERROR                  999L

//
// MessageId: ERROR_STACK_OVERFLOW
//
// MessageText:
//
//  Recursion too deep; the stack overflowed.
//
#define ERROR_STACK_OVERFLOW             1001L

//
// MessageId: ERROR_INVALID_MESSAGE
//
// MessageText:
//
//  The window cannot act on the sent message.
//
#define ERROR_INVALID_MESSAGE            1002L

//
// MessageId: ERROR_CAN_NOT_COMPLETE
//
// MessageText:
//
//  Cannot complete this function.
//
#define ERROR_CAN_NOT_COMPLETE           1003L

//
// MessageId: ERROR_INVALID_FLAGS
//
// MessageText:
//
//  Invalid flags.
//
#define ERROR_INVALID_FLAGS              1004L

//
// MessageId: ERROR_UNRECOGNIZED_VOLUME
//
// MessageText:
//
//  The volume does not contain a recognized file system.
//  Please make sure that all required file system drivers are loaded and that the
//  volume is not corrupted.
//
#define ERROR_UNRECOGNIZED_VOLUME        1005L

//
// MessageId: ERROR_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered so that the
//  opened file is no longer valid.
//
#define ERROR_FILE_INVALID               1006L

//
// MessageId: ERROR_FULLSCREEN_MODE
//
// MessageText:
//
//  The requested operation cannot be performed in full-screen mode.
//
#define ERROR_FULLSCREEN_MODE            1007L

//
// MessageId: ERROR_NO_TOKEN
//
// MessageText:
//
//  An attempt was made to reference a token that does not exist.
//
#define ERROR_NO_TOKEN                   1008L

//
// MessageId: ERROR_BADDB
//
// MessageText:
//
//  The configuration registry database is corrupt.
//
#define ERROR_BADDB                      1009L

//
// MessageId: ERROR_BADKEY
//
// MessageText:
//
//  The configuration registry key is invalid.
//
#define ERROR_BADKEY                     1010L

//
// MessageId: ERROR_CANTOPEN
//
// MessageText:
//
//  The configuration registry key could not be opened.
//
#define ERROR_CANTOPEN                   1011L

//
// MessageId: ERROR_CANTREAD
//
// MessageText:
//
//  The configuration registry key could not be read.
//
#define ERROR_CANTREAD                   1012L

//
// MessageId: ERROR_CANTWRITE
//
// MessageText:
//
//  The configuration registry key could not be written.
//
#define ERROR_CANTWRITE                  1013L

//
// MessageId: ERROR_REGISTRY_RECOVERED
//
// MessageText:
//
//  One of the files in the registry database had to be recovered
//  by use of a log or alternate copy.  The recovery was successful.
//
#define ERROR_REGISTRY_RECOVERED         1014L

//
// MessageId: ERROR_REGISTRY_CORRUPT
//
// MessageText:
//
//  The registry is corrupted. The structure of one of the files that contains
//  registry data is corrupted, or the system's image of the file in memory
//  is corrupted, or the file could not be recovered because the alternate
//  copy or log was absent or corrupted.
//
#define ERROR_REGISTRY_CORRUPT           1015L

//
// MessageId: ERROR_REGISTRY_IO_FAILED
//
// MessageText:
//
//  An I/O operation initiated by the registry failed unrecoverably.
//  The registry could not read in, or write out, or flush, one of the files
//  that contain the system's image of the registry.
//
#define ERROR_REGISTRY_IO_FAILED         1016L

//
// MessageId: ERROR_NOT_REGISTRY_FILE
//
// MessageText:
//
//  The system has attempted to load or restore a file into the registry, but the
//  specified file is not in a registry file format.
//
#define ERROR_NOT_REGISTRY_FILE          1017L

//
// MessageId: ERROR_KEY_DELETED
//
// MessageText:
//
//  Illegal operation attempted on a registry key that has been marked for deletion.
//
#define ERROR_KEY_DELETED                1018L

//
// MessageId: ERROR_NO_LOG_SPACE
//
// MessageText:
//
//  System could not allocate the required space in a registry log.
//
#define ERROR_NO_LOG_SPACE               1019L

//
// MessageId: ERROR_KEY_HAS_CHILDREN
//
// MessageText:
//
//  Cannot create a symbolic link in a registry key that already
//  has subkeys or values.
//
#define ERROR_KEY_HAS_CHILDREN           1020L

//
// MessageId: ERROR_CHILD_MUST_BE_VOLATILE
//
// MessageText:
//
//  Cannot create a stable subkey under a volatile parent key.
//
#define ERROR_CHILD_MUST_BE_VOLATILE     1021L

//
// MessageId: ERROR_NOTIFY_ENUM_DIR
//
// MessageText:
//
//  A notify change request is being completed and the information
//  is not being returned in the caller's buffer. The caller now
//  needs to enumerate the files to find the changes.
//
#define ERROR_NOTIFY_ENUM_DIR            1022L

//
// MessageId: ERROR_DEPENDENT_SERVICES_RUNNING
//
// MessageText:
//
//  A stop control has been sent to a service that other running services
//  are dependent on.
//
#define ERROR_DEPENDENT_SERVICES_RUNNING 1051L

//
// MessageId: ERROR_INVALID_SERVICE_CONTROL
//
// MessageText:
//
//  The requested control is not valid for this service.
//
#define ERROR_INVALID_SERVICE_CONTROL    1052L

//
// MessageId: ERROR_SERVICE_REQUEST_TIMEOUT
//
// MessageText:
//
//  The service did not respond to the start or control request in a timely
//  fashion.
//
#define ERROR_SERVICE_REQUEST_TIMEOUT    1053L

//
// MessageId: ERROR_SERVICE_NO_THREAD
//
// MessageText:
//
//  A thread could not be created for the service.
//
#define ERROR_SERVICE_NO_THREAD          1054L

//
// MessageId: ERROR_SERVICE_DATABASE_LOCKED
//
// MessageText:
//
//  The service database is locked.
//
#define ERROR_SERVICE_DATABASE_LOCKED    1055L

//
// MessageId: ERROR_SERVICE_ALREADY_RUNNING
//
// MessageText:
//
//  An instance of the service is already running.
//
#define ERROR_SERVICE_ALREADY_RUNNING    1056L

//
// MessageId: ERROR_INVALID_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account name is invalid or does not exist.
//
#define ERROR_INVALID_SERVICE_ACCOUNT    1057L

//
// MessageId: ERROR_SERVICE_DISABLED
//
// MessageText:
//
//  The service cannot be started, either because it is disabled or because
//  it has no enabled devices associated with it.
//
#define ERROR_SERVICE_DISABLED           1058L

//
// MessageId: ERROR_CIRCULAR_DEPENDENCY
//
// MessageText:
//
//  Circular service dependency was specified.
//
#define ERROR_CIRCULAR_DEPENDENCY        1059L

//
// MessageId: ERROR_SERVICE_DOES_NOT_EXIST
//
// MessageText:
//
//  The specified service does not exist as an installed service.
//
#define ERROR_SERVICE_DOES_NOT_EXIST     1060L

//
// MessageId: ERROR_SERVICE_CANNOT_ACCEPT_CTRL
//
// MessageText:
//
//  The service cannot accept control messages at this time.
//
#define ERROR_SERVICE_CANNOT_ACCEPT_CTRL 1061L

//
// MessageId: ERROR_SERVICE_NOT_ACTIVE
//
// MessageText:
//
//  The service has not been started.
//
#define ERROR_SERVICE_NOT_ACTIVE         1062L

//
// MessageId: ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
//
// MessageText:
//
//  The service process could not connect to the service controller.
//
#define ERROR_FAILED_SERVICE_CONTROLLER_CONNECT 1063L

//
// MessageId: ERROR_EXCEPTION_IN_SERVICE
//
// MessageText:
//
//  An exception occurred in the service when handling the control request.
//
#define ERROR_EXCEPTION_IN_SERVICE       1064L

//
// MessageId: ERROR_DATABASE_DOES_NOT_EXIST
//
// MessageText:
//
//  The database specified does not exist.
//
#define ERROR_DATABASE_DOES_NOT_EXIST    1065L

//
// MessageId: ERROR_SERVICE_SPECIFIC_ERROR
//
// MessageText:
//
//  The service has returned a service-specific error code.
//
#define ERROR_SERVICE_SPECIFIC_ERROR     1066L

//
// MessageId: ERROR_PROCESS_ABORTED
//
// MessageText:
//
//  The process terminated unexpectedly.
//
#define ERROR_PROCESS_ABORTED            1067L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_FAIL
//
// MessageText:
//
//  The dependency service or group failed to start.
//
#define ERROR_SERVICE_DEPENDENCY_FAIL    1068L

//
// MessageId: ERROR_SERVICE_LOGON_FAILED
//
// MessageText:
//
//  The service did not start due to a logon failure.
//
#define ERROR_SERVICE_LOGON_FAILED       1069L

//
// MessageId: ERROR_SERVICE_START_HANG
//
// MessageText:
//
//  After starting, the service hung in a start-pending state.
//
#define ERROR_SERVICE_START_HANG         1070L

//
// MessageId: ERROR_INVALID_SERVICE_LOCK
//
// MessageText:
//
//  The specified service database lock is invalid.
//
#define ERROR_INVALID_SERVICE_LOCK       1071L

//
// MessageId: ERROR_SERVICE_MARKED_FOR_DELETE
//
// MessageText:
//
//  The specified service has been marked for deletion.
//
#define ERROR_SERVICE_MARKED_FOR_DELETE  1072L

//
// MessageId: ERROR_SERVICE_EXISTS
//
// MessageText:
//
//  The specified service already exists.
//
#define ERROR_SERVICE_EXISTS             1073L

//
// MessageId: ERROR_ALREADY_RUNNING_LKG
//
// MessageText:
//
//  The system is currently running with the last-known-good configuration.
//
#define ERROR_ALREADY_RUNNING_LKG        1074L

//
// MessageId: ERROR_SERVICE_DEPENDENCY_DELETED
//
// MessageText:
//
//  The dependency service does not exist or has been marked for
//  deletion.
//
#define ERROR_SERVICE_DEPENDENCY_DELETED 1075L

//
// MessageId: ERROR_BOOT_ALREADY_ACCEPTED
//
// MessageText:
//
//  The current boot has already been accepted for use as the
//  last-known-good control set.
//
#define ERROR_BOOT_ALREADY_ACCEPTED      1076L

//
// MessageId: ERROR_SERVICE_NEVER_STARTED
//
// MessageText:
//
//  No attempts to start the service have been made since the last boot.
//
#define ERROR_SERVICE_NEVER_STARTED      1077L

//
// MessageId: ERROR_DUPLICATE_SERVICE_NAME
//
// MessageText:
//
//  The name is already in use as either a service name or a service display
//  name.
//
#define ERROR_DUPLICATE_SERVICE_NAME     1078L

//
// MessageId: ERROR_DIFFERENT_SERVICE_ACCOUNT
//
// MessageText:
//
//  The account specified for this service is different from the account
//  specified for other services running in the same process.
//
#define ERROR_DIFFERENT_SERVICE_ACCOUNT  1079L

//
// MessageId: ERROR_CANNOT_DETECT_DRIVER_FAILURE
//
// MessageText:
//
//  Failure actions can only be set for Win32 services, not for drivers.
//
#define ERROR_CANNOT_DETECT_DRIVER_FAILURE 1080L

//
// MessageId: ERROR_CANNOT_DETECT_PROCESS_ABORT
//
// MessageText:
//
//  This service runs in the same process as the service control manager.
//  Therefore, the service control manager cannot take action if this
//  service's process terminates unexpectedly.
//
#define ERROR_CANNOT_DETECT_PROCESS_ABORT 1081L

//
// MessageId: ERROR_NO_RECOVERY_PROGRAM
//
// MessageText:
//
//  No recovery program has been configured for this service.
//
#define ERROR_NO_RECOVERY_PROGRAM        1082L

//
// MessageId: ERROR_END_OF_MEDIA
//
// MessageText:
//
//  The physical end of the tape has been reached.
//
#define ERROR_END_OF_MEDIA               1100L

//
// MessageId: ERROR_FILEMARK_DETECTED
//
// MessageText:
//
//  A tape access reached a filemark.
//
#define ERROR_FILEMARK_DETECTED          1101L

//
// MessageId: ERROR_BEGINNING_OF_MEDIA
//
// MessageText:
//
//  The beginning of the tape or a partition was encountered.
//
#define ERROR_BEGINNING_OF_MEDIA         1102L

//
// MessageId: ERROR_SETMARK_DETECTED
//
// MessageText:
//
//  A tape access reached the end of a set of files.
//
#define ERROR_SETMARK_DETECTED           1103L

//
// MessageId: ERROR_NO_DATA_DETECTED
//
// MessageText:
//
//  No more data is on the tape.
//
#define ERROR_NO_DATA_DETECTED           1104L

//
// MessageId: ERROR_PARTITION_FAILURE
//
// MessageText:
//
//  Tape could not be partitioned.
//
#define ERROR_PARTITION_FAILURE          1105L

//
// MessageId: ERROR_INVALID_BLOCK_LENGTH
//
// MessageText:
//
//  When accessing a new tape of a multivolume partition, the current
//  blocksize is incorrect.
//
#define ERROR_INVALID_BLOCK_LENGTH       1106L

//
// MessageId: ERROR_DEVICE_NOT_PARTITIONED
//
// MessageText:
//
//  Tape partition information could not be found when loading a tape.
//
#define ERROR_DEVICE_NOT_PARTITIONED     1107L

//
// MessageId: ERROR_UNABLE_TO_LOCK_MEDIA
//
// MessageText:
//
//  Unable to lock the media eject mechanism.
//
#define ERROR_UNABLE_TO_LOCK_MEDIA       1108L

//
// MessageId: ERROR_UNABLE_TO_UNLOAD_MEDIA
//
// MessageText:
//
//  Unable to unload the media.
//
#define ERROR_UNABLE_TO_UNLOAD_MEDIA     1109L

//
// MessageId: ERROR_MEDIA_CHANGED
//
// MessageText:
//
//  The media in the drive may have changed.
//
#define ERROR_MEDIA_CHANGED              1110L

//
// MessageId: ERROR_BUS_RESET
//
// MessageText:
//
//  The I/O bus was reset.
//
#define ERROR_BUS_RESET                  1111L

//
// MessageId: ERROR_NO_MEDIA_IN_DRIVE
//
// MessageText:
//
//  No media in drive.
//
#define ERROR_NO_MEDIA_IN_DRIVE          1112L

//
// MessageId: ERROR_NO_UNICODE_TRANSLATION
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define ERROR_NO_UNICODE_TRANSLATION     1113L

//
// MessageId: ERROR_DLL_INIT_FAILED
//
// MessageText:
//
//  A dynamic link library (DLL) initialization routine failed.
//
#define ERROR_DLL_INIT_FAILED            1114L

//
// MessageId: ERROR_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  A system shutdown is in progress.
//
#define ERROR_SHUTDOWN_IN_PROGRESS       1115L

//
// MessageId: ERROR_NO_SHUTDOWN_IN_PROGRESS
//
// MessageText:
//
//  Unable to abort the system shutdown because no shutdown was in progress.
//
#define ERROR_NO_SHUTDOWN_IN_PROGRESS    1116L

//
// MessageId: ERROR_IO_DEVICE
//
// MessageText:
//
//  The request could not be performed because of an I/O device error.
//
#define ERROR_IO_DEVICE                  1117L

//
// MessageId: ERROR_SERIAL_NO_DEVICE
//
// MessageText:
//
//  No serial device was successfully initialized.  The serial driver will unload.
//
#define ERROR_SERIAL_NO_DEVICE           1118L

//
// MessageId: ERROR_IRQ_BUSY
//
// MessageText:
//
//  Unable to open a device that was sharing an interrupt request (IRQ)
//  with other devices. At least one other device that uses that IRQ
//  was already opened.
//
#define ERROR_IRQ_BUSY                   1119L

//
// MessageId: ERROR_MORE_WRITES
//
// MessageText:
//
//  A serial I/O operation was completed by another write to the serial port.
//  (The IOCTL_SERIAL_XOFF_COUNTER reached zero.)
//
#define ERROR_MORE_WRITES                1120L

//
// MessageId: ERROR_COUNTER_TIMEOUT
//
// MessageText:
//
//  A serial I/O operation completed because the timeout period expired.
//  (The IOCTL_SERIAL_XOFF_COUNTER did not reach zero.)
//
#define ERROR_COUNTER_TIMEOUT            1121L

//
// MessageId: ERROR_FLOPPY_ID_MARK_NOT_FOUND
//
// MessageText:
//
//  No ID address mark was found on the floppy disk.
//
#define ERROR_FLOPPY_ID_MARK_NOT_FOUND   1122L

//
// MessageId: ERROR_FLOPPY_WRONG_CYLINDER
//
// MessageText:
//
//  Mismatch between the floppy disk sector ID field and the floppy disk
//  controller track address.
//
#define ERROR_FLOPPY_WRONG_CYLINDER      1123L

//
// MessageId: ERROR_FLOPPY_UNKNOWN_ERROR
//
// MessageText:
//
//  The floppy disk controller reported an error that is not recognized
//  by the floppy disk driver.
//
#define ERROR_FLOPPY_UNKNOWN_ERROR       1124L

//
// MessageId: ERROR_FLOPPY_BAD_REGISTERS
//
// MessageText:
//
//  The floppy disk controller returned inconsistent results in its registers.
//
#define ERROR_FLOPPY_BAD_REGISTERS       1125L

//
// MessageId: ERROR_DISK_RECALIBRATE_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a recalibrate operation failed, even after retries.
//
#define ERROR_DISK_RECALIBRATE_FAILED    1126L

//
// MessageId: ERROR_DISK_OPERATION_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk operation failed even after retries.
//
#define ERROR_DISK_OPERATION_FAILED      1127L

//
// MessageId: ERROR_DISK_RESET_FAILED
//
// MessageText:
//
//  While accessing the hard disk, a disk controller reset was needed, but
//  even that failed.
//
#define ERROR_DISK_RESET_FAILED          1128L

//
// MessageId: ERROR_EOM_OVERFLOW
//
// MessageText:
//
//  Physical end of tape encountered.
//
#define ERROR_EOM_OVERFLOW               1129L

//
// MessageId: ERROR_NOT_ENOUGH_SERVER_MEMORY
//
// MessageText:
//
//  Not enough server storage is available to process this command.
//
#define ERROR_NOT_ENOUGH_SERVER_MEMORY   1130L

//
// MessageId: ERROR_POSSIBLE_DEADLOCK
//
// MessageText:
//
//  A potential deadlock condition has been detected.
//
#define ERROR_POSSIBLE_DEADLOCK          1131L

//
// MessageId: ERROR_MAPPED_ALIGNMENT
//
// MessageText:
//
//  The base address or the file offset specified does not have the proper
//  alignment.
//
#define ERROR_MAPPED_ALIGNMENT           1132L

//
// MessageId: ERROR_SET_POWER_STATE_VETOED
//
// MessageText:
//
//  An attempt to change the system power state was vetoed by another
//  application or driver.
//
#define ERROR_SET_POWER_STATE_VETOED     1140L

//
// MessageId: ERROR_SET_POWER_STATE_FAILED
//
// MessageText:
//
//  The system BIOS failed an attempt to change the system power state.
//
#define ERROR_SET_POWER_STATE_FAILED     1141L

//
// MessageId: ERROR_TOO_MANY_LINKS
//
// MessageText:
//
//  An attempt was made to create more links on a file than
//  the file system supports.
//
#define ERROR_TOO_MANY_LINKS             1142L

//
// MessageId: ERROR_OLD_WIN_VERSION
//
// MessageText:
//
//  The specified program requires a newer version of Windows.
//
#define ERROR_OLD_WIN_VERSION            1150L

//
// MessageId: ERROR_APP_WRONG_OS
//
// MessageText:
//
//  The specified program is not a Windows or MS-DOS program.
//
#define ERROR_APP_WRONG_OS               1151L

//
// MessageId: ERROR_SINGLE_INSTANCE_APP
//
// MessageText:
//
//  Cannot start more than one instance of the specified program.
//
#define ERROR_SINGLE_INSTANCE_APP        1152L

//
// MessageId: ERROR_RMODE_APP
//
// MessageText:
//
//  The specified program was written for an earlier version of Windows.
//
#define ERROR_RMODE_APP                  1153L

//
// MessageId: ERROR_INVALID_DLL
//
// MessageText:
//
//  One of the library files needed to run this application is damaged.
//
#define ERROR_INVALID_DLL                1154L

//
// MessageId: ERROR_NO_ASSOCIATION
//
// MessageText:
//
//  No application is associated with the specified file for this operation.
//
#define ERROR_NO_ASSOCIATION             1155L

//
// MessageId: ERROR_DDE_FAIL
//
// MessageText:
//
//  An error occurred in sending the command to the application.
//
#define ERROR_DDE_FAIL                   1156L

//
// MessageId: ERROR_DLL_NOT_FOUND
//
// MessageText:
//
//  One of the library files needed to run this application cannot be found.
//
#define ERROR_DLL_NOT_FOUND              1157L

//
// MessageId: ERROR_NO_MORE_USER_HANDLES
//
// MessageText:
//
//  The current process has used all of its system allowance of handles for Window Manager objects.
//
#define ERROR_NO_MORE_USER_HANDLES       1158L

//
// MessageId: ERROR_MESSAGE_SYNC_ONLY
//
// MessageText:
//
//  The message can be used only with synchronous operations.
//
#define ERROR_MESSAGE_SYNC_ONLY          1159L

//
// MessageId: ERROR_SOURCE_ELEMENT_EMPTY
//
// MessageText:
//
//  The indicated source element has no media.
//
#define ERROR_SOURCE_ELEMENT_EMPTY       1160L

//
// MessageId: ERROR_DESTINATION_ELEMENT_FULL
//
// MessageText:
//
//  The indicated destination element already contains media.
//
#define ERROR_DESTINATION_ELEMENT_FULL   1161L

//
// MessageId: ERROR_ILLEGAL_ELEMENT_ADDRESS
//
// MessageText:
//
//  The indicated element does not exist.
//
#define ERROR_ILLEGAL_ELEMENT_ADDRESS    1162L

//
// MessageId: ERROR_MAGAZINE_NOT_PRESENT
//
// MessageText:
//
//  The indicated element is part of a magazine that is not present.
//
#define ERROR_MAGAZINE_NOT_PRESENT       1163L

//
// MessageId: ERROR_DEVICE_REINITIALIZATION_NEEDED
//
// MessageText:
//
//  The indicated device requires reinitialization due to hardware errors.
//
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    // dderror

//
// MessageId: ERROR_DEVICE_REQUIRES_CLEANING
//
// MessageText:
//
//  The device has indicated that cleaning is required before further operations are attempted.
//
#define ERROR_DEVICE_REQUIRES_CLEANING   1165L

//
// MessageId: ERROR_DEVICE_DOOR_OPEN
//
// MessageText:
//
//  The device has indicated that its door is open.
//
#define ERROR_DEVICE_DOOR_OPEN           1166L

//
// MessageId: ERROR_DEVICE_NOT_CONNECTED
//
// MessageText:
//
//  The device is not connected.
//
#define ERROR_DEVICE_NOT_CONNECTED       1167L

//
// MessageId: ERROR_NOT_FOUND
//
// MessageText:
//
//  Element not found.
//
#define ERROR_NOT_FOUND                  1168L

//
// MessageId: ERROR_NO_MATCH
//
// MessageText:
//
//  There was no match for the specified key in the index.
//
#define ERROR_NO_MATCH                   1169L

//
// MessageId: ERROR_SET_NOT_FOUND
//
// MessageText:
//
//  The property set specified does not exist on the object.
//
#define ERROR_SET_NOT_FOUND              1170L

//
// MessageId: ERROR_POINT_NOT_FOUND
//
// MessageText:
//
//  The point passed to GetMouseMovePoints is not in the buffer.
//
#define ERROR_POINT_NOT_FOUND            1171L

//
// MessageId: ERROR_NO_TRACKING_SERVICE
//
// MessageText:
//
//  The tracking (workstation) service is not running.
//
#define ERROR_NO_TRACKING_SERVICE        1172L

//
// MessageId: ERROR_NO_VOLUME_ID
//
// MessageText:
//
//  The Volume ID could not be found.
//
#define ERROR_NO_VOLUME_ID               1173L




///////////////////////////
//                       //
// Winnet32 Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_CONNECTED_OTHER_PASSWORD
//
// MessageText:
//
//  The network connection was made successfully, but the user had to be prompted
//  for a password other than the one originally specified.
//
#define ERROR_CONNECTED_OTHER_PASSWORD   2108L

//
// MessageId: ERROR_BAD_USERNAME
//
// MessageText:
//
//  The specified username is invalid.
//
#define ERROR_BAD_USERNAME               2202L

//
// MessageId: ERROR_NOT_CONNECTED
//
// MessageText:
//
//  This network connection does not exist.
//
#define ERROR_NOT_CONNECTED              2250L

//
// MessageId: ERROR_OPEN_FILES
//
// MessageText:
//
//  This network connection has files open or requests pending.
//
#define ERROR_OPEN_FILES                 2401L

//
// MessageId: ERROR_ACTIVE_CONNECTIONS
//
// MessageText:
//
//  Active connections still exist.
//
#define ERROR_ACTIVE_CONNECTIONS         2402L

//
// MessageId: ERROR_DEVICE_IN_USE
//
// MessageText:
//
//  The device is in use by an active process and cannot be disconnected.
//
#define ERROR_DEVICE_IN_USE              2404L

//
// MessageId: ERROR_BAD_DEVICE
//
// MessageText:
//
//  The specified device name is invalid.
//
#define ERROR_BAD_DEVICE                 1200L

//
// MessageId: ERROR_CONNECTION_UNAVAIL
//
// MessageText:
//
//  The device is not currently connected but it is a remembered connection.
//
#define ERROR_CONNECTION_UNAVAIL         1201L

//
// MessageId: ERROR_DEVICE_ALREADY_REMEMBERED
//
// MessageText:
//
//  An attempt was made to remember a device that had previously been remembered.
//
#define ERROR_DEVICE_ALREADY_REMEMBERED  1202L

//
// MessageId: ERROR_NO_NET_OR_BAD_PATH
//
// MessageText:
//
//  No network provider accepted the given network path.
//
#define ERROR_NO_NET_OR_BAD_PATH         1203L

//
// MessageId: ERROR_BAD_PROVIDER
//
// MessageText:
//
//  The specified network provider name is invalid.
//
#define ERROR_BAD_PROVIDER               1204L

//
// MessageId: ERROR_CANNOT_OPEN_PROFILE
//
// MessageText:
//
//  Unable to open the network connection profile.
//
#define ERROR_CANNOT_OPEN_PROFILE        1205L

//
// MessageId: ERROR_BAD_PROFILE
//
// MessageText:
//
//  The network connection profile is corrupted.
//
#define ERROR_BAD_PROFILE                1206L

//
// MessageId: ERROR_NOT_CONTAINER
//
// MessageText:
//
//  Cannot enumerate a noncontainer.
//
#define ERROR_NOT_CONTAINER              1207L

//
// MessageId: ERROR_EXTENDED_ERROR
//
// MessageText:
//
//  An extended error has occurred.
//
#define ERROR_EXTENDED_ERROR             1208L

//
// MessageId: ERROR_INVALID_GROUPNAME
//
// MessageText:
//
//  The format of the specified group name is invalid.
//
#define ERROR_INVALID_GROUPNAME          1209L

//
// MessageId: ERROR_INVALID_COMPUTERNAME
//
// MessageText:
//
//  The format of the specified computer name is invalid.
//
#define ERROR_INVALID_COMPUTERNAME       1210L

//
// MessageId: ERROR_INVALID_EVENTNAME
//
// MessageText:
//
//  The format of the specified event name is invalid.
//
#define ERROR_INVALID_EVENTNAME          1211L

//
// MessageId: ERROR_INVALID_DOMAINNAME
//
// MessageText:
//
//  The format of the specified domain name is invalid.
//
#define ERROR_INVALID_DOMAINNAME         1212L

//
// MessageId: ERROR_INVALID_SERVICENAME
//
// MessageText:
//
//  The format of the specified service name is invalid.
//
#define ERROR_INVALID_SERVICENAME        1213L

//
// MessageId: ERROR_INVALID_NETNAME
//
// MessageText:
//
//  The format of the specified network name is invalid.
//
#define ERROR_INVALID_NETNAME            1214L

//
// MessageId: ERROR_INVALID_SHARENAME
//
// MessageText:
//
//  The format of the specified share name is invalid.
//
#define ERROR_INVALID_SHARENAME          1215L

//
// MessageId: ERROR_INVALID_PASSWORDNAME
//
// MessageText:
//
//  The format of the specified password is invalid.
//
#define ERROR_INVALID_PASSWORDNAME       1216L

//
// MessageId: ERROR_INVALID_MESSAGENAME
//
// MessageText:
//
//  The format of the specified message name is invalid.
//
#define ERROR_INVALID_MESSAGENAME        1217L

//
// MessageId: ERROR_INVALID_MESSAGEDEST
//
// MessageText:
//
//  The format of the specified message destination is invalid.
//
#define ERROR_INVALID_MESSAGEDEST        1218L

//
// MessageId: ERROR_SESSION_CREDENTIAL_CONFLICT
//
// MessageText:
//
//  The credentials supplied conflict with an existing set of credentials.
//
#define ERROR_SESSION_CREDENTIAL_CONFLICT 1219L

//
// MessageId: ERROR_REMOTE_SESSION_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to establish a session to a network server, but there
//  are already too many sessions established to that server.
//
#define ERROR_REMOTE_SESSION_LIMIT_EXCEEDED 1220L

//
// MessageId: ERROR_DUP_DOMAINNAME
//
// MessageText:
//
//  The workgroup or domain name is already in use by another computer on the
//  network.
//
#define ERROR_DUP_DOMAINNAME             1221L

//
// MessageId: ERROR_NO_NETWORK
//
// MessageText:
//
//  The network is not present or not started.
//
#define ERROR_NO_NETWORK                 1222L

//
// MessageId: ERROR_CANCELLED
//
// MessageText:
//
//  The operation was canceled by the user.
//
#define ERROR_CANCELLED                  1223L

//
// MessageId: ERROR_USER_MAPPED_FILE
//
// MessageText:
//
//  The requested operation cannot be performed on a file with a user-mapped section open.
//
#define ERROR_USER_MAPPED_FILE           1224L

//
// MessageId: ERROR_CONNECTION_REFUSED
//
// MessageText:
//
//  The remote system refused the network connection.
//
#define ERROR_CONNECTION_REFUSED         1225L

//
// MessageId: ERROR_GRACEFUL_DISCONNECT
//
// MessageText:
//
//  The network connection was gracefully closed.
//
#define ERROR_GRACEFUL_DISCONNECT        1226L

//
// MessageId: ERROR_ADDRESS_ALREADY_ASSOCIATED
//
// MessageText:
//
//  The network transport endpoint already has an address associated with it.
//
#define ERROR_ADDRESS_ALREADY_ASSOCIATED 1227L

//
// MessageId: ERROR_ADDRESS_NOT_ASSOCIATED
//
// MessageText:
//
//  An address has not yet been associated with the network endpoint.
//
#define ERROR_ADDRESS_NOT_ASSOCIATED     1228L

//
// MessageId: ERROR_CONNECTION_INVALID
//
// MessageText:
//
//  An operation was attempted on a nonexistent network connection.
//
#define ERROR_CONNECTION_INVALID         1229L

//
// MessageId: ERROR_CONNECTION_ACTIVE
//
// MessageText:
//
//  An invalid operation was attempted on an active network connection.
//
#define ERROR_CONNECTION_ACTIVE          1230L

//
// MessageId: ERROR_NETWORK_UNREACHABLE
//
// MessageText:
//
//  The remote network is not reachable by the transport.
//
#define ERROR_NETWORK_UNREACHABLE        1231L

//
// MessageId: ERROR_HOST_UNREACHABLE
//
// MessageText:
//
//  The remote system is not reachable by the transport.
//
#define ERROR_HOST_UNREACHABLE           1232L

//
// MessageId: ERROR_PROTOCOL_UNREACHABLE
//
// MessageText:
//
//  The remote system does not support the transport protocol.
//
#define ERROR_PROTOCOL_UNREACHABLE       1233L

//
// MessageId: ERROR_PORT_UNREACHABLE
//
// MessageText:
//
//  No service is operating at the destination network endpoint
//  on the remote system.
//
#define ERROR_PORT_UNREACHABLE           1234L

//
// MessageId: ERROR_REQUEST_ABORTED
//
// MessageText:
//
//  The request was aborted.
//
#define ERROR_REQUEST_ABORTED            1235L

//
// MessageId: ERROR_CONNECTION_ABORTED
//
// MessageText:
//
//  The network connection was aborted by the local system.
//
#define ERROR_CONNECTION_ABORTED         1236L

//
// MessageId: ERROR_RETRY
//
// MessageText:
//
//  The operation could not be completed.  A retry should be performed.
//
#define ERROR_RETRY                      1237L

//
// MessageId: ERROR_CONNECTION_COUNT_LIMIT
//
// MessageText:
//
//  A connection to the server could not be made because the limit on the number of
//  concurrent connections for this account has been reached.
//
#define ERROR_CONNECTION_COUNT_LIMIT     1238L

//
// MessageId: ERROR_LOGIN_TIME_RESTRICTION
//
// MessageText:
//
//  Attempting to log in during an unauthorized time of day for this account.
//
#define ERROR_LOGIN_TIME_RESTRICTION     1239L

//
// MessageId: ERROR_LOGIN_WKSTA_RESTRICTION
//
// MessageText:
//
//  The account is not authorized to log in from this station.
//
#define ERROR_LOGIN_WKSTA_RESTRICTION    1240L

//
// MessageId: ERROR_INCORRECT_ADDRESS
//
// MessageText:
//
//  The network address could not be used for the operation requested.
//
#define ERROR_INCORRECT_ADDRESS          1241L

//
// MessageId: ERROR_ALREADY_REGISTERED
//
// MessageText:
//
//  The service is already registered.
//
#define ERROR_ALREADY_REGISTERED         1242L

//
// MessageId: ERROR_SERVICE_NOT_FOUND
//
// MessageText:
//
//  The specified service does not exist.
//
#define ERROR_SERVICE_NOT_FOUND          1243L

//
// MessageId: ERROR_NOT_AUTHENTICATED
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not been authenticated.
//
#define ERROR_NOT_AUTHENTICATED          1244L

//
// MessageId: ERROR_NOT_LOGGED_ON
//
// MessageText:
//
//  The operation being requested was not performed because the user
//  has not logged on to the network.
//  The specified service does not exist.
//
#define ERROR_NOT_LOGGED_ON              1245L

//
// MessageId: ERROR_CONTINUE
//
// MessageText:
//
//  Continue with work in progress.
//
#define ERROR_CONTINUE                   1246L

//
// MessageId: ERROR_ALREADY_INITIALIZED
//
// MessageText:
//
//  An attempt was made to perform an initialization operation when
//  initialization has already been completed.
//
#define ERROR_ALREADY_INITIALIZED        1247L

//
// MessageId: ERROR_NO_MORE_DEVICES
//
// MessageText:
//
//  No more local devices.
//
#define ERROR_NO_MORE_DEVICES            1248L

//
// MessageId: ERROR_NO_SUCH_SITE
//
// MessageText:
//
//  The specified site does not exist.
//
#define ERROR_NO_SUCH_SITE               1249L

//
// MessageId: ERROR_DOMAIN_CONTROLLER_EXISTS
//
// MessageText:
//
//  A domain controller with the specified name already exists.
//
#define ERROR_DOMAIN_CONTROLLER_EXISTS   1250L

//
// MessageId: ERROR_DS_NOT_INSTALLED
//
// MessageText:
//
//  An error occurred while installing the Windows NT directory service. Please view the event log for more information.
//
#define ERROR_DS_NOT_INSTALLED           1251L




///////////////////////////
//                       //
// Security Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_NOT_ALL_ASSIGNED
//
// MessageText:
//
//  Not all privileges referenced are assigned to the caller.
//
#define ERROR_NOT_ALL_ASSIGNED           1300L

//
// MessageId: ERROR_SOME_NOT_MAPPED
//
// MessageText:
//
//  Some mapping between account names and security IDs was not done.
//
#define ERROR_SOME_NOT_MAPPED            1301L

//
// MessageId: ERROR_NO_QUOTAS_FOR_ACCOUNT
//
// MessageText:
//
//  No system quota limits are specifically set for this account.
//
#define ERROR_NO_QUOTAS_FOR_ACCOUNT      1302L

//
// MessageId: ERROR_LOCAL_USER_SESSION_KEY
//
// MessageText:
//
//  No encryption key is available.  A well-known encryption key was returned.
//
#define ERROR_LOCAL_USER_SESSION_KEY     1303L

//
// MessageId: ERROR_NULL_LM_PASSWORD
//
// MessageText:
//
//  The Windows NT password is too complex to be converted to a LAN Manager
//  password.  The LAN Manager password returned is a NULL string.
//
#define ERROR_NULL_LM_PASSWORD           1304L

//
// MessageId: ERROR_UNKNOWN_REVISION
//
// MessageText:
//
//  The revision level is unknown.
//
#define ERROR_UNKNOWN_REVISION           1305L

//
// MessageId: ERROR_REVISION_MISMATCH
//
// MessageText:
//
//  Indicates two revision levels are incompatible.
//
#define ERROR_REVISION_MISMATCH          1306L

//
// MessageId: ERROR_INVALID_OWNER
//
// MessageText:
//
//  This security ID may not be assigned as the owner of this object.
//
#define ERROR_INVALID_OWNER              1307L

//
// MessageId: ERROR_INVALID_PRIMARY_GROUP
//
// MessageText:
//
//  This security ID may not be assigned as the primary group of an object.
//
#define ERROR_INVALID_PRIMARY_GROUP      1308L

//
// MessageId: ERROR_NO_IMPERSONATION_TOKEN
//
// MessageText:
//
//  An attempt has been made to operate on an impersonation token
//  by a thread that is not currently impersonating a client.
//
#define ERROR_NO_IMPERSONATION_TOKEN     1309L

//
// MessageId: ERROR_CANT_DISABLE_MANDATORY
//
// MessageText:
//
//  The group may not be disabled.
//
#define ERROR_CANT_DISABLE_MANDATORY     1310L

//
// MessageId: ERROR_NO_LOGON_SERVERS
//
// MessageText:
//
//  There are currently no logon servers available to service the logon
//  request.
//
#define ERROR_NO_LOGON_SERVERS           1311L

//
// MessageId: ERROR_NO_SUCH_LOGON_SESSION
//
// MessageText:
//
//   A specified logon session does not exist.  It may already have
//   been terminated.
//
#define ERROR_NO_SUCH_LOGON_SESSION      1312L

//
// MessageId: ERROR_NO_SUCH_PRIVILEGE
//
// MessageText:
//
//   A specified privilege does not exist.
//
#define ERROR_NO_SUCH_PRIVILEGE          1313L

//
// MessageId: ERROR_PRIVILEGE_NOT_HELD
//
// MessageText:
//
//   A required privilege is not held by the client.
//
#define ERROR_PRIVILEGE_NOT_HELD         1314L

//
// MessageId: ERROR_INVALID_ACCOUNT_NAME
//
// MessageText:
//
//  The name provided is not a properly formed account name.
//
#define ERROR_INVALID_ACCOUNT_NAME       1315L

//
// MessageId: ERROR_USER_EXISTS
//
// MessageText:
//
//  The specified user already exists.
//
#define ERROR_USER_EXISTS                1316L

//
// MessageId: ERROR_NO_SUCH_USER
//
// MessageText:
//
//  The specified user does not exist.
//
#define ERROR_NO_SUCH_USER               1317L

//
// MessageId: ERROR_GROUP_EXISTS
//
// MessageText:
//
//  The specified group already exists.
//
#define ERROR_GROUP_EXISTS               1318L

//
// MessageId: ERROR_NO_SUCH_GROUP
//
// MessageText:
//
//  The specified group does not exist.
//
#define ERROR_NO_SUCH_GROUP              1319L

//
// MessageId: ERROR_MEMBER_IN_GROUP
//
// MessageText:
//
//  Either the specified user account is already a member of the specified
//  group, or the specified group cannot be deleted because it contains
//  a member.
//
#define ERROR_MEMBER_IN_GROUP            1320L

//
// MessageId: ERROR_MEMBER_NOT_IN_GROUP
//
// MessageText:
//
//  The specified user account is not a member of the specified group account.
//
#define ERROR_MEMBER_NOT_IN_GROUP        1321L

//
// MessageId: ERROR_LAST_ADMIN
//
// MessageText:
//
//  The last remaining administration account cannot be disabled
//  or deleted.
//
#define ERROR_LAST_ADMIN                 1322L

//
// MessageId: ERROR_WRONG_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided as the current
//  password is incorrect.
//
#define ERROR_WRONG_PASSWORD             1323L

//
// MessageId: ERROR_ILL_FORMED_PASSWORD
//
// MessageText:
//
//  Unable to update the password.  The value provided for the new password
//  contains values that are not allowed in passwords.
//
#define ERROR_ILL_FORMED_PASSWORD        1324L

//
// MessageId: ERROR_PASSWORD_RESTRICTION
//
// MessageText:
//
//  Unable to update the password because a password update rule has been
//  violated.
//
#define ERROR_PASSWORD_RESTRICTION       1325L

//
// MessageId: ERROR_LOGON_FAILURE
//
// MessageText:
//
//  Logon failure: unknown user name or bad password.
//
#define ERROR_LOGON_FAILURE              1326L

//
// MessageId: ERROR_ACCOUNT_RESTRICTION
//
// MessageText:
//
//  Logon failure: user account restriction.
//
#define ERROR_ACCOUNT_RESTRICTION        1327L

//
// MessageId: ERROR_INVALID_LOGON_HOURS
//
// MessageText:
//
//  Logon failure: account logon time restriction violation.
//
#define ERROR_INVALID_LOGON_HOURS        1328L

//
// MessageId: ERROR_INVALID_WORKSTATION
//
// MessageText:
//
//  Logon failure: user not allowed to log on to this computer.
//
#define ERROR_INVALID_WORKSTATION        1329L

//
// MessageId: ERROR_PASSWORD_EXPIRED
//
// MessageText:
//
//  Logon failure: the specified account password has expired.
//
#define ERROR_PASSWORD_EXPIRED           1330L

//
// MessageId: ERROR_ACCOUNT_DISABLED
//
// MessageText:
//
//  Logon failure: account currently disabled.
//
#define ERROR_ACCOUNT_DISABLED           1331L

//
// MessageId: ERROR_NONE_MAPPED
//
// MessageText:
//
//  No mapping between account names and security IDs was done.
//
#define ERROR_NONE_MAPPED                1332L

//
// MessageId: ERROR_TOO_MANY_LUIDS_REQUESTED
//
// MessageText:
//
//  Too many local user identifiers (LUIDs) were requested at one time.
//
#define ERROR_TOO_MANY_LUIDS_REQUESTED   1333L

//
// MessageId: ERROR_LUIDS_EXHAUSTED
//
// MessageText:
//
//  No more local user identifiers (LUIDs) are available.
//
#define ERROR_LUIDS_EXHAUSTED            1334L

//
// MessageId: ERROR_INVALID_SUB_AUTHORITY
//
// MessageText:
//
//  The subauthority part of a security ID is invalid for this particular use.
//
#define ERROR_INVALID_SUB_AUTHORITY      1335L

//
// MessageId: ERROR_INVALID_ACL
//
// MessageText:
//
//  The access control list (ACL) structure is invalid.
//
#define ERROR_INVALID_ACL                1336L

//
// MessageId: ERROR_INVALID_SID
//
// MessageText:
//
//  The security ID structure is invalid.
//
#define ERROR_INVALID_SID                1337L

//
// MessageId: ERROR_INVALID_SECURITY_DESCR
//
// MessageText:
//
//  The security descriptor structure is invalid.
//
#define ERROR_INVALID_SECURITY_DESCR     1338L

//
// MessageId: ERROR_BAD_INHERITANCE_ACL
//
// MessageText:
//
//  The inherited access control list (ACL) or access control entry (ACE)
//  could not be built.
//
#define ERROR_BAD_INHERITANCE_ACL        1340L

//
// MessageId: ERROR_SERVER_DISABLED
//
// MessageText:
//
//  The server is currently disabled.
//
#define ERROR_SERVER_DISABLED            1341L

//
// MessageId: ERROR_SERVER_NOT_DISABLED
//
// MessageText:
//
//  The server is currently enabled.
//
#define ERROR_SERVER_NOT_DISABLED        1342L

//
// MessageId: ERROR_INVALID_ID_AUTHORITY
//
// MessageText:
//
//  The value provided was an invalid value for an identifier authority.
//
#define ERROR_INVALID_ID_AUTHORITY       1343L

//
// MessageId: ERROR_ALLOTTED_SPACE_EXCEEDED
//
// MessageText:
//
//  No more memory is available for security information updates.
//
#define ERROR_ALLOTTED_SPACE_EXCEEDED    1344L

//
// MessageId: ERROR_INVALID_GROUP_ATTRIBUTES
//
// MessageText:
//
//  The specified attributes are invalid, or incompatible with the
//  attributes for the group as a whole.
//
#define ERROR_INVALID_GROUP_ATTRIBUTES   1345L

//
// MessageId: ERROR_BAD_IMPERSONATION_LEVEL
//
// MessageText:
//
//  Either a required impersonation level was not provided, or the
//  provided impersonation level is invalid.
//
#define ERROR_BAD_IMPERSONATION_LEVEL    1346L

//
// MessageId: ERROR_CANT_OPEN_ANONYMOUS
//
// MessageText:
//
//  Cannot open an anonymous level security token.
//
#define ERROR_CANT_OPEN_ANONYMOUS        1347L

//
// MessageId: ERROR_BAD_VALIDATION_CLASS
//
// MessageText:
//
//  The validation information class requested was invalid.
//
#define ERROR_BAD_VALIDATION_CLASS       1348L

//
// MessageId: ERROR_BAD_TOKEN_TYPE
//
// MessageText:
//
//  The type of the token is inappropriate for its attempted use.
//
#define ERROR_BAD_TOKEN_TYPE             1349L

//
// MessageId: ERROR_NO_SECURITY_ON_OBJECT
//
// MessageText:
//
//  Unable to perform a security operation on an object
//  that has no associated security.
//
#define ERROR_NO_SECURITY_ON_OBJECT      1350L

//
// MessageId: ERROR_CANT_ACCESS_DOMAIN_INFO
//
// MessageText:
//
//  Indicates a Windows NT Server could not be contacted or that
//  objects within the domain are protected such that necessary
//  information could not be retrieved.
//
#define ERROR_CANT_ACCESS_DOMAIN_INFO    1351L

//
// MessageId: ERROR_INVALID_SERVER_STATE
//
// MessageText:
//
//  The security account manager (SAM) or local security
//  authority (LSA) server was in the wrong state to perform
//  the security operation.
//
#define ERROR_INVALID_SERVER_STATE       1352L

//
// MessageId: ERROR_INVALID_DOMAIN_STATE
//
// MessageText:
//
//  The domain was in the wrong state to perform the security operation.
//
#define ERROR_INVALID_DOMAIN_STATE       1353L

//
// MessageId: ERROR_INVALID_DOMAIN_ROLE
//
// MessageText:
//
//  This operation is only allowed for the Primary Domain Controller of the domain.
//
#define ERROR_INVALID_DOMAIN_ROLE        1354L

//
// MessageId: ERROR_NO_SUCH_DOMAIN
//
// MessageText:
//
//  The specified domain did not exist.
//
#define ERROR_NO_SUCH_DOMAIN             1355L

//
// MessageId: ERROR_DOMAIN_EXISTS
//
// MessageText:
//
//  The specified domain already exists.
//
#define ERROR_DOMAIN_EXISTS              1356L

//
// MessageId: ERROR_DOMAIN_LIMIT_EXCEEDED
//
// MessageText:
//
//  An attempt was made to exceed the limit on the number of domains per server.
//
#define ERROR_DOMAIN_LIMIT_EXCEEDED      1357L

//
// MessageId: ERROR_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  Unable to complete the requested operation because of either a
//  catastrophic media failure or a data structure corruption on the disk.
//
#define ERROR_INTERNAL_DB_CORRUPTION     1358L

//
// MessageId: ERROR_INTERNAL_ERROR
//
// MessageText:
//
//  The security account database contains an internal inconsistency.
//
#define ERROR_INTERNAL_ERROR             1359L

//
// MessageId: ERROR_GENERIC_NOT_MAPPED
//
// MessageText:
//
//  Generic access types were contained in an access mask which should
//  already be mapped to nongeneric types.
//
#define ERROR_GENERIC_NOT_MAPPED         1360L

//
// MessageId: ERROR_BAD_DESCRIPTOR_FORMAT
//
// MessageText:
//
//  A security descriptor is not in the right format (absolute or self-relative).
//
#define ERROR_BAD_DESCRIPTOR_FORMAT      1361L

//
// MessageId: ERROR_NOT_LOGON_PROCESS
//
// MessageText:
//
//  The requested action is restricted for use by logon processes
//  only.  The calling process has not registered as a logon process.
//
#define ERROR_NOT_LOGON_PROCESS          1362L

//
// MessageId: ERROR_LOGON_SESSION_EXISTS
//
// MessageText:
//
//  Cannot start a new logon session with an ID that is already in use.
//
#define ERROR_LOGON_SESSION_EXISTS       1363L

//
// MessageId: ERROR_NO_SUCH_PACKAGE
//
// MessageText:
//
//  A specified authentication package is unknown.
//
#define ERROR_NO_SUCH_PACKAGE            1364L

//
// MessageId: ERROR_BAD_LOGON_SESSION_STATE
//
// MessageText:
//
//  The logon session is not in a state that is consistent with the
//  requested operation.
//
#define ERROR_BAD_LOGON_SESSION_STATE    1365L

//
// MessageId: ERROR_LOGON_SESSION_COLLISION
//
// MessageText:
//
//  The logon session ID is already in use.
//
#define ERROR_LOGON_SESSION_COLLISION    1366L

//
// MessageId: ERROR_INVALID_LOGON_TYPE
//
// MessageText:
//
//  A logon request contained an invalid logon type value.
//
#define ERROR_INVALID_LOGON_TYPE         1367L

//
// MessageId: ERROR_CANNOT_IMPERSONATE
//
// MessageText:
//
//  Unable to impersonate using a named pipe until data has been read
//  from that pipe.
//
#define ERROR_CANNOT_IMPERSONATE         1368L

//
// MessageId: ERROR_RXACT_INVALID_STATE
//
// MessageText:
//
//  The transaction state of a registry subtree is incompatible with the
//  requested operation.
//
#define ERROR_RXACT_INVALID_STATE        1369L

//
// MessageId: ERROR_RXACT_COMMIT_FAILURE
//
// MessageText:
//
//  An internal security database corruption has been encountered.
//
#define ERROR_RXACT_COMMIT_FAILURE       1370L

//
// MessageId: ERROR_SPECIAL_ACCOUNT
//
// MessageText:
//
//  Cannot perform this operation on built-in accounts.
//
#define ERROR_SPECIAL_ACCOUNT            1371L

//
// MessageId: ERROR_SPECIAL_GROUP
//
// MessageText:
//
//  Cannot perform this operation on this built-in special group.
//
#define ERROR_SPECIAL_GROUP              1372L

//
// MessageId: ERROR_SPECIAL_USER
//
// MessageText:
//
//  Cannot perform this operation on this built-in special user.
//
#define ERROR_SPECIAL_USER               1373L

//
// MessageId: ERROR_MEMBERS_PRIMARY_GROUP
//
// MessageText:
//
//  The user cannot be removed from a group because the group
//  is currently the user's primary group.
//
#define ERROR_MEMBERS_PRIMARY_GROUP      1374L

//
// MessageId: ERROR_TOKEN_ALREADY_IN_USE
//
// MessageText:
//
//  The token is already in use as a primary token.
//
#define ERROR_TOKEN_ALREADY_IN_USE       1375L

//
// MessageId: ERROR_NO_SUCH_ALIAS
//
// MessageText:
//
//  The specified local group does not exist.
//
#define ERROR_NO_SUCH_ALIAS              1376L

//
// MessageId: ERROR_MEMBER_NOT_IN_ALIAS
//
// MessageText:
//
//  The specified account name is not a member of the local group.
//
#define ERROR_MEMBER_NOT_IN_ALIAS        1377L

//
// MessageId: ERROR_MEMBER_IN_ALIAS
//
// MessageText:
//
//  The specified account name is already a member of the local group.
//
#define ERROR_MEMBER_IN_ALIAS            1378L

//
// MessageId: ERROR_ALIAS_EXISTS
//
// MessageText:
//
//  The specified local group already exists.
//
#define ERROR_ALIAS_EXISTS               1379L

//
// MessageId: ERROR_LOGON_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested
//  logon type at this computer.
//
#define ERROR_LOGON_NOT_GRANTED          1380L

//
// MessageId: ERROR_TOO_MANY_SECRETS
//
// MessageText:
//
//  The maximum number of secrets that may be stored in a single system has been
//  exceeded.
//
#define ERROR_TOO_MANY_SECRETS           1381L

//
// MessageId: ERROR_SECRET_TOO_LONG
//
// MessageText:
//
//  The length of a secret exceeds the maximum length allowed.
//
#define ERROR_SECRET_TOO_LONG            1382L

//
// MessageId: ERROR_INTERNAL_DB_ERROR
//
// MessageText:
//
//  The local security authority database contains an internal inconsistency.
//
#define ERROR_INTERNAL_DB_ERROR          1383L

//
// MessageId: ERROR_TOO_MANY_CONTEXT_IDS
//
// MessageText:
//
//  During a logon attempt, the user's security context accumulated too many
//  security IDs.
//
#define ERROR_TOO_MANY_CONTEXT_IDS       1384L

//
// MessageId: ERROR_LOGON_TYPE_NOT_GRANTED
//
// MessageText:
//
//  Logon failure: the user has not been granted the requested logon type
//  at this computer.
//
#define ERROR_LOGON_TYPE_NOT_GRANTED     1385L

//
// MessageId: ERROR_NT_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change a user password.
//
#define ERROR_NT_CROSS_ENCRYPTION_REQUIRED 1386L

//
// MessageId: ERROR_NO_SUCH_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member does
//  not exist.
//
#define ERROR_NO_SUCH_MEMBER             1387L

//
// MessageId: ERROR_INVALID_MEMBER
//
// MessageText:
//
//  A new member could not be added to a local group because the member has the
//  wrong account type.
//
#define ERROR_INVALID_MEMBER             1388L

//
// MessageId: ERROR_TOO_MANY_SIDS
//
// MessageText:
//
//  Too many security IDs have been specified.
//
#define ERROR_TOO_MANY_SIDS              1389L

//
// MessageId: ERROR_LM_CROSS_ENCRYPTION_REQUIRED
//
// MessageText:
//
//  A cross-encrypted password is necessary to change this user password.
//
#define ERROR_LM_CROSS_ENCRYPTION_REQUIRED 1390L

//
// MessageId: ERROR_NO_INHERITANCE
//
// MessageText:
//
//  Indicates an ACL contains no inheritable components.
//
#define ERROR_NO_INHERITANCE             1391L

//
// MessageId: ERROR_FILE_CORRUPT
//
// MessageText:
//
//  The file or directory is corrupted and unreadable.
//
#define ERROR_FILE_CORRUPT               1392L

//
// MessageId: ERROR_DISK_CORRUPT
//
// MessageText:
//
//  The disk structure is corrupted and unreadable.
//
#define ERROR_DISK_CORRUPT               1393L

//
// MessageId: ERROR_NO_USER_SESSION_KEY
//
// MessageText:
//
//  There is no user session key for the specified logon session.
//
#define ERROR_NO_USER_SESSION_KEY        1394L

//
// MessageId: ERROR_LICENSE_QUOTA_EXCEEDED
//
// MessageText:
//
//  The service being accessed is licensed for a particular number of connections.
//  No more connections can be made to the service at this time
//  because there are already as many connections as the service can accept.
//
#define ERROR_LICENSE_QUOTA_EXCEEDED     1395L

// End of security error codes



///////////////////////////
//                       //
// WinUser Error Codes   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_WINDOW_HANDLE
//
// MessageText:
//
//  Invalid window handle.
//
#define ERROR_INVALID_WINDOW_HANDLE      1400L

//
// MessageId: ERROR_INVALID_MENU_HANDLE
//
// MessageText:
//
//  Invalid menu handle.
//
#define ERROR_INVALID_MENU_HANDLE        1401L

//
// MessageId: ERROR_INVALID_CURSOR_HANDLE
//
// MessageText:
//
//  Invalid cursor handle.
//
#define ERROR_INVALID_CURSOR_HANDLE      1402L

//
// MessageId: ERROR_INVALID_ACCEL_HANDLE
//
// MessageText:
//
//  Invalid accelerator table handle.
//
#define ERROR_INVALID_ACCEL_HANDLE       1403L

//
// MessageId: ERROR_INVALID_HOOK_HANDLE
//
// MessageText:
//
//  Invalid hook handle.
//
#define ERROR_INVALID_HOOK_HANDLE        1404L

//
// MessageId: ERROR_INVALID_DWP_HANDLE
//
// MessageText:
//
//  Invalid handle to a multiple-window position structure.
//
#define ERROR_INVALID_DWP_HANDLE         1405L

//
// MessageId: ERROR_TLW_WITH_WSCHILD
//
// MessageText:
//
//  Cannot create a top-level child window.
//
#define ERROR_TLW_WITH_WSCHILD           1406L

//
// MessageId: ERROR_CANNOT_FIND_WND_CLASS
//
// MessageText:
//
//  Cannot find window class.
//
#define ERROR_CANNOT_FIND_WND_CLASS      1407L

//
// MessageId: ERROR_WINDOW_OF_OTHER_THREAD
//
// MessageText:
//
//  Invalid window; it belongs to other thread.
//
#define ERROR_WINDOW_OF_OTHER_THREAD     1408L

//
// MessageId: ERROR_HOTKEY_ALREADY_REGISTERED
//
// MessageText:
//
//  Hot key is already registered.
//
#define ERROR_HOTKEY_ALREADY_REGISTERED  1409L

//
// MessageId: ERROR_CLASS_ALREADY_EXISTS
//
// MessageText:
//
//  Class already exists.
//
#define ERROR_CLASS_ALREADY_EXISTS       1410L

//
// MessageId: ERROR_CLASS_DOES_NOT_EXIST
//
// MessageText:
//
//  Class does not exist.
//
#define ERROR_CLASS_DOES_NOT_EXIST       1411L

//
// MessageId: ERROR_CLASS_HAS_WINDOWS
//
// MessageText:
//
//  Class still has open windows.
//
#define ERROR_CLASS_HAS_WINDOWS          1412L

//
// MessageId: ERROR_INVALID_INDEX
//
// MessageText:
//
//  Invalid index.
//
#define ERROR_INVALID_INDEX              1413L

//
// MessageId: ERROR_INVALID_ICON_HANDLE
//
// MessageText:
//
//  Invalid icon handle.
//
#define ERROR_INVALID_ICON_HANDLE        1414L

//
// MessageId: ERROR_PRIVATE_DIALOG_INDEX
//
// MessageText:
//
//  Using private DIALOG window words.
//
#define ERROR_PRIVATE_DIALOG_INDEX       1415L

//
// MessageId: ERROR_LISTBOX_ID_NOT_FOUND
//
// MessageText:
//
//  The list box identifier was not found.
//
#define ERROR_LISTBOX_ID_NOT_FOUND       1416L

//
// MessageId: ERROR_NO_WILDCARD_CHARACTERS
//
// MessageText:
//
//  No wildcards were found.
//
#define ERROR_NO_WILDCARD_CHARACTERS     1417L

//
// MessageId: ERROR_CLIPBOARD_NOT_OPEN
//
// MessageText:
//
//  Thread does not have a clipboard open.
//
#define ERROR_CLIPBOARD_NOT_OPEN         1418L

//
// MessageId: ERROR_HOTKEY_NOT_REGISTERED
//
// MessageText:
//
//  Hot key is not registered.
//
#define ERROR_HOTKEY_NOT_REGISTERED      1419L

//
// MessageId: ERROR_WINDOW_NOT_DIALOG
//
// MessageText:
//
//  The window is not a valid dialog window.
//
#define ERROR_WINDOW_NOT_DIALOG          1420L

//
// MessageId: ERROR_CONTROL_ID_NOT_FOUND
//
// MessageText:
//
//  Control ID not found.
//
#define ERROR_CONTROL_ID_NOT_FOUND       1421L

//
// MessageId: ERROR_INVALID_COMBOBOX_MESSAGE
//
// MessageText:
//
//  Invalid message for a combo box because it does not have an edit control.
//
#define ERROR_INVALID_COMBOBOX_MESSAGE   1422L

//
// MessageId: ERROR_WINDOW_NOT_COMBOBOX
//
// MessageText:
//
//  The window is not a combo box.
//
#define ERROR_WINDOW_NOT_COMBOBOX        1423L

//
// MessageId: ERROR_INVALID_EDIT_HEIGHT
//
// MessageText:
//
//  Height must be less than 256.
//
#define ERROR_INVALID_EDIT_HEIGHT        1424L

//
// MessageId: ERROR_DC_NOT_FOUND
//
// MessageText:
//
//  Invalid device context (DC) handle.
//
#define ERROR_DC_NOT_FOUND               1425L

//
// MessageId: ERROR_INVALID_HOOK_FILTER
//
// MessageText:
//
//  Invalid hook procedure type.
//
#define ERROR_INVALID_HOOK_FILTER        1426L

//
// MessageId: ERROR_INVALID_FILTER_PROC
//
// MessageText:
//
//  Invalid hook procedure.
//
#define ERROR_INVALID_FILTER_PROC        1427L

//
// MessageId: ERROR_HOOK_NEEDS_HMOD
//
// MessageText:
//
//  Cannot set nonlocal hook without a module handle.
//
#define ERROR_HOOK_NEEDS_HMOD            1428L

//
// MessageId: ERROR_GLOBAL_ONLY_HOOK
//
// MessageText:
//
//  This hook procedure can only be set globally.
//
#define ERROR_GLOBAL_ONLY_HOOK           1429L

//
// MessageId: ERROR_JOURNAL_HOOK_SET
//
// MessageText:
//
//  The journal hook procedure is already installed.
//
#define ERROR_JOURNAL_HOOK_SET           1430L

//
// MessageId: ERROR_HOOK_NOT_INSTALLED
//
// MessageText:
//
//  The hook procedure is not installed.
//
#define ERROR_HOOK_NOT_INSTALLED         1431L

//
// MessageId: ERROR_INVALID_LB_MESSAGE
//
// MessageText:
//
//  Invalid message for single-selection list box.
//
#define ERROR_INVALID_LB_MESSAGE         1432L

//
// MessageId: ERROR_SETCOUNT_ON_BAD_LB
//
// MessageText:
//
//  LB_SETCOUNT sent to non-lazy list box.
//
#define ERROR_SETCOUNT_ON_BAD_LB         1433L

//
// MessageId: ERROR_LB_WITHOUT_TABSTOPS
//
// MessageText:
//
//  This list box does not support tab stops.
//
#define ERROR_LB_WITHOUT_TABSTOPS        1434L

//
// MessageId: ERROR_DESTROY_OBJECT_OF_OTHER_THREAD
//
// MessageText:
//
//  Cannot destroy object created by another thread.
//
#define ERROR_DESTROY_OBJECT_OF_OTHER_THREAD 1435L

//
// MessageId: ERROR_CHILD_WINDOW_MENU
//
// MessageText:
//
//  Child windows cannot have menus.
//
#define ERROR_CHILD_WINDOW_MENU          1436L

//
// MessageId: ERROR_NO_SYSTEM_MENU
//
// MessageText:
//
//  The window does not have a system menu.
//
#define ERROR_NO_SYSTEM_MENU             1437L

//
// MessageId: ERROR_INVALID_MSGBOX_STYLE
//
// MessageText:
//
//  Invalid message box style.
//
#define ERROR_INVALID_MSGBOX_STYLE       1438L

//
// MessageId: ERROR_INVALID_SPI_VALUE
//
// MessageText:
//
//  Invalid system-wide (SPI_*) parameter.
//
#define ERROR_INVALID_SPI_VALUE          1439L

//
// MessageId: ERROR_SCREEN_ALREADY_LOCKED
//
// MessageText:
//
//  Screen already locked.
//
#define ERROR_SCREEN_ALREADY_LOCKED      1440L

//
// MessageId: ERROR_HWNDS_HAVE_DIFF_PARENT
//
// MessageText:
//
//  All handles to windows in a multiple-window position structure must
//  have the same parent.
//
#define ERROR_HWNDS_HAVE_DIFF_PARENT     1441L

//
// MessageId: ERROR_NOT_CHILD_WINDOW
//
// MessageText:
//
//  The window is not a child window.
//
#define ERROR_NOT_CHILD_WINDOW           1442L

//
// MessageId: ERROR_INVALID_GW_COMMAND
//
// MessageText:
//
//  Invalid GW_* command.
//
#define ERROR_INVALID_GW_COMMAND         1443L

//
// MessageId: ERROR_INVALID_THREAD_ID
//
// MessageText:
//
//  Invalid thread identifier.
//
#define ERROR_INVALID_THREAD_ID          1444L

//
// MessageId: ERROR_NON_MDICHILD_WINDOW
//
// MessageText:
//
//  Cannot process a message from a window that is not a multiple document
//  interface (MDI) window.
//
#define ERROR_NON_MDICHILD_WINDOW        1445L

//
// MessageId: ERROR_POPUP_ALREADY_ACTIVE
//
// MessageText:
//
//  Popup menu already active.
//
#define ERROR_POPUP_ALREADY_ACTIVE       1446L

//
// MessageId: ERROR_NO_SCROLLBARS
//
// MessageText:
//
//  The window does not have scroll bars.
//
#define ERROR_NO_SCROLLBARS              1447L

//
// MessageId: ERROR_INVALID_SCROLLBAR_RANGE
//
// MessageText:
//
//  Scroll bar range cannot be greater than 0x7FFF.
//
#define ERROR_INVALID_SCROLLBAR_RANGE    1448L

//
// MessageId: ERROR_INVALID_SHOWWIN_COMMAND
//
// MessageText:
//
//  Cannot show or remove the window in the way specified.
//
#define ERROR_INVALID_SHOWWIN_COMMAND    1449L

//
// MessageId: ERROR_NO_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_NO_SYSTEM_RESOURCES        1450L

//
// MessageId: ERROR_NONPAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_NONPAGED_SYSTEM_RESOURCES  1451L

//
// MessageId: ERROR_PAGED_SYSTEM_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the requested service.
//
#define ERROR_PAGED_SYSTEM_RESOURCES     1452L

//
// MessageId: ERROR_WORKING_SET_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//
#define ERROR_WORKING_SET_QUOTA          1453L

//
// MessageId: ERROR_PAGEFILE_QUOTA
//
// MessageText:
//
//  Insufficient quota to complete the requested service.
//
#define ERROR_PAGEFILE_QUOTA             1454L

//
// MessageId: ERROR_COMMITMENT_LIMIT
//
// MessageText:
//
//  The paging file is too small for this operation to complete.
//
#define ERROR_COMMITMENT_LIMIT           1455L

//
// MessageId: ERROR_MENU_ITEM_NOT_FOUND
//
// MessageText:
//
//  A menu item was not found.
//
#define ERROR_MENU_ITEM_NOT_FOUND        1456L

//
// MessageId: ERROR_INVALID_KEYBOARD_HANDLE
//
// MessageText:
//
//  Invalid keyboard layout handle.
//
#define ERROR_INVALID_KEYBOARD_HANDLE    1457L

//
// MessageId: ERROR_HOOK_TYPE_NOT_ALLOWED
//
// MessageText:
//
//  Hook type not allowed.
//
#define ERROR_HOOK_TYPE_NOT_ALLOWED      1458L

//
// MessageId: ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION
//
// MessageText:
//
//  This operation requires an interactive window station.
//
#define ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION 1459L

//
// MessageId: ERROR_TIMEOUT
//
// MessageText:
//
//  This operation returned because the timeout period expired.
//
#define ERROR_TIMEOUT                    1460L

//
// MessageId: ERROR_INVALID_MONITOR_HANDLE
//
// MessageText:
//
//  Invalid monitor handle.
//
#define ERROR_INVALID_MONITOR_HANDLE     1461L

// End of WinUser error codes



///////////////////////////
//                       //
// Eventlog Status Codes //
//                       //
///////////////////////////


//
// MessageId: ERROR_EVENTLOG_FILE_CORRUPT
//
// MessageText:
//
//  The event log file is corrupted.
//
#define ERROR_EVENTLOG_FILE_CORRUPT      1500L

//
// MessageId: ERROR_EVENTLOG_CANT_START
//
// MessageText:
//
//  No event log file could be opened, so the event logging service did not start.
//
#define ERROR_EVENTLOG_CANT_START        1501L

//
// MessageId: ERROR_LOG_FILE_FULL
//
// MessageText:
//
//  The event log file is full.
//
#define ERROR_LOG_FILE_FULL              1502L

//
// MessageId: ERROR_EVENTLOG_FILE_CHANGED
//
// MessageText:
//
//  The event log file has changed between read operations.
//
#define ERROR_EVENTLOG_FILE_CHANGED      1503L

// End of eventlog error codes



///////////////////////////
//                       //
// MSI Error Codes       //
//                       //
///////////////////////////


//
// MessageId: ERROR_INSTALL_SERVICE
//
// MessageText:
//
//  Failure accessing install service.
//
#define ERROR_INSTALL_SERVICE            1601L

//
// MessageId: ERROR_INSTALL_USEREXIT
//
// MessageText:
//
//  The user canceled the installation.
//
#define ERROR_INSTALL_USEREXIT           1602L

//
// MessageId: ERROR_INSTALL_FAILURE
//
// MessageText:
//
//  Fatal error during installation.
//
#define ERROR_INSTALL_FAILURE            1603L

//
// MessageId: ERROR_INSTALL_SUSPEND
//
// MessageText:
//
//  Installation suspended, incomplete.
//
#define ERROR_INSTALL_SUSPEND            1604L

//
// MessageId: ERROR_UNKNOWN_PRODUCT
//
// MessageText:
//
//  Product code not registered.
//
#define ERROR_UNKNOWN_PRODUCT            1605L

//
// MessageId: ERROR_UNKNOWN_FEATURE
//
// MessageText:
//
//  Feature ID not registered.
//
#define ERROR_UNKNOWN_FEATURE            1606L

//
// MessageId: ERROR_UNKNOWN_COMPONENT
//
// MessageText:
//
//  Component ID not registered.
//
#define ERROR_UNKNOWN_COMPONENT          1607L

//
// MessageId: ERROR_UNKNOWN_PROPERTY
//
// MessageText:
//
//  Unknown property.
//
#define ERROR_UNKNOWN_PROPERTY           1608L

//
// MessageId: ERROR_INVALID_HANDLE_STATE
//
// MessageText:
//
//  Handle is in an invalid state.
//
#define ERROR_INVALID_HANDLE_STATE       1609L

//
// MessageId: ERROR_BAD_CONFIGURATION
//
// MessageText:
//
//  Configuration data corrupt.
//
#define ERROR_BAD_CONFIGURATION          1610L

//
// MessageId: ERROR_INDEX_ABSENT
//
// MessageText:
//
//  Language not available.
//
#define ERROR_INDEX_ABSENT               1611L

//
// MessageId: ERROR_INSTALL_SOURCE_ABSENT
//
// MessageText:
//
//  Install source unavailable.
//
#define ERROR_INSTALL_SOURCE_ABSENT      1612L

//
// MessageId: ERROR_BAD_DATABASE_VERSION
//
// MessageText:
//
//  Database version unsupported.
//
#define ERROR_BAD_DATABASE_VERSION       1613L

//
// MessageId: ERROR_PRODUCT_UNINSTALLED
//
// MessageText:
//
//  Product is uninstalled.
//
#define ERROR_PRODUCT_UNINSTALLED        1614L

//
// MessageId: ERROR_BAD_QUERY_SYNTAX
//
// MessageText:
//
//  SQL query syntax invalid or unsupported.
//
#define ERROR_BAD_QUERY_SYNTAX           1615L

//
// MessageId: ERROR_INVALID_FIELD
//
// MessageText:
//
//  Record field does not exist.
//
#define ERROR_INVALID_FIELD              1616L

// End of MSI error codes



///////////////////////////
//                       //
//   RPC Status Codes    //
//                       //
///////////////////////////


//
// MessageId: RPC_S_INVALID_STRING_BINDING
//
// MessageText:
//
//  The string binding is invalid.
//
#define RPC_S_INVALID_STRING_BINDING     1700L

//
// MessageId: RPC_S_WRONG_KIND_OF_BINDING
//
// MessageText:
//
//  The binding handle is not the correct type.
//
#define RPC_S_WRONG_KIND_OF_BINDING      1701L

//
// MessageId: RPC_S_INVALID_BINDING
//
// MessageText:
//
//  The binding handle is invalid.
//
#define RPC_S_INVALID_BINDING            1702L

//
// MessageId: RPC_S_PROTSEQ_NOT_SUPPORTED
//
// MessageText:
//
//  The RPC protocol sequence is not supported.
//
#define RPC_S_PROTSEQ_NOT_SUPPORTED      1703L

//
// MessageId: RPC_S_INVALID_RPC_PROTSEQ
//
// MessageText:
//
//  The RPC protocol sequence is invalid.
//
#define RPC_S_INVALID_RPC_PROTSEQ        1704L

//
// MessageId: RPC_S_INVALID_STRING_UUID
//
// MessageText:
//
//  The string universal unique identifier (UUID) is invalid.
//
#define RPC_S_INVALID_STRING_UUID        1705L

//
// MessageId: RPC_S_INVALID_ENDPOINT_FORMAT
//
// MessageText:
//
//  The endpoint format is invalid.
//
#define RPC_S_INVALID_ENDPOINT_FORMAT    1706L

//
// MessageId: RPC_S_INVALID_NET_ADDR
//
// MessageText:
//
//  The network address is invalid.
//
#define RPC_S_INVALID_NET_ADDR           1707L

//
// MessageId: RPC_S_NO_ENDPOINT_FOUND
//
// MessageText:
//
//  No endpoint was found.
//
#define RPC_S_NO_ENDPOINT_FOUND          1708L

//
// MessageId: RPC_S_INVALID_TIMEOUT
//
// MessageText:
//
//  The timeout value is invalid.
//
#define RPC_S_INVALID_TIMEOUT            1709L

//
// MessageId: RPC_S_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object universal unique identifier (UUID) was not found.
//
#define RPC_S_OBJECT_NOT_FOUND           1710L

//
// MessageId: RPC_S_ALREADY_REGISTERED
//
// MessageText:
//
//  The object universal unique identifier (UUID) has already been registered.
//
#define RPC_S_ALREADY_REGISTERED         1711L

//
// MessageId: RPC_S_TYPE_ALREADY_REGISTERED
//
// MessageText:
//
//  The type universal unique identifier (UUID) has already been registered.
//
#define RPC_S_TYPE_ALREADY_REGISTERED    1712L

//
// MessageId: RPC_S_ALREADY_LISTENING
//
// MessageText:
//
//  The RPC server is already listening.
//
#define RPC_S_ALREADY_LISTENING          1713L

//
// MessageId: RPC_S_NO_PROTSEQS_REGISTERED
//
// MessageText:
//
//  No protocol sequences have been registered.
//
#define RPC_S_NO_PROTSEQS_REGISTERED     1714L

//
// MessageId: RPC_S_NOT_LISTENING
//
// MessageText:
//
//  The RPC server is not listening.
//
#define RPC_S_NOT_LISTENING              1715L

//
// MessageId: RPC_S_UNKNOWN_MGR_TYPE
//
// MessageText:
//
//  The manager type is unknown.
//
#define RPC_S_UNKNOWN_MGR_TYPE           1716L

//
// MessageId: RPC_S_UNKNOWN_IF
//
// MessageText:
//
//  The interface is unknown.
//
#define RPC_S_UNKNOWN_IF                 1717L

//
// MessageId: RPC_S_NO_BINDINGS
//
// MessageText:
//
//  There are no bindings.
//
#define RPC_S_NO_BINDINGS                1718L

//
// MessageId: RPC_S_NO_PROTSEQS
//
// MessageText:
//
//  There are no protocol sequences.
//
#define RPC_S_NO_PROTSEQS                1719L

//
// MessageId: RPC_S_CANT_CREATE_ENDPOINT
//
// MessageText:
//
//  The endpoint cannot be created.
//
#define RPC_S_CANT_CREATE_ENDPOINT       1720L

//
// MessageId: RPC_S_OUT_OF_RESOURCES
//
// MessageText:
//
//  Not enough resources are available to complete this operation.
//
#define RPC_S_OUT_OF_RESOURCES           1721L

//
// MessageId: RPC_S_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The RPC server is unavailable.
//
#define RPC_S_SERVER_UNAVAILABLE         1722L

//
// MessageId: RPC_S_SERVER_TOO_BUSY
//
// MessageText:
//
//  The RPC server is too busy to complete this operation.
//
#define RPC_S_SERVER_TOO_BUSY            1723L

//
// MessageId: RPC_S_INVALID_NETWORK_OPTIONS
//
// MessageText:
//
//  The network options are invalid.
//
#define RPC_S_INVALID_NETWORK_OPTIONS    1724L

//
// MessageId: RPC_S_NO_CALL_ACTIVE
//
// MessageText:
//
//  There are no remote procedure calls active on this thread.
//
#define RPC_S_NO_CALL_ACTIVE             1725L

//
// MessageId: RPC_S_CALL_FAILED
//
// MessageText:
//
//  The remote procedure call failed.
//
#define RPC_S_CALL_FAILED                1726L

//
// MessageId: RPC_S_CALL_FAILED_DNE
//
// MessageText:
//
//  The remote procedure call failed and did not execute.
//
#define RPC_S_CALL_FAILED_DNE            1727L

//
// MessageId: RPC_S_PROTOCOL_ERROR
//
// MessageText:
//
//  A remote procedure call (RPC) protocol error occurred.
//
#define RPC_S_PROTOCOL_ERROR             1728L

//
// MessageId: RPC_S_UNSUPPORTED_TRANS_SYN
//
// MessageText:
//
//  The transfer syntax is not supported by the RPC server.
//
#define RPC_S_UNSUPPORTED_TRANS_SYN      1730L

//
// MessageId: RPC_S_UNSUPPORTED_TYPE
//
// MessageText:
//
//  The universal unique identifier (UUID) type is not supported.
//
#define RPC_S_UNSUPPORTED_TYPE           1732L

//
// MessageId: RPC_S_INVALID_TAG
//
// MessageText:
//
//  The tag is invalid.
//
#define RPC_S_INVALID_TAG                1733L

//
// MessageId: RPC_S_INVALID_BOUND
//
// MessageText:
//
//  The array bounds are invalid.
//
#define RPC_S_INVALID_BOUND              1734L

//
// MessageId: RPC_S_NO_ENTRY_NAME
//
// MessageText:
//
//  The binding does not contain an entry name.
//
#define RPC_S_NO_ENTRY_NAME              1735L

//
// MessageId: RPC_S_INVALID_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is invalid.
//
#define RPC_S_INVALID_NAME_SYNTAX        1736L

//
// MessageId: RPC_S_UNSUPPORTED_NAME_SYNTAX
//
// MessageText:
//
//  The name syntax is not supported.
//
#define RPC_S_UNSUPPORTED_NAME_SYNTAX    1737L

//
// MessageId: RPC_S_UUID_NO_ADDRESS
//
// MessageText:
//
//  No network address is available to use to construct a universal
//  unique identifier (UUID).
//
#define RPC_S_UUID_NO_ADDRESS            1739L

//
// MessageId: RPC_S_DUPLICATE_ENDPOINT
//
// MessageText:
//
//  The endpoint is a duplicate.
//
#define RPC_S_DUPLICATE_ENDPOINT         1740L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_TYPE
//
// MessageText:
//
//  The authentication type is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_TYPE         1741L

//
// MessageId: RPC_S_MAX_CALLS_TOO_SMALL
//
// MessageText:
//
//  The maximum number of calls is too small.
//
#define RPC_S_MAX_CALLS_TOO_SMALL        1742L

//
// MessageId: RPC_S_STRING_TOO_LONG
//
// MessageText:
//
//  The string is too long.
//
#define RPC_S_STRING_TOO_LONG            1743L

//
// MessageId: RPC_S_PROTSEQ_NOT_FOUND
//
// MessageText:
//
//  The RPC protocol sequence was not found.
//
#define RPC_S_PROTSEQ_NOT_FOUND          1744L

//
// MessageId: RPC_S_PROCNUM_OUT_OF_RANGE
//
// MessageText:
//
//  The procedure number is out of range.
//
#define RPC_S_PROCNUM_OUT_OF_RANGE       1745L

//
// MessageId: RPC_S_BINDING_HAS_NO_AUTH
//
// MessageText:
//
//  The binding does not contain any authentication information.
//
#define RPC_S_BINDING_HAS_NO_AUTH        1746L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_SERVICE
//
// MessageText:
//
//  The authentication service is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_SERVICE      1747L

//
// MessageId: RPC_S_UNKNOWN_AUTHN_LEVEL
//
// MessageText:
//
//  The authentication level is unknown.
//
#define RPC_S_UNKNOWN_AUTHN_LEVEL        1748L

//
// MessageId: RPC_S_INVALID_AUTH_IDENTITY
//
// MessageText:
//
//  The security context is invalid.
//
#define RPC_S_INVALID_AUTH_IDENTITY      1749L

//
// MessageId: RPC_S_UNKNOWN_AUTHZ_SERVICE
//
// MessageText:
//
//  The authorization service is unknown.
//
#define RPC_S_UNKNOWN_AUTHZ_SERVICE      1750L

//
// MessageId: EPT_S_INVALID_ENTRY
//
// MessageText:
//
//  The entry is invalid.
//
#define EPT_S_INVALID_ENTRY              1751L

//
// MessageId: EPT_S_CANT_PERFORM_OP
//
// MessageText:
//
//  The server endpoint cannot perform the operation.
//
#define EPT_S_CANT_PERFORM_OP            1752L

//
// MessageId: EPT_S_NOT_REGISTERED
//
// MessageText:
//
//  There are no more endpoints available from the endpoint mapper.
//
#define EPT_S_NOT_REGISTERED             1753L

//
// MessageId: RPC_S_NOTHING_TO_EXPORT
//
// MessageText:
//
//  No interfaces have been exported.
//
#define RPC_S_NOTHING_TO_EXPORT          1754L

//
// MessageId: RPC_S_INCOMPLETE_NAME
//
// MessageText:
//
//  The entry name is incomplete.
//
#define RPC_S_INCOMPLETE_NAME            1755L

//
// MessageId: RPC_S_INVALID_VERS_OPTION
//
// MessageText:
//
//  The version option is invalid.
//
#define RPC_S_INVALID_VERS_OPTION        1756L

//
// MessageId: RPC_S_NO_MORE_MEMBERS
//
// MessageText:
//
//  There are no more members.
//
#define RPC_S_NO_MORE_MEMBERS            1757L

//
// MessageId: RPC_S_NOT_ALL_OBJS_UNEXPORTED
//
// MessageText:
//
//  There is nothing to unexport.
//
#define RPC_S_NOT_ALL_OBJS_UNEXPORTED    1758L

//
// MessageId: RPC_S_INTERFACE_NOT_FOUND
//
// MessageText:
//
//  The interface was not found.
//
#define RPC_S_INTERFACE_NOT_FOUND        1759L

//
// MessageId: RPC_S_ENTRY_ALREADY_EXISTS
//
// MessageText:
//
//  The entry already exists.
//
#define RPC_S_ENTRY_ALREADY_EXISTS       1760L

//
// MessageId: RPC_S_ENTRY_NOT_FOUND
//
// MessageText:
//
//  The entry is not found.
//
#define RPC_S_ENTRY_NOT_FOUND            1761L

//
// MessageId: RPC_S_NAME_SERVICE_UNAVAILABLE
//
// MessageText:
//
//  The name service is unavailable.
//
#define RPC_S_NAME_SERVICE_UNAVAILABLE   1762L

//
// MessageId: RPC_S_INVALID_NAF_ID
//
// MessageText:
//
//  The network address family is invalid.
//
#define RPC_S_INVALID_NAF_ID             1763L

//
// MessageId: RPC_S_CANNOT_SUPPORT
//
// MessageText:
//
//  The requested operation is not supported.
//
#define RPC_S_CANNOT_SUPPORT             1764L

//
// MessageId: RPC_S_NO_CONTEXT_AVAILABLE
//
// MessageText:
//
//  No security context is available to allow impersonation.
//
#define RPC_S_NO_CONTEXT_AVAILABLE       1765L

//
// MessageId: RPC_S_INTERNAL_ERROR
//
// MessageText:
//
//  An internal error occurred in a remote procedure call (RPC).
//
#define RPC_S_INTERNAL_ERROR             1766L

//
// MessageId: RPC_S_ZERO_DIVIDE
//
// MessageText:
//
//  The RPC server attempted an integer division by zero.
//
#define RPC_S_ZERO_DIVIDE                1767L

//
// MessageId: RPC_S_ADDRESS_ERROR
//
// MessageText:
//
//  An addressing error occurred in the RPC server.
//
#define RPC_S_ADDRESS_ERROR              1768L

//
// MessageId: RPC_S_FP_DIV_ZERO
//
// MessageText:
//
//  A floating-point operation at the RPC server caused a division by zero.
//
#define RPC_S_FP_DIV_ZERO                1769L

//
// MessageId: RPC_S_FP_UNDERFLOW
//
// MessageText:
//
//  A floating-point underflow occurred at the RPC server.
//
#define RPC_S_FP_UNDERFLOW               1770L

//
// MessageId: RPC_S_FP_OVERFLOW
//
// MessageText:
//
//  A floating-point overflow occurred at the RPC server.
//
#define RPC_S_FP_OVERFLOW                1771L

//
// MessageId: RPC_X_NO_MORE_ENTRIES
//
// MessageText:
//
//  The list of RPC servers available for the binding of auto handles
//  has been exhausted.
//
#define RPC_X_NO_MORE_ENTRIES            1772L

//
// MessageId: RPC_X_SS_CHAR_TRANS_OPEN_FAIL
//
// MessageText:
//
//  Unable to open the character translation table file.
//
#define RPC_X_SS_CHAR_TRANS_OPEN_FAIL    1773L

//
// MessageId: RPC_X_SS_CHAR_TRANS_SHORT_FILE
//
// MessageText:
//
//  The file containing the character translation table has fewer than
//  512 bytes.
//
#define RPC_X_SS_CHAR_TRANS_SHORT_FILE   1774L

//
// MessageId: RPC_X_SS_IN_NULL_CONTEXT
//
// MessageText:
//
//  A null context handle was passed from the client to the host during
//  a remote procedure call.
//
#define RPC_X_SS_IN_NULL_CONTEXT         1775L

//
// MessageId: RPC_X_SS_CONTEXT_DAMAGED
//
// MessageText:
//
//  The context handle changed during a remote procedure call.
//
#define RPC_X_SS_CONTEXT_DAMAGED         1777L

//
// MessageId: RPC_X_SS_HANDLES_MISMATCH
//
// MessageText:
//
//  The binding handles passed to a remote procedure call do not match.
//
#define RPC_X_SS_HANDLES_MISMATCH        1778L

//
// MessageId: RPC_X_SS_CANNOT_GET_CALL_HANDLE
//
// MessageText:
//
//  The stub is unable to get the remote procedure call handle.
//
#define RPC_X_SS_CANNOT_GET_CALL_HANDLE  1779L

//
// MessageId: RPC_X_NULL_REF_POINTER
//
// MessageText:
//
//  A null reference pointer was passed to the stub.
//
#define RPC_X_NULL_REF_POINTER           1780L

//
// MessageId: RPC_X_ENUM_VALUE_OUT_OF_RANGE
//
// MessageText:
//
//  The enumeration value is out of range.
//
#define RPC_X_ENUM_VALUE_OUT_OF_RANGE    1781L

//
// MessageId: RPC_X_BYTE_COUNT_TOO_SMALL
//
// MessageText:
//
//  The byte count is too small.
//
#define RPC_X_BYTE_COUNT_TOO_SMALL       1782L

//
// MessageId: RPC_X_BAD_STUB_DATA
//
// MessageText:
//
//  The stub received bad data.
//
#define RPC_X_BAD_STUB_DATA              1783L

//
// MessageId: ERROR_INVALID_USER_BUFFER
//
// MessageText:
//
//  The supplied user buffer is not valid for the requested operation.
//
#define ERROR_INVALID_USER_BUFFER        1784L

//
// MessageId: ERROR_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  The disk media is not recognized.  It may not be formatted.
//
#define ERROR_UNRECOGNIZED_MEDIA         1785L

//
// MessageId: ERROR_NO_TRUST_LSA_SECRET
//
// MessageText:
//
//  The workstation does not have a trust secret.
//
#define ERROR_NO_TRUST_LSA_SECRET        1786L

//
// MessageId: ERROR_NO_TRUST_SAM_ACCOUNT
//
// MessageText:
//
//  The SAM database on the Windows NT Server does not have a computer
//  account for this workstation trust relationship.
//
#define ERROR_NO_TRUST_SAM_ACCOUNT       1787L

//
// MessageId: ERROR_TRUSTED_DOMAIN_FAILURE
//
// MessageText:
//
//  The trust relationship between the primary domain and the trusted
//  domain failed.
//
#define ERROR_TRUSTED_DOMAIN_FAILURE     1788L

//
// MessageId: ERROR_TRUSTED_RELATIONSHIP_FAILURE
//
// MessageText:
//
//  The trust relationship between this workstation and the primary
//  domain failed.
//
#define ERROR_TRUSTED_RELATIONSHIP_FAILURE 1789L

//
// MessageId: ERROR_TRUST_FAILURE
//
// MessageText:
//
//  The network logon failed.
//
#define ERROR_TRUST_FAILURE              1790L

//
// MessageId: RPC_S_CALL_IN_PROGRESS
//
// MessageText:
//
//  A remote procedure call is already in progress for this thread.
//
#define RPC_S_CALL_IN_PROGRESS           1791L

//
// MessageId: ERROR_NETLOGON_NOT_STARTED
//
// MessageText:
//
//  An attempt was made to logon, but the network logon service was not started.
//
#define ERROR_NETLOGON_NOT_STARTED       1792L

//
// MessageId: ERROR_ACCOUNT_EXPIRED
//
// MessageText:
//
//  The user's account has expired.
//
#define ERROR_ACCOUNT_EXPIRED            1793L

//
// MessageId: ERROR_REDIRECTOR_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The redirector is in use and cannot be unloaded.
//
#define ERROR_REDIRECTOR_HAS_OPEN_HANDLES 1794L

//
// MessageId: ERROR_PRINTER_DRIVER_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified printer driver is already installed.
//
#define ERROR_PRINTER_DRIVER_ALREADY_INSTALLED 1795L

//
// MessageId: ERROR_UNKNOWN_PORT
//
// MessageText:
//
//  The specified port is unknown.
//
#define ERROR_UNKNOWN_PORT               1796L

//
// MessageId: ERROR_UNKNOWN_PRINTER_DRIVER
//
// MessageText:
//
//  The printer driver is unknown.
//
#define ERROR_UNKNOWN_PRINTER_DRIVER     1797L

//
// MessageId: ERROR_UNKNOWN_PRINTPROCESSOR
//
// MessageText:
//
//  The print processor is unknown.
//
#define ERROR_UNKNOWN_PRINTPROCESSOR     1798L

//
// MessageId: ERROR_INVALID_SEPARATOR_FILE
//
// MessageText:
//
//  The specified separator file is invalid.
//
#define ERROR_INVALID_SEPARATOR_FILE     1799L

//
// MessageId: ERROR_INVALID_PRIORITY
//
// MessageText:
//
//  The specified priority is invalid.
//
#define ERROR_INVALID_PRIORITY           1800L

//
// MessageId: ERROR_INVALID_PRINTER_NAME
//
// MessageText:
//
//  The printer name is invalid.
//
#define ERROR_INVALID_PRINTER_NAME       1801L

//
// MessageId: ERROR_PRINTER_ALREADY_EXISTS
//
// MessageText:
//
//  The printer already exists.
//
#define ERROR_PRINTER_ALREADY_EXISTS     1802L

//
// MessageId: ERROR_INVALID_PRINTER_COMMAND
//
// MessageText:
//
//  The printer command is invalid.
//
#define ERROR_INVALID_PRINTER_COMMAND    1803L

//
// MessageId: ERROR_INVALID_DATATYPE
//
// MessageText:
//
//  The specified datatype is invalid.
//
#define ERROR_INVALID_DATATYPE           1804L

//
// MessageId: ERROR_INVALID_ENVIRONMENT
//
// MessageText:
//
//  The environment specified is invalid.
//
#define ERROR_INVALID_ENVIRONMENT        1805L

//
// MessageId: RPC_S_NO_MORE_BINDINGS
//
// MessageText:
//
//  There are no more bindings.
//
#define RPC_S_NO_MORE_BINDINGS           1806L

//
// MessageId: ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is an interdomain trust account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT 1807L

//
// MessageId: ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a computer account.  Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT 1808L

//
// MessageId: ERROR_NOLOGON_SERVER_TRUST_ACCOUNT
//
// MessageText:
//
//  The account used is a server trust account. Use your global user account or local user account to access this server.
//
#define ERROR_NOLOGON_SERVER_TRUST_ACCOUNT 1809L

//
// MessageId: ERROR_DOMAIN_TRUST_INCONSISTENT
//
// MessageText:
//
//  The name or security ID (SID) of the domain specified is inconsistent
//  with the trust information for that domain.
//
#define ERROR_DOMAIN_TRUST_INCONSISTENT  1810L

//
// MessageId: ERROR_SERVER_HAS_OPEN_HANDLES
//
// MessageText:
//
//  The server is in use and cannot be unloaded.
//
#define ERROR_SERVER_HAS_OPEN_HANDLES    1811L

//
// MessageId: ERROR_RESOURCE_DATA_NOT_FOUND
//
// MessageText:
//
//  The specified image file did not contain a resource section.
//
#define ERROR_RESOURCE_DATA_NOT_FOUND    1812L

//
// MessageId: ERROR_RESOURCE_TYPE_NOT_FOUND
//
// MessageText:
//
//  The specified resource type cannot be found in the image file.
//
#define ERROR_RESOURCE_TYPE_NOT_FOUND    1813L

//
// MessageId: ERROR_RESOURCE_NAME_NOT_FOUND
//
// MessageText:
//
//  The specified resource name cannot be found in the image file.
//
#define ERROR_RESOURCE_NAME_NOT_FOUND    1814L

//
// MessageId: ERROR_RESOURCE_LANG_NOT_FOUND
//
// MessageText:
//
//  The specified resource language ID cannot be found in the image file.
//
#define ERROR_RESOURCE_LANG_NOT_FOUND    1815L

//
// MessageId: ERROR_NOT_ENOUGH_QUOTA
//
// MessageText:
//
//  Not enough quota is available to process this command.
//
#define ERROR_NOT_ENOUGH_QUOTA           1816L

//
// MessageId: RPC_S_NO_INTERFACES
//
// MessageText:
//
//  No interfaces have been registered.
//
#define RPC_S_NO_INTERFACES              1817L

//
// MessageId: RPC_S_CALL_CANCELLED
//
// MessageText:
//
//  The remote procedure call was cancelled.
//
#define RPC_S_CALL_CANCELLED             1818L

//
// MessageId: RPC_S_BINDING_INCOMPLETE
//
// MessageText:
//
//  The binding handle does not contain all required information.
//
#define RPC_S_BINDING_INCOMPLETE         1819L

//
// MessageId: RPC_S_COMM_FAILURE
//
// MessageText:
//
//  A communications failure occurred during a remote procedure call.
//
#define RPC_S_COMM_FAILURE               1820L

//
// MessageId: RPC_S_UNSUPPORTED_AUTHN_LEVEL
//
// MessageText:
//
//  The requested authentication level is not supported.
//
#define RPC_S_UNSUPPORTED_AUTHN_LEVEL    1821L

//
// MessageId: RPC_S_NO_PRINC_NAME
//
// MessageText:
//
//  No principal name registered.
//
#define RPC_S_NO_PRINC_NAME              1822L

//
// MessageId: RPC_S_NOT_RPC_ERROR
//
// MessageText:
//
//  The error specified is not a valid Windows RPC error code.
//
#define RPC_S_NOT_RPC_ERROR              1823L

//
// MessageId: RPC_S_UUID_LOCAL_ONLY
//
// MessageText:
//
//  A UUID that is valid only on this computer has been allocated.
//
#define RPC_S_UUID_LOCAL_ONLY            1824L

//
// MessageId: RPC_S_SEC_PKG_ERROR
//
// MessageText:
//
//  A security package specific error occurred.
//
#define RPC_S_SEC_PKG_ERROR              1825L

//
// MessageId: RPC_S_NOT_CANCELLED
//
// MessageText:
//
//  Thread is not canceled.
//
#define RPC_S_NOT_CANCELLED              1826L

//
// MessageId: RPC_X_INVALID_ES_ACTION
//
// MessageText:
//
//  Invalid operation on the encoding/decoding handle.
//
#define RPC_X_INVALID_ES_ACTION          1827L

//
// MessageId: RPC_X_WRONG_ES_VERSION
//
// MessageText:
//
//  Incompatible version of the serializing package.
//
#define RPC_X_WRONG_ES_VERSION           1828L

//
// MessageId: RPC_X_WRONG_STUB_VERSION
//
// MessageText:
//
//  Incompatible version of the RPC stub.
//
#define RPC_X_WRONG_STUB_VERSION         1829L

//
// MessageId: RPC_X_INVALID_PIPE_OBJECT
//
// MessageText:
//
//  The RPC pipe object is invalid or corrupted.
//
#define RPC_X_INVALID_PIPE_OBJECT        1830L

//
// MessageId: RPC_X_WRONG_PIPE_ORDER
//
// MessageText:
//
//  An invalid operation was attempted on an RPC pipe object.
//
#define RPC_X_WRONG_PIPE_ORDER           1831L

//
// MessageId: RPC_X_WRONG_PIPE_VERSION
//
// MessageText:
//
//  Unsupported RPC pipe version.
//
#define RPC_X_WRONG_PIPE_VERSION         1832L

//
// MessageId: RPC_S_GROUP_MEMBER_NOT_FOUND
//
// MessageText:
//
//  The group member was not found.
//
#define RPC_S_GROUP_MEMBER_NOT_FOUND     1898L

//
// MessageId: EPT_S_CANT_CREATE
//
// MessageText:
//
//  The endpoint mapper database entry could not be created.
//
#define EPT_S_CANT_CREATE                1899L

//
// MessageId: RPC_S_INVALID_OBJECT
//
// MessageText:
//
//  The object universal unique identifier (UUID) is the nil UUID.
//
#define RPC_S_INVALID_OBJECT             1900L

//
// MessageId: ERROR_INVALID_TIME
//
// MessageText:
//
//  The specified time is invalid.
//
#define ERROR_INVALID_TIME               1901L

//
// MessageId: ERROR_INVALID_FORM_NAME
//
// MessageText:
//
//  The specified form name is invalid.
//
#define ERROR_INVALID_FORM_NAME          1902L

//
// MessageId: ERROR_INVALID_FORM_SIZE
//
// MessageText:
//
//  The specified form size is invalid.
//
#define ERROR_INVALID_FORM_SIZE          1903L

//
// MessageId: ERROR_ALREADY_WAITING
//
// MessageText:
//
//  The specified printer handle is already being waited on
//
#define ERROR_ALREADY_WAITING            1904L

//
// MessageId: ERROR_PRINTER_DELETED
//
// MessageText:
//
//  The specified printer has been deleted.
//
#define ERROR_PRINTER_DELETED            1905L

//
// MessageId: ERROR_INVALID_PRINTER_STATE
//
// MessageText:
//
//  The state of the printer is invalid.
//
#define ERROR_INVALID_PRINTER_STATE      1906L

//
// MessageId: ERROR_PASSWORD_MUST_CHANGE
//
// MessageText:
//
//  The user must change his password before he logs on the first time.
//
#define ERROR_PASSWORD_MUST_CHANGE       1907L

//
// MessageId: ERROR_DOMAIN_CONTROLLER_NOT_FOUND
//
// MessageText:
//
//  Could not find the domain controller for this domain.
//
#define ERROR_DOMAIN_CONTROLLER_NOT_FOUND 1908L

//
// MessageId: ERROR_ACCOUNT_LOCKED_OUT
//
// MessageText:
//
//  The referenced account is currently locked out and may not be logged on to.
//
#define ERROR_ACCOUNT_LOCKED_OUT         1909L

//
// MessageId: OR_INVALID_OXID
//
// MessageText:
//
//  The object exporter specified was not found.
//
#define OR_INVALID_OXID                  1910L

//
// MessageId: OR_INVALID_OID
//
// MessageText:
//
//  The object specified was not found.
//
#define OR_INVALID_OID                   1911L

//
// MessageId: OR_INVALID_SET
//
// MessageText:
//
//  The object resolver set specified was not found.
//
#define OR_INVALID_SET                   1912L

//
// MessageId: RPC_S_SEND_INCOMPLETE
//
// MessageText:
//
//  Some data remains to be sent in the request buffer.
//
#define RPC_S_SEND_INCOMPLETE            1913L

//
// MessageId: RPC_S_INVALID_ASYNC_HANDLE
//
// MessageText:
//
//  Invalid asynchronous remote procedure call handle.
//
#define RPC_S_INVALID_ASYNC_HANDLE       1914L

//
// MessageId: RPC_S_INVALID_ASYNC_CALL
//
// MessageText:
//
//  Invalid asynchronous RPC call handle for this operation.
//
#define RPC_S_INVALID_ASYNC_CALL         1915L

//
// MessageId: RPC_X_PIPE_CLOSED
//
// MessageText:
//
//  The RPC pipe object has already been closed.
//
#define RPC_X_PIPE_CLOSED                1916L

//
// MessageId: RPC_X_PIPE_DISCIPLINE_ERROR
//
// MessageText:
//
//  The RPC call completed before all pipes were processed.
//
#define RPC_X_PIPE_DISCIPLINE_ERROR      1917L

//
// MessageId: RPC_X_PIPE_EMPTY
//
// MessageText:
//
//  No more data is available from the RPC pipe.
//
#define RPC_X_PIPE_EMPTY                 1918L

//
// MessageId: ERROR_NO_SITENAME
//
// MessageText:
//
//  No site name is available for this machine.
//
#define ERROR_NO_SITENAME                1919L

//
// MessageId: ERROR_CANT_ACCESS_FILE
//
// MessageText:
//
//  The file can not be accessed by the system.
//
#define ERROR_CANT_ACCESS_FILE           1920L

//
// MessageId: ERROR_CANT_RESOLVE_FILENAME
//
// MessageText:
//
//  The name of the file cannot be resolved by the system.
//
#define ERROR_CANT_RESOLVE_FILENAME      1921L

//
// MessageId: ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY
//
// MessageText:
//
//  The directory service evaluated group memberships locally.
//
#define ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY 1922L

//
// MessageId: ERROR_DS_NO_ATTRIBUTE_OR_VALUE
//
// MessageText:
//
//  The specified directory service attribute or value does not exist.
//
#define ERROR_DS_NO_ATTRIBUTE_OR_VALUE   1923L

//
// MessageId: ERROR_DS_INVALID_ATTRIBUTE_SYNTAX
//
// MessageText:
//
//  The attribute syntax specified to the directory service is invalid.
//
#define ERROR_DS_INVALID_ATTRIBUTE_SYNTAX 1924L

//
// MessageId: ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED
//
// MessageText:
//
//  The attribute type specified to the directory service is not defined.
//
#define ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED 1925L

//
// MessageId: ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS
//
// MessageText:
//
//  The specified directory service attribute or value already exists.
//
#define ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS 1926L

//
// MessageId: ERROR_DS_BUSY
//
// MessageText:
//
//  The directory service is busy.
//
#define ERROR_DS_BUSY                    1927L

//
// MessageId: ERROR_DS_UNAVAILABLE
//
// MessageText:
//
//  The directory service is unavailable.
//
#define ERROR_DS_UNAVAILABLE             1928L

//
// MessageId: ERROR_DS_NO_RIDS_ALLOCATED
//
// MessageText:
//
//  The directory service was unable to allocate a relative identifier.
//
#define ERROR_DS_NO_RIDS_ALLOCATED       1929L

//
// MessageId: ERROR_DS_NO_MORE_RIDS
//
// MessageText:
//
//  The directory service has exhausted the pool of relative identifiers.
//
#define ERROR_DS_NO_MORE_RIDS            1930L

//
// MessageId: ERROR_DS_INCORRECT_ROLE_OWNER
//
// MessageText:
//
//  The requested operation could not be performed because the directory service is not the
//  master for that type of operation.
//
#define ERROR_DS_INCORRECT_ROLE_OWNER    1931L

//
// MessageId: ERROR_DS_RIDMGR_INIT_ERROR
//
// MessageText:
//
//  The directory service was unable to initialize the subsystem that allocates relative identifiers.
//
#define ERROR_DS_RIDMGR_INIT_ERROR       1932L

//
// MessageId: ERROR_DS_OBJ_CLASS_VIOLATION
//
// MessageText:
//
//  The requested operation did not satisfy one or more constraints associated with the class of the object.
//
#define ERROR_DS_OBJ_CLASS_VIOLATION     1933L

//
// MessageId: ERROR_DS_CANT_ON_NON_LEAF
//
// MessageText:
//
//  The directory service can perform the requested operation only on a leaf object.
//
#define ERROR_DS_CANT_ON_NON_LEAF        1934L

//
// MessageId: ERROR_DS_CANT_ON_RDN
//
// MessageText:
//
//  The directory service cannot perform the requested operation on the RDN attribute of an object.
//
#define ERROR_DS_CANT_ON_RDN             1935L

//
// MessageId: ERROR_DS_CANT_MOD_OBJ_CLASS
//
// MessageText:
//
//  The directory service detected an attempt to modify the object class of an object.
//
#define ERROR_DS_CANT_MOD_OBJ_CLASS      1936L

//
// MessageId: ERROR_DS_CROSS_DOM_MOVE_ERROR
//
// MessageText:
//
//  The requested cross domain move operation could not be performed.
//
#define ERROR_DS_CROSS_DOM_MOVE_ERROR    1937L

//
// MessageId: ERROR_DS_GC_NOT_AVAILABLE
//
// MessageText:
//
//  Unable to contact the global catalog server.
//
#define ERROR_DS_GC_NOT_AVAILABLE        1938L

//
// MessageId: ERROR_NO_BROWSER_SERVERS_FOUND
//
// MessageText:
//
//  The list of servers for this workgroup is not currently available
//
#define ERROR_NO_BROWSER_SERVERS_FOUND   6118L




///////////////////////////
//                       //
//   OpenGL Error Code   //
//                       //
///////////////////////////


//
// MessageId: ERROR_INVALID_PIXEL_FORMAT
//
// MessageText:
//
//  The pixel format is invalid.
//
#define ERROR_INVALID_PIXEL_FORMAT       2000L

//
// MessageId: ERROR_BAD_DRIVER
//
// MessageText:
//
//  The specified driver is invalid.
//
#define ERROR_BAD_DRIVER                 2001L

//
// MessageId: ERROR_INVALID_WINDOW_STYLE
//
// MessageText:
//
//  The window style or class attribute is invalid for this operation.
//
#define ERROR_INVALID_WINDOW_STYLE       2002L

//
// MessageId: ERROR_METAFILE_NOT_SUPPORTED
//
// MessageText:
//
//  The requested metafile operation is not supported.
//
#define ERROR_METAFILE_NOT_SUPPORTED     2003L

//
// MessageId: ERROR_TRANSFORM_NOT_SUPPORTED
//
// MessageText:
//
//  The requested transformation operation is not supported.
//
#define ERROR_TRANSFORM_NOT_SUPPORTED    2004L

//
// MessageId: ERROR_CLIPPING_NOT_SUPPORTED
//
// MessageText:
//
//  The requested clipping operation is not supported.
//
#define ERROR_CLIPPING_NOT_SUPPORTED     2005L

// End of OpenGL error codes



///////////////////////////////////////////
//                                       //
//   Image Color Management Error Code   //
//                                       //
///////////////////////////////////////////


//
// MessageId: ERROR_INVALID_CMM
//
// MessageText:
//
//  The specified color management module is invalid.
//
#define ERROR_INVALID_CMM                2300L

//
// MessageId: ERROR_INVALID_PROFILE
//
// MessageText:
//
//  The specified color profile is invalid.
//
#define ERROR_INVALID_PROFILE            2301L

//
// MessageId: ERROR_TAG_NOT_FOUND
//
// MessageText:
//
//  The specified tag was not found.
//
#define ERROR_TAG_NOT_FOUND              2302L

//
// MessageId: ERROR_TAG_NOT_PRESENT
//
// MessageText:
//
//  A required tag is not present.
//
#define ERROR_TAG_NOT_PRESENT            2303L

//
// MessageId: ERROR_DUPLICATE_TAG
//
// MessageText:
//
//  The specified tag is already present.
//
#define ERROR_DUPLICATE_TAG              2304L

//
// MessageId: ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE
//
// MessageText:
//
//  The specified color profile is not associated with any device.
//
#define ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE 2305L

//
// MessageId: ERROR_PROFILE_NOT_FOUND
//
// MessageText:
//
//  The specified color profile was not found.
//
#define ERROR_PROFILE_NOT_FOUND          2306L

//
// MessageId: ERROR_INVALID_COLORSPACE
//
// MessageText:
//
//  The specified color space is invalid.
//
#define ERROR_INVALID_COLORSPACE         2307L

//
// MessageId: ERROR_ICM_NOT_ENABLED
//
// MessageText:
//
//  Image Color Management is not enabled.
//
#define ERROR_ICM_NOT_ENABLED            2308L

//
// MessageId: ERROR_DELETING_ICM_XFORM
//
// MessageText:
//
//  There was an error while deleting the color transform.
//
#define ERROR_DELETING_ICM_XFORM         2309L

//
// MessageId: ERROR_INVALID_TRANSFORM
//
// MessageText:
//
//  The specified color transform is invalid.
//
#define ERROR_INVALID_TRANSFORM          2310L


////////////////////////////////////
//                                //
//     Win32 Spooler Error Codes  //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_UNKNOWN_PRINT_MONITOR
//
// MessageText:
//
//  The specified print monitor is unknown.
//
#define ERROR_UNKNOWN_PRINT_MONITOR      3000L

//
// MessageId: ERROR_PRINTER_DRIVER_IN_USE
//
// MessageText:
//
//  The specified printer driver is currently in use.
//
#define ERROR_PRINTER_DRIVER_IN_USE      3001L

//
// MessageId: ERROR_SPOOL_FILE_NOT_FOUND
//
// MessageText:
//
//  The spool file was not found.
//
#define ERROR_SPOOL_FILE_NOT_FOUND       3002L

//
// MessageId: ERROR_SPL_NO_STARTDOC
//
// MessageText:
//
//  A StartDocPrinter call was not issued.
//
#define ERROR_SPL_NO_STARTDOC            3003L

//
// MessageId: ERROR_SPL_NO_ADDJOB
//
// MessageText:
//
//  An AddJob call was not issued.
//
#define ERROR_SPL_NO_ADDJOB              3004L

//
// MessageId: ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print processor has already been installed.
//
#define ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED 3005L

//
// MessageId: ERROR_PRINT_MONITOR_ALREADY_INSTALLED
//
// MessageText:
//
//  The specified print monitor has already been installed.
//
#define ERROR_PRINT_MONITOR_ALREADY_INSTALLED 3006L

//
// MessageId: ERROR_INVALID_PRINT_MONITOR
//
// MessageText:
//
//  The specified print monitor does not have the required functions.
//
#define ERROR_INVALID_PRINT_MONITOR      3007L

//
// MessageId: ERROR_PRINT_MONITOR_IN_USE
//
// MessageText:
//
//  The specified print monitor is currently in use.
//
#define ERROR_PRINT_MONITOR_IN_USE       3008L

//
// MessageId: ERROR_PRINTER_HAS_JOBS_QUEUED
//
// MessageText:
//
//  The requested operation is not allowed when there are jobs queued to the printer.
//
#define ERROR_PRINTER_HAS_JOBS_QUEUED    3009L

//
// MessageId: ERROR_SUCCESS_REBOOT_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  Changes will not be effective until the system is rebooted.
//
#define ERROR_SUCCESS_REBOOT_REQUIRED    3010L

//
// MessageId: ERROR_SUCCESS_RESTART_REQUIRED
//
// MessageText:
//
//  The requested operation is successful.  Changes will not be effective until the service is restarted.
//
#define ERROR_SUCCESS_RESTART_REQUIRED   3011L

////////////////////////////////////
//                                //
//     Wins Error Codes           //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_WINS_INTERNAL
//
// MessageText:
//
//  WINS encountered an error while processing the command.
//
#define ERROR_WINS_INTERNAL              4000L

//
// MessageId: ERROR_CAN_NOT_DEL_LOCAL_WINS
//
// MessageText:
//
//  The local WINS can not be deleted.
//
#define ERROR_CAN_NOT_DEL_LOCAL_WINS     4001L

//
// MessageId: ERROR_STATIC_INIT
//
// MessageText:
//
//  The importation from the file failed.
//
#define ERROR_STATIC_INIT                4002L

//
// MessageId: ERROR_INC_BACKUP
//
// MessageText:
//
//  The backup failed. Was a full backup done before?
//
#define ERROR_INC_BACKUP                 4003L

//
// MessageId: ERROR_FULL_BACKUP
//
// MessageText:
//
//  The backup failed. Check the directory to which you are backing the database.
//
#define ERROR_FULL_BACKUP                4004L

//
// MessageId: ERROR_REC_NON_EXISTENT
//
// MessageText:
//
//  The name does not exist in the WINS database.
//
#define ERROR_REC_NON_EXISTENT           4005L

//
// MessageId: ERROR_RPL_NOT_ALLOWED
//
// MessageText:
//
//  Replication with a nonconfigured partner is not allowed.
//
#define ERROR_RPL_NOT_ALLOWED            4006L

////////////////////////////////////
//                                //
//     DHCP Error Codes           //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_DHCP_ADDRESS_CONFLICT
//
// MessageText:
//
//  The DHCP client has obtained an IP address that is already in use on the network.  The local interface will be disabled until the DHCP client can obtain a new address.
//
#define ERROR_DHCP_ADDRESS_CONFLICT      4100L

////////////////////////////////////
//                                //
//     WMI Error Codes            //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_WMI_GUID_NOT_FOUND
//
// MessageText:
//
//  The GUID passed was not recognized as valid by a WMI data provider.
//
#define ERROR_WMI_GUID_NOT_FOUND         4200L

//
// MessageId: ERROR_WMI_INSTANCE_NOT_FOUND
//
// MessageText:
//
//  The instance name passed was not recognized as valid by a WMI data provider.
//
#define ERROR_WMI_INSTANCE_NOT_FOUND     4201L

//
// MessageId: ERROR_WMI_ITEMID_NOT_FOUND
//
// MessageText:
//
//  The data item ID passed was not recognized as valid by a WMI data provider.
//
#define ERROR_WMI_ITEMID_NOT_FOUND       4202L

//
// MessageId: ERROR_WMI_TRY_AGAIN
//
// MessageText:
//
//  The WMI request could not be completed and should be retried.
//
#define ERROR_WMI_TRY_AGAIN              4203L

//
// MessageId: ERROR_WMI_DP_NOT_FOUND
//
// MessageText:
//
//  The WMI data provider could not be located.
//
#define ERROR_WMI_DP_NOT_FOUND           4204L

//
// MessageId: ERROR_WMI_UNRESOLVED_INSTANCE_REF
//
// MessageText:
//
//  The WMI data provider references an instance set that has not been registered.
//
#define ERROR_WMI_UNRESOLVED_INSTANCE_REF 4205L

//
// MessageId: ERROR_WMI_ALREADY_ENABLED
//
// MessageText:
//
//  The WMI data block or event notification has already been enabled.
//
#define ERROR_WMI_ALREADY_ENABLED        4206L

//
// MessageId: ERROR_WMI_GUID_DISCONNECTED
//
// MessageText:
//
//  The WMI data block is no longer available.
//
#define ERROR_WMI_GUID_DISCONNECTED      4207L

//
// MessageId: ERROR_WMI_SERVER_UNAVAILABLE
//
// MessageText:
//
//  The WMI data service is not available.
//
#define ERROR_WMI_SERVER_UNAVAILABLE     4208L

//
// MessageId: ERROR_WMI_DP_FAILED
//
// MessageText:
//
//  The WMI data provider failed to carry out the request.
//
#define ERROR_WMI_DP_FAILED              4209L

//
// MessageId: ERROR_WMI_INVALID_MOF
//
// MessageText:
//
//  The WMI MOF information is not valid.
//
#define ERROR_WMI_INVALID_MOF            4210L

//
// MessageId: ERROR_WMI_INVALID_REGINFO
//
// MessageText:
//
//  The WMI registration information is not valid.
//
#define ERROR_WMI_INVALID_REGINFO        4211L

////////////////////////////////////
//                                //
// NT Media Services Error Codes  //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_INVALID_MEDIA
//
// MessageText:
//
//  The media identifier does not represent a valid medium.
//
#define ERROR_INVALID_MEDIA              4300L

//
// MessageId: ERROR_INVALID_LIBRARY
//
// MessageText:
//
//  The library identifier does not represent a valid library.
//
#define ERROR_INVALID_LIBRARY            4301L

//
// MessageId: ERROR_INVALID_MEDIA_POOL
//
// MessageText:
//
//  The media pool identifier does not represent a valid media pool.
//
#define ERROR_INVALID_MEDIA_POOL         4302L

//
// MessageId: ERROR_DRIVE_MEDIA_MISMATCH
//
// MessageText:
//
//  The drive and medium are not compatible or exist in different libraries.
//
#define ERROR_DRIVE_MEDIA_MISMATCH       4303L

//
// MessageId: ERROR_MEDIA_OFFLINE
//
// MessageText:
//
//  The medium currently exists in an offline library and must be online to perform this operation.
//
#define ERROR_MEDIA_OFFLINE              4304L

//
// MessageId: ERROR_LIBRARY_OFFLINE
//
// MessageText:
//
//  The operation cannot be performed on an offline library.
//
#define ERROR_LIBRARY_OFFLINE            4305L

//
// MessageId: ERROR_EMPTY
//
// MessageText:
//
//  The library, drive, or media pool is empty.
//
#define ERROR_EMPTY                      4306L

//
// MessageId: ERROR_NOT_EMPTY
//
// MessageText:
//
//  The library, drive, or media pool must be empty to perform this operation.
//
#define ERROR_NOT_EMPTY                  4307L

//
// MessageId: ERROR_MEDIA_UNAVAILABLE
//
// MessageText:
//
//  No media is currently available in this media pool or library.
//
#define ERROR_MEDIA_UNAVAILABLE          4308L

//
// MessageId: ERROR_RESOURCE_DISABLED
//
// MessageText:
//
//  A resource required for this operation is disabled.
//
#define ERROR_RESOURCE_DISABLED          4309L

//
// MessageId: ERROR_INVALID_CLEANER
//
// MessageText:
//
//  The media identifier does not represent a valid cleaner.
//
#define ERROR_INVALID_CLEANER            4310L

//
// MessageId: ERROR_UNABLE_TO_CLEAN
//
// MessageText:
//
//  The drive cannot be cleaned or does not support cleaning.
//
#define ERROR_UNABLE_TO_CLEAN            4311L

//
// MessageId: ERROR_OBJECT_NOT_FOUND
//
// MessageText:
//
//  The object identifier does not represent a valid object.
//
#define ERROR_OBJECT_NOT_FOUND           4312L

//
// MessageId: ERROR_DATABASE_FAILURE
//
// MessageText:
//
//  Unable to read from or write to the database.
//
#define ERROR_DATABASE_FAILURE           4313L

//
// MessageId: ERROR_DATABASE_FULL
//
// MessageText:
//
//  The database is full.
//
#define ERROR_DATABASE_FULL              4314L

//
// MessageId: ERROR_MEDIA_INCOMPATIBLE
//
// MessageText:
//
//  The medium is not compatible with the device or media pool.
//
#define ERROR_MEDIA_INCOMPATIBLE         4315L

//
// MessageId: ERROR_RESOURCE_NOT_PRESENT
//
// MessageText:
//
//  The resource required for this operation does not exist.
//
#define ERROR_RESOURCE_NOT_PRESENT       4316L

//
// MessageId: ERROR_INVALID_OPERATION
//
// MessageText:
//
//  The operation identifier is not valid.
//
#define ERROR_INVALID_OPERATION          4317L

//
// MessageId: ERROR_MEDIA_NOT_AVAILABLE
//
// MessageText:
//
//  The media is not mounted or ready for use.
//
#define ERROR_MEDIA_NOT_AVAILABLE        4318L

//
// MessageId: ERROR_DEVICE_NOT_AVAILABLE
//
// MessageText:
//
//  The device is not ready for use.
//
#define ERROR_DEVICE_NOT_AVAILABLE       4319L

//
// MessageId: ERROR_REQUEST_REFUSED
//
// MessageText:
//
//  The operator or administrator has refused the request.
//
#define ERROR_REQUEST_REFUSED            4320L

////////////////////////////////////////////
//                                        //
// NT Remote Storage Service Error Codes  //
//                                        //
////////////////////////////////////////////
//
// MessageId: ERROR_FILE_OFFLINE
//
// MessageText:
//
//  The remote storage service was not able to recall the file.
//
#define ERROR_FILE_OFFLINE               4350L

//
// MessageId: ERROR_REMOTE_STORAGE_NOT_ACTIVE
//
// MessageText:
//
//  The remote storage service is not operational at this time.
//
#define ERROR_REMOTE_STORAGE_NOT_ACTIVE  4351L

//
// MessageId: ERROR_REMOTE_STORAGE_MEDIA_ERROR
//
// MessageText:
//
//  The remote storage service encountered a media error.
//
#define ERROR_REMOTE_STORAGE_MEDIA_ERROR 4352L

////////////////////////////////////////////
//                                        //
// NT Reparse Points Error Codes          //
//                                        //
////////////////////////////////////////////
//
// MessageId: ERROR_NOT_A_REPARSE_POINT
//
// MessageText:
//
//  The file or directory is not a reparse point.
//
#define ERROR_NOT_A_REPARSE_POINT        4390L

//
// MessageId: ERROR_REPARSE_ATTRIBUTE_CONFLICT
//
// MessageText:
//
//  The reparse point attribute cannot be set because it conflicts with an existing attribute.
//
#define ERROR_REPARSE_ATTRIBUTE_CONFLICT 4391L

////////////////////////////////////
//                                //
//     Cluster Error Codes        //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_DEPENDENT_RESOURCE_EXISTS
//
// MessageText:
//
//  The cluster resource cannot be moved to another group because other resources are dependent on it.
//
#define ERROR_DEPENDENT_RESOURCE_EXISTS  5001L

//
// MessageId: ERROR_DEPENDENCY_NOT_FOUND
//
// MessageText:
//
//  The cluster resource dependency cannot be found.
//
#define ERROR_DEPENDENCY_NOT_FOUND       5002L

//
// MessageId: ERROR_DEPENDENCY_ALREADY_EXISTS
//
// MessageText:
//
//  The cluster resource cannot be made dependent on the specified resource because it is already dependent.
//
#define ERROR_DEPENDENCY_ALREADY_EXISTS  5003L

//
// MessageId: ERROR_RESOURCE_NOT_ONLINE
//
// MessageText:
//
//  The cluster resource is not online.
//
#define ERROR_RESOURCE_NOT_ONLINE        5004L

//
// MessageId: ERROR_HOST_NODE_NOT_AVAILABLE
//
// MessageText:
//
//  A cluster node is not available for this operation.
//
#define ERROR_HOST_NODE_NOT_AVAILABLE    5005L

//
// MessageId: ERROR_RESOURCE_NOT_AVAILABLE
//
// MessageText:
//
//  The cluster resource is not available.
//
#define ERROR_RESOURCE_NOT_AVAILABLE     5006L

//
// MessageId: ERROR_RESOURCE_NOT_FOUND
//
// MessageText:
//
//  The cluster resource could not be found.
//
#define ERROR_RESOURCE_NOT_FOUND         5007L

//
// MessageId: ERROR_SHUTDOWN_CLUSTER
//
// MessageText:
//
//  The cluster is being shut down.
//
#define ERROR_SHUTDOWN_CLUSTER           5008L

//
// MessageId: ERROR_CANT_EVICT_ACTIVE_NODE
//
// MessageText:
//
//  A cluster node cannot be evicted from the cluster while it is online.
//
#define ERROR_CANT_EVICT_ACTIVE_NODE     5009L

//
// MessageId: ERROR_OBJECT_ALREADY_EXISTS
//
// MessageText:
//
//  The object already exists.
//
#define ERROR_OBJECT_ALREADY_EXISTS      5010L

//
// MessageId: ERROR_OBJECT_IN_LIST
//
// MessageText:
//
//  The object is already in the list.
//
#define ERROR_OBJECT_IN_LIST             5011L

//
// MessageId: ERROR_GROUP_NOT_AVAILABLE
//
// MessageText:
//
//  The cluster group is not available for any new requests.
//
#define ERROR_GROUP_NOT_AVAILABLE        5012L

//
// MessageId: ERROR_GROUP_NOT_FOUND
//
// MessageText:
//
//  The cluster group could not be found.
//
#define ERROR_GROUP_NOT_FOUND            5013L

//
// MessageId: ERROR_GROUP_NOT_ONLINE
//
// MessageText:
//
//  The operation could not be completed because the cluster group is not online.
//
#define ERROR_GROUP_NOT_ONLINE           5014L

//
// MessageId: ERROR_HOST_NODE_NOT_RESOURCE_OWNER
//
// MessageText:
//
//  The cluster node is not the owner of the resource.
//
#define ERROR_HOST_NODE_NOT_RESOURCE_OWNER 5015L

//
// MessageId: ERROR_HOST_NODE_NOT_GROUP_OWNER
//
// MessageText:
//
//  The cluster node is not the owner of the group.
//
#define ERROR_HOST_NODE_NOT_GROUP_OWNER  5016L

//
// MessageId: ERROR_RESMON_CREATE_FAILED
//
// MessageText:
//
//  The cluster resource could not be created in the specified resource monitor.
//
#define ERROR_RESMON_CREATE_FAILED       5017L

//
// MessageId: ERROR_RESMON_ONLINE_FAILED
//
// MessageText:
//
//  The cluster resource could not be brought online by the resource monitor.
//
#define ERROR_RESMON_ONLINE_FAILED       5018L

//
// MessageId: ERROR_RESOURCE_ONLINE
//
// MessageText:
//
//  The operation could not be completed because the cluster resource is online.
//
#define ERROR_RESOURCE_ONLINE            5019L

//
// MessageId: ERROR_QUORUM_RESOURCE
//
// MessageText:
//
//  The cluster resource could not be deleted or brought offline because it is the quorum resource.
//
#define ERROR_QUORUM_RESOURCE            5020L

//
// MessageId: ERROR_NOT_QUORUM_CAPABLE
//
// MessageText:
//
//  The cluster could not make the specified resource a quorum resource because it is not capable of being a quorum resource.
//
#define ERROR_NOT_QUORUM_CAPABLE         5021L

//
// MessageId: ERROR_CLUSTER_SHUTTING_DOWN
//
// MessageText:
//
//  The cluster software is shutting down.
//
#define ERROR_CLUSTER_SHUTTING_DOWN      5022L

//
// MessageId: ERROR_INVALID_STATE
//
// MessageText:
//
//  The group or resource is not in the correct state to perform the requested operation.
//
#define ERROR_INVALID_STATE              5023L

//
// MessageId: ERROR_RESOURCE_PROPERTIES_STORED
//
// MessageText:
//
//  The properties were stored but not all changes will take effect until the next
//  time the resource is brought online.
//
#define ERROR_RESOURCE_PROPERTIES_STORED 5024L

//
// MessageId: ERROR_NOT_QUORUM_CLASS
//
// MessageText:
//
//  The cluster could not make the specified resource a quorum resource because it does not belong to a shared storage class.
//
#define ERROR_NOT_QUORUM_CLASS           5025L

//
// MessageId: ERROR_CORE_RESOURCE
//
// MessageText:
//
//  The cluster resource could not be deleted since it is a core resource.
//
#define ERROR_CORE_RESOURCE              5026L

//
// MessageId: ERROR_QUORUM_RESOURCE_ONLINE_FAILED
//
// MessageText:
//
//  The quorum resource failed to come online.
//
#define ERROR_QUORUM_RESOURCE_ONLINE_FAILED 5027L

//
// MessageId: ERROR_QUORUMLOG_OPEN_FAILED
//
// MessageText:
//
//  The quorum log could not be created or mounted successfully.
//
#define ERROR_QUORUMLOG_OPEN_FAILED      5028L

//
// MessageId: ERROR_CLUSTERLOG_CORRUPT
//
// MessageText:
//
//  The cluster log is corrupt.
//
#define ERROR_CLUSTERLOG_CORRUPT         5029L

//
// MessageId: ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE
//
// MessageText:
//
//  The record could not be written to the cluster log since it exceeds the maximum size.
//
#define ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE 5030L

//
// MessageId: ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE
//
// MessageText:
//
//  The cluster log exceeds its maximum size.
//
#define ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE 5031L

//
// MessageId: ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND
//
// MessageText:
//
//  No checkpoint record was found in the cluster log.
//
#define ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND 5032L

//
// MessageId: ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE
//
// MessageText:
//
//  The minimum required disk space needed for logging is not available.
//
#define ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE 5033L

////////////////////////////////////
//                                //
//     EFS Error Codes            //
//                                //
////////////////////////////////////
//
// MessageId: ERROR_ENCRYPTION_FAILED
//
// MessageText:
//
//  The specified file could not be encrypted.
//
#define ERROR_ENCRYPTION_FAILED          6000L

//
// MessageId: ERROR_DECRYPTION_FAILED
//
// MessageText:
//
//  The specified file could not be decrypted.
//
#define ERROR_DECRYPTION_FAILED          6001L

//
// MessageId: ERROR_FILE_ENCRYPTED
//
// MessageText:
//
//  The specified file is encrypted and the user does not have the ability to decrypt it.
//
#define ERROR_FILE_ENCRYPTED             6002L

//
// MessageId: ERROR_NO_RECOVERY_POLICY
//
// MessageText:
//
//  There is no encryption recovery policy configured for this system.
//
#define ERROR_NO_RECOVERY_POLICY         6003L

//
// MessageId: ERROR_NO_EFS
//
// MessageText:
//
//  The required encryption driver is not loaded for this system.
//
#define ERROR_NO_EFS                     6004L

//
// MessageId: ERROR_WRONG_EFS
//
// MessageText:
//
//  The file was encrypted with a different encryption driver than is currently loaded.
//
#define ERROR_WRONG_EFS                  6005L

//
// MessageId: ERROR_NO_USER_KEYS
//
// MessageText:
//
//  There are no EFS keys defined for the user.
//
#define ERROR_NO_USER_KEYS               6006L

//
// MessageId: ERROR_FILE_NOT_ENCRYPTED
//
// MessageText:
//
//  The specified file is not encrypted.
//
#define ERROR_FILE_NOT_ENCRYPTED         6007L

//
// MessageId: ERROR_NOT_EXPORT_FORMAT
//
// MessageText:
//
//  The specified file is not in the defined EFS export format.
//
#define ERROR_NOT_EXPORT_FORMAT          6008L

////////////////////////////////////
//                                //
//     OLE Error Codes            //
//                                //
////////////////////////////////////

//
// OLE error definitions and values
//
// The return value of OLE APIs and methods is an HRESULT.
// This is not a handle to anything, but is merely a 32-bit value
// with several fields encoded in the value.  The parts of an
// HRESULT are shown below.
//
// Many of the macros and functions below were orginally defined to
// operate on SCODEs.  SCODEs are no longer used.  The macros are
// still present for compatibility and easy porting of Win16 code.
// Newly written code should use the HRESULT macros and functions.
//

//
//  HRESULTs are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define SUCCEEDED(Status) ((HRESULT)(Status) >= 0)

//
// and the inverse
//

#define FAILED(Status) ((HRESULT)(Status)<0)


//
// Generic test for error on any status value.
//

#define IS_ERROR(Status) ((unsigned long)(Status) >> 31 == SEVERITY_ERROR)

//
// Return the code
//

#define HRESULT_CODE(hr)    ((hr) & 0xFFFF)
#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define HRESULT_FACILITY(hr)  (((hr) >> 16) & 0x1fff)
#define SCODE_FACILITY(sc)    (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define HRESULT_SEVERITY(hr)  (((hr) >> 31) & 0x1)
#define SCODE_SEVERITY(sc)    (((sc) >> 31) & 0x1)

//
// Create an HRESULT value from component pieces
//

#define MAKE_HRESULT(sev,fac,code) \
    ((HRESULT) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )
#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )


//
// Map a WIN32 error value into a HRESULT
// Note: This assumes that WIN32 errors fall in the range -32k to 32k.
//
// Define bits here so macros are guaranteed to work

#define FACILITY_NT_BIT                 0x10000000
#define HRESULT_FROM_WIN32(x)   (x ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000)) : 0 )

//
// Map an NT status value into a HRESULT
//

#define HRESULT_FROM_NT(x)      ((HRESULT) ((x) | FACILITY_NT_BIT))


// ****** OBSOLETE functions

// HRESULT functions
// As noted above, these functions are obsolete and should not be used.


// Extract the SCODE from a HRESULT

#define GetScode(hr) ((SCODE) (hr))

// Convert an SCODE into an HRESULT.

#define ResultFromScode(sc) ((HRESULT) (sc))


// PropagateResult is a noop
#define PropagateResult(hrPrevious, scBase) ((HRESULT) scBase)


// ****** End of OBSOLETE functions.


// ---------------------- HRESULT value definitions -----------------
//
// HRESULT definitions
//

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED

#define NOERROR             0

//
// Error definitions follow
//

//
// Codes 0x4000-0x40ff are reserved for OLE
//
//
// Error codes
//
//
// MessageId: E_UNEXPECTED
//
// MessageText:
//
//  Catastrophic failure
//
#define E_UNEXPECTED                     _HRESULT_TYPEDEF_(0x8000FFFFL)

#if defined(_WIN32) && !defined(_MAC)
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        _HRESULT_TYPEDEF_(0x80004001L)

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    _HRESULT_TYPEDEF_(0x8007000EL)

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     _HRESULT_TYPEDEF_(0x80070057L)

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    _HRESULT_TYPEDEF_(0x80004002L)

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        _HRESULT_TYPEDEF_(0x80004003L)

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         _HRESULT_TYPEDEF_(0x80070006L)

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          _HRESULT_TYPEDEF_(0x80004004L)

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           _HRESULT_TYPEDEF_(0x80004005L)

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   _HRESULT_TYPEDEF_(0x80070005L)

#else
//
// MessageId: E_NOTIMPL
//
// MessageText:
//
//  Not implemented
//
#define E_NOTIMPL                        _HRESULT_TYPEDEF_(0x80000001L)

//
// MessageId: E_OUTOFMEMORY
//
// MessageText:
//
//  Ran out of memory
//
#define E_OUTOFMEMORY                    _HRESULT_TYPEDEF_(0x80000002L)

//
// MessageId: E_INVALIDARG
//
// MessageText:
//
//  One or more arguments are invalid
//
#define E_INVALIDARG                     _HRESULT_TYPEDEF_(0x80000003L)

//
// MessageId: E_NOINTERFACE
//
// MessageText:
//
//  No such interface supported
//
#define E_NOINTERFACE                    _HRESULT_TYPEDEF_(0x80000004L)

//
// MessageId: E_POINTER
//
// MessageText:
//
//  Invalid pointer
//
#define E_POINTER                        _HRESULT_TYPEDEF_(0x80000005L)

//
// MessageId: E_HANDLE
//
// MessageText:
//
//  Invalid handle
//
#define E_HANDLE                         _HRESULT_TYPEDEF_(0x80000006L)

//
// MessageId: E_ABORT
//
// MessageText:
//
//  Operation aborted
//
#define E_ABORT                          _HRESULT_TYPEDEF_(0x80000007L)

//
// MessageId: E_FAIL
//
// MessageText:
//
//  Unspecified error
//
#define E_FAIL                           _HRESULT_TYPEDEF_(0x80000008L)

//
// MessageId: E_ACCESSDENIED
//
// MessageText:
//
//  General access denied error
//
#define E_ACCESSDENIED                   _HRESULT_TYPEDEF_(0x80000009L)

#endif //WIN32
//
// MessageId: E_PENDING
//
// MessageText:
//
//  The data necessary to complete this operation is not yet available.
//
#define E_PENDING                        _HRESULT_TYPEDEF_(0x8000000AL)

//
// MessageId: CO_E_INIT_TLS
//
// MessageText:
//
//  Thread local storage failure
//
#define CO_E_INIT_TLS                    _HRESULT_TYPEDEF_(0x80004006L)

//
// MessageId: CO_E_INIT_SHARED_ALLOCATOR
//
// MessageText:
//
//  Get shared memory allocator failure
//
#define CO_E_INIT_SHARED_ALLOCATOR       _HRESULT_TYPEDEF_(0x80004007L)

//
// MessageId: CO_E_INIT_MEMORY_ALLOCATOR
//
// MessageText:
//
//  Get memory allocator failure
//
#define CO_E_INIT_MEMORY_ALLOCATOR       _HRESULT_TYPEDEF_(0x80004008L)

//
// MessageId: CO_E_INIT_CLASS_CACHE
//
// MessageText:
//
//  Unable to initialize class cache
//
#define CO_E_INIT_CLASS_CACHE            _HRESULT_TYPEDEF_(0x80004009L)

//
// MessageId: CO_E_INIT_RPC_CHANNEL
//
// MessageText:
//
//  Unable to initialize RPC services
//
#define CO_E_INIT_RPC_CHANNEL            _HRESULT_TYPEDEF_(0x8000400AL)

//
// MessageId: CO_E_INIT_TLS_SET_CHANNEL_CONTROL
//
// MessageText:
//
//  Cannot set thread local storage channel control
//
#define CO_E_INIT_TLS_SET_CHANNEL_CONTROL _HRESULT_TYPEDEF_(0x8000400BL)

//
// MessageId: CO_E_INIT_TLS_CHANNEL_CONTROL
//
// MessageText:
//
//  Could not allocate thread local storage channel control
//
#define CO_E_INIT_TLS_CHANNEL_CONTROL    _HRESULT_TYPEDEF_(0x8000400CL)

//
// MessageId: CO_E_INIT_UNACCEPTED_USER_ALLOCATOR
//
// MessageText:
//
//  The user supplied memory allocator is unacceptable
//
#define CO_E_INIT_UNACCEPTED_USER_ALLOCATOR _HRESULT_TYPEDEF_(0x8000400DL)

//
// MessageId: CO_E_INIT_SCM_MUTEX_EXISTS
//
// MessageText:
//
//  The OLE service mutex already exists
//
#define CO_E_INIT_SCM_MUTEX_EXISTS       _HRESULT_TYPEDEF_(0x8000400EL)

//
// MessageId: CO_E_INIT_SCM_FILE_MAPPING_EXISTS
//
// MessageText:
//
//  The OLE service file mapping already exists
//
#define CO_E_INIT_SCM_FILE_MAPPING_EXISTS _HRESULT_TYPEDEF_(0x8000400FL)

//
// MessageId: CO_E_INIT_SCM_MAP_VIEW_OF_FILE
//
// MessageText:
//
//  Unable to map view of file for OLE service
//
#define CO_E_INIT_SCM_MAP_VIEW_OF_FILE   _HRESULT_TYPEDEF_(0x80004010L)

//
// MessageId: CO_E_INIT_SCM_EXEC_FAILURE
//
// MessageText:
//
//  Failure attempting to launch OLE service
//
#define CO_E_INIT_SCM_EXEC_FAILURE       _HRESULT_TYPEDEF_(0x80004011L)

//
// MessageId: CO_E_INIT_ONLY_SINGLE_THREADED
//
// MessageText:
//
//  There was an attempt to call CoInitialize a second time while single threaded
//
#define CO_E_INIT_ONLY_SINGLE_THREADED   _HRESULT_TYPEDEF_(0x80004012L)

//
// MessageId: CO_E_CANT_REMOTE
//
// MessageText:
//
//  A Remote activation was necessary but was not allowed
//
#define CO_E_CANT_REMOTE                 _HRESULT_TYPEDEF_(0x80004013L)

//
// MessageId: CO_E_BAD_SERVER_NAME
//
// MessageText:
//
//  A Remote activation was necessary but the server name provided was invalid
//
#define CO_E_BAD_SERVER_NAME             _HRESULT_TYPEDEF_(0x80004014L)

//
// MessageId: CO_E_WRONG_SERVER_IDENTITY
//
// MessageText:
//
//  The class is configured to run as a security id different from the caller
//
#define CO_E_WRONG_SERVER_IDENTITY       _HRESULT_TYPEDEF_(0x80004015L)

//
// MessageId: CO_E_OLE1DDE_DISABLED
//
// MessageText:
//
//  Use of Ole1 services requiring DDE windows is disabled
//
#define CO_E_OLE1DDE_DISABLED            _HRESULT_TYPEDEF_(0x80004016L)

//
// MessageId: CO_E_RUNAS_SYNTAX
//
// MessageText:
//
//  A RunAs specification must be <domain name>\<user name> or simply <user name>
//
#define CO_E_RUNAS_SYNTAX                _HRESULT_TYPEDEF_(0x80004017L)

//
// MessageId: CO_E_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  The server process could not be started.  The pathname may be incorrect.
//
#define CO_E_CREATEPROCESS_FAILURE       _HRESULT_TYPEDEF_(0x80004018L)

//
// MessageId: CO_E_RUNAS_CREATEPROCESS_FAILURE
//
// MessageText:
//
//  The server process could not be started as the configured identity.  The pathname may be incorrect or unavailable.
//
#define CO_E_RUNAS_CREATEPROCESS_FAILURE _HRESULT_TYPEDEF_(0x80004019L)

//
// MessageId: CO_E_RUNAS_LOGON_FAILURE
//
// MessageText:
//
//  The server process could not be started because the configured identity is incorrect.  Check the username and password.
//
#define CO_E_RUNAS_LOGON_FAILURE         _HRESULT_TYPEDEF_(0x8000401AL)

//
// MessageId: CO_E_LAUNCH_PERMSSION_DENIED
//
// MessageText:
//
//  The client is not allowed to launch this server.
//
#define CO_E_LAUNCH_PERMSSION_DENIED     _HRESULT_TYPEDEF_(0x8000401BL)

//
// MessageId: CO_E_START_SERVICE_FAILURE
//
// MessageText:
//
//  The service providing this server could not be started.
//
#define CO_E_START_SERVICE_FAILURE       _HRESULT_TYPEDEF_(0x8000401CL)

//
// MessageId: CO_E_REMOTE_COMMUNICATION_FAILURE
//
// MessageText:
//
//  This computer was unable to communicate with the computer providing the server.
//
#define CO_E_REMOTE_COMMUNICATION_FAILURE _HRESULT_TYPEDEF_(0x8000401DL)

//
// MessageId: CO_E_SERVER_START_TIMEOUT
//
// MessageText:
//
//  The server did not respond after being launched.
//
#define CO_E_SERVER_START_TIMEOUT        _HRESULT_TYPEDEF_(0x8000401EL)

//
// MessageId: CO_E_CLSREG_INCONSISTENT
//
// MessageText:
//
//  The registration information for this server is inconsistent or incomplete.
//
#define CO_E_CLSREG_INCONSISTENT         _HRESULT_TYPEDEF_(0x8000401FL)

//
// MessageId: CO_E_IIDREG_INCONSISTENT
//
// MessageText:
//
//  The registration information for this interface is inconsistent or incomplete.
//
#define CO_E_IIDREG_INCONSISTENT         _HRESULT_TYPEDEF_(0x80004020L)

//
// MessageId: CO_E_NOT_SUPPORTED
//
// MessageText:
//
//  The operation attempted is not supported.
//
#define CO_E_NOT_SUPPORTED               _HRESULT_TYPEDEF_(0x80004021L)

//
// MessageId: CO_E_RELOAD_DLL
//
// MessageText:
//
//  A dll must be loaded.
//
#define CO_E_RELOAD_DLL                  _HRESULT_TYPEDEF_(0x80004022L)

//
// MessageId: CO_E_MSI_ERROR
//
// MessageText:
//
//  A Microsoft Software Installer error was encountered.
//
#define CO_E_MSI_ERROR                   _HRESULT_TYPEDEF_(0x80004023L)


//
// Success codes
//
#define S_OK                                   ((HRESULT)0x00000000L)
#define S_FALSE                                ((HRESULT)0x00000001L)

// ******************
// FACILITY_ITF
// ******************

//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//


//
// Generic OLE errors that may be returned by many inerfaces
//

#define OLE_E_FIRST ((HRESULT)0x80040000L)
#define OLE_E_LAST  ((HRESULT)0x800400FFL)
#define OLE_S_FIRST ((HRESULT)0x00040000L)
#define OLE_S_LAST  ((HRESULT)0x000400FFL)

//
// Old OLE errors
//
//
// MessageId: OLE_E_OLEVERB
//
// MessageText:
//
//  Invalid OLEVERB structure
//
#define OLE_E_OLEVERB                    _HRESULT_TYPEDEF_(0x80040000L)

//
// MessageId: OLE_E_ADVF
//
// MessageText:
//
//  Invalid advise flags
//
#define OLE_E_ADVF                       _HRESULT_TYPEDEF_(0x80040001L)

//
// MessageId: OLE_E_ENUM_NOMORE
//
// MessageText:
//
//  Can't enumerate any more, because the associated data is missing
//
#define OLE_E_ENUM_NOMORE                _HRESULT_TYPEDEF_(0x80040002L)

//
// MessageId: OLE_E_ADVISENOTSUPPORTED
//
// MessageText:
//
//  This implementation doesn't take advises
//
#define OLE_E_ADVISENOTSUPPORTED         _HRESULT_TYPEDEF_(0x80040003L)

//
// MessageId: OLE_E_NOCONNECTION
//
// MessageText:
//
//  There is no connection for this connection ID
//
#define OLE_E_NOCONNECTION               _HRESULT_TYPEDEF_(0x80040004L)

//
// MessageId: OLE_E_NOTRUNNING
//
// MessageText:
//
//  Need to run the object to perform this operation
//
#define OLE_E_NOTRUNNING                 _HRESULT_TYPEDEF_(0x80040005L)

//
// MessageId: OLE_E_NOCACHE
//
// MessageText:
//
//  There is no cache to operate on
//
#define OLE_E_NOCACHE                    _HRESULT_TYPEDEF_(0x80040006L)

//
// MessageId: OLE_E_BLANK
//
// MessageText:
//
//  Uninitialized object
//
#define OLE_E_BLANK                      _HRESULT_TYPEDEF_(0x80040007L)

//
// MessageId: OLE_E_CLASSDIFF
//
// MessageText:
//
//  Linked object's source class has changed
//
#define OLE_E_CLASSDIFF                  _HRESULT_TYPEDEF_(0x80040008L)

//
// MessageId: OLE_E_CANT_GETMONIKER
//
// MessageText:
//
//  Not able to get the moniker of the object
//
#define OLE_E_CANT_GETMONIKER            _HRESULT_TYPEDEF_(0x80040009L)

//
// MessageId: OLE_E_CANT_BINDTOSOURCE
//
// MessageText:
//
//  Not able to bind to the source
//
#define OLE_E_CANT_BINDTOSOURCE          _HRESULT_TYPEDEF_(0x8004000AL)

//
// MessageId: OLE_E_STATIC
//
// MessageText:
//
//  Object is static; operation not allowed
//
#define OLE_E_STATIC                     _HRESULT_TYPEDEF_(0x8004000BL)

//
// MessageId: OLE_E_PROMPTSAVECANCELLED
//
// MessageText:
//
//  User canceled out of save dialog
//
#define OLE_E_PROMPTSAVECANCELLED        _HRESULT_TYPEDEF_(0x8004000CL)

//
// MessageId: OLE_E_INVALIDRECT
//
// MessageText:
//
//  Invalid rectangle
//
#define OLE_E_INVALIDRECT                _HRESULT_TYPEDEF_(0x8004000DL)

//
// MessageId: OLE_E_WRONGCOMPOBJ
//
// MessageText:
//
//  compobj.dll is too old for the ole2.dll initialized
//
#define OLE_E_WRONGCOMPOBJ               _HRESULT_TYPEDEF_(0x8004000EL)

//
// MessageId: OLE_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define OLE_E_INVALIDHWND                _HRESULT_TYPEDEF_(0x8004000FL)

//
// MessageId: OLE_E_NOT_INPLACEACTIVE
//
// MessageText:
//
//  Object is not in any of the inplace active states
//
#define OLE_E_NOT_INPLACEACTIVE          _HRESULT_TYPEDEF_(0x80040010L)

//
// MessageId: OLE_E_CANTCONVERT
//
// MessageText:
//
//  Not able to convert object
//
#define OLE_E_CANTCONVERT                _HRESULT_TYPEDEF_(0x80040011L)

//
// MessageId: OLE_E_NOSTORAGE
//
// MessageText:
//
//  Not able to perform the operation because object is not given storage yet
//  
//
#define OLE_E_NOSTORAGE                  _HRESULT_TYPEDEF_(0x80040012L)

//
// MessageId: DV_E_FORMATETC
//
// MessageText:
//
//  Invalid FORMATETC structure
//
#define DV_E_FORMATETC                   _HRESULT_TYPEDEF_(0x80040064L)

//
// MessageId: DV_E_DVTARGETDEVICE
//
// MessageText:
//
//  Invalid DVTARGETDEVICE structure
//
#define DV_E_DVTARGETDEVICE              _HRESULT_TYPEDEF_(0x80040065L)

//
// MessageId: DV_E_STGMEDIUM
//
// MessageText:
//
//  Invalid STDGMEDIUM structure
//
#define DV_E_STGMEDIUM                   _HRESULT_TYPEDEF_(0x80040066L)

//
// MessageId: DV_E_STATDATA
//
// MessageText:
//
//  Invalid STATDATA structure
//
#define DV_E_STATDATA                    _HRESULT_TYPEDEF_(0x80040067L)

//
// MessageId: DV_E_LINDEX
//
// MessageText:
//
//  Invalid lindex
//
#define DV_E_LINDEX                      _HRESULT_TYPEDEF_(0x80040068L)

//
// MessageId: DV_E_TYMED
//
// MessageText:
//
//  Invalid tymed
//
#define DV_E_TYMED                       _HRESULT_TYPEDEF_(0x80040069L)

//
// MessageId: DV_E_CLIPFORMAT
//
// MessageText:
//
//  Invalid clipboard format
//
#define DV_E_CLIPFORMAT                  _HRESULT_TYPEDEF_(0x8004006AL)

//
// MessageId: DV_E_DVASPECT
//
// MessageText:
//
//  Invalid aspect(s)
//
#define DV_E_DVASPECT                    _HRESULT_TYPEDEF_(0x8004006BL)

//
// MessageId: DV_E_DVTARGETDEVICE_SIZE
//
// MessageText:
//
//  tdSize parameter of the DVTARGETDEVICE structure is invalid
//
#define DV_E_DVTARGETDEVICE_SIZE         _HRESULT_TYPEDEF_(0x8004006CL)

//
// MessageId: DV_E_NOIVIEWOBJECT
//
// MessageText:
//
//  Object doesn't support IViewObject interface
//
#define DV_E_NOIVIEWOBJECT               _HRESULT_TYPEDEF_(0x8004006DL)

#define DRAGDROP_E_FIRST 0x80040100L
#define DRAGDROP_E_LAST  0x8004010FL
#define DRAGDROP_S_FIRST 0x00040100L
#define DRAGDROP_S_LAST  0x0004010FL
//
// MessageId: DRAGDROP_E_NOTREGISTERED
//
// MessageText:
//
//  Trying to revoke a drop target that has not been registered
//
#define DRAGDROP_E_NOTREGISTERED         _HRESULT_TYPEDEF_(0x80040100L)

//
// MessageId: DRAGDROP_E_ALREADYREGISTERED
//
// MessageText:
//
//  This window has already been registered as a drop target
//
#define DRAGDROP_E_ALREADYREGISTERED     _HRESULT_TYPEDEF_(0x80040101L)

//
// MessageId: DRAGDROP_E_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle
//
#define DRAGDROP_E_INVALIDHWND           _HRESULT_TYPEDEF_(0x80040102L)

#define CLASSFACTORY_E_FIRST  0x80040110L
#define CLASSFACTORY_E_LAST   0x8004011FL
#define CLASSFACTORY_S_FIRST  0x00040110L
#define CLASSFACTORY_S_LAST   0x0004011FL
//
// MessageId: CLASS_E_NOAGGREGATION
//
// MessageText:
//
//  Class does not support aggregation (or class object is remote)
//
#define CLASS_E_NOAGGREGATION            _HRESULT_TYPEDEF_(0x80040110L)

//
// MessageId: CLASS_E_CLASSNOTAVAILABLE
//
// MessageText:
//
//  ClassFactory cannot supply requested class
//
#define CLASS_E_CLASSNOTAVAILABLE        _HRESULT_TYPEDEF_(0x80040111L)

//
// MessageId: CLASS_E_NOTLICENSED
//
// MessageText:
//
//  Class is not licensed for use
//
#define CLASS_E_NOTLICENSED              _HRESULT_TYPEDEF_(0x80040112L)

#define MARSHAL_E_FIRST  0x80040120L
#define MARSHAL_E_LAST   0x8004012FL
#define MARSHAL_S_FIRST  0x00040120L
#define MARSHAL_S_LAST   0x0004012FL
#define DATA_E_FIRST     0x80040130L
#define DATA_E_LAST      0x8004013FL
#define DATA_S_FIRST     0x00040130L
#define DATA_S_LAST      0x0004013FL
#define VIEW_E_FIRST     0x80040140L
#define VIEW_E_LAST      0x8004014FL
#define VIEW_S_FIRST     0x00040140L
#define VIEW_S_LAST      0x0004014FL
//
// MessageId: VIEW_E_DRAW
//
// MessageText:
//
//  Error drawing view
//
#define VIEW_E_DRAW                      _HRESULT_TYPEDEF_(0x80040140L)

#define REGDB_E_FIRST     0x80040150L
#define REGDB_E_LAST      0x8004015FL
#define REGDB_S_FIRST     0x00040150L
#define REGDB_S_LAST      0x0004015FL
//
// MessageId: REGDB_E_READREGDB
//
// MessageText:
//
//  Could not read key from registry
//
#define REGDB_E_READREGDB                _HRESULT_TYPEDEF_(0x80040150L)

//
// MessageId: REGDB_E_WRITEREGDB
//
// MessageText:
//
//  Could not write key to registry
//
#define REGDB_E_WRITEREGDB               _HRESULT_TYPEDEF_(0x80040151L)

//
// MessageId: REGDB_E_KEYMISSING
//
// MessageText:
//
//  Could not find the key in the registry
//
#define REGDB_E_KEYMISSING               _HRESULT_TYPEDEF_(0x80040152L)

//
// MessageId: REGDB_E_INVALIDVALUE
//
// MessageText:
//
//  Invalid value for registry
//
#define REGDB_E_INVALIDVALUE             _HRESULT_TYPEDEF_(0x80040153L)

//
// MessageId: REGDB_E_CLASSNOTREG
//
// MessageText:
//
//  Class not registered
//
#define REGDB_E_CLASSNOTREG              _HRESULT_TYPEDEF_(0x80040154L)

//
// MessageId: REGDB_E_IIDNOTREG
//
// MessageText:
//
//  Interface not registered
//
#define REGDB_E_IIDNOTREG                _HRESULT_TYPEDEF_(0x80040155L)

#define CAT_E_FIRST     0x80040160L
#define CAT_E_LAST      0x80040161L
//
// MessageId: CAT_E_CATIDNOEXIST
//
// MessageText:
//
//  CATID does not exist
//
#define CAT_E_CATIDNOEXIST               _HRESULT_TYPEDEF_(0x80040160L)

//
// MessageId: CAT_E_NODESCRIPTION
//
// MessageText:
//
//  Description not found
//
#define CAT_E_NODESCRIPTION              _HRESULT_TYPEDEF_(0x80040161L)

////////////////////////////////////
//                                //
//     Class Store Error Codes    //
//                                //
////////////////////////////////////
#define CS_E_FIRST     0x80040164L
#define CS_E_LAST      0x80040168L
//
// MessageId: CS_E_PACKAGE_NOTFOUND
//
// MessageText:
//
//  No package in Class Store meets this criteria
//
#define CS_E_PACKAGE_NOTFOUND            _HRESULT_TYPEDEF_(0x80040164L)

//
// MessageId: CS_E_NOT_DELETABLE
//
// MessageText:
//
//  Deleting this will break referential integrity
//
#define CS_E_NOT_DELETABLE               _HRESULT_TYPEDEF_(0x80040165L)

//
// MessageId: CS_E_CLASS_NOTFOUND
//
// MessageText:
//
//  No such CLSID in Class Store
//
#define CS_E_CLASS_NOTFOUND              _HRESULT_TYPEDEF_(0x80040166L)

//
// MessageId: CS_E_INVALID_VERSION
//
// MessageText:
//
//  The Class Store is corrupted or has a version that is no more supported
//
#define CS_E_INVALID_VERSION             _HRESULT_TYPEDEF_(0x80040167L)

//
// MessageId: CS_E_NO_CLASSSTORE
//
// MessageText:
//
//  No such Class Store
//
#define CS_E_NO_CLASSSTORE               _HRESULT_TYPEDEF_(0x80040168L)

#define CACHE_E_FIRST     0x80040170L
#define CACHE_E_LAST      0x8004017FL
#define CACHE_S_FIRST     0x00040170L
#define CACHE_S_LAST      0x0004017FL
//
// MessageId: CACHE_E_NOCACHE_UPDATED
//
// MessageText:
//
//  Cache not updated
//
#define CACHE_E_NOCACHE_UPDATED          _HRESULT_TYPEDEF_(0x80040170L)

#define OLEOBJ_E_FIRST     0x80040180L
#define OLEOBJ_E_LAST      0x8004018FL
#define OLEOBJ_S_FIRST     0x00040180L
#define OLEOBJ_S_LAST      0x0004018FL
//
// MessageId: OLEOBJ_E_NOVERBS
//
// MessageText:
//
//  No verbs for OLE object
//
#define OLEOBJ_E_NOVERBS                 _HRESULT_TYPEDEF_(0x80040180L)

//
// MessageId: OLEOBJ_E_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_E_INVALIDVERB             _HRESULT_TYPEDEF_(0x80040181L)

#define CLIENTSITE_E_FIRST     0x80040190L
#define CLIENTSITE_E_LAST      0x8004019FL
#define CLIENTSITE_S_FIRST     0x00040190L
#define CLIENTSITE_S_LAST      0x0004019FL
//
// MessageId: INPLACE_E_NOTUNDOABLE
//
// MessageText:
//
//  Undo is not available
//
#define INPLACE_E_NOTUNDOABLE            _HRESULT_TYPEDEF_(0x800401A0L)

//
// MessageId: INPLACE_E_NOTOOLSPACE
//
// MessageText:
//
//  Space for tools is not available
//
#define INPLACE_E_NOTOOLSPACE            _HRESULT_TYPEDEF_(0x800401A1L)

#define INPLACE_E_FIRST     0x800401A0L
#define INPLACE_E_LAST      0x800401AFL
#define INPLACE_S_FIRST     0x000401A0L
#define INPLACE_S_LAST      0x000401AFL
#define ENUM_E_FIRST        0x800401B0L
#define ENUM_E_LAST         0x800401BFL
#define ENUM_S_FIRST        0x000401B0L
#define ENUM_S_LAST         0x000401BFL
#define CONVERT10_E_FIRST        0x800401C0L
#define CONVERT10_E_LAST         0x800401CFL
#define CONVERT10_S_FIRST        0x000401C0L
#define CONVERT10_S_LAST         0x000401CFL
//
// MessageId: CONVERT10_E_OLESTREAM_GET
//
// MessageText:
//
//  OLESTREAM Get method failed
//
#define CONVERT10_E_OLESTREAM_GET        _HRESULT_TYPEDEF_(0x800401C0L)

//
// MessageId: CONVERT10_E_OLESTREAM_PUT
//
// MessageText:
//
//  OLESTREAM Put method failed
//
#define CONVERT10_E_OLESTREAM_PUT        _HRESULT_TYPEDEF_(0x800401C1L)

//
// MessageId: CONVERT10_E_OLESTREAM_FMT
//
// MessageText:
//
//  Contents of the OLESTREAM not in correct format
//
#define CONVERT10_E_OLESTREAM_FMT        _HRESULT_TYPEDEF_(0x800401C2L)

//
// MessageId: CONVERT10_E_OLESTREAM_BITMAP_TO_DIB
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the bitmap to a DIB
//
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB _HRESULT_TYPEDEF_(0x800401C3L)

//
// MessageId: CONVERT10_E_STG_FMT
//
// MessageText:
//
//  Contents of the IStorage not in correct format
//
#define CONVERT10_E_STG_FMT              _HRESULT_TYPEDEF_(0x800401C4L)

//
// MessageId: CONVERT10_E_STG_NO_STD_STREAM
//
// MessageText:
//
//  Contents of IStorage is missing one of the standard streams
//
#define CONVERT10_E_STG_NO_STD_STREAM    _HRESULT_TYPEDEF_(0x800401C5L)

//
// MessageId: CONVERT10_E_STG_DIB_TO_BITMAP
//
// MessageText:
//
//  There was an error in a Windows GDI call while converting the DIB to a bitmap.
//  
//
#define CONVERT10_E_STG_DIB_TO_BITMAP    _HRESULT_TYPEDEF_(0x800401C6L)

#define CLIPBRD_E_FIRST        0x800401D0L
#define CLIPBRD_E_LAST         0x800401DFL
#define CLIPBRD_S_FIRST        0x000401D0L
#define CLIPBRD_S_LAST         0x000401DFL
//
// MessageId: CLIPBRD_E_CANT_OPEN
//
// MessageText:
//
//  OpenClipboard Failed
//
#define CLIPBRD_E_CANT_OPEN              _HRESULT_TYPEDEF_(0x800401D0L)

//
// MessageId: CLIPBRD_E_CANT_EMPTY
//
// MessageText:
//
//  EmptyClipboard Failed
//
#define CLIPBRD_E_CANT_EMPTY             _HRESULT_TYPEDEF_(0x800401D1L)

//
// MessageId: CLIPBRD_E_CANT_SET
//
// MessageText:
//
//  SetClipboard Failed
//
#define CLIPBRD_E_CANT_SET               _HRESULT_TYPEDEF_(0x800401D2L)

//
// MessageId: CLIPBRD_E_BAD_DATA
//
// MessageText:
//
//  Data on clipboard is invalid
//
#define CLIPBRD_E_BAD_DATA               _HRESULT_TYPEDEF_(0x800401D3L)

//
// MessageId: CLIPBRD_E_CANT_CLOSE
//
// MessageText:
//
//  CloseClipboard Failed
//
#define CLIPBRD_E_CANT_CLOSE             _HRESULT_TYPEDEF_(0x800401D4L)

#define MK_E_FIRST        0x800401E0L
#define MK_E_LAST         0x800401EFL
#define MK_S_FIRST        0x000401E0L
#define MK_S_LAST         0x000401EFL
//
// MessageId: MK_E_CONNECTMANUALLY
//
// MessageText:
//
//  Moniker needs to be connected manually
//
#define MK_E_CONNECTMANUALLY             _HRESULT_TYPEDEF_(0x800401E0L)

//
// MessageId: MK_E_EXCEEDEDDEADLINE
//
// MessageText:
//
//  Operation exceeded deadline
//
#define MK_E_EXCEEDEDDEADLINE            _HRESULT_TYPEDEF_(0x800401E1L)

//
// MessageId: MK_E_NEEDGENERIC
//
// MessageText:
//
//  Moniker needs to be generic
//
#define MK_E_NEEDGENERIC                 _HRESULT_TYPEDEF_(0x800401E2L)

//
// MessageId: MK_E_UNAVAILABLE
//
// MessageText:
//
//  Operation unavailable
//
#define MK_E_UNAVAILABLE                 _HRESULT_TYPEDEF_(0x800401E3L)

//
// MessageId: MK_E_SYNTAX
//
// MessageText:
//
//  Invalid syntax
//
#define MK_E_SYNTAX                      _HRESULT_TYPEDEF_(0x800401E4L)

//
// MessageId: MK_E_NOOBJECT
//
// MessageText:
//
//  No object for moniker
//
#define MK_E_NOOBJECT                    _HRESULT_TYPEDEF_(0x800401E5L)

//
// MessageId: MK_E_INVALIDEXTENSION
//
// MessageText:
//
//  Bad extension for file
//
#define MK_E_INVALIDEXTENSION            _HRESULT_TYPEDEF_(0x800401E6L)

//
// MessageId: MK_E_INTERMEDIATEINTERFACENOTSUPPORTED
//
// MessageText:
//
//  Intermediate operation failed
//
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED _HRESULT_TYPEDEF_(0x800401E7L)

//
// MessageId: MK_E_NOTBINDABLE
//
// MessageText:
//
//  Moniker is not bindable
//
#define MK_E_NOTBINDABLE                 _HRESULT_TYPEDEF_(0x800401E8L)

//
// MessageId: MK_E_NOTBOUND
//
// MessageText:
//
//  Moniker is not bound
//
#define MK_E_NOTBOUND                    _HRESULT_TYPEDEF_(0x800401E9L)

//
// MessageId: MK_E_CANTOPENFILE
//
// MessageText:
//
//  Moniker cannot open file
//
#define MK_E_CANTOPENFILE                _HRESULT_TYPEDEF_(0x800401EAL)

//
// MessageId: MK_E_MUSTBOTHERUSER
//
// MessageText:
//
//  User input required for operation to succeed
//
#define MK_E_MUSTBOTHERUSER              _HRESULT_TYPEDEF_(0x800401EBL)

//
// MessageId: MK_E_NOINVERSE
//
// MessageText:
//
//  Moniker class has no inverse
//
#define MK_E_NOINVERSE                   _HRESULT_TYPEDEF_(0x800401ECL)

//
// MessageId: MK_E_NOSTORAGE
//
// MessageText:
//
//  Moniker does not refer to storage
//
#define MK_E_NOSTORAGE                   _HRESULT_TYPEDEF_(0x800401EDL)

//
// MessageId: MK_E_NOPREFIX
//
// MessageText:
//
//  No common prefix
//
#define MK_E_NOPREFIX                    _HRESULT_TYPEDEF_(0x800401EEL)

//
// MessageId: MK_E_ENUMERATION_FAILED
//
// MessageText:
//
//  Moniker could not be enumerated
//
#define MK_E_ENUMERATION_FAILED          _HRESULT_TYPEDEF_(0x800401EFL)

#define CO_E_FIRST        0x800401F0L
#define CO_E_LAST         0x800401FFL
#define CO_S_FIRST        0x000401F0L
#define CO_S_LAST         0x000401FFL
//
// MessageId: CO_E_NOTINITIALIZED
//
// MessageText:
//
//  CoInitialize has not been called.
//
#define CO_E_NOTINITIALIZED              _HRESULT_TYPEDEF_(0x800401F0L)

//
// MessageId: CO_E_ALREADYINITIALIZED
//
// MessageText:
//
//  CoInitialize has already been called.
//
#define CO_E_ALREADYINITIALIZED          _HRESULT_TYPEDEF_(0x800401F1L)

//
// MessageId: CO_E_CANTDETERMINECLASS
//
// MessageText:
//
//  Class of object cannot be determined
//
#define CO_E_CANTDETERMINECLASS          _HRESULT_TYPEDEF_(0x800401F2L)

//
// MessageId: CO_E_CLASSSTRING
//
// MessageText:
//
//  Invalid class string
//
#define CO_E_CLASSSTRING                 _HRESULT_TYPEDEF_(0x800401F3L)

//
// MessageId: CO_E_IIDSTRING
//
// MessageText:
//
//  Invalid interface string
//
#define CO_E_IIDSTRING                   _HRESULT_TYPEDEF_(0x800401F4L)

//
// MessageId: CO_E_APPNOTFOUND
//
// MessageText:
//
//  Application not found
//
#define CO_E_APPNOTFOUND                 _HRESULT_TYPEDEF_(0x800401F5L)

//
// MessageId: CO_E_APPSINGLEUSE
//
// MessageText:
//
//  Application cannot be run more than once
//
#define CO_E_APPSINGLEUSE                _HRESULT_TYPEDEF_(0x800401F6L)

//
// MessageId: CO_E_ERRORINAPP
//
// MessageText:
//
//  Some error in application program
//
#define CO_E_ERRORINAPP                  _HRESULT_TYPEDEF_(0x800401F7L)

//
// MessageId: CO_E_DLLNOTFOUND
//
// MessageText:
//
//  DLL for class not found
//
#define CO_E_DLLNOTFOUND                 _HRESULT_TYPEDEF_(0x800401F8L)

//
// MessageId: CO_E_ERRORINDLL
//
// MessageText:
//
//  Error in the DLL
//
#define CO_E_ERRORINDLL                  _HRESULT_TYPEDEF_(0x800401F9L)

//
// MessageId: CO_E_WRONGOSFORAPP
//
// MessageText:
//
//  Wrong OS or OS version for application
//
#define CO_E_WRONGOSFORAPP               _HRESULT_TYPEDEF_(0x800401FAL)

//
// MessageId: CO_E_OBJNOTREG
//
// MessageText:
//
//  Object is not registered
//
#define CO_E_OBJNOTREG                   _HRESULT_TYPEDEF_(0x800401FBL)

//
// MessageId: CO_E_OBJISREG
//
// MessageText:
//
//  Object is already registered
//
#define CO_E_OBJISREG                    _HRESULT_TYPEDEF_(0x800401FCL)

//
// MessageId: CO_E_OBJNOTCONNECTED
//
// MessageText:
//
//  Object is not connected to server
//
#define CO_E_OBJNOTCONNECTED             _HRESULT_TYPEDEF_(0x800401FDL)

//
// MessageId: CO_E_APPDIDNTREG
//
// MessageText:
//
//  Application was launched but it didn't register a class factory
//
#define CO_E_APPDIDNTREG                 _HRESULT_TYPEDEF_(0x800401FEL)

//
// MessageId: CO_E_RELEASED
//
// MessageText:
//
//  Object has been released
//
#define CO_E_RELEASED                    _HRESULT_TYPEDEF_(0x800401FFL)

//
// MessageId: CO_E_FAILEDTOIMPERSONATE
//
// MessageText:
//
//  Unable to impersonate DCOM client
//
#define CO_E_FAILEDTOIMPERSONATE         _HRESULT_TYPEDEF_(0x80040200L)

//
// MessageId: CO_E_FAILEDTOGETSECCTX
//
// MessageText:
//
//  Unable to obtain server's security context
//
#define CO_E_FAILEDTOGETSECCTX           _HRESULT_TYPEDEF_(0x80040201L)

//
// MessageId: CO_E_FAILEDTOOPENTHREADTOKEN
//
// MessageText:
//
//  Unable to open the access token of the current thread
//
#define CO_E_FAILEDTOOPENTHREADTOKEN     _HRESULT_TYPEDEF_(0x80040202L)

//
// MessageId: CO_E_FAILEDTOGETTOKENINFO
//
// MessageText:
//
//  Unable to obtain user info from an access token
//
#define CO_E_FAILEDTOGETTOKENINFO        _HRESULT_TYPEDEF_(0x80040203L)

//
// MessageId: CO_E_TRUSTEEDOESNTMATCHCLIENT
//
// MessageText:
//
//  The client who called IAccessControl::IsAccessPermitted was the trustee provided tot he method
//
#define CO_E_TRUSTEEDOESNTMATCHCLIENT    _HRESULT_TYPEDEF_(0x80040204L)

//
// MessageId: CO_E_FAILEDTOQUERYCLIENTBLANKET
//
// MessageText:
//
//  Unable to obtain the client's security blanket
//
#define CO_E_FAILEDTOQUERYCLIENTBLANKET  _HRESULT_TYPEDEF_(0x80040205L)

//
// MessageId: CO_E_FAILEDTOSETDACL
//
// MessageText:
//
//  Unable to set a discretionary ACL into a security descriptor
//
#define CO_E_FAILEDTOSETDACL             _HRESULT_TYPEDEF_(0x80040206L)

//
// MessageId: CO_E_ACCESSCHECKFAILED
//
// MessageText:
//
//  The system function, AccessCheck, returned false
//
#define CO_E_ACCESSCHECKFAILED           _HRESULT_TYPEDEF_(0x80040207L)

//
// MessageId: CO_E_NETACCESSAPIFAILED
//
// MessageText:
//
//  Either NetAccessDel or NetAccessAdd returned an error code.
//
#define CO_E_NETACCESSAPIFAILED          _HRESULT_TYPEDEF_(0x80040208L)

//
// MessageId: CO_E_WRONGTRUSTEENAMESYNTAX
//
// MessageText:
//
//  One of the trustee strings provided by the user did not conform to the <Domain>\<Name> syntax and it was not the "*" string
//
#define CO_E_WRONGTRUSTEENAMESYNTAX      _HRESULT_TYPEDEF_(0x80040209L)

//
// MessageId: CO_E_INVALIDSID
//
// MessageText:
//
//  One of the security identifiers provided by the user was invalid
//
#define CO_E_INVALIDSID                  _HRESULT_TYPEDEF_(0x8004020AL)

//
// MessageId: CO_E_CONVERSIONFAILED
//
// MessageText:
//
//  Unable to convert a wide character trustee string to a multibyte trustee string
//
#define CO_E_CONVERSIONFAILED            _HRESULT_TYPEDEF_(0x8004020BL)

//
// MessageId: CO_E_NOMATCHINGSIDFOUND
//
// MessageText:
//
//  Unable to find a security identifier that corresponds to a trustee string provided by the user
//
#define CO_E_NOMATCHINGSIDFOUND          _HRESULT_TYPEDEF_(0x8004020CL)

//
// MessageId: CO_E_LOOKUPACCSIDFAILED
//
// MessageText:
//
//  The system function, LookupAccountSID, failed
//
#define CO_E_LOOKUPACCSIDFAILED          _HRESULT_TYPEDEF_(0x8004020DL)

//
// MessageId: CO_E_NOMATCHINGNAMEFOUND
//
// MessageText:
//
//  Unable to find a trustee name that corresponds to a security identifier provided by the user
//
#define CO_E_NOMATCHINGNAMEFOUND         _HRESULT_TYPEDEF_(0x8004020EL)

//
// MessageId: CO_E_LOOKUPACCNAMEFAILED
//
// MessageText:
//
//  The system function, LookupAccountName, failed
//
#define CO_E_LOOKUPACCNAMEFAILED         _HRESULT_TYPEDEF_(0x8004020FL)

//
// MessageId: CO_E_SETSERLHNDLFAILED
//
// MessageText:
//
//  Unable to set or reset a serialization handle
//
#define CO_E_SETSERLHNDLFAILED           _HRESULT_TYPEDEF_(0x80040210L)

//
// MessageId: CO_E_FAILEDTOGETWINDIR
//
// MessageText:
//
//  Unable to obtain the Windows directory
//
#define CO_E_FAILEDTOGETWINDIR           _HRESULT_TYPEDEF_(0x80040211L)

//
// MessageId: CO_E_PATHTOOLONG
//
// MessageText:
//
//  Path too long
//
#define CO_E_PATHTOOLONG                 _HRESULT_TYPEDEF_(0x80040212L)

//
// MessageId: CO_E_FAILEDTOGENUUID
//
// MessageText:
//
//  Unable to generate a uuid.
//
#define CO_E_FAILEDTOGENUUID             _HRESULT_TYPEDEF_(0x80040213L)

//
// MessageId: CO_E_FAILEDTOCREATEFILE
//
// MessageText:
//
//  Unable to create file
//
#define CO_E_FAILEDTOCREATEFILE          _HRESULT_TYPEDEF_(0x80040214L)

//
// MessageId: CO_E_FAILEDTOCLOSEHANDLE
//
// MessageText:
//
//  Unable to close a serialization handle or a file handle.
//
#define CO_E_FAILEDTOCLOSEHANDLE         _HRESULT_TYPEDEF_(0x80040215L)

//
// MessageId: CO_E_EXCEEDSYSACLLIMIT
//
// MessageText:
//
//  The number of ACEs in an ACL exceeds the system limit
//
#define CO_E_EXCEEDSYSACLLIMIT           _HRESULT_TYPEDEF_(0x80040216L)

//
// MessageId: CO_E_ACESINWRONGORDER
//
// MessageText:
//
//  Not all the DENY_ACCESS ACEs are arranged in front of the GRANT_ACCESS ACEs in the stream
//
#define CO_E_ACESINWRONGORDER            _HRESULT_TYPEDEF_(0x80040217L)

//
// MessageId: CO_E_INCOMPATIBLESTREAMVERSION
//
// MessageText:
//
//  The version of ACL format in the stream is not supported by this implementation of IAccessControl
//
#define CO_E_INCOMPATIBLESTREAMVERSION   _HRESULT_TYPEDEF_(0x80040218L)

//
// MessageId: CO_E_FAILEDTOOPENPROCESSTOKEN
//
// MessageText:
//
//  Unable to open the access token of the server process
//
#define CO_E_FAILEDTOOPENPROCESSTOKEN    _HRESULT_TYPEDEF_(0x80040219L)

//
// MessageId: CO_E_DECODEFAILED
//
// MessageText:
//
//  Unable to decode the ACL in the stream provided by the user
//
#define CO_E_DECODEFAILED                _HRESULT_TYPEDEF_(0x8004021AL)

//
// MessageId: CO_E_ACNOTINITIALIZED
//
// MessageText:
//
//  The COM IAccessControl object is not initialized
//
#define CO_E_ACNOTINITIALIZED            _HRESULT_TYPEDEF_(0x8004021BL)

//
// Old OLE Success Codes
//
//
// MessageId: OLE_S_USEREG
//
// MessageText:
//
//  Use the registry database to provide the requested information
//
#define OLE_S_USEREG                     _HRESULT_TYPEDEF_(0x00040000L)

//
// MessageId: OLE_S_STATIC
//
// MessageText:
//
//  Success, but static
//
#define OLE_S_STATIC                     _HRESULT_TYPEDEF_(0x00040001L)

//
// MessageId: OLE_S_MAC_CLIPFORMAT
//
// MessageText:
//
//  Macintosh clipboard format
//
#define OLE_S_MAC_CLIPFORMAT             _HRESULT_TYPEDEF_(0x00040002L)

//
// MessageId: DRAGDROP_S_DROP
//
// MessageText:
//
//  Successful drop took place
//
#define DRAGDROP_S_DROP                  _HRESULT_TYPEDEF_(0x00040100L)

//
// MessageId: DRAGDROP_S_CANCEL
//
// MessageText:
//
//  Drag-drop operation canceled
//
#define DRAGDROP_S_CANCEL                _HRESULT_TYPEDEF_(0x00040101L)

//
// MessageId: DRAGDROP_S_USEDEFAULTCURSORS
//
// MessageText:
//
//  Use the default cursor
//
#define DRAGDROP_S_USEDEFAULTCURSORS     _HRESULT_TYPEDEF_(0x00040102L)

//
// MessageId: DATA_S_SAMEFORMATETC
//
// MessageText:
//
//  Data has same FORMATETC
//
#define DATA_S_SAMEFORMATETC             _HRESULT_TYPEDEF_(0x00040130L)

//
// MessageId: VIEW_S_ALREADY_FROZEN
//
// MessageText:
//
//  View is already frozen
//
#define VIEW_S_ALREADY_FROZEN            _HRESULT_TYPEDEF_(0x00040140L)

//
// MessageId: CACHE_S_FORMATETC_NOTSUPPORTED
//
// MessageText:
//
//  FORMATETC not supported
//
#define CACHE_S_FORMATETC_NOTSUPPORTED   _HRESULT_TYPEDEF_(0x00040170L)

//
// MessageId: CACHE_S_SAMECACHE
//
// MessageText:
//
//  Same cache
//
#define CACHE_S_SAMECACHE                _HRESULT_TYPEDEF_(0x00040171L)

//
// MessageId: CACHE_S_SOMECACHES_NOTUPDATED
//
// MessageText:
//
//  Some cache(s) not updated
//
#define CACHE_S_SOMECACHES_NOTUPDATED    _HRESULT_TYPEDEF_(0x00040172L)

//
// MessageId: OLEOBJ_S_INVALIDVERB
//
// MessageText:
//
//  Invalid verb for OLE object
//
#define OLEOBJ_S_INVALIDVERB             _HRESULT_TYPEDEF_(0x00040180L)

//
// MessageId: OLEOBJ_S_CANNOT_DOVERB_NOW
//
// MessageText:
//
//  Verb number is valid but verb cannot be done now
//
#define OLEOBJ_S_CANNOT_DOVERB_NOW       _HRESULT_TYPEDEF_(0x00040181L)

//
// MessageId: OLEOBJ_S_INVALIDHWND
//
// MessageText:
//
//  Invalid window handle passed
//
#define OLEOBJ_S_INVALIDHWND             _HRESULT_TYPEDEF_(0x00040182L)

//
// MessageId: INPLACE_S_TRUNCATED
//
// MessageText:
//
//  Message is too long; some of it had to be truncated before displaying
//
#define INPLACE_S_TRUNCATED              _HRESULT_TYPEDEF_(0x000401A0L)

//
// MessageId: CONVERT10_S_NO_PRESENTATION
//
// MessageText:
//
//  Unable to convert OLESTREAM to IStorage
//
#define CONVERT10_S_NO_PRESENTATION      _HRESULT_TYPEDEF_(0x000401C0L)

//
// MessageId: MK_S_REDUCED_TO_SELF
//
// MessageText:
//
//  Moniker reduced to itself
//
#define MK_S_REDUCED_TO_SELF             _HRESULT_TYPEDEF_(0x000401E2L)

//
// MessageId: MK_S_ME
//
// MessageText:
//
//  Common prefix is this moniker
//
#define MK_S_ME                          _HRESULT_TYPEDEF_(0x000401E4L)

//
// MessageId: MK_S_HIM
//
// MessageText:
//
//  Common prefix is input moniker
//
#define MK_S_HIM                         _HRESULT_TYPEDEF_(0x000401E5L)

//
// MessageId: MK_S_US
//
// MessageText:
//
//  Common prefix is both monikers
//
#define MK_S_US                          _HRESULT_TYPEDEF_(0x000401E6L)

//
// MessageId: MK_S_MONIKERALREADYREGISTERED
//
// MessageText:
//
//  Moniker is already registered in running object table
//
#define MK_S_MONIKERALREADYREGISTERED    _HRESULT_TYPEDEF_(0x000401E7L)

// ******************
// FACILITY_WINDOWS
// ******************
//
// Codes 0x0-0x01ff are reserved for the OLE group of
// interfaces.
//
//
// MessageId: CO_E_CLASS_CREATE_FAILED
//
// MessageText:
//
//  Attempt to create a class object failed
//
#define CO_E_CLASS_CREATE_FAILED         _HRESULT_TYPEDEF_(0x80080001L)

//
// MessageId: CO_E_SCM_ERROR
//
// MessageText:
//
//  OLE service could not bind object
//
#define CO_E_SCM_ERROR                   _HRESULT_TYPEDEF_(0x80080002L)

//
// MessageId: CO_E_SCM_RPC_FAILURE
//
// MessageText:
//
//  RPC communication failed with OLE service
//
#define CO_E_SCM_RPC_FAILURE             _HRESULT_TYPEDEF_(0x80080003L)

//
// MessageId: CO_E_BAD_PATH
//
// MessageText:
//
//  Bad path to object
//
#define CO_E_BAD_PATH                    _HRESULT_TYPEDEF_(0x80080004L)

//
// MessageId: CO_E_SERVER_EXEC_FAILURE
//
// MessageText:
//
//  Server execution failed
//
#define CO_E_SERVER_EXEC_FAILURE         _HRESULT_TYPEDEF_(0x80080005L)

//
// MessageId: CO_E_OBJSRV_RPC_FAILURE
//
// MessageText:
//
//  OLE service could not communicate with the object server
//
#define CO_E_OBJSRV_RPC_FAILURE          _HRESULT_TYPEDEF_(0x80080006L)

//
// MessageId: MK_E_NO_NORMALIZED
//
// MessageText:
//
//  Moniker path could not be normalized
//
#define MK_E_NO_NORMALIZED               _HRESULT_TYPEDEF_(0x80080007L)

//
// MessageId: CO_E_SERVER_STOPPING
//
// MessageText:
//
//  Object server is stopping when OLE service contacts it
//
#define CO_E_SERVER_STOPPING             _HRESULT_TYPEDEF_(0x80080008L)

//
// MessageId: MEM_E_INVALID_ROOT
//
// MessageText:
//
//  An invalid root block pointer was specified
//
#define MEM_E_INVALID_ROOT               _HRESULT_TYPEDEF_(0x80080009L)

//
// MessageId: MEM_E_INVALID_LINK
//
// MessageText:
//
//  An allocation chain contained an invalid link pointer
//
#define MEM_E_INVALID_LINK               _HRESULT_TYPEDEF_(0x80080010L)

//
// MessageId: MEM_E_INVALID_SIZE
//
// MessageText:
//
//  The requested allocation size was too large
//
#define MEM_E_INVALID_SIZE               _HRESULT_TYPEDEF_(0x80080011L)

//
// MessageId: CO_S_NOTALLINTERFACES
//
// MessageText:
//
//  Not all the requested interfaces were available
//
#define CO_S_NOTALLINTERFACES            _HRESULT_TYPEDEF_(0x00080012L)

// ******************
// FACILITY_DISPATCH
// ******************
//
// MessageId: DISP_E_UNKNOWNINTERFACE
//
// MessageText:
//
//  Unknown interface.
//
#define DISP_E_UNKNOWNINTERFACE          _HRESULT_TYPEDEF_(0x80020001L)

//
// MessageId: DISP_E_MEMBERNOTFOUND
//
// MessageText:
//
//  Member not found.
//
#define DISP_E_MEMBERNOTFOUND            _HRESULT_TYPEDEF_(0x80020003L)

//
// MessageId: DISP_E_PARAMNOTFOUND
//
// MessageText:
//
//  Parameter not found.
//
#define DISP_E_PARAMNOTFOUND             _HRESULT_TYPEDEF_(0x80020004L)

//
// MessageId: DISP_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define DISP_E_TYPEMISMATCH              _HRESULT_TYPEDEF_(0x80020005L)

//
// MessageId: DISP_E_UNKNOWNNAME
//
// MessageText:
//
//  Unknown name.
//
#define DISP_E_UNKNOWNNAME               _HRESULT_TYPEDEF_(0x80020006L)

//
// MessageId: DISP_E_NONAMEDARGS
//
// MessageText:
//
//  No named arguments.
//
#define DISP_E_NONAMEDARGS               _HRESULT_TYPEDEF_(0x80020007L)

//
// MessageId: DISP_E_BADVARTYPE
//
// MessageText:
//
//  Bad variable type.
//
#define DISP_E_BADVARTYPE                _HRESULT_TYPEDEF_(0x80020008L)

//
// MessageId: DISP_E_EXCEPTION
//
// MessageText:
//
//  Exception occurred.
//
#define DISP_E_EXCEPTION                 _HRESULT_TYPEDEF_(0x80020009L)

//
// MessageId: DISP_E_OVERFLOW
//
// MessageText:
//
//  Out of present range.
//
#define DISP_E_OVERFLOW                  _HRESULT_TYPEDEF_(0x8002000AL)

//
// MessageId: DISP_E_BADINDEX
//
// MessageText:
//
//  Invalid index.
//
#define DISP_E_BADINDEX                  _HRESULT_TYPEDEF_(0x8002000BL)

//
// MessageId: DISP_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown language.
//
#define DISP_E_UNKNOWNLCID               _HRESULT_TYPEDEF_(0x8002000CL)

//
// MessageId: DISP_E_ARRAYISLOCKED
//
// MessageText:
//
//  Memory is locked.
//
#define DISP_E_ARRAYISLOCKED             _HRESULT_TYPEDEF_(0x8002000DL)

//
// MessageId: DISP_E_BADPARAMCOUNT
//
// MessageText:
//
//  Invalid number of parameters.
//
#define DISP_E_BADPARAMCOUNT             _HRESULT_TYPEDEF_(0x8002000EL)

//
// MessageId: DISP_E_PARAMNOTOPTIONAL
//
// MessageText:
//
//  Parameter not optional.
//
#define DISP_E_PARAMNOTOPTIONAL          _HRESULT_TYPEDEF_(0x8002000FL)

//
// MessageId: DISP_E_BADCALLEE
//
// MessageText:
//
//  Invalid callee.
//
#define DISP_E_BADCALLEE                 _HRESULT_TYPEDEF_(0x80020010L)

//
// MessageId: DISP_E_NOTACOLLECTION
//
// MessageText:
//
//  Does not support a collection.
//
#define DISP_E_NOTACOLLECTION            _HRESULT_TYPEDEF_(0x80020011L)

//
// MessageId: DISP_E_DIVBYZERO
//
// MessageText:
//
//  Division by zero.
//
#define DISP_E_DIVBYZERO                 _HRESULT_TYPEDEF_(0x80020012L)

//
// MessageId: TYPE_E_BUFFERTOOSMALL
//
// MessageText:
//
//  Buffer too small.
//
#define TYPE_E_BUFFERTOOSMALL            _HRESULT_TYPEDEF_(0x80028016L)

//
// MessageId: TYPE_E_FIELDNOTFOUND
//
// MessageText:
//
//  Field name not defined in the record.
//
#define TYPE_E_FIELDNOTFOUND             _HRESULT_TYPEDEF_(0x80028017L)

//
// MessageId: TYPE_E_INVDATAREAD
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_INVDATAREAD               _HRESULT_TYPEDEF_(0x80028018L)

//
// MessageId: TYPE_E_UNSUPFORMAT
//
// MessageText:
//
//  Old format or invalid type library.
//
#define TYPE_E_UNSUPFORMAT               _HRESULT_TYPEDEF_(0x80028019L)

//
// MessageId: TYPE_E_REGISTRYACCESS
//
// MessageText:
//
//  Error accessing the OLE registry.
//
#define TYPE_E_REGISTRYACCESS            _HRESULT_TYPEDEF_(0x8002801CL)

//
// MessageId: TYPE_E_LIBNOTREGISTERED
//
// MessageText:
//
//  Library not registered.
//
#define TYPE_E_LIBNOTREGISTERED          _HRESULT_TYPEDEF_(0x8002801DL)

//
// MessageId: TYPE_E_UNDEFINEDTYPE
//
// MessageText:
//
//  Bound to unknown type.
//
#define TYPE_E_UNDEFINEDTYPE             _HRESULT_TYPEDEF_(0x80028027L)

//
// MessageId: TYPE_E_QUALIFIEDNAMEDISALLOWED
//
// MessageText:
//
//  Qualified name disallowed.
//
#define TYPE_E_QUALIFIEDNAMEDISALLOWED   _HRESULT_TYPEDEF_(0x80028028L)

//
// MessageId: TYPE_E_INVALIDSTATE
//
// MessageText:
//
//  Invalid forward reference, or reference to uncompiled type.
//
#define TYPE_E_INVALIDSTATE              _HRESULT_TYPEDEF_(0x80028029L)

//
// MessageId: TYPE_E_WRONGTYPEKIND
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_WRONGTYPEKIND             _HRESULT_TYPEDEF_(0x8002802AL)

//
// MessageId: TYPE_E_ELEMENTNOTFOUND
//
// MessageText:
//
//  Element not found.
//
#define TYPE_E_ELEMENTNOTFOUND           _HRESULT_TYPEDEF_(0x8002802BL)

//
// MessageId: TYPE_E_AMBIGUOUSNAME
//
// MessageText:
//
//  Ambiguous name.
//
#define TYPE_E_AMBIGUOUSNAME             _HRESULT_TYPEDEF_(0x8002802CL)

//
// MessageId: TYPE_E_NAMECONFLICT
//
// MessageText:
//
//  Name already exists in the library.
//
#define TYPE_E_NAMECONFLICT              _HRESULT_TYPEDEF_(0x8002802DL)

//
// MessageId: TYPE_E_UNKNOWNLCID
//
// MessageText:
//
//  Unknown LCID.
//
#define TYPE_E_UNKNOWNLCID               _HRESULT_TYPEDEF_(0x8002802EL)

//
// MessageId: TYPE_E_DLLFUNCTIONNOTFOUND
//
// MessageText:
//
//  Function not defined in specified DLL.
//
#define TYPE_E_DLLFUNCTIONNOTFOUND       _HRESULT_TYPEDEF_(0x8002802FL)

//
// MessageId: TYPE_E_BADMODULEKIND
//
// MessageText:
//
//  Wrong module kind for the operation.
//
#define TYPE_E_BADMODULEKIND             _HRESULT_TYPEDEF_(0x800288BDL)

//
// MessageId: TYPE_E_SIZETOOBIG
//
// MessageText:
//
//  Size may not exceed 64K.
//
#define TYPE_E_SIZETOOBIG                _HRESULT_TYPEDEF_(0x800288C5L)

//
// MessageId: TYPE_E_DUPLICATEID
//
// MessageText:
//
//  Duplicate ID in inheritance hierarchy.
//
#define TYPE_E_DUPLICATEID               _HRESULT_TYPEDEF_(0x800288C6L)

//
// MessageId: TYPE_E_INVALIDID
//
// MessageText:
//
//  Incorrect inheritance depth in standard OLE hmember.
//
#define TYPE_E_INVALIDID                 _HRESULT_TYPEDEF_(0x800288CFL)

//
// MessageId: TYPE_E_TYPEMISMATCH
//
// MessageText:
//
//  Type mismatch.
//
#define TYPE_E_TYPEMISMATCH              _HRESULT_TYPEDEF_(0x80028CA0L)

//
// MessageId: TYPE_E_OUTOFBOUNDS
//
// MessageText:
//
//  Invalid number of arguments.
//
#define TYPE_E_OUTOFBOUNDS               _HRESULT_TYPEDEF_(0x80028CA1L)

//
// MessageId: TYPE_E_IOERROR
//
// MessageText:
//
//  I/O Error.
//
#define TYPE_E_IOERROR                   _HRESULT_TYPEDEF_(0x80028CA2L)

//
// MessageId: TYPE_E_CANTCREATETMPFILE
//
// MessageText:
//
//  Error creating unique tmp file.
//
#define TYPE_E_CANTCREATETMPFILE         _HRESULT_TYPEDEF_(0x80028CA3L)

//
// MessageId: TYPE_E_CANTLOADLIBRARY
//
// MessageText:
//
//  Error loading type library/DLL.
//
#define TYPE_E_CANTLOADLIBRARY           _HRESULT_TYPEDEF_(0x80029C4AL)

//
// MessageId: TYPE_E_INCONSISTENTPROPFUNCS
//
// MessageText:
//
//  Inconsistent property functions.
//
#define TYPE_E_INCONSISTENTPROPFUNCS     _HRESULT_TYPEDEF_(0x80029C83L)

//
// MessageId: TYPE_E_CIRCULARTYPE
//
// MessageText:
//
//  Circular dependency between types/modules.
//
#define TYPE_E_CIRCULARTYPE              _HRESULT_TYPEDEF_(0x80029C84L)

// ******************
// FACILITY_STORAGE
// ******************
//
// MessageId: STG_E_INVALIDFUNCTION
//
// MessageText:
//
//  Unable to perform requested operation.
//
#define STG_E_INVALIDFUNCTION            _HRESULT_TYPEDEF_(0x80030001L)

//
// MessageId: STG_E_FILENOTFOUND
//
// MessageText:
//
//  %1 could not be found.
//
#define STG_E_FILENOTFOUND               _HRESULT_TYPEDEF_(0x80030002L)

//
// MessageId: STG_E_PATHNOTFOUND
//
// MessageText:
//
//  The path %1 could not be found.
//
#define STG_E_PATHNOTFOUND               _HRESULT_TYPEDEF_(0x80030003L)

//
// MessageId: STG_E_TOOMANYOPENFILES
//
// MessageText:
//
//  There are insufficient resources to open another file.
//
#define STG_E_TOOMANYOPENFILES           _HRESULT_TYPEDEF_(0x80030004L)

//
// MessageId: STG_E_ACCESSDENIED
//
// MessageText:
//
//  Access Denied.
//
#define STG_E_ACCESSDENIED               _HRESULT_TYPEDEF_(0x80030005L)

//
// MessageId: STG_E_INVALIDHANDLE
//
// MessageText:
//
//  Attempted an operation on an invalid object.
//
#define STG_E_INVALIDHANDLE              _HRESULT_TYPEDEF_(0x80030006L)

//
// MessageId: STG_E_INSUFFICIENTMEMORY
//
// MessageText:
//
//  There is insufficient memory available to complete operation.
//
#define STG_E_INSUFFICIENTMEMORY         _HRESULT_TYPEDEF_(0x80030008L)

//
// MessageId: STG_E_INVALIDPOINTER
//
// MessageText:
//
//  Invalid pointer error.
//
#define STG_E_INVALIDPOINTER             _HRESULT_TYPEDEF_(0x80030009L)

//
// MessageId: STG_E_NOMOREFILES
//
// MessageText:
//
//  There are no more entries to return.
//
#define STG_E_NOMOREFILES                _HRESULT_TYPEDEF_(0x80030012L)

//
// MessageId: STG_E_DISKISWRITEPROTECTED
//
// MessageText:
//
//  Disk is write-protected.
//
#define STG_E_DISKISWRITEPROTECTED       _HRESULT_TYPEDEF_(0x80030013L)

//
// MessageId: STG_E_SEEKERROR
//
// MessageText:
//
//  An error occurred during a seek operation.
//
#define STG_E_SEEKERROR                  _HRESULT_TYPEDEF_(0x80030019L)

//
// MessageId: STG_E_WRITEFAULT
//
// MessageText:
//
//  A disk error occurred during a write operation.
//
#define STG_E_WRITEFAULT                 _HRESULT_TYPEDEF_(0x8003001DL)

//
// MessageId: STG_E_READFAULT
//
// MessageText:
//
//  A disk error occurred during a read operation.
//
#define STG_E_READFAULT                  _HRESULT_TYPEDEF_(0x8003001EL)

//
// MessageId: STG_E_SHAREVIOLATION
//
// MessageText:
//
//  A share violation has occurred.
//
#define STG_E_SHAREVIOLATION             _HRESULT_TYPEDEF_(0x80030020L)

//
// MessageId: STG_E_LOCKVIOLATION
//
// MessageText:
//
//  A lock violation has occurred.
//
#define STG_E_LOCKVIOLATION              _HRESULT_TYPEDEF_(0x80030021L)

//
// MessageId: STG_E_FILEALREADYEXISTS
//
// MessageText:
//
//  %1 already exists.
//
#define STG_E_FILEALREADYEXISTS          _HRESULT_TYPEDEF_(0x80030050L)

//
// MessageId: STG_E_INVALIDPARAMETER
//
// MessageText:
//
//  Invalid parameter error.
//
#define STG_E_INVALIDPARAMETER           _HRESULT_TYPEDEF_(0x80030057L)

//
// MessageId: STG_E_MEDIUMFULL
//
// MessageText:
//
//  There is insufficient disk space to complete operation.
//
#define STG_E_MEDIUMFULL                 _HRESULT_TYPEDEF_(0x80030070L)

//
// MessageId: STG_E_PROPSETMISMATCHED
//
// MessageText:
//
//  Illegal write of non-simple property to simple property set.
//
#define STG_E_PROPSETMISMATCHED          _HRESULT_TYPEDEF_(0x800300F0L)

//
// MessageId: STG_E_ABNORMALAPIEXIT
//
// MessageText:
//
//  An API call exited abnormally.
//
#define STG_E_ABNORMALAPIEXIT            _HRESULT_TYPEDEF_(0x800300FAL)

//
// MessageId: STG_E_INVALIDHEADER
//
// MessageText:
//
//  The file %1 is not a valid compound file.
//
#define STG_E_INVALIDHEADER              _HRESULT_TYPEDEF_(0x800300FBL)

//
// MessageId: STG_E_INVALIDNAME
//
// MessageText:
//
//  The name %1 is not valid.
//
#define STG_E_INVALIDNAME                _HRESULT_TYPEDEF_(0x800300FCL)

//
// MessageId: STG_E_UNKNOWN
//
// MessageText:
//
//  An unexpected error occurred.
//
#define STG_E_UNKNOWN                    _HRESULT_TYPEDEF_(0x800300FDL)

//
// MessageId: STG_E_UNIMPLEMENTEDFUNCTION
//
// MessageText:
//
//  That function is not implemented.
//
#define STG_E_UNIMPLEMENTEDFUNCTION      _HRESULT_TYPEDEF_(0x800300FEL)

//
// MessageId: STG_E_INVALIDFLAG
//
// MessageText:
//
//  Invalid flag error.
//
#define STG_E_INVALIDFLAG                _HRESULT_TYPEDEF_(0x800300FFL)

//
// MessageId: STG_E_INUSE
//
// MessageText:
//
//  Attempted to use an object that is busy.
//
#define STG_E_INUSE                      _HRESULT_TYPEDEF_(0x80030100L)

//
// MessageId: STG_E_NOTCURRENT
//
// MessageText:
//
//  The storage has been changed since the last commit.
//
#define STG_E_NOTCURRENT                 _HRESULT_TYPEDEF_(0x80030101L)

//
// MessageId: STG_E_REVERTED
//
// MessageText:
//
//  Attempted to use an object that has ceased to exist.
//
#define STG_E_REVERTED                   _HRESULT_TYPEDEF_(0x80030102L)

//
// MessageId: STG_E_CANTSAVE
//
// MessageText:
//
//  Can't save.
//
#define STG_E_CANTSAVE                   _HRESULT_TYPEDEF_(0x80030103L)

//
// MessageId: STG_E_OLDFORMAT
//
// MessageText:
//
//  The compound file %1 was produced with an incompatible version of storage.
//
#define STG_E_OLDFORMAT                  _HRESULT_TYPEDEF_(0x80030104L)

//
// MessageId: STG_E_OLDDLL
//
// MessageText:
//
//  The compound file %1 was produced with a newer version of storage.
//
#define STG_E_OLDDLL                     _HRESULT_TYPEDEF_(0x80030105L)

//
// MessageId: STG_E_SHAREREQUIRED
//
// MessageText:
//
//  Share.exe or equivalent is required for operation.
//
#define STG_E_SHAREREQUIRED              _HRESULT_TYPEDEF_(0x80030106L)

//
// MessageId: STG_E_NOTFILEBASEDSTORAGE
//
// MessageText:
//
//  Illegal operation called on non-file based storage.
//
#define STG_E_NOTFILEBASEDSTORAGE        _HRESULT_TYPEDEF_(0x80030107L)

//
// MessageId: STG_E_EXTANTMARSHALLINGS
//
// MessageText:
//
//  Illegal operation called on object with extant marshallings.
//
#define STG_E_EXTANTMARSHALLINGS         _HRESULT_TYPEDEF_(0x80030108L)

//
// MessageId: STG_E_DOCFILECORRUPT
//
// MessageText:
//
//  The docfile has been corrupted.
//
#define STG_E_DOCFILECORRUPT             _HRESULT_TYPEDEF_(0x80030109L)

//
// MessageId: STG_E_BADBASEADDRESS
//
// MessageText:
//
//  OLE32.DLL has been loaded at the wrong address.
//
#define STG_E_BADBASEADDRESS             _HRESULT_TYPEDEF_(0x80030110L)

//
// MessageId: STG_E_INCOMPLETE
//
// MessageText:
//
//  The file download was aborted abnormally.  The file is incomplete.
//
#define STG_E_INCOMPLETE                 _HRESULT_TYPEDEF_(0x80030201L)

//
// MessageId: STG_E_TERMINATED
//
// MessageText:
//
//  The file download has been terminated.
//
#define STG_E_TERMINATED                 _HRESULT_TYPEDEF_(0x80030202L)

//
// MessageId: STG_S_CONVERTED
//
// MessageText:
//
//  The underlying file was converted to compound file format.
//
#define STG_S_CONVERTED                  _HRESULT_TYPEDEF_(0x00030200L)

//
// MessageId: STG_S_BLOCK
//
// MessageText:
//
//  The storage operation should block until more data is available.
//
#define STG_S_BLOCK                      _HRESULT_TYPEDEF_(0x00030201L)

//
// MessageId: STG_S_RETRYNOW
//
// MessageText:
//
//  The storage operation should retry immediately.
//
#define STG_S_RETRYNOW                   _HRESULT_TYPEDEF_(0x00030202L)

//
// MessageId: STG_S_MONITORING
//
// MessageText:
//
//  The notified event sink will not influence the storage operation.
//
#define STG_S_MONITORING                 _HRESULT_TYPEDEF_(0x00030203L)

//
// MessageId: STG_S_MULTIPLEOPENS
//
// MessageText:
//
//  Multiple opens prevent consolidated. (commit succeeded).
//
#define STG_S_MULTIPLEOPENS              _HRESULT_TYPEDEF_(0x00030204L)

//
// MessageId: STG_S_CONSOLIDATIONFAILED
//
// MessageText:
//
//  Consolidation of the storage file failed. (commit succeeded).
//
#define STG_S_CONSOLIDATIONFAILED        _HRESULT_TYPEDEF_(0x00030205L)

//
// MessageId: STG_S_CANNOTCONSOLIDATE
//
// MessageText:
//
//  Consolidation of the storage file is inappropriate. (commit succeeded).
//
#define STG_S_CANNOTCONSOLIDATE          _HRESULT_TYPEDEF_(0x00030206L)

// ******************
// FACILITY_RPC
// ******************
//
// Codes 0x0-0x11 are propagated from 16 bit OLE.
//
//
// MessageId: RPC_E_CALL_REJECTED
//
// MessageText:
//
//  Call was rejected by callee.
//
#define RPC_E_CALL_REJECTED              _HRESULT_TYPEDEF_(0x80010001L)

//
// MessageId: RPC_E_CALL_CANCELED
//
// MessageText:
//
//  Call was canceled by the message filter.
//
#define RPC_E_CALL_CANCELED              _HRESULT_TYPEDEF_(0x80010002L)

//
// MessageId: RPC_E_CANTPOST_INSENDCALL
//
// MessageText:
//
//  The caller is dispatching an intertask SendMessage call and
//  cannot call out via PostMessage.
//
#define RPC_E_CANTPOST_INSENDCALL        _HRESULT_TYPEDEF_(0x80010003L)

//
// MessageId: RPC_E_CANTCALLOUT_INASYNCCALL
//
// MessageText:
//
//  The caller is dispatching an asynchronous call and cannot
//  make an outgoing call on behalf of this call.
//
#define RPC_E_CANTCALLOUT_INASYNCCALL    _HRESULT_TYPEDEF_(0x80010004L)

//
// MessageId: RPC_E_CANTCALLOUT_INEXTERNALCALL
//
// MessageText:
//
//  It is illegal to call out while inside message filter.
//
#define RPC_E_CANTCALLOUT_INEXTERNALCALL _HRESULT_TYPEDEF_(0x80010005L)

//
// MessageId: RPC_E_CONNECTION_TERMINATED
//
// MessageText:
//
//  The connection terminated or is in a bogus state
//  and cannot be used any more. Other connections
//  are still valid.
//
#define RPC_E_CONNECTION_TERMINATED      _HRESULT_TYPEDEF_(0x80010006L)

//
// MessageId: RPC_E_SERVER_DIED
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call may
//  have executed.
//
#define RPC_E_SERVER_DIED                _HRESULT_TYPEDEF_(0x80010007L)

//
// MessageId: RPC_E_CLIENT_DIED
//
// MessageText:
//
//  The caller (client) disappeared while the callee (server) was
//  processing a call.
//
#define RPC_E_CLIENT_DIED                _HRESULT_TYPEDEF_(0x80010008L)

//
// MessageId: RPC_E_INVALID_DATAPACKET
//
// MessageText:
//
//  The data packet with the marshalled parameter data is incorrect.
//
#define RPC_E_INVALID_DATAPACKET         _HRESULT_TYPEDEF_(0x80010009L)

//
// MessageId: RPC_E_CANTTRANSMIT_CALL
//
// MessageText:
//
//  The call was not transmitted properly; the message queue
//  was full and was not emptied after yielding.
//
#define RPC_E_CANTTRANSMIT_CALL          _HRESULT_TYPEDEF_(0x8001000AL)

//
// MessageId: RPC_E_CLIENT_CANTMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot marshall the parameter data - low memory, etc.
//
#define RPC_E_CLIENT_CANTMARSHAL_DATA    _HRESULT_TYPEDEF_(0x8001000BL)

//
// MessageId: RPC_E_CLIENT_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The client (caller) cannot unmarshall the return data - low memory, etc.
//
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA  _HRESULT_TYPEDEF_(0x8001000CL)

//
// MessageId: RPC_E_SERVER_CANTMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot marshall the return data - low memory, etc.
//
#define RPC_E_SERVER_CANTMARSHAL_DATA    _HRESULT_TYPEDEF_(0x8001000DL)

//
// MessageId: RPC_E_SERVER_CANTUNMARSHAL_DATA
//
// MessageText:
//
//  The server (callee) cannot unmarshall the parameter data - low memory, etc.
//
#define RPC_E_SERVER_CANTUNMARSHAL_DATA  _HRESULT_TYPEDEF_(0x8001000EL)

//
// MessageId: RPC_E_INVALID_DATA
//
// MessageText:
//
//  Received data is invalid; could be server or client data.
//
#define RPC_E_INVALID_DATA               _HRESULT_TYPEDEF_(0x8001000FL)

//
// MessageId: RPC_E_INVALID_PARAMETER
//
// MessageText:
//
//  A particular parameter is invalid and cannot be (un)marshalled.
//
#define RPC_E_INVALID_PARAMETER          _HRESULT_TYPEDEF_(0x80010010L)

//
// MessageId: RPC_E_CANTCALLOUT_AGAIN
//
// MessageText:
//
//  There is no second outgoing call on same channel in DDE conversation.
//
#define RPC_E_CANTCALLOUT_AGAIN          _HRESULT_TYPEDEF_(0x80010011L)

//
// MessageId: RPC_E_SERVER_DIED_DNE
//
// MessageText:
//
//  The callee (server [not server application]) is not available
//  and disappeared; all connections are invalid.  The call did not execute.
//
#define RPC_E_SERVER_DIED_DNE            _HRESULT_TYPEDEF_(0x80010012L)

//
// MessageId: RPC_E_SYS_CALL_FAILED
//
// MessageText:
//
//  System call failed.
//
#define RPC_E_SYS_CALL_FAILED            _HRESULT_TYPEDEF_(0x80010100L)

//
// MessageId: RPC_E_OUT_OF_RESOURCES
//
// MessageText:
//
//  Could not allocate some required resource (memory, events, ...)
//
#define RPC_E_OUT_OF_RESOURCES           _HRESULT_TYPEDEF_(0x80010101L)

//
// MessageId: RPC_E_ATTEMPTED_MULTITHREAD
//
// MessageText:
//
//  Attempted to make calls on more than one thread in single threaded mode.
//
#define RPC_E_ATTEMPTED_MULTITHREAD      _HRESULT_TYPEDEF_(0x80010102L)

//
// MessageId: RPC_E_NOT_REGISTERED
//
// MessageText:
//
//  The requested interface is not registered on the server object.
//
#define RPC_E_NOT_REGISTERED             _HRESULT_TYPEDEF_(0x80010103L)

//
// MessageId: RPC_E_FAULT
//
// MessageText:
//
//  RPC could not call the server or could not return the results of calling the server.
//
#define RPC_E_FAULT                      _HRESULT_TYPEDEF_(0x80010104L)

//
// MessageId: RPC_E_SERVERFAULT
//
// MessageText:
//
//  The server threw an exception.
//
#define RPC_E_SERVERFAULT                _HRESULT_TYPEDEF_(0x80010105L)

//
// MessageId: RPC_E_CHANGED_MODE
//
// MessageText:
//
//  Cannot change thread mode after it is set.
//
#define RPC_E_CHANGED_MODE               _HRESULT_TYPEDEF_(0x80010106L)

//
// MessageId: RPC_E_INVALIDMETHOD
//
// MessageText:
//
//  The method called does not exist on the server.
//
#define RPC_E_INVALIDMETHOD              _HRESULT_TYPEDEF_(0x80010107L)

//
// MessageId: RPC_E_DISCONNECTED
//
// MessageText:
//
//  The object invoked has disconnected from its clients.
//
#define RPC_E_DISCONNECTED               _HRESULT_TYPEDEF_(0x80010108L)

//
// MessageId: RPC_E_RETRY
//
// MessageText:
//
//  The object invoked chose not to process the call now.  Try again later.
//
#define RPC_E_RETRY                      _HRESULT_TYPEDEF_(0x80010109L)

//
// MessageId: RPC_E_SERVERCALL_RETRYLATER
//
// MessageText:
//
//  The message filter indicated that the application is busy.
//
#define RPC_E_SERVERCALL_RETRYLATER      _HRESULT_TYPEDEF_(0x8001010AL)

//
// MessageId: RPC_E_SERVERCALL_REJECTED
//
// MessageText:
//
//  The message filter rejected the call.
//
#define RPC_E_SERVERCALL_REJECTED        _HRESULT_TYPEDEF_(0x8001010BL)

//
// MessageId: RPC_E_INVALID_CALLDATA
//
// MessageText:
//
//  A call control interfaces was called with invalid data.
//
#define RPC_E_INVALID_CALLDATA           _HRESULT_TYPEDEF_(0x8001010CL)

//
// MessageId: RPC_E_CANTCALLOUT_ININPUTSYNCCALL
//
// MessageText:
//
//  An outgoing call cannot be made since the application is dispatching an input-synchronous call.
//
#define RPC_E_CANTCALLOUT_ININPUTSYNCCALL _HRESULT_TYPEDEF_(0x8001010DL)

//
// MessageId: RPC_E_WRONG_THREAD
//
// MessageText:
//
//  The application called an interface that was marshalled for a different thread.
//
#define RPC_E_WRONG_THREAD               _HRESULT_TYPEDEF_(0x8001010EL)

//
// MessageId: RPC_E_THREAD_NOT_INIT
//
// MessageText:
//
//  CoInitialize has not been called on the current thread.
//
#define RPC_E_THREAD_NOT_INIT            _HRESULT_TYPEDEF_(0x8001010FL)

//
// MessageId: RPC_E_VERSION_MISMATCH
//
// MessageText:
//
//  The version of OLE on the client and server machines does not match.
//
#define RPC_E_VERSION_MISMATCH           _HRESULT_TYPEDEF_(0x80010110L)

//
// MessageId: RPC_E_INVALID_HEADER
//
// MessageText:
//
//  OLE received a packet with an invalid header.
//
#define RPC_E_INVALID_HEADER             _HRESULT_TYPEDEF_(0x80010111L)

//
// MessageId: RPC_E_INVALID_EXTENSION
//
// MessageText:
//
//  OLE received a packet with an invalid extension.
//
#define RPC_E_INVALID_EXTENSION          _HRESULT_TYPEDEF_(0x80010112L)

//
// MessageId: RPC_E_INVALID_IPID
//
// MessageText:
//
//  The requested object or interface does not exist.
//
#define RPC_E_INVALID_IPID               _HRESULT_TYPEDEF_(0x80010113L)

//
// MessageId: RPC_E_INVALID_OBJECT
//
// MessageText:
//
//  The requested object does not exist.
//
#define RPC_E_INVALID_OBJECT             _HRESULT_TYPEDEF_(0x80010114L)

//
// MessageId: RPC_S_CALLPENDING
//
// MessageText:
//
//  OLE has sent a request and is waiting for a reply.
//
#define RPC_S_CALLPENDING                _HRESULT_TYPEDEF_(0x80010115L)

//
// MessageId: RPC_S_WAITONTIMER
//
// MessageText:
//
//  OLE is waiting before retrying a request.
//
#define RPC_S_WAITONTIMER                _HRESULT_TYPEDEF_(0x80010116L)

//
// MessageId: RPC_E_CALL_COMPLETE
//
// MessageText:
//
//  Call context cannot be accessed after call completed.
//
#define RPC_E_CALL_COMPLETE              _HRESULT_TYPEDEF_(0x80010117L)

//
// MessageId: RPC_E_UNSECURE_CALL
//
// MessageText:
//
//  Impersonate on unsecure calls is not supported.
//
#define RPC_E_UNSECURE_CALL              _HRESULT_TYPEDEF_(0x80010118L)

//
// MessageId: RPC_E_TOO_LATE
//
// MessageText:
//
//  Security must be initialized before any interfaces are marshalled or
//  unmarshalled.  It cannot be changed once initialized.
//
#define RPC_E_TOO_LATE                   _HRESULT_TYPEDEF_(0x80010119L)

//
// MessageId: RPC_E_NO_GOOD_SECURITY_PACKAGES
//
// MessageText:
//
//  No security packages are installed on this machine or the user is not logged
//  on or there are no compatible security packages between the client and server.
//
#define RPC_E_NO_GOOD_SECURITY_PACKAGES  _HRESULT_TYPEDEF_(0x8001011AL)

//
// MessageId: RPC_E_ACCESS_DENIED
//
// MessageText:
//
//  Access is denied.
//
#define RPC_E_ACCESS_DENIED              _HRESULT_TYPEDEF_(0x8001011BL)

//
// MessageId: RPC_E_REMOTE_DISABLED
//
// MessageText:
//
//  Remote calls are not allowed for this process.
//
#define RPC_E_REMOTE_DISABLED            _HRESULT_TYPEDEF_(0x8001011CL)

//
// MessageId: RPC_E_INVALID_OBJREF
//
// MessageText:
//
//  The marshaled interface data packet (OBJREF) has an invalid or unknown format.
//
#define RPC_E_INVALID_OBJREF             _HRESULT_TYPEDEF_(0x8001011DL)

//
// MessageId: RPC_E_NO_CONTEXT
//
// MessageText:
//
//  No context is associated with this call.  This happens for some custom
//  marshalled calls and on the client side of the call.
//
#define RPC_E_NO_CONTEXT                 _HRESULT_TYPEDEF_(0x8001011EL)

//
// MessageId: RPC_E_TIMEOUT
//
// MessageText:
//
//  This operation returned because the timeout period expired.
//
#define RPC_E_TIMEOUT                    _HRESULT_TYPEDEF_(0x8001011FL)

//
// MessageId: RPC_E_NO_SYNC
//
// MessageText:
//
//  There are no synchronize objects to wait on.
//
#define RPC_E_NO_SYNC                    _HRESULT_TYPEDEF_(0x80010120L)

//
// MessageId: RPC_E_UNEXPECTED
//
// MessageText:
//
//  An internal error occurred.
//
#define RPC_E_UNEXPECTED                 _HRESULT_TYPEDEF_(0x8001FFFFL)


 /////////////////
 //
 //  FACILITY_SSPI
 //
 /////////////////

//
// MessageId: NTE_BAD_UID
//
// MessageText:
//
//  Bad UID.
//
#define NTE_BAD_UID                      _HRESULT_TYPEDEF_(0x80090001L)

//
// MessageId: NTE_BAD_HASH
//
// MessageText:
//
//  Bad Hash.
//
#define NTE_BAD_HASH                     _HRESULT_TYPEDEF_(0x80090002L)

//
// MessageId: NTE_BAD_KEY
//
// MessageText:
//
//  Bad Key.
//
#define NTE_BAD_KEY                      _HRESULT_TYPEDEF_(0x80090003L)

//
// MessageId: NTE_BAD_LEN
//
// MessageText:
//
//  Bad Length.
//
#define NTE_BAD_LEN                      _HRESULT_TYPEDEF_(0x80090004L)

//
// MessageId: NTE_BAD_DATA
//
// MessageText:
//
//  Bad Data.
//
#define NTE_BAD_DATA                     _HRESULT_TYPEDEF_(0x80090005L)

//
// MessageId: NTE_BAD_SIGNATURE
//
// MessageText:
//
//  Invalid Signature.
//
#define NTE_BAD_SIGNATURE                _HRESULT_TYPEDEF_(0x80090006L)

//
// MessageId: NTE_BAD_VER
//
// MessageText:
//
//  Bad Version of provider.
//
#define NTE_BAD_VER                      _HRESULT_TYPEDEF_(0x80090007L)

//
// MessageId: NTE_BAD_ALGID
//
// MessageText:
//
//  Invalid algorithm specified.
//
#define NTE_BAD_ALGID                    _HRESULT_TYPEDEF_(0x80090008L)

//
// MessageId: NTE_BAD_FLAGS
//
// MessageText:
//
//  Invalid flags specified.
//
#define NTE_BAD_FLAGS                    _HRESULT_TYPEDEF_(0x80090009L)

//
// MessageId: NTE_BAD_TYPE
//
// MessageText:
//
//  Invalid type specified.
//
#define NTE_BAD_TYPE                     _HRESULT_TYPEDEF_(0x8009000AL)

//
// MessageId: NTE_BAD_KEY_STATE
//
// MessageText:
//
//  Key not valid for use in specified state.
//
#define NTE_BAD_KEY_STATE                _HRESULT_TYPEDEF_(0x8009000BL)

//
// MessageId: NTE_BAD_HASH_STATE
//
// MessageText:
//
//  Hash not valid for use in specified state.
//
#define NTE_BAD_HASH_STATE               _HRESULT_TYPEDEF_(0x8009000CL)

//
// MessageId: NTE_NO_KEY
//
// MessageText:
//
//  Key does not exist.
//
#define NTE_NO_KEY                       _HRESULT_TYPEDEF_(0x8009000DL)

//
// MessageId: NTE_NO_MEMORY
//
// MessageText:
//
//  Insufficient memory available for the operation.
//
#define NTE_NO_MEMORY                    _HRESULT_TYPEDEF_(0x8009000EL)

//
// MessageId: NTE_EXISTS
//
// MessageText:
//
//  Object already exists.
//
#define NTE_EXISTS                       _HRESULT_TYPEDEF_(0x8009000FL)

//
// MessageId: NTE_PERM
//
// MessageText:
//
//  Access denied.
//
#define NTE_PERM                         _HRESULT_TYPEDEF_(0x80090010L)

//
// MessageId: NTE_NOT_FOUND
//
// MessageText:
//
//  Object was not found.
//
#define NTE_NOT_FOUND                    _HRESULT_TYPEDEF_(0x80090011L)

//
// MessageId: NTE_DOUBLE_ENCRYPT
//
// MessageText:
//
//  Data already encrypted.
//
#define NTE_DOUBLE_ENCRYPT               _HRESULT_TYPEDEF_(0x80090012L)

//
// MessageId: NTE_BAD_PROVIDER
//
// MessageText:
//
//  Invalid provider specified.
//
#define NTE_BAD_PROVIDER                 _HRESULT_TYPEDEF_(0x80090013L)

//
// MessageId: NTE_BAD_PROV_TYPE
//
// MessageText:
//
//  Invalid provider type specified.
//
#define NTE_BAD_PROV_TYPE                _HRESULT_TYPEDEF_(0x80090014L)

//
// MessageId: NTE_BAD_PUBLIC_KEY
//
// MessageText:
//
//  Provider's public key is invalid.
//
#define NTE_BAD_PUBLIC_KEY               _HRESULT_TYPEDEF_(0x80090015L)

//
// MessageId: NTE_BAD_KEYSET
//
// MessageText:
//
//  Keyset does not exist
//
#define NTE_BAD_KEYSET                   _HRESULT_TYPEDEF_(0x80090016L)

//
// MessageId: NTE_PROV_TYPE_NOT_DEF
//
// MessageText:
//
//  Provider type not defined.
//
#define NTE_PROV_TYPE_NOT_DEF            _HRESULT_TYPEDEF_(0x80090017L)

//
// MessageId: NTE_PROV_TYPE_ENTRY_BAD
//
// MessageText:
//
//  Provider type as registered is invalid.
//
#define NTE_PROV_TYPE_ENTRY_BAD          _HRESULT_TYPEDEF_(0x80090018L)

//
// MessageId: NTE_KEYSET_NOT_DEF
//
// MessageText:
//
//  The keyset is not defined.
//
#define NTE_KEYSET_NOT_DEF               _HRESULT_TYPEDEF_(0x80090019L)

//
// MessageId: NTE_KEYSET_ENTRY_BAD
//
// MessageText:
//
//  Keyset as registered is invalid.
//
#define NTE_KEYSET_ENTRY_BAD             _HRESULT_TYPEDEF_(0x8009001AL)

//
// MessageId: NTE_PROV_TYPE_NO_MATCH
//
// MessageText:
//
//  Provider type does not match registered value.
//
#define NTE_PROV_TYPE_NO_MATCH           _HRESULT_TYPEDEF_(0x8009001BL)

//
// MessageId: NTE_SIGNATURE_FILE_BAD
//
// MessageText:
//
//  The digital signature file is corrupt.
//
#define NTE_SIGNATURE_FILE_BAD           _HRESULT_TYPEDEF_(0x8009001CL)

//
// MessageId: NTE_PROVIDER_DLL_FAIL
//
// MessageText:
//
//  Provider DLL failed to initialize correctly.
//
#define NTE_PROVIDER_DLL_FAIL            _HRESULT_TYPEDEF_(0x8009001DL)

//
// MessageId: NTE_PROV_DLL_NOT_FOUND
//
// MessageText:
//
//  Provider DLL could not be found.
//
#define NTE_PROV_DLL_NOT_FOUND           _HRESULT_TYPEDEF_(0x8009001EL)

//
// MessageId: NTE_BAD_KEYSET_PARAM
//
// MessageText:
//
//  The Keyset parameter is invalid.
//
#define NTE_BAD_KEYSET_PARAM             _HRESULT_TYPEDEF_(0x8009001FL)

//
// MessageId: NTE_FAIL
//
// MessageText:
//
//  An internal error occurred.
//
#define NTE_FAIL                         _HRESULT_TYPEDEF_(0x80090020L)

//
// MessageId: NTE_SYS_ERR
//
// MessageText:
//
//  A base error occurred.
//
#define NTE_SYS_ERR                      _HRESULT_TYPEDEF_(0x80090021L)

//
// MessageId: CRYPT_E_MSG_ERROR
//
// MessageText:
//
//  An error was encountered doing a cryptographic message operation.
//
#define CRYPT_E_MSG_ERROR                _HRESULT_TYPEDEF_(0x80091001L)

//
// MessageId: CRYPT_E_UNKNOWN_ALGO
//
// MessageText:
//
//  The cryptographic algorithm is unknown.
//
#define CRYPT_E_UNKNOWN_ALGO             _HRESULT_TYPEDEF_(0x80091002L)

//
// MessageId: CRYPT_E_OID_FORMAT
//
// MessageText:
//
//  The object identifier is badly formatted.
//
#define CRYPT_E_OID_FORMAT               _HRESULT_TYPEDEF_(0x80091003L)

//
// MessageId: CRYPT_E_INVALID_MSG_TYPE
//
// MessageText:
//
//  The message type is invalid.
//
#define CRYPT_E_INVALID_MSG_TYPE         _HRESULT_TYPEDEF_(0x80091004L)

//
// MessageId: CRYPT_E_UNEXPECTED_ENCODING
//
// MessageText:
//
//  The message is not encoded as expected.
//
#define CRYPT_E_UNEXPECTED_ENCODING      _HRESULT_TYPEDEF_(0x80091005L)

//
// MessageId: CRYPT_E_AUTH_ATTR_MISSING
//
// MessageText:
//
//  The message does not contain an expected authenticated attribute.
//
#define CRYPT_E_AUTH_ATTR_MISSING        _HRESULT_TYPEDEF_(0x80091006L)

//
// MessageId: CRYPT_E_HASH_VALUE
//
// MessageText:
//
//  The hash value is not correct.
//
#define CRYPT_E_HASH_VALUE               _HRESULT_TYPEDEF_(0x80091007L)

//
// MessageId: CRYPT_E_INVALID_INDEX
//
// MessageText:
//
//  The index value is not valid.
//
#define CRYPT_E_INVALID_INDEX            _HRESULT_TYPEDEF_(0x80091008L)

//
// MessageId: CRYPT_E_ALREADY_DECRYPTED
//
// MessageText:
//
//  The message content has already been decrypted.
//
#define CRYPT_E_ALREADY_DECRYPTED        _HRESULT_TYPEDEF_(0x80091009L)

//
// MessageId: CRYPT_E_NOT_DECRYPTED
//
// MessageText:
//
//  The message content has not been decrypted yet.
//
#define CRYPT_E_NOT_DECRYPTED            _HRESULT_TYPEDEF_(0x8009100AL)

//
// MessageId: CRYPT_E_RECIPIENT_NOT_FOUND
//
// MessageText:
//
//  The enveloped-data message does not contain the specified recipient.
//
#define CRYPT_E_RECIPIENT_NOT_FOUND      _HRESULT_TYPEDEF_(0x8009100BL)

//
// MessageId: CRYPT_E_CONTROL_TYPE
//
// MessageText:
//
//  The control type is not valid.
//
#define CRYPT_E_CONTROL_TYPE             _HRESULT_TYPEDEF_(0x8009100CL)

//
// MessageId: CRYPT_E_ISSUER_SERIALNUMBER
//
// MessageText:
//
//  The issuer and/or serial number are/is not valid.
//
#define CRYPT_E_ISSUER_SERIALNUMBER      _HRESULT_TYPEDEF_(0x8009100DL)

//
// MessageId: CRYPT_E_SIGNER_NOT_FOUND
//
// MessageText:
//
//  The original signer is not found.
//
#define CRYPT_E_SIGNER_NOT_FOUND         _HRESULT_TYPEDEF_(0x8009100EL)

//
// MessageId: CRYPT_E_ATTRIBUTES_MISSING
//
// MessageText:
//
//  The message does not contain the requested attributes.
//
#define CRYPT_E_ATTRIBUTES_MISSING       _HRESULT_TYPEDEF_(0x8009100FL)

//
// MessageId: CRYPT_E_STREAM_MSG_NOT_READY
//
// MessageText:
//
//  The steamed message is note yet able to return the requested data.
//
#define CRYPT_E_STREAM_MSG_NOT_READY     _HRESULT_TYPEDEF_(0x80091010L)

//
// MessageId: CRYPT_E_STREAM_INSUFFICIENT_DATA
//
// MessageText:
//
//  The streamed message needs more data before the decode can complete.
//
#define CRYPT_E_STREAM_INSUFFICIENT_DATA _HRESULT_TYPEDEF_(0x80091011L)

//
// MessageId: CRYPT_E_BAD_LEN
//
// MessageText:
//
//  The length specified for the output data was insufficient.
//
#define CRYPT_E_BAD_LEN                  _HRESULT_TYPEDEF_(0x80092001L)

//
// MessageId: CRYPT_E_BAD_ENCODE
//
// MessageText:
//
//  An error was encountered while encoding or decoding.
//
#define CRYPT_E_BAD_ENCODE               _HRESULT_TYPEDEF_(0x80092002L)

//
// MessageId: CRYPT_E_FILE_ERROR
//
// MessageText:
//
//  An error occurred while reading or writing to the file
//
#define CRYPT_E_FILE_ERROR               _HRESULT_TYPEDEF_(0x80092003L)

//
// MessageId: CRYPT_E_NOT_FOUND
//
// MessageText:
//
//  The object or property wasn't found
//
#define CRYPT_E_NOT_FOUND                _HRESULT_TYPEDEF_(0x80092004L)

//
// MessageId: CRYPT_E_EXISTS
//
// MessageText:
//
//  The object or property already exists
//
#define CRYPT_E_EXISTS                   _HRESULT_TYPEDEF_(0x80092005L)

//
// MessageId: CRYPT_E_NO_PROVIDER
//
// MessageText:
//
//  No provider was specified for the store or object
//
#define CRYPT_E_NO_PROVIDER              _HRESULT_TYPEDEF_(0x80092006L)

//
// MessageId: CRYPT_E_SELF_SIGNED
//
// MessageText:
//
//  The specified certificate is self signed.
//
#define CRYPT_E_SELF_SIGNED              _HRESULT_TYPEDEF_(0x80092007L)

//
// MessageId: CRYPT_E_DELETED_PREV
//
// MessageText:
//
//  The previous certificate or CRL context was deleted.
//
#define CRYPT_E_DELETED_PREV             _HRESULT_TYPEDEF_(0x80092008L)

//
// MessageId: CRYPT_E_NO_MATCH
//
// MessageText:
//
//  No match when trying to find the object.
//
#define CRYPT_E_NO_MATCH                 _HRESULT_TYPEDEF_(0x80092009L)

//
// MessageId: CRYPT_E_UNEXPECTED_MSG_TYPE
//
// MessageText:
//
//  The type of the cryptographic message being decoded is different than what was expected.
//
#define CRYPT_E_UNEXPECTED_MSG_TYPE      _HRESULT_TYPEDEF_(0x8009200AL)

//
// MessageId: CRYPT_E_NO_KEY_PROPERTY
//
// MessageText:
//
//  The certificate doesn't have a private key property
//
#define CRYPT_E_NO_KEY_PROPERTY          _HRESULT_TYPEDEF_(0x8009200BL)

//
// MessageId: CRYPT_E_NO_DECRYPT_CERT
//
// MessageText:
//
//  No certificate was found having a private key property to use for decrypting.
//
#define CRYPT_E_NO_DECRYPT_CERT          _HRESULT_TYPEDEF_(0x8009200CL)

//
// MessageId: CRYPT_E_BAD_MSG
//
// MessageText:
//
//  Either, not a cryptographic message or incorrectly formatted.
//
#define CRYPT_E_BAD_MSG                  _HRESULT_TYPEDEF_(0x8009200DL)

//
// MessageId: CRYPT_E_NO_SIGNER
//
// MessageText:
//
//  The signed message doesn't have a signer for the specified signer index
//
#define CRYPT_E_NO_SIGNER                _HRESULT_TYPEDEF_(0x8009200EL)

//
// MessageId: CRYPT_E_PENDING_CLOSE
//
// MessageText:
//
//  Final closure is pending until additional frees or closes.
//
#define CRYPT_E_PENDING_CLOSE            _HRESULT_TYPEDEF_(0x8009200FL)

//
// MessageId: CRYPT_E_REVOKED
//
// MessageText:
//
//  The certificate or signature has been revoked
//
#define CRYPT_E_REVOKED                  _HRESULT_TYPEDEF_(0x80092010L)

//
// MessageId: CRYPT_E_NO_REVOCATION_DLL
//
// MessageText:
//
//  No Dll or exported function was found to verify revocation.
//
#define CRYPT_E_NO_REVOCATION_DLL        _HRESULT_TYPEDEF_(0x80092011L)

//
// MessageId: CRYPT_E_NO_REVOCATION_CHECK
//
// MessageText:
//
//  The called function wasn't able to do a revocation check on the certificate or signature.
//
#define CRYPT_E_NO_REVOCATION_CHECK      _HRESULT_TYPEDEF_(0x80092012L)

//
// MessageId: CRYPT_E_REVOCATION_OFFLINE
//
// MessageText:
//
//  Since the revocation server was offline, the called function wasn't able to complete the revocation check.
//
#define CRYPT_E_REVOCATION_OFFLINE       _HRESULT_TYPEDEF_(0x80092013L)

//
// MessageId: CRYPT_E_NOT_IN_REVOCATION_DATABASE
//
// MessageText:
//
//  The certificate or signature to be checked was not found in the revocation servers database.
//
#define CRYPT_E_NOT_IN_REVOCATION_DATABASE _HRESULT_TYPEDEF_(0x80092014L)

//
// MessageId: CRYPT_E_INVALID_NUMERIC_STRING
//
// MessageText:
//
//  The string contains a non-numeric character.
//
#define CRYPT_E_INVALID_NUMERIC_STRING   _HRESULT_TYPEDEF_(0x80092020L)

//
// MessageId: CRYPT_E_INVALID_PRINTABLE_STRING
//
// MessageText:
//
//  The string contains a non-printable character.
//
#define CRYPT_E_INVALID_PRINTABLE_STRING _HRESULT_TYPEDEF_(0x80092021L)

//
// MessageId: CRYPT_E_INVALID_IA5_STRING
//
// MessageText:
//
//  The string contains a character not in the 7 bit ASCII character set.
//
#define CRYPT_E_INVALID_IA5_STRING       _HRESULT_TYPEDEF_(0x80092022L)

//
// MessageId: CRYPT_E_INVALID_X500_STRING
//
// MessageText:
//
//  The string contains an invalid X500 name attribute key, oid, value or delimiter.
//
#define CRYPT_E_INVALID_X500_STRING      _HRESULT_TYPEDEF_(0x80092023L)

//
// MessageId: CRYPT_E_NOT_CHAR_STRING
//
// MessageText:
//
//  The dwValueType for the CERT_NAME_VALUE is not one of the character strings.  Most likely it is either a CERT_RDN_ENCODED_BLOB or CERT_TDN_OCTED_STRING.
//
#define CRYPT_E_NOT_CHAR_STRING          _HRESULT_TYPEDEF_(0x80092024L)

//
// MessageId: CRYPT_E_FILERESIZED
//
// MessageText:
//
//  The Put operation can not continue.  The file needs to be resized.  However, there is already a signature present.  A complete signing operation must be done.
//
#define CRYPT_E_FILERESIZED              _HRESULT_TYPEDEF_(0x80092025L)

//
// MessageId: CRYPT_E_SECURITY_SETTINGS
//
// MessageText:
//
//  The cryptography operation has failed due to a local security option setting.
//
#define CRYPT_E_SECURITY_SETTINGS        _HRESULT_TYPEDEF_(0x80092026L)

//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_DLL
//
// MessageText:
//
//  No DLL or exported function was found to verify subject usage.
//
#define CRYPT_E_NO_VERIFY_USAGE_DLL      _HRESULT_TYPEDEF_(0x80092027L)

//
// MessageId: CRYPT_E_NO_VERIFY_USAGE_CHECK
//
// MessageText:
//
//  The called function wasn't able to do a usage check on the subject.
//
#define CRYPT_E_NO_VERIFY_USAGE_CHECK    _HRESULT_TYPEDEF_(0x80092028L)

//
// MessageId: CRYPT_E_VERIFY_USAGE_OFFLINE
//
// MessageText:
//
//  Since the server was offline, the called function wasn't able to complete the usage check.
//
#define CRYPT_E_VERIFY_USAGE_OFFLINE     _HRESULT_TYPEDEF_(0x80092029L)

//
// MessageId: CRYPT_E_NOT_IN_CTL
//
// MessageText:
//
//  The subject was not found in a Certificate Trust List (CTL).
//
#define CRYPT_E_NOT_IN_CTL               _HRESULT_TYPEDEF_(0x8009202AL)

//
// MessageId: CRYPT_E_NO_TRUSTED_SIGNER
//
// MessageText:
//
//  No trusted signer was found to verify the signature of the message or trust list.
//
#define CRYPT_E_NO_TRUSTED_SIGNER        _HRESULT_TYPEDEF_(0x8009202BL)

//
// MessageId: CRYPT_E_OSS_ERROR
//
// MessageText:
//
//  OSS Certificate encode/decode error code base
//  
//  See asn1code.h for a definition of the OSS runtime errors. The OSS
//  error values are offset by CRYPT_E_OSS_ERROR.
//
#define CRYPT_E_OSS_ERROR                _HRESULT_TYPEDEF_(0x80093000L)

//
// MessageId: CERTSRV_E_BAD_REQUESTSUBJECT
//
// MessageText:
//
//  The request subject name is invalid or too long.
//
#define CERTSRV_E_BAD_REQUESTSUBJECT     _HRESULT_TYPEDEF_(0x80094001L)

//
// MessageId: CERTSRV_E_NO_REQUEST
//
// MessageText:
//
//  The request does not exist.
//
#define CERTSRV_E_NO_REQUEST             _HRESULT_TYPEDEF_(0x80094002L)

//
// MessageId: CERTSRV_E_BAD_REQUESTSTATUS
//
// MessageText:
//
//  The request's current status does not allow this operation.
//
#define CERTSRV_E_BAD_REQUESTSTATUS      _HRESULT_TYPEDEF_(0x80094003L)

//
// MessageId: CERTSRV_E_PROPERTY_EMPTY
//
// MessageText:
//
//  The requested property value is empty.
//
#define CERTSRV_E_PROPERTY_EMPTY         _HRESULT_TYPEDEF_(0x80094004L)

//
// MessageId: CERTDB_E_JET_ERROR
//
// MessageText:
//
//  Jet error code base
//  
//  See jet.h for a definition of the Jet runtime errors.
//  Negative Jet error values are masked to three digits and offset by CERTDB_E_JET_ERROR.
//
#define CERTDB_E_JET_ERROR               _HRESULT_TYPEDEF_(0x80095000L)

//
// MessageId: TRUST_E_SYSTEM_ERROR
//
// MessageText:
//
//  A system-level error occured while verifying trust.
//
#define TRUST_E_SYSTEM_ERROR             _HRESULT_TYPEDEF_(0x80096001L)

//
// MessageId: TRUST_E_NO_SIGNER_CERT
//
// MessageText:
//
//  The certificate for the signer of the message is invalid or not found.
//
#define TRUST_E_NO_SIGNER_CERT           _HRESULT_TYPEDEF_(0x80096002L)

//
// MessageId: TRUST_E_COUNTER_SIGNER
//
// MessageText:
//
//  One of the counter signers was invalid.
//
#define TRUST_E_COUNTER_SIGNER           _HRESULT_TYPEDEF_(0x80096003L)

//
// MessageId: TRUST_E_CERT_SIGNATURE
//
// MessageText:
//
//  The signature of the certificate can not be verified.
//
#define TRUST_E_CERT_SIGNATURE           _HRESULT_TYPEDEF_(0x80096004L)

//
// MessageId: TRUST_E_TIME_STAMP
//
// MessageText:
//
//  The time stamp signer and or certificate could not be verified or is malformed.
//
#define TRUST_E_TIME_STAMP               _HRESULT_TYPEDEF_(0x80096005L)

//
// MessageId: TRUST_E_BAD_DIGEST
//
// MessageText:
//
//  The objects digest did not verify.
//
#define TRUST_E_BAD_DIGEST               _HRESULT_TYPEDEF_(0x80096010L)

//
// MessageId: TRUST_E_BASIC_CONSTRAINTS
//
// MessageText:
//
//  The cerficates basic constraints are invalid or missing.
//
#define TRUST_E_BASIC_CONSTRAINTS        _HRESULT_TYPEDEF_(0x80096019L)

//
// MessageId: TRUST_E_FINANCIAL_CRITERIA
//
// MessageText:
//
//  The certificate does not meet or contain the Authenticode financial extensions.
//
#define TRUST_E_FINANCIAL_CRITERIA       _HRESULT_TYPEDEF_(0x8009601EL)

#define NTE_OP_OK 0

//
// Note that additional FACILITY_SSPI errors are in issperr.h
//
// ******************
// FACILITY_CERT
// ******************
//
// MessageId: TRUST_E_PROVIDER_UNKNOWN
//
// MessageText:
//
//  The specified trust provider is not known on this system.
//
#define TRUST_E_PROVIDER_UNKNOWN         _HRESULT_TYPEDEF_(0x800B0001L)

//
// MessageId: TRUST_E_ACTION_UNKNOWN
//
// MessageText:
//
//  The trust verification action specified is not supported by the specified trust provider.
//
#define TRUST_E_ACTION_UNKNOWN           _HRESULT_TYPEDEF_(0x800B0002L)

//
// MessageId: TRUST_E_SUBJECT_FORM_UNKNOWN
//
// MessageText:
//
//  The form specified for the subject is not one supported or known by the specified trust provider.
//
#define TRUST_E_SUBJECT_FORM_UNKNOWN     _HRESULT_TYPEDEF_(0x800B0003L)

//
// MessageId: TRUST_E_SUBJECT_NOT_TRUSTED
//
// MessageText:
//
//  The subject is not trusted for the specified action.
//
#define TRUST_E_SUBJECT_NOT_TRUSTED      _HRESULT_TYPEDEF_(0x800B0004L)

//
// MessageId: DIGSIG_E_ENCODE
//
// MessageText:
//
//  Error due to problem in ASN.1 encoding process.
//
#define DIGSIG_E_ENCODE                  _HRESULT_TYPEDEF_(0x800B0005L)

//
// MessageId: DIGSIG_E_DECODE
//
// MessageText:
//
//  Error due to problem in ASN.1 decoding process.
//
#define DIGSIG_E_DECODE                  _HRESULT_TYPEDEF_(0x800B0006L)

//
// MessageId: DIGSIG_E_EXTENSIBILITY
//
// MessageText:
//
//  Reading / writing Extensions where Attributes are appropriate, and visa versa.
//
#define DIGSIG_E_EXTENSIBILITY           _HRESULT_TYPEDEF_(0x800B0007L)

//
// MessageId: DIGSIG_E_CRYPTO
//
// MessageText:
//
//  Unspecified cryptographic failure.
//
#define DIGSIG_E_CRYPTO                  _HRESULT_TYPEDEF_(0x800B0008L)

//
// MessageId: PERSIST_E_SIZEDEFINITE
//
// MessageText:
//
//  The size of the data could not be determined.
//
#define PERSIST_E_SIZEDEFINITE           _HRESULT_TYPEDEF_(0x800B0009L)

//
// MessageId: PERSIST_E_SIZEINDEFINITE
//
// MessageText:
//
//  The size of the indefinite-sized data could not be determined.
//
#define PERSIST_E_SIZEINDEFINITE         _HRESULT_TYPEDEF_(0x800B000AL)

//
// MessageId: PERSIST_E_NOTSELFSIZING
//
// MessageText:
//
//  This object does not read and write self-sizing data.
//
#define PERSIST_E_NOTSELFSIZING          _HRESULT_TYPEDEF_(0x800B000BL)

//
// MessageId: TRUST_E_NOSIGNATURE
//
// MessageText:
//
//  No signature was present in the subject.
//
#define TRUST_E_NOSIGNATURE              _HRESULT_TYPEDEF_(0x800B0100L)

//
// MessageId: CERT_E_EXPIRED
//
// MessageText:
//
//  A required certificate is not within its validity period.
//
#define CERT_E_EXPIRED                   _HRESULT_TYPEDEF_(0x800B0101L)

//
// MessageId: CERT_E_VALIDITYPERIODNESTING
//
// MessageText:
//
//  The validity periods of the certification chain do not nest correctly.
//
#define CERT_E_VALIDITYPERIODNESTING     _HRESULT_TYPEDEF_(0x800B0102L)

//
// MessageId: CERT_E_ROLE
//
// MessageText:
//
//  A certificate that can only be used as an end-entity is being used as a CA or visa versa.
//
#define CERT_E_ROLE                      _HRESULT_TYPEDEF_(0x800B0103L)

//
// MessageId: CERT_E_PATHLENCONST
//
// MessageText:
//
//  A path length constraint in the certification chain has been violated.
//
#define CERT_E_PATHLENCONST              _HRESULT_TYPEDEF_(0x800B0104L)

//
// MessageId: CERT_E_CRITICAL
//
// MessageText:
//
//  An extension of unknown type that is labeled 'critical' is present in a certificate.
//
#define CERT_E_CRITICAL                  _HRESULT_TYPEDEF_(0x800B0105L)

//
// MessageId: CERT_E_PURPOSE
//
// MessageText:
//
//  A certificate is being used for a purpose other than that for which it is permitted.
//
#define CERT_E_PURPOSE                   _HRESULT_TYPEDEF_(0x800B0106L)

//
// MessageId: CERT_E_ISSUERCHAINING
//
// MessageText:
//
//  A parent of a given certificate in fact did not issue that child certificate.
//
#define CERT_E_ISSUERCHAINING            _HRESULT_TYPEDEF_(0x800B0107L)

//
// MessageId: CERT_E_MALFORMED
//
// MessageText:
//
//  A certificate is missing or has an empty value for an important field, such as a subject or issuer name.
//
#define CERT_E_MALFORMED                 _HRESULT_TYPEDEF_(0x800B0108L)

//
// MessageId: CERT_E_UNTRUSTEDROOT
//
// MessageText:
//
//  A certification chain processed correctly, but terminated in a root certificate which isn't trusted by the trust provider.
//
#define CERT_E_UNTRUSTEDROOT             _HRESULT_TYPEDEF_(0x800B0109L)

//
// MessageId: CERT_E_CHAINING
//
// MessageText:
//
//  A chain of certs didn't chain as they should in a certain application of chaining.
//
#define CERT_E_CHAINING                  _HRESULT_TYPEDEF_(0x800B010AL)

//
// MessageId: TRUST_E_FAIL
//
// MessageText:
//
//  Generic Trust Failure.
//
#define TRUST_E_FAIL                     _HRESULT_TYPEDEF_(0x800B010BL)

//
// MessageId: CERT_E_REVOKED
//
// MessageText:
//
//  A certificate was explicitly revoked by its issuer.
//
#define CERT_E_REVOKED                   _HRESULT_TYPEDEF_(0x800B010CL)

//
// MessageId: CERT_E_UNTRUSTEDTESTROOT
//
// MessageText:
//
//  The root certificate is a testing certificate and the policy settings disallow test certificates.
//
#define CERT_E_UNTRUSTEDTESTROOT         _HRESULT_TYPEDEF_(0x800B010DL)

//
// MessageId: CERT_E_REVOCATION_FAILURE
//
// MessageText:
//
//  The revocation process could not continue - the certificate(s) could not be checked.
//
#define CERT_E_REVOCATION_FAILURE        _HRESULT_TYPEDEF_(0x800B010EL)

//
// MessageId: CERT_E_CN_NO_MATCH
//
// MessageText:
//
//  The certificate's CN name does not match the passed value.
//
#define CERT_E_CN_NO_MATCH               _HRESULT_TYPEDEF_(0x800B010FL)

//
// MessageId: CERT_E_WRONG_USAGE
//
// MessageText:
//
//  The certificate is not valid for the requested usage.
//
#define CERT_E_WRONG_USAGE               _HRESULT_TYPEDEF_(0x800B0110L)

// *****************
// FACILITY_SETUPAPI
// *****************
//
// Since these error codes aren't in the standard Win32 range (i.e., 0-64K), define a
// macro to map either Win32 or SetupAPI error codes into an HRESULT.
//
#define HRESULT_FROM_SETUPAPI(x) ((((x) & (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR)) == (APPLICATION_ERROR_MASK|ERROR_SEVERITY_ERROR)) \
                                 ? ((HRESULT) (((x) & 0x0000FFFF) | (FACILITY_SETUPAPI << 16) | 0x80000000))                               \
                                 : HRESULT_FROM_WIN32(x))
//
// MessageId: SPAPI_E_EXPECTED_SECTION_NAME
//
// MessageText:
//
//  A non-empty line was encountered in the INF before the start of a section.
//
#define SPAPI_E_EXPECTED_SECTION_NAME    _HRESULT_TYPEDEF_(0x800F0000L)

//
// MessageId: SPAPI_E_BAD_SECTION_NAME_LINE
//
// MessageText:
//
//  A section name marker in the INF is not complete, or does not exist on a line by itself.
//
#define SPAPI_E_BAD_SECTION_NAME_LINE    _HRESULT_TYPEDEF_(0x800F0001L)

//
// MessageId: SPAPI_E_SECTION_NAME_TOO_LONG
//
// MessageText:
//
//  An INF section was encountered whose name exceeds the maximum section name length.
//
#define SPAPI_E_SECTION_NAME_TOO_LONG    _HRESULT_TYPEDEF_(0x800F0002L)

//
// MessageId: SPAPI_E_GENERAL_SYNTAX
//
// MessageText:
//
//  The syntax of the INF is invalid.
//
#define SPAPI_E_GENERAL_SYNTAX           _HRESULT_TYPEDEF_(0x800F0003L)

//
// MessageId: SPAPI_E_WRONG_INF_STYLE
//
// MessageText:
//
//  The style of the INF is different than what was requested.
//
#define SPAPI_E_WRONG_INF_STYLE          _HRESULT_TYPEDEF_(0x800F0100L)

//
// MessageId: SPAPI_E_SECTION_NOT_FOUND
//
// MessageText:
//
//  The required section was not found in the INF.
//
#define SPAPI_E_SECTION_NOT_FOUND        _HRESULT_TYPEDEF_(0x800F0101L)

//
// MessageId: SPAPI_E_LINE_NOT_FOUND
//
// MessageText:
//
//  The required line was not found in the INF.
//
#define SPAPI_E_LINE_NOT_FOUND           _HRESULT_TYPEDEF_(0x800F0102L)

//
// MessageId: SPAPI_E_NO_ASSOCIATED_CLASS
//
// MessageText:
//
//  The INF or the device information set or element does not have an associated install class.
//
#define SPAPI_E_NO_ASSOCIATED_CLASS      _HRESULT_TYPEDEF_(0x800F0200L)

//
// MessageId: SPAPI_E_CLASS_MISMATCH
//
// MessageText:
//
//  The INF or the device information set or element does not match the specified install class.
//
#define SPAPI_E_CLASS_MISMATCH           _HRESULT_TYPEDEF_(0x800F0201L)

//
// MessageId: SPAPI_E_DUPLICATE_FOUND
//
// MessageText:
//
//  An existing device was found that is a duplicate of the device being manually installed.
//
#define SPAPI_E_DUPLICATE_FOUND          _HRESULT_TYPEDEF_(0x800F0202L)

//
// MessageId: SPAPI_E_NO_DRIVER_SELECTED
//
// MessageText:
//
//  There is no driver selected for the device information set or element.
//
#define SPAPI_E_NO_DRIVER_SELECTED       _HRESULT_TYPEDEF_(0x800F0203L)

//
// MessageId: SPAPI_E_KEY_DOES_NOT_EXIST
//
// MessageText:
//
//  The requested device registry key does not exist.
//
#define SPAPI_E_KEY_DOES_NOT_EXIST       _HRESULT_TYPEDEF_(0x800F0204L)

//
// MessageId: SPAPI_E_INVALID_DEVINST_NAME
//
// MessageText:
//
//  The device instance name is invalid.
//
#define SPAPI_E_INVALID_DEVINST_NAME     _HRESULT_TYPEDEF_(0x800F0205L)

//
// MessageId: SPAPI_E_INVALID_CLASS
//
// MessageText:
//
//  The install class is not present or is invalid.
//
#define SPAPI_E_INVALID_CLASS            _HRESULT_TYPEDEF_(0x800F0206L)

//
// MessageId: SPAPI_E_DEVINST_ALREADY_EXISTS
//
// MessageText:
//
//  The device instance cannot be created because it already exists.
//
#define SPAPI_E_DEVINST_ALREADY_EXISTS   _HRESULT_TYPEDEF_(0x800F0207L)

//
// MessageId: SPAPI_E_DEVINFO_NOT_REGISTERED
//
// MessageText:
//
//  The operation cannot be performed on a device information element that has not been registered.
//
#define SPAPI_E_DEVINFO_NOT_REGISTERED   _HRESULT_TYPEDEF_(0x800F0208L)

//
// MessageId: SPAPI_E_INVALID_REG_PROPERTY
//
// MessageText:
//
//  The device property code is invalid.
//
#define SPAPI_E_INVALID_REG_PROPERTY     _HRESULT_TYPEDEF_(0x800F0209L)

//
// MessageId: SPAPI_E_NO_INF
//
// MessageText:
//
//  The INF from which a driver list is to be built does not exist.
//
#define SPAPI_E_NO_INF                   _HRESULT_TYPEDEF_(0x800F020AL)

//
// MessageId: SPAPI_E_NO_SUCH_DEVINST
//
// MessageText:
//
//  The device instance does not exist in the hardware tree.
//
#define SPAPI_E_NO_SUCH_DEVINST          _HRESULT_TYPEDEF_(0x800F020BL)

//
// MessageId: SPAPI_E_CANT_LOAD_CLASS_ICON
//
// MessageText:
//
//  The icon representing this install class cannot be loaded.
//
#define SPAPI_E_CANT_LOAD_CLASS_ICON     _HRESULT_TYPEDEF_(0x800F020CL)

//
// MessageId: SPAPI_E_INVALID_CLASS_INSTALLER
//
// MessageText:
//
//  The class installer registry entry is invalid.
//
#define SPAPI_E_INVALID_CLASS_INSTALLER  _HRESULT_TYPEDEF_(0x800F020DL)

//
// MessageId: SPAPI_E_DI_DO_DEFAULT
//
// MessageText:
//
//  The class installer has indicated that the default action should be performed for this installation request.
//
#define SPAPI_E_DI_DO_DEFAULT            _HRESULT_TYPEDEF_(0x800F020EL)

//
// MessageId: SPAPI_E_DI_NOFILECOPY
//
// MessageText:
//
//  The operation does not require any files to be copied.
//
#define SPAPI_E_DI_NOFILECOPY            _HRESULT_TYPEDEF_(0x800F020FL)

//
// MessageId: SPAPI_E_INVALID_HWPROFILE
//
// MessageText:
//
//  The specified hardware profile does not exist.
//
#define SPAPI_E_INVALID_HWPROFILE        _HRESULT_TYPEDEF_(0x800F0210L)

//
// MessageId: SPAPI_E_NO_DEVICE_SELECTED
//
// MessageText:
//
//  There is no device information element currently selected for this device information set.
//
#define SPAPI_E_NO_DEVICE_SELECTED       _HRESULT_TYPEDEF_(0x800F0211L)

//
// MessageId: SPAPI_E_DEVINFO_LIST_LOCKED
//
// MessageText:
//
//  The operation cannot be performed because the device information set is locked.
//
#define SPAPI_E_DEVINFO_LIST_LOCKED      _HRESULT_TYPEDEF_(0x800F0212L)

//
// MessageId: SPAPI_E_DEVINFO_DATA_LOCKED
//
// MessageText:
//
//  The operation cannot be performed because the device information element is locked.
//
#define SPAPI_E_DEVINFO_DATA_LOCKED      _HRESULT_TYPEDEF_(0x800F0213L)

//
// MessageId: SPAPI_E_DI_BAD_PATH
//
// MessageText:
//
//  The specified path does not contain any applicable device INFs.
//
#define SPAPI_E_DI_BAD_PATH              _HRESULT_TYPEDEF_(0x800F0214L)

//
// MessageId: SPAPI_E_NO_CLASSINSTALL_PARAMS
//
// MessageText:
//
//  No class installer parameters have been set for the device information set or element.
//
#define SPAPI_E_NO_CLASSINSTALL_PARAMS   _HRESULT_TYPEDEF_(0x800F0215L)

//
// MessageId: SPAPI_E_FILEQUEUE_LOCKED
//
// MessageText:
//
//  The operation cannot be performed because the file queue is locked.
//
#define SPAPI_E_FILEQUEUE_LOCKED         _HRESULT_TYPEDEF_(0x800F0216L)

//
// MessageId: SPAPI_E_BAD_SERVICE_INSTALLSECT
//
// MessageText:
//
//  A service installation section in this INF is invalid.
//
#define SPAPI_E_BAD_SERVICE_INSTALLSECT  _HRESULT_TYPEDEF_(0x800F0217L)

//
// MessageId: SPAPI_E_NO_CLASS_DRIVER_LIST
//
// MessageText:
//
//  There is no class driver list for the device information element.
//
#define SPAPI_E_NO_CLASS_DRIVER_LIST     _HRESULT_TYPEDEF_(0x800F0218L)

//
// MessageId: SPAPI_E_NO_ASSOCIATED_SERVICE
//
// MessageText:
//
//  The installation failed because a function driver was not specified for this device instance.
//
#define SPAPI_E_NO_ASSOCIATED_SERVICE    _HRESULT_TYPEDEF_(0x800F0219L)

//
// MessageId: SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE
//
// MessageText:
//
//  There is presently no default device interface designated for this interface class.
//
#define SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE _HRESULT_TYPEDEF_(0x800F021AL)

//
// MessageId: SPAPI_E_DEVICE_INTERFACE_ACTIVE
//
// MessageText:
//
//  The operation cannot be performed because the device interface is currently active.
//
#define SPAPI_E_DEVICE_INTERFACE_ACTIVE  _HRESULT_TYPEDEF_(0x800F021BL)

//
// MessageId: SPAPI_E_DEVICE_INTERFACE_REMOVED
//
// MessageText:
//
//  The operation cannot be performed because the device interface has been removed from the system.
//
#define SPAPI_E_DEVICE_INTERFACE_REMOVED _HRESULT_TYPEDEF_(0x800F021CL)

//
// MessageId: SPAPI_E_BAD_INTERFACE_INSTALLSECT
//
// MessageText:
//
//  An interface installation section in this INF is invalid.
//
#define SPAPI_E_BAD_INTERFACE_INSTALLSECT _HRESULT_TYPEDEF_(0x800F021DL)

//
// MessageId: SPAPI_E_NO_SUCH_INTERFACE_CLASS
//
// MessageText:
//
//  This interface class does not exist in the system.
//
#define SPAPI_E_NO_SUCH_INTERFACE_CLASS  _HRESULT_TYPEDEF_(0x800F021EL)

//
// MessageId: SPAPI_E_INVALID_REFERENCE_STRING
//
// MessageText:
//
//  The reference string supplied for this interface device is invalid.
//
#define SPAPI_E_INVALID_REFERENCE_STRING _HRESULT_TYPEDEF_(0x800F021FL)

//
// MessageId: SPAPI_E_INVALID_MACHINENAME
//
// MessageText:
//
//  The specified machine name does not conform to UNC naming conventions.
//
#define SPAPI_E_INVALID_MACHINENAME      _HRESULT_TYPEDEF_(0x800F0220L)

//
// MessageId: SPAPI_E_REMOTE_COMM_FAILURE
//
// MessageText:
//
//  A general remote communication error occurred.
//
#define SPAPI_E_REMOTE_COMM_FAILURE      _HRESULT_TYPEDEF_(0x800F0221L)

//
// MessageId: SPAPI_E_MACHINE_UNAVAILABLE
//
// MessageText:
//
//  The machine selected for remote communication is not available at this time.
//
#define SPAPI_E_MACHINE_UNAVAILABLE      _HRESULT_TYPEDEF_(0x800F0222L)

//
// MessageId: SPAPI_E_NO_CONFIGMGR_SERVICES
//
// MessageText:
//
//  The Plug and Play service is not available on the remote machine.
//
#define SPAPI_E_NO_CONFIGMGR_SERVICES    _HRESULT_TYPEDEF_(0x800F0223L)

//
// MessageId: SPAPI_E_INVALID_PROPPAGE_PROVIDER
//
// MessageText:
//
//  The property page provider registry entry is invalid.
//
#define SPAPI_E_INVALID_PROPPAGE_PROVIDER _HRESULT_TYPEDEF_(0x800F0224L)

//
// MessageId: SPAPI_E_NO_SUCH_DEVICE_INTERFACE
//
// MessageText:
//
//  The requested device interface is not present in the system.
//
#define SPAPI_E_NO_SUCH_DEVICE_INTERFACE _HRESULT_TYPEDEF_(0x800F0225L)

//
// MessageId: SPAPI_E_DI_POSTPROCESSING_REQUIRED
//
// MessageText:
//
//  The device's co-installer has additional work to perform after installation is complete.
//
#define SPAPI_E_DI_POSTPROCESSING_REQUIRED _HRESULT_TYPEDEF_(0x800F0226L)

//
// MessageId: SPAPI_E_INVALID_COINSTALLER
//
// MessageText:
//
//  The device's co-installer is invalid.
//
#define SPAPI_E_INVALID_COINSTALLER      _HRESULT_TYPEDEF_(0x800F0227L)

//
// MessageId: SPAPI_E_NO_COMPAT_DRIVERS
//
// MessageText:
//
//  There are no compatible drivers for this device.
//
#define SPAPI_E_NO_COMPAT_DRIVERS        _HRESULT_TYPEDEF_(0x800F0228L)

//
// MessageId: SPAPI_E_NO_DEVICE_ICON
//
// MessageText:
//
//  There is no icon that represents this device or device type.
//
#define SPAPI_E_NO_DEVICE_ICON           _HRESULT_TYPEDEF_(0x800F0229L)

//
// MessageId: SPAPI_E_INVALID_INF_LOGCONFIG
//
// MessageText:
//
//  A logical configuration specified in this INF is invalid.
//
#define SPAPI_E_INVALID_INF_LOGCONFIG    _HRESULT_TYPEDEF_(0x800F022AL)

//
// MessageId: SPAPI_E_DI_DONT_INSTALL
//
// MessageText:
//
//  The class installer has denied the request to install or upgrade this device.
//
#define SPAPI_E_DI_DONT_INSTALL          _HRESULT_TYPEDEF_(0x800F022BL)

//
// MessageId: SPAPI_E_INVALID_FILTER_DRIVER
//
// MessageText:
//
//  One of the filter drivers installed for this device is invalid.
//
#define SPAPI_E_INVALID_FILTER_DRIVER    _HRESULT_TYPEDEF_(0x800F022CL)

//
// MessageId: SPAPI_E_ERROR_NOT_INSTALLED
//
// MessageText:
//
//  No installed components were detected.
//
#define SPAPI_E_ERROR_NOT_INSTALLED      _HRESULT_TYPEDEF_(0x800F1000L)

#endif // _WINERROR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ldomerge\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)
!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETPATH)\$(TARGETBASENAME).exe $(TARGETCOMPLUS)
!endif


TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETBASENAME).pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\migpol\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "MIGPOL.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework CAS Policy Migration Tool\0"
#define VER_ORIGFILENAME_STR    "migpol.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mdhmerge\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)
!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETPATH)\$(TARGETBASENAME).exe $(TARGETCOMPLUS)
!endif


TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETBASENAME).pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mscorlibmanifest\makefile.inc ===
target_sign_link: $(TARGETPATH)\$(TARGETNAME)

$(TARGETPATH)\$(TARGETNAME): $(O)\$(ASSEMBLYNAME).tmp
    copy $(O)\$(ASSEMBLYNAME).tmp $(TARGETPATH)\$(TARGETNAME)
!if "$(TARGETCOMPLUS)" != ""
    copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)\$(ASSEMBLYNAME).dll
!endif

$(O)\$(ASSEMBLYNAME).tmp: $(O)\$(ASSEMBLYNAME).dll.manifest
    copy $(TARGETPATH)\$(ASSEMBLYNAME).dll $(O)\$(ASSEMBLYNAME).tmp
    GenMan32 $(O)\$(ASSEMBLYNAME).tmp /add /manifest:$(O)\$(ASSEMBLYNAME).dll.manifest

$(O)\$(ASSEMBLYNAME).dll.manifest: $(TARGETPATH)\$(ASSEMBLYNAME).dll
    -del $(O)\$(ASSEMBLYNAME).dll.manifest
!if "$(TARGETCOMPLUS)" != ""
    GenMan32 $(TARGETCOMPLUS)\$(ASSEMBLYNAME).dll /out:$(O)\$(ASSEMBLYNAME).dll.manifest
!else
    GenMan32 $(TARGETPATH)\$(ASSEMBLYNAME).dll /out:$(O)\$(ASSEMBLYNAME).dll.manifest
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\ldomerge\ldomerge.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace LDO {
    using System;
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.Globalization;

public class Merge
{

	internal Hashtable ht;
	internal ArrayList al;
    LDODataEntry[] sl;
	internal ArrayList[] m_rawdata;
//	internal LDODataEntry[] m_data;
	internal static int m_id = 0;

	public static readonly byte[] header00 = {0x1e, 0xf1, 0xd0, 0xa1, 0x00, 0x00, 0x00, 0x00};


	public byte[] m_mvid = null;

	public int m_fileversion;

	public Merge()
	{
		ht = new Hashtable();
		al = new ArrayList();
		m_fileversion = 0;
	}

	private static void DebugPrint(String str)
	{
		// Console.Write (str);
	}

	private static void DebugPrintLn(String str)
	{
		 Console.WriteLine (str);
	}

	public void ProcessFiles(String[] files)
	{
		String outfile = null;
		int indexofo = -1;
		for (int i = 0; i < files.Length; i++)
		{
			if (String.Compare(files[i].ToLower(CultureInfo.InvariantCulture), "-o", false, CultureInfo.InvariantCulture) == 0)
			{
				indexofo = i;
				// Found the output file
				outfile = files[i+1];
				if (i+1 >= files.Length)
				{
					throw new Exception("No output files specified");
				}
				files[i] = null;
				files[i+1] = null;
				i++;
			}
		}

		if (outfile == null)
		{
			throw new Exception("No output file specified");
		}

		m_rawdata = new ArrayList[indexofo];
		for (int i = 0; i < indexofo; i++)
		{
			ReadData(files[i], i);
		}

		AnalyzeData();

		FileStream fs = new FileStream(outfile, FileMode.CreateNew, FileAccess.ReadWrite);
		BinaryWriter write = new BinaryWriter(fs);

		//FixUpData();
		WriteDataAL(write);
		fs.Flush();
		fs.Close();
	}




	private void SortArray()
	{
		for (int i = 0; i < m_rawdata.Length; i++)
		{
			Console.WriteLine(m_rawdata[i].Count);
		}

		for (int i = m_rawdata.Length; --i >= 0;)
		{
			for (int j = 0; j < i; j++)
			{
				if (m_rawdata[j].Count > m_rawdata[j+1].Count)
				{
					ArrayList t = m_rawdata[j];
					m_rawdata[j] = m_rawdata[j+1];
					m_rawdata[j+1] = t;
				}
			}
		}
	}


	
    
    private void InsertInPosition(ref LDODataEntry[] sl, LDODataEntry d)
    {
        int i =0;
        while ((sl[i] != null) && 
               (sl[i].m_newcount >= d.m_newcount))
               i++;
        int count = i;
        while (sl[count] != null) count++;

        for (int j = count; j > i; j--)
            sl[j] = sl[j-1];

        sl[i] = d;
         
    }
    // Use a stable bubble sort algorithm
    private void SortUnion()
    {
		sl = new LDODataEntry[al.Count];
        for (int i=0;i<al.Count; i++)
            sl[i] = null;

        for (int i=0;i<al.Count; i++)
        {
            InsertInPosition(ref sl,(LDODataEntry)(al[i]));
        }
        
    }

	private void AnalyzeData()
	{
		SortArray();
		BuildUnion();
		SortUnion();
		//DumpUnion();

//		FindUnionAll();
//		Console.WriteLine(ht.Keys.Count);
	}

	private void BuildUnion()
	{

		for (int i = 0; i < m_rawdata.Length; i++)
		{
            int wt = (1 << i);
            Console.WriteLine("Index="+i+" Wt="+wt+" size="+m_rawdata[i].Count);
			for (int j = 0; j< m_rawdata[i].Count; j++)
			{
				((LDODataEntry)(m_rawdata[i][j])).m_fileindex = i;
				if (al.Contains(m_rawdata[i][j]))
				{
					int index = al.IndexOf(m_rawdata[i][j]);

					//((LDODataEntry)(al[index])).m_newcount++;
                    ((LDODataEntry)(al[index])).m_newcount |= wt;
				}
				else
				{
                    ((LDODataEntry)(m_rawdata[i][j])).m_newcount = wt;
					al.Add(m_rawdata[i][j]);
				}
			}

		}


	}




	private void CheckHeader(byte[] hd)
	{
		if (hd[4] == 0x00)
		{
			for (int i = 0; i < header00.Length; i++)
			{
				if (hd[i] != header00[i])
				{
					throw new Exception("LDO Header is invalid");
				}
			}
			m_fileversion = 0;
		}
		else
		{
			throw new Exception("MDH Header is invalid");
		}
	}


	private void ReadData (String hintFile, int htindex)
	{
		FileStream fs = new FileStream (hintFile, FileMode.Open);
		BinaryReader br = new BinaryReader (fs);
		m_rawdata[htindex] = new ArrayList();

		// Header
		Byte [] sig = br.ReadBytes(8);
		CheckHeader(sig);

		if (m_fileversion == 0)
		{
			ReadData00(br, htindex);
		}
		fs.Close();
	}

	public void ReadData00(BinaryReader br, int htindex)
	{
		//uint n;
		byte[] currentmvid;

		if(m_mvid == null)
		{
			m_mvid = br.ReadBytes(16);
		}
		else
		{
			currentmvid = br.ReadBytes(16);

			if(CompArray(m_mvid, currentmvid) == false)
			{
				throw new Exception("MVID Mismatch");
			}

		}

		long length = br.BaseStream.Length;
		length = length - 24;
		length = length /4;

		LDODataEntry current;

		//while ((n = br.ReadUInt32()) != 0xFFFFFFFF)
		for (long i = 0; i < length; i++)
		{
			current = new LDODataEntry();
			current.m_fileindex = htindex;
			current.m_data = br.ReadUInt32();
			current.m_id = m_id++;

			if (m_rawdata[htindex].Contains(current))
			{
				//m_rawdata[htindex][current] = ((int)m_rawdata[htindex][current])+1;
			}
			else
			{
				m_rawdata[htindex].Add(current);
			}
		}
	}



	public bool CompArray(byte[] a, byte[] b)
	{
		if (a.Length != b.Length)
		{
			return false;
		}

		for(int i = 0; i < a.Length; i++)
		{
			if (a[i] != b[i])
			{
				return false;
			}
		}
		return true;
	}


	public void WriteDataAL(BinaryWriter bw)
	{
		WriteHeader(bw);
		//WriteData00AL(bw);
		WriteData00SL(bw);
		WriteEOF(bw);
	}

	public void WriteHeader(BinaryWriter bw)
	{
		bw.Write(header00);
		bw.Write(m_mvid);
	}


	public void WriteData00AL(BinaryWriter bw)
	{
		Console.WriteLine(al.Count);
		for (int i = al.Count-1; i >= 0; --i)
		{
			//Console.WriteLine(i);
			LDODataEntry temp = (LDODataEntry)al[i];
			//int secnum = (m_data[i].m_secnum | (m_data[i].m_count << 8));
            //Console.WriteLine(temp.m_newcount);
			bw.Write(temp.m_data);
		}
	}

	public void WriteData00SL(BinaryWriter bw)
	{
		Console.WriteLine(al.Count);
		for (int i = 0; i < al.Count; i++)
		{
			bw.Write(sl[i].m_data);
		}
	}


	public void WriteEOF(BinaryWriter bw)
	{
		bw.Write(-1);
		bw.Write(-1);
	}

/*	public void DumpArrayDataWithCounts()
	{
		for (int i = 0; i < m_data.Length; i++)
		{
			Console.WriteLine(m_data[i] + "\r\nCount: " + m_data[i].m_count + "\r\nHashcode: " + m_data[i].GetHashCode());
		}

	}

	public void DumpUnion()
	{
		for (int i = 0; i < al.Count; i++)
		{
			LDODataEntry temp = (LDODataEntry)al[i];
			Console.WriteLine("File idx: " + temp.m_fileindex + " Count: " + temp.m_newcount);
		}

	}

	public void DumpDataWithCounts()
	{
		LDODataEntry[] data = new LDODataEntry[ht.Keys.Count];
		ht.Keys.CopyTo(data, 0);

		for (int i = 0; i < data.Length; i++)
		{
			Console.WriteLine(data[i] + "\r\nCount: " + ht[data[i]] + "\r\nHashcode: " + data[i].GetHashCode());
		}
	}
*/
	private static void Usage()
	{
		Console.WriteLine("Usage: mdhintfile 1.mdh 2.mdh 3.mdh -o out.mdh");
		Console.WriteLine("");
		Console.WriteLine("-o <outfile>");
	}

	public static int Main(String[] args)
	{
		switch (args.Length)
		{
			case 0:
				Usage();
				break;
			default:
			{
				try
				{
					Merge m = new Merge();
						m.ProcessFiles(args);
					break;
				}
				catch(Exception e) // @todo return -1 on failure
				{
					Console.WriteLine(e.Message);
					Console.Error.WriteLine(e.Message);
					Console.WriteLine(e.StackTrace);
					Console.Error.WriteLine(e.StackTrace);
					return 1;
				}
			}
		}
		return 0;
	}
}



public class LDODataEntry
{
	public int m_fileindex;
	public uint m_data;
	public int m_id;
	public int m_newcount;

	public LDODataEntry()
	{
		m_data = (uint)0xffffffff;
		m_id = 0;
		m_newcount = 1;
		m_fileindex = -1;
	}


	public override int GetHashCode()
	{
		return (int)m_data;
	}


	public override String ToString()
	{
		return m_data.ToString();
	}

	public override bool Equals(Object data)
	{
		LDODataEntry de = (LDODataEntry)data;

		if (de.m_data == m_data)
		{
			return true;
		}
		return false;
	}
}

/*
public class DataEntryComparer : IComparer
{
	public int Compare(Object x, Object y)
	{
		LDODataEntry a = (LDODataEntry)x;
		LDODataEntry b = (LDODataEntry)y;

		if(a.m_count == b.m_count)
		{
			if (a.m_id > b.m_id)
			{
				return -1;
			}
			return 1;

		}
		if (a.m_count < b.m_count)
		{
			return 1;
		}
		return -1;

	}

}
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\migpol\console\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif

cool_compile_resource: ..\MigPol.cs ..\resources.txt
        internalresgen ..\resources.txt migpol.resources

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(COOL_TARGET:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\migpol\win\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif

cool_compile_resource: ..\MigPol.cs ..\resources.txt
        internalresgen ..\resources.txt migpol.resources

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(COOL_TARGET:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mscorlibtlb\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "mscorlib.tlb"
#define VER_FILEDESCRIPTION_STR "Microsoft Common Language Runtime Class Library\0"
#define VER_ORIGFILENAME_STR    "mscorlib.tlb\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mscoverage\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.dll=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc

        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mscorlibtlb\makefile.inc ===
!if "$(TARGETCOMPLUS)" != ""
	TLBSRCDLL=$(TARGETCOMPLUS)\$(TARGETNAME:.tlb=.dll)
!else
	TLBSRCDLL=$(TARGETPATH)\$(TARGETNAME:.tlb=.dll)
!endif

MKTYPLIBLINK = $(LINKER) -Incremental:NO
TLBLINKFLAGS = \
	-dll \
	-nodefaultlib \
	-debug:none \
	-noentry \
	-heap:0,0 \
	-stack:0,0 \

C_DEFINES = $(C_DEFINES) -DREAL_TLB_FILE=$(O)\$(TARGETNAME:.tlb=.tmp)

target_sign_link :  $(TARGETPATH)\$(TARGETNAME)

!if "$(URT_NAMESFILE_NOIID)" == ""
NAMESFILE_IID= /iid
!else
NAMESFILE_IID=
!endif

$(O)\$(TARGETNAME:.tlb=.tmp) : $(TARGETPATH)\$(TARGETNAME:.tlb=.dll) $(TARGETPATH)\tlbexp.exe
!if "$(TARGETCOMPLUS)" != ""
	$(TARGETPATH)\tlbexp.exe /names:mscorlib.names $(TARGETCOMPLUS)\mscorlib.dll /out:$(O)\$(TARGETNAME:.tlb=.tmp)
	NamesGen /verify:mscorlib.names $(NAMESFILE_IID) /build $(O)\$(TARGETNAME:.tlb=.tmp)
!else
	$(TARGETPATH)\tlbexp.exe /names:mscorlib.names $(TARGETPATH)\mscorlib.dll /out:$(O)\$(TARGETNAME:.tlb=.tmp)
	NamesGen /verify:mscorlib.names $(NAMESFILE_IID) /build $(O)\$(TARGETNAME:.tlb=.tmp)
!endif

$(TARGETPATH)\$(TARGETNAME) : $(O)\$(TARGETNAME:.tlb=.tmp) $(O)\mktlb.res
	$(MKTYPLIBLINK) $(TLBLINKFLAGS) -out:$@ $(O)\mktlb.res
!if "$(TARGETCOMPLUS)" != ""
    copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif

!if "$(TARGETCOMPLUS)" != ""
    regasm /regfile:$(O)\$(ASSEMBLYNAME).reg $(TARGETCOMPLUS)\$(ASSEMBLYNAME).dll
!else
    regasm /regfile:$(O)\$(ASSEMBLYNAME).reg $(TARGETPATH)\$(ASSEMBLYNAME).dll
!endif
    RegKeySeperator $(O)\$(ASSEMBLYNAME).reg
    move $(ASSEMBLYNAME)_Shared.reg $(TARGETCOMPLUS)
    move $(ASSEMBLYNAME)_Version.reg $(TARGETCOMPLUS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\namesgen\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)
!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETPATH)\$(TARGETBASENAME).exe $(TARGETCOMPLUS)
!endif


TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETBASENAME).pdb
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mdhmerge\mdhmerge.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace MDH {
    using System;
    using System.IO;
    using System.Text;
    using System.Collections;
    using System.Globalization;

public class Merge
{

	internal Hashtable ht;
	internal ArrayList al;
	internal ArrayList[] m_rawdata;
	internal DataEntry[] m_data;
	internal static int m_id = 0;

	public static readonly byte[] header10 = {0x4d, 0x44, 0x48, 0x00, 0x01, 0x00, 0x00, 0x00};
	public static readonly byte[] header20 = {0x4d, 0x44, 0x48, 0x00, 0x02, 0x00, 0x00, 0x00};
	public byte[] m_mvid = null;

	public int m_fileversion;

	public Merge()
	{
		ht = new Hashtable();
		al = new ArrayList();
		m_fileversion = 0;
	}

	private static void DebugPrint(String str)
	{
		// Console.Write (str);
	}

	private static void DebugPrintLn(String str)
	{
		 Console.WriteLine (str);
	}

	public void ProcessFiles(String[] files)
	{
		String outfile = null;
		int indexofo = -1;
		for (int i = 0; i < files.Length; i++)
		{
			if (String.Compare(files[i].ToLower(CultureInfo.InvariantCulture), "-o", false, CultureInfo.InvariantCulture) == 0)
			{
				indexofo = i;
				// Found the output file
				outfile = files[i+1];
				if (i+1 >= files.Length)
				{
					throw new Exception("No output files specified");
				}
				files[i] = null;
				files[i+1] = null;
				i++;
			}
		}

		if (outfile == null)
		{
			throw new Exception("No output file specified");
		}

		m_rawdata = new ArrayList[indexofo];
		for (int i = 0; i < indexofo; i++)
		{
			ReadData(files[i], i);
		}

		AnalyzeData();

		FileStream fs = new FileStream(outfile, FileMode.CreateNew, FileAccess.ReadWrite);
		BinaryWriter write = new BinaryWriter(fs);

		//FixUpData();
		WriteDataAL(write);
		fs.Flush();
		fs.Close();
	}




	private void SortArray()
	{
		for (int i = m_rawdata.Length; --i >= 0;)
		{
			for (int j = 0; j < i; j++)
			{
				if (m_rawdata[j].Count > m_rawdata[j+1].Count)
				{
					ArrayList t = m_rawdata[j];
					m_rawdata[j] = m_rawdata[j+1];
					m_rawdata[j+1] = t;
				}
			}
		}
	}


	private void SortUnion()
	{
		for (int i = al.Count; --i >= 0;)
		{
			for (int j = 0; j < i; j++)
			{
				if (((DataEntry)(al[j])).m_newcount == ((DataEntry)(al[j+1])).m_newcount)
				{
					if (((DataEntry)(al[j])).m_fileindex < ((DataEntry)(al[j+1])).m_fileindex)
					{
						Object t = al[j];
						al[j] = al[j+1];
						al[j+1] = t;

					}
				}
				else if (((DataEntry)(al[j])).m_newcount > ((DataEntry)(al[j+1])).m_newcount)
				{
					Object t = al[j];
					al[j] = al[j+1];
					al[j+1] = t;
				}
			}
		}
	}

	private void AnalyzeData()
	{
		SortArray();
		BuildUnion();
		SortUnion();
		//DumpUnion();

//		FindUnionAll();
//		Console.WriteLine(ht.Keys.Count);
	}

	private void BuildUnion()
	{

		for (int i = 0; i < m_rawdata.Length; i++)
		{

			for (int j = 0; j< m_rawdata[i].Count; j++)
			{
				((DataEntry)(m_rawdata[i][j])).m_fileindex = i;
				if (al.Contains(m_rawdata[i][j]))
				{
					int index = al.IndexOf(m_rawdata[i][j]);

					((DataEntry)(al[index])).m_newcount++;
				}
				else
				{
					// We should test setting fileindex to i here
					al.Add(m_rawdata[i][j]);
				}
			}

		}

/*
		//DataEntry[] data = new DataEntry[m_rawdata[0].Keys.Count];
		//m_rawdata[0].Keys.CopyTo(data, 0);
		bool contains = true;

		for(int i = 0; i < data.Length; i++)
		{
			contains = true;
			for (int j = 1; j < m_rawdata.Length; j++)
			{
				if (m_rawdata[j].ContainsKey(data[i]) == false)
				{
					contains = false;
				}
			}

			if (contains == true)
			{
				al.Add(data[i]);
			}
		}
		*/
	}




	private void CheckHeader(byte[] hd)
	{
		if (hd[4] == 0x01)
		{
			for (int i = 0; i < header10.Length; i++)
			{
				if (hd[i] != header10[i])
				{
					throw new Exception("MDH Header is invalid");
				}
			}
			m_fileversion = 1;
		}
		else if (hd[4] == 2)
		{
			for (int i = 0; i < header20.Length; i++)
			{
				if (hd[i] != header20[i])
				{
					throw new Exception("MDH Header is invalid");
				}
			}
			m_fileversion = 2;
		}
		else
		{
			throw new Exception("MDH Header is invalid");
		}
	}


	private void ReadData (String hintFile, int htindex)
	{
		FileStream fs = new FileStream (hintFile, FileMode.Open);
		BinaryReader br = new BinaryReader (fs);
		m_rawdata[htindex] = new ArrayList();

		// Header
		Byte [] sig = br.ReadBytes(8);
		CheckHeader(sig);

		if (m_fileversion == 1)
		{
			ReadData10(br, htindex);
		}
		else if (m_fileversion == 2)
		{
			ReadData20(br, htindex);
		}
		fs.Close();
	}

	public void ReadData10(BinaryReader br, int htindex)
	{
		int n;
		int secNum;

		// We need to make a null mvid as we are outputting 2.0 files
		m_mvid = new byte[16];

		DataEntry current;

		while ((secNum = br.ReadInt32()) != -1)
		{
			current = new DataEntry();
			current.m_fileindex = htindex;
			current.m_secnum = secNum;
			n = br.ReadInt32();

			current.m_length = n;
			Byte [] b = br.ReadBytes(n);
			current.m_id = m_id++;

			//current.m_data = ascii.GetString(b);
			current.m_data = b;
			if (m_rawdata[htindex].Contains(current))
			{
				//m_rawdata[htindex][current] = ((int)m_rawdata[htindex][current])+1;
			}
			else
			{
				m_rawdata[htindex].Add(current);
			}
		}
	}

	public void ReadData20(BinaryReader br, int htindex)
	{
		int n;
		int secNum;
		byte[] currentmvid;

		if(m_mvid == null)
		{
			m_mvid = br.ReadBytes(16);
		}
		else
		{
			currentmvid = br.ReadBytes(16);

			if(CompArray(m_mvid, currentmvid) == false)
			{
				throw new Exception("MVID Mismatch");
			}

		}


		DataEntry current;

		while ((secNum = br.ReadInt32()) != -1)
		{
			current = new DataEntry();
			current.m_secnum = (secNum & 0xff);
			current.m_count = (secNum  >> 8);
			// Take one off for the one that will get added by this file
			// Not really the best way to do this but i works

			n = br.ReadInt32();
			current.m_fileindex = htindex;
			current.m_length = n;
			Byte [] b = br.ReadBytes(n);
			current.m_id = m_id++;

			//current.m_data = ascii.GetString(b);
			current.m_data = b;

			if (m_rawdata[htindex].Contains(current))
			{
				//m_rawdata[htindex][current] = ((int)m_rawdata[htindex][current])+1;
			}
			else
			{
				m_rawdata[htindex].Add(current);
			}
		}
	}

	public void FixUpData()
	{
		// @now lets get a useful array
		m_data = new DataEntry[ht.Keys.Count];
		ht.Keys.CopyTo(m_data, 0);

		for (int i = 0; i < m_data.Length; i++)
		{
			m_data[i].m_count = m_data[i].m_count + ((int)(ht[m_data[i]]));
		}

		Array.Sort(m_data, new DataEntryComparer());
		//DumpArrayDataWithCounts();

	}

	public bool CompArray(byte[] a, byte[] b)
	{
		if (a.Length != b.Length)
		{
			return false;
		}

		for(int i = 0; i < a.Length; i++)
		{
			if (a[i] != b[i])
			{
				return false;
			}
		}
		return true;
	}

	public void WriteData(BinaryWriter bw)
	{
		WriteHeader(bw);
		WriteData20(bw);
		WriteEOF(bw);
	}

	public void WriteDataAL(BinaryWriter bw)
	{
		WriteHeader(bw);
		WriteData20AL(bw);
		WriteEOF(bw);
	}

	public void WriteHeader(BinaryWriter bw)
	{
		bw.Write(header20);
		bw.Write(m_mvid);
	}

	public void WriteData10(BinaryWriter bw)
	{
		for (int i = 0; i < m_data.Length; i++)
		{
			bw.Write(m_data[i].m_secnum);
			bw.Write(m_data[i].m_length);
			bw.Write(m_data[i].m_data);
		}
	}

	public void WriteData20(BinaryWriter bw)
	{
		for (int i = 0; i < m_data.Length; i++)
		{
			int secnum = (m_data[i].m_secnum | (m_data[i].m_count << 8));
			bw.Write(secnum);
			bw.Write(m_data[i].m_length);
			bw.Write(m_data[i].m_data);
		}
	}

	public void WriteData20AL(BinaryWriter bw)
	{
		//Console.WriteLine(al.Count);
		for (int i = al.Count-1; i >= 0; --i)
		{
			//Console.WriteLine(i);
			DataEntry temp = (DataEntry)al[i];
			//int secnum = (m_data[i].m_secnum | (m_data[i].m_count << 8));
			bw.Write(temp.m_secnum);
			bw.Write(temp.m_length);
			bw.Write(temp.m_data);
		}
	}

	public void WriteEOF(BinaryWriter bw)
	{
		bw.Write(-1);
		bw.Write(-1);
	}

	public void DumpArrayDataWithCounts()
	{
		for (int i = 0; i < m_data.Length; i++)
		{
			Console.WriteLine(m_data[i] + "\r\nCount: " + m_data[i].m_count + "\r\nHashcode: " + m_data[i].GetHashCode());
		}

	}

	public void DumpUnion()
	{
		for (int i = 0; i < al.Count; i++)
		{
			DataEntry temp = (DataEntry)al[i];
			Console.WriteLine("File idx: " + temp.m_fileindex + " Count: " + temp.m_newcount);
		}

	}

	public void DumpDataWithCounts()
	{
		DataEntry[] data = new DataEntry[ht.Keys.Count];
		ht.Keys.CopyTo(data, 0);

		for (int i = 0; i < data.Length; i++)
		{
			Console.WriteLine(data[i] + "\r\nCount: " + ht[data[i]] + "\r\nHashcode: " + data[i].GetHashCode());
		}
	}

	private static void Usage()
	{
		Console.WriteLine("Usage: mdhintfile 1.mdh 2.mdh 3.mdh -o out.mdh");
		Console.WriteLine("");
		Console.WriteLine("-o <outfile>");
	}

	public static int Main(String[] args)
	{
		switch (args.Length)
		{
			case 0:
				Usage();
				break;
			default:
			{
				try
				{
					Merge m = new Merge();
						m.ProcessFiles(args);
					break;
				}
				catch(Exception e) // @todo return -1 on failure
				{
					Console.WriteLine(e.Message);
					Console.Error.WriteLine(e.Message);
					Console.WriteLine(e.StackTrace);
					Console.Error.WriteLine(e.StackTrace);
					return 1;
				}
			}
		}
		return 0;
	}
}



public class DataEntry
{
	public int m_fileindex;
	public int m_secnum;
	public int m_length;
	public byte[] m_data;
	public int m_count;
	public int m_id;
	public bool done1;
	public bool done2;
	public int m_newcount;

	public DataEntry()
	{
		m_secnum = 0;
		m_length = 0;
		m_data = null;
		m_count = 0;
		m_id = 0;
		done1 = false;
		done2 = false;
		m_newcount = 1;
		m_fileindex = -1;
	}


	public override int GetHashCode()
	{
	    int hash = 5381;

		hash = ((hash << 5) + hash) ^ m_secnum;

	    for (int i = 0; i < m_data.Length; i++)
	    {
	        hash = ((hash << 5) + hash) ^ m_data[i];
	    }
	    return hash;
	}


	public override String ToString()
	{
		StringBuilder str = new StringBuilder(m_length);
		String basestr = "SecNum: " + m_secnum + "\r\nLength: " + m_length + "\r\nData: ";

		for (int i = 0; i < m_data.Length; i ++)
		{
			// @todo this should be hex
			str.Append(m_data[i]);
			str.Append(" ");
		}
		return basestr + str.ToString();
	}

	public override bool Equals(Object data)
	{
		DataEntry de = (DataEntry)data;
		bool equal = false;
		if (de.m_secnum == m_secnum && de.m_length == m_length)
		{
			equal = true;
			for (int i = 0; i < m_data.Length; i++)
			{
				if (de.m_data[i] != m_data[i])
				{
					equal = false;
				}
			}
		}
		return equal;
	}
}


public class DataEntryComparer : IComparer
{
	public int Compare(Object x, Object y)
	{
		DataEntry a = (DataEntry)x;
		DataEntry b = (DataEntry)y;

		if(a.m_count == b.m_count)
		{
			if (a.m_id > b.m_id)
			{
				return -1;
			}
			return 1;

		}
		if (a.m_count < b.m_count)
		{
			return 1;
		}
		return -1;

	}

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\migpol\migpol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==

// Welcome to the wonderful world of security policy migration!

using System;
using System.Resources;
using System.Text;
using System.Globalization;
using System.Reflection;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Collections;
using System.IO;
using System.Diagnostics;
using Microsoft.Win32;


[assembly:SecurityPermissionAttribute( SecurityAction.RequestMinimum, ControlPolicy = true )]
[assembly:FileIOPermissionAttribute( SecurityAction.RequestMinimum, Unrestricted = true )]
[assembly:System.Reflection.AssemblyTitleAttribute("MigPol")]
namespace MigPol
{

    delegate void OptionHandler( String[] args, int index, out int numArgsUsed );

    internal class OptionTableEntry
    {
        public OptionTableEntry( String option, OptionHandler handler, String sameAs, bool list )
        {
            this.option = option;
            this.handler = handler;
            this.sameAs = sameAs;
            this.list = list;
            this.displayMShip = false;
        }

        public OptionTableEntry( String option, OptionHandler handler, String sameAs, bool list, bool displayMShip )
        {
            this.option = option;
            this.handler = handler;
            this.sameAs = sameAs;
            this.list = list;
            this.displayMShip = displayMShip;
        }
   
        
        internal String option;
        internal OptionHandler handler;
        internal String sameAs;
        internal bool list;
        internal bool displayMShip;
    }

    class ExitException : Exception
    {
    }

    class AppException : Exception
    {
    }

    [Flags]
    enum MergeSemantic
    {
        UpgradeInternet = 0x1,
        EatNonMicrosoftCodeGroup = 0x2,
        EatNonMicrosoftPermission = 0x4,
        ThrowNonMicrosoftCodeGroup = 0x8,
        ThrowNonMicrosoftPermission = 0x10,
        AllowNonMicrosoftCodeGroup = 0x20,
        AllowNonMicrosoft = 0x40,
    }

    enum MigpolErrorCode
    {
        Success = 0,
        Generic = -1,
        UnableToSavePolicy = 1000,
        NotEnoughArgs = 1001,
        InvalidOption = 1002
    }

    internal class MigPol
    {
        internal static ResourceManager manager = new ResourceManager( "migpol", Assembly.GetExecutingAssembly() );
        internal static ResourceManager mscorlibManager = new ResourceManager( "mscorlib", Assembly.Load( "mscorlib" ) );

        private static bool m_success = false;

        private const int m_retryAttempts = 1000;
        private const String m_labelSeparators = ".";

        private static MergeSemantic m_mergeSemantic = MergeSemantic.ThrowNonMicrosoftCodeGroup | MergeSemantic.EatNonMicrosoftPermission;

        private static bool m_debugBreak = false;
        private static bool m_useCurrent = false;

        private static readonly bool m_displayInternalOptions = false;

        internal static readonly byte[] s_microsoftPublicKey = 
        {
            0,  36,   0,   0,   4, 128,   0,   0, 148,   0,   0,   0,   6,   2,   0,
            0,   0,  36,   0,   0,  82,  83,  65,  49,   0,   4,   0,   0,   1,   0,
            1,   0,   7, 209, 250,  87, 196, 174, 217, 240, 163,  46, 132, 170,  15,
          174, 253,  13, 233, 232, 253, 106, 236, 143, 135, 251,   3, 118, 108, 131,
           76, 153, 146,  30, 178,  59, 231, 154, 217, 213, 220, 193, 221, 154, 210,
           54,  19,  33,   2, 144,  11, 114,  60, 249, 128, 149, 127, 196, 225, 119,
           16, 143, 198,   7, 119,  79,  41, 232,  50,  14, 146, 234,   5, 236, 228,
          232,  33, 192, 165, 239, 232, 241, 100,  92,  76,  12, 147, 193, 171, 153,
           40,  93,  98,  44, 170, 101,  44,  29, 250, 214,  61, 116,  93, 111,  45,
          229, 241, 126,  94, 175,  15, 196, 150,  61,  38,  28, 138,  18,  67, 101,
           24,  32, 109, 192, 147,  52,  77,  90, 210, 147
        };

        internal static readonly byte[] s_ecmaPublicKey = 
        {
            0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0
        };

        private static readonly String m_configFile = 
            "<?xml version =\"1.0\"?>\n" +
            "<configuration>\n" +
            "    <startup>\n" +
            "        <requiredRuntime  safemode=\"true\"  imageVersion=\"v" + Util.Version.VersionString + "\" version=\"v{VERSION}\"/>\n" +
            "    </startup>\n" +
            "    <runtime>\n" +
            "        <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n" +
            "            <publisherPolicy apply=\"no\"/>\n" +
            "        </assemblyBinding>\n" +
            "    </runtime>\n" + 
            "</configuration>";


        private static readonly String[] m_replaceStringTemplate = { ", Version={0}, ", "AssemblyVersion=\"{0}\"" };
        private static readonly String[] m_intermediateString = { "{__MIGPOL_INTERMEDIATE_STRING_VERSION__}", "{__MIGPOL_INTERMEDIATE_STRING_ASSEMBLYVERSION__}" };

        private static OptionTableEntry[] optionTable =
            { new OptionTableEntry( manager.GetString( "OptionTable_MigrateOut" ), new OptionHandler( MigrateOutHandler ), null, m_displayInternalOptions ),
              new OptionTableEntry( manager.GetString( "OptionTable_MigrateIn" ), new OptionHandler( MigrateInHandler ), null, m_displayInternalOptions ),

              new OptionTableEntry( manager.GetString( "OptionTable_DebugBreak" ), new OptionHandler( DebugBreakHandler ), null, m_displayInternalOptions ),
              new OptionTableEntry( manager.GetString( "OptionTable_Debug" ), new OptionHandler( DebugHandler ), null, m_displayInternalOptions ),

              new OptionTableEntry( manager.GetString( "OptionTable_UpgradeInternet" ), new OptionHandler( UpgradeInternetHandler ), null, m_displayInternalOptions ),
              new OptionTableEntry( manager.GetString( "OptionTable_Migrate" ), new OptionHandler( MigrateHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListVersions" ), new OptionHandler( ListVersionsHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_ListVersionsAbbr" ), new OptionHandler( ListVersionsHandler ), manager.GetString( "OptionTable_ListVersions" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_Help" ), new OptionHandler( HelpHandler ), null, true ),
              new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr1" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ), false ),
              new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr2" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ), true ),
              new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr3" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ), true ),
            };


////////// These are all functions doing the things that make this a
////////// cool full featured command line app.

        private static void PauseCapableWriteLine( String msg )
        {
            Console.WriteLine( msg );
        }

        public static void Main( String[] args )
        {
            System.Environment.ExitCode = (int)MigpolErrorCode.Success;

            PauseCapableWriteLine( GenerateHeader() );
    
            try
            {
                if (args.Length == 0)
                {
                    Error( null, manager.GetString( "Error_NotEnoughArgs" ), -1 );
                }
                else
                {
                    String[] normalizedArgs = args;

                    Run( normalizedArgs );
                }
            }
            catch (ExitException)
            {
                if (m_debugBreak)
                    System.Diagnostics.Debugger.Break();
            }
        }

        static String GenerateHeader()
        {
            StringBuilder sb = new StringBuilder();
                sb.Append( manager.GetString( "Copyright_Line1" ) + " " + Util.Version.VersionString );
            sb.Append( Environment.NewLine + manager.GetString( "Copyright_Line2" ) + Environment.NewLine );
            return sb.ToString();
        }        

        static void Run( String[] args )
        {
            int numArgs = args.Length;
            int currentIndex = 0;
            int numArgsUsed = 0;
        
            while (currentIndex < numArgs)
            {
                bool foundOption = false;
        
                for (int index = 0; index < optionTable.Length; ++index)
                {
                    if (args[currentIndex][0] == '/')
                    {
                        args[currentIndex] = '-' + args[currentIndex].Substring( 1, args[currentIndex].Length - 1 );
                    }

                    if (String.Compare( optionTable[index].option, args[currentIndex], true, CultureInfo.InvariantCulture) == 0)
                    {
                        try
                        {
                            optionTable[index].handler(args, currentIndex, out numArgsUsed );
                        }
                        catch (Exception e)
                        {
                            if (!(e is ExitException))
                            {
    #if _DEBUG
                                Error( null, String.Format( manager.GetString( "Error_RuntimeError" ), e.ToString() ), (int)MigpolErrorCode.Generic );
    #else
                                String message = e.Message;

                                if (message == null || message.Equals( "" ))
                                {
                                    message = e.GetType().AssemblyQualifiedName;
                                }

                                Error( null, String.Format( manager.GetString( "Error_RuntimeError" ), message ), (int)MigpolErrorCode.Generic );
    #endif
                            }
                            return;
                        }
                    
                        foundOption = true;
                        currentIndex += numArgsUsed;
                        break;
                    }
                }
                if (!foundOption)
                {
                    try
                    {
                        Error( null, String.Format( manager.GetString( "Error_InvalidOption" ), args[currentIndex] ), (int)MigpolErrorCode.InvalidOption );
                    }
                    catch (Exception e)
                    {
                        if (!(e is ExitException))
                        {
                            String message = e.Message;

                            if (message == null || message.Equals( "" ))
                            {
                                message = e.GetType().AssemblyQualifiedName;
                            }

                            Help( null, manager.GetString( "Error_UnhandledError" ) + message, true );
                        }
                        return;
                    }
                }
            }
            if (m_success)
                PauseCapableWriteLine( manager.GetString( "Dialog_Success" ) );
        }

        static void Error( String which, String message, int errorCode )
        {
            Error( which, message, errorCode, true );
        }

        static void Error( String which, String message, int errorCode, bool displayUsage )
        {
            Help( which, String.Format( manager.GetString( "Error_Arg" ), message ), displayUsage );
            System.Environment.ExitCode = errorCode;
            throw new ExitException();
        }

        static void Help( String whichOption, String message, bool displayUsage )
        {
            PauseCapableWriteLine( message + Environment.NewLine );
    
            if (displayUsage)
            {
                PauseCapableWriteLine( manager.GetString( "Usage" ) + Environment.NewLine );
    
                String[] helpArgs = new String[1];
                helpArgs[0] = "__internal_usage__";
                int numArgs = 0;
    
                for (int i = 0; i < optionTable.Length; ++i)
                {
                    // Only list if we've said to list it.        
                    if (optionTable[i].list)
                    {
                        // Look for all the options that aren't the same as something as and that we have requested.
                        if (optionTable[i].sameAs == null && (whichOption == null || String.Compare( whichOption, optionTable[i].option, true, CultureInfo.InvariantCulture) == 0))
                        {
                            // For each option we find, print out all like options first.
                            for (int j = 0; j < optionTable.Length; ++j)
                            {
                                if (optionTable[j].list && optionTable[j].sameAs != null && String.Compare( optionTable[i].option, optionTable[j].sameAs, true, CultureInfo.InvariantCulture) == 0)
                                {
                                    StringBuilder sb = new StringBuilder();
                                    sb.Append( manager.GetString( "Usage_Name" ) );
                                    sb.Append( " " );
                                    sb.Append( optionTable[j].option );
                                    PauseCapableWriteLine( sb.ToString() );
                                }
                            }
                        
                            optionTable[i].handler(helpArgs, 0, out numArgs);
                            PauseCapableWriteLine( "" );
                        }
                    }
                }
            }
        }

////////// These are some helpers to make the option handlers easier
////////// to write.

        static bool SupportsBindingRedirects()
        {
            bool retval;

            try
            {
                Enum.Parse( typeof( SecurityPermissionFlag ), "BindingRedirects" );
                retval = true;
            }
            catch (Exception)
            {
                retval = false;
            }

            return retval;
        }

        private const String s_bindingRedirectXml =
               "<PermissionSet class=\"System.Security.PermissionSet\"" +
                              "version=\"1\" " +
                  "<Permission class=\"System.Security.Permissions.SecurityPermission, mscorlib, PublicKeyToken=b77a5c561934e089\"" +
                              "version=\"1\" " +
                              "Flags=\"BindingRedirects\"/>" +
               "</PermissionSet>";

        static NamedPermissionSet AddBindingRedirect( NamedPermissionSet pSet )
        {
            // We cook up the permission set from xml to get around
            // any issues with versions of the Runtime (RTM) that
            // don't include the BindingRedirects flag in security permission.
            // On those platforms, we decode to an empty set which
            // will be harmlessly unioned with the input set and result
            // in a no-op.
            PermissionSet bindingRedirectPset = new PermissionSet( PermissionState.None );
            bindingRedirectPset.FromXml( new Parser( s_bindingRedirectXml ).GetTopElement() );
            PermissionSet unionSet = pSet.Union( bindingRedirectPset );
            NamedPermissionSet finalSet = new NamedPermissionSet( pSet.Name, PermissionState.None );
            finalSet.Description = pSet.Description;

            IEnumerator enumerator = unionSet.GetEnumerator();
            while (enumerator.MoveNext())
            {
                finalSet.SetPermission( (IPermission)enumerator.Current );
            }

            return finalSet;
        }

        static String GetErrorCodeString( MigpolErrorCode code )
        {
            return manager.GetString( "MigpolErrorCode_" + code.ToString() );
        }

        static PolicyLevel GetLevelFromHierarchy( String levelLabel )
        {
            IEnumerator enumerator = SecurityManager.PolicyHierarchy();

            while (enumerator.MoveNext())
            {
                PolicyLevel current = (PolicyLevel)enumerator.Current;

                if (current.Label.Equals( levelLabel ))
                    return current;
            }

            return null;
        }


        static void TransferDataAndSave( PolicyLevel src, PolicyLevel dest )
        {
            TransferData( src, dest );

            SecurityManager.SavePolicyLevel( dest );
        }

        static void TransferData( PolicyLevel src, PolicyLevel dest )
        {
            dest.RootCodeGroup = src.RootCodeGroup.Copy();

            IEnumerator destEnumerator;
            IEnumerator srcEnumerator;

            destEnumerator = dest.NamedPermissionSets.GetEnumerator();

            while (destEnumerator.MoveNext())
            {
                NamedPermissionSet currentSet = (NamedPermissionSet)destEnumerator.Current;

                try
                {
                    dest.RemoveNamedPermissionSet( currentSet.Name );
                }
                catch (Exception)
                {
                }
            }

            srcEnumerator = src.NamedPermissionSets.GetEnumerator();

            while (srcEnumerator.MoveNext())
            {
                try
                {
                    NamedPermissionSet currentSet = (NamedPermissionSet)srcEnumerator.Current;

                    if (currentSet.Name.Equals( "Everything" ) && SupportsBindingRedirects())
                        currentSet = AddBindingRedirect( currentSet );

                    dest.AddNamedPermissionSet( currentSet );
                }
                catch (Exception)
                {
                }
            }

/*          In Everett, we don't migrate references to other assemblies so
            we don't need to migrate the full trust list.  Instead we see the
            FullTrustAssemblies list to the default.

            destEnumerator = dest.FullTrustAssemblies.GetEnumerator();

            while (destEnumerator.MoveNext())
            {
                dest.RemoveFullTrustAssembly( (StrongNameMembershipCondition)destEnumerator.Current );
            }

            srcEnumerator = src.FullTrustAssemblies.GetEnumerator();

            while (srcEnumerator.MoveNext())
            {
                dest.AddFullTrustAssembly( (StrongNameMembershipCondition)srcEnumerator.Current );
            }
*/
            destEnumerator = dest.FullTrustAssemblies.GetEnumerator();

            while (destEnumerator.MoveNext())
            {
                dest.RemoveFullTrustAssembly( (StrongNameMembershipCondition)destEnumerator.Current );
            }

            PolicyLevel tempLevel = PolicyLevel.CreateAppDomainLevel();
            srcEnumerator = tempLevel.FullTrustAssemblies.GetEnumerator();

            while (srcEnumerator.MoveNext())
            {
                dest.AddFullTrustAssembly( (StrongNameMembershipCondition)srcEnumerator.Current );
            }
        }

        static void WriteStringToFile( String fileName, String str )
        {
            FileStream stream = File.Create( fileName );

            StreamWriter writer = new StreamWriter( stream );
            
            writer.Write( str );
            
            writer.Close();
            
            stream.Close();
        }

        static String GetExePath()
        {
            Assembly asm = Assembly.GetExecutingAssembly();

            AssemblyName asmName = asm.GetName();

            String codeBase = asmName.CodeBase;

            if (String.Compare( codeBase, 0, "file:///", 0, ("file:///").Length, true, CultureInfo.InvariantCulture ) == 0)
            {
                String exePath = codeBase.Substring( ("file:///").Length );

                // We always want to CreateProcess on the windows version of the exe
                // so that no dos box pops up.

                int index = exePath.LastIndexOfAny( new char[] { '/', '\\' } );

                if (index == -1)
                    exePath = "migpolwin.exe";
                else
                    exePath = exePath.Substring( 0, index ) + "\\migpolwin.exe";

                return exePath;
            }
            else
            {
                return null;
            }
        }

        static String GetTempPath()
        {
            String tempPath = Path.GetTempFileName();

            File.Delete( tempPath );
            Directory.CreateDirectory( tempPath );

            return tempPath;
        }

        static bool CompareKeys( byte[] left, byte[] right )
        {
            if (left == right)
                return true;

            if (left == null || right == null)
                return false;

            if (left.Length != right.Length)
                return false;

            for (int i = 0; i < left.Length; ++i)
            {
                if (left[i] != right[i])
                    return false;
            }

            return true;
        }

        static bool ThrowNonMicrosoftCodeGroup( MergeSemantic semantic )
        {
            return (semantic & MergeSemantic.ThrowNonMicrosoftCodeGroup) != 0;
        }

        static bool ThrowNonMicrosoftPermission( MergeSemantic semantic )
        {
            return (semantic & MergeSemantic.ThrowNonMicrosoftPermission) != 0;
        }

        static bool EatNonMicrosoftCodeGroup( MergeSemantic semantic )
        {
            return (semantic & MergeSemantic.EatNonMicrosoftCodeGroup) != 0;
        }

        static bool EatNonMicrosoftPermission( MergeSemantic semantic )
        {
            return (semantic & MergeSemantic.EatNonMicrosoftPermission) != 0;
        }

        static void FilterPolicyLevel( PolicyLevel level, MergeSemantic semantic )
        {
            FilterPermissionSets( level, semantic );

            FilterCodeGroups( level, semantic );
        }

        static void FilterPermissionSets( PolicyLevel level, MergeSemantic semantic )
        {
            IEnumerator setEnumerator = level.NamedPermissionSets.GetEnumerator();

            while (setEnumerator.MoveNext())
            {
                NamedPermissionSet alteredSet = (NamedPermissionSet) FilterPermissionSet( (NamedPermissionSet)setEnumerator.Current, semantic );

                if (alteredSet != null)
                {
                    level.ChangeNamedPermissionSet( alteredSet.Name, alteredSet );
                }
            }
        }

        static PermissionSet FilterPermissionSet( PermissionSet permSet, MergeSemantic semantic )
        {
            if (!ThrowNonMicrosoftPermission( semantic ) &&
                !EatNonMicrosoftPermission( semantic ))
            {
                return null;
            }

            PermissionSet alteredSet = null;

            IEnumerator permEnumerator = permSet.GetEnumerator();

            while (permEnumerator.MoveNext())
            {
                Type type = permEnumerator.Current.GetType();

                AssemblyName asm = type.Module.Assembly.GetName();

                byte[] publicKey = asm.GetPublicKey();

                if (!CompareKeys( publicKey, s_microsoftPublicKey ) &&
                    !CompareKeys( publicKey, s_ecmaPublicKey ))
                {
                    if (ThrowNonMicrosoftPermission( semantic ))
                        throw new AppException();

                    if (alteredSet == null)
                    {
                        alteredSet = permSet.Copy();
                    }

                    alteredSet.RemovePermission( type );
                }
            }

            return alteredSet;
        }

        static void FilterCodeGroups( PolicyLevel level, MergeSemantic semantic )
        {
            while (true)
            {
                String label = "1";

                CodeGroup group = FindNonMicrosoftCode( level.RootCodeGroup, -1, ref label, semantic );

                if (group == null)
                    break;

                if (ThrowNonMicrosoftCodeGroup( semantic ))
                    throw new AppException();
                else if (EatNonMicrosoftCodeGroup( semantic ))
                    ReplaceLabel( level, label, null );
            }

        }

        static CodeGroup FindNonMicrosoftCode( CodeGroup group, int recursive, ref String label, MergeSemantic semantic )
        {
            if (group == null)
                return null;

            PolicyStatement policy = group.PolicyStatement;
            PermissionSet permSet;
            PermissionSet alteredSet = null;

            if (policy != null)
            {
                permSet = policy.PermissionSet;

                if (permSet != null)
                {
                    alteredSet = FilterPermissionSet( permSet, semantic );
                }
            }

            if (alteredSet != null)
            {
                policy.PermissionSet = alteredSet;
                group.PolicyStatement = policy;
            }

            if (ThrowNonMicrosoftCodeGroup( semantic ) ||
                EatNonMicrosoftCodeGroup( semantic ))
            {
                Type type = group.GetType();

                AssemblyName asm = type.Module.Assembly.GetName();

                byte[] publicKey = asm.GetPublicKey();

                if (!CompareKeys( publicKey, s_microsoftPublicKey ) &&
                    !CompareKeys( publicKey, s_ecmaPublicKey ))
                {
                    return group;
                }

                IMembershipCondition cond = group.MembershipCondition;

                if (cond != null)
                {
                    type = cond.GetType();

                    asm = type.Module.Assembly.GetName();

                    publicKey = asm.GetPublicKey();

                    if (!CompareKeys( publicKey, s_microsoftPublicKey ) &&
                        !CompareKeys( publicKey, s_ecmaPublicKey ))
                    {
                        return group;
                    }
                }
            }

            if (recursive != 0)
            {
                int count = 1;

                IEnumerator enumerator = group.Children.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    String tempLabel = label + "." + count;
                    CodeGroup tempGroup = FindNonMicrosoftCode( (CodeGroup)enumerator.Current, recursive < 0 ? recursive : recursive - 1, ref tempLabel, semantic );

                    if (tempGroup != null)
                    {
                        label = tempLabel;
                        return tempGroup;
                    }

                    count++;
                }
            }

            return null;
        }


        static void UpgradeInternet( PolicyLevel level )
        {
            while (true)
            {
                String label = "1";

                CodeGroup group = FindInternetZone( level.RootCodeGroup, -1, ref label );

                if (group == null)
                    break;

                PolicyStatement policy = group.PolicyStatement;
                policy.PermissionSet = level.GetNamedPermissionSet( "Internet" );
                group.PolicyStatement = policy;
                NetCodeGroup netGroup = new NetCodeGroup( new AllMembershipCondition() );
                netGroup.Name = mscorlibManager.GetString( "Policy_InternetNet_Name" );
                netGroup.Description = mscorlibManager.GetString( "Policy_InternetNet_Description" );
                group.AddChild( netGroup );

                ReplaceLabel( level, label, group );
            }

        }

        static CodeGroup FindInternetZone( CodeGroup group, int recursive, ref String label )
        {
            if (group == null)
                return null;

            ZoneMembershipCondition cond = group.MembershipCondition as ZoneMembershipCondition;

            if (cond != null && cond.SecurityZone == SecurityZone.Internet)
            {
                if (group.PolicyStatement.PermissionSet.IsEmpty() &&
                    group.Children.Count == 0)
                    return group;
            }

            if (recursive != 0)
            {
                int count = 1;

                IEnumerator enumerator = group.Children.GetEnumerator();

                while (enumerator.MoveNext())
                {
                    String tempLabel = label + "." + count;
                    CodeGroup tempGroup = FindInternetZone( (CodeGroup)enumerator.Current, recursive < 0 ? recursive : recursive - 1, ref tempLabel );

                    if (tempGroup != null)
                    {
                        label = tempLabel;
                        return tempGroup;
                    }

                    count++;
                }
            }

            return null;
        }


        static void ReplaceLabel( PolicyLevel level, String label, CodeGroup obj )
        {
            if (label == null)
            {
                return;
            } 
            
            CodeGroup dummyGroup = new UnionCodeGroup( new AllMembershipCondition(), new PolicyStatement( new PermissionSet( PermissionState.None ) ) );
            if (obj == null)
            {
                obj = dummyGroup;
            }
    
            String[] separated = label.Split( m_labelSeparators.ToCharArray() );
            int size = separated[separated.Length-1] == null || separated[separated.Length-1].Equals( "" )
                            ? separated.Length-1 : separated.Length;
        
            if (size >= 1 && !separated[0].Equals( "1" ))
            {
                throw new ArgumentException( /*String.Format( manager.GetString( "Error_InvalidLabelArg" ), label )*/ );
            }
        
        
            CodeGroup group = level.RootCodeGroup;

            if (size == 1 && separated[0].Equals( "1" ))
            {
                level.RootCodeGroup = obj;
                return;
            }

            ArrayList groupsList = new ArrayList();
        
            CodeGroup newGroup = group;

            groupsList.Insert( 0, group );

            for (int index = 1; index < size - 1; ++index)
            {
                IEnumerator enumerator = group.Children.GetEnumerator();
                int count = 1;
            
                while (enumerator.MoveNext())
                {
                    if (count == Int32.Parse( separated[index] ))
                    {
                        newGroup = (CodeGroup)enumerator.Current;
                        break;
                    }
                    else
                    {
                        count++;
                    }
                }
            
                if (newGroup == null)
                    throw new ArgumentException( /*String.Format( manager.GetString( "Error_InvalidLabelArg" ), label )*/ );
                else
                {
                    group = newGroup;
                    groupsList.Insert( 0, group );
                }
            }

            groupsList.Insert( 0, obj );

            for (int i = 1; i < groupsList.Count; ++i)
            {
                newGroup = (CodeGroup)groupsList[i];

                IEnumerator finalEnumerator = newGroup.Children.GetEnumerator();

                newGroup.Children = new ArrayList();

                int finalCount = 1;
                while (finalEnumerator.MoveNext())
                {
                    if (finalCount == Int32.Parse( separated[size-i] ))
                    {
                        if (groupsList[i-1] != dummyGroup)
                            newGroup.AddChild( (CodeGroup)groupsList[i-1] );
                    }
                    else
                    {
                        newGroup.AddChild( (CodeGroup)finalEnumerator.Current );
                    }
                    finalCount++;
                }

            }

            level.RootCodeGroup = (CodeGroup)groupsList[groupsList.Count-1];        
        }
        
        
        static ArrayList GetInstalledVersions()
        {
            ArrayList list = new ArrayList();

            RegistryKey dotNetFrameworkPolicy = Registry.LocalMachine.OpenSubKey( "Software\\Microsoft\\.NetFramework\\policy" );

            String[] dotNetFrameworkPolicySubKeyNames = dotNetFrameworkPolicy.GetSubKeyNames();

            for (int i = 0; i < dotNetFrameworkPolicySubKeyNames.Length; ++i)
            {
                String mmVersion = dotNetFrameworkPolicySubKeyNames[i].Substring( 1 );
                RegistryKey policyKey = dotNetFrameworkPolicy.OpenSubKey( dotNetFrameworkPolicySubKeyNames[i] );

                String[] policyKeyValueNames = policyKey.GetValueNames();

                for (int j = 0; j < policyKeyValueNames.Length; ++j)
                {
                    try
                    {
                        Int32.Parse( policyKeyValueNames[j] );
                        list.Add( mmVersion + "." + policyKeyValueNames[j] );
                    }
                    catch (Exception)
                    {
                    }
                }
            }

            return list;
        }

        static ArrayList FilterVersions( ArrayList versionList, String toVersionStr )
        {
            ArrayList filteredList = new ArrayList();

            Version toVersion = new Version( toVersionStr );

            IEnumerator enumerator = versionList.GetEnumerator();

            while (enumerator.MoveNext())
            {
                Version version = new Version( (String)enumerator.Current );

                if (version.Major == toVersion.Major &&
                    version.Minor == toVersion.Minor)
                {
                    filteredList.Add( enumerator.Current );
                }
            }

            return filteredList;
        }

           
        static bool VerifyVersion( ArrayList versionList, String version )
        {
            IEnumerator enumerator = versionList.GetEnumerator();
            
            while (enumerator.MoveNext())
            {
                if (String.Compare( (String)enumerator.Current, version, false, CultureInfo.InvariantCulture ) == 0)
                {
                    return true;
                }
            }
            
            return false;
        }    
        
        static void ReplaceStringInFile( String fileName, String from, String to )
        {
            FileStream file = File.Open( fileName, FileMode.Open, FileAccess.Read | FileAccess.Write );
            
            StreamReader reader = new StreamReader( file );
            
            String data = reader.ReadToEnd();
            
            data = data.Replace( from, to );
            
            file.Position = 0;
            
            StreamWriter writer = new StreamWriter( file );
            
            writer.Write( data );
            
            writer.Close();
            
            file.Close();
        }   
        
        static String GetMscorlibVersionString()
        {
            Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies();
            
            for (int i = 0; i < assemblies.Length; ++i)
            {
                AssemblyName name = assemblies[i].GetName();
                
                if (String.Compare( name.Name, "mscorlib", false, CultureInfo.InvariantCulture ) == 0 &&
                    CompareKeys( name.GetPublicKey(), s_ecmaPublicKey ))
                {
                    return name.Version.ToString();
                }
            }

            return null;
        }

        static bool IsRTMSP( String fromVersionStr, int spNum )
        {
            RegistryKey regKey = Registry.LocalMachine.OpenSubKey( "Software\\Microsoft\\Active Setup\\Installed Components\\{78705f0d-e8db-4b2d-8193-982bdda15ecd}" );

            String version = (String)regKey.GetValue( "Version", "0,0,0,0" );

            Version regVersion = new Version( version.Replace( ",", "." ) );
            Version fromVersion = new Version( fromVersionStr );

            return regVersion.Major == fromVersion.Major &&
                   regVersion.Minor == fromVersion.Minor &&
                   regVersion.Build == fromVersion.Build &&
                   regVersion.Revision == spNum;
        }
        

////////// These are the individual option handlers.  These do all the
////////// real work.

        static void MigrateInHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_MigrateIn" ) );
                return;
            }
        
            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_MigrateIn" ), manager.GetString( "Error_NotEnoughArgs" ), (int)MigpolErrorCode.NotEnoughArgs );
            }

            String basePath = args[index+1];

            // Get the hierarchy levels.

            PolicyLevel hierarchyMachine = GetLevelFromHierarchy( "Machine" );
            PolicyLevel hierarchyEnterprise = GetLevelFromHierarchy( "Enterprise" );

            String mscorlibVersion = GetMscorlibVersionString();

            // Get the file levels.
            // @TODO: In the process of loading these files,
            // any types that are not available to this version of the Runtime
            // will fail to load.  How do we handle errors of that nature?

            // Now we sweep through the output files and replace version strings

            // Transfer data from the files to the hierarchy and save
            // the changes (thereby "migrating in").

            bool save = true;
            PolicyLevel fileMachine = null;
            PolicyLevel fileEnterprise = null;

            try
            {
                for (int i = 0; i < m_replaceStringTemplate.Length; ++i)
                {
                    ReplaceStringInFile( basePath + "\\security.config", m_intermediateString[i], String.Format( m_replaceStringTemplate[i], mscorlibVersion ) );
                }

                if (!SupportsBindingRedirects())
                {
                    ReplaceStringInFile( basePath + "\\security.config", "BindingRedirects,", "" );
                    ReplaceStringInFile( basePath + "\\security.config", ", BindingRedirects", "" );
                    ReplaceStringInFile( basePath + "\\security.config", "BindingRedirects", "" );
                }

                fileMachine = SecurityManager.LoadPolicyLevelFromFile( basePath + "\\security.config", PolicyLevelType.Machine );
            }
            catch (Exception)
            {
                save = false;
            }

            try
            {
                for (int i = 0; i < m_replaceStringTemplate.Length; ++i)
                {
                    ReplaceStringInFile( basePath + "\\enterprisesec.config", m_intermediateString[i], String.Format( m_replaceStringTemplate[i], mscorlibVersion ) );
                }

                if (!SupportsBindingRedirects())
                {
                    ReplaceStringInFile( basePath + "\\enterprisesec.config", "BindingRedirects,", "" );
                    ReplaceStringInFile( basePath + "\\enterprisesec.config", ", BindingRedirects", "" );
                    ReplaceStringInFile( basePath + "\\enterprisesec.config", "BindingRedirects", "" );
                }

                fileEnterprise = SecurityManager.LoadPolicyLevelFromFile( basePath + "\\enterprisesec.config", PolicyLevelType.Enterprise );
            }
            catch (Exception)
            {
                save = false;
            }

            if (save && fileMachine != null && fileEnterprise != null)
            {
                TransferDataAndSave( fileMachine, hierarchyMachine );
                TransferDataAndSave( fileEnterprise, hierarchyEnterprise );
            }

            if (m_displayInternalOptions)
                m_success = true;
        }

        static void MigrateOutHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_MigrateOut" ) );
                return;
            }
        
            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_MigrateOut" ), manager.GetString( "Error_NotEnoughArgs" ), (int)MigpolErrorCode.NotEnoughArgs );
            }

            String basePath = args[index+1];

            // We need to create dummy policy level files.  These need to
            // be version specific to the version we are moving from, but luckily
            // for now all the versions are compatible.  Let's just grab the enterprise
            // level from the hierarchy and spit it out into two files.

            PolicyLevel hierarchyMachine = GetLevelFromHierarchy( "Machine" );
            PolicyLevel hierarchyEnterprise = GetLevelFromHierarchy( "Enterprise" );

            SecurityElement elConf = new SecurityElement( "configuration" );
            SecurityElement elMscorlib = new SecurityElement( "mscorlib" );
            SecurityElement elSecurity = new SecurityElement( "security" );
            SecurityElement elPolicy = new SecurityElement( "policy" );
                    
            elConf.AddChild( elMscorlib );
            elMscorlib.AddChild( elSecurity );
            elSecurity.AddChild( elPolicy );
            elPolicy.AddChild( hierarchyEnterprise.ToXml() );
                    
            String strPolicyLevel = elConf.ToString();

            WriteStringToFile( basePath + "\\security.config", strPolicyLevel );
            WriteStringToFile( basePath + "\\enterprisesec.config", strPolicyLevel );

            PolicyLevel fileMachine = SecurityManager.LoadPolicyLevelFromFile( basePath + "\\security.config", PolicyLevelType.Machine );
            PolicyLevel fileEnterprise = SecurityManager.LoadPolicyLevelFromFile( basePath + "\\enterprisesec.config", PolicyLevelType.Enterprise );

            TransferData( hierarchyMachine, fileMachine );
            TransferData( hierarchyEnterprise, fileEnterprise );

            bool saveMachine = true;
            bool saveEnterprise = true;

            if ((m_mergeSemantic & MergeSemantic.UpgradeInternet) != 0)
            {
                UpgradeInternet( fileMachine );
                UpgradeInternet( fileEnterprise );
            }    

            try
            {
                FilterPolicyLevel( fileMachine, m_mergeSemantic );
                FilterPolicyLevel( fileEnterprise, m_mergeSemantic );
            }
            catch (AppException)
            {
                saveMachine = false;
                saveEnterprise = false;
            }

            String mscorlibVersion = GetMscorlibVersionString();

            if (saveMachine)
            {
                try
                {
                    SecurityManager.SavePolicyLevel( fileMachine );
                }
                catch
                {
                    Error( manager.GetString( "OptionTable_MigrateOut" ), manager.GetString( "MigpolErrorCode_UnableToSavePolicy" ), (int)MigpolErrorCode.UnableToSavePolicy );
                }

                for (int i = 0; i < m_replaceStringTemplate.Length; ++i)
                {
                    ReplaceStringInFile( basePath + "\\security.config", String.Format( m_replaceStringTemplate[i], mscorlibVersion ), m_intermediateString[i] );
                }
            }
            else
            {
                File.Delete( basePath + "\\security.config" );
            }

            if (saveEnterprise)
            {
                try
                {
                    SecurityManager.SavePolicyLevel( fileEnterprise );
                }
                catch
                {
                    Error( manager.GetString( "OptionTable_MigrateOut" ), manager.GetString( "MigpolErrorCode_UnableToSavePolicy" ), (int)MigpolErrorCode.UnableToSavePolicy );
                }

                for (int i = 0; i < m_replaceStringTemplate.Length; ++i)
                {
                    ReplaceStringInFile( basePath + "\\enterprisesec.config", String.Format( m_replaceStringTemplate[i], mscorlibVersion ), m_intermediateString[i] );
                }
            }
            else
            {
                File.Delete( basePath + "\\enterprisesec.config" );
            }

            if (m_displayInternalOptions)
                m_success = true;
        }

        static void MigrateHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Migrate" ) );
                return;
            }
        
            numArgsUsed = 2;

            if (args.Length - index < 2)
            {
                Error( manager.GetString( "OptionTable_Migrate" ), manager.GetString( "Error_NotEnoughArgs" ), (int)MigpolErrorCode.NotEnoughArgs );
            }

            String toVersion = args[index+1];
            String fromVersion = null;

            // Check for optional third param

            if (args.Length - index > 2)
            {
                bool isOption = false;

                for (int i = 0; i < optionTable.Length; ++i)
                {
                    if (args[index+2][0] == '/')
                    {
                        args[index+2] = '-' + args[index+2].Substring( 1, args[index+2].Length - 1 );
                    }

                    if (String.Compare( optionTable[i].option, args[index+2], true, CultureInfo.InvariantCulture) == 0)
                    {
                        isOption = true;
                        break;
                    }
                }

                if (!isOption)
                {
                    numArgsUsed = 3;
                    fromVersion = args[index+2];
                }
            }

            ArrayList list = GetInstalledVersions();

            if (list.Count <= 1)
            {
                Error( manager.GetString( "OptionTable_Migrate" ), manager.GetString( "Error_OnlyOneVersionInstalled" ), (int)MigpolErrorCode.Success, false );
            }

            if (fromVersion == null)
            {
                ArrayList filteredList = FilterVersions( list, toVersion );

                if (filteredList.Count != 2)
                {
                    Error( manager.GetString( "OptionTable_Migrate" ), manager.GetString( "Error_MustSpecifyTwoVersions" ), (int)MigpolErrorCode.Generic );
                }
                
                if (String.Compare( (String)filteredList[0], toVersion, false, CultureInfo.InvariantCulture ) == 0)
                {
                    fromVersion = (String)filteredList[1];
                }
                else
                {
                    fromVersion = (String)filteredList[0];
                }
            }

            if (!VerifyVersion( list, toVersion ))
            {
                Error( manager.GetString( "OptionTable_Migrate" ), String.Format( manager.GetString( "Error_InvalidVersion" ), toVersion ), (int)MigpolErrorCode.Generic );
            }

            if (!VerifyVersion( list, fromVersion ))
            {
                Error( manager.GetString( "OptionTable_Migrate" ), String.Format( manager.GetString( "Error_InvalidVersion" ), fromVersion ), (int)MigpolErrorCode.Generic );
            }

            if (String.Compare( toVersion, fromVersion, true, CultureInfo.InvariantCulture ) == 0)
            {
                Error( manager.GetString( "OptionTable_Migrate" ), manager.GetString( "Error_SameVersion" ), (int)MigpolErrorCode.Generic );
            }

            // Detect if the version we are coming from is RTM SP1 or SP2.  If
            // so, we want to upgrade the Internet.

            if (IsRTMSP( fromVersion, 1 ) || IsRTMSP( fromVersion, 2 ))
                m_mergeSemantic |= MergeSemantic.UpgradeInternet;

            // We need to know the location of the exe so that we can copy it
            // to a temp path.

            String exeFilePath = GetExePath();
            String tempFilePath = GetTempPath();

            String baseFilePath;
            
            if (m_useCurrent)
                baseFilePath = ".";
            else
                baseFilePath = tempFilePath;


            // We need to make a shadow copy of the exe in our temp path
            // so that config files can be dropped in the same directory
            // and a specific runtime targetted.

            File.Copy( exeFilePath, baseFilePath + "\\migpolwin.exe", true );

            // @TODO: detect if either of the processes failed and
            // report that error appropriately.

            // Build up any additional command line args.

            String cmdLinePrefix = "";

            if (m_debugBreak)
            {
                cmdLinePrefix += manager.GetString( "OptionTable_DebugBreak" ) + " ";
            }

            if ((m_mergeSemantic & MergeSemantic.UpgradeInternet) != 0)
            {
                cmdLinePrefix += manager.GetString( "OptionTable_UpgradeInternet" ) + " ";
            }

            // Start the first worker process.  This guy runs on top
            // of the Runtime version that we are migrating from.

            String fromConfigFile = m_configFile.Replace( "{VERSION}", fromVersion );

            WriteStringToFile( baseFilePath + "\\migpolwin.exe.config", fromConfigFile );

            Process migrateOutProc = Process.Start( baseFilePath + "\\migpolwin.exe", cmdLinePrefix + "-migrateout \"" + baseFilePath + "\"" );
            migrateOutProc.WaitForExit();
            
            if (migrateOutProc.ExitCode != (int)MigpolErrorCode.Success)
            {
                Error( manager.GetString( "OptionTable_Migrate" ), GetErrorCodeString( (MigpolErrorCode)migrateOutProc.ExitCode ), migrateOutProc.ExitCode );
            }

            // Now start the second worker process.  This guy runs on top
            // of the Runtime version that we are migrating to.

            String toConfigFile = m_configFile.Replace( "{VERSION}", toVersion );

            WriteStringToFile( baseFilePath + "\\migpolwin.exe.config", toConfigFile );

            Process migrateInProc = Process.Start( baseFilePath + "\\migpolwin.exe", cmdLinePrefix + "-migratein \"" + baseFilePath + "\"" );
            migrateInProc.WaitForExit(); 

            if (migrateInProc.ExitCode != (int)MigpolErrorCode.Success)
            {
                Error( manager.GetString( "OptionTable_Migrate" ), GetErrorCodeString( (MigpolErrorCode)migrateInProc.ExitCode ), migrateInProc.ExitCode );
            }

            // Delete our temp files

            // Here we will loop since this process is racing against the
            // OS to get a lock on this file.  If we just chill out and
            // retry to delete the file, we should eventually get to delete
            // it.  If someone really is holding the file for other reasons,
            // we'll just leave it there (it's in a temporary directory so
            // that should be fine).

            bool done = false;
            int count = 0;

            while (!done && count < m_retryAttempts)
            {
                count++;
                try
                {
                    File.Delete( baseFilePath + "\\migpolwin.exe" );
                    done = true;
                }
                catch (Exception)
                {
                }
            }

            Directory.Delete( baseFilePath, true );

            PauseCapableWriteLine( String.Format( manager.GetString( "Dialog_MigrateFromTo" ), fromVersion, toVersion ) );

            m_success = true;
        }

        static void ListVersionsHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_ListVersions" ) );
                return;
            }
        
            ArrayList list = GetInstalledVersions();

            Console.WriteLine( manager.GetString( "Dialog_InstalledVersions" ) );

            IEnumerator enumerator = list.GetEnumerator();

            while (enumerator.MoveNext())
            {
                Console.WriteLine( enumerator.Current );
            }

            m_success = true;
        }

        static void DebugBreakHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_DebugBreak" ) );
                return;
            }
        
            System.Diagnostics.Debugger.Break();
        }

        static void DebugHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Debug" ) );
                return;
            }
        
            m_debugBreak = true;
            m_useCurrent = true;
        }

        static void UpgradeInternetHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_UpgradeInternet" ) );
                return;
            }
        
            m_mergeSemantic |= MergeSemantic.UpgradeInternet;
        }
         
        static void HelpHandler( String[] args, int index, out int numArgsUsed )
        {
            numArgsUsed = 1;

            if (args[index].Equals( "__internal_usage__" ))
            {
                PauseCapableWriteLine( manager.GetString( "Help_Option_Help" ) );
                return;
            }
        
            m_success = false;

            Help( null, manager.GetString( "Dialog_HelpScreen" ), true );
        }        
            
    }


    internal enum SecurityElementType
    {
        Regular = 0,
        Format = 1,
        Comment = 2
    }


    sealed internal class Parser
    {
        private SecurityElement   _ecurr = null ;
        private Tokenizer _t     = null ;
    
        public SecurityElement GetTopElement()
        {
            return (SecurityElement)_ecurr.Children[0];
        }

        public Encoding GetEncoding()
        {
            return _t.GetEncoding();
        }
    
        private void ParseContents (SecurityElement e, bool restarted)
        {
            //
            // Iteratively collect stuff up until the next end-tag.
            // We've already seen the open-tag.
            //

            SecurityElementType lastType = SecurityElementType.Regular;

            ParserStack stack = new ParserStack();
            ParserStackFrame firstFrame = new ParserStackFrame();
            firstFrame.element = e;
            firstFrame.intag = false;
            stack.Push( firstFrame );
            
            bool needToBreak = false;
            bool needToPop = false;
            
            int i;

            do
            {
                ParserStackFrame locFrame = stack.Peek();
                
                for (i = _t.NextTokenType () ; i != -1 ; i = _t.NextTokenType ())
                {
                    switch (i)
                    {
                    case Tokenizer.cstr:
                        {
                            if (locFrame.intag)
                            {
                                if (locFrame.type == SecurityElementType.Comment)
                                {
                                    String appendString;

                                    if (locFrame.sawEquals)
                                    {
                                        appendString = "=\"" + _t.GetStringToken() + "\"";
                                        locFrame.sawEquals = false;
                                    }
                                    else
                                    {
                                        appendString = " " + _t.GetStringToken();
                                    }

                                    // Always set this directly since comments are not subjected
                                    // to the same restraints as other element types.  The strings
                                    // are all escaped so this shouldn't be a problem.

                                    locFrame.element.Tag = locFrame.element.Tag + appendString;
                                }
                                else
                                {
                                    // We're in a regular tag, so we've found an attribute/value pair.
                                
                                    if (locFrame.strValue == null)
                                    {
                                        // Found attribute name, save it for later.
                                    
                                        locFrame.strValue = _t.GetStringToken ();
                                    }
                                    else
                                    {
                                        // Found attribute text, add the pair to the current element.

                                        if (!locFrame.sawEquals)
                                            throw new XmlSyntaxException( _t.LineNo );

                                        locFrame.element.AddAttribute( locFrame.strValue, _t.GetStringToken() );

                                        locFrame.strValue = null;
                                    }
                                }
                            }
                            else
                            {
                                // We're not in a tag, so we've found text between tags.
                                
                                if (locFrame.element.Text == null)
                                    locFrame.element.Text = "" ;
    
                                StringBuilder sb = new StringBuilder (locFrame.element.Text) ;
    
                                //
                                // Separate tokens with single spaces, collapsing whitespace
                                //
                                if (!locFrame.element.Text.Equals (""))
                                    sb.Append (" ") ;
                            
                                sb.Append (_t.GetStringToken ()) ;
                                locFrame.element.Text = sb.ToString ();
                            }
                        }
                        break ;
        
                    case Tokenizer.bra:
                        locFrame.intag = true;
                        i = _t.NextTokenType () ;
    
                        if (i == Tokenizer.slash)
                        {
                            while (true)
                            {
                                // spin; don't care what's in here
                                i = _t.NextTokenType();
                                if (i == Tokenizer.cstr)
                                    continue;
                                else if (i == -1)
                                    throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_UnexpectedEndOfFile" ));
                                else
                                    break;
                            }
        
                            if (i != Tokenizer.ket)
                            {
                                    throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                            }
         
                            locFrame.intag = false;
         
                            // Found the end of this element
                            lastType = stack.Peek().type;
                            stack.Pop();
                            
                            needToBreak = true;

                        }
                        else if (i == Tokenizer.cstr)
                        {
                            // Found a child
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement (_t.GetStringToken() );
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.bang)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            ParserStackFrame newFrame = new ParserStackFrame();
        
                            newFrame.status = 1;

                            do
                            {
                                i = _t.NextTokenType();

                                if (newFrame.status < 3)
                                {
                                    if (i != Tokenizer.dash)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        newFrame.status++;
                                }
                                else
                                {
                                    if (i != Tokenizer.cstr)
                                        throw new XmlSyntaxException( _t.LineNo );
                                    else
                                        break;
                                }
                            }
                            while (true);                                    

                            
                            newFrame.element = new SecurityElement (_t.GetStringToken());

                            newFrame.type = SecurityElementType.Comment;
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else if (i == Tokenizer.quest)
                        {
                            // Found a child that is a format node.  Next up better be a cstr.

                            i = _t.NextTokenType();

                            if (i != Tokenizer.cstr)
                                throw new XmlSyntaxException( _t.LineNo );
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement ( _t.GetStringToken());

                            newFrame.type = SecurityElementType.Format;
                            
                            if (locFrame.type != SecurityElementType.Regular)
                                throw new XmlSyntaxException( _t.LineNo );

                            locFrame.element.AddChild (newFrame.element) ;
                            
                            newFrame.status = 1;

                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else   
                        {
                            throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_ExpectedSlashOrString" ));
                        }
                        break ;
        
                    case Tokenizer.equals:
                        locFrame.sawEquals = true;
                        break;
                        
                    case Tokenizer.ket:
                        if (locFrame.intag)
                        {
                            locFrame.intag = false;
                            continue;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_UnexpectedCloseBracket" ));
                        }
                        // not reachable
                        
                    case Tokenizer.slash:
                        locFrame.element.Text = null;
                        
                        i = _t.NextTokenType ();
                        
                        if (i == Tokenizer.ket)
                        {
                            // Found the end of this element
                            lastType = stack.Peek().type;
                            stack.Pop();
                            
                            needToBreak = true;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                        }
                        break;
                        
                    case Tokenizer.quest:
                        if (locFrame.intag && locFrame.type == SecurityElementType.Format && locFrame.status == 1)
                        {
                            i = _t.NextTokenType ();

                            if (i == Tokenizer.ket)
                            {
                                lastType = stack.Peek().type;
                                stack.Pop();

                                needToBreak = true;
                            }
                            else
                            {
                                throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    case Tokenizer.dash:
                        if (locFrame.intag && (locFrame.status > 0 && locFrame.status < 5) && locFrame.type == SecurityElementType.Comment)
                        {
                            locFrame.status++;

                            if (locFrame.status == 5)
                            {
                                i = _t.NextTokenType ();

                                if (i == Tokenizer.ket)
                                {
                                    lastType = stack.Peek().type;
                                    stack.Pop();

                                    needToBreak = true;
                                }
                                else
                                {
                                    throw new XmlSyntaxException (_t.LineNo, MigPol.manager.GetString( "XMLSyntax_ExpectedCloseBracket" ));
                                }
                            }
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        break;

                    default:
                        throw new XmlSyntaxException (_t.LineNo) ;
                    }
                    
                    if (needToBreak)
                    {
                        needToBreak = false;
                        needToPop = false;
                        break;
                    }
                    else
                    {
                        needToPop = true;
                    }
                }
                if (needToPop)
                {
                    lastType = stack.Peek().type;
                    stack.Pop();
                }
                else if (i == -1 && stack.GetCount() != 1)
                {
                    // This means that we still have items on the stack, but the end of our
                    // stream has been reached.

                    throw new XmlSyntaxException( _t.LineNo, MigPol.manager.GetString( "XMLSyntax_UnexpectedEndOfFile" ));
                }
            }
            while (stack.GetCount() > 1);

            SecurityElement topElement = this.GetTopElement();

            if (lastType == SecurityElementType.Format)
            {
                if (restarted)
                    throw new XmlSyntaxException( _t.LineNo );

                String format = topElement.Attribute( "encoding" );

                if (format != null)
                {
                    _t.ChangeFormat( System.Text.Encoding.GetEncoding( format ) );
                }

                _ecurr = new SecurityElement( "junk" );
                ParseContents( _ecurr, true );
            }

            
        }
    
        private Parser(Tokenizer t)
        {
            _t = t;
            _ecurr       = new SecurityElement( "junk" );

            ParseContents (_ecurr, false) ;
        }
        
        public Parser (String input)
            : this (new Tokenizer (input))
        {
        }
    
        public Parser (BinaryReader input)
            : this (new Tokenizer (input))
        {
        }
       
        public Parser( byte[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
        public Parser( StreamReader input )
            : this (new Tokenizer( input ) )
        {
        }
        
        public Parser( Stream input )
            : this (new Tokenizer( input ) )
        {
        }
        
        public Parser( char[] array )
            : this (new Tokenizer( array ) )
        {
        }
        
    }                                              
    
    
    internal class ParserStackFrame
    {
        internal SecurityElement element = null;
        internal bool intag = true;
        internal String strValue = null;
        internal int status = 0;
        internal bool sawEquals = false;
        internal SecurityElementType type = SecurityElementType.Regular;
    }
    
    
    internal class ParserStack
    {
        private ArrayList m_array;
        
        public ParserStack()
        {
            m_array = new ArrayList();
        }
        
        public void Push( ParserStackFrame element )
        {
            m_array.Add( element );
        }
        
        public ParserStackFrame Pop()
        {
            if (!IsEmpty())
            {
                int count = m_array.Count;
                ParserStackFrame temp = (ParserStackFrame) m_array[count-1];
                m_array.RemoveAt( count-1 );
                return temp;
            }
            else
            {
                throw new InvalidOperationException( MigPol.manager.GetString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        public ParserStackFrame Peek()
        {
            if (!IsEmpty())
            {
                return (ParserStackFrame) m_array[m_array.Count-1];
            }
            else
            {
                throw new InvalidOperationException( MigPol.manager.GetString( "InvalidOperation_EmptyStack" ) );
            }
        }
        
        public bool IsEmpty()
        {
            return m_array.Count == 0;
        }
        
        public int GetCount()
        {
            return m_array.Count;
        }
        
    }


    internal class Tokenizer 
    {
        private ITokenReader         _input;
        private bool             _fintag;
        private StringBuilder       _cstr;
        private char[]              _sbarray;
        private int                 _sbindex;
        private const int          _sbmaxsize = 128;
    
        // There are five externally knowable token types: bras, kets,
        // slashes, cstrs, and equals.  
    
        internal const int bra     = 0;
        internal const int ket     = 1;
        internal const int slash   = 2;
        internal const int cstr    = 3;
        internal const int equals  = 4;
        internal const int quest   = 5;
        internal const int bang    = 6;
        internal const int dash    = 7;

        internal const int intOpenBracket = (int) '<';
        internal const int intCloseBracket = (int) '>';
        internal const int intSlash = (int) '/';
        internal const int intEquals = (int) '=';
        internal const int intQuote = (int) '\"';
        internal const int intQuest = (int) '?';
        internal const int intBang = (int) '!';
        internal const int intDash = (int) '-';
    
        public int  LineNo;
    
        //================================================================
        // Constructor uses given ICharInputStream
        //

        internal Tokenizer (String input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StringTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        

        internal Tokenizer (BinaryReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new TokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (byte[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new ByteTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
        
        internal Tokenizer (char[] array)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new CharTokenReader(array) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }        
        
        internal Tokenizer (StreamReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }
    
        internal Tokenizer (Stream input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _cstr    = null  ;
            _input   = new StreamTokenReader(new StreamReader( input )) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;            
        }


        internal void ChangeFormat( System.Text.Encoding encoding )
        {
            if (encoding == null)
            {
                return;
            }

            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return;
            }

            Stream stream = reader._in.BaseStream;

            String fakeReadString = new String( new char[reader.NumCharEncountered] );

            stream.Position = reader._in.CurrentEncoding.GetByteCount( fakeReadString );

            _input = new StreamTokenReader( new StreamReader( stream, encoding ) );
        }

        internal System.Text.Encoding GetEncoding()
        {
            StreamTokenReader reader = _input as StreamTokenReader;

            if (reader == null)
            {
                return null;
            }
            
            return reader._in.CurrentEncoding;
        }

   
        //================================================================
        // 
        //
        private bool FIsWhite (int j)
        {
            if ((j == 10) && (_input.Peek() != -1))
                LineNo ++ ;
    
            bool retval =  (j == 32) || (j ==  9)  // Space and tab
                        || (j == 13) || (j == 10); // CR and LF
         
            return retval;
                
        }
    
        //================================================================
        // Parser needs to know types of tokens
        //
        private void SBArrayAppend(char c) {
            // this is the common case
            if (_sbindex != _sbmaxsize) {
                _sbarray[_sbindex] = c;
                _sbindex++;
                return;
            } 
            // OK, first check if we have to init the StringBuilder
            if (_cstr == null) {
                _cstr = new StringBuilder();
            }
            // OK, copy from _sbarray to _cstr
            _cstr.Append(_sbarray,0,_sbmaxsize);
            // reset _sbarray pointer
            _sbarray[0] = c;
            _sbindex = 1;
            return;
        }
        
        internal int NextTokenType()
        {
            _cstr = null;
            _sbindex = 0;
            int i;
            
            i = _input.Read();
        BEGINNING_AFTER_READ:            
        
            switch (i)
            {
            case -1:
                return -1;
                
            case intOpenBracket:
                _fintag = true;
                return bra;
                
            case intCloseBracket:
                _fintag = false;
                return ket;
                
            case intEquals:
                return equals;
                
            case intSlash:
                if (_fintag) return slash;
                goto default;

            case intQuest:
                if (_fintag) return quest;
                goto default;

            case intBang:
                if (_fintag) return bang;
                goto default;

            case intDash:
                if (_fintag) return dash;
                goto default;
                
            default:
                // We either have a string or whitespace.
                if (FIsWhite( i ))
                {
                    do
                    {
                        i = _input.Read();
                    } while (FIsWhite( i ));
                    
                    goto BEGINNING_AFTER_READ;
                }
                else
                {
                    // The first and last characters in a string can be quotes.
                    
                    bool inQuotedString = false;

                    if (i == intQuote)
                    {
                        inQuotedString = true;
                        i = _input.Read();

                        if (i == intQuote)
                            return cstr;
                    }

                    do
                    {
                        SBArrayAppend( (char)i );
                        i = _input.Peek();
                        if (!inQuotedString && (FIsWhite( i ) || i == intOpenBracket || (_fintag && (i == intCloseBracket || i == intEquals || i == intSlash))))
                            break;
                        _input.Read();
                        if (i == intQuote && inQuotedString)
                            break;
                        if (i == -1)
                            return -1;
                    } while (true);
                    
                    return cstr;
                }
            }
            
        }
        

        //================================================================
        //
        //
        
        internal String GetStringToken ()
        {
            // OK, easy case first, _cstr == null
            if (_cstr == null) {
                // degenerate case
                if (_sbindex == 0) return("");
                return(new String(_sbarray,0,_sbindex));
            }
            // OK, now we know we have a StringBuilder already, so just append chars
            _cstr.Append(_sbarray,0,_sbindex);
            return(_cstr.ToString());
        }
    
        internal interface ITokenReader
        {
            int Peek();
            int Read();
        }
    
        internal class ByteTokenReader : ITokenReader {
            private byte[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal ByteTokenReader( byte[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }

        internal class StringTokenReader : ITokenReader {
            private String _input;
            private int _currentIndex;
            private int _inputSize;
            
            internal StringTokenReader( String input )
            {
                _input = input;
                _currentIndex = 0;
                _inputSize = input.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _inputSize)
                {
                    return -1;
                }
                else
                {
                    return (int)_input[_currentIndex++];
                }
            }
        } 
        
        internal class CharTokenReader : ITokenReader {
            private char[] _array;
            private int _currentIndex;
            private int _arraySize;
            
            internal CharTokenReader( char[] array )
            {
                _array = array;
                _currentIndex = 0;
                _arraySize = array.Length;
            }
            
            public virtual int Peek()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex];
                }
            }
            
            public virtual int Read()
            {
                if (_currentIndex == _arraySize)
                {
                    return -1;
                }
                else
                {
                    return (int)_array[_currentIndex++];
                }
            }
        }        
                
        internal class TokenReader : ITokenReader {
    
            private BinaryReader _in;
    
            internal TokenReader(BinaryReader input) {
                _in = input;
            }
    
            public virtual int Peek() {
                return _in.PeekChar();
            }
    
            public virtual int Read() {
                return _in.Read();
            }
        }
        
        internal class StreamTokenReader : ITokenReader {
            
            internal StreamReader _in;
            internal int _numCharRead;
            
            internal StreamTokenReader(StreamReader input) {
                _in = input;
                _numCharRead = 0;
            }
            
            public virtual int Peek() {
                return _in.Peek();
            }
            
            public virtual int Read() {
                int value = _in.Read();
                if (value != -1)
                    _numCharRead++;
                return value;
            }

            internal int NumCharEncountered
            {
                get
                {
                    return _numCharRead;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\mscoverage\ilcover.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.Coverage {

    using System;
    using System.Security;
	using System.Runtime.InteropServices;

    public class ILCover
    {

        [DllImport("ilcovnat", CharSet=CharSet.Auto),
         SuppressUnmanagedCodeSecurityAttribute()]
        public static extern void CoverMethodNative(int token, int numbb);

        [DllImport("ilcovnat", CharSet=CharSet.Auto),
         SuppressUnmanagedCodeSecurityAttribute()]
        public static extern void CoverBlockNative(int token, int bbnun, int totalbb);

        [DllImport("ilcovnat", CharSet=CharSet.Auto),
         SuppressUnmanagedCodeSecurityAttribute()]
        public static extern void BBInstrProbe(int mdt, int offset, int iscall, int size);


    	public static void CoverMethod(int token, int bbcount)
    	{
           	CoverMethodNative(token, bbcount);
    	}

    	public static void CoverBlock(int compid, int BVidx, int totalbb)
    	{
   			CoverBlockNative(compid, BVidx, totalbb);
    	}

    	public static void BBInstrMProbe(int mdt, int offset, int iscall, int size)
    	{
			BBInstrProbe(mdt, offset, iscall, size);
		}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\namesgen\names.cs ===
//
//	Balanced tree implementation
//

using System;
using System.IO;
using System.Collections;

namespace NamesGen
{
	public	class Names : BalancedTree
	{
		public Names(IComparable v) : base(v)
		{
		}

		public static new BalancedTree LoadFromFile(string filename)
		{
			BalancedTree tree = null;
			StreamReader r = new StreamReader(filename, true);
			string str;
	 		while ((str=r.ReadLine()) != null)
	 		{
	 			Guid guid = Guid.Empty;

	 			// Pick apart bits
	            int cKeep = str.IndexOf('#');
	            if (cKeep >= 0)
	            {
	            	if(cKeep < str.Length)
	            	{
	            		try
	            		{
	            			guid = new Guid(str.Substring(cKeep + 1, str.Length-1-cKeep));
	            		}
	            		catch(Exception)			// Swallow exceptions since they were due to trying to turn a comment into a guid
	            		{
	            		}
		            	str = str.Substring(0, cKeep);
		            }
	            }

	        	// Trim whitespace and don't consider blank lines
	            str = str.Trim();
	            if (str.Length == 0) continue;

	            if(tree == null)
					tree = new Names(new Name(str, false, guid));
				else
					tree.Insert(new Name(str, false, guid));
			}
			r.Close();
			return tree;


		}
	}

	public class Name : IComparable
	{
		private Guid m_uuid;
		private Guid m_newuuid;
		private bool m_found;
		private string m_value;

		public Name(string value, bool found, Guid uuid)
		{
			m_value = value;
			m_found = found;
			m_uuid = uuid;
			m_newuuid = Guid.Empty;
		}
		int IComparable.CompareTo(object obj)
		{
			Name cmp = (Name)obj;
			return m_value.CompareTo(cmp.m_value);
		}
		public Guid	UUID
		{
			get { return m_uuid; }
			set { m_uuid=value; }
		}
		public Guid	NEWUUID
		{
			get { return m_newuuid; }
			set { m_newuuid=value; }
		}
		public bool Found
		{
			get { return m_found; }
			set { m_found=value; }
		}
		public string Value
		{
			get { return m_value; }
			set { m_value=Value; }
		}
		public override string ToString()
		{
			if(UUID != Guid.Empty)
				return Value.ToString() + "\t\t# " + UUID.ToString();
			else
				return Value.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\namesgen\programbase.cs ===
using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Text;
using System.Globalization;

namespace NamesGen
{
	public class	ProgramBase
	{
		protected class Option
		{
			public Option (string v, string a, string d, bool p)
			{
				value = v;
				alias = a;
				description = d;
				parameterized = p;
			}

			public override string ToString()
			{
				string reply = "";

				if (value != "")
				{
					reply = ("    " + value);
					if(alias != "")
					{
						reply += (" or " + alias);
					}
					reply += ("\t" + description);
				}
				return reply;
			}

			public string	value;
			public string	alias;
			public string	description;
			public bool		parameterized;
		};

		protected	class Setting
		{
			public Setting(Option opt, string val)
			{
				option = opt;
				value = val;
			}
			public Option option;
			public string value;
		};

		static protected string name = "Program Base";
		static protected string description = " The name and description must be provided by derived classes.";
		static protected string syntax = "Program Base - [Options] - override in derived class to provide your own.";
		static protected string where = "";

		static private Option[] baseoptions =
						 {
							new Option ("/silent",	"","\t\tPrevents the display of operational messages.", false),
							new Option ("/?", "/help", "\t\tDisplay this usage message.", false)
						 };
		static protected Option[] options;

		static public void PrintLogo()
		{
			Console.WriteLine("Microsoft (R) " + name + " - " + description + " " /*+ Version.VersionString*/);
			Console.WriteLine("Copyright (C) Microsoft Corp. 2000.  All rights reserved.");
			Console.WriteLine("");
		}

		static public	void PrintUsage()
		{
			Console.WriteLine("Syntax: " + syntax);
			if (where != "")
			{
				Console.WriteLine("Where:\n    {0}\n", where);
			}
			Console.WriteLine("Options:");
			if (options.Length > 0)
			{
				foreach(Option o in options)
				{
					Console.WriteLine(o);
				}
			}
			foreach(Option o in baseoptions)
			{
				Console.WriteLine(o);
			}
		}

		// ParseArguments returns true to indicate the program should continue and false otherwise.
		// If it returns false then the return code will be set to the return value that should
		// be returned by the program.
		protected static Setting[] GetSwitches(String []args)
		{
			ArrayList reply = new ArrayList();
			Option[] opts = new Option[baseoptions.Length + options.Length];
			baseoptions.CopyTo(opts, 0);
			options.CopyTo(opts, baseoptions.Length);

			foreach (string s in args)
			{
				if (s != "")
				{
					int	index = 0;

					// Is it a valid switch
					if (CompareString(s, "/") == 0)
					{
						// Is the part before the : a valid switchar
						foreach(Option o in opts)
						{
							// Split parameter into bit before : and the bit after
							string pAfter;
							string pBefore;
							Split(s, ':', out pBefore, out pAfter);

							string oAfter;
							string oBefore;
							Split(o.value, ':', out oBefore, out oAfter);
							if (String.Compare(pBefore, oBefore, true, CultureInfo.InvariantCulture)==0)
							{
								// We have a match on value
								Setting set = new Setting(o, pAfter);
								reply.Add(set);
								break;
							}
							else
							{
								Split(o.alias, ':', out oBefore, out oAfter);
								if (String.Compare(pBefore, oBefore, true, CultureInfo.InvariantCulture)==0)
								{
									// We have a match on alias
									Setting set=new Setting(o, pAfter);
									reply.Add(set);
									break;
								}
							}
							index += 1;
						}
					}
					else
					{
						// Must be an argument
						Setting set=new Setting(null, s);
						reply.Add(set);
					}
				}
			}
			reply.TrimToSize();

			Setting[] settings = new Setting[reply.Count];
			int i = 0;
			foreach( Setting s in reply)
				settings[i++] = s;

			return settings;
		}

		static public	void WriteErrorMsg(String msg)
		{
			Console.WriteLine(name + " error:   " + msg);
		}

		static public	void WriteErrorMsg(Exception e)
		{
			Console.WriteLine("Error:   " + e.ToString());
		}

		static private void Split(string s, char seperator, out string pBefore, out string pAfter)
		{
			int i = s.IndexOf(seperator);
			if (i >= 0)
			{
				pBefore = s.Substring(0, i);
				pAfter = s.Substring(i + 1);
			}
			else
			{
				pBefore = s;
				pAfter = "";
			}
		}

		static public int CompareString(string s1, string s2)
		{
			int l1 = s1.Length;
			int l2 = s2.Length;
			int l = (l1 <= l2) ? l1 : l2;

			if (l1 == 0 || l2 == 0)
				return l2 - l1;
			else
				return String.Compare(s1, 0, s2, 0, l, true, CultureInfo.InvariantCulture);
		}
		static public string whereis(string filename)
		{
			// Call SearchPath to find the full path of the file to load.
			StringBuilder sb = new StringBuilder(MAX_PATH + 1);
			if (SearchPath(null, filename, null, sb.Capacity + 1, sb, null) == 0)
			{
				throw new ApplicationException("File not found: " + filename);
			}
			return sb.ToString();
		}

	private const int MAX_PATH = 260;

	[DllImport("kernel32.dll", SetLastError=true)]
	protected static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\namesgen\node.cs ===
//
//	Balanced tree implementation
//

using System;
using System.IO;
using System.Collections;

namespace NamesGen
{
	public	class BalancedTree : IEnumerable
	{
		protected BalancedNode root = null;
		protected int	count = 0;

		public BalancedTree(IComparable v)
		{
			root = new BalancedNode(v);
			count = 1;
		}
		public	int	Count
		{
			get { return count; }
		}

		// Dump the list to a file in sorted order.
		public	void DumpToFile(string filename)
		{
			StreamWriter w = new StreamWriter(filename);
			root.Dump(w);
			w.Close();
		}

		// Dump the list to a file in sorted order.
		public	void DumpAsTreeToFile(string filename)
		{
			StreamWriter w = new StreamWriter(filename);
			root.DumpAsTree(w);
			w.Close();
		}

		public static BalancedTree LoadFromFile(string filename)
		{
			BalancedTree tree = null;
			StreamReader r = new StreamReader(filename, true);
			string str;
	 		if ((str=r.ReadLine()) != null)
	 		{
	 			// Pick apart bits
	 			tree = new Names(str);
		 		while ((str=r.ReadLine()) != null)
		 		{
		 			// Pick apart bits
					tree.Insert(str);
				}
			}
			r.Close();
			return tree;
		}

		// This will insert an entry into the tree
		// returns  true if added,
		//			false if already exists
		public	bool	Insert(IComparable v)
		{
			bool reply = root.Insert(v);
			if(reply) ++count;
			return reply;
		}

		public	BalancedNode	Search(IComparable v)
		{
			return root.Search(v);
		}

		public IEnumerator	GetEnumerator()
		{
			return new TreeEnumerator(root, count).GetEnumerator();
		}

		class TreeEnumerator
		{
			object[] elements;
			int	current;

			void TraverseTree(BalancedNode c)
			{
				if(c.Left != null) TraverseTree(c.Left);
				elements[current++] = c;
				if(c.Right != null) TraverseTree(c.Right);
			}

			public TreeEnumerator(BalancedNode root, int nitems)
			{
				elements = new object[nitems];
				current = 0;
				TraverseTree(root);
			}

			public IEnumerator GetEnumerator()
			{
				return elements.GetEnumerator();
			}
        }
	}

	public	class BalancedNode
	{
		internal BalancedNode Left = null;
		internal BalancedNode Right = null;

		int		depth = 0;
		public	IComparable	Value;

		// Objects added to this list must be comparable so I might as well enforce it here.
		public	BalancedNode(IComparable value)
		{
			Value = value;
		}

		// This will insert an entry into the list
		// returns  true if added,
		//			false if already in the list
		public	bool	Insert(IComparable v)
		{
			bool deepened = false;
			return InternalInsert(v, ref deepened);
		}

		// Used to keep the tree balanced, deepened indicates when The depth of the subtree has changed
		private	bool	InternalInsert(IComparable v, ref bool deepened)
		{
			bool result = false;

			// Here I am at a node
			if (v.CompareTo(Value)< 0)
			{
				// I am less than this nodes Value
				if (Left == null)
				{
					result = true;
					Left = new BalancedNode(v);
					if(Right == null)
					{
						++depth;
						deepened = true;
					}
				}
				else
				{
					result = Left.InternalInsert(v, ref deepened);

					// Maintain an accurate depth count
					if(deepened) ++depth;
				}
			}
			else if(v.CompareTo(Value) > 0)
			{
				// I am above than this nodes Value
				if (Right == null)
				{
					result = true;
					Right = new BalancedNode(v);
					if(Left == null)
					{
						++depth;
						deepened = true;
					}
				}
				else
				{
					result = Right.InternalInsert(v, ref deepened);

					// Maintain an accurate depth count
					if(deepened) ++depth;
				}
			}
			else
			{
				// I Already exist in the tree
				result = false;
			}

			// I have added my Node and updated my Depths
			// Now I need to ensure that my left and right subtrees differ by no more than 1
			if(deepened)
			{
				// Node with empty left and right is at depth -1
				//
				int left = (Left != null) ? Left.depth : -1;
				int right = (Right != null) ? Right.depth : -1;
				if(right - left > 1)
				{
					// Right subtree is deeper than left subtree
					IComparable t = Value;
					BalancedNode l = Left;
					BalancedNode r = Right.Left;
					Value = Right.Value;
					Right = Right.Right;
					Left = new BalancedNode(t);
					Left.Left = l;
					Left.Right = r;
					Left.depth = HigherOf(Left.Left, Left.Right) + 1;
				}
				else if(left - right  > 1)
				{
					// Left subtree is deeper than the right subtree
					IComparable t = Value;
					BalancedNode r = Right;
					BalancedNode l = Left.Right;
					Value = Left.Value;
					Left = Left.Left;
					Right = new BalancedNode(t);
					Right.Right = r;
					Right.Left = l;
					Right.depth = HigherOf(Right.Left, Right.Right) + 1;
				}
			}
			depth = HigherOf(Left, Right) + 1;
			return result;
		}

		static int	HigherOf(BalancedNode l, BalancedNode r)
		{
			int dl = (l != null) ? l.depth : -1;
			int dr = (r != null) ? r.depth : -1;
			return (dl > dr) ? dl : dr;
		}


		// This will Search for an entry in the list
		// returns  true if found,
		//			false if not found
		public BalancedNode Search(IComparable v)
		{
			BalancedNode result = null;
			// Here I am at a node
			if (v.CompareTo(Value) < 0)
			{
				// I am less than this nodes Value
				if (Left != null)
					result = Left.Search(v);
			}
			else if(v.CompareTo(Value) > 0)
			{
				// I am higher than this nodes Value
				if (Right != null)
					result = Right.Search(v);
			}
			else
			{
				// I Already exist in the tree
				result = this;
			}
			return result;
		}

		static int indent;
		public virtual void	DumpAsTree(StreamWriter sw)
		{
			for(int i=0; i < indent; i++) sw.Write("    ");
			sw.WriteLine("Value : " + Value + "  Depth : " + depth);
			++indent;
			if(Left != null) { sw.Write("L - "); Left.DumpAsTree(sw); }
			if(Right != null) { sw.Write("R - "); Right.DumpAsTree(sw); }
			--indent;
		}

		public void	Dump(StreamWriter sw)
		{
			if(Left != null) Left.Dump(sw);
			sw.WriteLine(this);
			if(Right != null) Right.Dump(sw);
		}
		public override string ToString()
		{
			return Value.ToString();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\blobheap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.IO;


/*********************************************************************************************************************
 * This class represents the #Blob heap.  It is also responsible for reading blobs from the blob heap.
 *********************************************************************************************************************/
internal class BlobHeap
{
	private	ulong			m_startPos;
	private uint			m_length;
	private MemoryStream	m_memStream;
	private BinaryReader	m_reader;
	private BinaryWriter	m_writer;

	internal BlobHeap(ref byte[] buf, ulong startPos, uint length)
	{
		m_startPos	= startPos;
		m_length	= length;
		m_memStream	= new MemoryStream(buf);
		m_reader	= new BinaryReader(m_memStream);
		m_writer	= new BinaryWriter(m_memStream);
	}

	internal byte[] ReadBlob(uint offset) 
	{
		uint	i, blobLength;
		byte[]	blob;

		m_reader.BaseStream.Seek((long)(m_startPos + offset), SeekOrigin.Begin);
		blobLength = (uint)m_reader.ReadByte();

		// first case - the first bit of the first byte is 0
		if ((blobLength & 0x80) == 0)
		{
			blobLength = blobLength & 0x7f;
		}
		// the first bit of the first byte is 1
		else
		{
			// second case - the second bit of the first byte is 0
			if ((blobLength & 0x40) == 0)
			{
				blobLength = ((blobLength & 0x3f) << 8) + (uint)m_reader.ReadByte();
			}
			// third case - the second bit of the first byte is 1
			else
			{
				blobLength = ((blobLength & 0x1f) << 24) + ((uint)m_reader.ReadByte() << 16) + 
							 ((uint)m_reader.ReadByte() << 8) + ((uint)m_reader.ReadByte());
			}
		}

		blob = new byte[blobLength];
		for (i = 0; i < blobLength; i++)
		{
			blob[i] = m_reader.ReadByte();
		}
		return blob;
	}

	internal bool WriteBlob(uint offset, byte[] blob) 
	{
		int		length;
		byte[]	lengthBlob;

		if (blob == null)
			return false;

		// Encode the length of the blob into a byte array.
		length = blob.Length;
		if (length <= 127)
		{
			lengthBlob		= new byte[1];
			lengthBlob[0]	= (byte)length;
		}
		else if (length <= 16383)
		{
			lengthBlob		= new byte[2];
			lengthBlob[0]	= (byte)(0x80 | (length >> 8));
			lengthBlob[1]	= (byte)(length & 0xff);
		}
		else
		{
			lengthBlob		= new byte[4];
			lengthBlob[0]	= (byte)(0xc0 | (length >> 24));
			lengthBlob[1]	= (byte)((length >> 16) & 0xff);
			lengthBlob[2]	= (byte)((length >> 8) & 0xff);
			lengthBlob[3]	= (byte)(length & 0xff);
		}

        m_writer.BaseStream.Seek((long)(m_startPos + offset), SeekOrigin.Begin);
		m_writer.Write(lengthBlob);							// write the length byte array
		m_writer.Write(blob);								// write the actual blob of data
		m_writer.Flush();
		return true;
	}

	// This is a static method which compares two blobs byte by byte and returns true or false.
	internal static bool CompareBlob(byte[] one, byte[] two)
	{
		int i;

		// Check for nulls.
		if (one == null && two == null)
			return true;

		if ( (one == null && two != null) || (one != null && two == null) )
			return false;

		// Check the lengths.
		if (one.Length != two.Length)
			return false;

		// Check the blobs byte by byte.
		for (i = 0; i < one.Length; i++)
		{
			if (one[i] != two[i])
				return false;
		}
		return true;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\namesgen\namesgen.cs ===
//
//	Generate the Names from a type library
//


using System;
using System.IO;
using System.Runtime.InteropServices;

namespace NamesGen
{
	internal class OleAut
	{
		internal const int S_OK = 0;
		internal const int S_FALSE = 1;

		internal const int REGKIND_DEFAULT         = 0;
		internal const int REGKIND_REGISTER        = 1;
		internal const int REGKIND_NONE            = 2;

		internal static bool FAILED(int hr)
		{
			return hr < 0;
		}

		internal static bool SUCCEEDED(int hr)
		{
			return hr >= 0;
		}

		[DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
		internal static extern void LoadTypeLibEx(String strTypeLibName, int regKind, out UCOMITypeLib TypeLib);
	}

	class EntryPoint  : ProgramBase
	{
		static EntryPoint()
		{
			name	= "NamesGen";
			description = "Generate / Verify names for a typelibrary";
			syntax	= name + "[Options] Type Library [Options]";
			where	= "Type Library\t\tFile containing the Type library to generate a names list from.";
			options = new Option[]	{
					  new Option ("/iid","","\tVerify the IID's are not changed.", true),
					  new Option ("/build","","\tRunning in a build process.", true),
					  new Option ("/verify:filename","","\tFilename - contains list of names to verify against.", true),
					  new Option ("/out:filename","","\tOutput filename", true),
					  new Option ("/dump:filename","","\tDump typelib symbols as tree", true),
					 };
		}

		static void		DealWithName(string name, Guid guid)
		{
			if(symbols == null)
				symbols = new Names(new Name(name, false, guid));
			else
				symbols.Insert(new Name(name, false, guid));
		}

		static BalancedTree symbols = null;
		static BalancedTree verify = null;

		static void		DealWithTypeInfo(UCOMITypeInfo it)
		{
			// Get the names from ITypeInfo
			string name;
			string docstring;
			Int32 ctxt;
			string helpfile;

			// TypeInfo name
			it.GetDocumentation(-1, out name, out docstring, out ctxt, out helpfile);
			IntPtr pa;
			it.GetTypeAttr(out pa);
			TYPEATTR ta = (TYPEATTR)Marshal.PtrToStructure(pa, typeof(TYPEATTR));

			DealWithName(name, ta.guid);

			// Deal with funcs
			for(int i=0; i < ta.cFuncs; i++)
			{
				IntPtr pfd;
				it.GetFuncDesc(i, out pfd);
				FUNCDESC fd = (FUNCDESC)Marshal.PtrToStructure(pfd, typeof(FUNCDESC));
				it.GetDocumentation(fd.memid, out name, out docstring, out ctxt, out helpfile);
				DealWithName(name, Guid.Empty);
			}

			// Deal with vars
			for(int i=0; i < ta.cVars; i++)
			{
				IntPtr pvd;
				it.GetVarDesc(i, out pvd);
				VARDESC vd = (VARDESC)Marshal.PtrToStructure(pvd, typeof(VARDESC));
				it.GetDocumentation(vd.memid, out name, out docstring, out ctxt, out helpfile);
				DealWithName(name, Guid.Empty);
			}
		}

		static	void	ExtractNames(string typelib)
		{
			UCOMITypeLib tl = null;
			OleAut.LoadTypeLibEx(typelib, OleAut.REGKIND_NONE, out tl);

			// Get the names from ITypeLib
			string 	name;
			string 	docstring;
			Int32 	ctxt;
			string 	helpfile;
			tl.GetDocumentation(-1, out name, out docstring, out ctxt, out helpfile);
			IntPtr pa;
			tl.GetLibAttr(out pa);
			TYPELIBATTR ta = (TYPELIBATTR)Marshal.PtrToStructure(pa, typeof(TYPELIBATTR));

			DealWithName(name, ta.guid);

			// Enumerate TypeInfos
			int nTypeInfos = tl.GetTypeInfoCount();
			for(int i=0; i < nTypeInfos; i++)
			{
				UCOMITypeInfo it = null;
				tl.GetTypeInfo(i, out it);
				DealWithTypeInfo(it);
			}
		}


		static int	Main(string[] args)
		{
			int		exitcode = 0;
			String	typelib = null;
			String	outfile = null;
			String	verifyfile = null;
			String	dump = null;
			bool	silent = false;
			bool	verifyiid = false;
			bool	inbuild = false;
			try
			{
				Setting[] switches = GetSwitches(args);

				foreach(Setting sw in switches)
				{
					if (sw.option == null)
					{
						if (typelib != null)
						{
							// We already have a typelib
							PrintLogo();
							WriteErrorMsg("Only one typelibrary can be operated on at a time.");
							exitcode = 1;
							goto done;
						}
						else
						{
							// We are cool with this
							typelib = sw.value;
						}
					}
					else
					{
						if (CompareString(sw.option.value, "/out")==0)
						{
							outfile = sw.value;
						}
						else if (CompareString(sw.option.value, "/verify")==0)
						{
							verifyfile = sw.value;
						}
						else if (CompareString(sw.option.value, "/iid")==0)
						{
							verifyiid = true;
						}
						else if (CompareString(sw.option.value, "/dump")==0)
						{
							dump = sw.value;
						}
						else if (CompareString(sw.option.value, "/silent")==0)
						{
							silent = true;
						}
						else if (CompareString(sw.option.value, "/build")==0)
						{
							inbuild = true;
						}
						else if (CompareString(sw.option.value, "/?")==0)
						{
							PrintLogo();
							PrintUsage();
							exitcode = 0;
							goto done;
						}
					}
				}

				if(!silent)
					PrintLogo();
				if (typelib == null)
				{
					WriteErrorMsg("No Type library file specified");
					exitcode = 1;
					goto done;
				}

				ExtractNames(typelib);
				if(dump != null)
				{
					symbols.DumpAsTreeToFile(dump);
					if(!silent)
					{
						Console.WriteLine("Successfully generated " + dump + " from " + typelib);
					}
				}

				// Is an output file desired?
				if(outfile != null)
				{
					symbols.DumpToFile(outfile);
					if(!silent)
					{
						Console.WriteLine("Successfully generated " + outfile + " from " + typelib);
					}
				}

				// Is verification desired?
				if(verifyfile != null)
				{
					if(!silent)
					{
						if (inbuild)
						{
							Console.Write("Build_Status ");
						}
						Console.WriteLine("Verify the names from " + typelib);
					}
					int errors = 0;
					verify = Names.LoadFromFile(verifyfile);
					foreach(BalancedNode s in symbols)
					{
						if(s.Value != null)
						{
							Name n = (Name)s.Value;
							BalancedNode o = verify.Search(n);
							if(o == null)
							{
								Console.WriteLine(typelib + " : error N2000 : Symbol named '" + n.Value + "' added to typelib.");
								++errors;
							}
							else
							{
								Name f = (Name)o.Value;
								f.Found = true;
								if (n.UUID != f.UUID)
								{
									f.NEWUUID = n.UUID;
								}
							}
						}
					}

					foreach(BalancedNode s in verify)
					{
						if(s.Value != null)
						{
							Name n = (Name)s.Value;
							if(n.Found != true)
							{
								Console.WriteLine(typelib + " : error N2001 : Symbol named '" + n.Value + "' removed from typelib.");
								++errors;
							}
						}
					}

					if(verifyiid)
					{
						foreach(BalancedNode s in verify)
						{
							if(s.Value != null)
							{
								Name n = (Name)s.Value;
								if(n.NEWUUID != Guid.Empty)
								{
									Console.WriteLine(typelib + " : error N2002 : Guid changed for symbol named '" + n.Value + "'; was " + n.UUID + " now is " + n.NEWUUID);
									++errors;
								}
							}
						}
					}

					if(!silent)
					{
						if(errors != 0)
						{
							Console.WriteLine(typelib + " : error N1000 : errors comparing typelib to names file " + verifyfile);
						}
						else
						if (!inbuild)
						{
							Console.WriteLine(typelib + " : no errors comparing typelib to names file " + verifyfile);
						}
					}
					exitcode = errors;
				}

			}
			catch(Exception e)
			{
				Console.WriteLine(typelib + " : error N1001 : Exception " + e.Message);
				return 1;
			}
		done:
			return exitcode;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\exceptions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;


internal class InvalidFileFormat : Exception
{
	internal InvalidFileFormat(string message) : base(message) {}
}
internal class NotEnoughSpace : Exception {}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\argumentparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//#define DEBUG0
//#define DEBUG1 
//#define DEBUG_NESTED
//#define DEBUG_DECODE
using System;
using System.IO;
using System.Text;
using System.Collections;
using System.Globalization;

/*********************************************************************************************************************
 * This is the driver class of the obfuscator.  It contains the "Main" method.
 *********************************************************************************************************************/
internal class ArgumentParser 
{
	// return values
	private const int RETURN_PASS				= 0x0080;
	private const int RETURN_FAIL				= 0x0100;
	private const int RETURN_BAD_ARGUMENT		= 0x0200;
	private const int RETURN_BAD_FILE_FORMAT	= 0x0400;
	private const int RETURN_CANNOT_OPEN_FILE	= 0x0800;
	private const int RETURN_NOT_ENOUGH_SPACE	= 0x1000;
	private const int RETURN_NESTED_TOO_DEEPLY	= 0x2000;
	private const int RETURN_CANNOT_CREATE_DIR	= 0x4000;

	// m_NullifyFlag is no longer used, but it is still here in case it will be needed in the future.
	internal static bool m_NullifyFlag	= false;			

	internal static bool m_ExcludeFlag		= false;		// indicate if any class is excluded
	internal static bool m_VerboseFlag		= false;		// to print statistics or not
	internal static bool m_NoLogoFlag		= false;		// to print logo information or not
	internal static bool m_HelpFlag			= false;		// to print the help information or not
	internal static bool m_SuppressFlag		= false;		// to suppress warning messages or not
	internal static bool m_EverythingFlag	= false;		// to obfuscate everything, ignoring accessibility and visibility

	internal static string		m_outFilePath = "obfus\\";			// default path to put the obfuscated file(s)
	internal static Hashtable	m_excludeTypeNames = new Hashtable();
	private  static int			m_errno = 0;
	private  static string		m_errmsg = null;
	private  static MetaData	m_mdSection		= null;
	private  static Obfus		m_obfuscator	= null;

	// This method prints the usage/help information.
    private static void Usage() 
	{
		Console.WriteLine(Environment.NewLine + "Obfuscate a binary CIL file." + Environment.NewLine);

		Console.WriteLine("  All argument names and values are case insensitive.");
		Console.WriteLine("  All command line arguments are optional, except for the name of the input");
		Console.WriteLine("  binary CIL file.");
		Console.WriteLine("  All command line arguments must be given before the name of the input binary");
		Console.WriteLine("  CIL file.");
		Console.WriteLine("  If no command line arguments were given at all, run as if /? were given.");
		Console.WriteLine("  All console output will be through stdout; stderr will never be used." + Environment.NewLine);

		Console.WriteLine("  /help");                 
		Console.WriteLine("                     Print this documentation to the console. (Short form /?)");
		Console.WriteLine("  /outpath:<path>    Control where the obfuscated binary file(s) should be");
		Console.WriteLine("                     stored.  By default the file(s) will be stored in the");
		Console.WriteLine("                     subdirectory called \"obfus\\\" of the current directory.");
		Console.WriteLine("                     This subdirectory will be created if it does not already");
		Console.WriteLine("                     exist.  It is illegal to specify the current directory.");
		Console.WriteLine("  /exclude:<full_class_name>,...");
		Console.WriteLine("                     A comma-delimited list of classes to exclude from the");
		Console.WriteLine("                     obfuscation process.  (Short form /x:)");
		Console.WriteLine("  /verbose[+[:<file_name.ext>]|-]");
		Console.WriteLine("                     Default is -.  + means print statistics report to the");
		Console.WriteLine("                     console.  In addition, a filename can be given in which");
		Console.WriteLine("                     to store the report.  (Short form /v:)");
		Console.WriteLine("  /nologo            Do not print tool logo information to the console via");
		Console.WriteLine("                     stdout.");
		Console.WriteLine("  /nowarning");
		Console.WriteLine("                     Suppress warning messages.");
		Console.WriteLine("  /exe");
		Console.WriteLine("                     Obfuscate as many names as possible, ignoring the");
		Console.WriteLine("                     accessibility and visibility.  This is only suitable for");
		Console.WriteLine("                     executable files.");
		Console.WriteLine("  @<file_name.ext>   Specify the name of a response file storing more options.");
		Console.WriteLine("                     Each line in a response file represents an option.  If a");
		Console.WriteLine("                     line starts with '#', then that line is treated as a ");
		Console.WriteLine("                     comment and is ignored.");
    }

    private static void Exit(int code) 
	{
        Environment.Exit(code);
    }

	// This method parses a single argument and set the appropriate flag if necessary.
	private static void ParseArguments(int depth, ref bool parsed, string args, ref string inName, ref string reportName)
	{
		string			upArgs, responseFileName = null, responseArg = null;
		FileStream		responseFileStream = null;
		StreamReader	responseFileReader = null;

		if (depth == 10)
		{
			SetErrNoAndMsg(RETURN_FAIL + RETURN_NESTED_TOO_DEEPLY, "  ERROR:  Response files are nested too deeply.");
			return;
		}

		// "parsed" is used to indicate whether we have already parsed the filename or not.
		if (parsed)
			SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, 
						   "  ERROR:  All command line arguments must be given before the name of the input" + Environment.NewLine + 
						   "          binary CIL file.");
						   
		upArgs = args.ToUpper(CultureInfo.InvariantCulture);

		// if the first character of the argument is a '/'
		if (upArgs[0] == '/')
		{
			if (upArgs.Equals("/HELP") || upArgs.Equals("/?"))
			{
				m_HelpFlag = true;
			}
			else if (upArgs.Equals("/NOWARNING"))
			{
				m_SuppressFlag = true;
			}
			else if (upArgs.Equals("/EXE"))
			{
				m_EverythingFlag = true;
			}
			else if (upArgs.Length >= 9 && String.Compare(upArgs, 0, "/OUTPATH:", 0, 9, false, CultureInfo.InvariantCulture) == 0)
			{
				m_outFilePath = args.Substring(9);
				if (m_outFilePath.Length <= 0)
					SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  Output file name is expected after /out:.");
			}
			else if (upArgs.Length >= 9 && String.Compare(upArgs, 0, "/EXCLUDE:", 0, 9, false, CultureInfo.InvariantCulture) == 0)
			{
				if (!ParseClassNames(args.Substring(9)))
					SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, 
								   "  ERROR:  A comma-delimited list of <full class name> is expected after /exclude:.");
				else
					m_ExcludeFlag = true;
			}
			else if ((upArgs.Length >= 3 && String.Compare(upArgs, 0, "/X:", 0, 3, false, CultureInfo.InvariantCulture) == 0) )
			{
				if (!ParseClassNames(args.Substring(3)))
					SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, 
								   "  ERROR:  A comma-delimited list of <full class name> is expected after /x:.");
				else
					m_ExcludeFlag = true;
			}
			else if (upArgs.Length >= 8 && String.Compare(upArgs, 0, "/VERBOSE", 0, 8, false, CultureInfo.InvariantCulture) == 0)
			{
				if (args.Length < 9 || !SetFlag(out m_VerboseFlag, args[8]))
					SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /verbose.");
				else
				{
					if (m_VerboseFlag)
					{
						if (args.Length == 9)
							return;

						// if a filename follows the '+' sign
						if (args.Length >= 10 && args[9] == ':')
						{
							reportName = args.Substring(10);
							if (reportName.Length <= 0)
								SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, 
											   "  ERROR:  '+[:<file>]' or '-' is expected after /verbose.");
						}
						else
							SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /verbose.");
					}
					else
					{
						if (args.Length != 9)
							SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /verbose.");
					}
				}
			}
			else if (upArgs.Length >= 2 && String.Compare(upArgs, 0, "/V", 0, 2, false, CultureInfo.InvariantCulture) == 0)
			{
				if (args.Length < 3 || !SetFlag(out m_VerboseFlag, args[2]))
					SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /v.");
				else
				{
					if (m_VerboseFlag)
					{
						if (args.Length == 3)
							return;

						// if a filename follows the '+' sign
						if (args.Length >= 4 && args[3] == ':')
						{
							reportName = args.Substring(4);
							if (reportName.Length <= 0)
								SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /v.");
						}
						else
							SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /v.");
					}
					else
					{
						if (args.Length != 3)
							SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  '+[:<file>]' or '-' is expected after /v.");
					}
				}
			}
			else if (upArgs.Equals("/NOLOGO"))
			{
				m_NoLogoFlag = true;
			}
			else 
				SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  Unknown option \"" + args + "\".");
		}
		else if (upArgs[0] == '@')									// handle response file
		{
			responseFileName = args.Substring(1);
			if (responseFileName.Length <= 0)
			{
				SetErrNoAndMsg(RETURN_FAIL + RETURN_BAD_ARGUMENT, "  ERROR:  <file_name.ext> is expected after @.");
			}
			else
			{
				try 
				{
					responseFileStream	= File.Open(responseFileName, FileMode.Open, FileAccess.Read, FileShare.Read);
					responseFileReader	= new StreamReader(responseFileStream, Encoding.ASCII);
				} 
				catch (Exception e)
				{
					SetErrNoAndMsg(RETURN_FAIL + RETURN_CANNOT_OPEN_FILE, "  ERROR:  " + e.Message);
					return;
				}

				responseFileReader.BaseStream.Seek(0, SeekOrigin.Begin);

				for (;;)
				{
					responseArg = responseFileReader.ReadLine();			// read a line, which represents one argument

					if (responseArg == null)								// we have reached the end of the file
						break;

					if (String.Equals(responseArg, "") || responseArg[0] == '#')			// skip empty lines and comments
						continue;

					ParseArguments(depth + 1, ref parsed, responseArg, ref inName, ref reportName);
				}
			}
		}
		else
		{
			// this argument is the file name
			parsed	= true;
			inName	= args;
		}
	}

	// Determine if "sign" is a '+' or a '-', and set "flag" accordingly.  If "sign" is neither '+' nor '-', return false.
	private static bool SetFlag(out bool flag, char sign)
	{
		if (sign == '+')
			flag = true;
		else if (sign == '-')
			flag = false;
		else
		{
			flag = false;							// this assignment is needed for compilation
			return false;
		}
		return true;
	}

	// This method parses a list of class names and add each class to the Hashtable "m_excludeTypeNames", keyed by namespace and name.
	private static bool ParseClassNames(string list)
	{
		int			i, index;
		string[]	rawNames;
		Obfus.NameSpaceAndName info;

		// check if the list is empty
		if (list.Length == 0)
			return false;

		rawNames = list.Trim().Split(',');

		for (i = 0; i < rawNames.Length; i++)
		{
			// Here, we append an extra null to the namespaces and names.  This is done so that comparisons with namespaces
			// and names read from the string heap can be done correctly.  We read nulls from the string heap in order to have 
			// accurate lengths of strings.
			index = rawNames[i].LastIndexOf('.');	
			if (index == -1)
			{
				info.nameSpace	= "\0";
				info.name		= String.Concat(rawNames[i], "\0");
			}
			else
			{
				info.nameSpace	= String.Concat(rawNames[i].Substring(0, index), "\0");
				info.name		= String.Concat(rawNames[i].Substring(index + 1), "\0");
			}

			// When this class is added to the Hashtable, we assign the value "false" to it, which shows that this class has
			// not been processed yet.  When we actually exclude the class from obfuscation, we change the value to "true".  At the
			// end, we print a warning for each class in the exclude list but not actually in the assembly, i.e. each class still
			// having the value "false".
			if (!m_excludeTypeNames.ContainsKey(info))
			{
				m_excludeTypeNames.Add(info, false);
			}
		}
		return true;
	}

	// Store the error number and the error message if they have not already been set.
	private static void SetErrNoAndMsg(int errorNum, string errMessage)
	{
		if (m_errno == 0)
		{
			m_errno		= errorNum;
			m_errmsg	= errMessage;
		}
	}

	// This method prints the statistics to stdout if "file" is null.  Otherwise, it opens "file" and prints the statistics to it.
	private static void PrintStats(string file)
	{
		if (file == null)
		{
			Console.WriteLine(Environment.NewLine + "Number of Names Obfuscated");

			Console.Write("  m_Type      : " + m_obfuscator.m_TypeCount + " \tout of " + m_obfuscator.m_TypeTotal + ",\tor ");
			if (m_obfuscator.m_TypeTotal == 0)
				Console.WriteLine("0%");
			else
				Console.WriteLine(Decimal.Round(Decimal.Divide(m_obfuscator.m_TypeCount, m_obfuscator.m_TypeTotal), 4) * 100 + "%");

			Console.Write("  m_Method    : " + m_obfuscator.m_MethodCount + " \tout of " + m_obfuscator.m_MethodTotal + ",\tor ");
			if (m_obfuscator.m_MethodTotal == 0)
				Console.WriteLine("0%");
			else
				Console.WriteLine(Decimal.Round(Decimal.Divide(m_obfuscator.m_MethodCount, m_obfuscator.m_MethodTotal), 4) * 100 + "%");

			Console.Write("  m_Field     : " + m_obfuscator.m_FieldCount + " \tout of " + m_obfuscator.m_FieldTotal + ",\tor ");
			if (m_obfuscator.m_FieldTotal == 0)
				Console.WriteLine("0%");
			else
				Console.WriteLine(Decimal.Round(Decimal.Divide(m_obfuscator.m_FieldCount, m_obfuscator.m_FieldTotal), 4) * 100 + "%");

			Console.Write("  m_Property  : " + m_obfuscator.m_PropertyCount + " \tout of " + m_obfuscator.m_PropertyTotal + ",\tor ");
			if (m_obfuscator.m_PropertyTotal == 0)
				Console.WriteLine("0%");
			else
				Console.WriteLine(Decimal.Round(Decimal.Divide(m_obfuscator.m_PropertyCount, m_obfuscator.m_PropertyTotal), 4) * 100 + "%");

			Console.Write("  m_Events    : " + m_obfuscator.m_EventCount + " \tout of " + m_obfuscator.m_EventTotal + ",\tor ");
			if (m_obfuscator.m_EventTotal == 0)
				Console.WriteLine("0%");
			else
				Console.WriteLine(Decimal.Round(Decimal.Divide(m_obfuscator.m_EventCount, m_obfuscator.m_EventTotal), 4) * 100 + "%");

			Console.Write("  m_Parameter : " + m_obfuscator.m_ParamCount + " \tout of " + m_obfuscator.m_ParamTotal + ",\tor ");
			if (m_obfuscator.m_ParamTotal == 0)
				Console.WriteLine("0%");
			else
				Console.WriteLine(Decimal.Round(Decimal.Divide(m_obfuscator.m_ParamCount, m_obfuscator.m_ParamTotal), 4) * 100 + "%");
		}
		else
		{
			FileStream		reportFileStream;
			StreamWriter	writer = null; 

			try
			{
				reportFileStream = File.Open(file, FileMode.Create, FileAccess.Write, FileShare.None);
				writer = new StreamWriter(reportFileStream, Encoding.ASCII);
			}
			catch (Exception e)
			{
				Console.WriteLine("  ERROR:  " + e.Message);
				Exit(RETURN_FAIL + RETURN_CANNOT_OPEN_FILE);
			}

			writer.Write(Environment.NewLine + "Number of Names Obfuscated" + Environment.NewLine);

			writer.Write("  m_Type      : " + m_obfuscator.m_TypeCount + " \tout of " + m_obfuscator.m_TypeTotal + ",\tor ");
			if (m_obfuscator.m_TypeTotal == 0)
				writer.Write("0%" + Environment.NewLine);
			else
				writer.Write(Decimal.Round(Decimal.Divide(m_obfuscator.m_TypeCount, m_obfuscator.m_TypeTotal), 4) * 100 + "%" + 
							 Environment.NewLine);

			writer.Write("  m_Method    : " + m_obfuscator.m_MethodCount + " \tout of " + m_obfuscator.m_MethodTotal + ",\tor ");
			if (m_obfuscator.m_MethodTotal == 0)
				writer.Write("0%" + Environment.NewLine);
			else
				writer.Write(Decimal.Round(Decimal.Divide(m_obfuscator.m_MethodCount, m_obfuscator.m_MethodTotal), 4) * 100 + "%" + 
							 Environment.NewLine);

			writer.Write("  m_Field     : " + m_obfuscator.m_FieldCount + " \tout of " + m_obfuscator.m_FieldTotal + ",\tor ");
			if (m_obfuscator.m_FieldTotal == 0)
				writer.Write("0%" + Environment.NewLine);
			else
				writer.Write(Decimal.Round(Decimal.Divide(m_obfuscator.m_FieldCount, m_obfuscator.m_FieldTotal), 4) * 100 + "%" + 
							 Environment.NewLine);

			writer.Write("  m_Property  : " + m_obfuscator.m_PropertyCount + " \tout of " + m_obfuscator.m_PropertyTotal + ",\tor ");
			if (m_obfuscator.m_PropertyTotal == 0)
				writer.Write("0%" + Environment.NewLine);
			else
				writer.Write(Decimal.Round(Decimal.Divide(m_obfuscator.m_PropertyCount, m_obfuscator.m_PropertyTotal), 4) * 100 + "%" + 
							 Environment.NewLine);

			writer.Write("  m_Events    : " + m_obfuscator.m_EventCount + " \tout of " + m_obfuscator.m_EventTotal + ",\tor ");
			if (m_obfuscator.m_EventTotal == 0)
				writer.Write("0%" + Environment.NewLine);
			else
				writer.Write(Decimal.Round(Decimal.Divide(m_obfuscator.m_EventCount, m_obfuscator.m_EventTotal), 4) * 100 + "%" +
							 Environment.NewLine);

			writer.Write("  m_Parameter : " + m_obfuscator.m_ParamCount + " \tout of " + m_obfuscator.m_ParamTotal + ",\tor ");
			if (m_obfuscator.m_ParamTotal == 0)
				writer.Write("0%" + Environment.NewLine);
			else
				writer.Write(Decimal.Round(Decimal.Divide(m_obfuscator.m_ParamCount, m_obfuscator.m_ParamTotal), 4) * 100 + "%" + 
							 Environment.NewLine);
			
			writer.Close();					// this call also flushes the writer
		}
	}

    public static void Main(string[] args) 
	{
		int				i;
		byte[]			buf = null;
		bool			parsedExeName = false;
		string			inFileName = null, reportFileName = null;
		FileStream		inFileStream = null;
		BinaryReader	inFileReader = null;

		string[]		fileList	= null;
		//char[]			counter		= new char[2]{(char)0, '\0'};			// initializes the string counter used to obfuscate strings
		char[]			counter		= new char[2]{(char)0x2F, '\0'};			// initializes the string counter used to obfuscate strings
		ArrayList		mdInfoList	= new ArrayList();		// this list stores all the MetaData section of all modules in this assembly

        if (args.Length == 0) 
		{
            Usage();
            Exit(RETURN_FAIL + RETURN_BAD_ARGUMENT);
        }

		for (i = 0; i < args.Length; i++)
		{
			ParseArguments(0, ref parsedExeName, args[i], ref inFileName, ref reportFileName);
		}

		if (!m_NoLogoFlag)
		{
			Console.WriteLine(Environment.NewLine + "OBFUS - .NET Assembly Obfuscation Utility.  Version " + Util.Version.VersionString);
			Console.WriteLine("Copyright (C) Microsoft Corporation. 2000-2002. All rights reserved." + Environment.NewLine);
		}

		if (m_HelpFlag)
		{
			Usage();
			Exit(RETURN_PASS);
		}

		if (m_errno != 0)										// we have encountered an error while parsing the arguments
		{
			Console.WriteLine(m_errmsg);
			Exit(m_errno);
		}

		if (inFileName == null)
		{
			Console.WriteLine("  ERROR:  Input binary CIL file is not specified.");
			Exit(RETURN_FAIL + RETURN_CANNOT_OPEN_FILE);
		}

		try 												// this try is only responsible for opening the input file
		{
			inFileStream = File.Open(inFileName, FileMode.Open, FileAccess.Read, FileShare.Read);
		} 
		catch (Exception e)
		{
			Console.WriteLine("  ERROR:  " + e.Message);
			Exit(RETURN_FAIL + RETURN_CANNOT_OPEN_FILE);
		}

		// TODO : There is a problem with System.dll.  If we have not closed the stream and if DEBUG is defined, then 
		//        when the obfuscator needs to load the System.Diagnostic.Debug class, it fails.  However, we cannot
		//        really close the stream, because we are still accessing the file in the method ParsePEFile.
		//        The workaround is to copy System.dll, obfuscate the copy, and then replace the original one with the
		//        obfuscated version.

		try														// this try is responsbile for parsing the headers of the input file
		{
			inFileReader = new BinaryReader(inFileStream);
			buf = PEParser.ParsePEFile(ref inFileReader);		// parse the input file
		}
		catch (EndOfStreamException)
		{
			// We have to change the error message for this type of exception.  The original message says 
			// "Unable to read beyond the end of the stream".
			Console.WriteLine("  ERROR:  Invalid CIL binary file format.");
			Exit(RETURN_FAIL + RETURN_BAD_FILE_FORMAT);
		}
		catch (Exception e)
		{
			Console.WriteLine("  ERROR:  " + e.Message);
			Exit(RETURN_FAIL + RETURN_BAD_FILE_FORMAT);
		}

		try														// this try is responsible for creating the output directory if necessary
		{
			if (!Directory.Exists(m_outFilePath))
				Directory.CreateDirectory(m_outFilePath);

			if (m_outFilePath[m_outFilePath.Length - 1] != '\\')
				m_outFilePath = String.Concat(m_outFilePath, "\\");
		}
		catch (Exception e)
		{
			Console.WriteLine("  ERROR:  " + e.Message);
			Exit(RETURN_FAIL + RETURN_CANNOT_CREATE_DIR);
		}

		try														// do the obfuscation
		{
			m_mdSection		= new MetaData(ref buf);
			m_obfuscator	= new Obfus(ref m_mdSection, ref counter, inFileName, ref mdInfoList, ref fileList, true);
			m_obfuscator.Initialize();
			m_obfuscator.FinishInitialization();
			m_obfuscator.ObfuscateAllModules();
		}
		catch (InvalidFileFormat)
		{
			Console.WriteLine("  ERROR:  Invalid CIL binary file format.");
			Exit(RETURN_FAIL + RETURN_BAD_FILE_FORMAT);			// we need to give the correct error code here
		}
		catch (NotEnoughSpace)
		{
			Console.WriteLine("  UNSUCCESSFUL:  There is not enough space in the string heap to finish obfuscation.");
			Exit(RETURN_FAIL + RETURN_NOT_ENOUGH_SPACE);		// we need to give the correct error code here
		}
		catch (Exception e)
		{
			Console.WriteLine("  ERROR:  " + e.Message);
			Exit(RETURN_FAIL);
		}

		if (!m_SuppressFlag)										// suppress warning messages if this flag is set
		{
			// Give a warning for each class which is in the exclude list but does not actually exist in the assembly.
			for (IDictionaryEnumerator excludeEnum = m_excludeTypeNames.GetEnumerator(); excludeEnum.MoveNext(); )
			{
				if (!(bool)excludeEnum.Value)
				{
					Console.WriteLine("  WARNING:  Class " + 
									  ((Obfus.NameSpaceAndName)excludeEnum.Key).nameSpace.Trim('\0') + "." + 
									  ((Obfus.NameSpaceAndName)excludeEnum.Key).name.Trim('\0') + " does not exist.");
				}
			}
		}

		if (m_VerboseFlag)	
			PrintStats(reportFileName);							// print the statistics if necessary

		// This call also closes the underlying stream.  Moreover, this call is delayed until the end so that the input
		// file will not be overwritten.
		inFileReader.Close();

		Exit(RETURN_PASS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\freespacelist.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;


/*********************************************************************************************************************
 * This class stores the free spaces in the string heap which we can use to store the obfuscated names.
 *********************************************************************************************************************/
internal class FreeSpaceList
{
	/*********************************************************************************************************************
	 * This class represents individual chunks of memory.  It has to inherit from IComparable because we want to sort these
	 * chunks by their offsets into the string heap.
	 *********************************************************************************************************************/
	private struct FreeSpace : IComparable 
	{
		internal uint offset;
		internal uint length;

		// This method is public because it is inherited from the IComparable interface
		public int CompareTo(object that)
		{
			if (this.offset > ((FreeSpace)that).offset)
				return 1;
			else if (this.offset < ((FreeSpace)that).offset)
				return -1;
			else
				return 0;
		}
	}

	private ArrayList	m_list;				// list of free spaces we can use
	private ArrayList	m_deleteList;		// list of spaces which must not be used

	public FreeSpaceList()
	{
		m_list			= new ArrayList();
		m_deleteList	= new ArrayList();
	}

	public void RawAdd(uint offset, uint length)
	{
		FreeSpace space;
		space.offset = offset;
		space.length = length;
		m_list.Add(space);
	}	

	// This method takes the haphazardly added chunks of free spaces and sort them by offsets.  Then it merges them
	// as appropriate.  Notice that each original chunk contains exaclty one '\0', which is at the end.
	public void MergeRawAdd()
	{
		int			i;
		FreeSpace	prevSpace, curSpace;

		if (m_list.Count == 0)
			return;

		m_list.Sort();											// sort the m_list by offsets into the string heap

		for (i = m_list.Count - 1; i > 0; i--)
		{
			prevSpace	= (FreeSpace)m_list[i - 1];
			curSpace	= (FreeSpace)m_list[i];

			if (prevSpace.offset == curSpace.offset)
			{
				prevSpace.length = curSpace.length;		// "curSpace.length" must be >= "prevSpace.length"
				m_list.RemoveAt(i);
				m_list[i - 1] = prevSpace;
				continue;
			}

			// If the end of the previous chunk is adjacent to the beginning of the current chunk, merge them.
			if (prevSpace.offset + prevSpace.length == curSpace.offset)
			{
				prevSpace.length += curSpace.length;
				m_list.RemoveAt(i);
				m_list[i - 1] = prevSpace;
				continue;
			}

			// If the previous chunk contains the current chunk, remove the current one.
			if (prevSpace.offset <= curSpace.offset && curSpace.offset <= prevSpace.offset + prevSpace.length - 1)
			{
				m_list.RemoveAt(i);
				continue;
			}

			// Other cases are not possible due to the fact that all chunks are originally delimited by '\0'.
		}
	}

	public void RawDelete(uint offset, uint length) 
	{
		FreeSpace space;
		space.offset = offset;
		space.length = length;
		m_deleteList.Add(space);
	}

	// This method takes the haphazardly added chunks of free spaces and sort them by offsets.  Then it deletes them
	// as appropriate.
	public void MergeRawDelete()
	{
		int			i, cur = 0;								// "cur" is an index into the free space m_list
		FreeSpace	deleteSpace, curSpace, newSpace;

		if (m_deleteList.Count == 0)
			return;

		m_deleteList.Sort();

		for (i = 0; i < m_deleteList.Count; i++)
		{
			deleteSpace = (FreeSpace)m_deleteList[i];

			// Skip if there are duplicates.
			if (i < m_deleteList.Count - 1 && deleteSpace.offset == ((FreeSpace)m_deleteList[i + 1]).offset)
				continue;

			for (;;)
			{
				// Return if we have finished the entire free space m_list. 
				if (cur >= m_list.Count)
				{
					m_deleteList.Clear();
					return;
				}

				curSpace = (FreeSpace)m_list[cur];

				// If the chunk we are trying to delete precedes the current chunk in the free space m_list, we can proceed
				// to the next chunk to be deleted.
				if (deleteSpace.offset < curSpace.offset)
					break;

				// If the current chunk in the free space m_list contains the chunk to be deleted, we have to do some checking.
				if (curSpace.offset <= deleteSpace.offset && deleteSpace.offset <= curSpace.offset + curSpace.length - 1) 
				{
					if (curSpace.offset == deleteSpace.offset)				// if the beginnings of the two chunks are the same
					{
						if (curSpace.length == deleteSpace.length)			// if the ends are the same
						{
							m_list.RemoveAt(cur);
							break;
						}
						else
						{
							curSpace.offset += deleteSpace.length;
							curSpace.length -= deleteSpace.length;
							m_list[cur] = curSpace;
							break;
						}
					}
					else
					{
						if (curSpace.offset + curSpace.length == deleteSpace.offset + deleteSpace.length)
						{
							curSpace.length = deleteSpace.offset - curSpace.offset;
							m_list[cur] = curSpace;
						}
						else							// If both the beginnings and the ends are different, we have to split.
						{
							newSpace.offset = deleteSpace.offset + deleteSpace.length;
							newSpace.length = (curSpace.offset + curSpace.length) - (deleteSpace.offset + deleteSpace.length);
							m_list.Insert(cur + 1, newSpace);
							curSpace.length = deleteSpace.offset - curSpace.offset;
							m_list[cur] = curSpace;
							cur += 1;
							break;
						}
					}
				}
				else
				{
					cur += 1;
				}
			}
		}
		m_deleteList.Clear();
	}
	
	// This method is basically a delete.  It uses the First-Fit algorithm to find the first chunk of free space whose length
	// is greater than or equal to the specified length.
	//
	// TODO : We can optimize a bit if we delete chunks of length 1, since we can never make use of such chunks.
	public uint Use(uint length)
	{
		uint tmp;
		FreeSpace space;

		for (int i = 0; i < m_list.Count; i++)
		{
			space = (FreeSpace)m_list[i];
			if (space.length >= length)
			{
				tmp = space.offset;
				if (space.length == length)
				{
					m_list.RemoveAt(i);
				}
				else
				{
					space.offset += length;
					space.length -= length;
					m_list[i] = space;
				}
				return tmp;
			}
		}
		return 0;								// return 0 if we run out of spaces
	}
	
	// This method returns information about a particular chunk of free space.  This is used when we want to clear
	// out unused free space with 'x'.
	public bool Get(int index, out uint offset, out uint length)
	{
		if (0 <= index && index < m_list.Count)
		{
			offset = ((FreeSpace)m_list[index]).offset;
			length = ((FreeSpace)m_list[index]).length;
			return true;
		}
		else
		{
			offset = 0;
			length = 0;
			return false;
		}
	}

	// This method is for debugging purposes only.
	internal void Dump()
	{
		FreeSpace space;

		Console.WriteLine();
		for (int i = 0; i < m_list.Count; i++)
		{
			space = (FreeSpace)m_list[i];
			Console.WriteLine(space.offset + "\t" + (space.offset + space.length - 1) + "\t" + space.length);
		}
		Console.WriteLine();
	}

	// This method sums up the total amount of free space available.
	public int SpaceLeft
	{
		get
		{
			int	length = 0;
			for (int i = 0; i < m_list.Count; i++)
			{
				length += (int)((FreeSpace)m_list[i]).length;
			}
			return length;
		}
	} 

	public int Count
	{
		get
		{
			return m_list.Count;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\headers.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.IO;


internal class DosHeader 
{
	// We only care about one value in the MS-DOS header, and that is the offset to the PE signature.
    internal uint m_e_lfanew;

    internal DosHeader(ref BinaryReader reader) 
	{
        reader.BaseStream.Seek(0x3c, SeekOrigin.Begin);			// the offset is always at 0x3c
        m_e_lfanew = reader.ReadUInt32();
    }
}


/*********************************************************************************************************************
 * Note: This class is NOT correctly laid out.  It actually contains several headers, including the COFF header and the
 *       PE Header (also known as Optional Header).
 *********************************************************************************************************************/
internal class NTHeader 
{
    internal struct ImageDataDirectory 
	{
        internal uint RVA;
        internal uint Size;
    }

    private uint		m_PESignature;
    private const uint	PE_SIGNATURE = 0x00004550;

    // COFF Header
    private  ushort m_Machine;
    internal ushort m_NumberOfSections;
    private  uint   m_TimeDateStamp;
    private  uint   m_PointerToSymbolTable;
    private  uint   m_NumberOfSymbols;
    private  ushort m_OptionalHeaderSize;
    private  ushort m_Characteristics;

    // Optional Header - Standard fields
    private ushort			m_Magic;
    private const ushort	IMAGE_NT_OPTIONAL_HDR32_MAGIC = 0x10b;
    private byte   m_MajorLinkerVersion;
    private byte   m_MinorLinkerVersion;
    private uint   m_CodeSize;
    private uint   m_InitializeDataSize;
    private uint   m_UninitializeDataSize;
    private uint   m_EntryPointRVA;
    private uint   m_BaseOfCode;
    private uint   m_BaseOfData;

	// Optional Header - NT-specific fields
    private  uint   m_ImageBase;
    private  uint   m_SectionAlignment;
    internal uint   m_FileAlignment;
    private  ushort m_MajorOperatingSystemVersion;
    private  ushort m_MinorOperatingSystemVersion;
    private  ushort m_MajorImageVersion;
    private  ushort m_MinorImageVersion;
    private  ushort m_MajorSubsystemVersion;
    private  ushort m_MinorSubsystemVersion;
    private  uint   m_Reserved;
    internal uint   m_ImageSize;
    internal uint   m_HeaderSize;
    private  uint   m_FileCheckSum;
    private  ushort m_Subsystem;
    private  ushort m_DLLFlags;
    private  uint   m_StackReserveSize;
    private  uint   m_StackCommitSize;
    private  uint   m_HeapReserveSize;
    private  uint   m_HeapCommitSize;
    private  uint   m_LoaderFlags;
    private  uint   m_NumberOfDataDirectories;

	// Optional Header - Data directories
    internal ImageDataDirectory[] m_DataDirectory;

    internal NTHeader(ref BinaryReader reader) 
	{
		Exception toBeThrown;

        m_PESignature = reader.ReadUInt32();
        if (m_PESignature != PE_SIGNATURE)
		{
			toBeThrown = new InvalidFileFormat("Invalid CIL binary file format.");
            throw toBeThrown;
		}

        // COFF Header
        m_Machine				= reader.ReadUInt16();
        m_NumberOfSections		= reader.ReadUInt16();
        m_TimeDateStamp			= reader.ReadUInt32();
        m_PointerToSymbolTable	= reader.ReadUInt32();
        m_NumberOfSymbols		= reader.ReadUInt32();
        m_OptionalHeaderSize	= reader.ReadUInt16();
        m_Characteristics		= reader.ReadUInt16();

        if (m_OptionalHeaderSize == 0)
		{
			toBeThrown = new InvalidFileFormat("Invalid CIL binary file format.");
            throw toBeThrown;
		}

        // Optional Header - Standard fields
        m_Magic = reader.ReadUInt16();
        if (m_Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
		{
			toBeThrown = new InvalidFileFormat("Invalid CIL binary file format.");
            throw toBeThrown;
		}

        m_MajorLinkerVersion	= reader.ReadByte();
        m_MinorLinkerVersion	= reader.ReadByte();
        m_CodeSize				= reader.ReadUInt32();
        m_InitializeDataSize	= reader.ReadUInt32();
        m_UninitializeDataSize	= reader.ReadUInt32();
        m_EntryPointRVA			= reader.ReadUInt32();
        m_BaseOfCode			= reader.ReadUInt32();
        m_BaseOfData			= reader.ReadUInt32();

		// Optional Header - NT-specific fields
        m_ImageBase					= reader.ReadUInt32();
        m_SectionAlignment			= reader.ReadUInt32();
        m_FileAlignment				= reader.ReadUInt32();
        m_MajorOperatingSystemVersion	= reader.ReadUInt16();
        m_MinorOperatingSystemVersion	= reader.ReadUInt16();
        m_MajorImageVersion			= reader.ReadUInt16();
        m_MinorImageVersion			= reader.ReadUInt16();
        m_MajorSubsystemVersion		= reader.ReadUInt16();
        m_MinorSubsystemVersion		= reader.ReadUInt16();
        m_Reserved					= reader.ReadUInt32();
        m_ImageSize					= reader.ReadUInt32();
        m_HeaderSize				= reader.ReadUInt32();
        m_FileCheckSum				= reader.ReadUInt32();
        m_Subsystem					= reader.ReadUInt16();
        m_DLLFlags					= reader.ReadUInt16();
        m_StackReserveSize			= reader.ReadUInt32();
        m_StackCommitSize			= reader.ReadUInt32();
        m_HeapReserveSize			= reader.ReadUInt32();
        m_HeapCommitSize			= reader.ReadUInt32();
        m_LoaderFlags				= reader.ReadUInt32();
        m_NumberOfDataDirectories	= reader.ReadUInt32();

		// The number of data directories in the remainder of the optional header is always 16.
        if (m_NumberOfDataDirectories != 16)
		{
			toBeThrown = new InvalidFileFormat("Invalid CIL binary file format.");
            throw toBeThrown;
		}

		// Optional Header - Data directories
        m_DataDirectory = new ImageDataDirectory[m_NumberOfDataDirectories];
        for (int i = 0; i < m_NumberOfDataDirectories; i++) 
		{
            m_DataDirectory[i].RVA	= reader.ReadUInt32();
            m_DataDirectory[i].Size	= reader.ReadUInt32();
        }
    }
}


internal class SectionHeader
{
    internal byte[]	m_Name;
    private  uint	m_VirtualSize;
    internal uint	m_VirtualAddress;
    internal uint	m_SizeOfRawData;
    internal uint	m_PointerToRawData;
    private  uint	m_PointerToRelocations;
    private  uint	m_PointerToLineNumbers;
    private  ushort	m_NumberOfRelocations;
    private  ushort	m_NumberOfLineNumbers;
    private  ulong	m_Characteristics;

    internal SectionHeader(ref BinaryReader reader) 
	{
		// "Name" must be 8-bytes long and may not have a terminating null.
        m_Name = new byte[8];
        for (int i = 0; i < 8; i++) 
		{
            m_Name[i] = reader.ReadByte();
        }
        m_VirtualSize			= reader.ReadUInt32();
        m_VirtualAddress		= reader.ReadUInt32();
        m_SizeOfRawData			= reader.ReadUInt32();
        m_PointerToRawData		= reader.ReadUInt32();
        m_PointerToRelocations	= reader.ReadUInt32();
        m_PointerToLineNumbers	= reader.ReadUInt32();
        m_NumberOfRelocations	= reader.ReadUInt16();
        m_NumberOfLineNumbers	= reader.ReadUInt16();
        m_Characteristics		= reader.ReadUInt32();
    }
}


internal class AllHeaders
{
    internal DosHeader			m_dosHeader;
    internal NTHeader			m_ntHeader;
    internal SectionHeader[]	m_sectionHeaders = null;

    internal AllHeaders(ref BinaryReader reader) 
	{
        m_dosHeader	= new DosHeader(ref reader);
        reader.BaseStream.Seek(m_dosHeader.m_e_lfanew, SeekOrigin.Begin);
        m_ntHeader	= new NTHeader(ref reader);

		// "NumberOfSections" comes from the COFF header.
        if (m_ntHeader.m_NumberOfSections != 0) 
		{
            m_sectionHeaders = new SectionHeader[m_ntHeader.m_NumberOfSections];
            for (int i = 0; i < m_ntHeader.m_NumberOfSections; i++)
			{
                m_sectionHeaders[i] = new SectionHeader(ref reader);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\metadata.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.IO;


/*********************************************************************************************************************
 * This is the main class of the obfuscator.  It represents the MetaData section of the PE file, and it is reponsible
 * for parsing the MetaData section and actually obfuscating the string names.
 *********************************************************************************************************************/
internal class MetaData 
{
	private ulong			m_startPos;
	internal byte[]			m_buffer;			// byte array representing the loaded version of the PE file
	internal PTHeap			m_heap;				// #~ heap
	internal StringHeap		m_strHeap;			// #Strings heap
	internal BlobHeap		m_blobHeap;			// #Blob heap
	internal MetaDataRoot	m_mdr;				// MetaData Root table

	/*********************************************************************************************************************
	 *	1) Parse the MetaData Root table.
	 *
	 *	2) Initialize the various heaps.
	 *
	 *	3) Initialize "m_oldNameHash", "m_classTree", and "m_freeSpaceList".
	 *
	 *	4) Initialize the various BitArrays.
	 *
	 *	5) Set the total numbers of the elements (types, methods, fields, properties, events, and parameters).
	 *********************************************************************************************************************/
    internal MetaData(ref byte[] buf)
	{
		int			i, ptHeapIndex = -1;
		Exception	toBeThrown;

		m_buffer		= buf;

		// Ok.  Now we can build a reader and a writer over the memory m_buffer.
		MemoryStream memStream	= new MemoryStream(m_buffer);
		BinaryReader reader		= new BinaryReader(memStream);
		BinaryWriter writer		= new BinaryWriter(memStream);

		AllHeaders all		= new AllHeaders(ref reader);
		NTHeader nth		= all.m_ntHeader;
		SectionHeader[] sh	= all.m_sectionHeaders;

		#if DEBUG0
			Console.WriteLine("Runtime Header Data Directory");
			Console.WriteLine("rva: " + nth.m_DataDirectory[14].RVA + "; size: " + nth.m_DataDirectory[14].Size + Environment.NewLine);
			Console.WriteLine("offset to MetaData section: " + (long)(nth.m_DataDirectory[14].RVA + 8));
		#endif

		// Read the RVA of the physical MetaData section from the Runtime Header Data Directory.
		reader.BaseStream.Seek((long)(nth.m_DataDirectory[14].RVA + 8), SeekOrigin.Begin);
		m_startPos = reader.ReadUInt64();

		// Theoretically, startPos can be 64 bit long, but in practice, 32 bits are enough.
		// TODO : Check the docs.  The following assertion will fail.
		// Debug.Assert((startPos >> 32) == 0);
		m_startPos = m_startPos & 0xffffffff;						// use the least significant 4 bytes as the offset

		m_mdr = new MetaDataRoot(ref reader, ref m_buffer, m_startPos);

		// We need to initialize the #Strings heap and the #Blob heap before dealing with the #~ heap.
		for (i = 0; i < m_mdr.m_numStreams; i++)
		{
			if (m_mdr.m_streamHeaders[i].name.Equals("#Strings\0"))
				m_strHeap = new StringHeap(ref m_buffer, m_startPos + m_mdr.m_streamHeaders[i].offset, m_mdr.m_streamHeaders[i].size);

			else if (m_mdr.m_streamHeaders[i].name.Equals("#Blob\0"))
				m_blobHeap = new BlobHeap(ref m_buffer, m_startPos + m_mdr.m_streamHeaders[i].offset, m_mdr.m_streamHeaders[i].size);

			else if (m_mdr.m_streamHeaders[i].name.Equals("#~\0") || m_mdr.m_streamHeaders[i].name.Equals("#-\0"))
				ptHeapIndex = i;
		}

		if (ptHeapIndex != -1)
			m_heap = new PTHeap(ref reader, ref writer, ref m_strHeap, m_startPos + m_mdr.m_streamHeaders[ptHeapIndex].offset);
		else
		{
			toBeThrown = new InvalidFileFormat("Invalid CIL binary file format.");
			throw toBeThrown;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\metadataroot.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.IO;
using System.Text;


/*********************************************************************************************************************
 * This class represents the MetaData Root table.
 *********************************************************************************************************************/
internal class MetaDataRoot 
{
    internal struct StreamHeader 
	{
        internal uint	offset;
        internal uint	size;
		internal string	name;
    };

	private uint		m_signature;
    private const uint	METADATA_SIGNATURE = 0x424a5342;				// this is equivalent to "BSJB"
	private ushort	m_majorVersion;
	private ushort	m_minorVersion;
	private uint	m_extraData;	
	private uint	m_versionStrLen;
	private string	m_versionStr;
	private byte	m_flags;
	private byte	m_pad;

	internal ushort			m_numStreams;
    internal StreamHeader[] m_streamHeaders;
	
	internal MetaDataRoot(ref BinaryReader reader, ref byte[] buf, ulong startPos) 
	{
		uint		i, offset;
		ulong		curPos = startPos;
		Exception	toBeThrown;

		reader.BaseStream.Seek((long)curPos, SeekOrigin.Begin);

		m_signature = reader.ReadUInt32();
		#if DEBUG0
			Console.Write("metadata m_signature: ");
			Console.Write((char)(m_signature & 0xff));
			Console.Write((char)((m_signature & 0xff00) >> 8));
			Console.Write((char)((m_signature & 0xff0000) >> 16));
			Console.WriteLine((char)((m_signature & 0xff000000) >> 24) + Environment.NewLine);
		#endif
        if (m_signature != METADATA_SIGNATURE)
		{
			toBeThrown = new InvalidFileFormat("Invalid CIL binary file format.");
			throw toBeThrown; 
		}

		m_majorVersion	= reader.ReadUInt16();
		m_minorVersion	= reader.ReadUInt16();
		m_extraData		= reader.ReadUInt32();	
		m_versionStrLen	= reader.ReadUInt32();
		curPos += (ulong)16;

		m_versionStr = Encoding.ASCII.GetString(buf, (int)curPos, (int)m_versionStrLen);
		curPos += (ulong)m_versionStrLen;
		reader.BaseStream.Seek(m_versionStrLen, SeekOrigin.Current);

		m_flags			= reader.ReadByte();
		m_pad			= reader.ReadByte();
		m_numStreams	= reader.ReadUInt16();
		curPos += (ulong)4;

		// Read each stream header.
        m_streamHeaders = new StreamHeader[m_numStreams];
		for (i = 0; i < m_numStreams; i++)
		{
			m_streamHeaders[i].offset = reader.ReadUInt32();
			m_streamHeaders[i].size	= reader.ReadUInt32();
			
			curPos += 8;

			// Read the stream name.
			m_streamHeaders[i].name = "";
			for ( ; ; curPos++)
			{
				m_streamHeaders[i].name += (char)buf[curPos];
				if (buf[curPos] == '\0')
				{
					curPos++;
					break;
				}
			}

			// Read until the length of the stream name is a multiple of 4.
			offset = (uint)m_streamHeaders[i].name.Length;
			for ( ;offset % 4 != 0; curPos++, offset++) {};

			reader.BaseStream.Seek(offset, SeekOrigin.Current);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\indexdecoder.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*********************************************************************************************************************
 * This class is responsible for resolving tokens found in various MetaData tables.  All of its methods are static.
 ************************;*********************************************************************************************/
internal class IndexDecoder
{
	// TypeDefOrRef token
	private const uint TYPEDEFORREF				= 0x3;
	private const uint TYPEDEFORREF_TYPEDEF		= 0x0;
	private const uint TYPEDEFORREF_TYPEREF		= 0x1;
	private const uint TYPEDEFORREF_TYPESPEC	= 0x2;

	// MemberRefParent token
	private const uint MEMBERREFPARENT				= 0x7;
	private const uint MEMBERREFPARENT_TYPEDEF		= 0x0;
	private const uint MEMBERREFPARENT_TYPEREF		= 0x1;
	private const uint MEMBERREFPARENT_MODULEREF	= 0x2;
	private const uint MEMBERREFPARENT_METHODDEF	= 0x3;
	private const uint MEMBERREFPARENT_TYPESPEC		= 0x4;

	// ResolutionScope token
	private const uint RESOLUTIONSCOPE				= 0x3;
	private const uint RESOLUTIONSCOPE_MODULE		= 0x0;
	private const uint RESOLUTIONSCOPE_MODULEREF	= 0x1;
	private const uint RESOLUTIONSCOPE_ASSEMBLYREF	= 0x2;
	private const uint RESOLUTIONSCOPE_TYPEREF		= 0x3;
	
	// HasSemantic token
	private const uint HASSEMANTIC			= 0x1;
	private const uint HASSEMANTIC_EVENT	= 0x0;
	private const uint HASSEMANTIC_PROPERTY	= 0x1;

	// Implementation token
	private const uint IMPLEMENTATION				= 0x03;
	private const uint IMPLEMENTATION_FILE			= 0x00;
	private const uint IMPLEMENTATION_ASSEMBLYREF	= 0x01;
	private const uint IMPLEMENTATION_EXPORTEDTYPE	= 0x02;

	// This type of token is really an index into one of three tables, not two: TypeDef, TypeRef, or TypeSpec.
	internal static void DecodeTypeDefOrRef(uint index, out uint tableIndex, out uint row)
	{
		tableIndex = 0;
		switch (index & TYPEDEFORREF)
		{
			case TYPEDEFORREF_TYPEDEF:
				tableIndex = PTHeap.TYPEDEF_TABLE;
				break;

			case TYPEDEFORREF_TYPEREF:
				tableIndex = PTHeap.TYPEREF_TABLE;
				break;

			case TYPEDEFORREF_TYPESPEC:
				tableIndex = PTHeap.TYPESPEC_TABLE;
				break;
		}
		row = index >> 2;
	}

	internal static void DecodeMemberRefParent(uint index, out uint tableIndex, out uint row)
	{
		tableIndex = 0;
		switch (index & MEMBERREFPARENT)
		{
			case MEMBERREFPARENT_TYPEDEF:
				tableIndex = PTHeap.TYPEDEF_TABLE;
				break;

			case MEMBERREFPARENT_TYPEREF:
				tableIndex = PTHeap.TYPEREF_TABLE;
				break;

			case MEMBERREFPARENT_MODULEREF:
				tableIndex = PTHeap.MODULEREF_TABLE;
				break;

			case MEMBERREFPARENT_METHODDEF:
				tableIndex = PTHeap.METHOD_TABLE;
				break;

			case MEMBERREFPARENT_TYPESPEC:
				tableIndex = PTHeap.TYPESPEC_TABLE;
				break;
		}
		row = index >> 3;
	}

	internal static void DecodeResolutionScope(uint index, out uint tableIndex, out uint row)
	{
		tableIndex = 0;
		switch (index & RESOLUTIONSCOPE)
		{
			case RESOLUTIONSCOPE_MODULE:
				tableIndex = PTHeap.MODULE_TABLE;
				break;

			case RESOLUTIONSCOPE_MODULEREF:
				tableIndex = PTHeap.MODULEREF_TABLE;
				break;

			case RESOLUTIONSCOPE_ASSEMBLYREF:
				tableIndex = PTHeap.ASSEMBLYREF_TABLE;
				break;

			case RESOLUTIONSCOPE_TYPEREF:
				tableIndex = PTHeap.TYPEREF_TABLE;
				break;
		}
		row = index >> 2;
	}

	internal static void DecodeHasSemantic(uint index, out uint tableIndex, out uint row)
	{
		tableIndex = 0;
		switch (index & HASSEMANTIC)
		{
			case HASSEMANTIC_EVENT:
				tableIndex = PTHeap.EVENT_TABLE;
				break;

			case HASSEMANTIC_PROPERTY:
				tableIndex = PTHeap.PROPERTY_TABLE;
				break;
		}
		row = index >> 1;
	}

	internal static void DecodeImplementation(uint index, out uint tableIndex, out uint row)
	{
		tableIndex = 0;
		switch (index & IMPLEMENTATION)
		{
			case IMPLEMENTATION_FILE:
				tableIndex = PTHeap.FILE_TABLE;
				break;

			case IMPLEMENTATION_ASSEMBLYREF:
				tableIndex = PTHeap.ASSEMBLYREF_TABLE;
				break;

			case IMPLEMENTATION_EXPORTEDTYPE:
				tableIndex = PTHeap.EXPORTEDTYPE_TABLE;
				break;
		}
		row = index >> 2;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\multitree.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*********************************************************************************************************************
 * This class is a tree which represents the class inheritance hierarchy.
 *********************************************************************************************************************/
internal class MultiTree
{
	private TreeNode m_root;

	public MultiTree()
	{
		m_root = new TreeNode(0, TreeNode.OUTOFASSEMBLY_NONE);
	}

	public void AddToRoot(ref TreeNode newNode)
	{
		m_root.AddChild(ref newNode);
		newNode.AddParent(ref m_root);
	}

	// Create a new node, add it as a child to "parentNode", and return it.
	public TreeNode AddChild(ref TreeNode parentNode, uint type)
	{
		TreeNode newNode = SearchDown(m_root, type);
		if (newNode == null)
			newNode = new TreeNode(type, TreeNode.OUTOFASSEMBLY_NONE);

		parentNode.AddChild(ref newNode);
		newNode.AddParent(ref parentNode);

		return newNode;
	}

	// Create a new node, add it as a parent to "childNode", and return it.
	public TreeNode AddParent(ref TreeNode childNode, uint type)
	{
		TreeNode newNode = SearchDown(m_root, type);
		if (newNode == null)
			newNode = new TreeNode(type, TreeNode.OUTOFASSEMBLY_NONE);

		childNode.AddParent(ref newNode);
		newNode.AddChild(ref childNode);

		return newNode;
	}

	// Search for a particular node by its type index, up from the current node.
	public TreeNode SearchUp(TreeNode curNode, uint type)
	{
		TreeNode tmp = null;

		if (curNode.Type == type)
			return curNode;

		// Break as soon as "tmp" is not null.
		for (int i = 0; i < curNode.ParentCount && tmp == null; i++)
		{
			tmp = SearchUp(curNode.GetParent(i), type);
		}

		return tmp;
	}

	// Search for a particular node by its type index, down from the current node.
	public TreeNode SearchDown(TreeNode curNode, uint type)
	{
		TreeNode tmp = null;

		if (curNode.Type == type)
			return curNode;

		// Break as soon as "tmp" is not null.
		for (int i = 0; i < curNode.ChildCount && tmp == null; i++)
		{
			tmp = SearchDown(curNode.GetChild(i), type);
		}

		return tmp;
	}

	// This function is used for debugging purposes only.
	internal void Dump(TreeNode curNode, int indent, ref PTHeap heap, ref StringHeap strHeap)
	{
		curNode.Print(indent, ref heap, ref strHeap);
		for (int i = 0; i < curNode.ChildCount; i++)
		{
			Dump(curNode.GetChild(i), indent + 1, ref heap, ref strHeap);
		}
	}

	public TreeNode Root
	{
		get
		{
			return m_root;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\peparser.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.IO;
using System.Diagnostics;


/*********************************************************************************************************************
 * This class reads in and writes out PE files.
 *********************************************************************************************************************/
internal class PEParser
{
    // Roundup to a power of 2.
    private static uint Roundup(uint n, uint mod) 
	{
        Debug.Assert((mod & (mod - 1)) == 0);      // Must be power of 2.
        return (n + (mod - 1)) & ~(mod - 1);
    }

	// This method reads a PE file, and then returns a byte array representation of the file.
    internal static byte[] ParsePEFile(ref BinaryReader reader) 
	{
		uint	i, fileOffset;
		byte[]	buf;

        AllHeaders all		= new AllHeaders(ref reader);
        NTHeader nth		= all.m_ntHeader;
        SectionHeader[] sh	= all.m_sectionHeaders;

		// "ImageSize" and "FileAlignment" come from Optional header - NT-specific fields. 
        buf = new byte[nth.m_ImageSize];

		#if DEBUG0
			Console.WriteLine("size of image: " + nth.m_ImageSize + Environment.NewLine);
		#endif

        // Ok.  Got all the info.  Ready to read in the sections.
        Debug.Assert(nth.m_FileAlignment >= 512);

        reader.BaseStream.Seek(0, SeekOrigin.Begin);
        reader.Read(buf, 0, (int)nth.m_HeaderSize);		// Read first "nth.m_HeaderSize" bytes.  These are the headers.

		// Read each section from the file.
        for (i = 0; i < nth.m_NumberOfSections; i++) 
		{
            fileOffset = sh[i].m_PointerToRawData;
            if (fileOffset != 0) 
			{
                reader.BaseStream.Seek(fileOffset, SeekOrigin.Begin);
                reader.Read(buf, (int)sh[i].m_VirtualAddress, (int)sh[i].m_SizeOfRawData);

				#if DEBUG0
					Console.Write("name of section " + i + ": ");
					for (int j = 0; j < 8; j++)
					{
						Console.Write((char)sh[i].m_Name[j]);	
					}
					Console.WriteLine();
					Console.WriteLine("size of section " + i + ": " + sh[i].m_SizeOfRawData + Environment.NewLine);
				#endif
            }
        }
        return buf;
    }

	// This method writes out a PE file.
    internal static void PersistPEFile(ref BinaryWriter writer, ref byte[] buf) 
	{
		uint i, chunkSize, fileOffset;

        MemoryStream memStream = new MemoryStream(buf);
        BinaryReader memReader = new BinaryReader(memStream);

        // Crack the headers.
        AllHeaders all		= new AllHeaders(ref memReader);
        NTHeader nth 		= all.m_ntHeader;
        SectionHeader[] sh	= all.m_sectionHeaders;

        // Write the headers to the file.
        writer.Write(buf, 0, (int)nth.m_HeaderSize);

		// Write each section to the file.
        for (i = 0; i < nth.m_NumberOfSections; i++) 
		{
            fileOffset = sh[i].m_PointerToRawData;
            if (fileOffset != 0) 
			{
                chunkSize = Roundup(sh[i].m_SizeOfRawData, nth.m_FileAlignment);

                writer.BaseStream.Seek(fileOffset, SeekOrigin.Begin);
                writer.Write(buf, (int)sh[i].m_VirtualAddress, (int)chunkSize);
            }
        }
        writer.Flush();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\stringheap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.IO;
using System.Text;


/*********************************************************************************************************************
 * This class represents the #Strings heap.  It is also responsible for reading and writing to the string heap.
 *********************************************************************************************************************/
internal class StringHeap
{
	private	ulong			m_startPos;
	private uint			m_length;
	private MemoryStream	m_memStream;
	private BinaryWriter	m_writer;
	private	string			m_entireString;

	internal StringHeap(ref byte[] buf, ulong startPos, uint length)
	{
		m_startPos	= startPos;
		m_length	= length;

		m_memStream	= new MemoryStream(buf);
		m_writer	= new BinaryWriter(m_memStream, Encoding.UTF8);

		// We have to use a string here instead of a "StreamReader" because we will have to search for '\0'.
		m_entireString	= Encoding.ASCII.GetString(buf, (int)m_startPos, (int)m_length);
		// Attention! It seems logical to use UTF8 here instead of ASCII, but then the character count
		// in the resulting string will not be the same as byte count (multibyte characters are counted for one).
		// But the string heap offsets in the metadata are defined in bytes, not in UTF-8 characters!
	}

	internal string ReadString(uint offset) 
	{
		int	endPos = m_entireString.IndexOf('\0', (int)offset);				// find the first '\0' starting from "offset"

		return m_entireString.Substring((int)offset, endPos - (int)offset + 1);
	}

	// Return the length of the string starting at "offset".
	internal uint StringLength(uint offset)
	{
		return (uint)m_entireString.IndexOf('\0', (int)offset) - offset + 1;
	}

	// Write the string "toBeWritten" to the string heap.  We cannot simply "Write" method of the "BinaryWriter" class here
	// because it will prefix the string with its length before writing it.
	internal bool WriteString(uint offset, string toBeWritten)
	{
		return WriteString(offset, toBeWritten.ToCharArray());
	}
	
	// Write the character array "charArray" to the string heap.  We use a character array because that is the type of the
	// parameter taken by the "Write" method of the "BinaryWriter" class.
	internal bool WriteString(uint offset, char[] charArray)
	{
		if (offset + charArray.Length > m_length)
			return false;

        m_writer.BaseStream.Seek((long)(m_startPos + offset), SeekOrigin.Begin);
		m_writer.Write(charArray);
		m_writer.Flush();
		return true;
	}

	// Clear the specified portion of the string heap by '\0'.
	internal void Clear(uint offset, uint length)
	{
		if (length == 0)
			return;

		char[] tmp = new char[length];

		for (int i = 0; i < length; i++)
		{
			tmp[i] = '\0';
		}

		WriteString(offset, tmp);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\perfstats\perfstatsdll\perfstatsdll.cpp ===
// PerfStatsDll.cpp : Defines the entry point for the DLL application.
//

#include "stdafx.h"
#define PERFSTATSDLL_EXPORTS
#include "PerfStatsDll.h"

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}


extern "C" PERFSTATSDLL_API unsigned __int64 GetCycleCount64(void)
{
    __asm rdtsc
}

#pragma warning(push)
#pragma warning(disable: 4035)
unsigned cpuid(int arg, unsigned char result[16])
{
    __asm
    {
        pushfd
        mov     eax, [esp]
        xor     dword ptr [esp], 1 shl 21 // Try to change ID flag
        popfd
        pushfd
        xor     eax, [esp]
        popfd
        and     eax, 1 shl 21             // Check whether ID flag changed
        je      no_cpuid                  // If not, 0 is an ok return value for us

        push    ebx
        push    esi
        mov     eax, arg
        cpuid
        mov     esi, result
        mov     [esi+ 0], eax
        mov     [esi+ 4], ebx
        mov     [esi+ 8], ecx
        mov     [esi+12], edx
        pop     esi
        pop     ebx
no_cpuid:
    }
}
#pragma warning(pop)

extern "C" PERFSTATSDLL_API unsigned GetL2CacheSize(void)
{
    unsigned char buffer[16];
    __try
    {
        int maxCpuId = cpuid(0, buffer);
        if (maxCpuId < 2)
            return 0;
        cpuid(2, buffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }

    for (int i = buffer[0]; --i >= 0; )
    {
        int j;
        for (j = 3; j < 16; j += 4)
        {
            // if the information in a register is marked invalid, set to null descriptors
            if  (buffer[j] & 0x80)
            {
                buffer[j-3] = 0;
                buffer[j-2] = 0;
                buffer[j-1] = 0;
                buffer[j-0] = 0;
            }
        }

        for (j = 1; j < 16; j++)
        {
            switch  (buffer[j])
            {
                case    0x41:
                case    0x79:
                case    0x81:
                    return  128*1024;

                case    0x42:
                case    0x7A:
                case    0x82:
                    return  256*1024;

                case    0x43:
                case    0x7B:
                case    0x83:
                    return  512*1024;

                case    0x44:
                case    0x7C:
                case    0x84:
                    return  1024*1024;

                case    0x45:
                case    0x85:
                    return  2*1024*1024;

                case    0x46:
                case    0x86:
                    return  4*1024*1024;

                case    0x47:
                case    0x87:
                    return  8*1024*1024;
            }
        }

        if  (i > 0)
            cpuid(2, buffer);
    }
    return  0;
}


extern "C" PERFSTATSDLL_API int GetProcessorSignature()
{
    unsigned char buffer[16];
    __try
    {
        int maxCpuId = cpuid(0, buffer);
        if (maxCpuId < 1)
            return 0;
        cpuid(1, buffer);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return 0;
    }
    return *(int *)buffer;
}


static int CopyResult(CHAR *result, CHAR *buffer, int bufferLen)
{
    int resultLen = strlen(result);
    if (resultLen > bufferLen)
        resultLen = bufferLen;
    memcpy(buffer, result, bufferLen*sizeof(CHAR));
    
    return resultLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\metadatatable.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System.IO;
using System.Diagnostics;


/*********************************************************************************************************************
 * This class represents a MetaData table.  It can be indexed by the [,] operator, with the first entry being the row
 * number and the second one being the column number.
 *********************************************************************************************************************/
internal class MetaDataTable
{
	internal uint			m_rowLen;
	internal uint			m_numRows;
	internal uint			m_numCols;
	private  ulong			m_startPos;
	internal uint[]			m_colDef;
	private  uint[]			m_colLen;
	private  BinaryReader	m_reader;
	private  BinaryWriter	m_writer;

	// This method initializes the column defintions and the accumulative column lengths.
	internal void Initialize(uint numCols, ulong startPos, ref uint[] colDef, ref BinaryReader reader, ref BinaryWriter writer)
	{
		uint i;

		m_numCols	= numCols;
		m_startPos	= startPos;
		m_colDef	= colDef;
		m_reader	= reader;
		m_writer	= writer;
		
		m_colLen = new uint[m_numCols];
		for (i = 1, m_rowLen = m_colDef[0], m_colLen[0] = 0; i < m_numCols; i++)
		{
			m_rowLen += m_colDef[i];
			m_colLen[i] = m_colLen[i - 1] + m_colDef[i - 1];
		}
	}

	// This indexer is used for accessing elements of the MetaData table.  Please note that the indexer is 1-based, not 0-based.
	// This is done so that the obfuscator is compatible to the documentation.
	internal uint this[uint row, uint col]
	{
		get 
		{
			row -= 1;										// change to 0-based internally
			col -= 1;

			Debug.Assert(col < m_numCols && row < m_numRows);

			ulong index = m_startPos + (ulong)(row * m_rowLen + m_colLen[col]);
			
			m_reader.BaseStream.Seek((long)index, SeekOrigin.Begin);
			if (m_colDef[col] == 2)
				return (uint)m_reader.ReadUInt16();
			else
				return m_reader.ReadUInt32();
		}
		set 
		{
			row -= 1;										// change to 0-based internally
			col -= 1;

			Debug.Assert(col < m_numCols && row < m_numRows);

			ulong index = m_startPos + (ulong)(row * m_rowLen + m_colLen[col]);
			
			m_writer.BaseStream.Seek((long)index, SeekOrigin.Begin);
			if (m_colDef[col] == 2)
				m_writer.Write((ushort)value);
			else
				m_writer.Write(value);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\perfstats\perfstatsexe\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET)
	echo This is needed to avoid a syntax error when processing this file. :-(


!if "$(TARGETCOMPLUS)" != ""
# Copy the files to the target COM+ directory
	copy $(COOL_TARGET) $(TARGETCOMPLUS)\int_tools
!endif

$(O)\Version.cs: Version.pp $(CORBASE)\src\inc\version\__file__.ver
	cl /EP /C $(COOL_EXTRA_PREPROCESS_FLAGS) /DCOOL_INCLUDE Version.pp > $(O)\Version.cs

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.exe=.pdb)
MANAGED_PDB_DESTINATION=$(TARGETCOMPLUS)\int_tools
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\treenode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;


/*********************************************************************************************************************
 * This class is a node which represents a class in the class inheritance hierarchy.
 *********************************************************************************************************************/
internal class TreeNode
{
	// These flags describe whether a class extends a class or an interface which is out of the current assembly.
	internal const byte OUTOFASSEMBLY			= 0x03;
	internal const byte OUTOFASSEMBLY_NONE		= 0x00; 
	internal const byte OUTOFASSEMBLY_CLASS		= 0x01; 
	internal const byte OUTOFASSEMBLY_INTERFACE	= 0x02; 
	internal const byte OUTOFASSEMBLY_BOTH		= 0x03; 

	private	uint		m_type;
	private byte		m_outOfAssem;
	private ArrayList	m_parentList = null, m_childList = null;

	public TreeNode(uint m_typeIndex, byte outOf)
	{
		m_type		= m_typeIndex;
		m_outOfAssem	= outOf;
		m_parentList	= new ArrayList();
		m_childList	= new ArrayList();
	}

	internal void AddParent(ref TreeNode parentNode)
	{
		m_parentList.Add(parentNode);
	}

	internal void AddChild(ref TreeNode childNode)
	{
		m_childList.Add(childNode);
	}

	// Search for a parent by its index in the list of parents.
	public TreeNode GetParent(int arrayIndex)
	{
		if (0 <= arrayIndex && arrayIndex < m_parentList.Count)
			return (TreeNode)m_parentList[arrayIndex];
		else
			return (TreeNode)null;	
	}

	// Search for a parent by its type index.
	public TreeNode GetParent(uint m_type)
	{
		for (int i = 0; i < m_parentList.Count; i++)
		{
			if (((TreeNode)m_parentList[i]).Type == m_type)
				return (TreeNode)m_parentList[i];
		}
		return (TreeNode)null;
	}

	// Search for a child by its index in the list of children.
	public TreeNode GetChild(int arrayIndex)
	{
		if (0 <= arrayIndex && arrayIndex < m_childList.Count)
			return (TreeNode)m_childList[arrayIndex];
		else
			return (TreeNode)null;	
	}

	// Search for a child by its m_type index.
	public TreeNode GetChild(uint m_type)
	{
		for (int i = 0; i < m_childList.Count; i++)
		{
			if (((TreeNode)m_childList[i]).Type == m_type)
				return (TreeNode)m_childList[i];
		}
		return (TreeNode)null;
	}

	// This method is for debugging purposes only.
	internal void Print(int indent, ref PTHeap heap, ref StringHeap strHeap)
	{
		for (int i = 0; i < indent; i++)
		{
			Console.Write("\t");
		}

		if (heap != null && strHeap != null && m_type != 0)
			Console.Write(strHeap.ReadString(heap.m_tables[PTHeap.TYPEDEF_TABLE][m_type, PTHeap.TYPEDEF_NAMESPACE_COL]) + "." + 
						  strHeap.ReadString(heap.m_tables[PTHeap.TYPEDEF_TABLE][m_type, PTHeap.TYPEDEF_NAME_COL]));
		else
			Console.Write("type: " + m_type);

		switch (m_outOfAssem)
		{
			case OUTOFASSEMBLY_NONE:
				Console.WriteLine("\tnone");
				break;

			case OUTOFASSEMBLY_CLASS:
				Console.WriteLine("\tclass");
				break;

			case OUTOFASSEMBLY_INTERFACE:
				Console.WriteLine("\tinterface");
				break;

			case OUTOFASSEMBLY_BOTH:
				Console.WriteLine("\tboth");
				break;

			default:
				break;
		}
	}

	public uint Type
	{
		get
		{
			return m_type;
		}
	}	

	public int ParentCount
	{
		get
		{
			return m_parentList.Count;
		}
	}

	public int ChildCount
	{
		get
		{
			return m_childList.Count;
		}
	}

	public byte OutOfAssem
	{
		get
		{
			return m_outOfAssem;
		}
		set
		{
			m_outOfAssem |= value;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\perfstats\perfstatsdll\perfstatsdll.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the PERFSTATSDLL_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// PERFSTATSDLL_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#ifdef PERFSTATSDLL_EXPORTS
#define PERFSTATSDLL_API __declspec(dllexport)
#else
#define PERFSTATSDLL_API __declspec(dllimport)
#endif


extern "C" PERFSTATSDLL_API unsigned __int64 GetCycleCount64(void);

extern "C" PERFSTATSDLL_API unsigned GetL2CacheSize(void);

extern "C" PERFSTATSDLL_API int GetProcessorSignature();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\perfstats\perfstatsdll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	PerfStatsDll.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\obfus.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.IO;
using System.Collections;
using System.Security.Cryptography;

using System.Reflection;
using System.Runtime;
using System.Resources;

[assembly: AssemblyVersionAttribute("1" + "." + "0" + "." + "3102" + "." + "0")]
[assembly: NeutralResourcesLanguageAttribute("en-US")]
[assembly: SatelliteContractVersionAttribute("1" + "." + "0" + "." + "3102" + "." + "0")]

namespace Util {
    internal class Version
    {
        public const String VersionString = "1" + "." + "0" + "." + "3319" + "." + "0";
        public const String SBSVersionString = "1" + "." + "0" + "." + "3319";
    }
}

internal class Obfus 
{
	// used to save the namespaces and the names of classes to exclude from obfuscation
	internal struct NameSpaceAndName
	{
		internal string	nameSpace;
		internal string name;
	}

	// used to store the new, obfuscated name and its offset into the string heap
	private struct NameInfo
	{
		internal uint	index;
		internal string	name;
	}

	// used to store which module a TypeRef is referring to
	private struct ModuleAndType
	{
		internal int	module;
		internal uint	type;
	}

	// used to store which module a MemberRef is referring to
	private struct MethodOrField
	{
		internal int	module;
		internal bool	method;
		internal uint	member;
	}

	// used to store the names and the signatures of non-obfuscatable virtual functions
	private struct NameAndSig
	{
		internal string	name;
		internal byte[]	sig;

		// We have to write our own "GetHashCode" and "Equals" so that the Hashtable will work properly with this struct.
		public override int GetHashCode()
		{
			int result = 0;

			for (int i = 0; i < sig.Length; i++)
			{
				result += sig[i].GetHashCode();
			}
			return result + name.GetHashCode();
		} 

		public override bool Equals(object that)
		{
			if (that == null)
				return false;

			if (this.name.Equals(((NameAndSig)that).name) && BlobHeap.CompareBlob(this.sig, ((NameAndSig)that).sig))
				return true;
			else
				return false;
		} 
	}

	// used to store a list of virtual methods with the same name and signature, and whether these virtual methods can be obfuscated or not
	private struct ObfusAndList
	{
		internal bool		obfus;
		internal ArrayList	indexList;
	}

	private char[]			m_strCounter;			// string counter used to obfuscate strings
	private MetaData		m_md;

	// BitArrays used to store whether each element is obfuscatable or not
	private BitArray		m_obfuscatableTypes, m_obfuscatableMethods, m_obfuscatableFields;
	private BitArray		m_obfuscatableProperties, m_obfuscatableEvents, m_obfuscatableParams;
	private BitArray		m_obfuscatableFiles;

	// BitArrays used to store which class is excluded from obfuscation, which method, property, and event has already been obfuscated,
	// and which method is an obfuscatable special method (getters/setters for properties and add/remove methods for events) 
	private BitArray		m_classesExcluded, m_methodsDone, m_propertiesDone, m_eventsDone, m_specialMethods;

	// These are mappings to store which new name is assigned to which element.  "m_obfusVirtual" is used in the same way,
	// but it is for virtual methods.
	private Hashtable		m_typeMapping, m_methodMapping,m_fieldMapping, m_propertyMapping, m_eventMapping, m_paramMapping;
	private Hashtable		m_obfusVirtual = null;

	private bool			m_isMainModule;				// indicate whether this module is the main one
	private string			m_fileName;					// name of this file
	private string[]		m_fileList			= null;		// name of all the entries in the File table
	private	ArrayList		m_moduleRefList		= null;		// list storing the MetaData sections of all modules in this assembly
	private ModuleAndType[]	m_typeRefToDef		= null;		// mapping from entries in the TypeRef table to the TypeDef table
	private MethodOrField[]	m_memberRefToDef	= null;		// mapping from entries in the MemberRef table to the Method or Field table

	private Hashtable		m_oldNameHash;				// Hashtable storing all existing names which cannot be obfuscated
	private MultiTree		m_classTree;				// class inheritance hierarhcy tree
	private FreeSpaceList	m_freeSpaceList;			// list of chunks of free spaces in the string heap

	// Following are various flags which we have to use when obfuscating.
	private const uint		TYPE_VISIBILITY_MASK		= 0x00000007;
	private const uint		TYPE_NOT_PUBLIC				= 0x00000000;
	private const uint		TYPE_PUBLIC					= 0x00000001;
	private const uint		TYPE_NESTED_PUBLIC			= 0x00000002;
	private const uint		TYPE_NESTED_PRIVATE			= 0x00000003;
	private const uint		TYPE_NESTED_FAMILY			= 0x00000004;
	private const uint		TYPE_NESTED_ASSEMBLY		= 0x00000005;
	private const uint		TYPE_NESTED_FAM_AND_ASSEM	= 0x00000006;
	private const uint		TYPE_NESTED_FAM_OR_ASSEM	= 0x00000007;

	private const uint		TYPE_CLASS_SEMANTICS_MASK	= 0x00000020;
	private const uint		TYPE_INTERFACE				= 0x00000020;
	private const uint		TYPE_SPECIAL_NAME			= 0x00000400;
	private const uint		TYPE_RESERVED_MASK			= 0x00040800;
	private const uint		TYPE_RT_SPECIAL_NAME		= 0x00000800;

    private const uint		METHOD_MEMBER_ACCESS_MASK	= 0x0007;
	private const uint		METHOD_FAMILY				= 0x0004;
	private const uint		METHOD_FAM_OR_ASSEM			= 0x0005;
	private const uint		METHOD_PUBLIC				= 0x0006;

    private const uint		METHOD_VIRTUAL				= 0x0040;
    private const uint		METHOD_VTABLE_LAYOUT_MASK	= 0x0100;
    private const uint		METHOD_NEWSLOT				= 0x0100;
	private const uint		METHOD_ABSTRACT				= 0x0400;
	private const uint		METHOD_SPECIAL_NAME			= 0x0800;
	private const uint		METHOD_RESERVED_MASK		= 0xd000;
	private const uint		METHOD_RT_SPECIAL_NAME		= 0x1000;

	// Methods with the Native, Runtime, or InternalCall bit set cannot be obfuscated.  Moreover, any class containing such methods
	// cannot be obfuscated as well.
	private const uint		METHODIMPL_CODE_TYPE_MASK	= 0x0003; 
	private const uint		METHODIMPL_NATIVE			= 0x0001; 
	private const uint		METHODIMPL_RUNTIME			= 0x0003; 
	private const uint		METHODIMPL_INTERNAL_CALL	= 0x1000; 

    private const uint		FIELD_FIELD_ACCESS_MASK		= 0x0007;
	private const uint		FIELD_FAMILY				= 0x0004;
	private const uint		FIELD_FAM_OR_ASSEM			= 0x0005;
	private const uint		FIELD_PUBLIC				= 0x0006;
	
    private const uint		FIELD_SPECIAL_NAME			= 0x0200;
    private const uint		FIELD_RESERVED_MASK			= 0x9500;
    private const uint		FIELD_RT_SPECIAL_NAME		= 0x0400;

	// These flags are used to check the signature of members for two purposes:
	// 1) to distinguish between fields and methods, and 
	// 2) to determine if a method has variable number of arguments.
	private const uint		CALLINGCONV					= 0x0f;
	private const uint		CALLINGCONV_STANDARD		= 0x00;
	private const uint		CALLINGCONV_VARARG			= 0x05;
	private const uint		CALLINGCONV_FIELD			= 0x06;

	internal uint m_TypeCount		= 0;			// counters for keeping track of how many elements can be obfuscated
	internal uint m_MethodCount		= 0;
	internal uint m_FieldCount		= 0;
	internal uint m_PropertyCount	= 0;
	internal uint m_EventCount		= 0;
	internal uint m_ParamCount		= 0;

	internal uint m_TypeTotal		= 0;			// total numbers of elements present
	internal uint m_MethodTotal		= 0;
	internal uint m_FieldTotal		= 0;
	internal uint m_PropertyTotal	= 0;
	internal uint m_EventTotal		= 0;
	internal uint m_ParamTotal		= 0;

    internal Obfus(ref MetaData md, ref char[] strCounter, string fileName, ref ArrayList mdInfoList, ref string[] fileList, bool isMain)
	{
		m_md			= md;
		m_strCounter	= strCounter;
		m_fileName		= fileName;
		m_moduleRefList	= mdInfoList;
		m_fileList		= fileList;
		m_isMainModule	= isMain;

		m_oldNameHash		= new Hashtable();
		m_classTree			= new MultiTree();
		m_freeSpaceList		= new FreeSpaceList();

		// Initialize every element as non-obfuscatable.
		if (m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE] != null)
		{
			m_obfuscatableTypes	= new BitArray((int)m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows, false);
			m_classesExcluded	= new BitArray((int)m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows, false);
		}
		if (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null)
		{
			m_obfuscatableMethods	= new BitArray((int)m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows, false);
			m_methodsDone			= new BitArray((int)m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows, false); 
			m_specialMethods		= new BitArray((int)m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows, false); 

			m_obfusVirtual = new Hashtable();
		}
		if (m_md.m_heap.m_tables[PTHeap.FIELD_TABLE] != null)
			m_obfuscatableFields	= new BitArray((int)m_md.m_heap.m_tables[PTHeap.FIELD_TABLE].m_numRows, false);
		if (m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE] != null)
		{
			m_obfuscatableProperties	= new BitArray((int)m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE].m_numRows, false);
			m_propertiesDone			= new BitArray((int)m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE].m_numRows, false);
		}
		if (m_md.m_heap.m_tables[PTHeap.EVENT_TABLE] != null)
		{
			m_obfuscatableEvents	= new BitArray((int)m_md.m_heap.m_tables[PTHeap.EVENT_TABLE].m_numRows, false);
			m_eventsDone			= new BitArray((int)m_md.m_heap.m_tables[PTHeap.EVENT_TABLE].m_numRows, false);
		}
		if (m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null)
			m_obfuscatableParams = new BitArray((int)m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows, false);

		if (m_isMainModule && m_md.m_heap.m_tables[PTHeap.FILE_TABLE] != null)
			m_obfuscatableFiles = new BitArray((int)m_md.m_heap.m_tables[PTHeap.FILE_TABLE].m_numRows, true);

		m_TypeTotal		= (m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE] != null	? m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows : 0);
		m_MethodTotal	= (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null	? m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows : 0); 
		m_FieldTotal	= (m_md.m_heap.m_tables[PTHeap.FIELD_TABLE] != null	? m_md.m_heap.m_tables[PTHeap.FIELD_TABLE].m_numRows : 0);
		m_PropertyTotal	= (m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE] != null	? m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE].m_numRows : 0);
		m_EventTotal	= (m_md.m_heap.m_tables[PTHeap.EVENT_TABLE] != null	? m_md.m_heap.m_tables[PTHeap.EVENT_TABLE].m_numRows : 0);
		m_ParamTotal	= (m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null	? m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows : 0);
	}

	/*********************************************************************************************************************
	 *	1)	Map entries in the ModuleRef table to entries in the File table.
	 *
	 *	2)	Map entries in the TypeRef table to entries in the corresponding TypeDef table, which may not necessarily 
	 *		be in this module.
	 *
	 *	3)	Map entries in the MemberRef table to entries in the corresponding Method or Field table, which may not 
	 *		necessarily be in this module.
	 *		
	 *	4)	Build the class inheritance hierarchy tree.
	 *
	 *	5)  Mark which classes are excluded.
	 *
	 *	6)  a) Determine which classes, methods, fields, properties, events, and parameters can be obfuscated.
	 *		b) Keep a counter of the number of each element which will be obfuscated.
	 *		c) Build a raw list of free spaces which can potentially be used/cleared.
	 *
	 *		Note: An excluded type is different from an obfuscated type, in that no members of an excluded type can be
	 *			  obfuscated, but that is not true for an non-obfuscatable type.
	 *********************************************************************************************************************/
	internal void Initialize()
	{
		uint	i, j, k;
		uint	startIndex, endIndex, startParamIndex, endParamIndex;
		uint	numRows, stringIndex;
		bool	obfuscatable, internalCall;

		string				name;
		TreeNode			curNode;
		NameSpaceAndName	excludeClass;							// used as key to the Hashtable of excluded classes

		if (m_isMainModule)
			HandleFileTable();
		MapTypeRefToDef();
		BuildInheritanceTree();
		MapMemberRefToDef();

		numRows = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows;

		// Mark classes as excluded if they have been specified by the user.
		if (ArgumentParser.m_ExcludeFlag)
		{
			for (i = 2; i <= numRows; i++)
			{
				// Get the namespace and the name of the current class.
				excludeClass.nameSpace	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAMESPACE_COL]);
				excludeClass.name		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAME_COL]);

				if (ArgumentParser.m_excludeTypeNames.ContainsKey(excludeClass))
				{
					ArgumentParser.m_excludeTypeNames[excludeClass] = true;
					if (!m_classesExcluded.Get((int)(i - 1)))
					{
						curNode = m_classTree.SearchDown(m_classTree.Root, i);
						ExcludeUpwards(i, ref curNode);				// exclude this class and all of its ancestor classes and interfaces
					}
				}
			}
		}

		// Start at 2 to skip the <Module> class.
		// TODO : We may have to include the <Module> class for global members.
		for (i = 2; i <= numRows; i++)
		{
			#if DEBUG1
				Console.Write(m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAMESPACE_COL]) + "." + 
							  m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAME_COL]) + ":" + i + " \t");
				Console.WriteLine(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_FLAGS_COL] & TYPE_VISIBILITY_MASK);
			#endif

			// If the current class is excluded, we have to mark all of its virtual methods as not obfuscatable.
			if (m_classesExcluded.Get((int)(i - 1)))
			{
				if (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null)
					HandleExcludedClass(i);
				continue;
			}

			curNode = m_classTree.SearchDown(m_classTree.Root, i);

			// Get the offset into the string heap of the current class name.
			stringIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAME_COL];
			obfuscatable = DetermineTypeObfuscatability(i);					// determine if the current class is obfuscatable
			if (obfuscatable)
			{
				m_obfuscatableTypes.Set((int)(i - 1), true); 								// mark it as obfuscatable
				m_TypeCount += 1;															// increment the counter
				m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));	// add the space this name takes up as free
			}
			else
			{
				name = m_md.m_strHeap.ReadString(stringIndex);						// add this name to the list of unusable names
				if (!m_oldNameHash.ContainsKey(name))
					m_oldNameHash.Add(name, stringIndex);
			}

			#if DEBUG1
				Console.WriteLine("\t\t\t****************");
			#endif

			// Determine the obfuscatability of methods of the current class.
			if (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null)
			{
				startIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_METHODLIST_COL];
				if ((i + 1) > m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows)
					endIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows + 1;
				else
					endIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i + 1, PTHeap.TYPEDEF_METHODLIST_COL];

				for (j = startIndex; j < endIndex; j++)						// for each method of the current class
				{
					#if DEBUG1
						Console.Write("\t\t\t" + m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][j, PTHeap.METHOD_NAME_COL]) + 
									  ":" + j + "\t");
						Console.WriteLine(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][j, PTHeap.METHOD_FLAGS_COL]);
					#endif

					// Check if this method is virtual or not.
					stringIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][j, PTHeap.METHOD_NAME_COL];
					if ((m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][j, PTHeap.METHOD_FLAGS_COL] & METHOD_VIRTUAL) == 0)
					{
						if (DetermineMethodObfuscatability(j, obfuscatable, out internalCall))
						{
							m_obfuscatableMethods.Set((int)(j - 1), true);
							m_MethodCount += 1;
							m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));

							// Deal with the parameters of the current method.
							if(m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null)
							{
								startParamIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][j, PTHeap.METHOD_PARAMLIST_COL];
								if ((j + 1) > m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows)
									endParamIndex = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows + 1;
								else
									endParamIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][j + 1, PTHeap.METHOD_PARAMLIST_COL];
								
								for (k = startParamIndex; k < endParamIndex; k++)
								{
									m_obfuscatableParams.Set((int)(k - 1), true);
									m_ParamCount += 1;
									stringIndex = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE][k, PTHeap.PARAM_NAME_COL];
									m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));
								}
							}
						}
						else
						{
							name = m_md.m_strHeap.ReadString(stringIndex);
							if (!m_oldNameHash.ContainsKey(name))
								m_oldNameHash.Add(name, stringIndex);

							// All methods with the InternalCall bit set are non-obfuscatable.  Moreover, the types containing
							// them are not obfuscatable as well.  So we have to reverse whatever we have already done for an
							// obfuscatable class.
							if (internalCall)
							{
								if (m_obfuscatableTypes.Get((int)(i - 1)))
								{
									m_obfuscatableTypes.Set((int)(i - 1), false);
									m_TypeCount -= 1;
									stringIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAME_COL];
									m_freeSpaceList.RawDelete(stringIndex, m_md.m_strHeap.StringLength(stringIndex));

									name = m_md.m_strHeap.ReadString(stringIndex);
									if (!m_oldNameHash.ContainsKey(name))
										m_oldNameHash.Add(name, stringIndex);
								}
							}
						}
					}
					else
					{
						HandleVirtualMethod(curNode, j, obfuscatable);		// if this method is virtual
					}
				}
			}

			#if DEBUG1
				Console.WriteLine("\t\t\t****************");
			#endif

			// Determine the obfuscatability of fields of the current class.  Fields are handled in much the same way as types.
			if (m_md.m_heap.m_tables[PTHeap.FIELD_TABLE] != null)
			{
				startIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_FIELDLIST_COL];
				if ((i + 1) > m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows)
					endIndex = m_md.m_heap.m_tables[PTHeap.FIELD_TABLE].m_numRows + 1;
				else
					endIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i + 1, PTHeap.TYPEDEF_FIELDLIST_COL];

				for (j = startIndex; j < endIndex; j++)
				{
					#if DEBUG1
						Console.Write("\t\t\t" + m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.FIELD_TABLE][j, PTHeap.FIELD_NAME_COL]) + 
									  ":" + j + "\t");
						Console.WriteLine(m_md.m_heap.m_tables[PTHeap.FIELD_TABLE][j, PTHeap.FIELD_FLAGS_COL] & FIELD_FIELD_ACCESS_MASK); 
					#endif

					stringIndex = m_md.m_heap.m_tables[PTHeap.FIELD_TABLE][j, PTHeap.FIELD_NAME_COL];
					if (DetermineFieldObfuscatability(j, obfuscatable))
					{
						m_obfuscatableFields.Set((int)(j - 1), true);
						m_FieldCount += 1;
						m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));
					}
					else
					{
						name = m_md.m_strHeap.ReadString(stringIndex);
						if (!m_oldNameHash.ContainsKey(name))
							m_oldNameHash.Add(name, stringIndex);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Try to open each entry in the File table and call MetaData.Initialize() on all of them.  This method is only called
	 *	by the main module.  Please note that although each entry in the ModuleRef table should correspond to an entry in 
	 *	the File table, that is not necessarily the case for some of the BCL assemblies such as System.Drawing.dll and 
	 *	System.Windows.Forms.dll.  Also, all modules of an assembly have to be in the same directory.
	 *********************************************************************************************************************/
	private void HandleFileTable()
	{
		uint	i, numFileRows;
		string	inFileName;
		byte[]	buf;

		FileStream		inFileStream;
		BinaryReader	inFileReader = null;
		MetaData		md;
		Obfus			obfus;

		if (m_md.m_heap.m_tables[PTHeap.FILE_TABLE] != null)										// check if the File table is null
		{
			// Populate "m_fileList" with entries in the File table.  (Only the main module has a File table.)
			numFileRows	= m_md.m_heap.m_tables[PTHeap.FILE_TABLE].m_numRows;
			m_fileList	= new string[numFileRows];
			for (i = 1; i <= numFileRows; i++)
			{
				m_fileList[i - 1] = m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.FILE_TABLE][i, PTHeap.FILE_NAME_COL]);
			}

			// Call MetaData.Initialize on each entry.  Note that some of these files may not be a CIL binary file.
			// In that case, we catch the exception and simply continue to the next entry.
			for (i = 0; i < numFileRows; i++)
			{
				// Prepend the full path to the referenced module name.
				inFileName = PrependFullPath(m_fileName, m_fileList[i]).Trim('\0');

				// We want to check for exceptions meaning that the referenced module is not in CIL binary format.
				// For example, gdiplus.dll is in invalid format and is referenced by System.Drawing.dll.
				// Also, we have to close the file reader before copying the file.
				try
				{
					inFileStream	= File.Open(inFileName, FileMode.Open, FileAccess.Read, FileShare.Read);
					inFileReader	= new BinaryReader(inFileStream);
					buf				= PEParser.ParsePEFile(ref inFileReader);
					inFileReader.Close();									// this call also closes the underlying stream

					md		= new MetaData(ref buf);
					obfus	= new Obfus(ref md, ref m_strCounter, inFileName, ref m_moduleRefList, ref m_fileList, false);
					obfus.Initialize();
					m_moduleRefList.Add(obfus);					// add the initialized MetaData section to the MetaData list
				}
				catch (IOException)
				{
					m_obfuscatableFiles.Set((int)i, false);

					if (inFileReader != null)
						inFileReader.Close();								// this call also closes the underlying stream

					if (File.Exists(inFileName))
					{
						if (!ArgumentParser.m_SuppressFlag)					// suppress warning messages if this flag is set
							Console.WriteLine("  WARNING:  Referenced module file " + inFileName + " is not in valid CIL binary format."); 
						File.Copy(inFileName, ArgumentParser.m_outFilePath + inFileName.Substring(m_fileName.LastIndexOf('\\') + 1), true);
					}
					else
					{
						if (!ArgumentParser.m_SuppressFlag)
							Console.WriteLine("  WARNING:  Cannot find referenced module file " + inFileName + "."); 
						continue;
					}
				}
				catch (InvalidFileFormat)
				{
					m_obfuscatableFiles.Set((int)i, false);

					if (inFileReader != null)
						inFileReader.Close();								// this call also closes the underlying stream

					if (!ArgumentParser.m_SuppressFlag)
						Console.WriteLine("  WARNING:  Referenced module file " + inFileName + " is not in valid CIL binary format."); 
					File.Copy(inFileName, ArgumentParser.m_outFilePath + inFileName.Substring(m_fileName.LastIndexOf('\\') + 1), true);
				}
			}
		}
		else
			return;
	}

	/*********************************************************************************************************************
	 *	This method prepends the full path in "fullPath" to "name.
	 *********************************************************************************************************************/
	private string PrependFullPath(string fullPath, string name)
	{
		string tmp;
		tmp = fullPath.Substring(0, fullPath.LastIndexOf('\\') + 1);	// make a substring from the start of "fullPath" to the last '/'
		tmp = String.Concat(tmp, name);
		return tmp;
	}

	/*********************************************************************************************************************
	 *	Map entries in the TypeRef table to entries in the corresponding TypeDef table, which may not necessarily be in 
	 *	this module.  The mapping used for TypeRefs take into account the module as well (it keeps track of the module by
	 *	an index into the MetaData list "m_moduleRefList").
	 *********************************************************************************************************************/
	private void MapTypeRefToDef()
	{
		int		k;
		uint	i, j, numTypeDefRows, numTypeDefRows2, numTypeRefRows;		// numTypeDefRows2 used for other referenced modules
		uint	resolutionScope, table, row, enclosingIndex;
		string	nameSpace, name, nameSpaceCheck, nameCheck, localModuleName;
		Obfus	obfusThere;													// MetaData section in other referenced modules

		if (m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE] == null || m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE] == null)
			return;

		numTypeDefRows	= m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows;
		numTypeRefRows	= m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE].m_numRows;
		m_typeRefToDef	= new ModuleAndType[numTypeRefRows];				// initialize the mapping
		for (i = 1; i <= numTypeRefRows; i++)								// for each entry in the TypeRef table
		{
			m_typeRefToDef[i - 1].module	= -1;								// -1 means the TypeRef points to the current module
			m_typeRefToDef[i - 1].type	= 0;								// 0 for "type" indicates an invalid mapping
			// Resolve the token.  It can point to the Module, ModuleRef, AssemblyRef, and TypeRef table.
			resolutionScope = m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_RESOLUTIONSCOPE_COL];
			IndexDecoder.DecodeResolutionScope(resolutionScope, out table, out row);

			// If "resolutionScope" is 0, then this is a non-nested type which may be in the TypeDef table, so compare the namespace 
			// and the name of the type.  If "table" is "PTHeap.MODULE_TABLE", then we have to check the current module.
			if (resolutionScope == 0 || resolutionScope == 1 ||table == PTHeap.MODULE_TABLE)
			{
				nameSpace	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAMESPACE_COL]);
				name		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAME_COL]);

				for (j = 1; j <= numTypeDefRows; j++)
				{
					nameSpaceCheck	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][j, PTHeap.TYPEDEF_NAMESPACE_COL]);
					nameCheck		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][j, PTHeap.TYPEDEF_NAME_COL]);

					if (nameSpace.Equals(nameSpaceCheck) && name.Equals(nameCheck))
					{
						if (m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE] == null ||
							FindIndex(PTHeap.NESTEDCLASS_TABLE, PTHeap.NESTEDCLASS_NESTEDCLASS_COL, j, 
									  1, m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE].m_numRows) == 0)
						{
							m_typeRefToDef[i - 1].module	= -1; 
							m_typeRefToDef[i - 1].type		= j; 
							break;
						}
					}
				}
			}
			// This type is out of this assembly, so it cannot be in the TypeDef table.
			else if (table == PTHeap.ASSEMBLYREF_TABLE)
			{
				continue;
			}
			//  This is a nested class.  We have to check its enclosing class.
			else if (table == PTHeap.TYPEREF_TABLE)
			{
				// The enclosing class does not resolve to a TypeDef, so it is not in this assembly.
				if (m_typeRefToDef[row - 1].type == 0)
					continue;

				nameSpace	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAMESPACE_COL]);
				name		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAME_COL]);

				if (m_typeRefToDef[row - 1].module == -1)							// if the enclosing class is in this module
				{
					// Search for the current type, starting from its enclosing class.
					for (j = row + 1; j <= numTypeDefRows; j++)
					{
						nameSpaceCheck	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][j, PTHeap.TYPEDEF_NAMESPACE_COL]);
						nameCheck		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][j, PTHeap.TYPEDEF_NAME_COL]);

						if (nameSpace.Equals(nameSpaceCheck) && name.Equals(nameCheck))
						{
							// Even if the namespace and name match, we still have to check the enclosing class to make sure.
							enclosingIndex = FindIndex(PTHeap.NESTEDCLASS_TABLE, PTHeap.NESTEDCLASS_NESTEDCLASS_COL, j, 1, 
													   m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE].m_numRows);

							// If the enclosing class matches, then we can assign the mapping accordingly.
							if (enclosingIndex != 0 && 
								m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE][enclosingIndex, PTHeap.NESTEDCLASS_ENCLOSINGCLASS_COL] == 
									m_typeRefToDef[row - 1].type)
							{
								m_typeRefToDef[i - 1].module	= -1;
								m_typeRefToDef[i - 1].type	= j;
								break;
							}
						}
					}
				}
				else															// if the enclosing class is in a different module
				{
					obfusThere		= (Obfus)m_moduleRefList[m_typeRefToDef[row - 1].module];
					numTypeDefRows2	= obfusThere.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows;

					for (j = m_typeRefToDef[row - 1].type + 1; j <= numTypeDefRows2; j++)
					{
						nameSpaceCheck= obfusThere.m_md.m_strHeap.ReadString(obfusThere.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE]
																		[j, PTHeap.TYPEDEF_NAMESPACE_COL]);
						nameCheck= obfusThere.m_md.m_strHeap.ReadString(obfusThere.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE]
																   [j, PTHeap.TYPEDEF_NAME_COL]);

						if (nameSpace.Equals(nameSpaceCheck) && name.Equals(nameCheck))
						{
							enclosingIndex = obfusThere.FindIndex(PTHeap.NESTEDCLASS_TABLE, PTHeap.NESTEDCLASS_NESTEDCLASS_COL, j, 1, 
																  obfusThere.m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE].m_numRows);

							if (enclosingIndex != 0 && 
								obfusThere.m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE]
									[enclosingIndex, PTHeap.NESTEDCLASS_ENCLOSINGCLASS_COL] == m_typeRefToDef[row - 1].type)
							{
								m_typeRefToDef[i - 1].module	= m_typeRefToDef[row - 1].module;
								m_typeRefToDef[i - 1].type	= j;
								break;
							}
						}
					}
				}
			}
			// This is not a nested class.   We have to check the ModuleRef table.
			else if (table == PTHeap.MODULEREF_TABLE)
			{
				// Determine which module is being referenced.
				localModuleName = PrependFullPath(m_fileName, m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.MODULEREF_TABLE]
																				   [row, PTHeap.MODULEREF_NAME_COL]).Trim('\0'));

				for (k = 0; k < m_moduleRefList.Count; k++)
				{
					if (localModuleName.Equals(((Obfus)m_moduleRefList[k]).m_fileName))
					{
						obfusThere		= (Obfus)m_moduleRefList[k];
						numTypeDefRows2	= obfusThere.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows;

						nameSpace	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAMESPACE_COL]);
						name		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAME_COL]);

						for (j = 1; j <= numTypeDefRows2; j++)
						{
							nameSpaceCheck	= obfusThere.m_md.m_strHeap.ReadString(obfusThere.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE]
																			  [j, PTHeap.TYPEDEF_NAMESPACE_COL]);
							nameCheck		= obfusThere.m_md.m_strHeap.ReadString(obfusThere.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE]
																			  [j, PTHeap.TYPEDEF_NAME_COL]);

							// Match namespace, name, and enclosing class.
							if (nameSpace.Equals(nameSpaceCheck) && name.Equals(nameCheck))
							{
								if (obfusThere.m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE] == null ||
									obfusThere.FindIndex(PTHeap.NESTEDCLASS_TABLE, PTHeap.NESTEDCLASS_NESTEDCLASS_COL, j, 1, 
										obfusThere.m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE].m_numRows) == 0)
								{
									m_typeRefToDef[i - 1].module	= k;
									m_typeRefToDef[i - 1].type	= j;
									break;
								}
							}
						}
						break;
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Map entries in the MemberRef table to entries in the corresponding Method or Field table, which may not 
	 *	necessarily be in this module.  The mapping used contains the module index in the MetaData list "m_moduleRefList", 
	 *	whether the member is a method or a field, and the index of the method/field.
	 *********************************************************************************************************************/
	private void MapMemberRefToDef()
	{
		uint	i, numMemberRefRows;
		uint	table, row, typeIndex;
		byte[]	blob;
		string	name;

		Obfus		obfus;
		TreeNode	curNode;

		if (m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE] == null)				// do nothing if there is no MemberRef
			return;

		numMemberRefRows	= m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE].m_numRows;
		m_memberRefToDef		= new MethodOrField[numMemberRefRows];		// initialize the mapping

		for (i = 1; i <= numMemberRefRows; i++)
		{
			m_memberRefToDef[i - 1].module	= -1;						// -1 for .module means the member is in the current module
			m_memberRefToDef[i - 1].method	= true;
			m_memberRefToDef[i - 1].member	= 0;						// 0 for .member means it's an invalid mapping

			// Resolve the parent token of the current MemberRef.  This token can point to the TypeDef (no longer supported), 
			// TypeRef, ModuleRef, MethodDef, and TypeSpec table.
			IndexDecoder.DecodeMemberRefParent(m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE][i, PTHeap.MEMBERREF_CLASS_COL], out table, out row);

			switch (table)
			{
				// The TypeDef table is no longer referenced by entries in the MemberRef table.
				case PTHeap.TYPEDEF_TABLE:
					break;

				case PTHeap.TYPEREF_TABLE:
					if (m_typeRefToDef[row - 1].type == 0)				// this TypeRef does not resolve to a TypeDef in this assembly
						continue;

					name	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE][i, PTHeap.MEMBERREF_NAME_COL]);
					blob	= m_md.m_blobHeap.ReadBlob(m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE][i, PTHeap.MEMBERREF_SIGNATURE_COL]);

					typeIndex = m_typeRefToDef[row - 1].type;
					m_memberRefToDef[i - 1].module = m_typeRefToDef[row - 1].module;	// set the module index in the mapping

					if (m_typeRefToDef[row - 1].module == -1)				// get the module in which this TypeRef is defined
						obfus = this;
					else
						obfus = (Obfus)m_moduleRefList[m_typeRefToDef[row - 1].module];

					// Search for this type in the appropriate MetaData section, and determine if the member is a field or a method.
					// Then we have to find out if the member belongs to this TypeRef or its ancestor classes and interfaces.
					curNode = obfus.m_classTree.SearchDown(obfus.m_classTree.Root, typeIndex);
					if ((blob[0] & CALLINGCONV) == CALLINGCONV_FIELD)
						MapUpwards(typeIndex, curNode, ref m_memberRefToDef[i - 1], name, blob, PTHeap.FIELD_TABLE, 5, 2, 3, obfus);
					else
						MapUpwards(typeIndex, curNode, ref m_memberRefToDef[i - 1], name, blob, PTHeap.METHOD_TABLE, 6, 4, 5, obfus);

					break;
				
				// TODO : Global members.
				case PTHeap.MODULEREF_TABLE:
					break;

				// This case is a direct resolution.
				case PTHeap.METHOD_TABLE:
					m_memberRefToDef[i - 1].member = row;

					break;
					
				// We can ignore this case because the TypeSpec table only stores array types created by the compiler.
				case PTHeap.TYPESPEC_TABLE:
					break;
			}
		}
	}

	/*********************************************************************************************************************
	 *	This method searches for a field or a method in the current type or its ancestor classes or interfaces, and fill
	 *	out the information in the struct "info" for the mapping.
	 *********************************************************************************************************************/
	private bool MapUpwards(uint origTypeIndex, TreeNode curNode, ref MethodOrField info, string name, byte[] blob, 
							uint table, uint typeCol, uint nameCol, uint sigCol, Obfus obfus)
	{
		int		i;
		uint	j, startIndex, endIndex;
		TreeNode	parentNode;
		
		if(obfus.m_md.m_heap.m_tables[table] == null) return false;

		// Get the range of the fields/methods of the current type.
		startIndex = obfus.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][origTypeIndex, typeCol];
		if ((origTypeIndex + 1) > obfus.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows)
			endIndex = obfus.m_md.m_heap.m_tables[table].m_numRows + 1;
		else
			endIndex = obfus.m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][origTypeIndex + 1, typeCol];

		// For each field/method, check its name and signature, and fill out the information if they match.
		for (j = startIndex; j < endIndex; j++)
		{
			if ( name.Equals(obfus.m_md.m_strHeap.ReadString(obfus.m_md.m_heap.m_tables[table][j, nameCol])) &&
				 BlobHeap.CompareBlob(blob, obfus.m_md.m_blobHeap.ReadBlob(obfus.m_md.m_heap.m_tables[table][j, sigCol])) )
			{
				info.method	= (typeCol == 6);
				info.member	= j;

				return true;
			}
		}

		// If we cannot find the MemberRef in this type, we have to go through each of its parents.
		// Note that we should never have to trace across modules for a parent, because if that is the case, both modules 
		// should be in the ModuleRef table.  (E.g. Module A defines a class "foo", Module B references Module A, and if
		// Module C wants to make use of "foo", it has to include Module A in its ModuleRef table.) 
		for (i = 0; i < curNode.ParentCount; i++)
		{
			parentNode = curNode.GetParent(i);

			if (parentNode.Type != 0)
			{
				if (MapUpwards(parentNode.Type, parentNode, ref info, name, blob, table, typeCol, nameCol, sigCol, obfus))
					return true;
			}
		}
		return false;												// return false if we cannot find it
	}

	/*********************************************************************************************************************
	 *	This method builds the inheritance hierarchy tree in a bottom-up fashion, since it is easier to trace up
	 *	than to trace down.  The tree only contains classes and interfaces defined in this module.
	 *********************************************************************************************************************/
	private void BuildInheritanceTree()
	{
		uint		i, numRows;
		TreeNode	curNode;

		// "builtTypes" keeps track of which classes have already been added to the tree. 
		BitArray	builtTypes = new BitArray((int)m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows, false);

		if (m_md.m_heap.m_tables[PTHeap.INTERFACEIMPL_TABLE] != null)							// get the number of interfaces
			numRows = m_md.m_heap.m_tables[PTHeap.INTERFACEIMPL_TABLE].m_numRows;
		else
			numRows = 0;

		// Building the tree bottom-up is easier.
		for (i = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows; i > 0; i--)
		{
			if (builtTypes.Get((int)(i - 1))) continue;								// skip if we have already built this type

			curNode = new TreeNode(i, TreeNode.OUTOFASSEMBLY_NONE);						// create a new node
			ScanUpwards(ref curNode, ref builtTypes, numRows);
		}
	}

	/*********************************************************************************************************************
	 *	Scan up from the current type and build the tree until we hit the root, which has type index 0 and does not represent
	 *	any type.  We hit the root if:
	 *	1) a type inherits from another type outside of this module, or
	 *	2) a type does not inherit from anything.
	 *  Note that all classes inherit from System.Object, which is in mscorlib.dll.
	 *	Also note that a class inherits all interfaces it implements in the InterfaceImpl table.
	 *	(E.g. Suppose Interface IB inherits from Interface IA, and suppose Class C extends IB only.  Nevertheless, all methods 
	 *	in IA must be implemented by C, and C implements both IA and IB in the InterfaceImpl table.  Also, IB implements IA in
	 *	the InterfaceImpl table as well.)
	 *********************************************************************************************************************/
	private void ScanUpwards(ref TreeNode originalNode, ref BitArray builtTypes, uint numRows)
	{
		uint	i, index, startIndex, endIndex;
		uint	table, baseTypeIndex;

		uint		curTypeIndex = originalNode.Type;
		TreeNode	curNode = originalNode;
		
		// Check the InterfaceImpl table.
		if (numRows > 0)
		{
			// Here we use binary search to find one corresponding entry in the InterfaceImpl table.  If the current type does
			// not implement any interface, then 0 is returned from the call to FindIndex().  If a non-zero value is returned,
			// then we decrement "startIndex" and increment "endIndex" until we have the range of corresponding entries in the
			// InterfaceImpl table.
			for (startIndex = FindIndex(PTHeap.INTERFACEIMPL_TABLE, 1, curTypeIndex, 1, numRows), endIndex = startIndex;
				 startIndex > 1 && 
					(m_md.m_heap.m_tables[PTHeap.INTERFACEIMPL_TABLE][startIndex - 1, PTHeap.INTERFACEIMPL_CLASS_COL] == curTypeIndex); 
				 startIndex--) {}

			if (endIndex != 0)												// if this type inherits from any interface
			{
				for (; endIndex < numRows && 
							m_md.m_heap.m_tables[PTHeap.INTERFACEIMPL_TABLE][endIndex + 1, PTHeap.INTERFACEIMPL_CLASS_COL] == curTypeIndex;
					   endIndex++) {}

				for (i = startIndex; i <= endIndex; i++)					// for each interface this type inherits
				{
					// Get the token and resolve it to determine which module the interface is defined in.
					index = m_md.m_heap.m_tables[PTHeap.INTERFACEIMPL_TABLE][i, PTHeap.INTERFACEIMPL_INTERFACE_COL];
					IndexDecoder.DecodeTypeDefOrRef(index, out table, out baseTypeIndex);

					if (table == PTHeap.TYPEDEF_TABLE)
					{
						// If we have not added this type to the tree yet, add it.
						if (m_classTree.SearchUp(curNode, baseTypeIndex) == null)
						{
							curNode	= m_classTree.AddParent(ref curNode, baseTypeIndex);			// add the parent to the current type
							if (!builtTypes.Get((int)(baseTypeIndex - 1)))
								ScanUpwards(ref curNode, ref builtTypes, numRows);
																			// continue with the parent if it has not been added yet
							curNode = originalNode;
						}
					}
					else if (table == PTHeap.TYPEREF_TABLE)
					{
						// if the TypeRef resolves to a TypeDef in this module
						if (m_typeRefToDef[baseTypeIndex - 1].type != 0 && m_typeRefToDef[baseTypeIndex - 1].module == -1)	
						{
							baseTypeIndex = m_typeRefToDef[baseTypeIndex - 1].type;

							if (m_classTree.SearchUp(curNode, baseTypeIndex) == null)
							{
								curNode	= m_classTree.AddParent(ref curNode, baseTypeIndex);
								if (!builtTypes.Get((int)(baseTypeIndex - 1)))
									ScanUpwards(ref curNode, ref builtTypes, numRows);

								curNode = originalNode;
							}
						}
						else
						{
							// if the TypeRef does not resolve to a TypeDef in this assembly 
							if (m_typeRefToDef[baseTypeIndex - 1].type == 0)
								curNode.OutOfAssem = TreeNode.OUTOFASSEMBLY_INTERFACE;

							if (!builtTypes.Get((int)(curTypeIndex - 1)))
							{
								builtTypes.Set((int)(curTypeIndex - 1), true);
								m_classTree.AddToRoot(ref curNode);
							}
						}
					}
				}
				builtTypes.Set((int)(curTypeIndex - 1), true);
			}
		}

		// So we have finished handling all the interface the current type implements.  Now we have to check if it inherits from
		// another class.
		index = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][curTypeIndex, PTHeap.TYPEDEF_EXTENDS_COL];

		// This type does not extend anything, so we can return from this method.
		if (index == 0)
		{
			if (!builtTypes.Get((int)(curTypeIndex - 1)))
			{
				builtTypes.Set((int)(curTypeIndex - 1), true);
				m_classTree.AddToRoot(ref curNode);
			}
			return;
		}

		IndexDecoder.DecodeTypeDefOrRef(index, out table, out baseTypeIndex);

		if (table == PTHeap.TYPEDEF_TABLE)
		{
			builtTypes.Set((int)(curTypeIndex - 1), true);

			curNode	= m_classTree.AddParent(ref curNode, baseTypeIndex);
			if (!builtTypes.Get((int)(baseTypeIndex - 1)))
				ScanUpwards(ref curNode, ref builtTypes, numRows);

			curNode = originalNode;
		}
		else if (table == PTHeap.TYPEREF_TABLE)
		{
			// if the current type extends a class from this module
			if (m_typeRefToDef[baseTypeIndex - 1].type != 0 && m_typeRefToDef[baseTypeIndex - 1].module == -1)
			{
				baseTypeIndex = m_typeRefToDef[baseTypeIndex - 1].type;

				builtTypes.Set((int)(curTypeIndex - 1), true);

				curNode	= m_classTree.AddParent(ref curNode, baseTypeIndex); 
				if (!builtTypes.Get((int)(baseTypeIndex - 1)))
					ScanUpwards(ref curNode, ref builtTypes, numRows);

				curNode = originalNode;
			}
			else
			{
				// if the TypeRef does not resolve to a TypeDef in this assembly 
				if (m_typeRefToDef[baseTypeIndex - 1].type == 0)
					curNode.OutOfAssem = TreeNode.OUTOFASSEMBLY_CLASS;

				if (!builtTypes.Get((int)(curTypeIndex - 1)))
				{
					builtTypes.Set((int)(curTypeIndex - 1), true);
					m_classTree.AddToRoot(ref curNode);
				}
				return;
			}
		}
	}
	
	/*********************************************************************************************************************
	 *	This method marks "origTypeIndex" as excluded, and traces up the class inheritance hierarchy tree and marks
	 *	all its ancestors as excluded.
	 *********************************************************************************************************************/
	private void ExcludeUpwards(uint origTypeIndex, ref TreeNode curNode)
	{
		int			i;
		TreeNode	parentNode;

		m_classesExcluded.Set((int)(origTypeIndex - 1), true);
		for (i = 0; i < curNode.ParentCount; i++)
		{
			parentNode = curNode.GetParent(i);
			
			if (parentNode.Type != 0)
				ExcludeUpwards(parentNode.Type, ref parentNode);
		}
	}

	/*********************************************************************************************************************
	 * This method marks all the virtual methods of an excluded class as non-obfuscatable.
	 *********************************************************************************************************************/
	private void HandleExcludedClass(uint typeIndex)
	{
		uint			i, startIndex, endIndex;
		NameAndSig		virtualInfo;
		ObfusAndList	virtualList;

		virtualList.indexList = new ArrayList();
		
		startIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][typeIndex, PTHeap.TYPEDEF_METHODLIST_COL];
		if ((typeIndex + 1) > m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows)
		{
			if(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null)
				endIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows + 1;
			else
				endIndex = 0;
		}
		else
			endIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][typeIndex + 1, PTHeap.TYPEDEF_METHODLIST_COL];

		for (i = startIndex; i < endIndex; i++)												// for each method of this class 
		{
			if ((m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][i, PTHeap.METHOD_FLAGS_COL] & METHOD_VIRTUAL) != 0)				// if the method is virtual
			{
				virtualInfo.name	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][i, PTHeap.METHOD_NAME_COL]);
				virtualInfo.sig		= m_md.m_blobHeap.ReadBlob(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][i, PTHeap.METHOD_SIGNATURE_COL]);

				// Check if the list of virtual methods already contains this method.
				if (!m_obfusVirtual.ContainsKey(virtualInfo))
				{
					virtualList.obfus = false;
					virtualList.indexList.Clear();
					virtualList.indexList.Add(i);							// add the index of this method to the index list
					m_obfusVirtual.Add(virtualInfo, virtualList);
				}
				else
				{
					virtualList = (ObfusAndList)m_obfusVirtual[virtualInfo];
					virtualList.obfus = false;
					virtualList.indexList.Add(i);							// add the index of this method to the index list
					m_obfusVirtual[virtualInfo] = virtualList;
				}
			}
		}
	}

	/*********************************************************************************************************************
	 * Given the index of a type, find out whether it is obfuscatable or not.
	 *********************************************************************************************************************/
	private bool DetermineTypeObfuscatability(uint typeIndex)
	{
		uint typeFlags, nestedIndex, numNestedClass = 0;

		if (m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE] != null)
			numNestedClass = m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE].m_numRows;

		for (;;)
		{
			typeFlags = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][typeIndex, PTHeap.TYPEDEF_FLAGS_COL];
			if ( (typeFlags & TYPE_SPECIAL_NAME) != 0 || (typeFlags & TYPE_RESERVED_MASK) == TYPE_RT_SPECIAL_NAME )
				return false;										// check for the Special and the RTSpecial bits

			if (ArgumentParser.m_EverythingFlag)					// obfuscate as much as possible, regardless of visibility
				return true;

			switch(typeFlags & TYPE_VISIBILITY_MASK)
			{
				case TYPE_NOT_PUBLIC:
				case TYPE_NESTED_PRIVATE:
				case TYPE_NESTED_ASSEMBLY:
				case TYPE_NESTED_FAM_AND_ASSEM:
					#if DEBUG_NESTED
						Console.WriteLine("non-public");
					#endif

					return true;

				case TYPE_PUBLIC:
					#if DEBUG_NESTED
						Console.WriteLine("public");
					#endif

					return false;

				case TYPE_NESTED_PUBLIC:							// for these flags, we have to check the enclosing class
				case TYPE_NESTED_FAMILY:
				case TYPE_NESTED_FAM_OR_ASSEM:
					// Find the index of the enclosing class.
					nestedIndex = FindIndex(PTHeap.NESTEDCLASS_TABLE, PTHeap.NESTEDCLASS_NESTEDCLASS_COL, typeIndex, 1, numNestedClass);
					#if DEBUG_NESTED
						Console.WriteLine("\tnested index: " + nestedIndex);
					#endif

					// Check the enclosing class by looping.
					typeIndex = m_md.m_heap.m_tables[PTHeap.NESTEDCLASS_TABLE][nestedIndex, PTHeap.NESTEDCLASS_ENCLOSINGCLASS_COL];
					#if DEBUG_NESTED
						Console.WriteLine("\tenclosing type: " + typeIndex);
					#endif

					break;

				default:
					#if DEBUG_NESTED
						Console.WriteLine("Should not reach here");
					#endif

					return false;
			}
		}
	}

	/*********************************************************************************************************************
	 *	Given the index of a method and the obfuscatability of the class containing it, find out whether it is obfuscatable 
	 *	or not.
	 *********************************************************************************************************************/
	private bool DetermineMethodObfuscatability(uint methodIndex, bool typeObfuscatable, out bool internalCall)
	{
		uint	methodFlags;
		byte[]	blob;
		string	name;

		methodFlags = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_IMPLFLAGS_COL];
		if ((methodFlags & METHODIMPL_INTERNAL_CALL) == 0)						// check the InternalCall bit
		{
			internalCall = false;

			// Check for the Native and Runtime bits
			if ((methodFlags & METHODIMPL_CODE_TYPE_MASK) != METHODIMPL_NATIVE && 
				(methodFlags & METHODIMPL_CODE_TYPE_MASK) != METHODIMPL_RUNTIME)
			{
				methodFlags = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_FLAGS_COL];

				// Constructors, getters/setters for properties, and add/remove methods for events are methods with the 
				// SpecialName bit set.
				if ( (methodFlags & METHOD_SPECIAL_NAME) == 0 && (methodFlags & METHOD_RESERVED_MASK) != METHOD_RT_SPECIAL_NAME )
				{
					methodFlags &= METHOD_MEMBER_ACCESS_MASK;

					// Check the accessibility of the method.
					if (ArgumentParser.m_EverythingFlag || typeObfuscatable || 
						(methodFlags != METHOD_FAMILY && methodFlags != METHOD_FAM_OR_ASSEM && methodFlags != METHOD_PUBLIC))
					{
						blob = m_md.m_blobHeap.ReadBlob(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_SIGNATURE_COL]);
						if ((blob[0] & CALLINGCONV) != CALLINGCONV_VARARG)		// check if the method has variable number of arguments
							return true;
					}
				}
				else
				{
					if ((methodFlags & METHOD_RESERVED_MASK) != METHOD_RT_SPECIAL_NAME)		// if only the Special bit is set
					{
						// Check if this special method is obfuscatable if we ignore accessibility.
						name = m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_NAME_COL]);
						if (name.StartsWith("get_") || name.StartsWith("set_") || name.StartsWith("add_") || name.StartsWith("remove_"))
						{
							if ((methodFlags & METHOD_VIRTUAL) == 0)						// only obfuscate non-virtual special methods
							{
								methodFlags &= METHOD_MEMBER_ACCESS_MASK;

								// Check the accessibility of the method.
								if (ArgumentParser.m_EverythingFlag || typeObfuscatable || 
									(methodFlags != METHOD_FAMILY && methodFlags != METHOD_FAM_OR_ASSEM && methodFlags != METHOD_PUBLIC))
								{
									blob = m_md.m_blobHeap.ReadBlob(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_SIGNATURE_COL]);

									// check if the method has variable number of arguments
									if ((blob[0] & CALLINGCONV) != CALLINGCONV_VARARG)
									{
										m_specialMethods.Set((int)(methodIndex - 1), true);	// set this method as special
										return true;
									}
								}
							}
						}
					}
				}
			}
		}
		else
		{
			internalCall = true;
		}
		return false;
	}

	/*********************************************************************************************************************
	 *	Figure out whether a virtual method is obfuscatable and handle it accordingly, given the obfuscatability of the
	 *	class containing it.
	 *********************************************************************************************************************/
	private void HandleVirtualMethod(TreeNode typeNode, uint methodIndex, bool typeObfuscatable)
	{
		uint			flags, stringIndex;
		bool			methodObfuscatable = false, internalCall = false;
		string			name;
		NameAndSig		virtualInfo;
		ObfusAndList	virtualList;

		// Get the name and the signature of this virtual method.
		virtualInfo.name		= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_NAME_COL]);
		virtualInfo.sig			= m_md.m_blobHeap.ReadBlob(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_SIGNATURE_COL]);
		virtualList.indexList	= new ArrayList();

		flags = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_FLAGS_COL];
		switch (typeNode.OutOfAssem & TreeNode.OUTOFASSEMBLY)
		{
			case TreeNode.OUTOFASSEMBLY_NONE:			// if this class does not extend anything outside of this assembly
				methodObfuscatable = DetermineMethodObfuscatability(methodIndex, typeObfuscatable, out internalCall);
				break;

			// If this class extends another class outside of this assembly, then we can only obfuscte this virtual method if
			// it has the NEWSLOT bit set.
			case TreeNode.OUTOFASSEMBLY_CLASS:
				if ((flags & METHOD_NEWSLOT) != 0)
					methodObfuscatable = DetermineMethodObfuscatability(methodIndex, typeObfuscatable, out internalCall);
				break;

			// If this class extends another interface outside of this assembly, then we can only obfuscte this virtual method 
			// if it has not public. 
			case TreeNode.OUTOFASSEMBLY_INTERFACE:
				if ((flags & METHOD_MEMBER_ACCESS_MASK) != METHOD_PUBLIC)
					methodObfuscatable = DetermineMethodObfuscatability(methodIndex, typeObfuscatable, out internalCall);
				break;

			case TreeNode.OUTOFASSEMBLY_BOTH:			// if this class extends both a class and an interface outside of this assembly
				if ((flags & METHOD_NEWSLOT) != 0 && (flags & METHOD_MEMBER_ACCESS_MASK) != METHOD_PUBLIC)
					methodObfuscatable = DetermineMethodObfuscatability(methodIndex, typeObfuscatable, out internalCall);
				break;

			default:
				break;
		}

		if (methodObfuscatable)
		{
			if (!m_obfusVirtual.ContainsKey(virtualInfo))
			{
				virtualList.obfus = true;										// initialize the obfuscatability to true
				virtualList.indexList.Clear();
				virtualList.indexList.Add(methodIndex);							// add the method index to the index list
				m_obfusVirtual.Add(virtualInfo, virtualList);
			}
			else
				((ObfusAndList)m_obfusVirtual[virtualInfo]).indexList.Add(methodIndex);
		}
		else
		{
			if (!m_obfusVirtual.ContainsKey(virtualInfo))
			{
				virtualList.obfus = false;
				virtualList.indexList.Clear();
				virtualList.indexList.Add(methodIndex);							// add the method index to the index list
				m_obfusVirtual.Add(virtualInfo, virtualList);
			}
			else
			{
				virtualList = (ObfusAndList)m_obfusVirtual[virtualInfo];
				virtualList.obfus = false;										// set the obfuscatability to false
				virtualList.indexList.Add(methodIndex);
				m_obfusVirtual[virtualInfo] = virtualList;
			}

			// All methods with the InternalCall bit set are non-obfuscatable.  Moreover, the types containing
			// them are not obfuscatable as well.  So we have to reverse whatever we have already done for an
			// obfuscatable class.
			if (internalCall)
			{
				if (m_obfuscatableTypes.Get((int)(typeNode.Type - 1)))
				{
					m_obfuscatableTypes.Set((int)(typeNode.Type - 1), false);
					m_TypeCount -= 1;
					stringIndex = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][typeNode.Type, PTHeap.TYPEDEF_NAME_COL];
					m_freeSpaceList.RawDelete(stringIndex, m_md.m_strHeap.StringLength(stringIndex));

					name = m_md.m_strHeap.ReadString(stringIndex);
					if (!m_oldNameHash.ContainsKey(name))
						m_oldNameHash.Add(name, stringIndex);
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Given the index of a field and the obfuscatability of the class containing it, find out whether it is obfuscatable 
	 *	or not.
	 *********************************************************************************************************************/
	private bool DetermineFieldObfuscatability(uint fieldIndex, bool typeObfuscatable)
	{
		uint fieldFlags = m_md.m_heap.m_tables[PTHeap.FIELD_TABLE][fieldIndex, PTHeap.FIELD_FLAGS_COL];

		// Check the Special and RTSpecial bits.
		if ( (fieldFlags & FIELD_SPECIAL_NAME) == 0 && (fieldFlags & FIELD_RESERVED_MASK) != FIELD_RT_SPECIAL_NAME )
		{
			fieldFlags &= FIELD_FIELD_ACCESS_MASK;
			if (ArgumentParser.m_EverythingFlag || typeObfuscatable || 
				(fieldFlags != FIELD_FAMILY && fieldFlags != FIELD_FAM_OR_ASSEM && fieldFlags != FIELD_PUBLIC))
			{
				return true;
			}
		}
		return false;
	}

	/*********************************************************************************************************************
	 *	After having passed through all the virtual methods in all modules, we have to combining the results from all modules.
	 *  Then we can proceed to consolidate the free spaces list and assign new unique names to the obfuscatable elements.
	 *********************************************************************************************************************/
	internal void FinishInitialization()
	{
		int				i;
		Obfus			obfusThere;
		Hashtable		allVirtual = new Hashtable();
		ObfusAndList	virtualList;
		IDictionaryEnumerator	allEnum;

		// First we have to gather all the results about virtual methods from all modules into one Hashtable "allVirtual".
		for (i = 0; i < m_moduleRefList.Count; i++)
		{
			// Traverse the virtual method list in this module.
			obfusThere = (Obfus)m_moduleRefList[i];
			if (obfusThere.m_obfusVirtual != null)
			{
				for (allEnum = obfusThere.m_obfusVirtual.GetEnumerator(); allEnum.MoveNext(); )
				{
					if (!allVirtual.ContainsKey(allEnum.Key))		// if this virtual method does not already exist in the Hashtable 
					{
						allVirtual.Add(allEnum.Key, ((ObfusAndList)allEnum.Value).obfus);
					}
					else
					{
						// Even if only one virtual method with this name and signature is non-obfuscatable, we have to set all
						// virtual methods with this name and signature as non-obfuscatable.
						if (!((ObfusAndList)allEnum.Value).obfus && (bool)allVirtual[allEnum.Key])
						{
							allVirtual[allEnum.Key] = false;
						}
					}
				}
			}
		}

		// Then do the same thing to the main module.
		if (m_obfusVirtual != null)
		{
			for (allEnum = m_obfusVirtual.GetEnumerator(); allEnum.MoveNext(); )
			{
				if (!allVirtual.ContainsKey(allEnum.Key))
				{
					allVirtual.Add(allEnum.Key, ((ObfusAndList)allEnum.Value).obfus);
				}
				else
				{
					if (!((ObfusAndList)allEnum.Value).obfus && (bool)allVirtual[allEnum.Key])
					{
						allVirtual[allEnum.Key] = false;
					}
				}
			}
		}

		// Finally, we traverse the list containing all virtual methods in this assembly, and set the virtual method lists in
		// all modules according to this "master copy".
		for (allEnum = allVirtual.GetEnumerator(); allEnum.MoveNext(); )
		{
			for (i = 0; i < m_moduleRefList.Count; i++)
			{
				obfusThere = (Obfus)m_moduleRefList[i];
				if (obfusThere.m_obfusVirtual != null)
				{
					if (obfusThere.m_obfusVirtual.ContainsKey(allEnum.Key))
					{
						if (!(bool)allEnum.Value && ((ObfusAndList)obfusThere.m_obfusVirtual[allEnum.Key]).obfus)
						{
							virtualList = (ObfusAndList)obfusThere.m_obfusVirtual[allEnum.Key];
							virtualList.obfus = false;
							obfusThere.m_obfusVirtual[allEnum.Key] = virtualList;
						}
					}
				}
			}

			if (m_obfusVirtual != null && m_obfusVirtual.ContainsKey(allEnum.Key))
			{
				if (!(bool)allEnum.Value && ((ObfusAndList)m_obfusVirtual[allEnum.Key]).obfus)
				{
					virtualList = (ObfusAndList)m_obfusVirtual[allEnum.Key];
					virtualList.obfus = false;
					m_obfusVirtual[allEnum.Key] = virtualList;
				}
			}
		}

		// Now we can continue on and finish the remaining tasks of the initialization step.
		for (i = 0; i < m_moduleRefList.Count; i++)								// for each module
		{
			((Obfus)m_moduleRefList[i]).InitializeVirtual();
			((Obfus)m_moduleRefList[i]).AssignNamesToAll();
		}
		InitializeVirtual();													// for the main module
		AssignNamesToAll();
	}

	/*********************************************************************************************************************
	 *	After having passed through all the virtual methods in all modules, we have to combining the results from all modules.
	 *  Then we can proceed to consolidate the free spaces list and assign new unique names to the obfuscatable elements.
	 *********************************************************************************************************************/
	private void InitializeVirtual()
	{
		uint	i, j, numRows, startParamIndex, endParamIndex;
		uint	methodIndex, stringIndex, table, row;							// "table" and "row" are used to resolve tokens
		string	name;
		ObfusAndList			virtualList;
		IDictionaryEnumerator	cur;

		if (m_obfusVirtual != null)
		{
			for (cur = m_obfusVirtual.GetEnumerator(); cur.MoveNext(); )
			{
				virtualList = (ObfusAndList)cur.Value;
				if (virtualList.obfus)											// if this list of virtual methods are not obfuscatable
				{
					for (i = 0; i < virtualList.indexList.Count; i++)			// for each virtual method with this name and signature
					{
						methodIndex = (uint)virtualList.indexList[(int)i];
						stringIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_NAME_COL];

						m_obfuscatableMethods.Set((int)(methodIndex - 1), true);
						m_MethodCount += 1;
						m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));
						if(m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null)
						{
							startParamIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_PARAMLIST_COL];
							if ((methodIndex + 1) > m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows)
								endParamIndex = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows + 1;
							else
								endParamIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex + 1, PTHeap.METHOD_PARAMLIST_COL];
							
							for (j = startParamIndex; j < endParamIndex; j++)		// handle the parameters of this method as well
							{
								m_obfuscatableParams.Set((int)(j - 1), true);
								m_ParamCount += 1;
								stringIndex = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE][j, PTHeap.PARAM_NAME_COL];
								m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));
							}
						}
					}
				}
				else
				{
					for (i = 0; i < virtualList.indexList.Count; i++)
					{
						methodIndex = (uint)virtualList.indexList[(int)i];
						stringIndex = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_NAME_COL];

						name = m_md.m_strHeap.ReadString(stringIndex);
						if (!m_oldNameHash.ContainsKey(name))
							m_oldNameHash.Add(name, stringIndex);
					}
				}
			}
		}

		// Determine the obfuscatability of properties and events of the current class.  Obfuscatability of properties depend on 
		// the Get and Set methods; obfuscatability of events depend on the AddOn and RemoveOn methods.
		if (m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE] != null)
		{
			numRows = m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE].m_numRows;
			for (i = 1; i <= numRows; i++)
			{
				// Resolve the token to see if we should look into the Event table or the Property table.
				// Other than that, properties and events are handled in much the same way as types and fields.
				methodIndex = m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE][i, PTHeap.METHODSEMANTICS_METHOD_COL];
				IndexDecoder.DecodeHasSemantic(m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE][i, PTHeap.METHODSEMANTICS_ASSOCIATION_COL], 
											   out table, out row);
				if (table == PTHeap.EVENT_TABLE)
				{
					stringIndex = m_md.m_heap.m_tables[PTHeap.EVENT_TABLE][row, PTHeap.EVENT_NAME_COL];
					if (!m_eventsDone.Get((int)(row - 1)))
					{
						if (m_obfuscatableMethods.Get((int)(methodIndex - 1)))
						{
							m_obfuscatableEvents.Set((int)(row - 1), true);
							m_EventCount += 1;
							m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));
						}
						else
						{
							name = m_md.m_strHeap.ReadString(stringIndex);
							if (!m_oldNameHash.ContainsKey(name))
								m_oldNameHash.Add(name, stringIndex);
						}
						m_eventsDone.Set((int)(row - 1), true);
					}
					else
					{
						if (!m_obfuscatableMethods.Get((int)(methodIndex - 1)) && m_obfuscatableEvents.Get((int)(row - 1)))
						{
							m_obfuscatableEvents.Set((int)(row - 1), false);
							m_EventCount -= 1;
							m_freeSpaceList.RawDelete(stringIndex, m_md.m_strHeap.StringLength(stringIndex));

							name = m_md.m_strHeap.ReadString(stringIndex);
							if (!m_oldNameHash.ContainsKey(name))
								m_oldNameHash.Add(name, stringIndex);
						}
					}
				}
				else if (table == PTHeap.PROPERTY_TABLE)
				{
					stringIndex = m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE][row, PTHeap.PROPERTY_NAME_COL];
					if (!m_propertiesDone.Get((int)(row - 1)))
					{
						if (m_obfuscatableMethods.Get((int)(methodIndex - 1)))
						{
							m_obfuscatableProperties.Set((int)(row - 1), true);
							m_PropertyCount += 1;
							m_freeSpaceList.RawAdd(stringIndex, m_md.m_strHeap.StringLength(stringIndex));
						}
						else
						{
							name = m_md.m_strHeap.ReadString(stringIndex);
							if (!m_oldNameHash.ContainsKey(name))
								m_oldNameHash.Add(name, stringIndex);
						}
						m_propertiesDone.Set((int)(row - 1), true);
					}
					else
					{
						if (!m_obfuscatableMethods.Get((int)(methodIndex - 1)) && m_obfuscatableProperties.Get((int)(row - 1)))
						{
							m_obfuscatableProperties.Set((int)(row - 1), false);
							m_PropertyCount -= 1;
							m_freeSpaceList.RawDelete(stringIndex, m_md.m_strHeap.StringLength(stringIndex));

							name = m_md.m_strHeap.ReadString(stringIndex);
							if (!m_oldNameHash.ContainsKey(name))
								m_oldNameHash.Add(name, stringIndex);
						}
					}
				}
			}
		}

		// For all non-obfuscatable parameters, we have to add the spaces their names take up as unusable.
		if (m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null)
		{
			numRows = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows;
			for (i = 1; i <= numRows; i++)
			{
				if (!m_obfuscatableParams.Get((int)(i - 1)))
				{
					stringIndex	= m_md.m_heap.m_tables[PTHeap.PARAM_TABLE][i, PTHeap.PARAM_NAME_COL];
					name		= m_md.m_strHeap.ReadString(stringIndex);
					if (!m_oldNameHash.ContainsKey(name))
						m_oldNameHash.Add(name, stringIndex);
				}
			}
		}

		// These mappings are used to store which new unique names are assigned to which elements.
		if (m_TypeCount > 0)
			m_typeMapping		= new Hashtable((int)m_TypeCount);
		if (m_MethodCount > 0)
			m_methodMapping	= new Hashtable((int)m_MethodCount);
		if (m_FieldCount > 0)
			m_fieldMapping	= new Hashtable((int)m_FieldCount);
		if (m_PropertyCount > 0)
			m_propertyMapping	= new Hashtable((int)m_PropertyCount);
		if (m_EventCount > 0)
			m_eventMapping	= new Hashtable((int)m_EventCount);
		if (m_ParamCount > 0)
			m_paramMapping	= new Hashtable((int)m_ParamCount);

		BuildFreeSpaceList();								// consolidate the free space list built in the initialization step
	}

	/*********************************************************************************************************************
	 *	Check all the string index fields of all MetaData table in this module.  For every string which are not to be 
	 *	obfuscated, we have to make sure that the space it takes up is not used for obfuscation.
	 *********************************************************************************************************************/
	internal void BuildFreeSpaceList()
	{
		uint	i, index;
		int		module;
		bool	method;
		uint	member;

		if (m_md.m_heap.m_tables[PTHeap.ASSEMBLY_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.ASSEMBLY_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.ASSEMBLY_TABLE][i, PTHeap.ASSEMBLY_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				index = m_md.m_heap.m_tables[PTHeap.ASSEMBLY_TABLE][i, PTHeap.ASSEMBLY_LOCALE_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.ASSEMBLYREF_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.ASSEMBLYREF_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.ASSEMBLYREF_TABLE][i, PTHeap.ASSEMBLYREF_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				index = m_md.m_heap.m_tables[PTHeap.ASSEMBLYREF_TABLE][i, PTHeap.ASSEMBLYREF_LOCALE_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.EVENT_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.EVENT_TABLE].m_numRows; i++)
			{
				if (!m_obfuscatableEvents.Get((int)(i - 1)))
				{
					index = m_md.m_heap.m_tables[PTHeap.EVENT_TABLE][i, PTHeap.EVENT_NAME_COL]; 
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.EXPORTEDTYPE_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.EXPORTEDTYPE_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.EXPORTEDTYPE_TABLE][i, PTHeap.EXPORTED_TYPENAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				index = m_md.m_heap.m_tables[PTHeap.EXPORTEDTYPE_TABLE][i, PTHeap.EXPORTED_TYPENAMESPACE_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.FIELD_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.FIELD_TABLE].m_numRows; i++)
			{
				if (!m_obfuscatableFields.Get((int)(i - 1)))
				{
					index = m_md.m_heap.m_tables[PTHeap.FIELD_TABLE][i, PTHeap.FIELD_NAME_COL]; 
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.FILE_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.FILE_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.FILE_TABLE][i, PTHeap.FILE_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.IMPLMAP_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.IMPLMAP_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.IMPLMAP_TABLE][i, PTHeap.IMPLMAP_IMPORTNAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.MANIFESTRESOURCE_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.MANIFESTRESOURCE_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.MANIFESTRESOURCE_TABLE][i, PTHeap.MANIFESTRESOURCE_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE].m_numRows; i++)
			{
				module	= m_memberRefToDef[i - 1].module;
				method	= m_memberRefToDef[i - 1].method;
				member	= m_memberRefToDef[i - 1].member;

				index	= m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE][i, PTHeap.MEMBERREF_NAME_COL]; 
				if (member == 0 || 
					(module == -1 && (method ? !m_obfuscatableMethods.Get((int)(member - 1)) : 
											   !m_obfuscatableFields.Get((int)(member - 1)))) ||
					((module != -1) &&
						(method ? !((Obfus)m_moduleRefList[module]).m_obfuscatableMethods.Get((int)(member - 1)) : 
							  !((Obfus)m_moduleRefList[module]).m_obfuscatableFields.Get((int)(member - 1)))))
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				else
					m_freeSpaceList.RawAdd(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows; i++)
			{
				if (!m_obfuscatableMethods.Get((int)(i - 1)))
				{
					index = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][i, PTHeap.METHOD_NAME_COL]; 
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.MODULE_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.MODULE_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.MODULE_TABLE][i, PTHeap.MODULE_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.MODULEREF_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.MODULEREF_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.MODULEREF_TABLE][i, PTHeap.MODULEREF_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows; i++)
			{
				if (!m_obfuscatableParams.Get((int)(i - 1)))
				{
					index = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE][i, PTHeap.PARAM_NAME_COL]; 
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE].m_numRows; i++)
			{
				if (!m_obfuscatableProperties.Get((int)(i - 1)))
				{
					index = m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE][i, PTHeap.PROPERTY_NAME_COL]; 
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows; i++)
			{
				if (!m_obfuscatableTypes.Get((int)(i - 1)))
				{
					index = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAME_COL]; 
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
				index = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAMESPACE_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAME_COL]; 
				if ( m_typeRefToDef[i - 1].type == 0 || 
					 (m_typeRefToDef[i - 1].module == -1 && !m_obfuscatableTypes.Get((int)(m_typeRefToDef[i - 1].type - 1))) ||
					 (m_typeRefToDef[i - 1].module != -1 && !((Obfus)m_moduleRefList[m_typeRefToDef[i - 1].module]).m_obfuscatableTypes.
					   Get((int)(m_typeRefToDef[i - 1].type - 1))) )
				{
					m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
				}
				else
				{
					m_freeSpaceList.RawAdd(index, m_md.m_strHeap.StringLength(index));
				}
					
				index = m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAMESPACE_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.TYPETYPAR_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.TYPETYPAR_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.TYPETYPAR_TABLE][i, PTHeap.TYPETYPAR_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}
		if (m_md.m_heap.m_tables[PTHeap.METHODTYPAR_TABLE] != null)
		{
			for (i = 1; i <= m_md.m_heap.m_tables[PTHeap.METHODTYPAR_TABLE].m_numRows; i++)
			{
				index = m_md.m_heap.m_tables[PTHeap.METHODTYPAR_TABLE][i, PTHeap.METHODTYPAR_NAME_COL]; 
				m_freeSpaceList.RawDelete(index, m_md.m_strHeap.StringLength(index));
			}
		}

		// Consolidate the free space list.  Note that "MergeRawAdd" must be called before "MergeRawDelete".
		m_freeSpaceList.MergeRawAdd();
		m_freeSpaceList.MergeRawDelete();
	}

	/*********************************************************************************************************************
	 *	1) Assign new unique names to the ModuleRef table and the File table.
	 *
	 *	2) Assign new unique names to each obfuscatable element.
	 *
	 *	Please note that all assignments are stored in the respective mappings and no file is actually changed at this time.
	 *	This is done so that we can check if there is enough space in all modules to finish obfuscation.  If not, we will
	 *	just leave the file(s) untouched.
	 *********************************************************************************************************************/
	internal void AssignNamesToAll()
	{
		ObTypes(false);
		ObMethods(false);
		ObFields(false);
		ObProps(false);
		ObEvents(false);
		ObSpecialMethods(false);
		ObParams(false);
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the TypeDef table.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *********************************************************************************************************************/
	private void ObTypes(bool actual)
	{
		uint i, index, numTypes;

		if (m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE] != null)
		{
			numTypes = m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE].m_numRows;

			// Start at 2 because the first type is <Module>.
			// TODO : Global members.
			for (i = 2; i <= numTypes; i++)
			{
				if (m_obfuscatableTypes.Get((int)(i - 1)))
				{
					if (!actual)
						HandlePrivateNames(ref m_typeMapping, i, false, null);
					else
					{
						index = ((NameInfo)m_typeMapping[i]).index;
						m_md.m_heap.m_tables[PTHeap.TYPEDEF_TABLE][i, PTHeap.TYPEDEF_NAME_COL] = index;
						m_md.m_strHeap.WriteString(index, ((NameInfo)m_typeMapping[i]).name);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the Method table.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *********************************************************************************************************************/
	private void ObMethods(bool actual)
	{
		uint	i, index, numMethods;

		if (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE] != null)
		{
			numMethods = m_md.m_heap.m_tables[PTHeap.METHOD_TABLE].m_numRows;

			for (i = 1; i <= numMethods; i++)
			{
				// Delay obfuscating special methods until after properties and events are obfuscated.
				if (m_obfuscatableMethods.Get((int)(i - 1)) && !m_specialMethods.Get((int)(i - 1)) && 
					( !m_methodsDone.Get((int)(i - 1)) || actual ))
				{
					if (!actual)
						HandlePrivateNames(ref m_methodMapping, i, 
										   (m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][i, PTHeap.METHOD_FLAGS_COL] & METHOD_VIRTUAL) != 0, null);
					else
					{
						index = ((NameInfo)m_methodMapping[i]).index;
						m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][i, PTHeap.METHOD_NAME_COL] = index;
						m_md.m_strHeap.WriteString(index, ((NameInfo)m_methodMapping[i]).name);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the Field table.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *********************************************************************************************************************/
	private void ObFields(bool actual)
	{
		uint i, index, numFields;

		if (m_md.m_heap.m_tables[PTHeap.FIELD_TABLE] != null)
		{
			numFields = m_md.m_heap.m_tables[PTHeap.FIELD_TABLE].m_numRows;

			for (i = 1; i <= numFields; i++)
			{
				if (m_obfuscatableFields.Get((int)(i - 1)))
				{
					if (!actual)
						HandlePrivateNames(ref m_fieldMapping, i, false, null);
					else
					{
						index = ((NameInfo)m_fieldMapping[i]).index;
						m_md.m_heap.m_tables[PTHeap.FIELD_TABLE][i, PTHeap.FIELD_NAME_COL] = index;
						m_md.m_strHeap.WriteString(index, ((NameInfo)m_fieldMapping[i]).name);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to special methods.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *	Notice that each special method corresponds to either a property or an event, and the new name for the property or
	 *	event is used as a seed for assigning a new name to the special method.
	 *********************************************************************************************************************/
	private void ObSpecialMethods(bool actual)
	{
		uint	i, index, numRows;
		uint	methodIndex, table, row;
	
		if (m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE] != null)
		{
			numRows = m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE].m_numRows;
			
			for (i = 1; i <= numRows; i++)
			{
				methodIndex = m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE][i, PTHeap.METHODSEMANTICS_METHOD_COL];
				IndexDecoder.DecodeHasSemantic(m_md.m_heap.m_tables[PTHeap.METHODSEMANTICS_TABLE][i, PTHeap.METHODSEMANTICS_ASSOCIATION_COL], 
											   out table, out row);
				if (table == PTHeap.EVENT_TABLE)
				{
					if (m_obfuscatableEvents.Get((int)(row - 1)))
					{
						if (!actual)
						{
							// The last argument is the seed - the name assigned to the corresponding event.
							HandlePrivateNames(ref m_methodMapping, methodIndex, false, ((NameInfo)m_eventMapping[row]).name);
						}
						else
						{
							index = ((NameInfo)m_methodMapping[methodIndex]).index;
							m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_NAME_COL] = index;
							m_md.m_strHeap.WriteString(index, ((NameInfo)m_methodMapping[methodIndex]).name);
						}
					}
				}
				else if (table == PTHeap.PROPERTY_TABLE)
				{
					if (m_obfuscatableProperties.Get((int)(row - 1)))
					{
						if (!actual)
						{
							// The last argument is the seed - the name assigned to the corresponding property.
							HandlePrivateNames(ref m_methodMapping, methodIndex, false, ((NameInfo)m_propertyMapping[row]).name);
						}
						else
						{
							index = ((NameInfo)m_methodMapping[methodIndex]).index;
							m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][methodIndex, PTHeap.METHOD_NAME_COL] = index;
							m_md.m_strHeap.WriteString(index, ((NameInfo)m_methodMapping[methodIndex]).name);
						}
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the Parameter table.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *********************************************************************************************************************/
	private void ObParams(bool actual)
	{
		uint i, index, numParams;
	
		if (m_md.m_heap.m_tables[PTHeap.PARAM_TABLE] != null)
		{
			numParams = m_md.m_heap.m_tables[PTHeap.PARAM_TABLE].m_numRows;
			
			for (i = 1; i <= numParams; i++)
			{
				if (m_obfuscatableParams.Get((int)(i - 1)))
				{
					if (!actual)
						HandlePrivateNames(ref m_paramMapping, i, false, null);
					else
					{
						index = ((NameInfo)m_paramMapping[i]).index;
						m_md.m_heap.m_tables[PTHeap.PARAM_TABLE][i, PTHeap.PARAM_NAME_COL] = index;
						m_md.m_strHeap.WriteString(index, ((NameInfo)m_paramMapping[i]).name);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the Property table.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *********************************************************************************************************************/
	private void ObProps(bool actual)
	{
		uint i, index, numProps;
	
		if (m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE] != null)
		{
			numProps = m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE].m_numRows;
			
			for (i = 1; i <= numProps; i++)
			{
				if (m_obfuscatableProperties.Get((int)(i - 1)))
				{
					if (!actual)
						HandlePrivateNames(ref m_propertyMapping, i, false, null);
					else
					{
						index = ((NameInfo)m_propertyMapping[i]).index;
						m_md.m_heap.m_tables[PTHeap.PROPERTY_TABLE][i, PTHeap.PROPERTY_NAME_COL] = index;
						m_md.m_strHeap.WriteString(index, ((NameInfo)m_propertyMapping[i]).name);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the Event table.  If "actual" is false, we are just assigning new unique names to the
	 *	mapping.  If "actual" is true, we are actually overwriting the indices into the string heap and the string heap itself.
	 *********************************************************************************************************************/
	private void ObEvents(bool actual)
	{
		uint i, index, numEvents;
	
		if (m_md.m_heap.m_tables[PTHeap.EVENT_TABLE] != null)
		{
			numEvents = m_md.m_heap.m_tables[PTHeap.EVENT_TABLE].m_numRows;
			
			for (i = 1; i <= numEvents; i++)
			{
				if (m_obfuscatableEvents.Get((int)(i - 1)))
				{
					if (!actual)
						HandlePrivateNames(ref m_eventMapping, i, false, null);
					else
					{
						index = ((NameInfo)m_eventMapping[i]).index;
						m_md.m_heap.m_tables[PTHeap.EVENT_TABLE][i, PTHeap.EVENT_NAME_COL] = index;
						m_md.m_strHeap.WriteString(index, ((NameInfo)m_eventMapping[i]).name);
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Assign new unique names to the respective mapping, depending on "tableIndex".  If "appendName" is not null, then
	 *	we are trying to obfuscate a special method.
	 *********************************************************************************************************************/
	private void HandlePrivateNames(ref Hashtable mapping, uint row, bool virtualMethod, string appendName)
	{
		int			i;
		uint		index;
		string		newName = null;

		Obfus			obfusThere = null;
		NameInfo		info;
		NameAndSig		virtualInfo;
		ObfusAndList	virtualList;

		if (ArgumentParser.m_NullifyFlag)
		{
			info.index	= 0;
			info.name	= "\0";
			mapping.Add(row, info);
		}
		else
		{
			if (appendName != null)
			{
				newName = m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][row, PTHeap.METHOD_NAME_COL]);				// get the original name
				if (newName.StartsWith("remove_"))
					newName = newName.Substring(0, 7) + appendName;
				else
					newName = newName.Substring(0, 4) + appendName;
			}

			if (!virtualMethod)						// if this method is not virtual
			{
				index = Assign(ref newName);		// We run out of free space to use in the string heap if "index" equals 0.
				if (index != 0)
				{
					info.index	= index;
					info.name	= newName;
					mapping.Add(row, info);			// populate the mapping
				}
				else
					throw new NotEnoughSpace();		// throw an exception if we run out of space
			}
			else
			{
				// Get the name and the signature.
				virtualInfo.name	= m_md.m_strHeap.ReadString(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][row, PTHeap.METHOD_NAME_COL]);
				virtualInfo.sig		= m_md.m_blobHeap.ReadBlob(m_md.m_heap.m_tables[PTHeap.METHOD_TABLE][row, PTHeap.METHOD_SIGNATURE_COL]);

				for (i = 0; i < m_moduleRefList.Count; i++)
				{
					// All modules referenced by this module must precede this module in the MetaData list "m_moduleRefList".
					// So if we hit the current module, then there is no virtual method with this name and signature in
					// all modules referenced by the current module.
					if (m_fileName.Equals(((Obfus)m_moduleRefList[i]).m_fileName))
						break;

					// If one of the modules referenced by the current module contains virtual method(s) with this name and signature,
					// then we store the new name assigned to that/those virtual methods into the mapping.
					if (((Obfus)m_moduleRefList[i]).m_obfusVirtual != null &&
						((Obfus)m_moduleRefList[i]).m_obfusVirtual.ContainsKey(virtualInfo))
					{
						obfusThere	= (Obfus)m_moduleRefList[i];
						virtualList	= (ObfusAndList)obfusThere.m_obfusVirtual[virtualInfo];
						newName		= ((NameInfo)obfusThere.m_methodMapping[virtualList.indexList[0]]).name;
						break;
					}
				}

				virtualList	= (ObfusAndList)m_obfusVirtual[virtualInfo];

				// If we have not encountered another virtual method with the same name and signature in a referenced module, then
				// "newName" would be null at this point.  Otherwise, "newName" would store the new name assigned to the virtual
				// method(s) in the other module.
				index = Assign(ref newName);
				if (index != 0)
				{
					info.index	= index;
					info.name	= newName;

					// Do the assignment to all virtual methods with this name and signature in this module, and mark them as
					// having been taken care of.
					for (i = 0; i < virtualList.indexList.Count; i++)
					{
						mapping.Add((uint)virtualList.indexList[i], info);
						m_methodsDone.Set((int)((uint)virtualList.indexList[i] - 1), true);
					}
				}
				else
					throw new NotEnoughSpace();
			}
		}
	}

	/*********************************************************************************************************************
	 *	Call MetaData.Obfuscate() on all other modules, and resign all modules which have been obfuscated.  The new hash
	 *	values are written into the File table as a blob.  Note that all hash values should have the same length if they
	 *	are generated by the same hash algorithm.  Finally, add up the statistics from all referenced modules.  This method 
	 *	is only called on the main module.
	 *********************************************************************************************************************/
	internal void ObfuscateAllModules()
	{
		int		i;
		uint	j, flags, blobIndex;
		byte[]	oldHashValue, newHashValue;

		string			m_fileName;
		Obfus			obfus;
		FileStream		fs;
		HashAlgorithm	hashAlg = null;
		for (i = 0; i < m_moduleRefList.Count; i++)
		{
			obfus = (Obfus)m_moduleRefList[i];
			obfus.Obfuscate();

			m_TypeCount		+= obfus.m_TypeCount;
			m_MethodCount	+= obfus.m_MethodCount;
			m_FieldCount	+= obfus.m_FieldCount;
			m_PropertyCount	+= obfus.m_PropertyCount;
			m_EventCount	+= obfus.m_EventCount;
			m_ParamCount	+= obfus.m_ParamCount;

			m_TypeTotal		+= obfus.m_TypeTotal;
			m_MethodTotal	+= obfus.m_MethodTotal;
			m_FieldTotal	+= obfus.m_FieldTotal;
			m_PropertyTotal	+= obfus.m_PropertyTotal;
			m_EventTotal	+= obfus.m_EventTotal;
			m_ParamTotal	+= obfus.m_ParamTotal;
		}

		// We have to resign all obfuscated modules and write the new hash values into the File table.
		if (m_fileList != null)
		{
			flags = m_md.m_heap.m_tables[PTHeap.ASSEMBLY_TABLE][1, PTHeap.ASSEMBLY_HASHALGID_COL]; 
			if (flags != 0x0000)
			{
				if (flags == 0x8003)						// MD5
					hashAlg = new MD5CryptoServiceProvider();
				else										// SHA1
					hashAlg = new SHA1CryptoServiceProvider();
					
				if (hashAlg != null)
				{
					for (j = 1; j <= m_fileList.Length; j++)
					{
						if (m_obfuscatableFiles.Get((int)(j - 1)))
						{
							// Get the name of the obfuscated module, and prepend the output path to it.
							m_fileName = m_fileList[j - 1];
							m_fileName = ArgumentParser.m_outFilePath + m_fileName.Substring(m_fileName.LastIndexOf('\\') + 1).Trim('\0');

							// Resign the module.
							fs = new FileStream(ArgumentParser.m_outFilePath + m_fileName.Substring(m_fileName.LastIndexOf('\\') + 1), 
												FileMode.Open);
							newHashValue = hashAlg.ComputeHash(fs);

							// Get the old hash value.
							blobIndex = m_md.m_heap.m_tables[PTHeap.FILE_TABLE][j, PTHeap.FILE_HASHVALUE_COL];
							oldHashValue = m_md.m_blobHeap.ReadBlob(blobIndex);

							// Hash values obtained by the same hash algorithm should always have the same lengths.  However,
							// we should check it here anyway.
							if (newHashValue.Length > oldHashValue.Length)
							{
								if (!ArgumentParser.m_SuppressFlag)
									Console.WriteLine("  WARNING:  Cannot resign referenced file " + m_fileName + ".");
							}
							else
								m_md.m_blobHeap.WriteBlob(blobIndex, newHashValue);						// write the new hash value
						}
					}
				}
			}
		}
		this.Obfuscate();						// obfuscate the main module
	}

	/*********************************************************************************************************************
	 *	Overwrite the string heap with the newly assigned unique names stored in the mappings.  In additional to the 
	 *	TypeDef, Method, Field, Property, Event, and Parameter tables, this method also handles the TypeRef table and the
	 *	MemberRef table.  Finally, we write the obfuscated byte array representation of the input file to the destination file.
	 *********************************************************************************************************************/
	internal void Obfuscate()
	{
		FileStream		outFileStream;
		BinaryWriter	outFileWriter;

		ChangeTypeRef();
		ChangeMemberRef();

		ObTypes(true);
		ObMethods(true);
		ObFields(true);
		ObProps(true);
		ObEvents(true);
		ObSpecialMethods(true);
		ObParams(true);

		ClearFreeSpace();						// clear all the unused spaces in the string heap with 'x'

		outFileStream	= File.Open(ArgumentParser.m_outFilePath + m_fileName.Substring(m_fileName.LastIndexOf('\\') + 1), 
									FileMode.Create, FileAccess.Write, FileShare.None);
		outFileWriter	= new BinaryWriter(outFileStream);
		PEParser.PersistPEFile(ref outFileWriter, ref m_md.m_buffer);
		outFileWriter.Close();								// this call also closes the underlying stream
	}

	/*********************************************************************************************************************
	 *	Change TypeRef names if necessary.  We have to look into the mappings in other modules to determine which new
	 *	names have been assigned to the TypeRefs. 
	 *********************************************************************************************************************/
	private void ChangeTypeRef()
	{
		uint		i, numRows, typeIndex, stringIndex;
		string		newName;
		Obfus		obfus;
		
		if (m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE] != null)
		{
			numRows = m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE].m_numRows;
			for (i = 1; i <= numRows; i++)
			{
				if (m_typeRefToDef[i - 1].type != 0)						// if this TypeRef resolves to a TypeDef in this assembly
				{
					if (m_typeRefToDef[i - 1].module == -1)
						obfus = this;
					else
						obfus = (Obfus)m_moduleRefList[m_typeRefToDef[i - 1].module];
					typeIndex = m_typeRefToDef[i - 1].type;							// get the corresponding MetaData section

					if (obfus.m_obfuscatableTypes.Get((int)(typeIndex - 1)))				// if the TypeDef is obfuscated
					{
						newName		= ((NameInfo)obfus.m_typeMapping[typeIndex]).name;
						stringIndex	= Assign(ref newName);							// write the name into the string heap
						if (stringIndex != 0)
						{
							m_md.m_heap.m_tables[PTHeap.TYPEREF_TABLE][i, PTHeap.TYPEREF_NAME_COL] = stringIndex;
							m_md.m_strHeap.WriteString(stringIndex, newName);
						}
						else
							throw new NotEnoughSpace();					// if 0 is returned from "Assign", we run out of space
					}
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Change MemberRef names if necessary.  We have to look into the mappings in other modules to determine which new
	 *	names have been assigned to the MemberRefs. 
	 *********************************************************************************************************************/
	private void ChangeMemberRef()
	{
		uint		i, numRows, memberIndex, stringIndex;
		string		newName;
		Obfus		obfus;

		if (m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE] != null)
		{
			numRows = m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE].m_numRows;

			for (i = 1; i <= numRows; i++)
			{
				if (m_memberRefToDef[i - 1].member != 0)				// if this MemberRef resolves to anything in this assembly
				{
					if (m_memberRefToDef[i - 1].module == -1)			// get the corresponding MetaData section		
						obfus = this;
					else
						obfus = (Obfus)m_moduleRefList[m_memberRefToDef[i - 1].module];
					memberIndex = m_memberRefToDef[i - 1].member;

					if (m_memberRefToDef[i - 1].method && obfus.m_obfuscatableMethods.Get((int)(memberIndex - 1)))
						newName	= ((NameInfo)obfus.m_methodMapping[memberIndex]).name;
					else if (!m_memberRefToDef[i - 1].method && obfus.m_obfuscatableFields.Get((int)(memberIndex - 1)))
						newName	= ((NameInfo)obfus.m_fieldMapping[memberIndex]).name;
					else
						continue;									// if the member is obfuscated

					stringIndex	= Assign(ref newName);				// write the new name into the string heap
					if (stringIndex != 0)
					{
						m_md.m_heap.m_tables[PTHeap.MEMBERREF_TABLE][i, 2] = stringIndex;
						m_md.m_strHeap.WriteString(stringIndex, newName);
					}
					else
						throw new NotEnoughSpace();					// if 0 is returned from "Assign", we run out of space
				}
			}
		}
	}

	/*********************************************************************************************************************
	 *	Clear all the unused spaces in the string heap with 'x'.
	 *********************************************************************************************************************/
	internal void ClearFreeSpace()
	{
		uint offset, length;

		// Clear out all unused free space with 'x'.
		for (int i = 0; i < m_freeSpaceList.Count; i++)
		{
			m_freeSpaceList.Get((int)i, out offset, out length);
			if (offset != 0)
				m_md.m_strHeap.Clear(offset, length);
		}
	}

	/*********************************************************************************************************************
	 *	Look for "targetValue" in the specified table, in the specified column.  "startIndex" and "endIndex" gives the range
	 *	of rows to search for.  This method uses a recursive Binary Search algorithm.
	 *********************************************************************************************************************/
	internal uint FindIndex(uint table, uint column, uint targetValue, uint startIndex, uint endIndex)
	{
		uint value, midIndex;

		if (startIndex > endIndex)
			return 0;											// "targetValue" not found

		midIndex = (startIndex + endIndex) / 2;					// get the middle index of the range
		value = m_md.m_heap.m_tables[table][midIndex, column];		// get the value at the middle index

		if (value == targetValue)
		{
			return midIndex;									// "targetValue" found at index "midIndex"
		}
		else
		{
			if (value > targetValue)							// search recursively
				return FindIndex(table, column, targetValue, startIndex, midIndex - 1);
			else
				return FindIndex(table, column, targetValue, midIndex + 1, endIndex);
		}
	}

	/*********************************************************************************************************************
	 *	If "newName" is null, then we assign a new unique name to it and assign space for it in the string heap.  If 
	 *	"newName" is not null, then we simply assign space for it.
	 *	Note:  There are certain characters we cannot use:
	 *			&		(ascii code 38)
	 *			*		(ascii code 42)
	 *			+		(ascii code 43)
	 *			,		(ascii code 44)
	 *			.		(ascii code 46)
	 *			/		(ascii code 47)
	 *			[		(ascii code 91)
	 *			\		(ascii code 92)
	 *			]		(ascii code 93)
	 *********************************************************************************************************************/
	internal uint Assign(ref string newName)
	{
		int		i, overflow, obfusIndex;
		uint	index;
		string  checkString;

		if (newName == null)											// in this case, we have to increment the string counter
		{
			for (;;)
			{
			/* The following block is replaced with the one below it to limit name chars to 0-9,A-Z
				if ((int)m_strCounter[m_strCounter.Length - 2] == 127)		// we have to "carry over" the string counter
				{
					m_strCounter[m_strCounter.Length - 2] = (char)1;		// reset the "unit character" in the string counter
					for (obfusIndex = m_strCounter.Length - 3; obfusIndex >= 0; obfusIndex--)
					{
						// Increment all other characters by 1, skipping over unusable characters.
						overflow = (int)m_strCounter[obfusIndex];
						if (overflow == 127)
						{
							m_strCounter[obfusIndex] = (char)1;
						}
						else if (overflow == 37)											// cannot use '&'
						{
							overflow += 2;
							m_strCounter[obfusIndex] = (char)overflow;
							break;
						}
						else if (overflow == 45)											// cannot use '.' and '/'
						{
							overflow += 3;
							m_strCounter[obfusIndex] = (char)overflow;
							break;
						}
						else if (overflow == 41 || overflow == 90)							// cannot use '*', '+', and ','
						{																	// cannot use '[', '\', and ']'
							overflow += 4;
							m_strCounter[obfusIndex] = (char)overflow;
							break;
						}
						else
						{
							overflow += 1;
							m_strCounter[obfusIndex] = (char)overflow;
							break;
						}
					}
					if (obfusIndex == -1)								// we have to add one more character to the string counter		
					{
						m_strCounter = new char[m_strCounter.Length + 1];
						for (i = 0; i < m_strCounter.Length - 1; i++)
						{
							m_strCounter[i] = (char)1;
						}
						m_strCounter[m_strCounter.Length - 1] = '\0';
					}
				}
				else if ((int)m_strCounter[m_strCounter.Length - 2] == 37)	// simply increment the "unit character" in the string counter
				{
					m_strCounter[m_strCounter.Length - 2] = (char)((int)m_strCounter[m_strCounter.Length - 2] + 2);
				}
				else if ((int)m_strCounter[m_strCounter.Length - 2] == 45)
				{
					m_strCounter[m_strCounter.Length - 2] = (char)((int)m_strCounter[m_strCounter.Length - 2] + 3);
				}
				else if ((int)m_strCounter[m_strCounter.Length - 2] == 41 || (int)m_strCounter[m_strCounter.Length - 2] == 90)
				{
					m_strCounter[m_strCounter.Length - 2] = (char)((int)m_strCounter[m_strCounter.Length - 2] + 4);
				}
				else
				{
					m_strCounter[m_strCounter.Length - 2] = (char)((int)m_strCounter[m_strCounter.Length - 2] + 1);
				}
				*/
				if ((int)m_strCounter[m_strCounter.Length - 2] == 0x5A)		// we have to "carry over" the string counter
				{
					m_strCounter[m_strCounter.Length - 2] = (char)0x30;		// reset the "unit character" in the string counter
					for (obfusIndex = m_strCounter.Length - 3; obfusIndex >= 0; obfusIndex--)
					{
						// Increment all other characters by 1, skipping over unusable characters.
						overflow = (int)m_strCounter[obfusIndex];
						if (overflow == 0x5A)
						{
							m_strCounter[obfusIndex] = (char)0x30; //'Z' -> '0'
						}
						else if (overflow == 0x39)					// '9' -> 'A'
						{
							overflow = 0x41;
							m_strCounter[obfusIndex] = (char)overflow;
							break;
						}
						else
						{
							overflow += 1;
							m_strCounter[obfusIndex] = (char)overflow;
							break;
						}
					}
					if (obfusIndex == -1)								// we have to add one more character to the string counter		
					{
						m_strCounter = new char[m_strCounter.Length + 1];
						for (i = 0; i < m_strCounter.Length - 1; i++)
						{
							m_strCounter[i] = (char)0x30;
						}
						m_strCounter[m_strCounter.Length - 1] = '\0';
					}
				}
				else if ((int)m_strCounter[m_strCounter.Length - 2] == 0x39) // '9' -> 'A'	
				{
					m_strCounter[m_strCounter.Length - 2] = (char)0x41;
				}
				else	// simply increment the "unit character" in the string counter
				{
					m_strCounter[m_strCounter.Length - 2] = (char)((int)m_strCounter[m_strCounter.Length - 2] + 1);
				}

				checkString = new String(m_strCounter);

				// Check if the new name is used for any of the non-obfuscatable elements.
				for (i = 0; i < m_moduleRefList.Count; i++)
				{
					if (((Obfus)m_moduleRefList[i]).m_oldNameHash.ContainsKey(checkString))
						break;
				}

				if (i == m_moduleRefList.Count && !m_oldNameHash.ContainsKey(checkString))
					break;
			}

			index = m_freeSpaceList.Use((uint)checkString.Length);				// get space from the free space list
			if (index != 0)
				newName = checkString;											// assign the new name to be returned
		}
		else
		{
			index = m_freeSpaceList.Use((uint)newName.Length);					// get space from the free space list
		}
		return index;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\perfstats\perfstatsdll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4F0222D5_4F5F_430A_B75F_B49FAC7D0AC6__INCLUDED_)
#define AFX_STDAFX_H__4F0222D5_4F5F_430A_B75F_B49FAC7D0AC6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4F0222D5_4F5F_430A_B75F_B49FAC7D0AC6__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regasm\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\RegAsm.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt RegAsm.resources

cool_target: $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)

TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\perfstats\perfstatsexe\perfstats.cs ===
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Collections;
using System.IO;
using System.Globalization;

namespace PerfStats
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class PerfStats
	{
		static string TruncatedAppName(string appName)
		{
			const int truncateLength = 15;
			string[] splitString = appName.Split('#');
			string truncatedString = splitString[0];
			if (truncatedString.Length > truncateLength)
				truncatedString = truncatedString.Substring(0, truncateLength);
			if (splitString.Length > 1)
				truncatedString += "#" + splitString[1];
			return truncatedString;
		}

		static void AddCategories(Hashtable categories, string[] counters)
		{
			for (int i = 0; i < counters.Length; i++)
			{
				string[] s = counters[i].Split('|');
				string category = s[0];
				if (categories[category] ==null)
				{
					try
					{
						categories[category] = new PerformanceCounterCategory(category);
					}
					catch (Exception)
					{
						Console.WriteLine("PerformanceCategory '{0}' not found", category);
					}
				}
			}
		}

		static  InstanceDataCollectionCollection[] SampleCategories(PerformanceCounterCategory[] categories)
		{
			InstanceDataCollectionCollection[] idcc = new InstanceDataCollectionCollection[categories.Length];
			for (int i = 0; i < categories.Length; i++)
			{
				try
				{
					idcc[i] = categories[i].ReadCategory();
				}
				catch (Exception)
				{
				}
			}
			return idcc;
		}

		static int FindCategory(PerformanceCounterCategory[] categories, string category)
		{
			for (int i = 0; i < categories.Length; i++)
				if (categories[i].CategoryName == category)
					return i;
			return -1;
		}

		static void GetAverageMinMaxTrend(float[] samples, out float average, out float min, out float max, out string trend)
		{
			float sample = samples[0];
			average = min = max = sample;
			trend = "";

			for (int sampleIndex = 1; sampleIndex < samples.Length; sampleIndex++)
			{
				sample = samples[sampleIndex];
				average += sample;
				if (min > sample)
					min = sample;
				if (max < sample)
					max = sample;
				if (sample < samples[sampleIndex-1])
					trend += "\\";
				else if (sample > samples[sampleIndex-1])
					trend += "/";
				else
					trend += "-";
			}
			average /= samples.Length;

			float delta = max - min;
			if (delta <= 0.0)
				trend = new string('-', samples.Length);
			else
			{
				trend = "";
				for (int sampleIndex = 0; sampleIndex < samples.Length; sampleIndex++)
				{
					sample = samples[sampleIndex];
					int quant = (int)(10*(sample - min)/delta);
					if (quant >= 10)
						quant = 9;
					trend += (char)('0' + quant);
				}
			}
		}

		static float Calculate(CounterSample oldSample, CounterSample newSample)
		{
			switch (newSample.CounterType)
			{
				case	PerformanceCounterType.CounterTimer:
				{
					float elapsedTime = 1e-7f*(newSample.TimeStamp100nSec - oldSample.TimeStamp100nSec);
					float elapsedClocks = newSample.SystemFrequency*elapsedTime;
					float sampleDiff = newSample.RawValue - oldSample.RawValue;
					float result = sampleDiff / elapsedClocks *100;
					return result;
				}

				case	PerformanceCounterType.Timer100Ns:
				{
					float elapsed100ns = newSample.TimeStamp100nSec - oldSample.TimeStamp100nSec;
					float sampleDiff = newSample.RawValue - oldSample.RawValue;
					float result = sampleDiff / elapsed100ns *100;
					return result;
				}
				
				default:
					return CounterSample.Calculate(oldSample, newSample);
			}
		}

		static float[] ExtractSamples(int categoryIndex, string counter, InstanceDataCollectionCollection[][] samples, string instance)
		{
			float[] result = new float[samples.Length-1];
			CounterSample oldSample = CounterSample.Empty;
			for (int i = 0; i < samples.Length; i++)
			{
				InstanceDataCollectionCollection idcc = samples[i][categoryIndex];
				if (idcc == null)
					return null;
				InstanceDataCollection idc = idcc[counter];
				if (idc == null)
					return null;
				InstanceData id = idc[instance];
				if (id == null)
				{
					id = idc[TruncatedAppName(instance)];
					if (id == null)
						return null;
				}
				CounterSample sample = id.Sample;
				if (i > 0)
					result[i-1] = Calculate(oldSample, sample);
				oldSample = sample;
			}
			return result;
		}

		static void PrintCounter(int categoryIndex, string counter, InstanceDataCollectionCollection[][] samples, string instance, bool giveDiagnostic)
		{
			float[] floatSamples = ExtractSamples(categoryIndex, counter, samples, instance);
			if (floatSamples == null)
			{
				if (giveDiagnostic)
					Console.WriteLine("Counter '{0}/{1}' not found", counter, instance);
				return;
			}
			float average, min, max;
			string trend;
			GetAverageMinMaxTrend(floatSamples, out average, out min, out max, out trend);
			Console.WriteLine(" {0,-40}{1,11:n0} {2} ({3,1:n0}-{4,1:n0})", counter, average, trend, min, max);
		}

		static void PrintInstanceCounter(string counter, string instance, int categoryIndex, PerformanceCounterCategory[] categories, InstanceDataCollectionCollection[][] samples)
		{
			if (counter != "")
			{
				PrintCounter(categoryIndex, counter, samples, instance, true);
			}
			else
			{
				try
				{
					foreach (PerformanceCounter pc in categories[categoryIndex].GetCounters(instance))
					{
						PrintCounter(categoryIndex, pc.CounterName, samples, instance, false);
					}
				}
				catch (Exception)
				{
					try
					{
						instance = TruncatedAppName(instance);
						foreach (PerformanceCounter pc in categories[categoryIndex].GetCounters(instance))
						{
							PrintCounter(categoryIndex, pc.CounterName, samples, instance, false);
						}
					}
					catch (Exception)
					{
						Console.WriteLine("Category '{0}' not found", categories[categoryIndex].CategoryName);
					}
				}
			}
		}

		static void	PrintCounters(string[] counters, PerformanceCounterCategory[] categories, InstanceDataCollectionCollection[][] samples, string appName)
		{
			for (int i = 0; i < counters.Length; i++)
			{
				string[] s = counters[i].Split('|');
				string category = s[0];
				int categoryIndex = FindCategory(categories, category);
				if (categoryIndex < 0)
					continue;
				string counter = "";
				if (s.Length >= 2)
					counter = s[1];
				string instance = null;
				if (s.Length >= 3)
                {
					instance = s[2];
                    if (instance == "singleinstance")
                        instance = "systemdiagnosticsperfcounterlibsingleinstance";
                }
				if (instance == null)
				{
					if (appName == null)
						continue;
					else
						instance = appName;
				}
				else
				{
					if (appName != null)
						continue;
				}
				if (instance != "")
				{
					Console.WriteLine();
					Console.WriteLine("{0,-41}{1,11} {2} ({3,1}-{4,1})", category + ":", "Average", "Instant   ", "Min", "Max");
					PrintInstanceCounter(counter, instance, categoryIndex, categories, samples);
				}
				else
				{
					string[] instances = categories[categoryIndex].GetInstanceNames();
					foreach (string instanceName in instances)
					{
						Console.WriteLine();
						Console.WriteLine("{0,-41}{1,11} {2} ({3,1}-{4,1})", category + "/" + instanceName + ":", "Average", "Instant   ", "Min", "Max");
						PrintInstanceCounter(counter, instanceName, categoryIndex, categories, samples);
					}
				}
			}
		}

		[StructLayout(LayoutKind.Sequential, Pack=1)]
		struct SYSTEM_INFO 
		{
			public ushort wProcessorArchitecture;
			public ushort wReserved;
			public uint dwPageSize;
			public IntPtr lpMinimumApplicationAddress;
			public IntPtr lpMaximumApplicationAddress;
			public IntPtr dwActiveProcessorMask;
			public uint dwNumberOfProcessors;
			public uint dwProcessorType;
			public uint dwAllocationGranularity;
			public ushort wProcessorLevel;
			public ushort wProcessorRevision;
		};

		[DllImport("kernel32.dll")]
		static extern void GetSystemInfo(out SYSTEM_INFO si);

		[StructLayout(LayoutKind.Sequential, Pack=1)]
		struct MEMORYSTATUS 
		{ // mst 
			public uint dwLength;        // sizeof(MEMORYSTATUS) 
			public uint dwMemoryLoad;    // percent of memory in use 
			public uint dwTotalPhys;     // bytes of physical memory 
			public uint dwAvailPhys;     // free physical memory bytes 
			public uint dwTotalPageFile; // bytes of paging file 
			public uint dwAvailPageFile; // free bytes of paging file 
			public uint dwTotalVirtual;  // user bytes of address space 
			public uint dwAvailVirtual;  // free user bytes 
		}; 

		[DllImport("kernel32.dll")]
		static extern void GlobalMemoryStatus(ref MEMORYSTATUS ms);

		[DllImport("kernel32.dll")]
		static extern int GetTickCount();

		[DllImport("PerfStatsdll.dll")]
		static extern long GetCycleCount64();

		[DllImport("PerfStatsdll.dll")]
		static extern int GetL2CacheSize();

		[DllImport("PerfStatsdll.dll")]
		static extern int GetProcessorSignature();

		[DllImport("imagehlp.dll")]
		static extern bool SymInitialize(IntPtr hProcess, string UserSearchPath, bool fInvadeProcess);

		enum SYM_TYPE : int
		{
			SymNone = 0,
			SymCoff,
			SymCv,
			SymPdb,
			SymExport,
			SymDeferred,
			SymSym,       // .sym file
			SymDia,
			NumSymTypes
		};

		[StructLayout(LayoutKind.Sequential, Pack=1)]
		struct Filler32Bytes
		{
			long filler0, filler1, filler2, filler3;
		};


		[StructLayout(LayoutKind.Sequential, Pack=1)]
		struct Filler256Bytes
		{
			Filler32Bytes filler0, filler1, filler2, filler3, filler4, filler5, filler6, filler7;
		};


		[StructLayout(LayoutKind.Sequential, Pack=1)]
		struct IMAGEHLP_MODULE 
		{
			internal int SizeOfStruct;
			internal uint BaseOfImage;
			internal uint ImageSize;
			internal uint TimeDateStamp;
			internal uint CheckSum;
			internal uint NumSyms;
			internal SYM_TYPE SymType;
			internal Filler32Bytes ModuleName; // CHAR ModuleName[32];
			internal Filler256Bytes ImageName; // CHAR ImageName[256];
			internal Filler256Bytes LoadedImageName; // CHAR LoadedImageName[256];
		};
		
		[DllImport("imagehlp.dll")]
		static extern bool SymGetModuleInfo(IntPtr hProcess, IntPtr dwAddr, out IMAGEHLP_MODULE ModuleInfo);

		static string GetSymType(IntPtr hProcess, IntPtr dwAddr)
		{
			IMAGEHLP_MODULE im = new IMAGEHLP_MODULE();

			string result = "None";

			im.SizeOfStruct = System.Runtime.InteropServices.Marshal.SizeOf(im);

			if (!SymGetModuleInfo(hProcess, dwAddr, out im))
				return result;

			switch (im.SymType)
			{
				case SYM_TYPE.SymNone:
					result = "none";
					break;

				case SYM_TYPE.SymCoff:
					result = "COFF";
					break;

				case SYM_TYPE.SymCv:
					result = "CV";
					break;

				case SYM_TYPE.SymPdb:
					result = "PDB";
					break;

				case SYM_TYPE.SymExport:
					result = "EXP";
					break;

				case SYM_TYPE.SymDeferred:
					result = "deferred";
					break;

				case SYM_TYPE.SymSym:
					result = "SYM";
					break;

				case SYM_TYPE.SymDia:
					result = "PDB v7";
					break;

				default:
					result = String.Format("unknown: {0}", im.SymType);
					break;
			}
			return result;
		}

		static uint pageSize;

		static int Bits(int value, int hiBit, int loBit)
		{
			return (value >> loBit) & ((1<<(hiBit+1-loBit))-1);
		}

		static string ProcessorName(int family, int model)
		{
			switch (family)
			{
				case	3:
					return	"386";

				case	4:
					return	"486";

				case	5:
					return	"Pentium";

				case	6:
					switch	(model)
					{
						case	1:
							return	"Pentium Pro";

						case	3:
							return	"Pentium II";

						case	5:
							return	"Pentium II, Pentium II Xeon, or Celeron";

						case	6:
							return	"Celeron";

						case	7:
						case	8:
							return	"Pentium III, Pentium III Xeon, or Celeron";

						case	10:
							return	"Pentium III Xeon";
					}
					break;

				case	15:
					return	"Pentium 4";
			}
			return	"Processor not recognized";
		}

		static void PrintSystemInformation()
		{
			Console.WriteLine("{0,-41}{1,11}", "Operating System:", Environment.OSVersion);
			Console.WriteLine("{0,-41}{1,11}", "Machine name:", Environment.MachineName);

			SYSTEM_INFO si;
			GetSystemInfo(out si);
			Console.WriteLine("{0,-41}{1,11}", "Number of processors:", si.dwNumberOfProcessors);
			pageSize = si.dwPageSize;

			int processorSignature = GetProcessorSignature();
			string processorName = ProcessorName(Bits(processorSignature, 11,  8), 
												 Bits(processorSignature,  7,  4));
			Console.WriteLine("{0,-41}{1,11}", "Processor:",    processorName);
			Console.WriteLine("{0,-41}{1,11}", "Processor Extended Family:", Bits(processorSignature, 27, 20));
			Console.WriteLine("{0,-41}{1,11}", "Processor Extended Model:",  Bits(processorSignature, 19, 16));
			Console.WriteLine("{0,-41}{1,11}", "Processor Type:",            Bits(processorSignature, 13, 13));
			Console.WriteLine("{0,-41}{1,11}", "Processor Family:",          Bits(processorSignature, 11,  8));
			Console.WriteLine("{0,-41}{1,11}", "Processor Model:",           Bits(processorSignature,  7,  4));
			Console.WriteLine("{0,-41}{1,11}", "Processor Stepping:",        Bits(processorSignature,  3,  0));

			MEMORYSTATUS ms = new MEMORYSTATUS();
			ms.dwLength = (uint)System.Runtime.InteropServices.Marshal.SizeOf(ms);
			GlobalMemoryStatus(ref ms);
			Console.WriteLine("{0,-41}{1,8:n0} MB", "Physical Memory:",  (double)ms.dwTotalPhys/(1024*1024));
			Console.WriteLine("{0,-41}{1,8:n0} MB", "Available Memory:", (double)ms.dwAvailPhys/(1024*1024));
			Console.WriteLine("{0,-41}{1,11}", "% MemoryLoad:", ms.dwMemoryLoad);

		}

		class MemoryCategory : IComparable
		{
			internal MemoryCategory nextCategory;
			internal double			presentSize;
			internal double			privateSize;
			internal string			categoryName;
			internal MemoryCategory subCategories;

			internal static MemoryCategory categoryList;
			internal static MemoryCategory totalList;

			int IComparable.CompareTo(Object thatObject)
			{
				MemoryCategory that = (MemoryCategory)thatObject;
				if (this.presentSize > that.presentSize)
					return -1;
				else if (this.presentSize < that.presentSize)
					return 1;
				else
					return 0;
			}

			static MemoryCategory AddPage(MemoryCategory root, string categoryName, string subCategoryName, bool privatePage)
			{
				MemoryCategory mc;
				for (mc = root; mc != null; mc = mc.nextCategory)
					if (mc.categoryName == categoryName)
						break;
				if (mc == null)
				{
					mc = new MemoryCategory();
					mc.nextCategory = root;
					root = mc;
					mc.categoryName = categoryName;
				}
				mc.presentSize += pageSize;
				if (privatePage)
					mc.privateSize += pageSize;
				if (subCategoryName != null)
					mc.subCategories = AddPage(mc.subCategories, subCategoryName, null, privatePage);
				return root;
			}

			internal static void AddPage(string categoryName, string subCategoryName, bool privatePage)
			{
				totalList = AddPage(totalList, "Grand Total", null, privatePage);
				categoryList = AddPage(categoryList, categoryName, subCategoryName, privatePage);
			}

			static void PrintCategories(MemoryCategory categoryList, double total, bool majorCategory)
			{
				ArrayList al = new ArrayList();
				for (MemoryCategory mc = categoryList; mc != null; mc = mc.nextCategory)
					al.Add(mc);
				al.Sort();
				foreach (MemoryCategory mc in al)
				{
					string format = ": {1,7:n0} kB ={2,5:f1}%  ({3,3:f1}% Private)";
					if (majorCategory)
					{
						format = "{0,-30}" + format;
						Console.WriteLine();
					}
					else
						format = "  {0,-28}" + format;

					Console.WriteLine(format, mc.categoryName, mc.presentSize/1024, mc.presentSize/total*100, mc.privateSize/mc.presentSize*100.0);

					if (mc.subCategories != null)
						PrintCategories(mc.subCategories, total, false);
				}
			}

			internal static void PrintCategories()
			{
				Console.WriteLine();
				Console.WriteLine("Working Set Analysis:");
				Console.WriteLine("=====================");

				if (totalList == null)
				{
					Console.WriteLine("No information available");
				}
				else
				{
					PrintCategories(totalList   , totalList.presentSize, true);
					PrintCategories(categoryList, totalList.presentSize, true);
				}
			}
		}

		[StructLayout(LayoutKind.Sequential, Pack=1)]
		struct	MEMORY_BASIC_INFORMATION
		{
			internal	IntPtr	BaseAddress;            // base address of region 
			internal	IntPtr	AllocationBase;         // allocation base address 
			internal	uint	AllocationProtect;      // initial access protection 
			internal	uint	RegionSize;             // size, in bytes, of region 
			internal	uint	State;                  // committed, reserved, free 
			internal	uint	Protect;                // current access protection 
			internal	uint	Type;                   // type of pages 		
		}

		[DllImport("kernel32.dll")]
		static extern int VirtualQueryEx(IntPtr hProcess, IntPtr addr, out MEMORY_BASIC_INFORMATION mbi, int mbiSize);

		class GcRegion
		{
			GcRegion	next;
			long		startAddr;
			long		endAddr;

			static	GcRegion gcRegionList;

			internal static bool PageInGcRegion(IntPtr addr)
			{
				long lAddr = (long)addr;
				for (GcRegion gcRegion = gcRegionList; gcRegion != null; gcRegion = gcRegion.next)
					if (lAddr >= gcRegion.startAddr && lAddr < gcRegion.endAddr)
						return true;
				return false;
			}

			static void AddGcRegion(long baseAddr, long regionSize)
			{
				long startAddr = baseAddr;
				long endAddr = baseAddr + regionSize;
				GcRegion gcRegion;
				for (gcRegion = gcRegionList; gcRegion != null; gcRegion = gcRegion.next)
				{
					if (gcRegion.startAddr <= startAddr && gcRegion.endAddr >= endAddr)
					{
						// the new region is a subset of an old one - ignore it.
						return;
					}
					else if (startAddr <= gcRegion.startAddr && endAddr >= gcRegion.endAddr)
					{
						// an existing region is a subset of the new one - enlarge the existing one.
						gcRegion.startAddr = startAddr;
						gcRegion.endAddr = endAddr;
						return;
					}
				}
				gcRegion = new GcRegion();
				gcRegion.next = gcRegionList;
				gcRegionList = gcRegion;
				gcRegion.startAddr = endAddr;
				gcRegion.endAddr = endAddr;
			}

			internal static void InitGcRegions(IntPtr hProcess)
			{
				gcRegionList = null;

				MEMORY_BASIC_INFORMATION mbi = new MEMORY_BASIC_INFORMATION();

				IntPtr addr = IntPtr.Zero;
				while (true)
				{
					if (VirtualQueryEx(hProcess, addr, out mbi, System.Runtime.InteropServices.Marshal.SizeOf(mbi)) <= 0)
						break;
					if (mbi.State != 0x10000 && mbi.Type == 0x20000 && 
						(long)mbi.BaseAddress - (long)mbi.AllocationBase + mbi.RegionSize >= 16*1024*1024)
					{
						AddGcRegion((long)mbi.AllocationBase, mbi.RegionSize);
					}
					addr = (IntPtr)((long)mbi.BaseAddress + mbi.RegionSize);
				}
			}
		}

		[DllImport("psapi.dll")]
		static extern int QueryWorkingSet(IntPtr hProcess, IntPtr[] buffer, int size);

		[DllImport("kernel32.dll")]
		static extern IntPtr OpenProcess(uint dwDesiredAccess, bool bInheritHandle, int dwProcessId);

		[DllImport("psapi.dll", CharSet=CharSet.Unicode)]
		static extern int GetMappedFileName(IntPtr hProcess, IntPtr addr, char[] buffer, int cbSize);

		static void RunVadump(Process p)
		{
			ProcessStartInfo processStartInfo = new ProcessStartInfo("vadump.exe");
			processStartInfo.Arguments = "-o -p " + p.Id;

			processStartInfo.UseShellExecute = false;

			processStartInfo.RedirectStandardOutput = true;

			Process vadumpProcess = Process.Start(processStartInfo);

			//			vadumpProcess.WaitForExit();

			IntPtr processHandle = OpenProcess(0x1F0FFF, false, p.Id);
			GcRegion.InitGcRegions(processHandle);

			StreamReader r = vadumpProcess.StandardOutput;
			string line;

			MemoryCategory.categoryList = null;

			while ((line = r.ReadLine()) != null)
			{
				string[] fields = line.Split(' ');
				if (fields.Length >= 3 && 
					fields[0].IndexOf("0x") == 0 &&
					fields[1].Length >= 3 && fields[1][0] == '(')
				{
					bool privatePage = fields[1] == "(0)";
					switch (fields[2])
					{
						case	"PRIVATE":
							IntPtr addr = (IntPtr)Int64.Parse(fields[0].Substring(2), NumberStyles.HexNumber);
							if (GcRegion.PageInGcRegion(addr))
								MemoryCategory.AddPage("Heaps", "GC Heap", privatePage);
							else
								MemoryCategory.AddPage("Heaps", "Private VirtualAlloc", privatePage);
							break;

						case	"Stack":
							string thread = null;
							if (fields.Length >= 6 && fields[4] == "ThreadID")
								thread = fields[4] + " " + fields[5];
							MemoryCategory.AddPage("Stacks", thread, privatePage);
							break;

						case	"Process":
							MemoryCategory.AddPage("Heaps", "Process Heap", privatePage);
							break;

						case	"UNKNOWN_MAPPED":
							MemoryCategory.AddPage("Other Stuff", "Unknown Mapped", privatePage);
							break;

						case	"DATAFILE_MAPPED":
							string fileName = "<Unknown>";
							if (fields.Length == 6)
								fileName = fields[5];
							MemoryCategory.AddPage("Mapped data", fileName, privatePage);
							break;

						case	"Private":
							MemoryCategory.AddPage("Heaps", "Private Heaps", privatePage);
							break;

						case	"TEB":
							MemoryCategory.AddPage("Other Stuff", "TEB", privatePage);
							break;

						default:
							MemoryCategory.AddPage("Modules", fields[2], privatePage);
							break;
					}
				}
				else if (fields.Length >= 2 && 
					fields[0].IndexOf("0xc") == 0 &&
					fields[1] == "->")
				{
					MemoryCategory.AddPage("Other Stuff", "Page Tables", true);
				}
			}
		
			MemoryCategory.PrintCategories();
		}

		static void WorkingSetAnalysis(Process p, string processName)
		{
			try
			{
				RunVadump(p);
			}
			catch (Exception)
			{
				Console.WriteLine();
				Console.WriteLine("Working set analysis failed - is vadump.exe on the path?");
			}
		}

		static int ProcessId(string processName)
		{
			try
			{
				PerformanceCounter pidCounter = new PerformanceCounter("Process", "ID Process", processName);
				return (int)pidCounter.RawValue;
			}
			catch (Exception)
			{
				try
				{
					string truncatedName = TruncatedAppName(processName);
					PerformanceCounter pidCounter = new PerformanceCounter("Process", "ID Process", truncatedName);
					return (int)pidCounter.RawValue;
				}
				catch (Exception)
				{
					return -1;
				}
			}
		}

		static string FindProcessById(string processName, int processId)
		{
			if (ProcessId(processName) == processId)
				return processName;
			for (int i = 1; i < 1000; i++)
			{
				string instanceName = string.Format("{0}#{1}", processName, i);
				if (ProcessId(instanceName) == processId)
					return instanceName;				
			}
			return processName;
		}

		static string[] ReadConfigCounters(string fileName)
		{
			StreamReader r;
			try
			{
				r = new StreamReader(fileName);
			}
			catch (FileNotFoundException)
			{
				return new string[0];
			}
			string line;
			int lineNo = 1;
			ArrayList al = new ArrayList();
			while ((line = r.ReadLine()) != null)
			{
				line = line.Trim();
				if (line != "")
				{
					if (line.StartsWith(";") || line.StartsWith("#") || line.StartsWith("//"))
					{
						// comment line - skip
					}
					else
					{
						if (line.Split('|').Length > 3)
							Console.WriteLine("Syntax error in config file {0} line {1}", fileName, lineNo);
						al.Add(line);
					}
				}
				lineNo++;
			}
			r.Close();
			string[] result = new string[al.Count];
			int i = 0;
			foreach (string s in al)
				result[i++] = s;
			return result;
		}

		static string[] stdCounters =
		{
			"Processor||_Total",
			"System||singleinstance",
			"Memory||singleinstance",
			"ASP.NET Applications||__Total__",
			"ASP.NET||singleinstance",
			".NET CLR Networking||singleinstance",
			"Process",
			".NET CLR Exceptions",
			".NET CLR Interop",
			".NET CLR Jit",
			".NET CLR Loading",
			".NET CLR LocksAndThreads",
			".NET CLR Memory",
			".NET CLR Remoting",
			".NET CLR Security",
		};

		static void MakeApplyToAllInstances(string[] counters)
		{
			for (int i = 0; i < counters.Length; i++)
			{
				switch (counters[i].Split('|').Length)
				{
					case	1:
						counters[i] += "||";
						break;

					case	2:
						counters[i] += '|';
						break;

					default:
						break;
				}
			}
		}

		class ProcessModuleComparer: IComparer
		{
			int IComparer.Compare(Object x, Object y)
			{
				ProcessModule mx = (ProcessModule)x;
				ProcessModule my = (ProcessModule)y;

				return string.Compare(mx.ModuleName, my.ModuleName, false, CultureInfo.InvariantCulture);
			}
		};

		static void PrintModuleList(Process process)
		{
			Console.WriteLine();
			Console.WriteLine();
			Console.WriteLine("Modules loaded:");
			Console.WriteLine("===============");
			Console.WriteLine();
			string format = "{0,-30}{1,9} {2,-15} {3,-7} {4}";
			Console.WriteLine(format, "Module name", "Size (kB)", "Version", "Symbols", "File name");
			Console.WriteLine(format, "-----------", "---------", "-------", "-------", "---------");
			SymInitialize(process.Handle, null, true);
			ArrayList al = new ArrayList();
			foreach (ProcessModule module in process.Modules)
			{
				al.Add(module);
			}
			al.Sort(new ProcessModuleComparer());
			foreach (ProcessModule module in al)
			{
				Console.WriteLine(format, module.ModuleName, module.ModuleMemorySize/1024, module.FileVersionInfo.FileVersion, GetSymType(process.Handle, module.BaseAddress), module.FileName);
			}
		}

		static void Usage()
		{
			Console.WriteLine("Usage:  PerfStats MyManagedProcess");
			Console.WriteLine("   or:  PerfStats -p pid");
			Console.WriteLine();
			Console.WriteLine("Options:");
			Console.WriteLine("  -m-   No Module list");
			Console.WriteLine("  -w-   No Working Set Analysis");
			Console.WriteLine("  -t nn Measure for nn seconds");
			Console.WriteLine();
			Console.WriteLine();
			Console.WriteLine("Add additional perf counters via config file 'PerfStats.cfg'");
			Console.WriteLine("containing lines of the following format:");
			Console.WriteLine();
			Console.WriteLine("  category[|counter[|instance]]");
			Console.WriteLine();
			Console.WriteLine("where 'category' is the perfmon category, e.g. '.NET CLR Memory',");
			Console.WriteLine("'counter' is the perfmon counter name, e.g. '% Time in GC'");
			Console.WriteLine("'instance' is the perfmon counter instance name, e.g. 'MyApplication'.");
			Console.WriteLine();
			Console.WriteLine("Missing or empty counter means all counters under the category");
			Console.WriteLine("Missing instance means the process command line argument.");
			Console.WriteLine("Empty instance means all instances. Use 'singleinstance' for the case");
			Console.WriteLine("where perfmon shows no instances.");
			Console.WriteLine();
			Console.WriteLine("Lines starting with '#', ';' or '//' are ignored.");
			Console.WriteLine();
			Console.WriteLine("Example 'Perfstats.cfg':");
			Console.WriteLine();
			Console.WriteLine("  // Get all processor counters, but only the total for all processors");
			Console.WriteLine("  Processor||_Total");
			Console.WriteLine();
			Console.WriteLine("  // Get all TCP counters");
			Console.WriteLine("  TCP||singleinstance");
			Console.WriteLine();
			Console.WriteLine("  // Get privileged time for this process");
			Console.WriteLine("  Process|% Privileged Time");
			Console.WriteLine();
			Console.WriteLine("  // Get working set for all processes");
			Console.WriteLine("  Process|Working Set|");
		}

		static void Main(string[] args)
		{
			bool doModuleList = true;
			bool doWorkingSet = true;
			int measurementTime = 10/*secs*/;
			string[] configCounters = ReadConfigCounters("PerfStats.cfg");
			Console.WriteLine();

			// print usage information
			if (args.Length == 1 && (args[0] == "/?" || args[0].ToLower(CultureInfo.InvariantCulture) == "/help" ||
									 args[0] == "-?" || args[0].ToLower(CultureInfo.InvariantCulture) == "-help"))
			{
				Usage();
				return;
			}

			// process command line

			string processName = null;
			int processId = 0;
			Process process = null;
			for (int i = 0; i < args.Length; i++)
			{
				// Can it be an option?
				if (args[i].Length >= 1 && (args[i][0] == '-' || args[i][0] == '/'))
				{
					switch (args[i].Substring(1).ToLower(CultureInfo.InvariantCulture))
					{
						case	"m":
						case	"m+":
							doModuleList = true;
							break;

						case	"m-":
							doModuleList = false;
							break;

						case	"p":
							i++;
							if (i < args.Length)
							{
								processId = Int32.Parse(args[i]);
								process = Process.GetProcessById(processId);
								if (process == null)
									Console.WriteLine("Process id not found: {0}", processId);
								else
								{
									processName = process.MainModule.ModuleName;
									if (processName.EndsWith(".exe") || processName.EndsWith(".EXE"))
										processName = processName.Substring(0, processName.Length-4);
									processName = FindProcessById(processName, processId);
								}
							}
							else
								Console.WriteLine("-P option missing argument");
							break;

						case	"w":
						case	"w+":
							doWorkingSet = true;
							break;

						case	"w-":
							doWorkingSet = true;
							break;

						case	"t":
							i++;
							if (i < args.Length)
							{
								measurementTime = Int32.Parse(args[i]);
								if (measurementTime < 1)
								{
									Console.WriteLine("Measurement time must be at least 1 seconds");
									measurementTime = 1;
								}
							}
							else
								Console.WriteLine("-T option missing argument");
							break;

						default:
							Console.WriteLine("Unrecognized option {0}", args[i]);
							break;
					}
				}
				else
				{
					if (processName != null || processId != 0)
						Console.WriteLine("More than one process specified");
					else
					{
						processName = args[i];
						if (processName.ToLower(CultureInfo.InvariantCulture).EndsWith(".exe"))
							processName = processName.Substring(0, processName.Length-4);
					}
				}
			}

			if (processName != null)
			{
				if (process == null)
				{
					processId = ProcessId(processName);
					if (processId >= 0)
						process = Process.GetProcessById(processId);
				}

				if (process == null)
				{
					Console.WriteLine("Process {0} not found", processName);
				}
			}

			if (process == null)
			{
				MakeApplyToAllInstances(stdCounters);
				MakeApplyToAllInstances(configCounters);
			}

			long startCycleCount = GetCycleCount64();
			int startTickCount = GetTickCount();
			Hashtable categoryHash = new Hashtable();
			AddCategories(categoryHash, stdCounters);
			AddCategories(categoryHash, configCounters);

			PerformanceCounterCategory[] categories = new PerformanceCounterCategory[categoryHash.Count];
			int j = 0;
			foreach (PerformanceCounterCategory pcc in categoryHash.Values)
				categories[j++] = pcc;

			InstanceDataCollectionCollection[][] samples = new InstanceDataCollectionCollection[measurementTime+1][];
			Console.Write("Taking measurements for {0} seconds: ", measurementTime);
			samples[0] = SampleCategories(categories);
			for (int t = 1; t <= measurementTime; t++)
			{
				System.Threading.Thread.Sleep(1000);
				samples[t] = SampleCategories(categories);
				Console.Write("{0}", (char)((t % 10) + '0'));
			}
			Console.WriteLine();
			Console.WriteLine();
			Console.WriteLine("System information:");
			Console.WriteLine("===================");
			PrintSystemInformation();

			long elapsedCycleCount = GetCycleCount64() - startCycleCount;
			int elapsedTickCount = GetTickCount() - startTickCount;
			double clockSpeed = (double)elapsedCycleCount/elapsedTickCount/1000.0;
			Console.WriteLine("{0,-41}{1,7:n0} MHz", "Clock speed:", clockSpeed);
			int l2CacheSize = GetL2CacheSize();
			if (l2CacheSize == 0)
				Console.WriteLine("{0,-41}{1,11}", "L2 Cache size:", "Unknown");
			else
				Console.WriteLine("{0,-41}{1,8:n0} kB", "L2 Cache size:", l2CacheSize/1024);

			PrintCounters(stdCounters, categories, samples, null);
			PrintCounters(configCounters, categories, samples, null);

			if (process != null)
			{
				Console.WriteLine();
				Console.WriteLine("Process information for {0}:", processName);
				Console.WriteLine("========================{0}=", new string('=', processName.Length));
				PrintCounters(stdCounters, categories, samples, processName);
				PrintCounters(configCounters, categories, samples, processName);

				if (doModuleList)
				{
					PrintModuleList(process);
				}
				if (doWorkingSet)
				{
					WorkingSetAnalysis(process, processName);
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regasm\commandline.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections;
using System.Globalization;

namespace RegAsm {

internal class Option
{
    private String m_strName;
    private String m_strValue;

    public Option(String strName, String strValue)
    {
        m_strName = strName;
        m_strValue = strValue;
    }

    public String Name { get { return m_strName; } }
    public String Value { get { return m_strValue; } }
}

internal class Abbrevs
{
    private String[] m_aOptions;
    private bool[] m_bRequiresValue;
    private bool[] m_bCanHaveValue;

    public Abbrevs(String[] aOptions)
    {
        m_aOptions = new String[aOptions.Length];
        m_bRequiresValue = new bool[aOptions.Length];
        m_bCanHaveValue = new bool[aOptions.Length];

        // Store option list in lower case for canonical comparison.
        for (int i = 0; i < aOptions.Length; i++)
        {
            String strOption = aOptions[i].ToLower(CultureInfo.InvariantCulture);

            // A leading '*' implies the option requires a value
            // (the '*' itself is not stored in the option name).
            if (strOption.StartsWith("*"))
            {
                m_bRequiresValue[i] = true;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }
            else if (strOption.StartsWith("+"))
            {
                m_bRequiresValue[i] = false;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }

            m_aOptions[i] = strOption;
        }
    }

    public String Lookup(String strOpt, out bool bRequiresValue, out bool bCanHaveValue)
    {
        String strOptLower = strOpt.ToLower(CultureInfo.InvariantCulture);
        int i;
        bool bMatched = false;
        int iMatch = -1;

        // Compare option to stored list.
        for (i = 0; i < m_aOptions.Length; i++)
        {
            // Exact matches always cause immediate termination of
            // the search (else with options foo and foobar, the user
            // could never specify foo unambiguously).
            if (strOptLower.Equals(m_aOptions[i]))
            {
                bRequiresValue = m_bRequiresValue[i];
                bCanHaveValue = m_bCanHaveValue[i];
                return m_aOptions[i];
            }

            // Check for potential match (the input word is a prefix
            // of the current stored option).
            if (m_aOptions[i].StartsWith(strOptLower))
            {
                // If we've already seen a prefix match then the
                // input word is ambiguous.
                if (bMatched)
                    throw new ApplicationException(Resource.FormatString("Err_AmbigousOption", strOpt));

                // Remember this partial match.
                bMatched = true;
                iMatch = i;
            }
        }

        // If we get here with bMatched set, we saw one and only one
        // partial match, so we've got a winner.
        if (bMatched)
        {
            bRequiresValue = m_bRequiresValue[iMatch];
            bCanHaveValue = m_bCanHaveValue[iMatch];
            return m_aOptions[iMatch];
        }

        // Else the word doesn't match at all.
        throw new ApplicationException(Resource.FormatString("Err_UnknownOption", strOpt));
    }
}

internal class CommandLine
{
    private String[] m_aArgList;
    private Option[] m_aOptList;
    private int m_iArgCursor;
    private int m_iOptCursor;
    private Abbrevs m_sValidOptions;

    public CommandLine(String[] aArgs, String[] aValidOpts)
    {
        int i, iArg, iOpt;

        // Keep a list of valid option names.
        m_sValidOptions = new Abbrevs(aValidOpts);

        // Temporary lists of raw arguments and options and their
        // associated values.
        String[] aArgList = new String[aArgs.Length];
        Option[] aOptList = new Option[aArgs.Length];

        // Reset counters of raw arguments and option/value pairs found
        // so far.
        iArg = 0;
        iOpt = 0;

        // Iterate through words of command line.
        for (i = 0; i < aArgs.Length; i++)
        {
            // Check for option or raw argument.
            if (aArgs[i].StartsWith("/") ||
                aArgs[i].StartsWith("-"))
            {
                String strOpt;
                String strVal = null;
                bool bRequiresValue;
                bool bCanHaveValue;

                // It's an option. Strip leading '/' or '-' and
                // anything after a value separator (':' or
                // '=').
                int iColon = aArgs[i].IndexOfAny(new char[] {':', '='});
                if (iColon == -1)
                        strOpt = aArgs[i].Substring(1);
                else
                        strOpt = aArgs[i].Substring(1, iColon - 1);

                // Look it up in the table of valid options (to
                // check it exists, get the full option name and
                // to see if an associated value is expected).
                strOpt = m_sValidOptions.Lookup(strOpt, out bRequiresValue, out bCanHaveValue);

                // Check that the user hasn't specified a value separator for an option 
                // that doesn't take a value.
                if (!bCanHaveValue && (iColon != -1))
                    throw new ApplicationException(Resource.FormatString("Err_NoValueRequired", strOpt));

                // Check that the user has put a colon if the option requires a value.
                if (bRequiresValue && (iColon == -1))
                    throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                
                // Go look for a value if there is one.
                if (bCanHaveValue && iColon != -1)
                {
                    if (iColon == (aArgs[i].Length - 1))
                    {
                        // No value separator, or
                        // separator is at end of
                        // option; look for value in
                        // next command line arg.
                        if (i + 1 == aArgs.Length)
                        {
                            throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                        }
                        else
                        {
                            if ((aArgs[i + 1].StartsWith( "/" ) || aArgs[i + 1].StartsWith( "-" )))
                                throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));

                            strVal = aArgs[i+1];
                            i++;
                        }
                    }
                    else
                    {
                        // Value is in same command line
                        // arg as the option, substring
                        // it out.
                        strVal = aArgs[i].Substring(iColon + 1);
                    }
                }

                // Build the option value pair.
                aOptList[iOpt++] = new Option(strOpt, strVal);
            }
            else
            {
                // Command line word is a raw argument.
                aArgList[iArg++] = aArgs[i];
            }
        }

        // Allocate the non-temporary arg and option lists at exactly
        // the right size.
        m_aArgList = new String[iArg];
        m_aOptList = new Option[iOpt];

        // Copy in the values we've calculated.
        Array.Copy(aArgList, m_aArgList, iArg);
        Array.Copy(aOptList, m_aOptList, iOpt);

        // Reset enumeration cursors to start of lists.
        m_iArgCursor = 0;
        m_iOptCursor = 0;
    }

    public int NumArgs { get { return m_aArgList.Length; } }

    public int NumOpts { get { return m_aOptList.Length; } }

    public String GetNextArg()
    {
        if (m_iArgCursor >= m_aArgList.Length)
            return null;
        return m_aArgList[m_iArgCursor++];
    }

    public Option GetNextOption()
    {
        if (m_iOptCursor >= m_aOptList.Length)
            return null;
        return m_aOptList[m_iOptCursor++];
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regasm\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "REGASM.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Assembly Registration Utility\0"
#define VER_ORIGFILENAME_STR    "RegAsm.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\obfus\poundtildaheap.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.IO;


/*********************************************************************************************************************
 * This class represents the #~ heap.  It stores all the information about the various MetaData tables.
 *********************************************************************************************************************/
internal class PTHeap 
{
	private struct Index4Bytes 
	{
		internal bool stringHeap;
		internal bool guidHeap;
		internal bool blobHeap;
	}

	private uint	m_reserved;
	private byte 	m_majorVersion;
	private byte 	m_minorVersion;
	private byte 	m_heapSizes;
	private byte 	m_rid;
	private ulong	m_valid;
	private ulong	m_sorted;

	private  Index4Bytes		m_indices;
	internal MetaDataTable[]	m_tables;

	private	uint		m_numTables = 0;				// number of MetaData tables
	private const uint	TYPESOFTABLES = 0x2c;

    internal const uint MODULE_TABLE		= 0x00;
    internal const uint TYPEREF_TABLE		= 0x01;
    internal const uint TYPEDEF_TABLE		= 0x02;
    internal const uint FIELDPTR_TABLE		= 0x03;
    internal const uint FIELD_TABLE			= 0x04;
    internal const uint METHODPTR_TABLE		= 0x05;
    internal const uint METHOD_TABLE		= 0x06;
    internal const uint PARAMPTR_TABLE		= 0x07;
    internal const uint PARAM_TABLE			= 0x08;
    internal const uint INTERFACEIMPL_TABLE	= 0x09;

    internal const uint MEMBERREF_TABLE			= 0x0a;
    internal const uint CONSTANT_TABLE			= 0x0b;
    internal const uint CUSTOMATTRIBUTE_TABLE	= 0x0c;
    internal const uint FIELDMARSHAL_TABLE		= 0x0d;
    internal const uint DECLSECURITY_TABLE		= 0x0e;
    internal const uint CLASSLAYOUT_TABLE		= 0x0f;
    internal const uint FIELDLAYOUT_TABLE		= 0x10;
    internal const uint STANDALONESIG_TABLE		= 0x11;
    internal const uint EVENTMAP_TABLE			= 0x12;
    internal const uint EVENTPTR_TABLE			= 0x13;

    internal const uint EVENT_TABLE				= 0x14;
    internal const uint PROPERTYMAP_TABLE		= 0x15;
    internal const uint PROPERTYPTR_TABLE		= 0x16;
    internal const uint PROPERTY_TABLE			= 0x17;
    internal const uint METHODSEMANTICS_TABLE	= 0x18;
    internal const uint METHODIMPL_TABLE		= 0x19;
    internal const uint MODULEREF_TABLE			= 0x1a;
    internal const uint TYPESPEC_TABLE			= 0x1b;
    internal const uint IMPLMAP_TABLE			= 0x1c;
    internal const uint FIELDRVA_TABLE			= 0x1d;

    internal const uint ENCLOG_TABLE				= 0x1e;
    internal const uint ENCMAP_TABLE				= 0x1f;
    internal const uint ASSEMBLY_TABLE				= 0x20;
    internal const uint ASSEMBLYPROCESSOR_TABLE		= 0x21;
    internal const uint ASSEMBLYOS_TABLE			= 0x22;
    internal const uint ASSEMBLYREF_TABLE			= 0x23;
    internal const uint ASSEMBLYREFPROCESSOR_TABLE	= 0x24;
    internal const uint ASSEMBLYREFOS_TABLE			= 0x25;
    internal const uint FILE_TABLE					= 0x26;
    internal const uint EXPORTEDTYPE_TABLE			= 0x27;

    internal const uint MANIFESTRESOURCE_TABLE	= 0x28;
    internal const uint NESTEDCLASS_TABLE		= 0x29;
    internal const uint TYPETYPAR_TABLE			= 0x2a;
    internal const uint METHODTYPAR_TABLE		= 0x2b;

	internal const uint MODULE_NAME_COL			= 2;

	internal const uint TYPEREF_RESOLUTIONSCOPE_COL	= 1;
	internal const uint TYPEREF_NAME_COL			= 2;
	internal const uint TYPEREF_NAMESPACE_COL		= 3;

	internal const uint TYPEDEF_FLAGS_COL		= 1;
	internal const uint TYPEDEF_NAME_COL		= 2;
	internal const uint TYPEDEF_NAMESPACE_COL	= 3;
	internal const uint TYPEDEF_EXTENDS_COL		= 4;
	internal const uint TYPEDEF_FIELDLIST_COL	= 5;
	internal const uint TYPEDEF_METHODLIST_COL	= 6;

	internal const uint FIELD_FLAGS_COL			= 1;
	internal const uint FIELD_NAME_COL			= 2;

	internal const uint METHOD_IMPLFLAGS_COL	= 2;
	internal const uint METHOD_FLAGS_COL		= 3;
	internal const uint METHOD_NAME_COL			= 4;
	internal const uint METHOD_SIGNATURE_COL	= 5;
	internal const uint METHOD_PARAMLIST_COL	= 6;

	internal const uint PARAM_NAME_COL				= 3;

	internal const uint INTERFACEIMPL_CLASS_COL		= 1;
	internal const uint INTERFACEIMPL_INTERFACE_COL	= 2;

	internal const uint MEMBERREF_CLASS_COL		= 1;
	internal const uint MEMBERREF_NAME_COL		= 2;
	internal const uint MEMBERREF_SIGNATURE_COL	= 3;
	
	internal const uint EVENT_NAME_COL		= 2;
	internal const uint PROPERTY_NAME_COL	= 2;

	internal const uint METHODSEMANTICS_METHOD_COL		= 2;
	internal const uint METHODSEMANTICS_ASSOCIATION_COL	= 3;

	internal const uint MODULEREF_NAME_COL	= 1;

	internal const uint IMPLMAP_IMPORTNAME_COL	= 3;

	internal const uint ASSEMBLY_HASHALGID_COL	= 1;
	internal const uint ASSEMBLY_NAME_COL		= 8;
	internal const uint ASSEMBLY_LOCALE_COL		= 9;

	internal const uint ASSEMBLYREF_NAME_COL	= 7;
	internal const uint ASSEMBLYREF_LOCALE_COL	= 8;

	internal const uint FILE_NAME_COL		= 2;
	internal const uint FILE_HASHVALUE_COL	= 3;

	internal const uint EXPORTED_TYPENAME_COL		= 3;
	internal const uint EXPORTED_TYPENAMESPACE_COL	= 4;

	internal const uint MANIFESTRESOURCE_NAME_COL	= 3;

	internal const uint NESTEDCLASS_NESTEDCLASS_COL		= 1;
	internal const uint NESTEDCLASS_ENCLOSINGCLASS_COL	= 2;

	internal const uint TYPETYPAR_NAME_COL		= 4;
	internal const uint METHODTYPAR_NAME_COL	= 4;

	internal PTHeap(ref BinaryReader reader, ref BinaryWriter writer, ref StringHeap strHeap, ulong startPos) 
	{
		uint	i, width, max;
		ulong	tmp, offset = startPos;		// "offset" is used to store the starting position of each MetaData table
		uint[]	colDef;						// column definitions for the various MetaData tables

		reader.BaseStream.Seek((long)startPos, SeekOrigin.Begin);

		m_reserved		= reader.ReadUInt32();
		m_majorVersion	= reader.ReadByte();
		m_minorVersion	= reader.ReadByte();
		m_heapSizes		= reader.ReadByte();
		m_rid			= reader.ReadByte();
		m_valid			= reader.ReadUInt64();
		m_sorted		= reader.ReadUInt64();

		offset += 24;

		// Determine whether the indices to the string, guid, and blob heaps are 4 bytes wide or 2 bytes wide.
		m_indices.stringHeap	= ((m_heapSizes & 1) != 0); 
		m_indices.guidHeap		= ((m_heapSizes >> 1 & 1) != 0); 
		m_indices.blobHeap		= ((m_heapSizes >> 2 & 1) != 0); 

		#if DEBUG0
			Console.Write("indices are 4 bytes wide: ");
			Console.WriteLine(m_indices.stringHeap + " " + m_indices.guidHeap + " " + m_indices.blobHeap);
		#endif

		// Figure out which MetaData tables are present in this file.
		m_tables = new MetaDataTable[TYPESOFTABLES];
		tmp = m_valid;
		for (i = 0; i < TYPESOFTABLES; i++)
		{
			if ((tmp & 1) != 0)
			{
				m_tables[i] = new MetaDataTable();
				m_numTables += 1;
			}
			else
			{
				m_tables[i] = null;
			}
			tmp >>= 1;
		}

		#if DEBUG0
			Console.WriteLine("number of tables in the #~ heap: " + m_numTables + Environment.NewLine);
		#endif

		// Read the number of rows for each present MetaData table.
		for (i = 0; i < TYPESOFTABLES; i++)
		{
			if (m_tables[i] != null)
			{
				m_tables[i].m_numRows = reader.ReadUInt32();
				offset += 4;
			}
		}

		#if DEBUG0
			for (i = 0; i < TYPESOFTABLES; i++)
			{
				if (m_tables[i] != null)
				{
					Console.WriteLine(i + "\t" + m_tables[i].m_numRows + "\t" + m_tables[i].m_rowLen);
				}
			}
		#endif

		// TODO : Should we flatten the for loop so that we can eliminate the switch statement?
		// Populate each MetaData table.	
		for (i = 0; i < TYPESOFTABLES; i++)
		{
			if (m_tables[i] == null) continue;

			switch (i)
			{
				case MODULE_TABLE:
					colDef = new uint[5];
					colDef[0] = 2;
					colDef[1] = (uint)(m_indices.stringHeap ? 4 : 2);
					width = (uint)(m_indices.guidHeap ? 4 : 2);
					colDef[2] = width;
					colDef[3] = width;
					colDef[4] = width;

					m_tables[i].Initialize(5, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case TYPEREF_TABLE:
					colDef = new uint[3];

					max = (m_tables[MODULE_TABLE] != null ? m_tables[MODULE_TABLE].m_numRows : 0); 
					if (m_tables[MODULEREF_TABLE] != null && m_tables[MODULEREF_TABLE].m_numRows > max)
						max = m_tables[MODULEREF_TABLE].m_numRows;
					if (m_tables[ASSEMBLYREF_TABLE] != null && m_tables[ASSEMBLYREF_TABLE].m_numRows > max)
						max = m_tables[ASSEMBLYREF_TABLE].m_numRows;
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					colDef[0] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);
	
					width = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[1] = width;
					colDef[2] = width;

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case TYPEDEF_TABLE:
					colDef = new uint[6];
					colDef[0] = 4;
					width = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[1] = width;
					colDef[2] = width;

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					colDef[3] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					colDef[4] = (uint)(m_tables[FIELD_TABLE] != null && m_tables[FIELD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);
					colDef[5] = (uint)(m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(6, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case FIELDPTR_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_tables[FIELD_TABLE] != null && m_tables[FIELD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case FIELD_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;
					colDef[1] = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case METHODPTR_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case METHOD_TABLE:
					colDef = new uint[6];
					colDef[0] = 4;
					colDef[1] = 2;
					colDef[2] = 2;

					colDef[3] = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[4] = (uint)(m_indices.blobHeap ? 4 : 2);
					colDef[5] = (uint)(m_tables[PARAM_TABLE] != null && m_tables[PARAM_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(6, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case PARAMPTR_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_tables[PARAM_TABLE] != null && m_tables[PARAM_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case PARAM_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;
					colDef[1] = 2;
					colDef[2] = (uint)(m_indices.stringHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case INTERFACEIMPL_TABLE:
					colDef = new uint[2];
					colDef[0] = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					colDef[1] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case MEMBERREF_TABLE:
					colDef = new uint[3];

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[MODULEREF_TABLE] != null && m_tables[MODULEREF_TABLE].m_numRows > max)
						max = m_tables[MODULEREF_TABLE].m_numRows;
					if (m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > max)
						max = m_tables[METHOD_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					colDef[0] = (uint)(max > Math.Pow(2, 16 - 3) - 1 ? 4 : 2);

					colDef[1] = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case CONSTANT_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;

					max = (m_tables[FIELD_TABLE] != null ? m_tables[FIELD_TABLE].m_numRows : 0);
					if (m_tables[PARAM_TABLE] != null && m_tables[PARAM_TABLE].m_numRows > max)
						max = m_tables[PARAM_TABLE].m_numRows;
					if (m_tables[PROPERTY_TABLE] != null && m_tables[PROPERTY_TABLE].m_numRows > max)
						max = m_tables[PROPERTY_TABLE].m_numRows;
					colDef[1] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case CUSTOMATTRIBUTE_TABLE:
					colDef = new uint[3];

					max = (m_tables[METHOD_TABLE] != null ? m_tables[METHOD_TABLE].m_numRows : 0);
					if (m_tables[FIELD_TABLE] != null && m_tables[FIELD_TABLE].m_numRows > max)
						max = m_tables[FIELD_TABLE].m_numRows;
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > max)
						max = m_tables[TYPEDEF_TABLE].m_numRows;
					if (m_tables[PARAM_TABLE] != null && m_tables[PARAM_TABLE].m_numRows > max)
						max = m_tables[PARAM_TABLE].m_numRows;

					if (m_tables[INTERFACEIMPL_TABLE] != null && m_tables[INTERFACEIMPL_TABLE].m_numRows > max)
						max = m_tables[INTERFACEIMPL_TABLE].m_numRows;
					if (m_tables[MEMBERREF_TABLE] != null && m_tables[MEMBERREF_TABLE].m_numRows > max)
						max = m_tables[MEMBERREF_TABLE].m_numRows;
					if (m_tables[MODULE_TABLE] != null && m_tables[MODULE_TABLE].m_numRows > max)
						max = m_tables[MODULE_TABLE].m_numRows;
					if (m_tables[DECLSECURITY_TABLE] != null && m_tables[DECLSECURITY_TABLE].m_numRows > max)
						max = m_tables[DECLSECURITY_TABLE].m_numRows;
					if (m_tables[PROPERTY_TABLE] != null && m_tables[PROPERTY_TABLE].m_numRows > max)
						max = m_tables[PROPERTY_TABLE].m_numRows;

					if (m_tables[EVENT_TABLE] != null && m_tables[EVENT_TABLE].m_numRows > max)
						max = m_tables[EVENT_TABLE].m_numRows;
					if (m_tables[STANDALONESIG_TABLE] != null && m_tables[STANDALONESIG_TABLE].m_numRows > max)
						max = m_tables[STANDALONESIG_TABLE].m_numRows;
					if (m_tables[MODULEREF_TABLE] != null && m_tables[MODULEREF_TABLE].m_numRows > max)
						max = m_tables[MODULEREF_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					if (m_tables[ASSEMBLY_TABLE] != null && m_tables[ASSEMBLY_TABLE].m_numRows > max)
						max = m_tables[ASSEMBLY_TABLE].m_numRows;

					if (m_tables[ASSEMBLYREF_TABLE] != null && m_tables[ASSEMBLYREF_TABLE].m_numRows > max)
						max = m_tables[ASSEMBLYREF_TABLE].m_numRows;
					if (m_tables[FILE_TABLE] != null && m_tables[FILE_TABLE].m_numRows > max)
						max = m_tables[FILE_TABLE].m_numRows;
					if (m_tables[EXPORTEDTYPE_TABLE] != null && m_tables[EXPORTEDTYPE_TABLE].m_numRows > max)
						max = m_tables[EXPORTEDTYPE_TABLE].m_numRows;
					if (m_tables[MANIFESTRESOURCE_TABLE] != null && m_tables[MANIFESTRESOURCE_TABLE].m_numRows > max)
						max = m_tables[MANIFESTRESOURCE_TABLE].m_numRows;
					colDef[0] = (uint)(max > Math.Pow(2, 16 - 5) - 1 ? 4 : 2);

					max = (m_tables[TYPEREF_TABLE] != null ? m_tables[TYPEREF_TABLE].m_numRows : 0);
					if (m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > max)
						max = m_tables[TYPEDEF_TABLE].m_numRows;
					if (m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > max)
						max = m_tables[METHOD_TABLE].m_numRows;
					if (m_tables[MEMBERREF_TABLE] != null && m_tables[MEMBERREF_TABLE].m_numRows > max)
						max = m_tables[MEMBERREF_TABLE].m_numRows;
					colDef[1] = (uint)(max > Math.Pow(2, 16 - 3) - 1 ? 4 : 2);

					/*
					// Please note that the size of the string heap should not be taken into account when determining the 
					// length of this column.  Use System.dll as a test to see the behaviour.
					if (colDef[1] == 2 && m_indices.stringHeap)
						colDef[1] = 4;
					*/

					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case FIELDMARSHAL_TABLE:
					colDef = new uint[2];

					max = (m_tables[FIELD_TABLE] != null ? m_tables[FIELD_TABLE].m_numRows : 0);
					if (m_tables[PARAM_TABLE] != null && m_tables[PARAM_TABLE].m_numRows > max)
						max = m_tables[PARAM_TABLE].m_numRows;
					colDef[0] = (uint)(max > Math.Pow(2, 16 - 1) - 1 ? 4 : 2);

					colDef[1] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case DECLSECURITY_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > max)
						max = m_tables[METHOD_TABLE].m_numRows;
					if (m_tables[ASSEMBLY_TABLE] != null && m_tables[ASSEMBLY_TABLE].m_numRows > max)
						max = m_tables[ASSEMBLY_TABLE].m_numRows;
					colDef[1] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case CLASSLAYOUT_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;
					colDef[1] = 4;
					colDef[2] = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case FIELDLAYOUT_TABLE:
					colDef = new uint[2];
					colDef[0] = 4;
					colDef[1] = (uint)(m_tables[FIELD_TABLE] != null && m_tables[FIELD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case STANDALONESIG_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case EVENTMAP_TABLE:
					colDef = new uint[2];
					colDef[0] = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);
					colDef[1] = (uint)(m_tables[EVENT_TABLE] != null && m_tables[EVENT_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case EVENTPTR_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_tables[EVENT_TABLE] != null && m_tables[EVENT_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case EVENT_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;
					colDef[1] = (uint)(m_indices.stringHeap ? 4 : 2);

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					colDef[2] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case PROPERTYMAP_TABLE:
					colDef = new uint[2];
					colDef[0] = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);
					colDef[1] = (uint)(m_tables[PROPERTY_TABLE] != null && m_tables[PROPERTY_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case PROPERTYPTR_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_tables[PROPERTY_TABLE] != null && m_tables[PROPERTY_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case PROPERTY_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;
					colDef[1] = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case METHODSEMANTICS_TABLE:
					colDef = new uint[3];
					colDef[0] = 2;
					colDef[1] = (uint)(m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					max = (m_tables[EVENT_TABLE] != null ? m_tables[EVENT_TABLE].m_numRows : 0);
					if (m_tables[PROPERTY_TABLE] != null && m_tables[PROPERTY_TABLE].m_numRows > max)
						max = m_tables[PROPERTY_TABLE].m_numRows;
					colDef[2] = (uint)(max > Math.Pow(2, 16 - 1) - 1 ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case METHODIMPL_TABLE:
					colDef = new uint[3];
					colDef[0] = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					max = (m_tables[METHOD_TABLE] != null ? m_tables[METHOD_TABLE].m_numRows : 0);
					if (m_tables[MEMBERREF_TABLE] != null && m_tables[MEMBERREF_TABLE].m_numRows > max)
						max = m_tables[MEMBERREF_TABLE].m_numRows;
					width = (uint)(max > Math.Pow(2, 16 - 1) - 1 ? 4 : 2);
					colDef[1] = width;
					colDef[2] = width;

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case MODULEREF_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_indices.stringHeap ? 4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case TYPESPEC_TABLE:
					colDef = new uint[1];
					colDef[0] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case IMPLMAP_TABLE:
					colDef = new uint[4];
					colDef[0] = 2;

					max = (m_tables[FIELD_TABLE] != null ? m_tables[FIELD_TABLE].m_numRows : 0);
					if (m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > max)
						max = m_tables[METHOD_TABLE].m_numRows;
					colDef[1] = (uint)(max > Math.Pow(2, 16 - 1) - 1 ? 4 : 2);

					colDef[2] = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[3] = (uint)(m_tables[MODULEREF_TABLE] != null && m_tables[MODULEREF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					m_tables[i].Initialize(4, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case FIELDRVA_TABLE:
					colDef = new uint[2];
					colDef[0] = 4;
					colDef[1] = (uint)(m_tables[FIELD_TABLE] != null && m_tables[FIELD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ?
									   4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case ENCLOG_TABLE:
					colDef = new uint[2];
					colDef[0] = 4;
					colDef[1] = 4;

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case ENCMAP_TABLE:
					colDef = new uint[1];
					colDef[0] = 4;

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case ASSEMBLY_TABLE:
					colDef = new uint[9];
					colDef[0] = 4;
					colDef[1] = 2;
					colDef[2] = 2;
					colDef[3] = 2;
					colDef[4] = 2;
					colDef[5] = 4;

					colDef[6] = (uint)(m_indices.blobHeap ? 4 : 2);
					width = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[7] = width;
					colDef[8] = width;

					m_tables[i].Initialize(9, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case ASSEMBLYPROCESSOR_TABLE:
					colDef = new uint[1];
					colDef[0] = 4;

					m_tables[i].Initialize(1, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case ASSEMBLYOS_TABLE:
					colDef = new uint[3];
					colDef[0] = 4;
					colDef[1] = 4;
					colDef[2] = 4;

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case ASSEMBLYREF_TABLE:
					colDef = new uint[9];
					colDef[0] = 2;
					colDef[1] = 2;
					colDef[2] = 2;
					colDef[3] = 2;
					colDef[4] = 4;

					width = (uint)(m_indices.blobHeap ? 4 : 2);
					colDef[5] = width;
					colDef[8] = width;

					width = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[6] = width;
					colDef[7] = width;

					m_tables[i].Initialize(9, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case ASSEMBLYREFPROCESSOR_TABLE:
					colDef = new uint[2];
					colDef[0] = 4;
					colDef[1] = (uint)(m_tables[ASSEMBLYREF_TABLE] != null && m_tables[ASSEMBLYREF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case ASSEMBLYREFOS_TABLE:
					colDef = new uint[4];
					colDef[0] = 4;
					colDef[1] = 4;
					colDef[2] = 4;

					colDef[3] = (uint)(m_tables[ASSEMBLYREF_TABLE] != null && m_tables[ASSEMBLYREF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					m_tables[i].Initialize(4, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case FILE_TABLE:
					colDef = new uint[3];
					colDef[0] = 4;
					colDef[1] = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[2] = (uint)(m_indices.blobHeap ? 4 : 2);

					m_tables[i].Initialize(3, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case EXPORTEDTYPE_TABLE:
					colDef = new uint[5];
					colDef[0] = 4;
					colDef[1] = 4;

					width = (uint)(m_indices.stringHeap ? 4 : 2);
					colDef[2] = width;
					colDef[3] = width;

					max = (m_tables[FILE_TABLE] != null ? m_tables[FILE_TABLE].m_numRows : 0);
					if (m_tables[ASSEMBLYREF_TABLE] != null && m_tables[ASSEMBLYREF_TABLE].m_numRows > max)
						max = m_tables[ASSEMBLYREF_TABLE].m_numRows;
					if (m_tables[EXPORTEDTYPE_TABLE] != null && m_tables[EXPORTEDTYPE_TABLE].m_numRows > max)
						max = m_tables[EXPORTEDTYPE_TABLE].m_numRows;
					colDef[4] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					m_tables[i].Initialize(5, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case MANIFESTRESOURCE_TABLE:
					colDef = new uint[4];
					colDef[0] = 4;
					colDef[1] = 4;
					colDef[2] = (uint)(m_indices.stringHeap ? 4 : 2);

					max = (m_tables[FILE_TABLE] != null ? m_tables[FILE_TABLE].m_numRows : 0);
					if (m_tables[ASSEMBLYREF_TABLE] != null && m_tables[ASSEMBLYREF_TABLE].m_numRows > max)
						max = m_tables[ASSEMBLYREF_TABLE].m_numRows;
					if (m_tables[EXPORTEDTYPE_TABLE] != null && m_tables[EXPORTEDTYPE_TABLE].m_numRows > max)
						max = m_tables[EXPORTEDTYPE_TABLE].m_numRows;
					colDef[3] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					m_tables[i].Initialize(4, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				case NESTEDCLASS_TABLE:
					colDef = new uint[2];
					width = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);
					colDef[0] = width;
					colDef[1] = width;

					m_tables[i].Initialize(2, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case TYPETYPAR_TABLE:
					colDef = new uint[4];
					colDef[0] = 2;
					colDef[1] = (uint)(m_tables[TYPEDEF_TABLE] != null && m_tables[TYPEDEF_TABLE].m_numRows > 
									   Math.Pow(2, 16) - 1 ? 4 : 2);

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					colDef[2] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					colDef[3] = (uint)(m_indices.stringHeap ? 4 : 2);

					m_tables[i].Initialize(4, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				// according to ildasm
				case METHODTYPAR_TABLE:
					colDef = new uint[4];
					colDef[0] = 2;
					colDef[1] = (uint)(m_tables[METHOD_TABLE] != null && m_tables[METHOD_TABLE].m_numRows > Math.Pow(2, 16) - 1 ? 
									   4 : 2);

					max = (m_tables[TYPEDEF_TABLE] != null ? m_tables[TYPEDEF_TABLE].m_numRows : 0);
					if (m_tables[TYPEREF_TABLE] != null && m_tables[TYPEREF_TABLE].m_numRows > max)
						max = m_tables[TYPEREF_TABLE].m_numRows;
					if (m_tables[TYPESPEC_TABLE] != null && m_tables[TYPESPEC_TABLE].m_numRows > max)
						max = m_tables[TYPESPEC_TABLE].m_numRows;
					colDef[2] = (uint)(max > Math.Pow(2, 16 - 2) - 1 ? 4 : 2);

					colDef[3] = (uint)(m_indices.stringHeap ? 4 : 2);

					m_tables[i].Initialize(4, offset, ref colDef, ref reader, ref writer);
					offset += m_tables[i].m_numRows * m_tables[i].m_rowLen;
					break;

				default:
					break;
			}
		}

		#if DEBUG0
			for (i = 0; i < TYPESOFTABLES; i++)
			{
				Console.Write("table " + i + ": \t");
				if (m_tables[i] != null)
				{
					for (uint j = 0; j < m_tables[i].m_numCols; j++)
					{
						Console.Write(m_tables[i].m_colDef[j] + "\t");
					}
				}
				Console.WriteLine();
			}
		#endif
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regasm\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace RegAsm {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("RegAsm", 
                                          Assembly.GetAssembly(typeof(RegAsm)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regasm\regasm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Resources;
using System.Collections;
using System.Runtime.Remoting;
using System.Threading;
using System.Globalization;
using RegCode;

[assembly:ComVisible(false)]

namespace RegAsm {

internal enum REGKIND
{
    REGKIND_DEFAULT         = 0,
    REGKIND_REGISTER        = 1,
    REGKIND_NONE            = 2
}

public class RegAsm
{
    private const String strDocStringPrefix = "";
    private const String strManagedTypeThreadingModel = "Both";
    private const String strClassesRootRegKey = "HKEY_CLASSES_ROOT";
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;

    public static int Main(String []aArgs)
    {
        int RetCode = SuccessReturnCode;
        // Parse the command line arguments.
        if (!ParseArguments(aArgs, ref s_Options, ref RetCode))
            return RetCode;
        
        // If we are not in silent mode then print the RegAsm logo.
        if (!s_Options.m_bSilentMode)
            PrintLogo();
        
        return Run();
    }

    public static int Run()
    {
        String strAsmDir = null;
        String strInitCurrDir = null;
        int RetCode = SuccessReturnCode;

        try
        {
            String fullPath = Path.GetFullPath( s_Options.m_strAssemblyName );

            if (!File.Exists( fullPath ))
            {
                // Call SearchPath to find the full path of the assembly to load.
                StringBuilder sb = new StringBuilder(MAX_PATH + 1);
                if (SearchPath(null, s_Options.m_strAssemblyName, null, sb.Capacity + 1, sb, null) == 0)
                    throw new ApplicationException(Resource.FormatString("Err_InputFileNotFound", s_Options.m_strAssemblyName));
                s_Options.m_strAssemblyName = sb.ToString();
            }
            else
            {
                s_Options.m_strAssemblyName = fullPath;
            }

            // Expand the file names to their full path.
            s_Options.m_strAssemblyName = (new FileInfo(s_Options.m_strAssemblyName)).FullName;
            if (s_Options.m_strRegFileName != null)
                s_Options.m_strRegFileName = (new FileInfo(s_Options.m_strRegFileName)).FullName;

            // Retrieve the directory of the assembly.
            strAsmDir = Path.GetDirectoryName(s_Options.m_strAssemblyName);

            // If a typelib was specified without any path information then put in the directory of
            // the assembly. If there is path information, then retrieve the fully qualified path
            // name of the typelib.
            if (s_Options.m_strTypeLibName != null)
            {
                if (Path.GetDirectoryName(s_Options.m_strTypeLibName) == "")
                {
                    s_Options.m_strTypeLibName = Path.Combine(strAsmDir, s_Options.m_strTypeLibName);
                }
                else
                {
                    s_Options.m_strTypeLibName = (new FileInfo(s_Options.m_strTypeLibName)).FullName;
                }

            }

            // If the /tlb flag has been specified then we need to do some validation for
            // embedded type libraries and determine the name of the type library if it 
            // was not specified.
            if (s_Options.m_bTypeLibSpecified)
            {
                if (s_Options.m_strTypeLibName == null)
                {
                    // If the assembly contains an embedded type library, then we will use it as the
                    // name of the type library to register or unregister.
                    if (ContainsEmbeddedTlb(s_Options.m_strAssemblyName))
                    {
                        s_Options.m_strTypeLibName = s_Options.m_strAssemblyName;
                    }
                    else
                    {
	                    if (s_Options.m_strAssemblyName.Length >= 4 &&
	                        (String.Compare( s_Options.m_strAssemblyName.Substring( s_Options.m_strAssemblyName.Length - 4 ), ".dll", true, CultureInfo.InvariantCulture) == 0 ||
	                         String.Compare( s_Options.m_strAssemblyName.Substring( s_Options.m_strAssemblyName.Length - 4 ), ".exe", true, CultureInfo.InvariantCulture ) == 0))
	                    {
	                        s_Options.m_strTypeLibName = s_Options.m_strAssemblyName.Substring( 0, s_Options.m_strAssemblyName.Length - 4 ) + ".tlb";
	                    }
	                    else
	                    {
	                        s_Options.m_strTypeLibName = s_Options.m_strAssemblyName + ".tlb";
	                    }
	                }

                    if (!Directory.Exists( Path.GetDirectoryName( s_Options.m_strTypeLibName ) ))
                    {
                        Directory.CreateDirectory( Path.GetDirectoryName( s_Options.m_strTypeLibName ) );
                    }
                }
                else
                {
                    if (!Directory.Exists( Path.GetDirectoryName( s_Options.m_strTypeLibName ) ))
                    {
                        Directory.CreateDirectory( Path.GetDirectoryName( s_Options.m_strTypeLibName ) );
                    }

                    // A typelib name has been specified, make sure that the assembly does not contain
                    // an embedded typelib.
                    if (ContainsEmbeddedTlb(s_Options.m_strAssemblyName))
                        throw new ApplicationException(Resource.FormatString("Err_TlbNameNotAllowedWithEmbedded"));
                }

            }
            
            // If the regfile option was specified but no file was given
            // assume the file name is the assembly name with a different suffix.
            if (s_Options.m_bRegFileSpecified && s_Options.m_strRegFileName == null)
            {
                if (s_Options.m_strAssemblyName.Length >= 4 &&
                    (String.Compare( s_Options.m_strAssemblyName.Substring( s_Options.m_strAssemblyName.Length - 4 ), ".dll", true, CultureInfo.InvariantCulture ) == 0 ||
                     String.Compare( s_Options.m_strAssemblyName.Substring( s_Options.m_strAssemblyName.Length - 4 ), ".exe", true, CultureInfo.InvariantCulture ) == 0))
                {
                    s_Options.m_strRegFileName = s_Options.m_strAssemblyName.Substring( 0, s_Options.m_strAssemblyName.Length - 4 ) + ".reg";
                }
                else
                {
                    s_Options.m_strRegFileName = s_Options.m_strAssemblyName + ".reg";
                }

            }

            if (s_Options.m_bRegFileSpecified && !Directory.Exists( Path.GetDirectoryName( s_Options.m_strRegFileName ) ))
            {
                Directory.CreateDirectory( Path.GetDirectoryName( s_Options.m_strRegFileName ) );
            }


            // Retrieve the initial current directory.
            strInitCurrDir = Environment.CurrentDirectory;

            // Create an AppDomain to load the implementation part of the app into.
            AppDomainSetup options = new AppDomainSetup();
            options.ApplicationBase = strAsmDir;
            AppDomain domain = AppDomain.CreateDomain("RegAsm", null, options);
            if (domain == null)
                throw new ApplicationException(Resource.FormatString("Err_CannotCreateAppDomain"));

            // Create the remote component that will perform the rest of the conversion.
			String assemblyName = typeof(RegCode.RemoteRegAsm).Assembly.GetName().FullName;
			ObjectHandle h = domain.CreateInstance(assemblyName, "RegCode.RemoteRegAsm");
            if (h == null)
                throw new ApplicationException(Resource.FormatString("Err_CannotCreateRemoteRegAsm"));

            // Have the remote component perform the rest of the conversion.
            RemoteRegAsm code = (RemoteRegAsm) h.Unwrap();
            if(code != null)
                RetCode = code.Run(s_Options);

            // Do not unload the domain, this causes problems with IJW MC++ assemblies that
            // call managed code from DllMain's ProcessDetach notification.
        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            RetCode = ErrorReturnCode;
        }

        return RetCode;
    }

    private static bool ContainsEmbeddedTlb(String strFileName)
    {
        UCOMITypeLib Tlb = null;

        try
        {
            LoadTypeLibEx(s_Options.m_strAssemblyName, REGKIND.REGKIND_NONE, out Tlb);
        }
        catch (Exception)
        {
        }

        return Tlb != null ? true : false;
    }

    private static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";        
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
        else
        {
            strErrorMsg += e.GetType().ToString();
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_RegAsmErrorPrefix", strErrorMsg));
    }

    private static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_RegAsmErrorPrefix", strErrorMsg));
    }

    private static void WriteWarningMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_RegAsmWarningPrefix", strErrorMsg));
    }

    // ParseArguments returns true to indicate the program should continue and false otherwise.
    // If it returns false then the return code will be set to the return value that should
    // be returned by the program.
    private static bool ParseArguments(String []aArgs, ref RegAsmOptions Options, ref int ReturnCode)
    {
        CommandLine cmdLine;
        Option opt;

        // Create the options object that will be returned.
        Options = new RegAsmOptions();

        // Parse the command line arguments using the command line argument parser.
        try 
        {
            cmdLine = new CommandLine(aArgs, new String[] { "+regfile", "+tlb", "unregister", "registered", "codebase", "nologo", "silent", "verbose", "?", "help" });
        }
        catch (ApplicationException e)
        {
            PrintLogo();
            WriteErrorMsg(null, e);
            ReturnCode = ErrorReturnCode;
            return false;
        }

        // Make sure there is at least one argument.
        if ((cmdLine.NumArgs + cmdLine.NumOpts) < 1)
        {
            PrintUsage();
            ReturnCode = SuccessReturnCode;
            return false;
        }

        // Get the name of the input file.
        Options.m_strAssemblyName = cmdLine.GetNextArg();

        // Go through the list of options.
        while ((opt = cmdLine.GetNextOption()) != null)
        {
            // Determine which option was specified.
            if (opt.Name.Equals("regfile"))
            {
                Options.m_strRegFileName = opt.Value;
                Options.m_bRegFileSpecified = true;
            }
            else if (opt.Name.Equals("tlb"))
            {
                Options.m_strTypeLibName = opt.Value;
                Options.m_bTypeLibSpecified = true;
            }
            else if (opt.Name.Equals("codebase"))
                Options.m_bSetCodeBase = true;
            else if (opt.Name.Equals("unregister"))
                Options.m_bRegister = false;
            else if (opt.Name.Equals("registered"))
                Options.m_Flags |= TypeLibExporterFlags.OnlyReferenceRegistered;
            else if (opt.Name.Equals("nologo"))
                Options.m_bNoLogo = true;
            else if (opt.Name.Equals("silent"))
                Options.m_bSilentMode = true;
            else if (opt.Name.Equals("verbose"))
                Options.m_bVerboseMode = true;
            else if (opt.Name.Equals("?") || opt.Name.Equals("help"))
            {
                PrintUsage();
                ReturnCode = SuccessReturnCode;
                return false;
            }
            else
            {
                PrintLogo();
                WriteErrorMsg(Resource.FormatString("Err_InvalidOption"));
                ReturnCode = ErrorReturnCode;
                return false;
            }
        }

        // Check for invalid combinations.
        if (!Options.m_bRegister && Options.m_bRegFileSpecified)
        {
            PrintLogo();
            WriteErrorMsg(Resource.FormatString("Err_CannotGenRegFileForUnregister"));
            ReturnCode = ErrorReturnCode;
            return false;
        }

        if (Options.m_bTypeLibSpecified && Options.m_bRegFileSpecified)
        {
            PrintLogo();
            WriteErrorMsg(Resource.FormatString("Err_CannotGenRegFileAndExpTlb"));
            ReturnCode = ErrorReturnCode;
            return false;
        }

        // Make sure an input file was specified.
        if (Options.m_strAssemblyName == null)
        {
            PrintLogo();
            WriteErrorMsg(Resource.FormatString("Err_NoInputFile"));
            ReturnCode = ErrorReturnCode;
            return false;
        }

        return true;
    }

    private static void PrintLogo()
    {
        if (!s_Options.m_bNoLogo)
            Console.WriteLine(Resource.FormatString("Msg_Copyright", Util.Version.VersionString));
    }

    private static void PrintUsage()
    {
        // Print the copyright message.
        PrintLogo();

        // Print the usage.
        Console.WriteLine(Resource.FormatString("Msg_Usage"));
    }

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void LoadTypeLibEx(String strTypeLibName, REGKIND regKind, out UCOMITypeLib TypeLib);

    internal static RegAsmOptions s_Options = null;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regcode\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\Regcode.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt Regcode.resources

cool_target_sign: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)

TARGET_EXTESION_ = dll
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.dll=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc

        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regcode\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "REGASM.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Assembly Registration Utility\0"
#define VER_ORIGFILENAME_STR    "RegAsm.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regkeyseperator\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regcode\regasmoptions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Runtime.InteropServices;

namespace RegCode {

[Serializable()] 
public sealed class RegAsmOptions
{
    public String m_strAssemblyName = null;
    public String m_strTypeLibName = null;
    public bool   m_bRegister = true;
    public bool   m_bSetCodeBase = false;
    public String m_strRegFileName = null;
    public bool   m_bNoLogo = false;
    public bool   m_bSilentMode = false;
    public bool   m_bVerboseMode = false;
    public bool   m_bTypeLibSpecified = false;
    public bool   m_bRegFileSpecified = false;
    public TypeLibExporterFlags    m_Flags = 0;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regcode\remoteregasm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace RegCode {

public class RemoteRegAsm: MarshalByRefObject
{

    public int Run(RegAsmOptions s_options)
    {
        return RegCode.Run(s_options);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regcode\regcode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Globalization;

[assembly:ComVisible(false)]

namespace RegCode {

internal enum REGKIND
{
    REGKIND_DEFAULT         = 0,
    REGKIND_REGISTER        = 1,
    REGKIND_NONE            = 2
}

[ComVisible(false)]
public class RegCode
{
    private const String strDocStringPrefix = "";
    private const String strManagedTypeThreadingModel = "Both";
    private const String strClassesRootRegKey = "HKEY_CLASSES_ROOT";
    private const String strMsCorEEFileName = "mscoree.dll";
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;

    public static int Run(RegAsmOptions options)
    {
        s_Options = options;

        int RetCode = SuccessReturnCode;

        try
        {
            // Load the assembly.
            Assembly asm = null;
            try
            {
                asm = Assembly.LoadFrom(s_Options.m_strAssemblyName);
            } 
            catch (BadImageFormatException)
            {
                throw new ApplicationException(Resource.FormatString("Err_InvalidAssembly", s_Options.m_strAssemblyName));
            }
            catch (FileNotFoundException)
            {
                throw new ApplicationException(Resource.FormatString("Err_InputFileNotFound", s_Options.m_strAssemblyName));
            }

            if (s_Options.m_strRegFileName != null)
            {
                // Make sure the registry file will not overwrite the input file.
                if (String.Compare(s_Options.m_strAssemblyName, s_Options.m_strRegFileName, true, CultureInfo.InvariantCulture) == 0)
                    throw new ApplicationException(Resource.FormatString("Err_RegFileWouldOverwriteInput"));

                // If /codebase is specified, then give a warning if the assembly is not strongly
                // named.
                if (s_Options.m_bSetCodeBase && asm.GetName().GetPublicKey() == null || s_Options.m_bSetCodeBase && asm.GetName().GetPublicKey().Length == 0)
                    WriteWarningMsg(Resource.FormatString("Wrn_CodeBaseWithNoStrongName"));

                // The user wants to generate a reg file.
                bool bRegFileGenerated = GenerateRegFile(s_Options.m_strRegFileName, asm);
                if (!s_Options.m_bSilentMode)
                {
                    if (bRegFileGenerated)
                    {
                        Console.WriteLine(Resource.FormatString("Msg_RegScriptGenerated", s_Options.m_strRegFileName));
                    }
                    else
                    {
                        WriteWarningMsg(Resource.FormatString("Wrn_NoRegScriptGenerated"));
                    }
                }
            }
            else if (s_Options.m_bRegister)
            {
                // If /codebase is specified, then give a warning if the assembly is not strongly
                // named.
                if (s_Options.m_bSetCodeBase && asm.GetName().GetPublicKey() == null || s_Options.m_bSetCodeBase && asm.GetName().GetPublicKey().Length == 0)
                    WriteWarningMsg(Resource.FormatString("Wrn_CodeBaseWithNoStrongName"));

                // Register the types inside the assembly.
                AssemblyRegistrationFlags flags = s_Options.m_bSetCodeBase ? AssemblyRegistrationFlags.SetCodeBase : 0;
                bool bTypesRegistered = s_RegistrationServices.RegisterAssembly(asm, flags);
                if (!s_Options.m_bSilentMode)
                {
                    if (bTypesRegistered)
                    {
                        Console.WriteLine(Resource.FormatString("Msg_TypesRegistered"));
                    }
                    else
                    {
                        WriteWarningMsg(Resource.FormatString("Wrn_NoTypesRegistered"));
                    }
                }

                // Register the typelib if the /tlb option is specified.
                if (s_Options.m_strTypeLibName != null)
                    RegisterMainTypeLib(asm);
            }
            else
            {
                // Unregister the types inside the assembly.
                bool bTypesUnregistered = s_RegistrationServices.UnregisterAssembly(asm);
                if (!s_Options.m_bSilentMode)
                {
                    if (bTypesUnregistered)
                    {
                        Console.WriteLine(Resource.FormatString("Msg_TypesUnRegistered"));
                    }
                    else
                    {
                        WriteWarningMsg(Resource.FormatString("Wrn_NoTypesUnRegistered"));
                    }
                }

                // Un-register the typelib if the /tlb option is specified.
                if (s_Options.m_strTypeLibName != null)
                {
                    // Check to see if the assembly is imported from COM.
                    if (IsAssemblyImportedFromCom(asm))
                    {
                        if (!s_Options.m_bSilentMode)
                            WriteWarningMsg(Resource.FormatString("Wrn_ComTypelibNotUnregistered"));
                    }
                    else
                    {
                        // Unregister the typelib.
                        UnRegisterMainTypeLib();
                    }
                }
            }
        }
        catch (TargetInvocationException e)
        {
            WriteErrorMsg(Resource.FormatString("Err_ErrorInUserDefFunc") + e.InnerException);
            RetCode = ErrorReturnCode;
        }
        catch (ReflectionTypeLoadException e)
        {
            int i;
            Exception[] exceptions;
            WriteErrorMsg(Resource.FormatString("Err_TypeLoadExceptions"));
            exceptions = e.LoaderExceptions;
            for (i = 0; i < exceptions.Length; i++)
            {
                try 
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayException", i, exceptions[i]));
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayNestedException", i, ex));
                }
            }
            RetCode = ErrorReturnCode;
        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            RetCode = ErrorReturnCode;
        }

        return RetCode;
    }

    internal static UCOMITypeLib DoExportAndRegister(Assembly asm, String strTypeLibName)
    {
        // Create the TypeLibConverter.
        ITypeLibConverter TLBConv = new TypeLibConverter();

        // Convert the assembly.
        ExporterCallback callback = new ExporterCallback();
        UCOMITypeLib Tlb = (UCOMITypeLib)TLBConv.ConvertAssemblyToTypeLib(asm, strTypeLibName, s_Options.m_Flags, callback);

        // Persist the typelib.
        try
        {
            UCOMICreateITypeLib CreateTlb = (UCOMICreateITypeLib)Tlb;
            CreateTlb.SaveAllChanges();
        }
        catch (Exception e)
        {
            ThrowAppException(Resource.FormatString("Err_TypelibSaveFailed"), e);
        }

        // Register the typelib.
        try
        {
            RegisterTypeLib(Tlb, strTypeLibName, Path.GetDirectoryName(strTypeLibName));
        }
        catch (Exception e)
        {
            ThrowAppException(Resource.FormatString("Err_TypelibRegisterFailed"), e);
        }

        return Tlb;
    }

    private static bool GenerateRegFile(String strRegFileName, Assembly asm)
    {
        // Retrieve the list of registrable types in the assembly.
        Type[] aTypes = s_RegistrationServices.GetRegistrableTypesInAssembly(asm);
        int NumTypes = aTypes.Length;

        // Retrieve the list of PIA attributes.
        Object[] aPIAAttrs = asm.GetCustomAttributes(typeof(PrimaryInteropAssemblyAttribute), false);
        int NumPIAAttrs = aPIAAttrs.Length;

        // If this isn't a PIA and there are no types to register then we don't need to
        // generate a reg file.
        if (NumTypes == 0 && NumPIAAttrs == 0)
            return false;

        // Create the reg file.
        Stream RegFile = File.Create(strRegFileName);

        // Write the REGEDIT4 header in the file.
        WriteUTFChars(RegFile, "REGEDIT4" + Environment.NewLine);

        // Retrieve the assembly and file values to put in the registry.
        String strAsmName = asm.FullName;
        
        // Retrieve the assembly version
        String strAsmVersion = asm.GetName().Version.ToString();

        // Retrieve the runtime version used to build the assembly.
        String strRuntimeVersion = asm.ImageRuntimeVersion;

        // Retrieve the assembly codebase.
        String strAsmCodeBase = null;
        if (s_Options.m_bSetCodeBase)
        {
            strAsmCodeBase = asm.CodeBase;
            if (strAsmCodeBase == null)
                throw new ApplicationException(Resource.FormatString("Err_NoAsmCodeBase", s_Options.m_strAssemblyName));
        }

        // Generate the reg file entries for each type in the lists of types.
        for (int cTypes = 0; cTypes < NumTypes; cTypes++)
        {
            if (aTypes[cTypes].IsValueType)
                AddValueTypeToRegFile(aTypes[cTypes], strAsmName, strAsmVersion, strAsmCodeBase, RegFile);
            else if (s_RegistrationServices.TypeRepresentsComType(aTypes[cTypes]))
                AddComImportedTypeToRegFile(aTypes[cTypes], strAsmName, strAsmVersion, strAsmCodeBase, strRuntimeVersion, RegFile);
            else
                AddManagedTypeToRegFile(aTypes[cTypes], strAsmName, strAsmVersion, strAsmCodeBase, strRuntimeVersion, RegFile);
        }

        // If this assembly has the PIA attribute, then register it as a PIA.
        for (int cPIAAttrs = 0; cPIAAttrs < NumPIAAttrs; cPIAAttrs++)
        {
            AddPrimaryInteropAssemblyToRegFile(Marshal.GetTypeLibGuidForAssembly(asm).ToString().ToUpper(CultureInfo.InvariantCulture), 
                                               strAsmName,
                                               strAsmCodeBase, 
                                               (PrimaryInteropAssemblyAttribute)aPIAAttrs[cPIAAttrs],
                                               RegFile);
        }

        // Close the reg file.
        RegFile.Close();

        // Return true to indicate a reg file was generated.
        return true;
    }

    private static void AddValueTypeToRegFile(Type type, String strAsmName, String strAsmVersion, String strAsmCodeBase, Stream regFile)
    {
        String strRecordId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper() + "}";

        // HKEY_CLASSES_ROOT\Record\<RecordId>\<Version> key
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\Record\\" + strRecordId + "\\" + strAsmVersion + "]" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
        if (strAsmCodeBase != null)
            WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
   }

    private static void AddManagedTypeToRegFile(Type type, String strAsmName, String strAsmVersion, String strAsmCodeBase, String strRuntimeVersion, Stream regFile)
    {
        //
        // Retrieve some information we need to generate the entries.
        //

        String strDocString = strDocStringPrefix + type.FullName;
        String strClsId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";
        String strProgId = s_RegistrationServices.GetProgIdForType(type);


        //
        // Create the actual entries.
        //

        if (strProgId != String.Empty)
        {
            // HKEY_CLASS_ROOT\<wzProgId> key.
            WriteUTFChars(regFile, Environment.NewLine);
            WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\" + strProgId + "]" + Environment.NewLine);
            WriteUTFChars(regFile, "@=\"" + strDocString + "\"" + Environment.NewLine);

            // HKEY_CLASS_ROOT\<wzProgId>\CLSID key.
            WriteUTFChars(regFile, Environment.NewLine);
            WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\" + strProgId + "\\CLSID]" + Environment.NewLine);
            WriteUTFChars(regFile, "@=\"" + strClsId + "\"" + Environment.NewLine);
        }

        // HKEY_CLASS_ROOT\CLSID\<CLSID> key.
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "]" + Environment.NewLine);
        WriteUTFChars(regFile, "@=\"" + strDocString + "\"" + Environment.NewLine);

        // HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32 key.
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "\\InprocServer32]" + Environment.NewLine);
        WriteUTFChars(regFile, "@=\"" + strMsCorEEFileName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"ThreadingModel\"=\"" + strManagedTypeThreadingModel + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
        if (strAsmCodeBase != null)
            WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);

        // HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32\<Version> subkey
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "\\InprocServer32" + "\\" + strAsmVersion + "]" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
        if (strAsmCodeBase != null)
            WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);

        if (strProgId != String.Empty)
        {
            // HKEY_CLASS_ROOT\CLSID\<CLSID>\ProdId key.
            WriteUTFChars(regFile, Environment.NewLine);
            WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "\\ProgId]" + Environment.NewLine);
            WriteUTFChars(regFile, "@=\"" + strProgId + "\"" + Environment.NewLine);
        }

        // HKEY_CLASS_ROOT\CLSID\<CLSID>\Implemented Categories\<Managed Category Guid> key.
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "\\Implemented Categories\\" + "{" + s_RegistrationServices.GetManagedCategoryGuid().ToString().ToUpper(CultureInfo.InvariantCulture) + "}]" + Environment.NewLine);            
     } 

    private static void AddComImportedTypeToRegFile(Type type, String strAsmName, String strAsmVersion, String strAsmCodeBase, String strRuntimeVersion, Stream regFile)
    {
        String strClsId = "{" + Marshal.GenerateGuidForType(type).ToString().ToUpper(CultureInfo.InvariantCulture) + "}";

        // HKEY_CLASS_ROOT\CLSID\<CLSID>\InprocServer32 key.
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "\\InprocServer32]" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
        if (strAsmCodeBase != null)
            WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);

        // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprovServer32\<version> key
        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\CLSID\\" + strClsId + "\\InprocServer32" + "\\" + strAsmVersion + "]" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Class\"=\"" + type.FullName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"Assembly\"=\"" + strAsmName + "\"" + Environment.NewLine);
        WriteUTFChars(regFile, "\"RuntimeVersion\"=\"" + strRuntimeVersion + "\"" + Environment.NewLine);
        if (strAsmCodeBase != null)
            WriteUTFChars(regFile, "\"CodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
   }

    private static void AddPrimaryInteropAssemblyToRegFile(String strAsmGuid, String strAsmName, String strAsmCodeBase, PrimaryInteropAssemblyAttribute attr, Stream regFile)
    {
        String strTlbId = "{" + strAsmGuid + "}";
        String strVersion = attr.MajorVersion + "." + attr.MinorVersion;

        WriteUTFChars(regFile, Environment.NewLine);
        WriteUTFChars(regFile, "[" + strClassesRootRegKey + "\\TypeLib\\" + strTlbId + "\\" + strVersion + "]" + Environment.NewLine);
        WriteUTFChars(regFile, "\"PrimaryInteropAssemblyName\"=\"" + strAsmName + "\"" + Environment.NewLine);
        if (strAsmCodeBase != null)
            WriteUTFChars(regFile, "\"PrimaryInteropAssemblyCodeBase\"=\"" + strAsmCodeBase + "\"" + Environment.NewLine);
    }

    private static void WriteUTFChars(Stream s, String value)
    {
        byte[] bytes = System.Text.Encoding.UTF8.GetBytes(value);
        s.Write(bytes, 0, bytes.Length);
    }

    private static void RegisterMainTypeLib(Assembly asm)
    {
        UCOMITypeLib Tlb = null;

        // If the assembly contains an embedded type library, then register it.
        if (s_Options.m_strAssemblyName == s_Options.m_strTypeLibName)
        {
            try
            {
                LoadTypeLibEx(s_Options.m_strTypeLibName, REGKIND.REGKIND_REGISTER, out Tlb);

                // Display the success message unless silent mode is enabled.
                if (Tlb != null && !s_Options.m_bSilentMode)
                    Console.WriteLine(Resource.FormatString("Msg_EmbeddedTypelibReg", s_Options.m_strTypeLibName));
            }
            catch (Exception)
            {
            }
        }

        if (Tlb == null)
        {
            // Export the assembly to a typelib.
            Tlb = DoExportAndRegister(asm, s_Options.m_strTypeLibName);
    
            // Display the success message unless silent mode is enabled.
            if (!s_Options.m_bSilentMode)
                Console.WriteLine(Resource.FormatString("Msg_AssemblyExportedAndReg", s_Options.m_strTypeLibName));
        }
    }

    private static void UnRegisterMainTypeLib()
    {
        UCOMITypeLib Tlb = null;
        IntPtr pAttr = (IntPtr)0;

        try
        {
            // Try and load the typelib.
            LoadTypeLibEx(s_Options.m_strTypeLibName, REGKIND.REGKIND_NONE, out Tlb);

            // Retrieve the version information from the typelib.
            Tlb.GetLibAttr(out pAttr);

            // Copy the int we got back from GetLibAttr to a TypeLibAttr struct.
            TYPELIBATTR Attr = (TYPELIBATTR)Marshal.PtrToStructure((IntPtr)pAttr, typeof(TYPELIBATTR));

            // Unregister the typelib.
            UnRegisterTypeLib(ref Attr.guid, Attr.wMajorVerNum, Attr.wMinorVerNum, Attr.lcid, Attr.syskind);
        }
        catch (COMException e)
        {
            // TYPE_E_REGISTRYACCESS errors simply mean that the typelib has already been unregistered.
            if (e.ErrorCode != unchecked((int)0x8002801C))
                ThrowAppException(Resource.FormatString("Err_UnregistrationFailed"), e);
        }
        catch (Exception e)
        {
            ThrowAppException(Resource.FormatString("Err_UnregistrationFailed"), e);
        }
        finally
        {
            // Release the typelib attributes.
            if (pAttr != (IntPtr)0)
                Tlb.ReleaseTLibAttr(pAttr);
        }

        // Display the success message unless silent mode is enabled.
        if (!s_Options.m_bSilentMode)
            Console.WriteLine(Resource.FormatString("Msg_TypelibUnregistered", s_Options.m_strTypeLibName));
    }

    private static bool IsAssemblyImportedFromCom(Assembly asm)
    {
        return asm.GetCustomAttributes(typeof(ImportedFromTypeLibAttribute), false).Length != 0;
    }

    private static void ThrowAppException(String strPrefix, Exception e)
    {
        if (strPrefix == null)
            strPrefix = "";

        if (e.Message != null)
        {
            throw new ApplicationException(strPrefix + e.Message);
        }
        else
        {
            throw new ApplicationException(strPrefix + e.GetType().ToString());
        }
    }

    private static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";        
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
        else
        {
            strErrorMsg += e.GetType().ToString();
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_RegAsmErrorPrefix", strErrorMsg));
    }

    private static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_RegAsmErrorPrefix", strErrorMsg));
    }

    private static void WriteWarningMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_RegAsmWarningPrefix", strErrorMsg));
    }

    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    private static extern IntPtr GetModuleHandle(String strLibrary);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    private static extern int GetModuleFileName(IntPtr BaseAddress, StringBuilder sbOutPath, int length);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void LoadTypeLibEx(String strTypeLibName, REGKIND regKind, out UCOMITypeLib TypeLib);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void RegisterTypeLib(UCOMITypeLib TypeLib, String szFullPath, String szHelpDirs);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void UnRegisterTypeLib(ref Guid libID, Int16 wVerMajor, Int16 wVerMinor, int lcid, SYSKIND syskind);

    internal static RegAsmOptions s_Options = null;
    internal static RegistrationServices s_RegistrationServices = new RegistrationServices();
}

[GuidAttribute("00020406-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
[ComVisible(false)]
[ComImport]
internal interface UCOMICreateITypeLib
{
    void CreateTypeInfo();       
    void SetName();       
    void SetVersion();        
    void SetGuid();
    void SetDocString();
    void SetHelpFileName();        
    void SetHelpContext();
    void SetLcid();
    void SetLibFlags();
    void SaveAllChanges();
}

internal class ExporterCallback : ITypeLibExporterNotifySink
{
    public void ReportEvent(ExporterEventKind EventKind, int EventCode, String EventMsg)
    {
		if (EventKind == ExporterEventKind.NOTIF_TYPECONVERTED)
		{
			if (RegCode.s_Options.m_bVerboseMode)
				Console.WriteLine(EventMsg);
		}
		else
			Console.WriteLine(EventMsg);
    }
    
    public Object ResolveRef(Assembly asm)
    {
        UCOMITypeLib rslt = null;

        // Retrieve the path of the assembly on disk.
        Module[] aModule = asm.GetLoadedModules();
        String asmPath = Path.GetDirectoryName(aModule[0].FullyQualifiedName);

        // If the typelib name is null then create it from the assembly name.
        String FullyQualifiedTypeLibName = Path.Combine(asmPath, asm.GetName().Name) + ".tlb";
        if (RegCode.s_Options.m_bVerboseMode)
            Console.WriteLine(Resource.FormatString("Msg_AutoExpAndRegAssembly", asm.GetName().Name, FullyQualifiedTypeLibName));
            
        // Export the typelib for the module.
        rslt = RegCode.DoExportAndRegister(asm, FullyQualifiedTypeLibName);

        return rslt;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regasm\regcode\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace RegCode {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("RegCode", 
                                          Assembly.GetAssembly(typeof(RegCode)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regkeyseperator\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "REGKEYSEPERATOR.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft (R) .NET Framework Registry Key Seperator\0"
#define VER_ORIGFILENAME_STR    "RegKeySeperator.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regsvcs\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "REGSVCS.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Services Installation Utility\0"
#define VER_ORIGFILENAME_STR    "RegSvcs.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regkeyseperator\regkeyseperator.cs ===
using System;
using System.IO;

namespace Tools.KeysSeparator
{
	/// <summary>
	/// Summary description for Class1.
	/// </summary>
	class KeysSeparator
	{
		private StreamReader inputFile = null;
		private StreamWriter verIndepFile = null;
		private StreamWriter verDepFile = null;

		private enum LineType {Empty, Value, IndepKey, DepKey, Other};

		private void OpenFiles(string fileName)
		{
			inputFile = new StreamReader(
				(System.IO.Stream)File.OpenRead(fileName));
			inputFile.BaseStream.Seek(0, SeekOrigin.Begin);

			string verIndepFileName = Path.GetFileNameWithoutExtension(fileName) + "_Shared" + Path.GetExtension(fileName);
			string verDepFileName = Path.GetFileNameWithoutExtension(fileName) + "_Version" + Path.GetExtension(fileName);

			verIndepFile = new StreamWriter(
				(System.IO.Stream)File.OpenWrite(verIndepFileName));
			verIndepFile.BaseStream.Seek(0, SeekOrigin.Begin);
			
			verDepFile = new StreamWriter(
				(System.IO.Stream)File.OpenWrite(verDepFileName));
			verDepFile.BaseStream.Seek(0, SeekOrigin.Begin);
		}

		private LineType GetLineType(string line)
		{
			if (line == string.Empty)
				return LineType.Empty;
			if (line.StartsWith("@") || line.StartsWith("\""))
				return LineType.Value;
			if (line.StartsWith("["))
				if (Char.IsNumber(line[line.LastIndexOf("\\") + 1]))
					return LineType.DepKey;
				else 
					return LineType.IndepKey;
			return LineType.Other;
		}

		private void SeparateKeys()
		{
			string curLine = null;
			bool activeFileIsVerDep = false;

			while (inputFile.Peek() > -1) 
			{
				curLine = inputFile.ReadLine();

				switch (GetLineType(curLine))
				{
					case LineType.Value:
						if (activeFileIsVerDep)
							verDepFile.WriteLine(curLine);
						else
							verIndepFile.WriteLine(curLine);
						break;

					case LineType.Empty: 
						break;

					case LineType.IndepKey:
						verIndepFile.WriteLine(string.Empty);
						verIndepFile.WriteLine(curLine);
						activeFileIsVerDep = false;
						break;

					case LineType.DepKey:
						verDepFile.WriteLine(string.Empty);
						verDepFile.WriteLine(curLine);
						activeFileIsVerDep = true;
						break;

					case LineType.Other:
						verIndepFile.WriteLine(curLine);
						verDepFile.WriteLine(curLine);
						break;
				};
			}
		}

		private void CloseFiles()
		{
			inputFile.Close();
			verIndepFile.Close();
			verDepFile.Close();
		}

		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main(string[] args)
		{
			if (args.Length == 0) 
			{
				Console.WriteLine("Please enter a file name.");
				return;
			}

			KeysSeparator ks = new KeysSeparator();
			ks.OpenFiles(args[0]);
			ks.SeparateKeys();
			ks.CloseFiles();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regsvcs\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)

fake_binplace: 
	copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
	copy $(TARGETPATH)\$(TARGETNAME:.exe=.pdb) $(TARGETCOMPLUS)


TARGET_EXTESION_ = exe
TARGET_MANAGED_PDB = $(TARGETPATH)\$(TARGETNAME:.exe=.pdb)
!INCLUDE $(NTMAKEENV)\mk_mngpdb.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secdbedit\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)
!if "$(TARGETCOMPLUS)" != ""
        copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)\dump
        copy $(TARGETPATH)\$(TARGETNAME) $(URTTARGET)\sdk\bin
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secpol\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target_sign: $(COOL_TARGET) $(TARGETPATH)\$(SIGNEDNAME).exe

$(TARGETPATH)\$(SIGNEDNAME).exe: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
    del $(TARGETPATH)\$(SIGNEDNAME).exe /q
    del $(TARGETPATH)\$(SIGNEDNAME).pdb /q
    copy $(COOL_TARGET) $(TARGETPATH)\$(SIGNEDNAME).exe
    cmd /C "if not exist $(CORBASE)\bin\publish312345.cer $(CORENV)\bin\$(TARGET_DIRECTORY)\makecert -sk publish312345  -n "CN=312345 Test Publisher, O=Microsoft" -d "312345 Test Publisher" -# 312345 -l http://www.microsoft.com -m 7 $(CORBASE)\bin\publish312345.cer"
    cmd /C "if not exist $(CORBASE)\bin\publish312345.spc $(CORENV)\bin\$(TARGET_DIRECTORY)\cert2spc $(CORBASE)\bin\publish312345.cer $(CORBASE)\bin\publish312345.spc"
    $(CORENV)\bin\$(TARGET_DIRECTORY)\signcode -spc $(CORBASE)\bin\publish312345.spc -k publish312345 -n "this is a test case" -i "www.microsoft.com" $(TARGETPATH)\$(SIGNEDNAME).exe

!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETPATH)\$(SIGNEDNAME).exe $(TARGETCOMPLUS)
	copy $(TARGETPATH)\$(SIGNEDNAME).pdb $(TARGETCOMPLUS)
!endif

cool_preprocess_target: SecPol.cs $(CORBASE)\src\inc\version\__file__.ver
        cl /EP /C $(COOL_EXTRA_PREPROCESS_FLAGS) /DCOOL_INCLUDE SecPol.cool > $(O)\SecPol.cs
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secutil\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
	copy $(TARGETPATH)\$(TARGETNAME:.exe=.pdb) $(TARGETCOMPLUS)
!endif

cool_compile_resource: SecUtil.cs resources.txt
        internalresgen resources.txt secutil.resources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secpol\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "SECPOL.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft COM Runtime Security Policy Manager\0"
#define VER_ORIGFILENAME_STR    "secpol.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\regsvcs\regsvcs.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

// #define _NO_APPDOMAIN

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Resources;
using System.Collections;
using System.Runtime.Remoting;
using System.EnterpriseServices;
using System.Globalization;

internal class UsageException : ApplicationException
{
    private int _returnCode;
    
    private static String Usage()
    {
        return(Resource.FormatString("RegSvcs_Usage"));
    }

    public UsageException(int code)
      : base(Usage())
    {
        
    }

    public UsageException(int code, String msg)
      : base(msg + "\n" + Usage())
    {
        _returnCode = code;
    }

    public int ReturnCode { get { return(_returnCode); } }
}

[ComVisible(false)]
public class RegSvcs
{
    private const int MAX_PATH = 260;

    private static RegistrationConfig   regConfig;
    private static bool                 logoOutput;
    private static bool                 successOutput;
    private static bool                 uninstallApplication;
    private static bool                 bootstrapInstall;
    private static bool                 bootstrapUninstall;

    [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Auto)]
    private static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);

    static RegSvcs()
    {
        regConfig = new RegistrationConfig();
    }

    private static RegistrationHelper GetRegistrationHelper(bool bCreateAppDomain, out AppDomain domain)
    {
        RegistrationHelper reg = null;

        domain = null;

        if (!bCreateAppDomain)
        	reg = new RegistrationHelper();
        
        else
        {
        	String dir = Path.GetDirectoryName(regConfig.AssemblyFile);
	        
            AppDomainSetup domainOptions = new AppDomainSetup();
            
            domainOptions.ApplicationBase = dir;
            domain = AppDomain.CreateDomain("RegSvcs",
                                            null, 
                                            domainOptions);
            if(domain != null)
            {
                
                AssemblyName n = typeof(RegistrationHelper).Assembly.GetName();
                ObjectHandle h = domain.CreateInstance(n.FullName, typeof(RegistrationHelper).FullName);
                if(h != null)
                {
                    reg = (RegistrationHelper) h.Unwrap();
                }
            }        
        }

        return(reg);
    }

    private static void Bootstrap()
    {
        Type rtx = typeof(RegistrationHelperTx);
        
        if(bootstrapInstall)
        {
            MethodInfo info = rtx.GetMethod("InstallUtilityApplication", BindingFlags.Static|BindingFlags.NonPublic|BindingFlags.Public|BindingFlags.DeclaredOnly);
            info.Invoke(null, new Object[] { null });
        }
        else if(bootstrapUninstall)
        {
            MethodInfo info = rtx.GetMethod("UninstallUtilityApplication", BindingFlags.Static|BindingFlags.NonPublic|BindingFlags.Public|BindingFlags.DeclaredOnly);
            info.Invoke(null, new Object[] { null });
        }
    }

	// returns null if no file is found given this assembly name
    private static String FindAssembly(String name)
    {
        StringBuilder sb = new StringBuilder(MAX_PATH + 1);
        
        if(SearchPath(null, name, null, sb.Capacity+1, sb, null) == 0)        
        {
        	return null;
        }

        return(sb.ToString());
    }
    
    	// returns true if assembly exists in the GAC, otherwise false
    private static bool IsAssemblyInGAC(String name)
    {
	try {
		Assembly a = Assembly.Load(name);
	}
	catch {
		return false;
	}                	
	return true;
    }

    [MTAThread()]
    public static int Main(String[] args)
    {
        try
        {
            return(UnsafeMain(args));
        }
        catch(Exception)
        {
            // This means that one of our error handlers threw an exception.  We
            // have to return a failure, but we probably can't explain why this
            // happened, so...
            return(1);
        }
    }

    public static int UnsafeMain(String[] args)
    {
        AppDomain appDomain = null;

        try {
        	
            ParseArguments(args);
            
            if(bootstrapInstall || bootstrapUninstall)
            {
                Bootstrap();
            }
            else
            {
                if(logoOutput)
                {
                    PrintLogo();
                }
                if(regConfig.AssemblyFile != null)
                {
                    RegistrationHelper reg;            	
                    
                    String assemblyFilename = FindAssembly(regConfig.AssemblyFile);
                    
                    if (assemblyFilename != null)		// we found the assembly file on disk
                    {
                        regConfig.AssemblyFile = assemblyFilename;	// store the full filename, its used by GetRegistrationHelper
                        reg = GetRegistrationHelper(true, out appDomain);
                    }
                    else					// try looking for the assembly in the GAC
                    {
                        if (IsAssemblyInGAC(regConfig.AssemblyFile))
                            reg = GetRegistrationHelper(false, out appDomain);
                        else
                            throw new RegistrationException(Resource.FormatString("RegSvcs_AssemblyNotFound", regConfig.AssemblyFile));
                    }
                    
                    if(uninstallApplication)
                    {
                        reg.UninstallAssemblyFromConfig(ref regConfig);
                        if(successOutput)
                        {                                      	
                        	Console.WriteLine(Resource.FormatString("RegSvcs_UninstallSuccess",
                                                                    regConfig.AssemblyFile));
                        }
                    }
                    else
                    {                        
                        reg.InstallAssemblyFromConfig(ref regConfig);
                        if(successOutput)
                        {
                            if (null != regConfig.Partition && null != regConfig.Application)
                            {
                                String[] param = new String[4];
                                param[0] = regConfig.AssemblyFile;
                                param[1] = regConfig.Application;
                                param[2] = regConfig.Partition;
                                param[3] = regConfig.TypeLibrary;
                                
                                Console.WriteLine(Resource.FormatString("RegSvcs_InstallSuccess2", param));
                            }
                            else if (null != regConfig.Application)
                                Console.WriteLine(Resource.FormatString("RegSvcs_InstallSuccess",
                                                                        regConfig.AssemblyFile,
                                                                        regConfig.Application,
                                                                        regConfig.TypeLibrary));
                            else
                                Console.WriteLine(Resource.FormatString("RegSvcs_NoServicedComponents"));
                        }
                    }
                }
            }
        }
        catch(UsageException e)
        {
            // We still need to print the logo if we got some bad arguments.
            if(logoOutput) 
            {
                PrintLogo();
            }
            Console.WriteLine(e.Message);
            return(e.ReturnCode);
        }
        catch(RegistrationException e)
        {
            String message = null;
            if(uninstallApplication) message = Resource.FormatString("RegSvcs_UninstallError");
            else                     message = Resource.FormatString("RegSvcs_InstallError");

            DumpExceptions(message, e, false);
            if (e.InnerException!=null)
            {
            	if (e.InnerException is COMException)
            	{
            		COMException ce = (COMException) e.InnerException;
            		if (ce.ErrorCode!=0)
            			return (ce.ErrorCode);
            		else
            			return 1;
            	}
            }
            else
            if (e.ErrorInfo != null)	// otherwise, take the first non-zero errorcode
            {
            	foreach(RegistrationErrorInfo rei in e.ErrorInfo)
            	{
            		if (rei.ErrorCode!=0)
            			return (rei.ErrorCode);
            	}
            }
            
			return (1);	// otherwise, be sure to just return a non-zero
        }
        catch(COMException e)
        {
            // This should in theory never happen, because we catch all COMExceptions,
            // in the hopes that we can gather more information about them.
            DumpExceptions(Resource.FormatString("RegSvcs_CatalogError"), e, false);
            if (e.ErrorCode!=0)
	            return(e.ErrorCode);
	        else
	        	return (1);
        }
        catch(Exception e)
        {
            // This happens if a call such as RegisterAssembly fails.
            // The system will dump these exceptions back to us, and we
            // must filter them.
            DumpExceptions(Resource.FormatString("RegSvcs_UnknownError"), e, true);
            return (1);
        }
        finally
        {
            if (appDomain != null)
                AppDomain.Unload(appDomain);
        }

        return(0);
    }

    private static void DumpExceptions(String msg, Exception e, bool ename)
    {
        Console.WriteLine("\n" + msg);
        for(int i = 1; e != null; i++, e = e.InnerException)
        {
            if(ename || e.Message == null || e.Message.Length == 0) {
                Console.WriteLine("" + i + ": " + e.GetType().FullName + " - " + e.Message);
            }
            else {
                Console.WriteLine("" + i + ": " + e.Message);
            }
            // If we have ErrorInfo (for per-component errors, dump those).
            // The dump format is one of:
            //     Name: ErrorString
            //     Name.MinorRef: ErrorString
            // depending on whether MinorRef == <invalid> or not.
            // We don't display MajorRef, because usually it is identical to 
            // Name. (or a Guid instead of a friendly name).
            if(e is RegistrationException) 
            {
                RegistrationErrorInfo[] info = ((RegistrationException)e).ErrorInfo;
                if(info != null) 
                {
                    foreach(RegistrationErrorInfo j in info)
                    {
                        if(j.MinorRef.ToLower(CultureInfo.InvariantCulture) != "<invalid>") 
                        {
                            Console.WriteLine("    " + j.Name + "." + j.MinorRef + ": " + j.ErrorString);
                        }
                        else 
                        {
                            Console.WriteLine("    " + j.Name + ": " + j.ErrorString);
                        }
                    }
                }
            }
        }
    }

    private static void PrintLogo()
    {
        Console.WriteLine(Resource.FormatString("RegSvcs_CopyrightMsg", Util.Version.VersionString));
    }

    private static bool IsArgument(String arg, String check)
    {
        String lower = arg.ToLower(CultureInfo.InvariantCulture);
        return("/" + check == lower || "-" + check == lower);
    }


    private static bool IsPrefixArgument(String arg, String check, ref String prefix)
    {
        String lower = arg.ToLower(CultureInfo.InvariantCulture);
        prefix = null;
        
        if(arg.StartsWith("/" + check + ":")
           || arg.StartsWith("-" + check + ":"))
        {
            if(arg.Length > check.Length+2)
            {
                // We've got a non-null value.  Read prefix:
                prefix = arg.Substring(check.Length+2);
            }
            return(true);
        }

        return(IsArgument(arg, check));
    }

    private static void ParseArguments(String[] args)
    {
        regConfig.InstallationFlags = InstallationFlags.FindOrCreateTargetApplication|InstallationFlags.ReconfigureExistingApplication|InstallationFlags.ReportWarningsToConsole;		
        logoOutput = true;
        successOutput = true;
        uninstallApplication = false;

        if(args.Length < 1)
        {
            throw new UsageException(0);
        }
        // Loop through and process arguments:
        int i = 0;
        for(i = 0; i < args.Length; i++)
        {
            String prefix = null;

            if(IsArgument(args[i], "?") || IsArgument(args[i], "help"))
            {
                throw new UsageException(0);
            }
            else if(IsArgument(args[i], "c"))
            {
                regConfig.InstallationFlags |= InstallationFlags.CreateTargetApplication;
                regConfig.InstallationFlags &= ~InstallationFlags.FindOrCreateTargetApplication;
            }
            else if(IsArgument(args[i], "fc"))
            {
                regConfig.InstallationFlags |= InstallationFlags.FindOrCreateTargetApplication;
            }
            else if(IsArgument(args[i], "exapp"))
            {
                regConfig.InstallationFlags &= ~(InstallationFlags.FindOrCreateTargetApplication|InstallationFlags.CreateTargetApplication);
            }
            else if(IsArgument(args[i], "extlb"))
            {
                regConfig.InstallationFlags |= InstallationFlags.ExpectExistingTypeLib;
            }
            else if(IsPrefixArgument(args[i], "tlb", ref prefix))
            {
                regConfig.TypeLibrary = prefix;
            }
            else if(IsArgument(args[i], "reconfig"))
            {
                regConfig.InstallationFlags |= InstallationFlags.ReconfigureExistingApplication;
            }
            else if(IsArgument(args[i], "noreconfig"))
            {
                regConfig.InstallationFlags &= ~InstallationFlags.ReconfigureExistingApplication;
            }
            else if(IsArgument(args[i], "nologo"))
            {
                logoOutput = false;
            }
            else if(IsArgument(args[i], "quiet"))
            {
                regConfig.InstallationFlags &= ~InstallationFlags.ReportWarningsToConsole;
                logoOutput = false;
                successOutput = false;
            }
            else if(IsArgument(args[i], "u"))
            {
                uninstallApplication = true;
            }
            else if(IsArgument(args[i], "componly"))
            {
                regConfig.InstallationFlags |= InstallationFlags.ConfigureComponentsOnly;
            }
            else if(IsArgument(args[i], "bootstrapi"))
            {
                bootstrapInstall = true;
            }
            else if(IsArgument(args[i], "bootstrapu"))
            {
                bootstrapUninstall = true;
            }
            else if(IsPrefixArgument(args[i], "appname", ref prefix))
            {
                regConfig.Application = prefix;
            }
            else if(IsPrefixArgument(args[i], "parname", ref prefix))
            {
                regConfig.Partition = prefix;
            }
            else if(IsPrefixArgument(args[i], "appdir", ref prefix))
            {
                regConfig.ApplicationRootDirectory = prefix;
            }
            else if(args[i].StartsWith("/") || args[i].StartsWith("-"))
            {
                // Invalid option:
                throw new UsageException(1, Resource.FormatString("RegSvcs_InvalidOption", args[i]));
            }
            else break;
        }
        if(i > args.Length)
        {
            throw new UsageException(1);
        }

        // i should be 1, 2, or 3 from the end of the list of options.  If 1, we have only the
        // assembly name.
        // if 2, we have application assembly.  If 3, we have application assembly typelib.
        int remainder = args.Length - i;

        // no validation if we're doing bootstrap
        if(!bootstrapInstall && !bootstrapUninstall)
        {
            if(remainder == 0)
            {
                throw new UsageException(1, Resource.FormatString("RegSvcs_NotEnoughArgs"));
            }
            else if(remainder == 1)
            {
                regConfig.AssemblyFile = args[i];
            }
            else if(remainder == 2)
            {
                regConfig.AssemblyFile = args[i];
                regConfig.Application = args[i+1];
                regConfig.TypeLibrary = null;
            }
            else if(remainder == 3)
            {
                regConfig.AssemblyFile = args[i];
                regConfig.Application = args[i+1];
                regConfig.TypeLibrary = args[i+2];
            }
            else
            {
                throw new UsageException(1, Resource.FormatString("RegSvcs_ToManyArgs"));
            }
        }        
    }
}

// A Resource utility (copied from System.EnterpriseServices (Utility.cool))
internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("System.EnterpriseServices", 
                                          Assembly.GetAssembly(typeof(System.EnterpriseServices.RegistrationHelper)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        // Console.WriteLine("Looking up string: " + key);
        String s = _resmgr.GetString(key, null);
        // Console.WriteLine("Got back string: " + s);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secutil\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "SECEDIT.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Security Utility\0"
#define VER_ORIGFILENAME_STR    "secedit.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsuds\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

SoapSuds.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt $(O)\SoapSuds.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsuds\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace SoapSuds {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("SoapSuds", 
                                          Assembly.GetAssembly(typeof(SoapSuds)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secutil\secutil.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  secutil.cool
//
//  secutil is a command-line utility for obtaining some handy security info.
//

using System;
using Assembly = System.Reflection.Assembly;
using AssemblyName = System.Reflection.AssemblyName;
using System.Collections;
using System.IO;
using System.Security.Policy;
using System.Security.Util;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Security.Permissions;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using Microsoft.Win32;
using System.Runtime.InteropServices;
using System.Resources;
using System.Threading;
using System.Globalization;

delegate void OptionHandler( String[] args, int index, out int numArgsUsed );


internal class OptionTableEntry
{
    public OptionTableEntry( String option, OptionHandler handler, String sameAs )
    {
        this.option = option;
        this.handler = handler;
        this.sameAs = sameAs;
        this.display = true;
    }
   
    public OptionTableEntry( String option, OptionHandler handler, String sameAs, bool display )
    {
        this.option = option;
        this.handler = handler;
        this.sameAs = sameAs;
        this.display = display;
    }
        
    internal String option;
    internal OptionHandler handler;
    internal String sameAs;
    internal bool display;
}

public class secutil
{
    private static bool m_hexFormat = false;
    private static bool m_vbMode = false;

    private static ResourceManager manager = new ResourceManager( "secutil", Assembly.GetExecutingAssembly() );

    // The table of options that are recognized.
    // Note: the order in this table is also the order in which they are displayed
    // on the help screen.
    private static OptionTableEntry[] optionTable =
        { new OptionTableEntry( manager.GetString( "OptionTable_StrongName" ), new OptionHandler( StrongNameHandler ), null ),
          new OptionTableEntry( manager.GetString( "OptionTable_StrongNameAbbr" ), new OptionHandler( StrongNameHandler ), manager.GetString( "OptionTable_StrongName" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_X509Certificate" ), new OptionHandler( X509CertificateHandler ), null ),
          new OptionTableEntry( manager.GetString( "OptionTable_X509CertificateAbbr" ), new OptionHandler( X509CertificateHandler ), manager.GetString( "OptionTable_X509Certificate" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_Hex" ), new OptionHandler( HexHandler ), null ),
          new OptionTableEntry( manager.GetString( "OptionTable_Array" ), new OptionHandler( ArrayHandler ), null ),
          new OptionTableEntry( manager.GetString( "OptionTable_ArrayAbbr" ), new OptionHandler( ArrayHandler ), manager.GetString( "OptionTable_Array" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_VBMode" ), new OptionHandler( VBModeHandler ), null),
          new OptionTableEntry( manager.GetString( "OptionTable_VBModeAbbr" ), new OptionHandler( VBModeHandler ), manager.GetString( "OptionTable_VBMode" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_CMode" ), new OptionHandler( CModeHandler ), null),
          new OptionTableEntry( manager.GetString( "OptionTable_CModeAbbr" ), new OptionHandler( CModeHandler ), manager.GetString( "OptionTable_CMode" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_Help" ), new OptionHandler( HelpHandler ), null ),
          new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr1" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr2" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ) ),
          new OptionTableEntry( manager.GetString( "OptionTable_HelpAbbr3" ), new OptionHandler( HelpHandler ), manager.GetString( "OptionTable_Help" ) )          
        };
        
    static String GenerateHeader()
    {
        StringBuilder sb = new StringBuilder();
        sb.Append( manager.GetString( "Copyright_Line1" ) + " " + Util.Version.VersionString );
        sb.Append( Environment.NewLine + manager.GetString( "Copyright_Line2" ) + Environment.NewLine );
        return sb.ToString();
    }        
    
    public static void Main( String[] args )
    {
        Console.WriteLine( GenerateHeader() );

        if (args.Length == 0)
        {
            try
            {
                Error( null, manager.GetString( "Error_NotEnoughArgs" ), -1 );
            }
            catch (ExitException)
            {
            }
        }
        else
        {
            Run( args );
        }

    }
    
    static void Run( String[] args )
    {
        int numArgs = args.Length;
        int currentIndex = 0;
        int numArgsUsed;
        
        while (currentIndex < numArgs)
        {
            bool foundOption = false;
        
            for (int index = 0; index < optionTable.Length; ++index)
            {
                if (args[currentIndex][0] == '/')
                {
                    args[currentIndex] = '-' + args[currentIndex].Substring( 1, args[currentIndex].Length - 1 );
                }

                if (optionTable[index].option.Equals( args[currentIndex] ))
                {
                    try
                    {
                        optionTable[index].handler(args, currentIndex, out numArgsUsed );
                    }
                    catch (Exception e)
                    {
                        if (!(e is ExitException))
                            Help( null, String.Format( manager.GetString( "Error_RuntimeError" ), e.ToString() ) );
                        return;
                    }
                    
                    foundOption = true;
                    currentIndex += numArgsUsed;
                    break;
                }
            }
            if (!foundOption)
            {
                try
                {
                    Error( null, String.Format( manager.GetString( "Error_InvalidOption" ), args[currentIndex] ), -1 );
                }
                catch (Exception e)
                {
                    if (!(e is ExitException))
                    {
                        String message = e.Message;

                        if (message == null || message.Equals( "" ))
                        {
                            message = e.GetType().AssemblyQualifiedName;
                        }

                        Help( null, String.Format( manager.GetString( "Error_UnhandledError" ), message ) );
                    }
                    return;
                }
            }
        }
        Console.WriteLine( manager.GetString( "Dialog_Success" ) );
    }
    
    static void Error( String which, String message, int errorCode )
    {
        Help( which, String.Format( manager.GetString( "Error_Arg" ), message ) );
        // HACK: throw an exception here instead of exiting since we can't always
        // call Runtime.Exit().
        throw new ExitException();        
    }
    
    static void Help( String whichOption, String message )
    {
        Console.WriteLine( message + Environment.NewLine );
        
        Console.WriteLine( manager.GetString( "Usage" ) + Environment.NewLine );
        
        String[] helpArgs = new String[1];
        helpArgs[0] = "__internal_usage__";
        int numArgs;
        
        for (int i = 0; i < optionTable.Length; ++i)
        {
            // Look for all the options that aren't the same as something as and that we have requested.
            if (optionTable[i].display && optionTable[i].sameAs == null && (whichOption == null || String.Compare( whichOption, optionTable[i].option, true, CultureInfo.InvariantCulture ) == 0))
            {
                // For each option we find, print out all like options first.
                for (int j = 0; j < optionTable.Length; ++j)
                {
                    if (optionTable[j].sameAs != null && String.Compare( optionTable[i].option, optionTable[j].sameAs, true, CultureInfo.InvariantCulture ) == 0)
                    {
                        StringBuilder sb = new StringBuilder();
                        sb.Append( manager.GetString( "Usage_Name" ) );
                        sb.Append( " " );
                        sb.Append( optionTable[j].option );
                        Console.WriteLine( sb.ToString() );
                    }
                }
                        
                optionTable[i].handler(helpArgs, 0, out numArgs);
                Console.WriteLine( "" );
            }
        }
    }
    
    static private char[]  hexValues = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
        
    public  static String EncodeHexString(byte[] sArray) 
    {
        String result = null;
    
        if(sArray != null) {
            char[] hexOrder = new char[sArray.Length * 2];
            
            int digit;
            for(int i = 0, j = 0; i < sArray.Length; i++) {
                digit = (int)((sArray[i] & 0xf0) >> 4);
                hexOrder[j++] = hexValues[digit];
                digit = (int)(sArray[i] & 0x0f);
                hexOrder[j++] = hexValues[digit];
            }
            result = new String(hexOrder);
        }
        return result;
    }    
    
    private static int ConvertHexDigit(Char val) {
        int retval;
        if (val <= '9')
            retval = (val - '0');
        else if (val >= 'a')
            retval = ((val - 'a') + 10);
        else
            retval = ((val - 'A') + 10);
        return retval;
                
    }

        
    public static byte[] DecodeHexString(String hexString)
    {
        if (hexString == null)
            throw new ArgumentNullException( "hexString" );
                
        bool spaceSkippingMode = false;    
                
        int i = 0;
        int length = hexString.Length;
        
        if (hexString.StartsWith( "0x" ))
        {
            length = hexString.Length - 2;
            i = 2;
        }
        
        // Hex strings must always have 2N or (3N - 1) entries.
        
        if (length % 2 != 0 && length % 3 != 2)
        {
            throw new ArgumentException( manager.GetString( "Error_ImproperlyFormattedString" ) );
        }                
            
        byte[] sArray;
            
        if (length >=3 && hexString[i + 2] == ' ')
        {
            spaceSkippingMode = true;
                
            // Each hex digit will take three spaces, except the first (hence the plus 1).
            sArray = new byte[length / 3 + 1];
        }
        else
        {
            // Each hex digit will take two spaces
            sArray = new byte[length / 2];
        }
            
        int digit;
        int rawdigit;
        for (int j = 0; i < hexString.Length; i += 2, j++) {
            rawdigit = ConvertHexDigit(hexString[i]);
            digit = ConvertHexDigit(hexString[i+1]);
            sArray[j] = (byte) (digit | (rawdigit << 4));
            if (spaceSkippingMode)
                i++;
        }
        return(sArray);    
    }
        
    
    static Assembly LoadAssembly( String fileName, String option )
    {
        AppDomain domain = AppDomain.CreateDomain( "Secutil Domain",
                                                   null,
                                                   Environment.CurrentDirectory,
                                                   Thread.GetDomain().BaseDirectory,
                                                   false );

        if (domain == null)
            Error( option, manager.GetString( "Error_UnableToLoadAssembly" ), -1 );
        
        Assembly asm = null;
        
        try
        {
            asm = domain.Load( fileName );
        }
        catch (Exception)
        {
        }
        
        if (asm != null)
            return asm;
            
        try
        {
            asm = Assembly.LoadFrom( fileName );
        }
        catch (Exception)
        {
        }

        try
        {
            asm = Assembly.LoadFrom( Environment.CurrentDirectory + "\\" + fileName );
        }
        catch (Exception)
        {
        }

        
        if (asm != null)
            return asm;
            
        Error( option, String.Format( manager.GetString( "Error_UnableToLoadAssemblyArg" ), fileName ), -1 );
        
        /* not reached */

        return null;
    }            
        
    private static void DisplayByteArray( byte[] array )
    {
        if (m_hexFormat)
        {
            StringBuilder sb = new StringBuilder();
            
            sb.Append( "0x" );
            sb.Append( EncodeHexString( array ) );
            
            Console.WriteLine( sb.ToString() );
        }
        else
        {
            StringBuilder sb = new StringBuilder();
            
            if (m_vbMode)
                sb.Append( "(" );
            else
                sb.Append( "{" );
            
            for (int i = 0; i < array.Length - 1; ++i)
            {
                sb.Append( " " );
                sb.Append( (int)array[i] );
                sb.Append( "," );
            }
            
            sb.Append( " " );
            sb.Append( (int)array[array.Length-1] );
            
            if (m_vbMode)
                sb.Append( " )" );
            else
                sb.Append( " }" );
            
            Console.WriteLine( sb.ToString() );
        }
    }

    static void HelpHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_Help" ) );
            return;
        }
        
        Help( null, manager.GetString( "Dialog_HelpScreenRequested" ) );
    }        
     
                
    static void StrongNameHandler( String[] args, int index, out int numArgsUsed )
    {

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_StrongName" ) );
            numArgsUsed = 1;
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( manager.GetString( "OptionTable_StrongName" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
        }
        
        Assembly asm = LoadAssembly( args[index+1], manager.GetString( "OptionTable_StrongName" ) );
        Evidence evi = asm.Evidence;
        
        if (evi == null)
        {
            Error( manager.GetString( "OptionTable_StrongName" ), manager.GetString( "Error_StrongName_NotSigned" ), -1 );
        }
        
        IEnumerator enumerator = evi.GetHostEnumerator();

        StrongName sn = null;

        while (enumerator.MoveNext())
        {
            if (enumerator.Current is StrongName)
            {
                sn = (StrongName)enumerator.Current;
                break;
            }
        }
        
        if (sn == null)
        {
            Error( manager.GetString( "OptionTable_StrongName" ), manager.GetString( "Error_StrongName_NotSigned" ), -1 );
        }
        
        Console.WriteLine( manager.GetString( "Dialog_PublicKey" ) );
        DisplayByteArray( DecodeHexString( sn.PublicKey.ToString() ) );
        
        Console.WriteLine( manager.GetString( "Dialog_Name" )  );
        Console.WriteLine( sn.Name );
        
        Console.WriteLine( manager.GetString( "Dialog_Version" )  );
        Console.WriteLine( sn.Version );
    }
    
    static void X509CertificateHandler( String[] args, int index, out int numArgsUsed )
    {

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_X509Certificate" ) );
            numArgsUsed = 1;
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( manager.GetString( "OptionTable_X509Certificate" ), manager.GetString( "Error_NotEnoughArgs" ), -1 );
        }
        
        Assembly asm = LoadAssembly( args[index+1], manager.GetString( "OptionTable_X509Certificate" ) );
        Evidence evi = asm.Evidence;
        
        if (evi == null)
        {
            Error( manager.GetString( "OptionTable_X509Certificate" ), manager.GetString( "Error_X509Certificate_NotSigned" ), -1 );
        }
        
        IEnumerator enumerator = evi.GetHostEnumerator();
       
        Publisher pub = null;

        while (enumerator.MoveNext())
        {
            if (enumerator.Current is Publisher)
            {
                pub = (Publisher)enumerator.Current;
                break;
            }
        }
        
        if (pub == null)
        {
            Error( manager.GetString( "OptionTable_X509Certificate" ), manager.GetString( "Error_X509Certificate_NotSigned" ), -1 );
        }
        
        Console.WriteLine( manager.GetString( "Dialog_X509Certificate" ) );
        DisplayByteArray( pub.Certificate.GetRawCertData() );
    }
    
    static void HexHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_Hex" ) );
            return;
        }
        
        m_hexFormat = true;
    }
    
    static void ArrayHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_Array" ) );
            return;
        }
        
        m_hexFormat = false;
    }    
    
    static void VBModeHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_VBMode" ) );
            return;
        }
        
        m_vbMode = true;
    } 
    
    static void CModeHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( manager.GetString( "Help_CMode" ) );
            return;
        }
        
        m_vbMode = false;
    } 
           
    
}    

internal class ExitException : Exception
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsuds\__strongname.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
[assembly: System.Reflection.AssemblyDelaySign(true), System.Reflection.AssemblyKeyFile("FinalPublicKey.snk")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsuds\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "SOAPSUDS.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft SoapSuds Utility\0"
#define VER_ORIGFILENAME_STR    "SoapSuds.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secpol\secpol.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  secpol.cool
//
//  SecPol is a command-line utility for manipulating the policy for a machine.
//

using System;
using Assembly = System.Reflection.Assembly;
using AssemblyName = System.Reflection.AssemblyName;
using System.Collections;
using System.IO;
using System.Security.Policy;
using System.Security.Util;
using System.Security;
using System.Security.Cryptography;
using System.Text;
using System.Reflection;
using System.Configuration.Assemblies;
using System.Security.Permissions;
using System.Security.Cryptography.X509Certificates;
using System.Security.Principal;
using Microsoft.Win32;
using System.Runtime.InteropServices;

delegate void OptionHandler( String[] args, int index, out int numArgsUsed );
delegate IMembershipCondition MembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset );

enum LevelType
{
    None = 0,
    Machine = 1,
    UserDefault = 2,
    UserCustom = 3,
    All = 4,
}

public class secpol
{
    // Indicator of the last specified level.
    private static LevelType m_levelType = LevelType.None;
    private static PolicyLevel m_level;
    
    // The space used to indent the code groups
    private const String m_indent = "   ";
    
    // The allowed separators within labels (right now only 1.2.3 is legal)
    private const String m_labelSeparators = ".";
    
    private const String m_policyKey = "Software\\Microsoft\\.NETFramework\\Security\\Policy\\1.002";
        
    private static bool m_force = false;
    
    private static bool m_success = true;
        
    // The table of options that are recognized.
    // Note: the order in this table is also the order in which they are displayed
    // on the help screen.
    private static OptionTableEntry[] optionTable =
        { new OptionTableEntry( "-machine", new OptionHandler( MachineHandler ), null ),
          new OptionTableEntry( "-m", new OptionHandler( MachineHandler ), "-machine" ),
          new OptionTableEntry( "-user", new OptionHandler( UserHandler ), null ),
          new OptionTableEntry( "-u", new OptionHandler( UserHandler ), "-user" ),
          new OptionTableEntry( "-all", new OptionHandler( AllHandler ), null ),
          new OptionTableEntry( "-a", new OptionHandler( AllHandler ), "-all" ),
          new OptionTableEntry( "-list", new OptionHandler( ListHandler ), null ),
          new OptionTableEntry( "-l", new OptionHandler( ListHandler ), "-list" ),
          new OptionTableEntry( "-listgroups", new OptionHandler( ListGroupHandler ), null ),
          new OptionTableEntry( "-lg", new OptionHandler( ListGroupHandler ), "-listgroups" ),
          new OptionTableEntry( "-listpset", new OptionHandler( ListPermHandler ), null ),
          new OptionTableEntry( "-lp", new OptionHandler( ListPermHandler ), "-listpset" ),
          new OptionTableEntry( "-addpset", new OptionHandler( AddPermHandler ), null ),
          new OptionTableEntry( "-ap", new OptionHandler( AddPermHandler ), "-addpset" ),
          new OptionTableEntry( "-chgpset", new OptionHandler( ChgPermHandler ), null ),
          new OptionTableEntry( "-cp", new OptionHandler( ChgPermHandler ), "-chgpset" ),
          new OptionTableEntry( "-rempset", new OptionHandler( RemPermHandler ), null ),
          new OptionTableEntry( "-rp", new OptionHandler( RemPermHandler ), "-rempset" ),
          new OptionTableEntry( "-remgroup", new OptionHandler( RemGroupHandler ), null ),
          new OptionTableEntry( "-rg", new OptionHandler( RemGroupHandler ), "-remgroup" ),
          new OptionTableEntry( "-chggroup", new OptionHandler( ChgGroupHandler ), null ),
          new OptionTableEntry( "-cg", new OptionHandler( ChgGroupHandler ), "-chggroup" ),
          new OptionTableEntry( "-addgroup", new OptionHandler( AddGroupHandler ), null ),
          new OptionTableEntry( "-ag", new OptionHandler( AddGroupHandler ), "-addgroup" ),
          new OptionTableEntry( "-resolvegroup", new OptionHandler( ResolveGroupHandler ), null ),
          new OptionTableEntry( "-rsg", new OptionHandler( ResolveGroupHandler ), "-resolvegroup" ),
          new OptionTableEntry( "-resolveperm", new OptionHandler( ResolvePermHandler ), null ),
          new OptionTableEntry( "-rsp", new OptionHandler( ResolvePermHandler ), "-resolveperm" ),
          new OptionTableEntry( "-security", new OptionHandler( SecurityHandler ), null ),
          new OptionTableEntry( "-s", new OptionHandler( SecurityHandler ), "-security" ),
          new OptionTableEntry( "-execution", new OptionHandler( ExecutionHandler ), null ),
          new OptionTableEntry( "-e", new OptionHandler( ExecutionHandler ), "-execution" ),
          new OptionTableEntry( "-polchgprompt", new OptionHandler( PolicyChangeHandler ), null ),
          new OptionTableEntry( "-pp", new OptionHandler( PolicyChangeHandler ), "-polchgprompt" ),
          new OptionTableEntry( "-recover", new OptionHandler( RecoverHandler ), null ),
          new OptionTableEntry( "-r", new OptionHandler( RecoverHandler ), "-recover" ),
          new OptionTableEntry( "-reset", new OptionHandler( ResetHandler ), null ),
          new OptionTableEntry( "-rs", new OptionHandler( ResetHandler ), "-reset" ), 
          new OptionTableEntry( "-force", new OptionHandler( ForceHandler ), null ),
          new OptionTableEntry( "-f", new OptionHandler( ForceHandler ), "-force" ),
          new OptionTableEntry( "-help", new OptionHandler( HelpHandler ), null ),
          new OptionTableEntry( "-h", new OptionHandler( HelpHandler ), "-help" )
        };
        
    private static MembershipConditionTableEntry[] mshipTable =
        { new MembershipConditionTableEntry( "-all", new MembershipConditionHandler( AllMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-appdir", new MembershipConditionHandler( ApplicationDirectoryMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-hash", new MembershipConditionHandler( HashMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-pub", new MembershipConditionHandler( PublisherMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-site", new MembershipConditionHandler( SiteMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-skipverif", new MembershipConditionHandler( SkipVerificationMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-strong", new MembershipConditionHandler( StrongNameMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-url", new MembershipConditionHandler( URLMembershipConditionHandler ) ),
          new MembershipConditionTableEntry( "-zone", new MembershipConditionHandler( ZoneMembershipConditionHandler ) ),
        };
        
    private static PolicyStatementAttributeTableEntry[] psattrTable =
        { new PolicyStatementAttributeTableEntry( "-exclusive", PolicyStatementAttribute.Exclusive, "Exclusive" ),
          new PolicyStatementAttributeTableEntry( "-levelfinal", PolicyStatementAttribute.LevelFinal, "Level final" ),
        };
        
    // Map between zone number and zone name.    
    private static String[] s_names =
        {"MyComputer", "Intranet", "Trusted", "Internet", "Untrusted"};
    
    static String GenerateHeader()
    {
        StringBuilder sb = new StringBuilder();
        sb.Append( "Microsoft (R) .NET Framework SecPol " + VER_FILEVERSION_STR + " - the policy manipulation tool");
        sb.Append( "\nCopyright (c) Microsoft Corp 1999-1999. All rights reserved.\n");
        return sb.ToString();
    }        
    
    public static void Main( String[] args )
    {
        Console.WriteLine( GenerateHeader() );
    
        if (args.Length == 0)
        {
            Help( null, "No arguments supplied" );
        }
        else
        {
            Run( args );
        }
    }
    
    static void Run( String[] args )
    {
        int numArgs = args.Length;
        int currentIndex = 0;
        int numArgsUsed = 0;
        
        while (currentIndex < numArgs)
        {
            bool foundOption = false;
        
            for (int index = 0; index < optionTable.Length; ++index)
            {
                if (optionTable[index].option.Equals( args[currentIndex] ))
                {
                    try
                    {
                        optionTable[index].handler(args, currentIndex, out numArgsUsed );
                    }
                    catch (Exception e)
                    {
                        if (!(e is ExitException))
                            Help( null, "Runtime error: " + e.ToString() );
                        return;
                    }
                    
                    foundOption = true;
                    currentIndex += numArgsUsed;
                    break;
                }
            }
            if (!foundOption)
            {
                try
                {
                    Error( null, "Invalid option: " + args[currentIndex], -1 );
                }
                catch (Exception e)
                {
                    if (!(e is ExitException))
                        Help( null, "Unhandled error: " + e.Message );
                    return;
                }
            }
        }
        if (m_success)
            Console.WriteLine( "Success" );
    }
    
    private static PermissionSet GenerateSecpolRequiredPermSet()
    {
        PermissionSet permSet = new PermissionSet( PermissionState.None );
        permSet.AddPermission( new RegistryPermission( RegistryPermissionAccess.Read | RegistryPermissionAccess.Write, m_policyKey ) );
        permSet.AddPermission( new SecurityPermission( SecurityPermissionFlag.Execution | SecurityPermissionFlag.ControlPolicy | SecurityPermissionFlag.UnmanagedCode ) );
        return permSet;
    }
    
    private static int ConvertHexDigit(Char val) {
        if (val <= '9') return (val - '0');
        return ((val - 'A') + 10);
    }

    private static byte[] DecodeHexString(String hexString) {
        byte[] sArray = new byte[(hexString.Length / 2)];
        int digit;
        int rawdigit;
        for (int i = 0, j = 0; i < hexString.Length; i += 2, j++) {
            rawdigit = ConvertHexDigit(hexString[i]);
            digit = ConvertHexDigit(hexString[i+1]);
            sArray[j] = (byte) (digit | (rawdigit << 4));
        }
        return(sArray);
    }

    static PolicyStatementAttribute IsExclusive( String[] args, int index, out int argsUsed )
    {
        PolicyStatementAttribute attr = PolicyStatementAttribute.Nothing;
        
        argsUsed = 0;
        
        int usedInThisIteration;
        int tableCount = psattrTable.Length;
        
        do
        {
            usedInThisIteration = 0;
        
            if (args.Length - (index + argsUsed) < 2)
            {
                break;
            }
        
            for (int i = 0; i < tableCount; ++i)
            {
                if (String.Compare( args[index+argsUsed], psattrTable[i].label, true, CultureInfo.InvariantCulture ) == 0)
                {
                    if (String.Compare( args[index+argsUsed+1], "on", true, CultureInfo.InvariantCulture ) == 0)
                    {
                        attr |= psattrTable[i].value;
                    }
                    else if (String.Compare( args[index+argsUsed+1], "off", true, CultureInfo.InvariantCulture ) == 0)
                    {
                        attr &= ~psattrTable[i].value;
                    }
                    else
                    {
                        throw new Exception( "Invalid option to " + psattrTable[i].label + " - " + args[index+argsUsed+1] );
                    }
                    usedInThisIteration = 2;
                    break;
                }

            }
            if (usedInThisIteration == 0)
            {
                break;
            }
            else
            {
                argsUsed += usedInThisIteration;
            }
            
        } while (true);
    
        return attr;
    }
    
    static IMembershipCondition CreateMembershipCondition( PolicyLevel level, String[] args, int index, out int offset )
    {
        IMembershipCondition mship = CreateMembershipConditionNoThrow( level, args, index, out offset );
        
        if (mship == null)
        {
            int optionIndex = index >= 2 ? 2 : 0;
            ErrorMShip( args[optionIndex], null, "Unknown membership condition - " + args[index], -1 );
        }
        
        return mship;
    }
    
    static IMembershipCondition CreateMembershipConditionNoThrow( PolicyLevel level, String[] args, int index, out int offset )
    {
        for (int i = 0; i < mshipTable.Length; ++i)
        {
            if (mshipTable[i].option.Equals( args[index] ))
            {
                return mshipTable[i].handler( level, args, index, out offset );
            }
        }
        
        offset = 0;
        
        return null;
    }    
    
    static IMembershipCondition AllMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -all                     All" );
            return null;
        }
        
        return new AllMembershipCondition();
    }
    
    static IMembershipCondition ApplicationDirectoryMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -appdir                  Application directory" );
            return null;
        }
        
        return new ApplicationDirectoryMembershipCondition();
    }
    
    static IMembershipCondition HashMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -hash <hashAlg> {-hex <hashValue>|-file <assembly_file>}\n" +
                               "                           Assembly hash" );
            offset = 0;
            return null;
        }
        
        if (args.Length - index < 2)
        {
            ErrorMShip( args[0], "-hash", "Not enough arguments", -1 );
        }
        
        HashAlgorithm hashAlg = HashAlgorithm.Create( args[index+1] );
        byte[] hashValue = null;
        
        if (args[index+2].Equals( "-file" ))
        {
            hashValue = new Hash( Assembly.LoadFrom( args[index+3] ) ).GenerateHash( HashAlgorithm.Create( args[index+1] ) );
            offset = 3;
        }
        else if (args[index+2].Equals( "-hex" ))
        {
            hashValue = DecodeHexString( args[index+3] );
            offset = 4;
        }
        else
        {
            ErrorMShip( args[0], "-hash", "Invalid hash option - " + args[index+2], -1 );
            // not reached;
            offset = 0;
        }
            
        return new HashMembershipCondition( hashAlg, hashValue );
    }
    
    static IMembershipCondition PublisherMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 3;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -pub {-cert <cert_file_name> | -file <signed_file_name> | -hex <hex_string>}\n" +
                               "                           Software publisher" );
            return null;
        }
        
        if (args.Length - index < 2)
        {
            ErrorMShip( args[0], "-pub", "Not enough arguments", -1 );
        }
        
        X509Certificate pub = null;
        
        if (String.Compare( args[index+1], "-file", true, CultureInfo.InvariantCulture ) == 0)
        {
            pub = X509Certificate.CreateFromSignedFile( args[index+2] );
        }
        else if (String.Compare( args[index+1], "-cert", true, CultureInfo.InvariantCulture ) == 0)
        {
            pub = X509Certificate.CreateFromCertFile( args[index+2] );
        }
        else if (String.Compare( args[index+1], "-hex", true, CultureInfo.InvariantCulture ) == 0)
        {
            pub = new X509Certificate( DecodeHexString( args[index+2] ) );
        }
        else            
        {
            ErrorMShip( args[0], "-pub", "Invalid publisher option - " + args[index+1], -1 );
        }
            
        return new PublisherMembershipCondition( pub );
    }    
    
    static IMembershipCondition SiteMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 2;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -site <website>          Site" );
            return null;
        }
        
        if (args.Length - index < 1)
        {
            ErrorMShip( args[0], "-site", "Not enough arguments", -1 );
        }
        
        return new SiteMembershipCondition( args[index+1] );
    }
    
    static IMembershipCondition SkipVerificationMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -skipverif               Skip verification" );
            return null;
        }
        
        return new SkipVerificationMembershipCondition();
    }    
    
    static IMembershipCondition StrongNameMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -strong {-file <file_name> | -nokey} {<name> | -noname}\n" +
                               "          {<version> | -noversion}\n" +
                               "                           Strong name" );
            offset = 0;
            return null;
        }
        
        if (args.Length - index < 3)
        {
            ErrorMShip( args[0], "-strong", "Not enough arguments", -1 );
        }
        
        StrongNamePublicKeyBlob publicKey = null;
        String assemblyName = null;
        String assemblyVersion = null;
            
        if (String.Compare( args[index+1], "-file", true, CultureInfo.InvariantCulture ) == 0)
        {
            AssemblyName name = AssemblyName.GetAssemblyName( args[index+2] );
            publicKey = new StrongNamePublicKeyBlob( name.GetOriginator() );
            assemblyName = args[index+3];
            assemblyVersion = args[index+4];
            offset = 5;
        }
        else if (String.Compare( args[index+1], "-nokey", true, CultureInfo.InvariantCulture ) == 0)
        {
            assemblyName = args[index+2];
            assemblyVersion = args[index+3];
            offset = 4;
        }
        else
        {
            ErrorMShip( args[0], "-strong", "Invalid strong name option - " + args[index+1], -1 );
            // not reached
            offset = 0;
        }
                
        if (String.Compare( assemblyName, "-noname", true, CultureInfo.InvariantCulture ) == 0)
        {
            assemblyName = null;
        }
                    
        if (String.Compare( assemblyVersion, "-noversion", true, CultureInfo.InvariantCulture ) == 0)
        {
            assemblyVersion = null;
        }
        
        Version asmVer = null;
        
        if (assemblyVersion != null)
        {
            asmVer = ParseVersion( assemblyVersion );
        }
                
        return new StrongNameMembershipCondition( publicKey, assemblyName, asmVer );
    }         
    

    internal static Version ParseVersion( String version )
    {
        if (version == null)
            throw new ArgumentNullException( "version" );
        
        String[] separated = version.Split( new char[] { '.' } );
            
        int[] numbers = new int[4];
            
        int i;
            
        for (i = 0; i < separated.Length; ++i)
        {
            if (separated[i] == null)
                numbers[i] = 0;
            else
                numbers[i] = Int32.FromString( separated[i] );
        }
            
        while (i < 4)
        {
            numbers[i] = 0;
        }
            
        return new Version( numbers[0], numbers[1], numbers[2], numbers[3] );
    }
            
    
    
    static IMembershipCondition URLMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 2;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -url <url>               URL" );
            return null;
        }
        
        if (args.Length - index < 1)
        {
            ErrorMShip( args[0], "-url", "Not enough arguments", -1 );
        }
        
        return new URLMembershipCondition( args[index+1] );
    }
    
    static IMembershipCondition ZoneMembershipConditionHandler( PolicyLevel level, String[] args, int index, out int offset )
    {
        offset = 2;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "  -zone <zone_name>        Zone, where zone can be:" );
            for (int i = 0; i < s_names.Length; ++i)
                Console.WriteLine( "                                 " + s_names[i] );
            return null;
        }
        
        if (args.Length - index < 1)
        {
            ErrorMShip( args[0], "-zone", "Not enough arguments", -1 );
        }
        
        SecurityZone zoneNum = SecurityZone.NoZone;
                
        try
        {
            zoneNum = (SecurityZone)Int32.Parse( args[index+1] );
        }
        catch (Exception)
        {
            for (int i = 0; i < s_names.Length; ++i)
            {
                if (String.Compare( args[index+1], s_names[i], true, CultureInfo.InvariantCulture ) == 0)
                {
                    zoneNum = (SecurityZone)i;
                    break;
                }
            }
        }
                
        if (zoneNum < SecurityZone.MyComputer || zoneNum > SecurityZone.Untrusted)
        {
            ErrorMShip( args[0], "-zone", "Invalid zone - " + args[index+1], -1 );
        }
        
        return new ZoneMembershipCondition( zoneNum );
    }            
    
    
    static PolicyLevel GetLevel( String label )
    {
        IEnumerator enumerator;
                
        try
        {
            enumerator = SecurityManager.PolicyHierarchy();
        }
        catch (SecurityException)
        {
            Error( null, "Insufficient rights to obtain policy level", -1 );
            // not reached
            return null;
        }
                
        while (enumerator.MoveNext())
        {
            PolicyLevel level = (PolicyLevel)enumerator.Current;
            if (level.Label.Equals( label ))
            {
                m_level = level;
                break;
            }
        }
                
        return m_level;
    }    
        
    
    static PolicyLevel GetLevel()
    {
        if (m_levelType == LevelType.None)
        {
            WindowsPrincipal principal = new WindowsPrincipal( WindowsIdentity.GetCurrent() );
            
            if (principal.IsInRole( "BUILTIN\\Administrators" ))
            {
                return GetLevel( "Machine" );
            }
            else
            {
                return GetLevel( "User" );
            }
        }
        else if (m_levelType == LevelType.Machine)
        {
            return GetLevel( "Machine" );
        }
        else if (m_levelType == LevelType.UserDefault)
        {
            return GetLevel( "User" );
        }
        else if (m_levelType == LevelType.UserCustom)
        {
            // TODO: we need to retrieve the level for a particular user.  Don't really know how to do this
            // right now.
            return null;
        }
        else if (m_levelType == LevelType.All)
        {
            return null;
        }
        else
        {
            // This should never occur.
            Error( null, "Unknown level type", -1 );
            /* not reached */
            return null;
        }
    }
    
    static String ParentLabel( String label )
    {
        String[] separated = label.Split( m_labelSeparators.ToCharArray() );
        int size = separated[separated.Length-1] == null || separated[separated.Length-1].Equals( "" )
                        ? separated.Length-1 : separated.Length;
        
        StringBuilder sb = new StringBuilder();
        
        for (int i = 0; i < size-1; ++i)
        {
            sb.Append( separated[i] );
            sb.Append( '.' );
        }
        
        return sb.ToString();
    }
    
    static Object GetLabel( String label )
    {
        PolicyLevel level = GetLevel();
        
        if (level == null)
        {
            return null;
        }
        
        if (label == null)
        {
            return null;
        }        
    
        String[] separated = label.Split( m_labelSeparators.ToCharArray() );
        int size = separated[separated.Length-1] == null || separated[separated.Length-1].Equals( "" )
                        ? separated.Length-1 : separated.Length;
        
        if (size >= 1 && !separated[0].Equals( "1" ))
        {
            throw new ArgumentException( "Invalid label - " + label );
        }
        
        
        ICodeGroup group = level.RootCodeGroup;

        if (size == 1 && separated[0].Equals( "1" ))
        {
            return group;
        }
        
        for (int index = 1; index < size; ++index)
        {
            ICodeGroup newGroup = null;
            IEnumerator enumerator = group.Children.GetEnumerator();
            int count = 1;
            
            while (enumerator.MoveNext())
            {
                if (count == Int32.Parse( separated[index] ))
                {
                    newGroup = (ICodeGroup)enumerator.Current;
                    break;
                }
                else
                {
                    count++;
                }
            }
            
            if (newGroup == null)
                throw new ArgumentException( "Invalid label - " + label );
            else
                group = newGroup;
        }
        
        return group;
    }
                
    static void Error( String which, String message, int errorCode )
    {
        ErrorMShip( which, null, message, errorCode );
    }
    
    static void ErrorMShip( String whichOption, String whichMShip, String message, int errorCode )
    {
        HelpMShip( whichOption, whichMShip, "ERROR: " + message );
        // HACK: throw an exception here instead of exiting since we can't always
        // call Runtime.Exit().
        throw new ExitException();
    }
    
    
    static void Help( String which, String message )
    {
        HelpMShip( which, null, message );
    }
    
    static void HelpMShip( String whichOption, String whichMShip, String message )
    {
        Console.WriteLine( message + "\n" );
        
        Console.WriteLine( "Usage: secpol <option> <args> ...\n" );
        
        String[] helpArgs = new String[1];
        helpArgs[0] = "__internal_usage__";
        int numArgs = 0;
	// Remove this when the C# bug is fixed.
	numArgs++;
        
        for (int i = 0; i < optionTable.Length; ++i)
        {
            if (optionTable[i].sameAs == null && (whichOption == null || whichOption.Equals( optionTable[i].option )))
            {
                optionTable[i].handler(helpArgs, 0, out numArgs);
                Console.WriteLine( "" );
            }
            if (optionTable[i].sameAs != null && (whichOption == null || whichOption.Equals( optionTable[i].sameAs )))
            {
                StringBuilder sb = new StringBuilder();
                sb.Append( "secpol " );
                sb.Append( optionTable[i].option );
                sb.Append( "\n    Abbreviation for " );
                sb.Append( optionTable[i].sameAs );
                sb.Append( "\n" );
                Console.WriteLine( sb.ToString() );
            }
        }
        
        Console.WriteLine( "\nwhere \"<mship>\" can be:" );
        
        for (int i = 0; i < mshipTable.Length; ++i)
        {
            if (whichMShip == null || whichMShip.Equals( mshipTable[i].option ))
            {
                int offset = 0;
		// Remove this when the C# bug is fixed.
		offset++;
                mshipTable[i].handler( null, helpArgs, 0, out offset );
            }
        }
        
        Console.WriteLine( "\nwhere \"<psflag>\" can be any combination of:" );
        
        for (int i = 0; i < psattrTable.Length; ++i)
        {
            Console.WriteLine( "  " + psattrTable[i].label + " {on|off}" );
            Console.WriteLine( "                           " + psattrTable[i].description );
        }
    }
    
    static void SafeSavePolicy()
    {
        if (!m_force)
        {
            PermissionSet required = new PermissionSet( PermissionState.None );
            PermissionSet optional = new PermissionSet( PermissionState.Unrestricted );
            PermissionSet refused = new PermissionSet( PermissionState.None );
            PermissionSet denied = null;
            PermissionSet granted = SecurityManager.ResolvePolicy( Assembly.GetExecutingAssembly().Evidence, required, optional, refused, out denied );
            
            PermissionSet secpolRequired = GenerateSecpolRequiredPermSet();
            
            if (!secpolRequired.IsSubsetOf( granted ) || (denied != null && secpolRequired.Intersect( denied ) != null))
            {
                Console.WriteLine( "This operation will make some or all SecPol functionality cease to work." );
                Console.WriteLine( "In you are sure you want to do this operation, use the '-force on' option" );
                Console.WriteLine( "before the option you just executed.  For example:" );
                Console.WriteLine( "    secpol -force on -machine -remgroup 1.6" );
                Console.WriteLine( "\nPolicy save aborted." );
                m_success = false;
                throw new ExitException();
            }
        }
            
        try
        {            
            RegistryKey key = Registry.LocalMachine.OpenSubKey( m_policyKey, true );

            bool promptOn;

            if (key == null)
            {
                promptOn = true;        
            }
            else
            {
                byte[] value = (byte[])key.GetValue( "GlobalSettings", null );

                if (value == null)
                    promptOn = true;
                else
                    promptOn = (value[0] & 0x01) != 0x01;
            }
        
            if (promptOn)
            {
                Console.WriteLine( "The operation you are performing will alter security policy.\nAre you sure you want to perform this operation? (yes/no)" );
        
                String input = Console.ReadLine();
                
                if (input != null && (String.Compare( input, "yes", true, CultureInfo.InvariantCulture ) == 0 || String.Compare( input, "y", true, CultureInfo.InvariantCulture ) == 0))
                    SecurityManager.SavePolicy();
                else
                {
                    Console.WriteLine( "Policy save aborted" );
                    m_success = false;
                    throw new ExitException();
                }
            }
            else
            {
                SecurityManager.SavePolicy();
            }
        }
        catch (Exception)
        {
            SecurityManager.SavePolicy();
        }
    }
    
    static void MachineHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -machine\n    Set the machine policy level as the active level" );
            return;
        }
        
        m_levelType = LevelType.Machine;
    }
    
    static void UserHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -user\n    Set the user policy level as the active level" );
            return;
        }
        
        m_levelType = LevelType.UserDefault;
    }
    
    static void AllHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -all\n    Set all policy levels as the active levels" );
            return;
        }
        
        m_levelType = LevelType.All;
    }    
            
    static void SecurityHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -security { on | off }\n    Turn security on or off" );
            return;
        }

        numArgsUsed = 2;

        if (args.Length - index < 2)
        {
            Error( "-security", "Not enough arguments", -1 );
        }
        
        if (String.Compare( args[index + 1], "on", true, CultureInfo.InvariantCulture ) == 0)
        {
            SecurityManager.SecurityEnabled = true;
        }
        else if (String.Compare( args[index + 1], "off", true, CultureInfo.InvariantCulture ) == 0)
        {
            SecurityManager.SecurityEnabled = false;
        }
        else
        {
            Error( "-security", "Invalid option", -1 );
        }
        
        SecurityManager.SavePolicy();
    }
    
    static void ExecutionHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -execution { on | off }\n    Enable/Disable checking for \"right-to-run\" on code execution start-up" );
            return;
        }

        numArgsUsed = 2;

        if (args.Length - index < 2)
        {
            Error( "-execution", "Not enough arguments", -1 );
        }
        
        if (String.Compare( args[index + 1], "on", true, CultureInfo.InvariantCulture ) == 0)
        {
            SecurityManager.CheckExecutionRights = true;
        }
        else if (String.Compare( args[index + 1], "off", true, CultureInfo.InvariantCulture ) == 0)
        {
            SecurityManager.CheckExecutionRights = false;
        }
        else
        {
            Error( "-execution", "Invalid option", -1 );
        }

        SecurityManager.SavePolicy();
    }
    
    static void PolicyChangeHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -polchgprompt { on | off }\n    Enable/Disable policy change prompt" );
            return;
        }

        numArgsUsed = 2;

        if (args.Length - index < 2)
        {
            Error( "-polchgprompt", "Not enough arguments", -1 );
        }
        
        RegistryKey key = Registry.LocalMachine.OpenSubKey( m_policyKey, true );
        
        if (key == null)
            key = Registry.LocalMachine.CreateSubKey( m_policyKey );

        byte[] value = (byte[])key.GetValue( "GlobalSettings", null );
        
        if (value == null)
        {
            value = new byte[4];
            value[0] = 0;
            value[1] = 0;
            value[2] = 0;
            value[3] = 0;
        }
            
        if (String.Compare( args[index + 1], "on", true, CultureInfo.InvariantCulture ) == 0)
        {
            value[0] = 0;
        }
        else if (String.Compare( args[index + 1], "off", true, CultureInfo.InvariantCulture ) == 0)
        {
            value[0] = 1;
        }
        else
        {
            Error( "-polchgprompt", "Invalid option", -1 );
        }

        key.SetValue( "GlobalSettings", value );
    }
    
    static void RecoverHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -recover\n    Recover the most recently saved version of a level" );
            return;
        }
        
        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-recover", "Unable to retrieve level information for display", -1 );
        } 
        
        try
        {
            while (levelEnumerator.MoveNext())
            {
                ((PolicyLevel)levelEnumerator.Current).Recover();
            }
        }
        catch (Exception e)
        {
            Error( "-recover", e.Message, -1 );
        }
        
        SafeSavePolicy();
               
    }
    
    static void ResetHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -reset\n    Reset a level to its default state" );
            return;
        }
        
        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-reset", "Unable to retrieve level information for display", -1 );
        }
        
        try
        {
            while (levelEnumerator.MoveNext())
            {
                Console.WriteLine( "Resetting policy for " + ((PolicyLevel)levelEnumerator.Current).Label );
                ((PolicyLevel)levelEnumerator.Current).Reset();
            }
        }
        catch (Exception e)
        {
            Error( "-reset", e.Message, -1 );
        }
        
        
        
        SafeSavePolicy();
    }
    
    static void ForceHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -force { on | off }\n    Enable/Disable forcing save that will disable SecPol functionality" );
            return;
        }

        numArgsUsed = 2;

        if (args.Length - index < 2)
        {
            Error( "-force", "Not enough arguments", -1 );
        }
        
        if (String.Compare( args[index + 1], "on", true, CultureInfo.InvariantCulture ) == 0)
        {
            m_force = true;
        }
        else if (String.Compare( args[index + 1], "off", true, CultureInfo.InvariantCulture ) == 0)
        {
            m_force = false;
        }
        else
        {
            Error( "-force", "Invalid option", -1 );
        }
    }
    
    
    static void HelpHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -help\n    Displays this screen" );
            return;
        }
        
        Help( null, "Help screen requested" );
    }        
    
    static void SaveHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -save\n    Saves the current policy" );
            return;
        }
        
        SafeSavePolicy();
    }
        
        
    private static void DisplayLevelCodeGroups( PolicyLevel level )
    {
        DisplayCodeGroups( level.RootCodeGroup );
    }
    
    private static void DisplayCodeGroups( ICodeGroup group )
    {
        String label = "1";
            
        Console.WriteLine( label + ".  " +
            (group.MergeLogic.Equals( "Union" ) ? "" : ("(" + group.MergeLogic + ") ")) +
            group.MembershipCondition.ToString() + ": " +
            (group.PermissionSetName == null ? "@@Unknown@@" : group.PermissionSetName) +
            ( group.AttributeString == null ||
              group.AttributeString.Equals( "" ) ? "" :
            " (" + group.AttributeString + ")" ) );
                
        ListCodeGroup( label, m_indent, group.Children.GetEnumerator() );
    }        
    
    private static void DisplayLevelPermissionSets( PolicyLevel level )
    {
        IEnumerator permEnumerator = level.NamedPermissionSets.GetEnumerator();
            
        int inner_count = 1;
            
        while (permEnumerator.MoveNext())
        {
            NamedPermissionSet permSet = (NamedPermissionSet)permEnumerator.Current;
                
            StringBuilder sb = new StringBuilder();
                
            sb.Append( inner_count + ". " + permSet.Name );
            if (permSet.Description != null && !permSet.Description.Equals( "" ))
            {
                sb.Append( " (" + permSet.Description + ")" );
            }
            sb.Append( " =\n" + permSet.ToXml().ToString() );
                
            Console.WriteLine( sb.ToString() );
                
            ++inner_count;
        }    
    }
    
    static void DisplaySecurityOnOff()
    {
        Console.WriteLine( "Security is " + (SecurityManager.SecurityEnabled ? "ON" : "OFF") );
        Console.WriteLine( "Execution checking is " + (SecurityManager.CheckExecutionRights ? "ON" : "OFF") );
        
        try
        {
            RegistryKey key = Registry.LocalMachine.OpenSubKey( m_policyKey, true );
        
            if (key == null)
                key = Registry.LocalMachine.CreateSubKey( m_policyKey );

            byte[] value = (byte[])key.GetValue( "GlobalSettings", null );
        
            Console.WriteLine( "Policy change prompt is " + (value == null || value[0] == 0 ? "ON" : "OFF") );
        }
        catch (Exception)
        {
        }
    }
    
    static void ListHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;

        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -list\n    List code groups & permission sets" );
            return;
        }

        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-list", "Unable to retrieve level information for display", -1 );
        }
        
        DisplaySecurityOnOff();
        
        while (levelEnumerator.MoveNext())
        {
            PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
            Console.WriteLine( "\nLevel = " + currentLevel.Label );
            Console.WriteLine( "\nCode Groups:\n" );
            DisplayLevelCodeGroups( currentLevel ); 
            Console.WriteLine( "\nNamed Permission Sets:\n" );
            DisplayLevelPermissionSets( currentLevel );
        }
    }
    
    static void ListGroupHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;
    
        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -listgroups\n    List code groups" );
            return;
        }
        
        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-list", "Unable to retrieve level information for display", -1 );
        }
        
        DisplaySecurityOnOff();
        
        while (levelEnumerator.MoveNext())
        {
            PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
            Console.WriteLine( "\nLevel = " + currentLevel.Label );
            Console.WriteLine( "\nCode Groups:\n" );
            DisplayLevelCodeGroups( currentLevel ); 
        }
    }
    
    static void ListPermHandler( String[] args, int index, out int numArgsUsed )
    {
        numArgsUsed = 1;
    
        if (args[index].Equals( "__internal_usage__" ))
        {
            Console.WriteLine( "secpol -listpset\n    List permission sets" );
            return;
        }
        
        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-list", "Unable to retrieve level information for display", -1 );
        }
        
        DisplaySecurityOnOff();
        
        while (levelEnumerator.MoveNext())
        {
            PolicyLevel currentLevel = (PolicyLevel)levelEnumerator.Current;
            Console.WriteLine( "\nLevel = " + currentLevel.Label );
            Console.WriteLine( "\nNamed Permission Sets:\n" );
            DisplayLevelPermissionSets( currentLevel );
        }
    }
    
    
    static void ListCodeGroup( String prefix, String indent, IEnumerator enumerator )
    {
        if (enumerator == null)
            return;
        
        int count = 1;
        
        while (enumerator.MoveNext())
        {
            String label = prefix + "." + count;
            ICodeGroup group = (ICodeGroup)enumerator.Current;
            
            Console.WriteLine( indent + label + ".  " +
                (group.MergeLogic.Equals( "Union" ) ? "" : ("(" + group.MergeLogic + ") ")) +
                group.MembershipCondition.ToString() + ": " +
                (group.PermissionSetName == null ? "@@Unknown@@" : group.PermissionSetName) +
                ( group.AttributeString == null ||
                  group.AttributeString.Equals( "" ) ? "" :
                " (" + group.AttributeString + ")" ) );
                
            ListCodeGroup( label, indent + m_indent, group.Children.GetEnumerator() );
            
            ++count;
        }
    }
    
    static void AddPermHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -addpset { <named_xml_file> | <xml_file> <name> } \n    Add named permission set to policy level" );
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( "-addpset", "Not enough arguments", -1 );
            return;
        }
        
        PolicyLevel level = GetLevel();
        
        if (level == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-addpset", "This option is not valid with the \"-all\" option", -1 );
            else
                Error( "-addpset", "Unable to retrieve level", -1 );
        }
        
        NamedPermissionSet permSet = null;
        
        try
        {
            permSet = GetPermissionSet( args, index + 1 );
        }
        catch (Exception e)
        {
            Error( "-addpset", e.Message, -1 );
        }
        
        if (permSet.Name == null)
        {
            // The provided XML file did not provide a name for the permission set.  Assume that (index + 2) points to the
            // name.
            permSet.Name = args[index+2];
            numArgsUsed = 3;
        }
        else
        {
            numArgsUsed = 2;
        }
        
        try
        {
            level.AddNamedPermissionSet( permSet );
        }
        catch (Exception)
        {
            Error( "-addpset", "Permission set with that name already exists at requested level", -1 );
            return;
        }
        
        SafeSavePolicy();
    }
    
    static void ChgPermHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -chgpset <xml_file> <pset_name>\n    Change named permission set in active level" );
            return;
        }

        numArgsUsed = 3;

        if (args.Length - index < 3)
        {
            Error( "-chgpset", "Not enough arguments", -1 );
            return;
        }
        
        PolicyLevel level = GetLevel();
        
        if (level == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-chgpset", "This option is not valid with the \"-all\" option", -1 );
            else
                Error( "-chgpset", "Unable to retrieve level", -1 );
        }
        
        NamedPermissionSet permSet = null;
        
        try
        {
            permSet = GetPermissionSet( args, index + 1 );
        }
        catch (Exception e)
        {
            Error( "-chgpset", e.Message, -1 );
        }
        
        permSet.Name = args[index+1];
        
        try
        {
            level.RemoveNamedPermissionSet( args[index+2] );
            level.AddNamedPermissionSet( permSet );
        }
        catch (Exception e)
        {
            Error( "-chgpset", e.Message, -1 );
        }
        
        SafeSavePolicy();
    }        
    
    static void RemPermHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -rempset <pset_name>\n    Remove a named permission set from the policy level" );
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( "-rempset", "Not enough arguments", -1 );
            return;
        }
        
        PolicyLevel level = GetLevel();
        
        if (level == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-rempset", "This option is not valid with the \"-all\" option", -1 );
            else
                Error( "-rempset", "Unable to retrieve level", -1 );
        }
        
        try
        {
            level.RemoveNamedPermissionSet( args[index+1] );
        }
        catch (Exception e)
        {
            Error( "-rempset", e.Message, -1 );
        }
        
        SafeSavePolicy();
    }
    
    static void RemGroupHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -remgroup <label>\n    Remove code group at <label>" );
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( "-remgroup", "Not enough arguments", -1 );
            return;
        }
        
        Object removeValue = null;
        Object parentValue = null;
        
        try
        {
            removeValue = GetLabel( args[index+1] );
        }
        catch (Exception e)
        {
            if (e is SecurityException)
                Error( "-remgroup", "Permission to alter policy was denied", -1 );
            else        
                Error( "-remgroup", "Invalid label", -1 );
            return;
        }
        
        if (removeValue == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-remgroup", "This option is not valid with the \"-all\" option.", -1 );
            else
                Error( "-remgroup", "Invalid label", -1 );
            return;
        }
       
        if (!(removeValue is ICodeGroup))
        {
            Error( "-remgroup", "Label must point to a code group", -1 );
            return;
        }
        
        try
        {
            parentValue = GetLabel( ParentLabel( args[index+1] ) );
        }
        catch (Exception)
        {
            Error( "-remgroup", "Invalid label", -1 );
            return;
        }
        
        if (parentValue == null)
        {
            Error( "-remgroup", "Invalid label", -1 );
            return;
        }
       
        if (!(parentValue is ICodeGroup))
        {
            Error( "-remgroup", "Label must point to a code group", -1 );
            return;
        }      
        
        ((ICodeGroup)parentValue).RemoveChild( (ICodeGroup)removeValue );
        
        SafeSavePolicy();
        
        Console.WriteLine( "Removed code group from " + GetLevel().Label + " level." );
        
    }
    
    static void AddGroupHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -addgroup <label> <mship> <pset_name> <psflag>\n    Add code group to <label> with given membership,\n    permission set, and flags" );
            return;
        }
        
        numArgsUsed = 2;

        if (args.Length - index < 4) 
        {
            Error( "-addgroup", "Not enough arguments", -1 );
            return;
        }
        
        Object parentValue = null;

        PolicyLevel level = GetLevel();
        
        if (level == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-addgroup", "This option is not valid with the \"-all\" option", -1 );
            else
                Error( "-addgroup", "Unable to retrieve level", -1 );
        }
        
        try
        {
            parentValue = GetLabel( args[index+1] );
        }
        catch (Exception e)
        {
            if (e is SecurityException)
                Error( "-addgroup", "Permission to alter policy was denied", -1 );
            else        
                Error( "-addgroup", "Invalid label", -1 );
            return;
        }
        
        if (parentValue == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-addgroup", "This option is not valid with the \"-all\" option.", -1 );
            else
                Error( "-addgroup", "Invalid label", -1 );
            return;
        }
       
        if (!(parentValue is ICodeGroup))
        {
            Error( "-addgroup", "Label must point to a code group", -1 );
            return;
        }
        
        int offset = 0, exlOffset = 0;
        
        IMembershipCondition mship = CreateMembershipCondition( level, args, index+2, out offset );

        ICodeGroup newGroup = new UnionCodeGroup( mship, new PolicyStatement( GetPermissionSet( level, args[index + 2 + offset] ), IsExclusive( args, index + 3 + offset, out exlOffset ) ) );
        
        ((ICodeGroup)parentValue).AddChild( newGroup );
        
        SafeSavePolicy();
        
        Console.WriteLine( "Added union code group with \"" + args[index+2] + "\" membership condition to " + level.Label + " level." );
        
        numArgsUsed = offset + exlOffset + 3;
    }
    
    static void ChgGroupHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -chggroup <label> {<mship>|<pset_name>|<psflag>}\n    Change code group at <label> to given membership,\n    permission set, or flags" );
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 3)
        {
            Error( "-chggroup", "Not enough arguments", -1 );
            return;
        }        
        
        Object group = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-chggroup", "This option is not valid with the \"-all\" option", -1 );
            else
                Error( "-chggroup", "Unable to retrieve level", -1 );
        }        
        try
        {
            group = GetLabel( args[index+1] );
        }
        catch (Exception e)
        {
            if (e is SecurityException)
                Error( "-addgroup", "Permission to alter policy was denied", -1 );
            else        
                Error( "-addgroup", "Invalid label", -1 );
            return;
        }
        
        if (group == null)
        {
            if (m_levelType == LevelType.All)
                Error( "-remgroup", "This option is not valid with the \"-all\" option.", -1 );
            else
                Error( "-remgroup", "Invalid label", -1 );
            return;
        }
       
        if (!(group is ICodeGroup))
        {
            Error( "-chggroup", "Label must point to a code group", -1 );
            return;
        }
        
        ICodeGroup codeGroup = (ICodeGroup)group;
        
        bool foundAtLeastOneMatch = false;
        
        StringBuilder sb = new StringBuilder();
        
        while (true)
        {
            int offset = 0;
            
            if (args.Length - index <= numArgsUsed)
                break;
        
            IMembershipCondition condition = CreateMembershipConditionNoThrow( level, args, index + numArgsUsed, out offset );
        
            if (condition != null && offset != 0)
            {
                codeGroup.MembershipCondition = condition;
                if (foundAtLeastOneMatch)
                    sb.Append( "\n" );
                sb.Append( "Changed code group membership condition to type \"" + args[index+numArgsUsed] + "\" in " + level.Label + " level." );
                numArgsUsed += offset;        
                foundAtLeastOneMatch = true;
                
                continue;
            }
        
            PolicyStatementAttribute attr = PolicyStatementAttribute.Nothing;
        
            attr = IsExclusive( args, index + numArgsUsed, out offset );

            if (offset != 0)
            {
                if (codeGroup is UnionCodeGroup)
                {
                    PolicyStatement ps = ((UnionCodeGroup)codeGroup).PolicyStatement;
                    ps.Attributes = attr;
                    ((UnionCodeGroup)codeGroup).PolicyStatement = ps;
                }
                else if (codeGroup is FirstMatchCodeGroup)
                {
                    PolicyStatement ps = ((FirstMatchCodeGroup)codeGroup).PolicyStatement;
                    ps.Attributes = attr;
                    ((FirstMatchCodeGroup)codeGroup).PolicyStatement = ps;
                }
                else
                    Error( "-chggroup", "Only able to change permission set or flags on built-in code groups", -1 );
                    
                if (foundAtLeastOneMatch)
                    sb.Append( "\n" );
                sb.Append( "Changed code group attributes to \"" + ((ICodeGroup)codeGroup).AttributeString + "\" in " + level.Label + " level." );
                numArgsUsed += offset;
                foundAtLeastOneMatch = true;
                continue;
            }

            PermissionSet permSet = GetPermissionSet( level, args[index + numArgsUsed] );
        
            if (permSet != null)
            {
                if (codeGroup is UnionCodeGroup)
                {
                    PolicyStatement ps = ((UnionCodeGroup)codeGroup).PolicyStatement;
                    ps.PermissionSet = permSet;
                    ((UnionCodeGroup)codeGroup).PolicyStatement = ps;
                }
                else if (codeGroup is FirstMatchCodeGroup)
                {
                    PolicyStatement ps = ((FirstMatchCodeGroup)codeGroup).PolicyStatement;
                    ps.PermissionSet = permSet;
                    ((FirstMatchCodeGroup)codeGroup).PolicyStatement = ps;
                }
                else
                    Error( "-chggroup", "Only able to change permission set or flags on built-in code groups", -1 );
                
                if (foundAtLeastOneMatch)
                    sb.Append( "\n" );
                sb.Append( "Changed code group permission set to \"" + args[index+numArgsUsed] + "\" in " + level.Label + " level." );
                
                numArgsUsed++;
                foundAtLeastOneMatch = true;
                continue;
            }
        
            if (!foundAtLeastOneMatch)
                Error( "-chggroup", "Unrecognized option or permission set name \"" + args[index + 2] + "\".", -1 );
            else
                break;
        }
        
        SafeSavePolicy();
        
        Console.WriteLine( sb.ToString() );
    }
    
    static Evidence GenerateShellEvidence( String fileName, String option )
    {
        Assembly asm = Assembly.LoadFrom( fileName );
        
        if (asm == null)
            Error( option, "Unable to load specified assembly", -1 );
            
        return asm.Evidence;
    }
    
    static void ResolveGroupHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -resolvegroup <assembly-file>\n    List code groups this file belongs to" );
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( "-resolvegroup", "Not enough arguments", -1 );
        }
        
        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-list", "Unable to retrieve level information for display", -1 );
        }
        
        Evidence evidence = GenerateShellEvidence( args[index+1], "-resolvegroup" );
        
        while (levelEnumerator.MoveNext())
        {
            Console.WriteLine( "Level = " + ((PolicyLevel)levelEnumerator.Current).Label );
            
            DisplayCodeGroups( ((PolicyLevel)levelEnumerator.Current).ResolveMatchingCodeGroups( evidence ) );
            
            Console.WriteLine( "" );
        }
        
    }
    
    static void ResolvePermHandler( String[] args, int index, out int numArgsUsed )
    {
        if (args[index].Equals( "__internal_usage__" ))
        {
            numArgsUsed = 1;
            Console.WriteLine( "secpol -resolveperm <assembly-file>\n    List code groups this file belongs to" );
            return;
        }
        
        numArgsUsed = 2;
        
        if (args.Length - index < 2)
        {
            Error( "-resolveperm", "Not enough arguments", -1 );
        }
        
        IEnumerator levelEnumerator = null;
        
        PolicyLevel level = GetLevel();
        
        if (level == null && m_levelType == LevelType.All)
        {
            levelEnumerator = SecurityManager.PolicyHierarchy();
        }
        else if (level != null)
        {
            ArrayList list = new ArrayList();
            list.Add( level );
            levelEnumerator = list.GetEnumerator();
        }
        
        if (levelEnumerator == null)
        {
            Error( "-list", "Unable to retrieve level information for display", -1 );
        }
        
        Evidence evidence = GenerateShellEvidence( args[index+1], "-resolveperm" );
        
        PermissionSet grant = new PermissionSet( PermissionState.Unrestricted );
        
        while (levelEnumerator.MoveNext())
        {
            Console.WriteLine( "Resolving permissions for level = " + ((PolicyLevel)levelEnumerator.Current).Label );
            
            PolicyStatement policy = ((PolicyLevel)levelEnumerator.Current).Resolve( evidence );
            
            if (policy != null)
                grant = grant.Intersect( policy.PermissionSet );
            else
                grant = new PermissionSet( PermissionState.None );
        }
        
        Console.WriteLine( "\nGrant =\n" + grant.ToString() );
        
    }
    
    static NamedPermissionSet GetPermissionSet(String[] args, int index)
    {
        FileStream f;

        try
        {
            f = new FileStream(args[index], FileMode.Open, FileAccess.Read);
        }
        catch (Exception e)
        {
            if (e is FileNotFoundException) {
                throw new Exception( "Unable to find specified file" );
            }
            
            throw new Exception( "Error accessing specified file" );
        }

        // Create named permission set with "no name" since you have to give it a name.
        NamedPermissionSet p = new NamedPermissionSet( "@@no name@@" );

        // Do the actual decode.  First try XMLAscii, then XMLUnicode
        
        
        try
        {
            f.Position = 0;

            p.FromXml(new Parser( new BinaryReader( f, Encoding.ASCII) ).GetTopElement() );
        }
        catch (Exception e1)
        {
            Console.WriteLine( "exception occured =\n" + e1 );
        
            f.Position = 0;
        
            try
            {
                p.FromXml(new Parser( new BinaryReader( f, Encoding.Unicode) ).GetTopElement() );
            }
            catch (Exception)
            {
                f.Close();
                throw new Exception( "Error decoding file - " + e1 );
            }
        }

        f.Close();
        
        if (p.Name == null || p.Name.Equals( "" ) || p.Name.Equals( "@@no name@@" ))
        {
            if (args.Length > index + 1)
            {
                p.Name = args[index+1];
            }
            else
            {
                throw new ArgumentException( "Not enough arguments or improper xml file format:\n" +
                                             "     Must supply a name for this permission set" );
            }
        }

        return p;
    }
    
    static NamedPermissionSet GetPermissionSet( PolicyLevel level, String name )
    {
        NamedPermissionSet permSet = level.GetNamedPermissionSet( name );
        if (permSet == null)
        {
            throw new ArgumentException( "Unknown permission set - " + name );
        }
        return permSet;
    }
}    

internal class OptionTableEntry
{
    public OptionTableEntry( String option, OptionHandler handler, String sameAs )
    {
        this.option = option;
        this.handler = handler;
        this.sameAs = sameAs;
    }
   
        
    internal String option;
    internal OptionHandler handler;
    internal String sameAs;
}

internal class MembershipConditionTableEntry
{
    public MembershipConditionTableEntry( String option, MembershipConditionHandler handler )
    {
        this.option = option;
        this.handler = handler;
    }
        
    internal String option;
    internal MembershipConditionHandler handler;
}

internal class PolicyStatementAttributeTableEntry
{
    public PolicyStatementAttributeTableEntry( String label, PolicyStatementAttribute value, String description )
    {
        this.label = label;
        this.value = value;
        this.description = description;
    }
    
    internal String label;
    internal PolicyStatementAttribute value;
    internal String description;
}

class ExitException : Exception
{
}

internal class Parser
{
    private SecurityElement   _ecurr = null ;
    private Tokenizer _t     = null ;
    
    public virtual SecurityElement GetTopElement()
    {
        return _ecurr;
    }
    
    private void MustBe (int tokenType)
    {
        int i = _t.NextTokenType () ;
        if (i != tokenType)
            throw new XMLSyntaxException (_t.LineNo) ;
    }
    
    private String MandatoryTag ()
    {
        String s ;
            
        MustBe (Tokenizer.bra)   ;
        MustBe (Tokenizer.cstr)  ;
        s = _t.GetStringToken () ;
    
        return s ;
    }
    
    private void ParseContents (SecurityElement e)
    {
        //
        // Iteratively collect stuff up until the next end-tag.
        // We've already seen the open-tag.
        //
        ParserStack stack = new ParserStack();
        ParserStackFrame firstFrame = new ParserStackFrame();
        firstFrame.element = e;
        stack.Push( firstFrame );
            
        bool needToBreak = false;
        bool needToPop = false;
            
        while (!stack.IsEmpty())
        {
            ParserStackFrame locFrame = stack.Peek();
                
            for (int i = _t.NextTokenType () ; i != -1 ; i = _t.NextTokenType ())
            {
                switch (i)
                {
                case Tokenizer.cstr:
                    {
                        if (locFrame.intag)
                        {
                            // We're in a tag, so we've found an attribute/value pair.
                                
                            if (locFrame.strValue == null)
                            {
                                // Found attribute name, save it for later.
                                    
                                locFrame.strValue = _t.GetStringToken ();
                            }
                            else
                            {
                                // Found attribute text, add the pair to the current element.
                                    
                                locFrame.element.AddAttribute( locFrame.strValue, _t.GetStringToken () );
                                locFrame.strValue = null;
                            }
                        }
                        else
                        {
                            // We're not in a tag, so we've found text between tags.
                                
                            if (locFrame.element.Text == null)
                                locFrame.element.Text = "" ;
    
                            StringBuilder sb = new StringBuilder (locFrame.element.Text) ;
    
                            //
                            // Separate tokens with single spaces, collapsing whitespace
                            //
                            if (!locFrame.element.Text.Equals (""))
                                sb.Append (" ") ;
                            
                            sb.Append (_t.GetStringToken ()) ;
                            locFrame.element.Text = sb.ToString () ;
                        }
                    }
                    break ;
        
                case Tokenizer.bra:
                    locFrame.intag = true;
                    i = _t.NextTokenType () ;
    
                    if (i == Tokenizer.slash)
                    {
                        while ( (i = _t.NextTokenType()) == Tokenizer.cstr)
                            ; // spin; don't care what's in here
        
                        if (i != Tokenizer.ket)
                            throw new XMLSyntaxException (_t.LineNo) ;
         
                        // Found the end of this element
                        stack.Pop();
                            
                        needToBreak = true;

                    }
                    else if (i == Tokenizer.cstr)
                    {
                        // Found a child
                            
                        ParserStackFrame newFrame = new ParserStackFrame();
                            
                        newFrame.element = new SecurityElement (_t.GetStringToken ()) ;
                            
                        locFrame.element.AddChild (newFrame.element) ;
                            
                        stack.Push( newFrame );
                            
                        needToBreak = true;
                    }
                    else
                    {
                        throw new XMLSyntaxException (_t.LineNo) ;
                    }
                    break ;
        
                case Tokenizer.equals:
                    break;
                        
                case Tokenizer.ket:
                    if (locFrame.intag)
                    {
                        locFrame.intag = false;
                        continue;
                    }
                    else
                    {
                        throw new XMLSyntaxException (_t.LineNo);
                    }
                    // not reachable
                        
                case Tokenizer.slash:
                    locFrame.element.Text = null;
                        
                    i = _t.NextTokenType ();
                        
                    if (i == Tokenizer.ket)
                    {
                        // Found the end of this element
                        stack.Pop();
                            
                        needToBreak = true;
                    }
                    else
                    {
                        throw new XMLSyntaxException (_t.LineNo) ;
                    }
                    break;
                        
                        
                default:
                    throw new XMLSyntaxException (_t.LineNo) ;
                }
                    
                if (needToBreak)
                {
                    needToBreak = false;
                    needToPop = false;
                    break;
                }
                else
                {
                    needToPop = true;
                }
            }
            if (needToPop)
            {
                stack.Pop();
            }
        }
    }
    
    private Parser(Tokenizer t)
    {
        _t = t;
        _ecurr       = new SecurityElement( MandatoryTag() );
    
        ParseContents (_ecurr) ;
    }
        
    
    internal Parser (BinaryReader input)
        : this (new Tokenizer (input))
    {
    }
       

        
}                                              
    
    
internal class ParserStackFrame
{
    internal SecurityElement element = null;
    internal bool intag = true;
    internal String strValue = null;
}    
    
internal class ParserStack
{
    private ArrayList m_array;
        
    public ParserStack()
    {
        m_array = new ArrayList();
    }
        
    public virtual void Push( ParserStackFrame element )
    {
        m_array.Add( element );
    }
        
    public virtual ParserStackFrame Pop()
    {
        if (!IsEmpty())
        {
            int count = m_array.Count;
            ParserStackFrame temp = (ParserStackFrame) m_array[count-1];
            m_array.RemoveAt( count-1 );
            return temp;
        }
        else
        {
            throw new Exception( "Stack is empty." );
        }
    }
        
    public virtual ParserStackFrame Peek()
    {
        if (!IsEmpty())
        {
            return (ParserStackFrame) m_array[m_array.Count-1];
        }
        else
        {
            throw new Exception( "Stack is empty." );
        }
    }
        
    public virtual bool IsEmpty()
    {
        return m_array.Count == 0;
    }
        
    public virtual int GetCount()
    {
        return m_array.Count;
    }
        
}

internal class Tokenizer 
{
    private TokenReader         _input   ;
    private bool             _fincstr ;
    private bool             _fintag  ;
    private StringBuilder       _cstr    ;
    private char[]              _sbarray;
    private int                 _sbindex;
    private const int          _sbmaxsize = 128;
    
    // There are five externally knowable token types: bras, kets,
    // slashes, cstrs, and equals.  
    
    internal const int bra    = 0 ;
    internal const int ket    = 1 ;
    internal const int slash  = 2 ;
    internal const int cstr   = 3 ;
    internal const int equals = 4;
    
    public int  LineNo  ;
    
/*
    //================================================================
    // Constructor opens the file
    //
    Tokenizer (String fn) 
    {
        LineNo  = 1 ;
        _fintag  = false ;
        _fincstr = false ;
        _cstr    = null  ;
        _input   = new TextInputStream (fn) ;
    }
    
*/
    //================================================================
    // Constructor uses given ICharInputStream
    //
    internal Tokenizer (BinaryReader input)
    {
        LineNo  = 1 ;
        _fintag  = false ;
        _fincstr = false ;
        _cstr    = null  ;
        _input   = new TokenReader(input) ;
        _sbarray = new char[_sbmaxsize];
        _sbindex = 0;
    }
    
    //================================================================
    // 
    //
    private void EatLineComment ()
    {
        while (true)
        {
            int  i = _input.Read () ;
            char c = (char)i ;
    
            if (i == -1)
                return ;
    
            else if ((i == 13) && (_input.Peek () == 10))
            {
                _input.Read () ;
                if (_input.Peek() != -1)
                    LineNo ++ ;
                return ;
            }
        }
    }
    
    //================================================================
    // An XML Comment had better consist of <!- or <!-- followed by 
    // anything up until a -> or -->.  First thing had better be a 
    // bang.  One round through here eats all nested comments,
    // recursively.
    //
    private void
    EatXMLComment () 
    {
        int  i ;
        char c ;
            
        i = _input.Read () ;  c = (char) i ;
    
        if (c != '!')
        {
            throw new XMLSyntaxException (LineNo) ;
        }
    
        i = _input.Peek () ;  c = (char) i ;
    
        if (c != '-')
            // This ain't a comment, and it's somebody else's problem.
            return ;
    
        while (true)
        {
            i = _input.Read () ;  c = (char) i ;
                
            if (c == '-')
            {
                if (((char)_input.Peek()) == '>')
                {
                    _input.Read () ;
                    return ;
                }
            }
    
            if (c == '<')
            {
                if (((char)_input.Peek ()) == '!')
                    EatXMLComment () ;
            }
    
            if (i == -1)
                return ;
        }
    }
    
    //================================================================
    // 
    //
    private bool FIsWhite (int j)
    {
        if ((j == 10) && (_input.Peek() != -1))
            LineNo ++ ;
    
        return (j == 32) || (j ==  9)  // Space and tab
            || (j == 13) || (j == 10)  // CR and LF
            ;
    }
    
    //================================================================
    // Parser needs to know types of tokens
    //
    private void SBArrayAppend(char c) {
        // this is the common case
        if (_sbindex != _sbmaxsize) {
            _sbarray[_sbindex] = c;
            _sbindex++;
            return;
        } 
        // OK, first check if we have to init the StringBuilder
        if (_cstr == null) {
            _cstr = new StringBuilder();
        }
        // OK, copy from _sbarray to _cstr
        _cstr.Append(_sbarray,0,_sbmaxsize);
        // reset _sbarray pointer
        _sbarray[0] = c;
        _sbindex = 1;
        return;
    }
    
    internal virtual int NextTokenType ()
    {
        int  i ;
        char c ;
        char cpeek;
    
        _fincstr = false ;
        // If we overflowed last time, clear out any left-over string builder.
        _cstr    = null;
        // reset the buffer
        _sbindex = 0;
            
        while (true)
        {
            if (_fintag)
            {
                cpeek = (char) _input.Peek();
                if (cpeek == '>' || cpeek == '=' || cpeek == '/')
                    if (_fincstr)
                    {   
                        return cstr ;
                    }
                    
                //
                // Else, fallthrough and go into the normal loop
                //
            }
    
            if (_fincstr)
            {
                if ((char)_input.Peek() == '<')
                {   
                    return cstr ;
                }
            }
    
            i = _input.Read () ;
            c = (char)i ;
                
            if (i == -1)
            {   
                return -1 ;
            }
    
            else if (FIsWhite (i))
            {
                if (_fincstr) {   
                    return cstr ;
                } 
            }
    
            else if (c == ';')
            {
                if ((char)_input.Peek () == ';')
                {   
                    EatLineComment () ;
                }
                else
                {
                    SBArrayAppend (c) ;
                    _fincstr = true ;
                }
            }
    
            else if (c == '<')
            {
                if ((char)_input.Peek () == '!')
                {   
                    EatXMLComment () ;
                }
                else
                {   
                    _fintag = true ;
                    return bra ;
                }
            }
    
            else if (c == '>')
            {   
                _fintag = false ;
                return ket ;
            }
    
            else if (c == '/')
            {
                if (_fintag)
                {   
                    return slash ;
                }
                else
                {
                    SBArrayAppend (c) ;
                }
            } else if (c=='\"') {
                //We've found a quoted string.  Add the entire thing, including whitespace.
                //For the time being, we'll disallow "'s within the string. (These should strictly be &quot; anyway).
                //I explicitly return this without the "'s.  
                while(true) {
                    i=_input.Read();                    
                    c=(char)i;
                    if (i==-1) {
                        //We found the end of the stream without finding the closing "
                        return -1;
                    }
                    if (c!='\"') {
                        SBArrayAppend(c);
                    } else {
                        break;
                    }
                }
                _fincstr = true;
            }
            else if (c=='=') {
                if (_fintag)
                {
                    return equals;
                }
                else
                {
                    SBArrayAppend (c);
                }
                    
            }
            else
            {
                SBArrayAppend (c) ;
                _fincstr = true ;
            }
        }//end while
    }//end NextTokenType
    
    //================================================================
    //
    //
    internal virtual String GetStringToken ()
    {
        // OK, easy case first, _cstr == null
        if (_cstr == null) {
            // degenerate case
            if (_sbindex == 0) return(null);
            return(new String(_sbarray,0,_sbindex));
        }
        // OK, now we know we have a StringBuilder already, so just append chars
        _cstr.Append(_sbarray,0,_sbindex);
        return(_cstr.ToString());
    }
    
    internal class TokenReader {
    
        private BinaryReader _in;
    
        internal TokenReader(BinaryReader input) {
            _in = input;
        }
    
        internal virtual int Peek() {
            return _in.PeekChar();
        }
    
        internal virtual int Read() {
            return _in.ReadChar();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsudscode\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

SoapSudsCode.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt $(O)\SoapSudsCode.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsudscode\__strongname.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
[assembly: System.Reflection.AssemblyDelaySign(true), System.Reflection.AssemblyKeyFile("FinalPublicKey.snk")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsuds\soapsuds.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SOAPSUDS.cs
//
//  Summary:    Command line program to generate or read SDL and WSDL
//
//  Classes:    SoapSuds
//
//--------------------------------------------------------------------------
//
//==========================================================================

namespace SoapSuds
{
    using System;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.Remoting;
    using System.Resources;
    using System.Text;
    using System.Runtime.Remoting.MetadataServices;
    using SoapSudsCode;
    using System.Globalization;

    public class SoapSuds
    {

        public static int Main(string[] args)
        {
            try
            {

                SoapSudsArgs soapSudsArgs = new SoapSudsArgs();
                bool bInput = false;
                String inputDirectory = null;

                if (args.Length == 0)
                {
                    Usage();
                    return 1;
                }

                // Parse Arguments

                for (int i=0;i<args.Length;i++)
                {
                    if (
                       String.Compare(args[i],"HELP", true, CultureInfo.InvariantCulture) == 0 ||
                       String.Compare(args[i],"?", true, CultureInfo.InvariantCulture) == 0 ||
                       String.Compare(args[i],"/h", true, CultureInfo.InvariantCulture) == 0 ||
                       String.Compare(args[i],"-h", true, CultureInfo.InvariantCulture) == 0 ||
                       String.Compare(args[i],"-?", true, CultureInfo.InvariantCulture) == 0 ||
                       String.Compare(args[i],"/?", true, CultureInfo.InvariantCulture) == 0
                       )
                    {
                        Usage();
                        return 1;
                    }

                    String arg = args[i];
                    String value = null;

                    if (args[i][0] == '/' || args[i][0] == '-')
                    {
                        int index = args[i].IndexOf(':');
                        if (index != -1)
                        {
                            arg = args[i].Substring(1, index-1);

                            // make sure ':' isn't last character
                            if (index == (args[i].Length - 1))
                                throw new ApplicationException(Resource.FormatString("Err_ParamValueEmpty", args[i]));

                            value = args[i].Substring(index+1);
                        }
                        else
                            arg = args[i].Substring(1);
                    }


                    //Process Input Sources
                    if (String.Compare(arg,"urlToSchema", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "url",true, CultureInfo.InvariantCulture) == 0)
                    {
                        if (bInput)
                            throw new ApplicationException(Resource.FormatString("Err_MultipleInputSources", value));

                        bInput = true;
                        soapSudsArgs.urlToSchema = CheckArg(value, "urlToSchema");
                    }
                    else if (String.Compare(arg, "types", true, CultureInfo.InvariantCulture) == 0)
                    {
                        if (bInput)
                            throw new ApplicationException(Resource.FormatString("Err_MultipleInputSources", value));
                        bInput = true;
                        String typesInputString = CheckArg(value, "types");
                        String[] parts = typesInputString.Split(';');

                        soapSudsArgs.serviceTypeInfos = new ServiceTypeInfo[parts.Length];

                        for (int partType = 0;partType < parts.Length; partType++)
                        {
                            String[] part = parts[partType].Split(',');
                            if (part.Length < 2 || part.Length > 3 || 
                                part[0] == null || part[0].Length == 0 ||
                                part[1] == null || part[1].Length == 0)
                                throw new ArgumentException(Resource.FormatString("Err_TypeOption", value));

                            soapSudsArgs.serviceTypeInfos[partType] = new ServiceTypeInfo();
                            soapSudsArgs.serviceTypeInfos[partType].type = part[0];
                            soapSudsArgs.serviceTypeInfos[partType].assembly = part[1];
                            if (part.Length == 3)
                                soapSudsArgs.serviceTypeInfos[partType].serviceEndpoint = part[2];
                        }
                    }
                    else if (String.Compare(arg, "inputSchemaFile", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "is", true, CultureInfo.InvariantCulture) == 0)
                    {
                        if (bInput)
                            throw new ApplicationException(Resource.FormatString("Err_MultipleInputSources", value));
                        bInput = true;
                        soapSudsArgs.inputSchemaFile = CheckArg(value, "inputSchemaFile");
                    }
                    else if (String.Compare(arg, "inputAssemblyFile", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "ia", true, CultureInfo.InvariantCulture) == 0)
                    {
                        if (bInput)
                            throw new ApplicationException(Resource.FormatString("Err_MultipleInputSources", value));
                        bInput = true;
                        soapSudsArgs.inputAssemblyFile = CheckArg(value, "inputAssemblyFile");
                    }

                    // Input Options
                    else if (String.Compare(arg, "inputDirectory", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "id", true, CultureInfo.InvariantCulture) == 0)
                    {
                        inputDirectory = CheckArg(value, "inputDirectory");
                    }
                    else if (String.Compare(arg, "serviceEndpoint", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "se", true, CultureInfo.InvariantCulture) == 0)
                    {
                        soapSudsArgs.serviceEndpoint = CheckArg(value, "serviceEndpoint");
                    }

                    // Output Options
                    else if (String.Compare(arg, "outputSchemaFile", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "os", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.outputSchemaFile = CheckArg(value, "outputSchemaFile");
                    else if (String.Compare(arg, "outputDirectory", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "od", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.outputDirectory = CheckArg(value, "outputDirectory");
                    else if (String.Compare(arg, "outputAssemblyFile", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "oa", true, CultureInfo.InvariantCulture) == 0)
                    {
                        soapSudsArgs.outputAssemblyFile = CheckArg(value, "outputAssemblyFile");
                        if (soapSudsArgs.outputAssemblyFile.EndsWith(".exe") || soapSudsArgs.outputAssemblyFile.EndsWith(".com"))
                            throw new ApplicationException(Resource.FormatString("Err_OutputAssembly", soapSudsArgs.outputAssemblyFile));
                    }

                    // Generate Options
                    else if (String.Compare(arg, "generateCode", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "gc", true, CultureInfo.InvariantCulture) == 0)
                    {
                        soapSudsArgs.gc = true;
                        soapSudsArgs.outputDirectory = ".";
                    }

                    // Other Options
                    else if (String.Compare(arg, "WrappedProxy", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "wp", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.wp = true;
                    else if (String.Compare(arg, "NoWrappedProxy", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "nowp", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.wp = false;
                    else if (String.Compare(arg, "proxyNamespace", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "pn", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.proxyNamespace = CheckArg(value, "proxyNamespace");
                    else if (String.Compare(arg, "sdl", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.sdlType = SdlType.Sdl;
                    else if (String.Compare(arg, "wsdl", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.sdlType = SdlType.Wsdl;
                    else if (String.Compare(arg, "strongNameFile", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "sn", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.strongNameFile = CheckArg(value, "strongNameFile");

                    // Connection Information Options
                    else if (String.Compare(arg, "username", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "u", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.username = CheckArg(value, "username");
                    else if (String.Compare(arg, "password", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "p", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.password = CheckArg(value, "password");
                    else if (String.Compare(arg, "domain", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "d", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.domain = CheckArg(value, "domain");
                    else if (String.Compare(arg, "httpProxyName", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "hpn", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.httpProxyName = CheckArg(value, "httpProxyName");
                    else if (String.Compare(arg, "httpProxyPort", true, CultureInfo.InvariantCulture) == 0 || String.Compare(arg, "hpp", true, CultureInfo.InvariantCulture) == 0)
                        soapSudsArgs.httpProxyPort = CheckArg(value, "httpProxyPort");
                    else
                    {
                        Console.WriteLine(Resource.FormatString("Err_UnknownParameter",arg));
                        return 1;
                    }
                }


                int RetCode = 0;

                // Create an AppDomain to load the implementation part of the app into.
                AppDomainSetup options = new AppDomainSetup();
                if (inputDirectory == null)
                    options.ApplicationBase = Environment.CurrentDirectory;
                else
                    options.ApplicationBase = new DirectoryInfo(inputDirectory).FullName;

                options.ConfigurationFile = AppDomain.CurrentDomain.SetupInformation.ConfigurationFile;


                AppDomain domain = AppDomain.CreateDomain("SoapSuds", null, options);
                if (domain == null)
                    throw new ApplicationException(Resource.FormatString("Err_CannotCreateAppDomain"));

                // Create the remote component that will perform the rest of the conversion.
                AssemblyName n = Assembly.GetExecutingAssembly().GetName();
                AssemblyName codeName = new AssemblyName();
                codeName.Name = "SoapSudsCode";
                codeName.Version = n.Version;
                codeName.SetPublicKey(n.GetPublicKey());
                codeName.CultureInfo = n.CultureInfo;
                ObjectHandle h = domain.CreateInstance(codeName.FullName, "SoapSudsCode.SoapSudsCode");
                if (h == null)
                    throw new ApplicationException(Resource.FormatString("Err_CannotCreateRemoteSoapSuds"));

                SoapSudsCode soapSudsCode = (SoapSudsCode)h.Unwrap();
                if (soapSudsCode != null)
                    RetCode = soapSudsCode.Run(soapSudsArgs);
            }
            catch (Exception e)
            {
                StringBuilder sb = new StringBuilder();
                sb.Append(e.Message);
                while(e.InnerException != null)
                {
                    sb.Append(", ");
                    sb.Append(e.InnerException.Message);
                    e= e.InnerException;
                }
                Console.WriteLine(Resource.FormatString("Err_SoapSuds",sb.ToString()));
                return 1;
            }

            return 0;
        } 

        internal static String CheckArg(String value, String arg)
        {
            if (value == null || value.Length == 0)
                throw new ArgumentException(arg);
            return value;
        }

        internal static void Usage()
        {
            AssemblyName n = Assembly.GetExecutingAssembly().GetName();
            Console.WriteLine(Resource.FormatString("M1", Util.Version.VersionString));
            Console.WriteLine(Resource.FormatString("M2"));
            Console.WriteLine(Resource.FormatString("M3"));
            Console.WriteLine(Resource.FormatString("M4"));
            Console.WriteLine(Resource.FormatString("M5"));
            Console.WriteLine(Resource.FormatString("M6"));
            Console.WriteLine(Resource.FormatString("M7"));
            Console.WriteLine(Resource.FormatString("M8"));
            Console.WriteLine(Resource.FormatString("M9"));
            Console.WriteLine(Resource.FormatString("MA"));
            Console.WriteLine(Resource.FormatString("MB"));
            Console.WriteLine(Resource.FormatString("MC"));
            Console.WriteLine(Resource.FormatString("MD"));
            Console.WriteLine(Resource.FormatString("ME"));
            Console.WriteLine(Resource.FormatString("MF"));
            Console.WriteLine(Resource.FormatString("MG"));
            Console.WriteLine(Resource.FormatString("MH"));
            Console.WriteLine(Resource.FormatString("MI"));
            Console.WriteLine(Resource.FormatString("MJ"));
            Console.WriteLine(Resource.FormatString("MM"));
            Console.WriteLine(Resource.FormatString("MN"));
            Console.WriteLine(Resource.FormatString("MO"));
            Console.WriteLine(Resource.FormatString("MP"));
            Console.WriteLine(Resource.FormatString("MQ"));
            Console.WriteLine(Resource.FormatString("MR"));
            Console.WriteLine(Resource.FormatString("MS"));
            Console.WriteLine(Resource.FormatString("MT"));
            Console.WriteLine(Resource.FormatString("MU"));
            Console.WriteLine(Resource.FormatString("MV"));
            Console.WriteLine(Resource.FormatString("MW"));
            Console.WriteLine(Resource.FormatString("MX"));
            Console.WriteLine(Resource.FormatString("MY"));
            Console.WriteLine(Resource.FormatString("MZ"));
            Console.WriteLine(Resource.FormatString("M10"));
            Console.WriteLine(Resource.FormatString("M11"));
            Console.WriteLine(Resource.FormatString("M12"));
            Console.WriteLine(Resource.FormatString("M13"));
            Console.WriteLine(Resource.FormatString("M14"));
            Console.WriteLine(Resource.FormatString("M15"));
            Console.WriteLine(Resource.FormatString("M16"));
        }



    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsudscode\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace SoapSudsCode {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("SoapSudsCode", 
                                          Assembly.GetAssembly(typeof(SoapSudsCode)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsudscode\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "SoapSuds.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft SoapSuds Utility\0"
#define VER_ORIGFILENAME_STR    "SoapSuds.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\storeadm\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
	copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
	copy $(TARGETPATH)\$(TARGETNAME:.exe=.pdb) $(TARGETCOMPLUS)
!endif

cool_compile_resource: StoreAdm.cs resources.txt
        internalresgen resources.txt storeadm.resources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\secdbedit\secdbedit.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//  SecDBEdit.cool
//
//  SecDBEdit is a command-line utility for manipulating the security database.
//
namespace DefaultNamespace {
    using System;
    using System.Text;
    using System.IO;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.Security.Util;
    using System.Reflection;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.Runtime.Remoting.Activation;
    using System.Globalization;
        
    using ulongint = System.UInt64;

    delegate void OptionHandler( String[] args );
    
    public class SecDBEdit
    {
        // Global instance of the class (allows singleton-esque usage).   
        private static SecDBEdit m_instance;
        
        // The table of options that are recognized
        private static readonly TableEntry[] table =
            { new TableEntry( "-list", new OptionHandler( ListHandler ) ),
              new TableEntry( "-alterxml", new OptionHandler( AlterXMLHandler ) ),
              new TableEntry( "-alterbinary", new OptionHandler( AlterBinaryHandler ) ),
              new TableEntry( "-add", new OptionHandler( AddHandler ) ),
              new TableEntry( "-update", new OptionHandler( UpdateHandler ) ),
              new TableEntry( "-regen", new OptionHandler( RegenHandler ) ),
              new TableEntry( "-verify", new OptionHandler( VerifyHandler ) )
            };

        private static readonly String attrTag = "<CorSecAttrV1/>";
              
        public static void Main( String[] args )
        {
            m_instance = new SecDBEdit();
            
            if (args.Length == 0)
            {
                Help( null, "No arguments supplied" );
            }
            else
            {
                Run( args );
            }
        }
        
        internal static void Run( String[] args )
        {
            for (int index = 0; index < table.Length; ++index)
            {
                if (table[index].option.Equals( args[0] ))
                {
                    try
                    {
                        table[index].handler( args );
                    }
                    catch (Exception)
                    {
                        return;
                    }
                    Console.WriteLine( "Success" );
                    return;
                }
            }
            try
            {
                Error( null, "Invalid option", -1 );
            }
            catch (Exception)
            {
            }
        }
                
        internal static void Error( String which, String message, int errorCode )
        {
            Help( which, "ERROR: " + message );
            // HACK: throw an exception here instead of exiting since we can't always
            // call Runtime.Exit().
            throw new Exception();
        }
        
        
        internal static void Help( String which, String message )
        {
            StringBuilder sb = new StringBuilder();
            sb.Append( "Microsoft (R) .NET Framework SecDBEdit\n" );
            sb.Append( "THE security database manipulation tool\n");
            sb.Append( "Copyright (c) Microsoft Corp 1999-2000. All rights reserved.\n");
            
            Console.WriteLine( sb );
            
            Console.WriteLine( message + "\n" );
            
            Console.WriteLine( "Usage: SecDBEdit <option> <args>\n" );
            
            String[] helpArgs = new String[1];
            helpArgs[0] = "__internal_usage__";
            
            for (int i = 0; i < table.Length; ++i)
            {
                if (which == null || which.Equals( table[i].option ))
                {
                    table[i].handler( helpArgs );
                    Console.WriteLine( "" );
                }
            }
    
        }
        
        
        private static int Get(FileStream f, int[] iVal)
        {
            byte[] bytes = new byte[iVal.Length * 4];
            int r = f.Read( bytes, 0, iVal.Length * 4 );
            Buffer.BlockCopy(bytes, 0, iVal, 0, r);
            return r;
        }    
        
        internal static ArrayList LoadDatabase( String file )
        {
            FileStream indexStream = new FileStream( file + ".idx", FileMode.Open, FileAccess.Read );
            FileStream dbStream = new FileStream( file + ".db", FileMode.Open, FileAccess.Read );
            
            int[] numEntries = new int[1];
            
            if (Get( indexStream, numEntries ) != 4)
                throw new Exception( "Unable to read index file" );
            
            Index[] indices = new Index[numEntries[0]];
            
            int[] int4  = new int[4];
            
            for (int i = 0; i < numEntries[0]; ++i)
            {
                indices[i] = new Index();
                
                if (Get( indexStream, int4 ) != 16)
                    throw new Exception("Unable to get Record # " + i);
    
                indices[i].pXml = int4[0];
                indices[i].cXml = int4[1];
                indices[i].pBinary = int4[2];
                indices[i].cBinary = int4[3];
            }     
            
            ArrayList list = new ArrayList( numEntries[0] );
            
            for (int i = 0; i < numEntries[0]; ++i)
            {
                DatabaseEntry entry = new DatabaseEntry();
    
                if (indices[i].pXml == 0 && indices[i].cXml == 0)
                {
                    entry.xml = null;
                }
                else
                {
                    entry.xml = new byte[indices[i].cXml];
                    
                    dbStream.Seek( indices[i].pXml, SeekOrigin.Begin );
                    
                    if (dbStream.Read( entry.xml, 0, indices[i].cXml ) != indices[i].cXml)
                        throw new Exception( "Unable to get XML record #" + i );
                }
                
                if (indices[i].cBinary == 0)
                {
                    entry.binary = null;
                }
                else
                {
                    entry.binary = new byte[indices[i].cBinary];
                    
                    dbStream.Seek( indices[i].pBinary, SeekOrigin.Begin );
                    
                    if (dbStream.Read( entry.binary, 0, indices[i].cBinary ) != indices[i].cBinary)
                        throw new Exception( "Unable to get Binary record #" + i );
                }
                
                list.Add( entry );
            }
                
            indexStream.Close();
            dbStream.Close();
            
            return list;
        }
        
        internal static void SaveDatabase( String file, ArrayList list )
        {
            //Console.WriteLine( "file = " + file );
            //Console.WriteLine( "list = " + list );
            
            FileStream indexStream = new FileStream( file + ".idx", FileMode.Create, FileAccess.Write );
            FileStream dbStream = new FileStream( file + ".db", FileMode.Create, FileAccess.Write );

            BinaryWriter indexWriter = new BinaryWriter(indexStream);
            BinaryWriter dbWriter = new BinaryWriter(dbStream);
            indexWriter.Write( list.Count );
            
            //Console.WriteLine( "count = " + list.Length );
            
            for (int i = 0; i < list.Count; ++i)
            {
                DatabaseEntry entry = (DatabaseEntry)list[i];
                
                if (entry.xml != null)
                {
                    indexWriter.Write( (int)dbWriter.BaseStream.Position );
                    indexWriter.Write( entry.xml.Length );
                    dbWriter.Write( entry.xml, 0, entry.xml.Length );
                }
                else
                {
                    // No xml for this entry (shouldn't happen, but we'll support), just write zeros
                    // for position and size.
                    indexWriter.Write( 0 );
                    indexWriter.Write( 0 );
                }
                
                if (entry.binary != null)
                {
                    indexWriter.Write( (int)dbWriter.BaseStream.Position );
                    indexWriter.Write( entry.binary.Length );
                    dbWriter.Write( entry.binary, 0, entry.binary.Length );
                }
                else
                {
                    // No xml for this entry (shouldn't happen, but we'll support), just write zeros
                    // for position and size.
                    indexWriter.Write( 0 );
                    indexWriter.Write( 0 );
                }
            }

            indexWriter.Close();
            dbWriter.Close();
        }
         
        internal static String GetStringFromUbyte( byte[] array )
        {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < array.Length; i += 2)
            {
                sb.Append( (char)array[i] );
            }

            return sb.ToString();
        }
       
        internal static SecurityElement GetElementFromUbyte( byte[] array )
        {
            MemoryStream stream = new MemoryStream( array );
            Parser parser = new Parser( new BinaryReader( stream, Encoding.Unicode) );
            
            return parser.GetTopElement();
        }
        
        internal static SecurityElement GetElementFromFile( String file )
        {
            FileStream stream = new FileStream( file, FileMode.Open, FileAccess.Read );
            Parser parser = new Parser( new BinaryReader( stream, Encoding.ASCII) );
            stream.Close();
            return parser.GetTopElement();
        }
        
        internal static byte[] ConvertStringToUbyte( String input )
        {
            if (input == null)
            {
                return null;
            }

            char[] carray = input.ToCharArray();
            int count = carray.Length;
            byte[] bytes = new byte[count*2];
            Buffer.BlockCopy(carray, 0, bytes, 0, count*2);
            return bytes;
        }
        
        internal static void ListHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -list <file>\n    List database entries for file" );
                return;
            }
            
            if (args.Length < 2)
            {
                Error( "-list", "Not enough arguments", -1 );
            }
            
            ArrayList list = null;
            
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception e)
            {
                Error( "-list", "Failed during load - " + e.Message, -1 );
            }

            for (int i = 0; i < list.Count; ++i)
            {
                Console.WriteLine( "**** Entry #" + (i+1) + " *********************" );
                
                if (((DatabaseEntry)list[i]).xml != null)
                {
                    Console.WriteLine( "XML:" );
                    if (IsSecAttr( ((DatabaseEntry)list[i]).xml) )
                        Console.WriteLine( SecAttrToPermSet( ((DatabaseEntry)list[i]).xml ).ToString() );
                    else
                        Console.WriteLine( GetElementFromUbyte( ((DatabaseEntry)list[i]).xml ).ToString() );
                }
                else
                {
                    Console.WriteLine( "No XML entry" );
                }
                
                if (((DatabaseEntry)list[i]).binary != null)
                {
                    String format = null;
                    PermissionSet permSet = new PermissionSet(PermissionState.Unrestricted);
                    try
                    {
                        if ( ((DatabaseEntry)list[i]).binary[0] == '<' )
                        {
                            permSet.FromXml( GetElementFromUbyte( ((DatabaseEntry)list[i]).binary ) );
                            format = "(XML)";
                        }
                        else
                        {
                            BinaryFormatter formatter = new BinaryFormatter();
                            permSet = (PermissionSet)formatter.Deserialize( new MemoryStream( ((DatabaseEntry)list[i]).binary ) );
                            format = "(binary serialization)";
                        }
                    }
                    catch (Exception e)
                    {
                        Error( "-list", "Binary decode failed" + e.ToString(), -1 );
                    }
                    Console.WriteLine( "Binary " + format + ":" );
                    Console.WriteLine( permSet.ToXml().ToString() );
                }
                else
                {
                    Console.WriteLine( "No Binary entry - this equates to the empty set" );
                }
            }
        }
        
        internal static void AlterXMLHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -alterxml <database_file> <entry_num> <xml_file>\n    Change the XML at <entry_num> to be what's in <xml_file>" );
                return;
            }
            
            if (args.Length < 4)
            {
                Error( "-alterxml", "Not enough arguments", -1 );
            }
            
            SecurityElement elt = null;
            
            try
            {
                elt = GetElementFromFile( args[3] );
            }
            catch (Exception)
            {
                Error( "-alterxml", "Unable to open and/or parse XML file - " + args[3], -1 );
            }
            
            ArrayList list = null;
    
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception exc)
            {
                Error( "-alterxml", exc.Message, -1 );
            }
            
            int index = 0;
            
            try
            {
                index = Int32.Parse( args[2] );
            }
            catch (Exception)
            {
                Error( "-alterxml", "Invalid index - not a number", -1 );
            }
            
            if (index < 1 || index > list.Count)
                Error( "-alterxml", "Invalid index - out of range", -1 );
            
            ((DatabaseEntry)list[index - 1]).xml = ConvertStringToUbyte( elt.ToString() );
            
            byte[] array = ConvertStringToUbyte( elt.ToString() );
                
            try
            {
                SaveDatabase( args[1], list );
            }
            catch (Exception)
            {
                Error( "-alterxml", "Error saving database", -1 );
            }
            
        }
    
        internal static void AlterBinaryHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -alterbinary <database_file> <entry_num> <xml_file>\n    Change the Binary at <entry_num> to be what's in <xml_file>" );
                return;
            }
            
            if (args.Length < 4)
            {
                Error( "-alterbinary", "Not enough arguments", -1 );
            }
        
            SecurityElement e = null;
            
            try
            {
                e = GetElementFromFile( args[3] );
            }
            catch (Exception)
            {
                Error( "-alterbinary", "Unable to open and/or parse XML file - " + args[3], -1 );
            }
            
            ArrayList list = null;
    
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception exc)
            {
                Error( "-alterbinary", exc.Message, -1 );
            }
            
            int index = 0;
            
            try
            {
                index = Int32.Parse( args[2] );
            }
            catch (Exception)
            {
                Error( "-alterbinary", "Invalid index - not a number", -1 );
            }
            
            if (index < 1 || index > list.Count)
                Error( "-alterbinary", "Invalid index - out of range", -1 );
            
            MemoryStream stream = new MemoryStream();
            PermissionSet permSet = new PermissionSet(PermissionState.Unrestricted);
            permSet.FromXml( e );
            
            
            BinaryFormatter formatter = new BinaryFormatter();
            formatter.Serialize( stream, permSet );
            
            ((DatabaseEntry)list[index - 1]).binary = stream.ToArray();
    
            try
            {
                SaveDatabase( args[1], list );
            }
            catch (Exception)
            {
                Error( "-alterbinary", "Error saving database", -1 );
            }
        }
        
        internal static void AddHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -add <file>\n    Add an entry to the database in <file>" );
                return;
            }
            
            if (args.Length < 2)
            {
                Error( "-add", "Not enough arguments", -1 );
            }
            
            ArrayList list = null;
    
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception e)
            {
                Error( "-add", e.Message, -1 );
            }
    
            list.Add( new DatabaseEntry() );
            
            try
            {
                SaveDatabase( args[1], list );
            }
            catch (Exception e)
            {
                Error( "-add", "Error saving database - " + e.Message, -1 );
            }
        }
        
        internal static void UpdateHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -update <file>\n    Add translations for database entries with missing binary values" );
                return;
            }
            
            if (args.Length < 2)
            {
                Error( "-update", "Not enough arguments", -1 );
            }
            
            ArrayList list = null;
            
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception e)
            {
                Error( "-update", "Failed during load - " + e.Message, -1 );
            }
            
            for (int i = 0; i < list.Count; ++i)
            {
                if ((((DatabaseEntry)list[i]).xml != null) && (((DatabaseEntry)list[i]).binary == null))
                {
                    try
                    {
                        Console.WriteLine( "Adding binary value for entry #" + (i+1) + ":" );
                        PermissionSet pset;
                        if (IsSecAttr( ((DatabaseEntry)list[i]).xml))
                        {
                            pset = SecAttrToPermSet( ((DatabaseEntry)list[i]).xml );
                            Console.WriteLine( pset.ToString() );
                        }
                        else
                        {
                            SecurityElement elem = GetElementFromUbyte( ((DatabaseEntry)list[i]).xml );
                            Console.WriteLine( elem.ToString() );
                            pset = new PermissionSet( PermissionState.None );
                            pset.FromXml( elem );
                        }
                        MemoryStream stream = new MemoryStream();
                        BinaryFormatter formatter = new BinaryFormatter();
                        formatter.Serialize( stream, pset );
                        ((DatabaseEntry)list[i]).binary = stream.ToArray();
                        
                    }
                    catch (Exception)
                    {
                        Console.WriteLine( "Error converting entry");
                    }
                }
            }

            try
            {
                SaveDatabase( args[1], list );
            }
            catch (Exception)
            {
                Error( "-update", "Error saving database", -1 );
            }
        }
        
        internal static void RegenHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -regen <file> [{binary|xml}]\n    Regenerate translations for database entries with missing binary values" );
                return;
            }
            
            if (args.Length < 2)
            {
                Error( "-regen", "Not enough arguments", -1 );
            }

            bool useBinary = true;

            if (args.Length > 2 && String.Compare( args[2], "xml", true, CultureInfo.InvariantCulture ) == 0)
            {
                useBinary = false;
            }
            
            ArrayList list = null;
            
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception e)
            {
                Error( "-regen", "Failed during load - " + e.Message, -1 );
            }
            
            for (int i = 0; i < list.Count; ++i)
            {
                if ((((DatabaseEntry)list[i]).xml != null))
                {
                    try
                    {
                        Console.WriteLine( "Adding binary value for entry #" + (i+1) + ":" );
                        PermissionSet pset;
                        if (IsSecAttr( ((DatabaseEntry)list[i]).xml))
                        {
                            pset = SecAttrToPermSet( ((DatabaseEntry)list[i]).xml );
                            Console.WriteLine( pset.ToString() );
                        }
                        else
                        {
                            SecurityElement elem = GetElementFromUbyte( ((DatabaseEntry)list[i]).xml );
                            Console.WriteLine( elem.ToString() );
                            pset = new PermissionSet( PermissionState.None );
                            pset.FromXml( elem );
                        }

                        byte[] bArray;

                        // These should be functionally identical to
                        // PermissionSet.EncodeBinary() and
                        // PermissionSet.EncodeXml()

                        if (useBinary)
                        {
                            MemoryStream stream = new MemoryStream();
                            BinaryFormatter formatter = new BinaryFormatter();
                            formatter.Serialize( stream, pset );
                            bArray = stream.ToArray();
                        }
                        else
                        {
                            MemoryStream stream = new MemoryStream();
                            BinaryWriter writer = new BinaryWriter( stream, Encoding.Unicode );
                            writer.Write( pset.ToXml().ToString() );
                            writer.Flush();

                            stream.Position = 2;
                            int countBytes = (int)stream.Length - 2;
                            bArray = new byte[countBytes];
                            stream.Read( bArray, 0, bArray.Length );
                        }

                        ((DatabaseEntry)list[i]).binary = bArray;
                    }
                    catch (Exception)
                    {
                        Console.WriteLine( "Error converting entry");
                    }
                }
            }

            try
            {
                SaveDatabase( args[1], list );
            }
            catch (Exception)
            {
                Error( "-regen", "Error saving database", -1 );
            }
        }
        
        internal static void VerifyHandler( String[] args )
        {
            if (args[0].Equals( "__internal_usage__" ))
            {
                Console.WriteLine( "SecDBEdit -verify <file>\n    Verify that the binary blobs decode without errors in the specified database" );
                return;
            }
            
            if (args.Length < 2)
            {
                Error( "-verify", "Not enough arguments", -1 );
            }
            
            ArrayList list = null;
            
            try
            {
                list = LoadDatabase( args[1] );
            }
            catch (Exception e)
            {
                Error( "-verify", "Failed during load - " + e.Message, -1 );
            }
            
            for (int i = 0; i < list.Count; ++i)
            {
                BinaryFormatter formatter = new BinaryFormatter();
            
                if ((((DatabaseEntry)list[i]).binary != null))
                {
                    try
                    {
                        PermissionSet permSet = (PermissionSet)formatter.Deserialize( new MemoryStream( ((DatabaseEntry)list[i]).binary ) );
                    }
                    catch (Exception e)
                    {
                        Error( "-verify", "Entry #" + i + " failed to verify:\n" + e.ToString(), -2 );
                    }
                }
            }

            try
            {
                SaveDatabase( args[1], list );
            }
            catch (Exception)
            {
                Error( "-verify", "Error saving database", -1 );
            }
        }
        

        internal static bool IsSecAttr(byte[] input)
        {
            if (input.Length < attrTag.Length)
                return false;

            for (int i = 0; i < attrTag.Length; i++)
                if (input[i] != (byte)attrTag[i])
                    return false;

            return true;
        }
        
        internal static PermissionSet SecAttrToPermSet(byte[] input)
        {
            // Convert byte array to string.
            char[] charInput = new char[input.Length - 1];
            for (int i = 0; i < (input.Length - 1); i++)
                charInput[i] = (char)input[i];
            String strInput = new String(charInput);

            // Start with an empty permission set.
            PermissionSet pset = new PermissionSet(PermissionState.None);

            // Remove initial tag.
            strInput = strInput.Substring(attrTag.Length);

            // Divide input up into descriptors for each security attribute
            // (each descriptor is separated with a ';').
            String[] attrs = strInput.Split(new char[] {';'});

            // Process each security attribute individually.
            for (int i = 0; i < attrs.Length; i++) {

                // The last descriptor is always blank (we always append a
                // trailing ';').
                if (attrs[i].Length == 0)
                    break;

                // Break the '@' separated descriptor into its constituent
                // fields.
                String[] fields = attrs[i].Split(new char[] {'@'});

                // The first field is the fully qualified name of the security
                // attribute class.
                Type attrType = Type.GetType(fields[0]);
                if (attrType == null)
                    throw new ArgumentException();

                // Build an argument list for the attribute class constructor
                // (it takes a single SecurityAction enumerated type, which we
                // always set to zero because we don't care what the security
                // action is (it's not encoded in the permission set)).
                Object[] attrArgs = new Object[] { Enum.ToObject(typeof(SecurityAction), 0) };

                // Create an instance of the security attribute class.
                Object attr = Activator.CreateInstance(attrType,attrArgs);
                if (attr == null)
                    throw new ArgumentException();

                // Set any properties or fields on the instance that represent
                // state data.
                for (int j = 1; j < fields.Length; j++) {

                    // First character in the descriptor indicates either a
                    // field ('F') or a property ('P').
                    bool isField = fields[j][0] == 'F';

                    // The field type is encoded in the next two characters.
                    String type = fields[j].Substring(1, 2);

                    // Remove the characters we've already parsed from the field
                    // descriptor.
                    String field = fields[j].Substring(3);

                    // Enumerated types have an extended type description that
                    // includes the fully qualified name of the enumerated value
                    // type. Extract this name and remove it from the field
                    // descriptor.
                    int pos;
                    String enumType = "";
                    if (type == "EN") {
                        pos = field.IndexOf('!');
                        enumType = field.Substring(0, pos);
                        field = field.Substring(pos + 1);
                    }

                    // The field/property name is everything up to the '='. The
                    // textual form of the value is everything after the '=' up
                    // to the end of the descriptor.
                    pos = field.IndexOf('=');
                    String name = field.Substring(0, pos);
                    String value = field.Substring(pos + 1);

                    // Build a one-value argument list for the field/property
                    // set. Need to parse the value string based on the field
                    // type.
                    Object[] args = new Object[1];
                    if (type == "BL")
                        args[0] =(Object)(value == "T");
                    else if (type == "I1")
                        args[0] = (sbyte) Int32.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "I2")
                        args[0] = (short)Int32.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "I4")
                        args[0] = (int)Int32.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "I8")
                        args[0] = (long)Int64.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "U1")
                        args[0] = (byte)Int32.Parse(value, CultureInfo.InvariantCulture); //BUGBUG: Should this use UInt32?
                    else if (type == "U2")
                        args[0] = (ushort)Int32.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "U4")
                        args[0] = (uint)Int32.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "U8")
                        args[0] = (ulongint)Int64.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "R4")
                        args[0] = (float)Double.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "R8")
                        args[0] = (double)Double.Parse(value, CultureInfo.InvariantCulture);
                    else if (type == "CH")
                        args[0] = value[0];
                    else if (type == "SZ") {
                        // Strings are encoded as hex dumps to avoid conflicts
                        // with the separator characters in the descriptors.
                        StringBuilder sb = new StringBuilder();
                        for (int k = 0; k < (value.Length / 2); k++) {
                            String lookup = "0123456789ABCDEF";
                            int ch = (lookup.IndexOf(value[k * 2]) * 16) + lookup.IndexOf(value[(k * 2) + 1]);
                            sb.Append((char)ch);
                        }
                        args[0] = sb.ToString();
                    } else if (type == "EN")
                        args[0] = Enum.ToObject(Type.GetType(enumType),Int32.Parse(value, CultureInfo.InvariantCulture));

                    // Call the property setter or set the field with the value
                    // we've just calculated.
                    attrType.InvokeMember(name,
                                          isField ? BindingFlags.SetField : BindingFlags.SetProperty,
                                          Type.DefaultBinder,
                                          attr,
                                          args); 
                }

                // Ask the security attribute class to generate a class instance
                // for corresponding permission class (taking into account the
                // state data we supplied). There's one special case: if the
                // security custom attribute class is PermissionSetAttribute, a
                // whole permission set is generated instead (which we merge
                // into the current set).
                if (attrType != typeof(PermissionSetAttribute)) {
                    IPermission perm = ((SecurityAttribute)attr).CreatePermission();
                    if (perm == null)
                        throw new ArgumentException();

                    // We really can't cope with non-code access permissions
                    // embedded in mscorlib (we need to place them in separate
                    // sets from CAS perms, and we can't tell the difference
                    // soon enough).
                    if (!(perm is CodeAccessPermission))
                        throw new ArgumentException("Non-CAS perm used in mscorlib, see security team");

                    // Add the permission to the permission set we're accumulating.
                    pset.AddPermission(perm);
                } else {
                    PermissionSet mergePset = ((PermissionSetAttribute)attr).CreatePermissionSet();
                    if (mergePset == null)
                        throw new ArgumentException();

                    // As above, check perm set for non-CAS perms.
                    if (mergePset.ContainsNonCodeAccessPermissions())
                        throw new ArgumentException("Non-CAS perm used in mscorlib, see security team");

                    // Merge the new set into the permission we're building.
                    pset = pset.Union(mergePset);
                }
            }

            // Return the completed permission set.
            return pset;
        }

    }
    
    internal class DatabaseEntry
    {
        internal byte[] xml = null;
        internal byte[] binary = null;
    }
    
    internal class Index
    {
        internal int pXml = 0;
        internal int cXml = 0;
        internal int pBinary = 0;
        internal int cBinary = 0;
    }
    
       
    internal class TableEntry
    {
        public TableEntry( String option, OptionHandler handler )
        {
            this.option = option;
            this.handler = handler;
        }
            
        internal String option;
        internal OptionHandler handler;
    }

    internal class Parser
    {
        private SecurityElement   _ecurr = null ;
        private Tokenizer _t     = null ;
    
        public virtual SecurityElement GetTopElement()
        {
            return _ecurr;
        }
    
        private void MustBe (int tokenType)
        {
            int i = _t.NextTokenType () ;
            if (i != tokenType)
                throw new XmlSyntaxException (_t.LineNo) ;
        }
    
        private String MandatoryTag ()
        {
            String s ;
            
            MustBe (Tokenizer.bra)   ;
            MustBe (Tokenizer.cstr)  ;
            s = _t.GetStringToken () ;
    
            return s ;
        }
    
        private void ParseContents (SecurityElement e)
        {
            //
            // Iteratively collect stuff up until the next end-tag.
            // We've already seen the open-tag.
            //
            ParserStack stack = new ParserStack();
            ParserStackFrame firstFrame = new ParserStackFrame();
            firstFrame.element = e;
            stack.Push( firstFrame );
            
            bool needToBreak = false;
            bool needToPop = false;
            
            while (!stack.IsEmpty())
            {
                ParserStackFrame locFrame = stack.Peek();
                
                for (int i = _t.NextTokenType () ; i != -1 ; i = _t.NextTokenType ())
                {
                    switch (i)
                    {
                    case Tokenizer.cstr:
                        {
                            if (locFrame.intag)
                            {
                                // We're in a tag, so we've found an attribute/value pair.
                                
                                if (locFrame.strValue == null)
                                {
                                    // Found attribute name, save it for later.
                                    
                                    locFrame.strValue = _t.GetStringToken ();
                                }
                                else
                                {
                                    // Found attribute text, add the pair to the current element.
                                    
                                    locFrame.element.AddAttribute( locFrame.strValue, _t.GetStringToken () );
                                    locFrame.strValue = null;
                                }
                            }
                            else
                            {
                                // We're not in a tag, so we've found text between tags.
                                
                                if (locFrame.element.Text == null)
                                    locFrame.element.Text = "" ;
    
                                StringBuilder sb = new StringBuilder (locFrame.element.Text) ;
    
                                //
                                // Separate tokens with single spaces, collapsing whitespace
                                //
                                if (!locFrame.element.Text.Equals (""))
                                    sb.Append (" ") ;
                            
                                sb.Append (_t.GetStringToken ()) ;
                                locFrame.element.Text = sb.ToString () ;
                            }
                        }
                        break ;
        
                    case Tokenizer.bra:
                        locFrame.intag = true;
                        i = _t.NextTokenType () ;
    
                        if (i == Tokenizer.slash)
                        {
                            while ( (i = _t.NextTokenType()) == Tokenizer.cstr)
                                ; // spin; don't care what's in here
        
                            if (i != Tokenizer.ket)
                                throw new XmlSyntaxException (_t.LineNo) ;
         
                            // Found the end of this element
                            stack.Pop();
                            
                            needToBreak = true;

                        }
                        else if (i == Tokenizer.cstr)
                        {
                            // Found a child
                            
                            ParserStackFrame newFrame = new ParserStackFrame();
                            
                            newFrame.element = new SecurityElement (_t.GetStringToken ()) ;
                            
                            locFrame.element.AddChild (newFrame.element) ;
                            
                            stack.Push( newFrame );
                            
                            needToBreak = true;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo) ;
                        }
                        break ;
        
                    case Tokenizer.equals:
                        break;
                        
                    case Tokenizer.ket:
                        if (locFrame.intag)
                        {
                            locFrame.intag = false;
                            continue;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo);
                        }
                        // not reachable
                        
                    case Tokenizer.slash:
                        locFrame.element.Text = null;
                        
                        i = _t.NextTokenType ();
                        
                        if (i == Tokenizer.ket)
                        {
                            // Found the end of this element
                            stack.Pop();
                            
                            needToBreak = true;
                        }
                        else
                        {
                            throw new XmlSyntaxException (_t.LineNo) ;
                        }
                        break;
                        
                        
                    default:
                        throw new XmlSyntaxException (_t.LineNo) ;
                    }
                    
                    if (needToBreak)
                    {
                        needToBreak = false;
                        needToPop = false;
                        break;
                    }
                    else
                    {
                        needToPop = true;
                    }
                }
                if (needToPop)
                {
                    stack.Pop();
                }
            }
        }
    
        private Parser(Tokenizer t)
        {
            _t = t;
            _ecurr       = new SecurityElement( MandatoryTag() );
    
            ParseContents (_ecurr) ;
        }
        
    
        internal Parser (BinaryReader input)
            : this (new Tokenizer (input))
        {
        }
       

        
    }                                              
    
    
    internal class ParserStackFrame
    {
        internal SecurityElement element = null;
        internal bool intag = true;
        internal String strValue = null;
    }    
    
    internal class ParserStack
    {
        private ArrayList m_array;
        
        public ParserStack()
        {
            m_array = new ArrayList();
        }
        
        public virtual void Push( ParserStackFrame element )
        {
            m_array.Add( element );
        }
        
        public virtual ParserStackFrame Pop()
        {
            if (!IsEmpty())
            {
                int count = m_array.Count;
                ParserStackFrame temp = (ParserStackFrame) m_array[count-1];
                m_array.RemoveAt( count-1 );
                return temp;
            }
            else
            {
                throw new Exception( "Stack is empty." );
            }
        }
        
        public virtual ParserStackFrame Peek()
        {
            if (!IsEmpty())
            {
                return (ParserStackFrame) m_array[m_array.Count-1];
            }
            else
            {
                throw new Exception( "Stack is empty." );
            }
        }
        
        public virtual bool IsEmpty()
        {
            return m_array.Count == 0;
        }
        
        public virtual int GetCount()
        {
            return m_array.Count;
        }
        
    }

    internal class Tokenizer 
    {
        private TokenReader         _input   ;
        private bool             _fincstr ;
        private bool             _fintag  ;
        private StringBuilder       _cstr    ;
        private char[]              _sbarray;
        private int                 _sbindex;
        private const int          _sbmaxsize = 128;
    
        // There are five externally knowable token types: bras, kets,
        // slashes, cstrs, and equals.  
    
        internal const int bra    = 0 ;
        internal const int ket    = 1 ;
        internal const int slash  = 2 ;
        internal const int cstr   = 3 ;
        internal const int equals = 4;
    
        public int  LineNo  ;
    
    /*
        //================================================================
        // Constructor opens the file
        //
        Tokenizer (String fn) 
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _fincstr = false ;
            _cstr    = null  ;
            _input   = new TextInputStream (fn) ;
        }
    
    */
        //================================================================
        // Constructor uses given ICharInputStream
        //
        internal Tokenizer (BinaryReader input)
        {
            LineNo  = 1 ;
            _fintag  = false ;
            _fincstr = false ;
            _cstr    = null  ;
            _input   = new TokenReader(input) ;
            _sbarray = new char[_sbmaxsize];
            _sbindex = 0;
        }
    
        //================================================================
        // 
        //
        private void EatLineComment ()
        {
            while (true)
            {
                int  i = _input.Read () ;
                char c = (char)i ;
    
                if (i == -1)
                    return ;
    
                else if ((i == 13) && (_input.Peek () == 10))
                {
                    _input.Read () ;
                    if (_input.Peek() != -1)
                        LineNo ++ ;
                    return ;
                }
            }
        }
    
        //================================================================
        // An XML Comment had better consist of <!- or <!-- followed by 
        // anything up until a -> or -->.  First thing had better be a 
        // bang.  One round through here eats all nested comments,
        // recursively.
        //
        private void
        EatXMLComment () 
        {
            int  i ;
            char c ;
            
            i = _input.Read () ;  c = (char) i ;
    
            if (c != '!')
            {
                throw new XmlSyntaxException (LineNo) ;
            }
    
            i = _input.Peek () ;  c = (char) i ;
    
            if (c != '-')
                // This ain't a comment, and it's somebody else's problem.
                return ;
    
            while (true)
            {
                i = _input.Read () ;  c = (char) i ;
                
                if (c == '-')
                {
                    if (((char)_input.Peek()) == '>')
                    {
                        _input.Read () ;
                        return ;
                    }
                }
    
                if (c == '<')
                {
                    if (((char)_input.Peek ()) == '!')
                        EatXMLComment () ;
                }
    
                if (i == -1)
                    return ;
            }
        }
    
        //================================================================
        // 
        //
        private bool FIsWhite (int j)
        {
            if ((j == 10) && (_input.Peek() != -1))
                LineNo ++ ;
    
            return (j == 32) || (j ==  9)  // Space and tab
                || (j == 13) || (j == 10)  // CR and LF
                ;
        }
    
        //================================================================
        // Parser needs to know types of tokens
        //
        private void SBArrayAppend(char c) {
            // this is the common case
            if (_sbindex != _sbmaxsize) {
                _sbarray[_sbindex] = c;
                _sbindex++;
                return;
            } 
            // OK, first check if we have to init the StringBuilder
            if (_cstr == null) {
                _cstr = new StringBuilder();
            }
            // OK, copy from _sbarray to _cstr
            _cstr.Append(_sbarray,0,_sbmaxsize);
            // reset _sbarray pointer
            _sbarray[0] = c;
            _sbindex = 1;
            return;
        }
    
        internal virtual int NextTokenType ()
        {
            int  i ;
            char c ;
            char cpeek;
    
            _fincstr = false ;
            // If we overflowed last time, clear out any left-over string builder.
            _cstr    = null;
            // reset the buffer
            _sbindex = 0;
            
            while (true)
            {
                if (_fintag)
                {
                    cpeek = (char) _input.Peek();
                    if (cpeek == '>' || cpeek == '=' || cpeek == '/')
                        if (_fincstr)
                        {   
                            return cstr ;
                        }
                    
                    //
                    // Else, fallthrough and go into the normal loop
                    //
                }
    
                if (_fincstr)
                {
                    if ((char)_input.Peek() == '<')
                    {   
                        return cstr ;
                    }
                }
    
                i = _input.Read () ;
                c = (char)i ;
                
                if (i == -1)
                {   
                    return -1 ;
                }
    
                else if (FIsWhite (i))
                {
                    if (_fincstr) {   
                        return cstr ;
                    } 
                }
    
                else if (c == ';')
                {
                    if ((char)_input.Peek () == ';')
                    {   
                        EatLineComment () ;
                    }
                    else
                    {
                        SBArrayAppend (c) ;
                        _fincstr = true ;
                    }
                }
    
                else if (c == '<')
                {
                    if ((char)_input.Peek () == '!')
                    {   
                        EatXMLComment () ;
                    }
                    else
                    {   
                        _fintag = true ;
                        return bra ;
                    }
                }
    
                else if (c == '>')
                {   
                    _fintag = false ;
                    return ket ;
                }
    
                else if (c == '/')
                {
                    if (_fintag)
                    {   
                        return slash ;
                    }
                    else
                    {
                        SBArrayAppend (c) ;
                    }
                } else if (c=='\"') {
                    //We've found a quoted string.  Add the entire thing, including whitespace.
                    //For the time being, we'll disallow "'s within the string. (These should strictly be &quot; anyway).
                    //I explicitly return this without the "'s.  
                    while(true) {
                        i=_input.Read();                    
                        c=(char)i;
                        if (i==-1) {
                            //We found the end of the stream without finding the closing "
                            return -1;
                        }
                        if (c!='\"') {
                            SBArrayAppend(c);
                        } else {
                            break;
                        }
                    }
                    _fincstr = true;
                }
                else if (c=='=') {
                    if (_fintag)
                    {
                        return equals;
                    }
                    else
                    {
                        SBArrayAppend (c);
                    }
                    
                }
                else
                {
                    SBArrayAppend (c) ;
                    _fincstr = true ;
                }
            }//end while
        }//end NextTokenType
    
        //================================================================
        //
        //
        internal virtual String GetStringToken ()
        {
            // OK, easy case first, _cstr == null
            if (_cstr == null) {
                // degenerate case
                if (_sbindex == 0) return(null);
                return(new String(_sbarray,0,_sbindex));
            }
            // OK, now we know we have a StringBuilder already, so just append chars
            _cstr.Append(_sbarray,0,_sbindex);
            return(_cstr.ToString());
        }
    
        internal class TokenReader {
    
            private BinaryReader _in;
    
            internal TokenReader(BinaryReader input) {
                _in = input;
            }
    
            internal virtual int Peek() {
                return _in.PeekChar();
            }
    
            internal virtual int Read() {
                return _in.ReadChar();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\storeadm\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "STOREADM.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Framework Store Admin\0"
#define VER_ORIGFILENAME_STR    "storeadm.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\soapsuds\soapsudscode\soapsudscode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//==========================================================================
//  File:       SoapSudsCode.cs
//
//  Summary:    Command line program to generate or read SDL and WSDL
//
//  Classes:    SoapSudsCode
//
//--------------------------------------------------------------------------
//
//==========================================================================

namespace SoapSudsCode
{
	using System;
	using System.IO;
	using System.Collections;
	using System.Net;
	using System.Reflection;
	using System.Runtime.Remoting;
	using System.Resources;
	using System.Runtime.Remoting.MetadataServices;
	using System.Text;
    using System.Threading;
    using System.Globalization;

    [Serializable()] 
	public sealed class SoapSudsArgs
	{
		public String urlToSchema = null;
		public ServiceTypeInfo[] serviceTypeInfos = null;
		public String inputSchemaFile = null;
		public String inputAssemblyFile = null;
		public String serviceEndpoint = null;
		public String outputSchemaFile = null;
		public String outputDirectory = null;
		public String outputAssemblyFile = null;
		public bool gc = false;
		public bool wp = true;
		public String proxyNamespace = null;
		public SdlType sdlType = SdlType.Wsdl;
		public String strongNameFile = null;
		public String username = null;
		public String password = null;
		public String domain = null;
		public String httpProxyName = null;
		public String httpProxyPort = null;
	}

    [Serializable()] 
	public sealed class ServiceTypeInfo
	{
        public String type = null;
		public String assembly = null;
		public String serviceEndpoint = null;
	}


	public class SoapSudsCode : MarshalByRefObject
	{
		public int Run(SoapSudsArgs args)
		{
			try
			{
				ProcessCommand(args);
			}
			catch (Exception e)
			{
                StringBuilder sb = new StringBuilder();
                sb.Append(e.Message);
                while(e.InnerException != null)
                {
                    sb.Append(", ");
                    sb.Append(e.InnerException.Message);
                    e= e.InnerException;
                }
                Console.WriteLine(Resource.FormatString("Err_SoapSuds",sb.ToString()));
                return 1;
			}
			return 0;
		}

		internal void ProcessCommand(SoapSudsArgs args)
		{
			ServiceType[] serviceTypes = null;
			Type[] assemblyTypes = null;
			bool generateCode = false;
			bool schemaGenerated = false;
            bool btempdirectory = false;
            DirectoryInfo dir = null;
			ArrayList outCodeStreamList = new ArrayList();

			if (args.serviceTypeInfos != null)
			{
				serviceTypes = new ServiceType[args.serviceTypeInfos.Length];
				Type type;
				Assembly assem;

				for (int i=0; i<args.serviceTypeInfos.Length; i++)
				{
					try
					{
						assem = Assembly.Load(args.serviceTypeInfos[i].assembly);
					}
					catch (Exception ex)
					{
                        String baseDirectory = Thread.GetDomain().BaseDirectory;
                        String assemName = args.serviceTypeInfos[i].assembly;
                        if (assemName.EndsWith(".dll") || assemName.EndsWith(".exe"))
                            throw new ApplicationException(Resource.FormatString("Err_AssemblyName", args.serviceTypeInfos[i].assembly, baseDirectory), ex);
                        else
                            throw new ApplicationException(Resource.FormatString("Err_Assembly", args.serviceTypeInfos[i].assembly, baseDirectory), ex);
					}


					if (assem == null)
                    {
                        String baseDirectory = Thread.GetDomain().BaseDirectory;
                        String assemName = args.serviceTypeInfos[i].assembly;
                        if (assemName.EndsWith(".dll") || assemName.EndsWith(".exe"))
                            throw new ApplicationException(Resource.FormatString("Err_AssemblyName", args.serviceTypeInfos[i].assembly, baseDirectory));
                        else
                            throw new ApplicationException(Resource.FormatString("Err_Assembly", args.serviceTypeInfos[i].assembly, baseDirectory));
                    }

					type = assem.GetType(args.serviceTypeInfos[i].type);

					if (type == null)
						throw new ArgumentException(Resource.FormatString("Err_Type", args.serviceTypeInfos[i].type, assem));

					serviceTypes[i] = new ServiceType(type, args.serviceTypeInfos[i].serviceEndpoint);
				}
			}

			if (args.inputSchemaFile != null)
			{
				FileInfo file = new FileInfo(args.inputSchemaFile);
				if (!(file.Exists))
					throw new ApplicationException(Resource.FormatString("Err_InputSchemaFileNotFound", args.inputSchemaFile));
			}

			if (args.inputAssemblyFile != null) // input assembly
			{
				try
				{
					Assembly assem = Assembly.Load(args.inputAssemblyFile);
					if (assem == null)
                    {
                        String baseDirectory = Thread.GetDomain().BaseDirectory;
                        String assemName = args.inputAssemblyFile;
                        if (assemName.EndsWith(".dll") || assemName.EndsWith(".exe"))
                            throw new ApplicationException(Resource.FormatString("Err_AssemblyName", args.inputAssemblyFile, baseDirectory));
                        else
                            throw new ApplicationException(Resource.FormatString("Err_Assembly", args.inputAssemblyFile, baseDirectory));
                    }

					assemblyTypes = assem.GetExportedTypes();
                    serviceTypes = new ServiceType[assemblyTypes.Length];
                    for (int i=0; i<serviceTypes.Length; i++)
                        serviceTypes[i] = new ServiceType(assemblyTypes[i], args.serviceEndpoint);
				}
				catch (Exception ex)
				{
                    String baseDirectory = Thread.GetDomain().BaseDirectory;
                    String assemName = args.inputAssemblyFile;
                    if (assemName.EndsWith(".dll") || assemName.EndsWith(".exe"))
                        throw new ApplicationException(Resource.FormatString("Err_AssemblyName", args.inputAssemblyFile, baseDirectory), ex);
                    else
                        throw new ApplicationException(Resource.FormatString("Err_Assembly", args.inputAssemblyFile, baseDirectory), ex);
				}
			}

            if (args.outputDirectory == null)
            {
                // Create a temp subdirectory in the temp directory
                // loop until a directory can be created
                String temppath = Path.GetTempPath();
                Random ran = new Random();
                while(true)
                {
                    try
                    {
                        dir =Directory.CreateDirectory (temppath+"\\SS"+ran.Next(10000).ToString("X")+".tmp");
                        break;
                    }
                    catch{}
                }

                args.outputDirectory = dir.FullName;
                generateCode = true; 
                btempdirectory = true;
            }
            else
            {
                // See if specified directory exists
                dir = new DirectoryInfo(args.outputDirectory);
                if (!(dir.Exists))
					throw new ApplicationException(Resource.FormatString("Err_odInvalidDirectory", args.outputDirectory));
                generateCode = true; 
            }


			//
			// GENERATE SCHEMA
			//

			bool bOutputOptionProvided = false; // tracks whether an output option was provided
			

			schemaGenerated = false;
			MemoryStream outSchemaStream = new MemoryStream();

			if (args.inputSchemaFile != null) // copy schema file to schema output stream
			{
				Stream fs = File.OpenRead(args.inputSchemaFile);
				int chunkSize = 1024;
				byte[] buffer = new byte[chunkSize];
				int bytesRead;
				do 
				{
					bytesRead = fs.Read(buffer, 0, chunkSize);
					if (bytesRead > 0)
						outSchemaStream.Write(buffer, 0, bytesRead);
				} while (bytesRead == chunkSize);
				fs.Close();

				schemaGenerated = true;
			}

			if (serviceTypes != null)
			{
				MetaData.ConvertTypesToSchemaToStream(serviceTypes, args.sdlType, outSchemaStream);
				schemaGenerated = true;
			}

			if (args.urlToSchema != null) // pull schema from the web
			{
				try
				{
					RetrieveSchemaFromUrl(args.urlToSchema, outSchemaStream, args);
					schemaGenerated = true;
				}
				catch (Exception ex)
				{
                    String errorMsg = Resource.FormatString("Err_urlSchema",args.urlToSchema);

                    if (!args.urlToSchema.ToLower(CultureInfo.InvariantCulture).EndsWith("?wsdl"))
                    {
                        errorMsg += " " + Resource.FormatString("Err_urlMightNeedWsdl");
                    }
				
					throw new ApplicationException(errorMsg, ex);    
				}
			}

			// Ensure that some sort of schema data has been provided
			if (!schemaGenerated)
			{
				throw new ApplicationException(Resource.FormatString("Err_NoSchemaInput"));
			}

			if (args.outputSchemaFile != null) // save schema to file if output requested
			{
                bOutputOptionProvided = true;
			
				outSchemaStream.Position = 0;
				MetaData.SaveStreamToFile(outSchemaStream, args.outputSchemaFile);
			}

			//
			// END OF GENERATE SCHEMA
			//

			if (generateCode || args.outputAssemblyFile != null)
			{
                bOutputOptionProvided = true;
			
				// The out stream stream for the step above, becomes the
				// in schema stream for the code gen
				outSchemaStream.Position = 0;

				try
				{
                    MetaData.ConvertSchemaStreamToCodeSourceStream(args.wp, args.outputDirectory, outSchemaStream, outCodeStreamList, args.urlToSchema, args.proxyNamespace);
				}
				catch (Exception ex)
				{
					throw new ApplicationException(Resource.FormatString("Err_InvalidSchemaData"), ex);
				}
			}


			if (args.outputAssemblyFile != null)
			{
                bOutputOptionProvided = true;
			
				MetaData.ConvertCodeSourceStreamToAssemblyFile(outCodeStreamList, args.outputAssemblyFile, args.strongNameFile);
			}


            if (!bOutputOptionProvided)
            {
			    Console.WriteLine(Resource.FormatString("Err_NoOutputOptionGiven"));
			}
            
            if (btempdirectory)
            {
                // delete temp directory
                dir.Delete(true);
            }

		} // ProcessCommand


		private void RetrieveSchemaFromUrl(String url, Stream outputStream, SoapSudsArgs args) 		
		{
		    WebRequest   request;
            WebResponse  response;
            Stream respStream;					
            TextWriter tw = new StreamWriter(outputStream, new UTF8Encoding(false));

            request = WebRequest.Create(url);

            // Set the credentials
            if ((args.username != null) && (args.password != null))
            {
                if (args.domain == null)
                    request.Credentials = new NetworkCredential(args.username, args.password);
                else
                    request.Credentials = new NetworkCredential(args.username, args.password, args.domain);
            }                    

            // Set the proxy
            if ((args.httpProxyName != null) && (args.httpProxyPort != null))
            {
                int port = Convert.ToInt32(args.httpProxyPort);
                request.Proxy = new WebProxy(args.httpProxyName, port);                    
            }
            
            response = request.GetResponse();
            respStream = response.GetResponseStream();
			StreamReader sr = new StreamReader(respStream);
			tw.Write(sr.ReadToEnd());
            tw.Flush();
		} // RetrieveSchemaFromUrl

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\storeadm\storeadm.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*============================================================
 *
 * Purpose: Administer System.IO.IsolatedStorage
 *
 * Author: Shajan Dasan
 * Date:   Mar 23, 2000
 *
 ===========================================================*/

using System;
using System.Text;
using System.Reflection;
using System.Collections;
using System.IO.IsolatedStorage;
using System.Runtime.InteropServices;
using System.Runtime.CompilerServices;
using System.Globalization;
using System.Resources;

[assembly:AssemblyTitleAttribute("StoreAdm")]

class StoreAdm
{
    // Global settings
    private static bool s_LogoPrinted = false;

    // User input Options
    private static String g_help0;
    private static String g_help1;
    private static String g_help2;
    private static String g_help3;
    private static String g_help4;
    private static String g_help5;
    private static String g_help6;

    private static String g_help;
    private static String g_list;
    private static String g_roaming;
    private static String g_remove;
    private static String g_quiet;

    private static bool  s_list    = false;
    private static bool  s_roaming = false;
    private static bool  s_remove  = false;
    private static bool  s_quiet   = false;

    private static IsolatedStorageScope s_Scope;
    private static ResourceManager s_resmgr; 

    static StoreAdm()
    {
        s_resmgr = new ResourceManager("storeadm", 
            Assembly.GetExecutingAssembly());

        g_help0 = s_resmgr.GetString("g_help0");
        g_help1 = s_resmgr.GetString("g_help1");
        g_help2 = s_resmgr.GetString("g_help2");
        g_help3 = s_resmgr.GetString("g_help3");
        g_help4 = s_resmgr.GetString("g_help4");
        g_help5 = s_resmgr.GetString("g_help5");
        g_help6 = s_resmgr.GetString("g_help6");
    
        g_help    = s_resmgr.GetString("g_help");
        g_list    = s_resmgr.GetString("g_list");
        g_roaming = s_resmgr.GetString("g_roaming");
        g_remove  = s_resmgr.GetString("g_remove");
        g_quiet   = s_resmgr.GetString("g_quiet");
    }

    private static void Print(String str)
    {
        if (s_quiet)
            return;

        PrintLogo();

        Console.Write(str);
    }

    private static void PrintError(String str)
    {
        PrintLogo();
        Console.Write(str);
    }

    private static void Usage()
    {
        Print(Environment.NewLine);
        Print(s_resmgr.GetString("Usage1") + Environment.NewLine);
        Print(s_resmgr.GetString("Usage2") + Environment.NewLine);
        Print(s_resmgr.GetString("Usage3") + Environment.NewLine);
        Print(s_resmgr.GetString("Usage4") + Environment.NewLine);
        Print(s_resmgr.GetString("Usage5") + Environment.NewLine);
        Print(s_resmgr.GetString("Usage6") + Environment.NewLine);
    }

    private static void PrintLogo()
    {
        if (s_quiet || s_LogoPrinted)
            return;

        s_LogoPrinted = true;

        StringBuilder sb = new StringBuilder();

        sb.Append(
            s_resmgr.GetString("Copyright1") + " " + 
            Util.Version.VersionString + 
            Environment.NewLine +
            s_resmgr.GetString("Copyright2") + 
            Environment.NewLine
        );

        Console.WriteLine(sb.ToString());
    }

    private static void Main(String[] arg)
    {
        if (arg.Length == 0)
        {
            PrintLogo();
            Usage();
            return;
        }

        for (int i=0; i<arg.Length; ++i)
        {
            if ((String.Compare(g_help,  arg[i], true, CultureInfo.InvariantCulture) == 0) || 
                (String.Compare(g_help0, arg[i], true, CultureInfo.InvariantCulture) == 0) ||
                (String.Compare(g_help1, arg[i], true, CultureInfo.InvariantCulture) == 0) || 
                (String.Compare(g_help2, arg[i], true, CultureInfo.InvariantCulture) == 0) ||
                (String.Compare(g_help3, arg[i], true, CultureInfo.InvariantCulture) == 0) || 
                (String.Compare(g_help4, arg[i], true, CultureInfo.InvariantCulture) == 0) ||
                (String.Compare(g_help5, arg[i], true, CultureInfo.InvariantCulture) == 0)) {
                PrintLogo();
                Usage();
                return;
            } else if (String.Compare(g_quiet, arg[i], true, CultureInfo.InvariantCulture) == 0) {
                s_quiet = true;
            } else if (String.Compare(g_remove, arg[i], true, CultureInfo.InvariantCulture) == 0) {
                s_remove = true;
            } else if (String.Compare(g_list, arg[i], true, CultureInfo.InvariantCulture) == 0) {
                s_list = true;
            } else if (String.Compare(g_roaming, arg[i], true, CultureInfo.InvariantCulture) == 0) {
                s_roaming = true;
            } else {
                PrintError(s_resmgr.GetString("Unknown_Option") + " ");
                PrintError(arg[i]);
                PrintError(Environment.NewLine);
                Usage();
                return;
            }
        }

        try {
            Execute();
        } catch (Exception e) {
            PrintError(s_resmgr.GetString("Unknown_Error"));
            PrintError(Environment.NewLine);
            PrintError(e.ToString());
            PrintError(Environment.NewLine);
        }
    }

    private static void Execute()
    {
        if (s_roaming)
            s_Scope = IsolatedStorageScope.User | IsolatedStorageScope.Roaming;
        else
            s_Scope = IsolatedStorageScope.User; 

        if (s_remove)
            Remove();

        if (s_list)
            List();
    }

    private static void Remove()
    {
        try {
            IsolatedStorageFile.Remove(s_Scope);
        } catch (Exception) {
            PrintError(s_resmgr.GetString("Remove_Error"));
            PrintError(Environment.NewLine);
        }
    }

    private static void List()
    {
        IEnumerator e =
            IsolatedStorageFile.GetEnumerator(s_Scope);
        IsolatedStorageFile isf;
        IsolatedStorageScope scope;
        int i = 0;

        while (e.MoveNext())
        {
            ++i;
            isf = (IsolatedStorageFile) e.Current;
            scope = isf.Scope;

            Print(s_resmgr.GetString("Record_Number"));
            Print(i.ToString());
            Print(Environment.NewLine);

            if ((scope & IsolatedStorageScope.Domain) != 0)
            {
                Print(s_resmgr.GetString("Domain") + Environment.NewLine);
                Print(isf.DomainIdentity.ToString());
                Print(Environment.NewLine);
            }

            if ((scope & IsolatedStorageScope.Assembly) != 0)
            {
                Print(s_resmgr.GetString("Assembly") + Environment.NewLine);
                Print(isf.AssemblyIdentity.ToString());
                Print(Environment.NewLine);
            }

            if (!s_roaming)
            {
                Print("\t" + s_resmgr.GetString("Size") + " ");
                Print(isf.CurrentSize.ToString());
                Print(Environment.NewLine);
            }

            isf.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexp\commandline.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections;
using System.Globalization;

namespace TlbExp {

internal class Option
{
    private String m_strName;
    private String m_strValue;

    public Option(String strName, String strValue)
    {
        m_strName = strName;
        m_strValue = strValue;
    }

    public String Name { get { return m_strName; } }
    public String Value { get { return m_strValue; } }
}

internal class Abbrevs
{
    private String[] m_aOptions;
    private bool[] m_bRequiresValue;
    private bool[] m_bCanHaveValue;

    public Abbrevs(String[] aOptions)
    {
        m_aOptions = new String[aOptions.Length];
        m_bRequiresValue = new bool[aOptions.Length];
        m_bCanHaveValue = new bool[aOptions.Length];

        // Store option list in lower case for canonical comparison.
        for (int i = 0; i < aOptions.Length; i++)
        {
            String strOption = aOptions[i].ToLower(CultureInfo.InvariantCulture);

            // A leading '*' implies the option requires a value
            // (the '*' itself is not stored in the option name).
            if (strOption.StartsWith("*"))
            {
                m_bRequiresValue[i] = true;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }
            else if (strOption.StartsWith("+"))
            {
                m_bRequiresValue[i] = false;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }

            m_aOptions[i] = strOption;
        }
    }

    public String Lookup(String strOpt, out bool bRequiresValue, out bool bCanHaveValue)
    {
        String strOptLower = strOpt.ToLower(CultureInfo.InvariantCulture);
        int i;
        bool bMatched = false;
        int iMatch = -1;

        // Compare option to stored list.
        for (i = 0; i < m_aOptions.Length; i++)
        {
            // Exact matches always cause immediate termination of
            // the search (else with options foo and foobar, the user
            // could never specify foo unambiguously).
            if (strOptLower.Equals(m_aOptions[i]))
            {
                bRequiresValue = m_bRequiresValue[i];
                bCanHaveValue = m_bCanHaveValue[i];
                return m_aOptions[i];
            }

            // Check for potential match (the input word is a prefix
            // of the current stored option).
            if (m_aOptions[i].StartsWith(strOptLower))
            {
                // If we've already seen a prefix match then the
                // input word is ambiguous.
                if (bMatched)
                    throw new ApplicationException(Resource.FormatString("Err_AmbigousOption", strOpt));

                // Remember this partial match.
                bMatched = true;
                iMatch = i;
            }
        }

        // If we get here with bMatched set, we saw one and only one
        // partial match, so we've got a winner.
        if (bMatched)
        {
            bRequiresValue = m_bRequiresValue[iMatch];
            bCanHaveValue = m_bCanHaveValue[iMatch];
            return m_aOptions[iMatch];
        }

        // Else the word doesn't match at all.
        throw new ApplicationException(Resource.FormatString("Err_UnknownOption", strOpt));
    }
}

internal class CommandLine
{
    private String[] m_aArgList;
    private Option[] m_aOptList;
    private int m_iArgCursor;
    private int m_iOptCursor;
    private Abbrevs m_sValidOptions;

    public CommandLine(String[] aArgs, String[] aValidOpts)
    {
        int i, iArg, iOpt;

        // Keep a list of valid option names.
        m_sValidOptions = new Abbrevs(aValidOpts);

        // Temporary lists of raw arguments and options and their
        // associated values.
        String[] aArgList = new String[aArgs.Length];
        Option[] aOptList = new Option[aArgs.Length];

        // Reset counters of raw arguments and option/value pairs found
        // so far.
        iArg = 0;
        iOpt = 0;

        // Iterate through words of command line.
        for (i = 0; i < aArgs.Length; i++)
        {
            // Check for option or raw argument.
            if (aArgs[i].StartsWith("/") ||
                aArgs[i].StartsWith("-"))
            {
                String strOpt;
                String strVal = null;
                bool bRequiresValue;
                bool bCanHaveValue;

                // It's an option. Strip leading '/' or '-' and
                // anything after a value separator (':' or
                // '=').
                int iColon = aArgs[i].IndexOfAny(new char[] {':', '='});
                if (iColon == -1)
                        strOpt = aArgs[i].Substring(1);
                else
                        strOpt = aArgs[i].Substring(1, iColon - 1);

                // Look it up in the table of valid options (to
                // check it exists, get the full option name and
                // to see if an associated value is expected).
                strOpt = m_sValidOptions.Lookup(strOpt, out bRequiresValue, out bCanHaveValue);

                // Check that the user hasn't specified a value separator for an option 
                // that doesn't take a value.
                if (!bCanHaveValue && (iColon != -1))
                    throw new ApplicationException(Resource.FormatString("Err_NoValueRequired", strOpt));

                // Check that the user has put a colon if the option requires a value.
                if (bRequiresValue && (iColon == -1))
                    throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                
                // Go look for a value if there is one.
                if (bCanHaveValue && iColon != -1)
                {
                    if (iColon == (aArgs[i].Length - 1))
                    {
                        // No value separator, or
                        // separator is at end of
                        // option; look for value in
                        // next command line arg.
                        if (i + 1 == aArgs.Length)
                        {
                            throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                        }
                        else
                        {
                            if ((aArgs[i + 1].StartsWith( "/" ) || aArgs[i + 1].StartsWith( "-" )))
                                throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));

                            strVal = aArgs[i+1];
                            i++;
                        }
                    }
                    else
                    {
                        // Value is in same command line
                        // arg as the option, substring
                        // it out.
                        strVal = aArgs[i].Substring(iColon + 1);
                    }
                }

                // Build the option value pair.
                aOptList[iOpt++] = new Option(strOpt, strVal);
            }
            else
            {
                // Command line word is a raw argument.
                aArgList[iArg++] = aArgs[i];
            }
        }

        // Allocate the non-temporary arg and option lists at exactly
        // the right size.
        m_aArgList = new String[iArg];
        m_aOptList = new Option[iOpt];

        // Copy in the values we've calculated.
        Array.Copy(aArgList, m_aArgList, iArg);
        Array.Copy(aOptList, m_aOptList, iOpt);

        // Reset enumeration cursors to start of lists.
        m_iArgCursor = 0;
        m_iOptCursor = 0;
    }

    public int NumArgs { get { return m_aArgList.Length; } }

    public int NumOpts { get { return m_aOptList.Length; } }

    public String GetNextArg()
    {
        if (m_iArgCursor >= m_aArgList.Length)
            return null;
        return m_aArgList[m_iArgCursor++];
    }

    public Option GetNextOption()
    {
        if (m_iOptCursor >= m_aOptList.Length)
            return null;
        return m_aOptList[m_iOptCursor++];
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexp\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\TlbExp.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt TlbExp.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexp\process.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Reflection;
using System.Runtime.InteropServices;

namespace TlbExp {

[StructLayout(LayoutKind.Sequential)]
internal class StartupInfo
{
    public int cb; 
    public String lpReserved; 
    public String lpDesktop; 
    public String lpTitle; 
    public int dwX; 
    public int dwY; 
    public int dwXSize; 
    public int dwYSize; 
    public int dwXCountChars; 
    public int dwYCountChars; 
    public int dwFillAttribute; 
    public int dwFlags; 
    public UInt16 wShowWindow; 
    public UInt16 cbReserved2; 
    public Byte  lpReserved2; 
    public int hStdInput; 
    public int hStdOutput; 
    public int hStdError; 

    public StartupInfo()
    {
        cb = System.Runtime.InteropServices.Marshal.SizeOf(this);
        lpReserved = null;
        lpDesktop = null;
        lpTitle = null;
        dwX = dwY = dwXSize = dwYSize = dwXCountChars = dwYCountChars = dwFillAttribute = dwFlags = 0;
        wShowWindow = cbReserved2 = 0;
        lpReserved2 = 0;
        hStdInput = hStdOutput = hStdError = 0;
    }
}

[StructLayout(LayoutKind.Sequential)]
internal class ProcessInformation
{
    public int hProcess; 
    public int hThread; 
    public int dwProcessId; 
    public int dwThreadId; 

    public ProcessInformation()
    {
        hProcess = hThread = 0;
        dwProcessId = dwThreadId = 0;
    }
}

internal class Win32Process
{
    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    public static extern Boolean CreateProcess(
        String lpApplicationName,
        String lpCommandLine,
        UInt32 lpProcessAttributes, 
        UInt32 lpThreadAttributes, 
        Boolean bInheritHandles,
        UInt32 dwCreationFlags,
        UInt32 lpEnvironment,
        String lpCurrentDirectory,
        [In] StartupInfo lpStartupInfo, 
        [Out] ProcessInformation lpProcessInformation);

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    public static extern Boolean CloseHandle(int hObject);

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    public static extern int WaitForSingleObject(int hHandle, int dwMilliseconds);

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    public static extern Boolean GetExitCodeProcess(int hProcess, [In, Out] ref int lpExitCode);

    public static int RunCommand(String application, String command)
    {
        StartupInfo si = new StartupInfo();
        ProcessInformation pi = new ProcessInformation();
        int dwExitCode = 0;
        
        si.cb = System.Runtime.InteropServices.Marshal.SizeOf(si); //68

        try
        {
            if (CreateProcess (application, command, (UInt32)0, (UInt32)0, true, (UInt32)0, (UInt32)0, null, si, pi))
            {
                CloseHandle (pi.hThread);
                WaitForSingleObject (pi.hProcess, Int32.MaxValue /*INFINITE*/);
                GetExitCodeProcess (pi.hProcess, ref dwExitCode);
                CloseHandle (pi.hProcess);
            }
            else
            {
                Console.WriteLine("RunCommand: ERROR: Unable to run \"" + command + "\"");
            }
        } 
        catch (Exception e) 
        { 
            Console.WriteLine(e); 
        }

        return dwExitCode;
    }

    public static int RunCommand(String application, String[] args)
    {
        String command = application;

        for (int i = 0; i < args.Length; ++i)
        {
            bool bQuote = args[i].IndexOf(' ') >= 0;
            command = command + ' ';
            if (bQuote)
                command = command + '"';
            command = command + args[i];
            if (bQuote)
                command = command + '"';
        }
        
        return RunCommand(null, command);
    }

    public static bool ReInvoke(String[] args, ref int dwExitCode)
    {
        try
        {
            String file = "file://";
            
            // Get the current application.
            String application = System.Reflection.Assembly.GetExecutingAssembly().GetName().CodeBase;
            if (application.Length > file.Length)
            {
                if (System.String.Compare(application.Substring(0, file.Length), file, false /*case sensitive*/, CultureInfo.InvariantCulture) == 0) {
                    if (application[file.Length] == '/')
                        application = application.Substring(file.Length+1);
                    else
                        application = application.Substring(file.Length);
                }
            }
            
            // Run it with the given args.          
            dwExitCode = RunCommand(application, args);
        }
        catch (Exception e)
        {
            Console.WriteLine("Re-invocation of application failed: "+e.Message);
            return false;
        }
        
        return true;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexp\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "TLBEXP.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Assembly to Type Library Converter\0"
#define VER_ORIGFILENAME_STR    "TlbExp.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexp\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace TlbExp {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("TlbExp", 
                                          Assembly.GetAssembly(typeof(TlbExp)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexpcode\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\TlbExpCode.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt TlbExpCode.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
!if "$(TARGETCOMPLUS)" != ""
    copy $(TARGETPATH)\$(TARGETNAME) $(TARGETCOMPLUS)
!endif
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexpcode\remotetlbexp.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace TlbExpCode {

public class RemoteTlbExp : MarshalByRefObject
{
    public int Run(TlbExpOptions s_options)
    {
        return TlbExpCode.Run(s_options);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexpcode\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace TlbExpCode {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("TlbExpCode", 
                                          Assembly.GetAssembly(typeof(TlbExpCode)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexp\tlbexp.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Resources;
using System.Collections;
using System.Runtime.Remoting;
using System.Globalization;
using TlbExpCode;

[assembly:ComVisible(false)]

namespace TlbExp {

public class TlbExp
{
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;
    
    // This is the driver for the typelib exporter.
    public static int Main(String []aArgs)
    {
        int RetCode = SuccessReturnCode;

        // Parse the command line arguments.
        if (!ParseArguments(aArgs, ref s_Options, ref RetCode))
            return RetCode;
        
        // If we are not in silent mode then print the RegAsm logo.
        if (!s_Options.m_bSilentMode)
            PrintLogo();
        
        return Run();
    }

    public static int Run()
    {
        String strAsmDir = null;
        String strInitCurrDir = null;
        int RetCode = SuccessReturnCode;

        try
        {
            // Call SearchPath to find the full path of the typelib to load.
            StringBuilder sb = new StringBuilder(MAX_PATH + 1);
            if (SearchPath(null, s_Options.m_strAssemblyName, null, sb.Capacity + 1, sb, null) == 0)
                throw new ApplicationException(Resource.FormatString("Err_InputFileNotFound", s_Options.m_strAssemblyName));
            s_Options.m_strAssemblyName = sb.ToString();
            
            // Retrieve the full path name of the assembly and output files.
            s_Options.m_strAssemblyName = (new FileInfo(s_Options.m_strAssemblyName)).FullName;
            if (s_Options.m_strTypeLibName != null)
                s_Options.m_strTypeLibName = (new FileInfo(s_Options.m_strTypeLibName)).FullName;

            // Retrieve the full path name of any names file.
            if (s_Options.m_strNamesFileName != null)
                s_Options.m_strNamesFileName = (new FileInfo(s_Options.m_strNamesFileName)).FullName;

            // Verify that the output typelib will not overwrite the input assembly.
            if (s_Options.m_strTypeLibName != null)
            {
                // Make sure the registry file will not overwrite the input file.
                if (String.Compare(s_Options.m_strAssemblyName, s_Options.m_strTypeLibName, true, CultureInfo.InvariantCulture) == 0)
                    throw new ApplicationException(Resource.FormatString("Err_OutputWouldOverwriteInput"));

                if (!Directory.Exists( Path.GetDirectoryName( s_Options.m_strTypeLibName ) ))
                {
                    Directory.CreateDirectory( Path.GetDirectoryName( s_Options.m_strTypeLibName ) );
                }
            }

            // Retrieve the directory of the assembly.
            strAsmDir = Path.GetDirectoryName(s_Options.m_strAssemblyName);

            // Retrieve the initial current directory.
            strInitCurrDir = Environment.CurrentDirectory;

            // If the assembly has a directory specified change to that directory.
            if (strAsmDir != null && strAsmDir.Length != 0 && String.Compare(strInitCurrDir, strAsmDir, true, CultureInfo.InvariantCulture) != 0)
                Environment.CurrentDirectory = strAsmDir;

            // Set the output directory.
            if (s_Options.m_strTypeLibName != null && Path.GetDirectoryName(s_Options.m_strTypeLibName) != null)
                s_Options.m_strOutputDir = Path.GetDirectoryName(s_Options.m_strTypeLibName);
            else
                s_Options.m_strOutputDir = strInitCurrDir;

            // Create an AppDomain to load the implementation part of the app into.
            AppDomainSetup options = new AppDomainSetup();
            options.ApplicationBase = strAsmDir;
            AppDomain domain = AppDomain.CreateDomain("TlbExp", null, options);
            if (domain == null)
                throw new ApplicationException(Resource.FormatString("Err_CannotCreateAppDomain"));

            // Create the remote component that will perform the rest of the conversion.
			String assemblyName = typeof(TlbExpCode.RemoteTlbExp).Assembly.GetName().FullName;
			ObjectHandle h = domain.CreateInstance(assemblyName, "TlbExpCode.RemoteTlbExp");
            if (h == null)
                throw new ApplicationException(Resource.FormatString("Err_CannotCreateRemoteTlbExp"));

            // Have the remote component perform the rest of the conversion.
            RemoteTlbExp code = (RemoteTlbExp) h.Unwrap();
            if(code != null)
                RetCode = code.Run(s_Options);

            // Do not unload the domain, this causes problems with IJW MC++ assemblies that
            // call managed code from DllMain's ProcessDetach notification.
        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            RetCode = ErrorReturnCode;
        }

        return RetCode;
    }

    private static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";        
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
        else
        {
            strErrorMsg += e.GetType().ToString();
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbExpErrorPrefix", strErrorMsg));
    }

    private static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbExpErrorPrefix", strErrorMsg));
    }

    private static bool ParseArguments(String []aArgs, ref TlbExpOptions Options, ref int ReturnCode)
    {
        CommandLine cmdLine;
        Option opt;
        
        // Create the options object that will be returned.
        Options = new TlbExpOptions();
        
        // Parse the command line arguments using the command line argument parser.
        try 
        {
            cmdLine = new CommandLine(aArgs, new String[] { "*out", "nologo", "silent", "verbose", "*names", "?", "help" });
        }
        catch (ApplicationException e)
        {
            PrintLogo();
            WriteErrorMsg(null, e);
            ReturnCode = ErrorReturnCode;
            return false;
        }
        
        // Make sure there is at least one argument.
        if ((cmdLine.NumArgs + cmdLine.NumOpts) < 1)
        {
            PrintUsage();
            ReturnCode = SuccessReturnCode;
            return false;
        }

        // Get the name of the input file.
        Options.m_strAssemblyName = cmdLine.GetNextArg();

        // Go through the list of options.
        while ((opt = cmdLine.GetNextOption()) != null)
        {
            // Determine which option was specified.
            if (opt.Name.Equals("out"))
                Options.m_strTypeLibName = opt.Value;
            else if (opt.Name.Equals("nologo"))
                Options.m_bNoLogo = true;
            else if (opt.Name.Equals("silent"))
                Options.m_bSilentMode = true;
            else if (opt.Name.Equals("verbose"))
                Options.m_bVerboseMode = true;
            else if (opt.Name.Equals("names"))
                Options.m_strNamesFileName = opt.Value;
            else if (opt.Name.Equals("?") || opt.Name.Equals("help"))
            {
                PrintUsage();
                ReturnCode = SuccessReturnCode;
                return false;
            }
            else
            {
                PrintLogo();
                WriteErrorMsg(Resource.FormatString("Err_InvalidOption"));
                ReturnCode = ErrorReturnCode;
                return false;
            }
        }
        
        // Make sure the input file was specified.
        if (Options.m_strAssemblyName == null)
        {
            PrintLogo();
            WriteErrorMsg(Resource.FormatString("Err_NoInputFile"));
            ReturnCode = ErrorReturnCode;
            return false;
        }
        
        return true;
    }
    
    private static void PrintLogo()
    {
        if (!s_Options.m_bNoLogo)
            Console.WriteLine(Resource.FormatString("Msg_Copyright", Util.Version.VersionString));
    }

    private static void PrintUsage()
    {
        // Print the copyright message.
        PrintLogo();

        // Print the usage.
        Console.WriteLine(Resource.FormatString("Msg_Usage"));
    }

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    private static extern Boolean SetEnvironmentVariable(String szName, String szValue);

    internal static TlbExpOptions s_Options = null;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexpcode\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "TLBEXPCODE.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Assembly to Type Library Converter Implementation\0"
#define VER_ORIGFILENAME_STR    "TlbExpCode.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbguid\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\TlbGuid.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt TlbGuid.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexpcode\tlbexpoptions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace TlbExpCode {

[Serializable()] 
public sealed class TlbExpOptions
{
    public String m_strAssemblyName = null;
    public String m_strTypeLibName = null;
    public String m_strOutputDir = null;
    public String m_strNamesFileName = null;
    public bool   m_bNoLogo = false;
    public bool   m_bSilentMode = false;
    public bool   m_bVerboseMode = false;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbguid\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace TlbGuid {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("TlbGuid", 
                                          Assembly.GetAssembly(typeof(TlbGuid)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbguid\commandline.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections;
using System.Globalization;

namespace TlbGuid {

internal class Option
{
    private String m_strName;
    private String m_strValue;

    public Option(String strName, String strValue)
    {
        m_strName = strName;
        m_strValue = strValue;
    }

    public String Name { get { return m_strName; } }
    public String Value { get { return m_strValue; } }
}

internal class Abbrevs
{
    private String[] m_aOptions;
    private bool[] m_bRequiresValue;
    private bool[] m_bCanHaveValue;

    public Abbrevs(String[] aOptions)
    {
        m_aOptions = new String[aOptions.Length];
        m_bRequiresValue = new bool[aOptions.Length];
        m_bCanHaveValue = new bool[aOptions.Length];

        // Store option list in lower case for canonical comparison.
        for (int i = 0; i < aOptions.Length; i++)
        {
            String strOption = aOptions[i].ToLower(CultureInfo.InvariantCulture);

            // A leading '*' implies the option requires a value
            // (the '*' itself is not stored in the option name).
            if (strOption.StartsWith("*"))
            {
                m_bRequiresValue[i] = true;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }
            else if (strOption.StartsWith("+"))
            {
                m_bRequiresValue[i] = false;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }

            m_aOptions[i] = strOption;
        }
    }

    public String Lookup(String strOpt, out bool bRequiresValue, out bool bCanHaveValue)
    {
        String strOptLower = strOpt.ToLower(CultureInfo.InvariantCulture);
        int i;
        bool bMatched = false;
        int iMatch = -1;

        // Compare option to stored list.
        for (i = 0; i < m_aOptions.Length; i++)
        {
            // Exact matches always cause immediate termination of
            // the search (else with options foo and foobar, the user
            // could never specify foo unambiguously).
            if (strOptLower.Equals(m_aOptions[i]))
            {
                bRequiresValue = m_bRequiresValue[i];
                bCanHaveValue = m_bCanHaveValue[i];
                return m_aOptions[i];
            }

            // Check for potential match (the input word is a prefix
            // of the current stored option).
            if (m_aOptions[i].StartsWith(strOptLower))
            {
                // If we've already seen a prefix match then the
                // input word is ambiguous.
                if (bMatched)
                    throw new ApplicationException(Resource.FormatString("Err_AmbigousOption", strOpt));

                // Remember this partial match.
                bMatched = true;
                iMatch = i;
            }
        }

        // If we get here with bMatched set, we saw one and only one
        // partial match, so we've got a winner.
        if (bMatched)
        {
            bRequiresValue = m_bRequiresValue[iMatch];
            bCanHaveValue = m_bCanHaveValue[iMatch];
            return m_aOptions[iMatch];
        }

        // Else the word doesn't match at all.
        throw new ApplicationException(Resource.FormatString("Err_UnknownOption", strOpt));
    }
}

internal class CommandLine
{
    private String[] m_aArgList;
    private Option[] m_aOptList;
    private int m_iArgCursor;
    private int m_iOptCursor;
    private Abbrevs m_sValidOptions;

    public CommandLine(String[] aArgs, String[] aValidOpts)
    {
        int i, iArg, iOpt;

        // Keep a list of valid option names.
        m_sValidOptions = new Abbrevs(aValidOpts);

        // Temporary lists of raw arguments and options and their
        // associated values.
        String[] aArgList = new String[aArgs.Length];
        Option[] aOptList = new Option[aArgs.Length];

        // Reset counters of raw arguments and option/value pairs found
        // so far.
        iArg = 0;
        iOpt = 0;

        // Iterate through words of command line.
        for (i = 0; i < aArgs.Length; i++)
        {
            // Check for option or raw argument.
            if (aArgs[i].StartsWith("/") ||
                aArgs[i].StartsWith("-"))
            {
                String strOpt;
                String strVal = null;
                bool bRequiresValue;
                bool bCanHaveValue;

                // It's an option. Strip leading '/' or '-' and
                // anything after a value separator (':' or
                // '=').
                int iColon = aArgs[i].IndexOfAny(new char[] {':', '='});
                if (iColon == -1)
                        strOpt = aArgs[i].Substring(1);
                else
                        strOpt = aArgs[i].Substring(1, iColon - 1);

                // Look it up in the table of valid options (to
                // check it exists, get the full option name and
                // to see if an associated value is expected).
                strOpt = m_sValidOptions.Lookup(strOpt, out bRequiresValue, out bCanHaveValue);

                // Check that the user hasn't specified a value separator for an option 
                // that doesn't take a value.
                if (!bCanHaveValue && (iColon != -1))
                    throw new ApplicationException(Resource.FormatString("Err_NoValueRequired", strOpt));

                // Check that the user has put a colon if the option requires a value.
                if (bRequiresValue && (iColon == -1))
                    throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                
                // Go look for a value if there is one.
                if (bCanHaveValue && iColon != -1)
                {
                    if (iColon == (aArgs[i].Length - 1))
                    {
                        // No value separator, or
                        // separator is at end of
                        // option; look for value in
                        // next command line arg.
                        if (i + 1 == aArgs.Length)
                        {
                            throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                        }
                        else
                        {
                            if ((aArgs[i + 1].StartsWith( "/" ) || aArgs[i + 1].StartsWith( "-" )))
                                throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));

                            strVal = aArgs[i+1];
                            i++;
                        }
                    }
                    else
                    {
                        // Value is in same command line
                        // arg as the option, substring
                        // it out.
                        strVal = aArgs[i].Substring(iColon + 1);
                    }
                }

                // Build the option value pair.
                aOptList[iOpt++] = new Option(strOpt, strVal);
            }
            else
            {
                // Command line word is a raw argument.
                aArgList[iArg++] = aArgs[i];
            }
        }

        // Allocate the non-temporary arg and option lists at exactly
        // the right size.
        m_aArgList = new String[iArg];
        m_aOptList = new Option[iOpt];

        // Copy in the values we've calculated.
        Array.Copy(aArgList, m_aArgList, iArg);
        Array.Copy(aOptList, m_aOptList, iOpt);

        // Reset enumeration cursors to start of lists.
        m_iArgCursor = 0;
        m_iOptCursor = 0;
    }

    public int NumArgs { get { return m_aArgList.Length; } }

    public int NumOpts { get { return m_aOptList.Length; } }

    public String GetNextArg()
    {
        if (m_iArgCursor >= m_aArgList.Length)
            return null;
        return m_aArgList[m_iArgCursor++];
    }

    public Option GetNextOption()
    {
        if (m_iOptCursor >= m_aOptList.Length)
            return null;
        return m_aOptList[m_iOptCursor++];
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbguid\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "TLBGuid.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft .NET Assembly Type Library GUID viewer\0"
#define VER_ORIGFILENAME_STR    "TlbGuid.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbexp\tlbexpcode\tlbexpcode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;
using System.Globalization;

[assembly:ComVisible(false)]

namespace TlbExpCode {

internal enum REGKIND
{
    REGKIND_DEFAULT         = 0,
    REGKIND_REGISTER        = 1,
    REGKIND_NONE            = 2
}

public class TlbExpCode
{
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;

    public static int Run(TlbExpOptions options)
    {
        s_Options = options;

        int RetCode = SuccessReturnCode;

        try
        {
            // Load the assembly.
            Assembly asm = Assembly.LoadFrom(s_Options.m_strAssemblyName);
            
            // If the typelib name is null then create it from the assembly name.
            if (s_Options.m_strTypeLibName == null)
                s_Options.m_strTypeLibName = Path.Combine(s_Options.m_strOutputDir, asm.GetName().Name) + ".tlb";
            
            // If the input assembly has an embedded type library, give a warning unless we are in silent mode.
            if (!s_Options.m_bSilentMode && (LoadEmbeddedTlb(s_Options.m_strAssemblyName) != null))
                WriteWarningMsg(Resource.FormatString("Wrn_AssemblyHasEmbeddedTlb", s_Options.m_strAssemblyName));

            // Import the typelib to an assembly.
            UCOMITypeLib Tlb = DoExport(asm, s_Options.m_strTypeLibName);
            
            // Display the success message unless silent mode is enabled.
            if (!s_Options.m_bSilentMode)
                Console.WriteLine(Resource.FormatString("Msg_AssemblyExported", s_Options.m_strTypeLibName));
        }
        catch (ReflectionTypeLoadException e)
        {
            int i;
            Exception[] exceptions;
            WriteErrorMsg(Resource.FormatString("Err_TypeLoadExceptions"));
            exceptions = e.LoaderExceptions;
            for (i = 0; i < exceptions.Length; i++)
            {
                try 
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayException", i, exceptions[i]));
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayNestedException", i, ex));
                }
            }
            RetCode = ErrorReturnCode;
        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            RetCode = ErrorReturnCode;
        }

        return RetCode;
    }

    public static UCOMITypeLib DoExport(Assembly asm, String strTypeLibName)
    {
        // Create the TypeLibConverter.
        ITypeLibConverter TLBConv = new TypeLibConverter();
        
        // Convert the assembly.
        ExporterCallback callback = new ExporterCallback();
        UCOMITypeLib Tlb = (UCOMITypeLib)TLBConv.ConvertAssemblyToTypeLib(asm, strTypeLibName, 0, callback);
        
        // Persist the typelib.
        try
        {
            UCOMICreateITypeLib CreateTlb = (UCOMICreateITypeLib)Tlb;
            CreateTlb.SaveAllChanges();
        }
        catch (Exception e)
        {
            ThrowAppException(Resource.FormatString("Err_ErrorSavingTypeLib"), e);
        }
        
        return Tlb;
    }

    private static UCOMITypeLib LoadEmbeddedTlb(String strFileName)
    {
        UCOMITypeLib Tlb = null;

        try
        {
            LoadTypeLibEx(s_Options.m_strAssemblyName, REGKIND.REGKIND_NONE, out Tlb);
        }
        catch (Exception)
        {
        }

        return Tlb;
    }
    
    internal static void ThrowAppException(String strPrefix, Exception e)
    {
        if (strPrefix == null)
            strPrefix = "";

        if (e.Message != null)
        {
            throw new ApplicationException(strPrefix + e.Message);
        }
        else
        {
            throw new ApplicationException(strPrefix + e.GetType().ToString());
        }
    }

    internal static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";        
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
        else
        {
            strErrorMsg += e.GetType().ToString();
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbExpErrorPrefix", strErrorMsg));
    }

    internal static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbExpErrorPrefix", strErrorMsg));
    }

    internal static void WriteWarningMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbExpWarningPrefix", strErrorMsg));
    }

    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    private static extern Boolean SetEnvironmentVariable(String szName, String szValue);
    
    [DllImport("kernel32.dll", SetLastError=true, CharSet=CharSet.Auto)]
    private static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void LoadTypeLibEx(String strTypeLibName, REGKIND regKind, out UCOMITypeLib TypeLib);
   
    internal static TlbExpOptions s_Options;
}

[GuidAttribute("00020406-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
[ComImport]
internal interface UCOMICreateITypeLib
{
    void CreateTypeInfo();       
    void SetName();       
    void SetVersion();        
    void SetGuid();
    void SetDocString();
    void SetHelpFileName();        
    void SetHelpContext();
    void SetLcid();
    void SetLibFlags();
    void SaveAllChanges();
}

internal class ExporterCallback : ITypeLibExporterNotifySink, ITypeLibExporterNameProvider
{
    public void ReportEvent(ExporterEventKind EventKind, int EventCode, String EventMsg)
    {
		if (EventKind == ExporterEventKind.NOTIF_TYPECONVERTED)
		{
			if (TlbExpCode.s_Options.m_bVerboseMode)
				Console.WriteLine(EventMsg);
		}
		else
			Console.WriteLine(EventMsg);
    }
    
    public Object ResolveRef(Assembly asm)
    {
        UCOMITypeLib rslt = null;
        
        // If the typelib name is null then create it from the assembly name.
        String FullyQualifiedTypeLibName = Path.Combine(TlbExpCode.s_Options.m_strOutputDir, asm.GetName().Name) + ".tlb";
        if (TlbExpCode.s_Options.m_bVerboseMode)
            Console.WriteLine(Resource.FormatString("Msg_AutoExportingAssembly", asm.GetName().Name, FullyQualifiedTypeLibName));

        // Make sure the current typelib will not be overriten by the 
        // typelib generated by the assembly being exported.        
        if (String.Compare(FullyQualifiedTypeLibName, TlbExpCode.s_Options.m_strTypeLibName, true, CultureInfo.InvariantCulture) == 0)
        {
            String str = Resource.FormatString("Err_RefTlbOverwrittenByOutput", asm.GetName().Name, FullyQualifiedTypeLibName);
            TlbExpCode.WriteErrorMsg(str);
            throw new ApplicationException(str);
        }

        // Export the typelib for the module.
        rslt = TlbExpCode.DoExport(asm, FullyQualifiedTypeLibName);
        
        return rslt;
    }

	public String[] GetNames()
	{
		if (TlbExpCode.s_Options.m_strNamesFileName == null)
			return new String[0];
	
		string  str;						// An input line.
		System.Collections.ArrayList lst = new System.Collections.ArrayList();	// The output array.
	
		// Open the input file.  Detect encoding based on byte order marks.
		FileStream fs = new FileStream(TlbExpCode.s_Options.m_strNamesFileName, FileMode.Open, FileAccess.Read);
		StreamReader r = new StreamReader(fs, true);
		
		// Start at the beginning.
		r.BaseStream.Seek(0, SeekOrigin.Begin);
	
		// Read each line.
		while ((str=r.ReadLine()) != null)
		{
			// Eliminate comments
			int cKeep = str.IndexOf('#');
			if (cKeep >=  0)
				str = str.Substring(0, cKeep);
	
			// Trim whitespace and don't consider blank lines
			str = str.Trim();
			if (str.Length == 0) 
				continue;
	
			// Got a good line.
			lst.Add(str);
		}
	
		// Done with the input file.
		r.Close();
	
		// Copy the results to an String[]
		String[] rslt = new String[lst.Count];
		Array.Copy(lst.ToArray(), rslt, lst.Count);
	
		return rslt;
	}

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimp\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\TlbImp.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt TlbImp.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbguid\tlbguid.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Text;
using System.Reflection;
using System.Runtime.InteropServices;

[assembly:ComVisible(false)]

namespace TlbGuid {

public class TlbGuid
{
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;
    
    // This is the driver for the typelib exporter.
    public static int Main(String []aArgs)
    {
        int RetCode = SuccessReturnCode;

        // Parse the command line arguments.
        if (!ParseArguments(aArgs, ref s_Options, ref RetCode))
            return RetCode;
        
        // If we are not in silent mode then print the RegAsm logo.
        if (!s_Options.m_bSilentMode)
            PrintLogo();
        
        return Run();
    }

    public static int Run()
    {
        int RetCode = SuccessReturnCode;

        try
        {

            // Retrieve the directory of the assembly.
            Assembly asm = Assembly.LoadFrom(s_Options.m_strAssemblyName);
            
            if(asm != null) {
                Guid g = Marshal.GetTypeLibGuidForAssembly(asm);
                Console.WriteLine(g);
            }
            else
                Console.WriteLine("Error opening assembly: " + s_Options.m_strAssemblyName);

        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            RetCode = ErrorReturnCode;
        }

        return RetCode;
        }

    private static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";        
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
        else
        {
            strErrorMsg += e.GetType().ToString();
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbGuidErrorPrefix", strErrorMsg));
    }

    private static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbGuidErrorPrefix", strErrorMsg));
    }

    private static bool ParseArguments(String []aArgs, ref TlbGuidOptions Options, ref int ReturnCode)
    {
        CommandLine cmdLine;
        Option opt;
        
        // Create the options object that will be returned.
        Options = new TlbGuidOptions();
        
        // Parse the command line arguments using the command line argument parser.
        try 
        {
            cmdLine = new CommandLine(aArgs, new String[] { "nologo", "silent", "?", "help" });
        }
        catch (ApplicationException e)
        {
            PrintLogo();
            WriteErrorMsg(null, e);
            ReturnCode = ErrorReturnCode;
            return false;
        }
        
        // Make sure there is at least one argument.
        if ((cmdLine.NumArgs + cmdLine.NumOpts) < 1)
        {
            PrintUsage();
            ReturnCode = SuccessReturnCode;
            return false;
        }

        // Get the name of the input file.
        Options.m_strAssemblyName = cmdLine.GetNextArg();

        // Go through the list of options.
        while ((opt = cmdLine.GetNextOption()) != null)
        {
            // Determine which option was specified.
            if (opt.Name.Equals("nologo"))
                Options.m_bNoLogo = true;
            else if (opt.Name.Equals("silent"))
                Options.m_bSilentMode = true;
            else if (opt.Name.Equals("?") || opt.Name.Equals("help"))
            {
                PrintUsage();
                ReturnCode = SuccessReturnCode;
                return false;
            }
            else
            {
                PrintLogo();
                WriteErrorMsg(Resource.FormatString("Err_InvalidOption"));
                ReturnCode = ErrorReturnCode;
                return false;
            }
        }
        
        // Make sure the input file was specified.
        if (Options.m_strAssemblyName == null)
        {
            PrintLogo();
            WriteErrorMsg(Resource.FormatString("Err_NoInputFile"));
            ReturnCode = ErrorReturnCode;
            return false;
        }
        
        return true;
    }
    
    private static void PrintLogo()
    {
        if (!s_Options.m_bNoLogo)
            Console.WriteLine(Resource.FormatString("Msg_Copyright", Util.Version.VersionString));
    }

    private static void PrintUsage()
    {
        // Print the copyright message.
        PrintLogo();

        // Print the usage.
        Console.WriteLine(Resource.FormatString("Msg_Usage"));
    }
    
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);
    
    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    private static extern Boolean SetEnvironmentVariable(String szName, String szValue);
    
    internal static TlbGuidOptions s_Options = null;
    }
    

    [Serializable()] 
    public sealed class TlbGuidOptions
    {
        public String m_strAssemblyName = null;
        public bool   m_bNoLogo = false;
        public bool   m_bSilentMode = false;
    }
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimp\commandline.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Reflection.Emit;
using System.Collections;
using System.Globalization;

namespace TlbImp {

internal class Option
{
    private String m_strName;
    private String m_strValue;

    public Option(String strName, String strValue)
    {
        m_strName = strName;
        m_strValue = strValue;
    }

    public String Name { get { return m_strName; } }
    public String Value { get { return m_strValue; } }
}

internal class Abbrevs
{
    private String[] m_aOptions;
    private bool[] m_bRequiresValue;
    private bool[] m_bCanHaveValue;

    public Abbrevs(String[] aOptions)
    {
        m_aOptions = new String[aOptions.Length];
        m_bRequiresValue = new bool[aOptions.Length];
        m_bCanHaveValue = new bool[aOptions.Length];

        // Store option list in lower case for canonical comparison.
        for (int i = 0; i < aOptions.Length; i++)
        {
            String strOption = aOptions[i].ToLower(CultureInfo.InvariantCulture);

            // A leading '*' implies the option requires a value
            // (the '*' itself is not stored in the option name).
            if (strOption.StartsWith("*"))
            {
                m_bRequiresValue[i] = true;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }
            else if (strOption.StartsWith("+"))
            {
                m_bRequiresValue[i] = false;
                m_bCanHaveValue[i] = true;
                strOption = strOption.Substring(1);
            }

            m_aOptions[i] = strOption;
        }
    }

    public String Lookup(String strOpt, out bool bRequiresValue, out bool bCanHaveValue)
    {
        String strOptLower = strOpt.ToLower(CultureInfo.InvariantCulture);
        int i;
        bool bMatched = false;
        int iMatch = -1;

        // Compare option to stored list.
        for (i = 0; i < m_aOptions.Length; i++)
        {
            // Exact matches always cause immediate termination of
            // the search (else with options foo and foobar, the user
            // could never specify foo unambiguously).
            if (strOptLower.Equals(m_aOptions[i]))
            {
                bRequiresValue = m_bRequiresValue[i];
                bCanHaveValue = m_bCanHaveValue[i];
                return m_aOptions[i];
            }

            // Check for potential match (the input word is a prefix
            // of the current stored option).
            if (m_aOptions[i].StartsWith(strOptLower))
            {
                // If we've already seen a prefix match then the
                // input word is ambiguous.
                if (bMatched)
                    throw new ApplicationException(Resource.FormatString("Err_AmbigousOption", strOpt));

                // Remember this partial match.
                bMatched = true;
                iMatch = i;
            }
        }

        // If we get here with bMatched set, we saw one and only one
        // partial match, so we've got a winner.
        if (bMatched)
        {
            bRequiresValue = m_bRequiresValue[iMatch];
            bCanHaveValue = m_bCanHaveValue[iMatch];
            return m_aOptions[iMatch];
        }

        // Else the word doesn't match at all.
        throw new ApplicationException(Resource.FormatString("Err_UnknownOption", strOpt));
    }
}

internal class CommandLine
{
    private String[] m_aArgList;
    private Option[] m_aOptList;
    private int m_iArgCursor;
    private int m_iOptCursor;
    private Abbrevs m_sValidOptions;

    public CommandLine(String[] aArgs, String[] aValidOpts)
    {
        int i, iArg, iOpt;

        // Keep a list of valid option names.
        m_sValidOptions = new Abbrevs(aValidOpts);

        // Temporary lists of raw arguments and options and their
        // associated values.
        String[] aArgList = new String[aArgs.Length];
        Option[] aOptList = new Option[aArgs.Length];

        // Reset counters of raw arguments and option/value pairs found
        // so far.
        iArg = 0;
        iOpt = 0;

        // Iterate through words of command line.
        for (i = 0; i < aArgs.Length; i++)
        {
            // Check for option or raw argument.
            if (aArgs[i].StartsWith("/") ||
                aArgs[i].StartsWith("-"))
            {
                String strOpt;
                String strVal = null;
                bool bRequiresValue;
                bool bCanHaveValue;

                // It's an option. Strip leading '/' or '-' and
                // anything after a value separator (':' or
                // '=').
                int iColon = aArgs[i].IndexOfAny(new char[] {':', '='});
                if (iColon == -1)
                        strOpt = aArgs[i].Substring(1);
                else
                        strOpt = aArgs[i].Substring(1, iColon - 1);

                // Look it up in the table of valid options (to
                // check it exists, get the full option name and
                // to see if an associated value is expected).
                strOpt = m_sValidOptions.Lookup(strOpt, out bRequiresValue, out bCanHaveValue);

                // Check that the user hasn't specified a value separator for an option 
                // that doesn't take a value.
                if (!bCanHaveValue && (iColon != -1))
                    throw new ApplicationException(Resource.FormatString("Err_NoValueRequired", strOpt));

                // Check that the user has put a colon if the option requires a value.
                if (bRequiresValue && (iColon == -1))
                    throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                
                // Go look for a value if there is one.
                if (bCanHaveValue && iColon != -1)
                {
                    if (iColon == (aArgs[i].Length - 1))
                    {
                        // No value separator, or
                        // separator is at end of
                        // option; look for value in
                        // next command line arg.
                        if (i + 1 == aArgs.Length)
                        {
                            throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));
                        }
                        else
                        {
                            if ((aArgs[i + 1].StartsWith( "/" ) || aArgs[i + 1].StartsWith( "-" )))
                                throw new ApplicationException(Resource.FormatString("Err_ValueRequired", strOpt));

                            strVal = aArgs[i+1];
                            i++;
                        }
                    }
                    else
                    {
                        // Value is in same command line
                        // arg as the option, substring
                        // it out.
                        strVal = aArgs[i].Substring(iColon + 1);
                    }
                }

                // Build the option value pair.
                aOptList[iOpt++] = new Option(strOpt, strVal);
            }
            else
            {
                // Command line word is a raw argument.
                aArgList[iArg++] = aArgs[i];
            }
        }

        // Allocate the non-temporary arg and option lists at exactly
        // the right size.
        m_aArgList = new String[iArg];
        m_aOptList = new Option[iOpt];

        // Copy in the values we've calculated.
        Array.Copy(aArgList, m_aArgList, iArg);
        Array.Copy(aOptList, m_aOptList, iOpt);

        // Reset enumeration cursors to start of lists.
        m_iArgCursor = 0;
        m_iOptCursor = 0;
    }

    public int NumArgs { get { return m_aArgList.Length; } }

    public int NumOpts { get { return m_aOptList.Length; } }

    public String GetNextArg()
    {
        if (m_iArgCursor >= m_aArgList.Length)
            return null;
        return m_aArgList[m_iArgCursor++];
    }

    public Option GetNextOption()
    {
        if (m_iOptCursor >= m_aOptList.Length)
            return null;
        return m_aOptList[m_iOptCursor++];
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimpcode\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

$(O)\TlbImpCode.resources: resources.txt
    $(TARGETPATH)\InternalResGen.Exe resources.txt TlbImpCode.resources

cool_target: $(COOL_TARGET) $(O)\$(WIN32_RESOURCE_FILE:.rc=.res)
        gacutil -i $(TARGETPATH)\$(TARGETNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimp\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "TLBIMP.EXE"
#define VER_FILEDESCRIPTION_STR "Microsoft (R) .NET Framework Type Library to Assembly Converter\0"
#define VER_ORIGFILENAME_STR    "TlbImp.exe\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimpcode\remotetlbimp.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;

namespace TlbImpCode {

public class RemoteTlbImp : MarshalByRefObject
{
    public int Run(TlbImpOptions s_options)
    {
        return TlbImpCode.Run(s_options);
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimpcode\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace TlbImpCode {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("TlbImpCode", 
                                          Assembly.GetAssembly(typeof(TlbImpCode)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimp\resource.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Resources;
using System.Reflection;

namespace TlbImp {

internal class Resource
{
    // For string resources located in a file:
    private static ResourceManager _resmgr;
    
    private static void InitResourceManager()
    {
        if(_resmgr == null)
        {
            _resmgr = new ResourceManager("TlbImp", 
                                          Assembly.GetAssembly(typeof(TlbImp)));
        }
    }
    
    internal static String GetString(String key)
    {
        InitResourceManager();
        String s = _resmgr.GetString(key, null);
        if(s == null) throw new ApplicationException("FATAL: Resource string for '" + key + "' is null");
        return(s);
    }
    
    internal static String FormatString(String key)
    {
        return(GetString(key));
    }
    
    internal static String FormatString(String key, Object a1)
    {
        return(String.Format(GetString(key), a1));
    }
    
    internal static String FormatString(String key, Object a1, Object a2)
    {
        return(String.Format(GetString(key), a1, a2));
    }
    
    internal static String FormatString(String key, Object a1, Object a2, Object a3)
    {
        return(String.Format(GetString(key), a1, a2, a3));
    }
    
    internal static String FormatString(String key, Object[] a)
    {
        return(String.Format(GetString(key), a));
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimpcode\tlbimpoptions.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
using System;
using System.Collections;
using System.Reflection;
using System.Runtime.InteropServices;

namespace TlbImpCode {

[Serializable()] 
public sealed class TlbImpOptions
{
    public String               m_strTypeLibName = null;
    public String               m_strAssemblyName = null;
    public String               m_strAssemblyNamespace = null;
    public String               m_strOutputDir = null;
    public byte[]               m_aPublicKey = null;
    public StrongNameKeyPair    m_sKeyPair = null;
    public Hashtable            m_AssemblyRefList = new Hashtable();
    public Version              m_AssemblyVersion = null;
    public TypeLibImporterFlags m_flags = 0;
    public bool                 m_bNoLogo = false;
    public bool                 m_bSilentMode = false;
    public bool                 m_bVerboseMode = false;
    public bool                 m_bStrictRef = false;
    public bool                 m_bSearchPathSucceeded = false;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimpcode\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "TLBIMPCODE.DLL"
#define VER_FILEDESCRIPTION_STR "Microsoft Type Library to .NET Assembly Converter Implementation\0"
#define VER_ORIGFILENAME_STR    "TlbImpCode.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimp\tlbimp.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.Runtime.InteropServices;
using System.IO;
using System.Reflection;
using System.Reflection.Emit;
using System.Text;
using System.Resources;
using System.Collections;
using System.Runtime.Remoting;
using System.Globalization;
using TlbImpCode;

[assembly:ComVisible(false)]

namespace TlbImp {

public class TlbImp
{
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;

    public static int Main(String []aArgs)
    {
        int RetCode = SuccessReturnCode;

        // Parse the command line arguments.
        if (!ParseArguments(aArgs, ref s_Options, ref RetCode))
            return RetCode;
        
        // If we are not in silent mode then print the RegAsm logo.
        if (!s_Options.m_bSilentMode)
            PrintLogo();
        
        return Run();
    }

    public static int Run()
    {
        int RetCode = SuccessReturnCode;

        try
        {
            // Call SearchPath to find the full path of the typelib to load.
            StringBuilder sb = new StringBuilder(MAX_PATH + 1);
            if (SearchPath(null, s_Options.m_strTypeLibName, null, sb.Capacity + 1, sb, null) == 0)
            {
                // We failed to find the typelib. This might be because a resource ID is specified
                // so lets let LoadTypeLibEx have a crack at it but remember that we failed to find it.
                s_Options.m_bSearchPathSucceeded = false;
            }
            else
            {
                // We found the typelib.
                s_Options.m_bSearchPathSucceeded = true;
                s_Options.m_strTypeLibName = sb.ToString();
            }

            // Retrieve the full path name of the typelib and output file.
            s_Options.m_strTypeLibName = (new FileInfo(s_Options.m_strTypeLibName)).FullName;
            if (s_Options.m_strAssemblyName != null)
            {
                s_Options.m_strAssemblyName = (new FileInfo(s_Options.m_strAssemblyName)).FullName;
                if (Directory.Exists( s_Options.m_strAssemblyName ))
                    throw new ApplicationException(Resource.FormatString("Err_OutputCannotBeDirectory"));
            }

            // Determine the output directory for the generated assembly.
            if (s_Options.m_strAssemblyName != null)
            {
                // An output file has been provided so use its directory as the output directory.
                s_Options.m_strOutputDir = Path.GetDirectoryName(s_Options.m_strAssemblyName);
            }
            else
            {
                // No output file has been provided so use the current directory as the output directory.
                s_Options.m_strOutputDir = Environment.CurrentDirectory;
            }

            if (!Directory.Exists( s_Options.m_strOutputDir ))
            {
                Directory.CreateDirectory( s_Options.m_strOutputDir );
            }

            // If the output directory is different from the current directory then change to that directory.
            if (String.Compare(s_Options.m_strOutputDir, Environment.CurrentDirectory, true, CultureInfo.InvariantCulture) != 0)
                Environment.CurrentDirectory = s_Options.m_strOutputDir;

            // Create an AppDomain to load the implementation part of the app into.
            AppDomainSetup options = new AppDomainSetup();
            options.ApplicationBase = s_Options.m_strOutputDir;
            AppDomain domain = AppDomain.CreateDomain("TlbImp", null, options);
            if (domain == null)
                throw new ApplicationException(Resource.FormatString("Err_CannotCreateAppDomain"));

            // Create the remote component that will perform the rest of the conversion.
			String assemblyName = typeof(TlbImpCode.RemoteTlbImp).Assembly.GetName().FullName;
            ObjectHandle h = domain.CreateInstance(assemblyName, "TlbImpCode.RemoteTlbImp");
            if (h == null)
                throw new ApplicationException(Resource.FormatString("Err_CannotCreateRemoteTlbImp"));

            // Have the remote component perform the rest of the conversion.
            RemoteTlbImp code = (RemoteTlbImp) h.Unwrap();
            if(code != null)
                RetCode = code.Run(s_Options);
            
            // Do not unload the domain, this causes problems with IJW MC++ assemblies that
            // call managed code from DllMain's ProcessDetach notification.
        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            RetCode = ErrorReturnCode;
        }

        return RetCode;
    }

    internal static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
        else
        {
            strErrorMsg += e.GetType().ToString();
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbImpErrorPrefix", strErrorMsg));
    }

    internal static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbImpErrorPrefix", strErrorMsg));
    }

    private static bool ParseArguments(String []aArgs, ref TlbImpOptions Options, ref int ReturnCode)
    {
        CommandLine cmdLine;
        Option opt;
        bool delaysign = false;

        // Create the options object that will be returned.
        Options = new TlbImpOptions();

        // Parse the command line arguments using the command line argument parser.
        try 
        {
            cmdLine = new CommandLine(aArgs, new String[] { "*out", "*publickey", "*keyfile", "*keycontainer", "delaysign", "*reference",
                                                            "unsafe", "nologo", "silent", "verbose", "strictref", "primary", "*namespace", 
                                                            "*asmversion", "sysarray", "*transform", "?", "help" });
        }
        catch (ApplicationException e)
        {
            PrintLogo();
            WriteErrorMsg(null, e);
            ReturnCode = ErrorReturnCode;
            return false;
        }

        // Make sure there is at least one argument.
        if ((cmdLine.NumArgs + cmdLine.NumOpts) < 1)
        {
            PrintUsage();
            ReturnCode = SuccessReturnCode;
            return false;
        }

        // Get the name of the COM typelib.
        Options.m_strTypeLibName = cmdLine.GetNextArg();

        // Go through the list of options.
        while ((opt = cmdLine.GetNextOption()) != null)
        {
            // Determine which option was specified.
            if (opt.Name.Equals("out"))
                Options.m_strAssemblyName = opt.Value;
            else if (opt.Name.Equals("namespace"))
                Options.m_strAssemblyNamespace = opt.Value;
            else if (opt.Name.Equals("asmversion"))
            {
                try
                {
                    Options.m_AssemblyVersion = new Version(opt.Value);
                }
                catch (Exception e)
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_InvalidVersion"), e);
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
            }
            else if (opt.Name.Equals("reference"))
            {
                Assembly asm = null;
                String AsmFileName = opt.Value;
                
                // Call SearchPath to find the full path of the referenced assembly.
                StringBuilder sb = new StringBuilder(MAX_PATH + 1);
                if (SearchPath(null, AsmFileName, null, sb.Capacity + 1, sb, null) == 0)
                {
                    WriteErrorMsg(Resource.FormatString("Err_RefAssemblyNotFound", AsmFileName));
                    return false;
                }
                AsmFileName = sb.ToString();
                
                try
                {
                    // Load the assembly.
                    asm = Assembly.LoadFrom(AsmFileName);
                    
                    // Retrieve the GUID and add the assembly to the hashtable of referenced assemblies.
                    Guid TypeLibId = GetTypeLibIdForAssembly(asm);
                    
                    // Add the assembly to the list of referenced assemblies.
                    Options.m_AssemblyRefList.Add(TypeLibId, asm);
                } 
                catch (BadImageFormatException)
                {
                    WriteErrorMsg(Resource.FormatString("Err_RefAssemblyInvalid", AsmFileName));
                    return false;
                }
                catch (FileNotFoundException)
                {
                    WriteErrorMsg(Resource.FormatString("Err_RefAssemblyNotFound", AsmFileName));
                    return false;
                }
                catch (ApplicationException e)
                {
                    WriteErrorMsg(null, e);
                    return false;
                }
            }
            else if (opt.Name.Equals("delaysign"))
            {
                delaysign = true;
            }
            else if (opt.Name.Equals("publickey"))
            {
                if (Options.m_sKeyPair != null || Options.m_aPublicKey != null)
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_TooManyKeys"));
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
                // Read data from binary file into byte array.
                byte[] aData;
                FileStream fs = null;
                try
                {
                    fs = new FileStream(opt.Value, FileMode.Open, FileAccess.Read, FileShare.Read);
                    int iLength = (int)fs.Length;
                    aData = new byte[iLength];
                    fs.Read(aData, 0, iLength);
                }
                catch (Exception e)
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_ErrorWhileOpenningFile", opt.Value), e);
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
                finally
                {
                    if (fs != null)
                        fs.Close();
                }
                Options.m_aPublicKey = aData;
            }
            else if (opt.Name.Equals("keyfile"))
            {
                if (Options.m_sKeyPair != null || Options.m_aPublicKey != null)
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_TooManyKeys"));
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
                // Read data from binary file into byte array.
                byte[] aData;
                FileStream fs = null;
                try
                {
                    fs = new FileStream(opt.Value, FileMode.Open, FileAccess.Read, FileShare.Read);
                    int iLength = (int)fs.Length;
                    aData = new byte[iLength];
                    fs.Read(aData, 0, iLength);
                }
                catch (Exception e)
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_ErrorWhileOpenningFile", opt.Value), e);
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
                finally
                {
                    if (fs != null)
                        fs.Close();
                }
                Options.m_sKeyPair = new StrongNameKeyPair(aData);
            }
            else if (opt.Name.Equals("keycontainer"))
            {
                if (Options.m_sKeyPair != null)
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_TooManyKeys"));
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
                Options.m_sKeyPair = new StrongNameKeyPair(opt.Value);
            }
            else if (opt.Name.Equals("unsafe"))
                Options.m_flags |= TypeLibImporterFlags.UnsafeInterfaces;
            else if (opt.Name.Equals("primary"))
                Options.m_flags |= TypeLibImporterFlags.PrimaryInteropAssembly;
            else if (opt.Name.Equals("sysarray"))
                Options.m_flags |= TypeLibImporterFlags.SafeArrayAsSystemArray;
            else if (opt.Name.Equals("nologo"))
                Options.m_bNoLogo = true;
            else if (opt.Name.Equals("silent"))
                Options.m_bSilentMode = true;
            else if (opt.Name.Equals("verbose"))
                Options.m_bVerboseMode = true;
            else if (opt.Name.Equals("strictref"))
                Options.m_bStrictRef = true;
            else if (opt.Name.Equals("transform"))
            {
                if (opt.Value.ToLower(CultureInfo.InvariantCulture) == "dispret")
                    Options.m_flags |= TypeLibImporterFlags.TransformDispRetVals;
                else
                {
                    PrintLogo();
                    WriteErrorMsg(Resource.FormatString("Err_InvalidTransform", opt.Value));
                    ReturnCode = ErrorReturnCode;
                    return false;
                }
            }
            else if (opt.Name.Equals("?") || opt.Name.Equals("help"))
            {
                PrintUsage();
                ReturnCode = SuccessReturnCode;
                return false;
            }
            else
            {
                PrintLogo();
                WriteErrorMsg(Resource.FormatString("Err_InvalidOption"));
                ReturnCode = ErrorReturnCode;
                return false;
            }
        }

        // Validate that the typelib name has been specified.
        if (Options.m_strTypeLibName == null)
        {
            PrintLogo();
            WriteErrorMsg(Resource.FormatString("Err_NoInputFile"));
            ReturnCode = ErrorReturnCode;
            return false;
        }

        // Gather information needed for strong naming the assembly (if
        // the user desires this).
        if ((Options.m_sKeyPair != null) && (Options.m_aPublicKey == null))
        {
            try {
                Options.m_aPublicKey = Options.m_sKeyPair.PublicKey;
            } catch (Exception) {
                PrintLogo();
                WriteErrorMsg(Resource.FormatString("Err_InvalidStrongName"));
                ReturnCode = ErrorReturnCode;
                return false;
            }
        }
        if (delaysign && Options.m_sKeyPair != null)
            Options.m_sKeyPair = null;

        // To be able to generate a PIA, we must also be strong naming the assembly.
        if ((Options.m_flags & TypeLibImporterFlags.PrimaryInteropAssembly) != 0)
        {
            if (Options.m_aPublicKey == null && Options.m_sKeyPair == null)
            {
                PrintLogo();
                WriteErrorMsg(Resource.FormatString("Err_PIAMustBeStrongNamed"));
                ReturnCode = ErrorReturnCode;
                return false;                
            }
        }


        return true;
    }

    private static void PrintLogo()
    {
        if (!s_Options.m_bNoLogo)
        {
            Console.WriteLine(Resource.FormatString("Msg_Copyright", Util.Version.VersionString));
        }
    }

    private static void PrintUsage()
    {
        PrintLogo();

        Console.WriteLine(Resource.FormatString("Msg_Usage"));
    }

    private static Guid GetTypeLibIdForAssembly(Assembly asm)
    {
        // Check to see if the typelib has an imported from typelib attribute.
        if (asm.GetCustomAttributes(typeof(ImportedFromTypeLibAttribute), false).Length == 0)
            throw new ApplicationException(Resource.FormatString("Err_ImpFromTlbAttrNotFound", asm.GetName().Name));
        
        // Retrieve the GUID of the assembly (which is also the GUID of the typelib the
        // assembly was imported from).
        Object[] aGuidAttrs = asm.GetCustomAttributes(typeof(GuidAttribute), false);
        
        // If there is no guid attribute then throw an exception.
        if (aGuidAttrs.Length == 0)
            throw new ApplicationException(Resource.FormatString("Err_GuidAttrNotFound", asm.GetName().Name));
        
        // If there are multiple guid attributes then throw an exception.
        if (aGuidAttrs.Length > 1)
            throw new ApplicationException(Resource.FormatString("Err_MultipleGuidAttrs", asm.GetName().Name));
        
        // Create a guid from the string value of guid attribute.
        return new Guid(((GuidAttribute)aGuidAttrs[0]).Value);
    }

    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    public static extern int SearchPath(String path, String fileName, String extension, int numBufferChars, StringBuilder buffer, int[] filePart);

    internal static TlbImpOptions s_Options = null;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\lwhost\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.cool

cool_target: $(COOL_TARGET)
	copy ConsumerCommands.xml $(URTTARGET)
	
resources: 
	ResGen resource/dlgtemplates/main.resX $(O)\Microsoft.CLRAdmin.LWHost.resources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\shortcutres\resource.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Script1.rc
//
#define UIMAIN_DISPLAYNAME              1
#define UIMAIN_TOOLTIP			2
#define UIWIZARD_DISPLAYNAME		3
#define UIWIZARD_TOOLTIP                4
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\shortcutres\__file__.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifdef _DEBUG
#define VER_FILEFLAGS       VS_FF_DEBUG
#else
#define VER_FILEFLAGS       VS_FF_SPECIALBUILD
#endif

#define VER_FILETYPE        VFT_DLL
#define VER_INTERNALNAME_STR    "NETUIRES.DLL"
#define VER_FILEDESCRIPTION_STR "MUI resources for .NET Admin shortcuts\0"
#define VER_ORIGFILENAME_STR    "netuires.dll\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\tlbimp\tlbimpcode\tlbimpcode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
///////////////////////////////////////////////////////////////////////////////
// COM+ Runtime Type registration utility.
//
// This program register all the types that are visible to COM.
//
///////////////////////////////////////////////////////////////////////////////

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Collections;
using System.Reflection;
using System.Reflection.Emit;
using System.Threading;
using System.Text;
using System.Globalization;

[assembly:ComVisible(false)]

namespace TlbImpCode {

//******************************************************************************
// Enum passed in to LoadTypeLibEx.
//******************************************************************************
internal enum REGKIND
{
    REGKIND_DEFAULT         = 0,
    REGKIND_REGISTER        = 1,
    REGKIND_NONE            = 2
}

//******************************************************************************
// The typelib importer implementation.
//******************************************************************************
public class TlbImpCode
{
    private const int SuccessReturnCode = 0;
    private const int ErrorReturnCode = 100;
    private const int MAX_PATH = 260;

    //**************************************************************************
    // Entry point called on the typelib importer in the proper app domain.
    //**************************************************************************
    public static int Run(TlbImpOptions options)
    {
        s_Options = options;

        UCOMITypeLib TypeLib = null;
        String strPIAName = null;
        String strPIACodeBase = null;

        //----------------------------------------------------------------------
        // Load the typelib.
        try
        {
            LoadTypeLibEx(s_Options.m_strTypeLibName, REGKIND.REGKIND_NONE, out TypeLib);
        }
        catch (COMException e)
        {
            if (!s_Options.m_bSearchPathSucceeded)
            {
                // We failed to search for the typelib and we failed to load it.
                // This means that the input typelib is not available.
                WriteErrorMsg(Resource.FormatString("Err_InputFileNotFound", s_Options.m_strTypeLibName));
            }
            else
            {
                if (e.ErrorCode == unchecked((int)0x80029C4A))
                {
                    WriteErrorMsg(Resource.FormatString("Err_InputFileNotValidTypeLib", s_Options.m_strTypeLibName));
                }
                else
                {
                    WriteErrorMsg(Resource.FormatString("Err_TypeLibLoad", e));
                }
            }
            return ErrorReturnCode;
        }
        catch (Exception e)
        {
            WriteErrorMsg(Resource.FormatString("Err_TypeLibLoad", e));
        }

        //----------------------------------------------------------------------
        // Check to see if there already exists a primary interop assembly for 
        // this typelib.

        if (TlbImpCode.GetPrimaryInteropAssembly(TypeLib, out strPIAName, out strPIACodeBase))
        {
            WriteWarningMsg(Resource.FormatString("Wrn_PIARegisteredForTlb", strPIAName, s_Options.m_strTypeLibName));
        }

        //----------------------------------------------------------------------
        // Retrieve the name of output assembly if it was not explicitly set.

        if (s_Options.m_strAssemblyName == null)
        {
            s_Options.m_strAssemblyName = Marshal.GetTypeLibName(TypeLib) + ".dll";
        }

        //----------------------------------------------------------------------
        // If no extension is provided, append a .dll to the assembly name.

        if ("".Equals(Path.GetExtension(s_Options.m_strAssemblyName)))
        {
            s_Options.m_strAssemblyName = s_Options.m_strAssemblyName + ".dll";
        }

        //----------------------------------------------------------------------
        // Do some verification on the output assembly.

        String strFileNameNoPath = Path.GetFileName(s_Options.m_strAssemblyName);
        String strExtension = Path.GetExtension(s_Options.m_strAssemblyName);   

        // Validate that the extension is valid.
        bool bExtensionValid = ".dll".Equals(strExtension.ToLower(CultureInfo.InvariantCulture));

        // If the extension is not valid then tell the user and quit.
        if (!bExtensionValid)
        {
            WriteErrorMsg(Resource.FormatString("Err_InvalidExtension"));
            return ErrorReturnCode;
        }

        // Make sure the output file will not overwrite the input file.
        String strInputFilePath = (new FileInfo(s_Options.m_strTypeLibName)).FullName.ToLower(CultureInfo.InvariantCulture);
        String strOutputFilePath;
        try
        {
            strOutputFilePath = (new FileInfo(s_Options.m_strAssemblyName)).FullName.ToLower(CultureInfo.InvariantCulture);
        }
        catch(System.IO.PathTooLongException)
        {
            WriteErrorMsg(Resource.FormatString("Err_OutputFileNameTooLong", s_Options.m_strAssemblyName));
            return ErrorReturnCode;
        }
        if (strInputFilePath.Equals(strOutputFilePath))
        {
            WriteErrorMsg(Resource.FormatString("Err_OutputWouldOverwriteInput"));
            return ErrorReturnCode;
        }

        // Check to see if the output directory is valid.
        if (!Directory.Exists(Path.GetDirectoryName(strOutputFilePath)))
        {
            WriteErrorMsg(Resource.FormatString("Err_InvalidOutputDirectory"));
            return ErrorReturnCode;
        }

        //----------------------------------------------------------------------
        // Attempt the import.

        try
        {
            // Import the typelib to an assembly.
            AssemblyBuilder AsmBldr = DoImport(TypeLib, s_Options.m_strAssemblyName, s_Options.m_strAssemblyNamespace, s_Options.m_AssemblyVersion, s_Options.m_aPublicKey, s_Options.m_sKeyPair, s_Options.m_flags);
            if (AsmBldr == null)
                return ErrorReturnCode;
        }
        catch (ReflectionTypeLoadException e)
        {
            int i;
            Exception[] exceptions;
            WriteErrorMsg(Resource.FormatString("Err_TypeLoadExceptions"));
            exceptions = e.LoaderExceptions;
            for (i = 0; i < exceptions.Length; i++)
            {
                try 
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayException", i, exceptions[i]));
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayNestedException", i, ex));
                }
            }
            return ErrorReturnCode;
        }
        catch (Exception e)
        {
            WriteErrorMsg(null, e);
            return ErrorReturnCode;
        }

        //----------------------------------------------------------------------
        // Display the success message unless silent mode is enabled.

        if (!s_Options.m_bSilentMode)
            Console.WriteLine(Resource.FormatString("Msg_TypeLibImported", s_Options.m_strAssemblyName));

        return SuccessReturnCode;
    }

    //**************************************************************************
    // Static importer function used by main and the callback.
    //**************************************************************************
    public static AssemblyBuilder DoImport(UCOMITypeLib TypeLib,
                                           String strAssemblyFileName,
                                           String strAssemblyNamespace,
                                           Version asmVersion,
                                           byte[] publicKey,
                                           StrongNameKeyPair keyPair,
                                           TypeLibImporterFlags flags)
    {
        // Detemine the assembly file name.
        String asmFileName = Path.GetFileName(strAssemblyFileName);

        // Add this typelib to list of importing typelibs.
        Guid guid = Marshal.GetTypeLibGuid(TypeLib);
        s_ImportingLibraries.Add(guid.ToString(), guid);

        // Convert the typelib.
        ImporterCallback callback = new ImporterCallback();
        AssemblyBuilder AsmBldr = s_TypeLibConverter.ConvertTypeLibToAssembly(TypeLib,
                                                                   strAssemblyFileName,
                                                                   flags,
                                                                   callback,
                                                                   publicKey,
                                                                   keyPair,
                                                                   strAssemblyNamespace,
                                                                   asmVersion);

        // Remove this typelib from list of importing typelibs.
        s_ImportingLibraries.Remove(guid.ToString());

        // Delete the output assembly.
        File.Delete(asmFileName);

        // Save the assembly to disk.
        AsmBldr.Save(asmFileName);
        return AsmBldr;
    }

    //**************************************************************************
    // Helper to get a PIA from a typelib.
    //**************************************************************************
    internal static bool GetPrimaryInteropAssembly(Object TypeLib, out String asmName, out String asmCodeBase)
    {
        IntPtr pAttr = (IntPtr)0;
        TYPELIBATTR Attr;
        UCOMITypeLib pTLB = (UCOMITypeLib)TypeLib;
        int Major = 0;
        int Minor = 0;
        Guid TlbId;
        int lcid = 0;

        // Retrieve the major and minor version from the typelib.
        try
        {
            pTLB.GetLibAttr(out pAttr);
            Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
            Major = Attr.wMajorVerNum;
            Minor = Attr.wMinorVerNum;
            TlbId = Attr.guid;
            lcid = Attr.lcid;
        }
        finally
        {
            // Release the typelib attributes.
            if (pAttr != (IntPtr)0)
                pTLB.ReleaseTLibAttr(pAttr);
        }

        // Ask the converter for a PIA for this typelib.
        return s_TypeLibConverter.GetPrimaryInteropAssembly(TlbId, Major, Minor, lcid, out asmName, out asmCodeBase);
    }

    internal static bool IsPrimaryInteropAssembly(Assembly asm)
    {
        // Check to see if the assembly has one or more PrimaryInteropAssembly attributes.
        Object[] aPIAAttrs = asm.GetCustomAttributes(typeof(PrimaryInteropAssemblyAttribute), false);
        return aPIAAttrs.Length > 0;
    }

    //**************************************************************************
    // Error message handling.
    //**************************************************************************
    internal static void WriteErrorMsg(String strPrefix, Exception e)
    {
        String strErrorMsg = "";
        if (strPrefix != null)
            strErrorMsg = strPrefix;
            
        strErrorMsg += e.GetType().ToString() + " - ";
        if (e.Message != null)
        {
            strErrorMsg += e.Message;
        }
            
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbImpErrorPrefix", strErrorMsg));
    }

    internal static void WriteErrorMsg(String strErrorMsg)
    {
        Console.Error.WriteLine(Resource.FormatString("Msg_TlbImpErrorPrefix", strErrorMsg));
    }
    
    internal static void WriteWarningMsg(String strWarningMsg)
    {
        if (!s_Options.m_bSilentMode)
            Console.Error.WriteLine(Resource.FormatString("Msg_TlbImpWarningPrefix", strWarningMsg));
    }

    [DllImport("oleaut32.dll", CharSet = CharSet.Unicode, PreserveSig = false)]
    private static extern void LoadTypeLibEx(String strTypeLibName, REGKIND regKind, out UCOMITypeLib TypeLib);

    internal static TlbImpOptions s_Options;

    // List of libraries being imported, as guids.
    internal static Hashtable s_ImportingLibraries = new Hashtable();
    
    // List of libraries that have been imported, as guids.
    internal static Hashtable s_AlreadyImportedLibraries = new Hashtable();

    // TypeLib converter.
    internal static TypeLibConverter s_TypeLibConverter = new TypeLibConverter();
}

//******************************************************************************
// The resolution callback class.
//******************************************************************************
internal class ImporterCallback : ITypeLibImporterNotifySink
{
    public void ReportEvent(ImporterEventKind EventKind, int EventCode, String EventMsg)
    {
        //@todo: the following line is very useful, and should be available as a verbose option.
        //Console.Write(DateTime.Now.ToString("h:mm:ss.fff "));

		if (EventKind == ImporterEventKind.NOTIF_TYPECONVERTED)
		{
			if (TlbImpCode.s_Options.m_bVerboseMode)
				Console.WriteLine(EventMsg);
		}
		else
        if (EventKind == ImporterEventKind.NOTIF_CONVERTWARNING)
        {
            TlbImpCode.WriteWarningMsg(EventMsg);
        }
        else
        {
            Console.WriteLine(EventMsg);
        }
    }

    public Assembly ResolveRef(Object TypeLib)
    {
        Assembly rslt = null;
        UCOMITypeLib pTLB = (UCOMITypeLib)TypeLib;
        String strPIAName = null;
        String strPIACodeBase = null;
        bool bExistingAsmLoaded = false;
        bool bGeneratingPIA = (TlbImpCode.s_Options.m_flags & TypeLibImporterFlags.PrimaryInteropAssembly) != 0;     


        //----------------------------------------------------------------------
        // Display a message indicating we are resolving a reference.

        if (TlbImpCode.s_Options.m_bVerboseMode)
            Console.WriteLine(Resource.FormatString("Msg_ResolvingRef", Marshal.GetTypeLibName(pTLB)));


        //----------------------------------------------------------------------
        // Check our list of referenced assemblies.

        rslt = (Assembly)TlbImpCode.s_Options.m_AssemblyRefList[Marshal.GetTypeLibGuid((UCOMITypeLib)TypeLib)];
        if (rslt != null)
        {
            // Validate that the assembly is indeed a PIA.
            if (bGeneratingPIA && !TlbImpCode.IsPrimaryInteropAssembly(rslt))
                throw new ApplicationException(Resource.FormatString("Err_ReferencedPIANotPIA", rslt.GetName().Name));

            // If we are in verbose mode then display message indicating we successfully resolved the assembly 
            // from the list of referenced assemblies.
            if (TlbImpCode.s_Options.m_bVerboseMode)
                Console.WriteLine(Resource.FormatString("Msg_RefFoundInAsmRefList", Marshal.GetTypeLibName(pTLB), rslt.GetName().Name));

            return rslt;
        }


        //----------------------------------------------------------------------
        // Look for a primary interop assembly for the typelib.

        if (TlbImpCode.GetPrimaryInteropAssembly(TypeLib, out strPIAName, out strPIACodeBase))
        {
            // Load the primary interop assembly.
            try
            {
                // First try loading the assembly using its full name.
                rslt = Assembly.Load(strPIAName);
            }
            catch(FileNotFoundException)
            {
                if (strPIACodeBase != null)
                {
                    // If that failed, try loading it using LoadFrom bassed on the codebase.
                    rslt = Assembly.LoadFrom(strPIACodeBase);

                    // // Validate that the full name of the loaded assembly is the same as the
                    // // full name stored in the registry for the PIA.
                    // if (rslt.FullName != strPIAName)
                    //     throw new ApplicationException(Resource.FormatString("Err_NonCompatPIALoaded", strPIACodeBase, Marshal.GetTypeLibName((UCOMITypeLib)TypeLib)));
                }
				else
                    throw;
            }

            // Validate that the assembly is indeed a PIA.
            if (!TlbImpCode.IsPrimaryInteropAssembly(rslt))
                throw new ApplicationException(Resource.FormatString("Err_RegisteredPIANotPIA", rslt.GetName().Name, Marshal.GetTypeLibName((UCOMITypeLib)TypeLib)));

            // If we are in verbose mode then display message indicating we successfully resolved the PIA.
            if (TlbImpCode.s_Options.m_bVerboseMode)
                Console.WriteLine(Resource.FormatString("Msg_ResolvedRefToPIA", Marshal.GetTypeLibName(pTLB), rslt.GetName().Name));

            return rslt;
        }


        //----------------------------------------------------------------------
        // If we are generating a primary interop assembly or if strict ref mode
        // is enabled, then the resolve ref has failed.

        if (bGeneratingPIA)
            throw new ApplicationException(Resource.FormatString("Err_NoPIARegistered", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib)));
        if (TlbImpCode.s_Options.m_bStrictRef)
            throw new ApplicationException(Resource.FormatString("Err_RefNotInList", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib)));

        
        //----------------------------------------------------------------------
        // See if this has already been imported.

        rslt = (Assembly)TlbImpCode.s_AlreadyImportedLibraries[Marshal.GetTypeLibGuid((UCOMITypeLib)TypeLib)];
        if (rslt != null)
        {
            // If we are in verbose mode then display message indicating we successfully resolved the assembly 
            // from the list of referenced assemblies.
            if (TlbImpCode.s_Options.m_bVerboseMode)
                Console.WriteLine(Resource.FormatString("Msg_AssemblyResolved", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib)));

            return rslt;
        }


        //----------------------------------------------------------------------
        // Try to load the assembly.

        String FullyQualifiedAsmFileName = Path.Combine(TlbImpCode.s_Options.m_strOutputDir, Marshal.GetTypeLibName((UCOMITypeLib)TypeLib) + ".dll");
        try
        {
            IntPtr pAttr = (IntPtr)0;
            TYPELIBATTR Attr;
            Int16 MajorTlbVer = 0;
            Int16 MinorTlbVer = 0;
            Guid TlbId;

            // Check to see if we've already built the assembly.
            rslt = Assembly.LoadFrom(FullyQualifiedAsmFileName);

            // Remember we loaded an existing assembly.
            bExistingAsmLoaded = true;

            // Get the major and minor version number from the TypeLibAttr.
            try
            {
                ((UCOMITypeLib)TypeLib).GetLibAttr(out pAttr);
                Attr = (TYPELIBATTR)Marshal.PtrToStructure(pAttr, typeof(TYPELIBATTR));
                MajorTlbVer = Attr.wMajorVerNum;
                MinorTlbVer = Attr.wMinorVerNum;
                TlbId = Attr.guid;
            }
            finally
            {
                if (pAttr != (IntPtr)0)
                    ((UCOMITypeLib)TypeLib).ReleaseTLibAttr(pAttr);
            }

            // Make sure the assembly is for the current typelib and that the version number of the 
            // loaded assembly is the same as the version number of the typelib.
            Version asmVersion = rslt.GetName().Version;
            if (Marshal.GetTypeLibGuidForAssembly(rslt) == TlbId && asmVersion.Major == MajorTlbVer && asmVersion.Minor == MinorTlbVer)
            {
                // If we are in verbose mode then display message indicating we successfully loaded the assembly.
                if (TlbImpCode.s_Options.m_bVerboseMode)
                    Console.WriteLine(Resource.FormatString("Msg_AssemblyLoaded", FullyQualifiedAsmFileName));

                // Remember the loaded assembly.
                TlbImpCode.s_AlreadyImportedLibraries[Marshal.GetTypeLibGuid((UCOMITypeLib)TypeLib)] = rslt;
            
                return rslt;
            }
        }
        catch (System.IO.FileNotFoundException)
        {
            // This is actually great, just fall through to create the new file.
        }
        catch (Exception)
        {
            throw new ApplicationException(Resource.FormatString("Err_ExistingFileOverwrittenByRefAsm", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib), FullyQualifiedAsmFileName));
        }


        //----------------------------------------------------------------------
        // Make sure an existing assembly will not be overwritten by the 
        // assembly generated by the typelib being imported.

        if (bExistingAsmLoaded)
            throw new ApplicationException(Resource.FormatString("Err_ExistingAsmOverwrittenByRefAsm", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib), FullyQualifiedAsmFileName));


        //----------------------------------------------------------------------
        // Make sure the current assembly will not be overriten by the 
        // assembly generated by the typelib being imported.
        
        if (String.Compare(FullyQualifiedAsmFileName, TlbImpCode.s_Options.m_strAssemblyName, true, CultureInfo.InvariantCulture) == 0)
            throw new ApplicationException(Resource.FormatString("Err_RefAsmOverwrittenByOutput", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib), FullyQualifiedAsmFileName));


        //----------------------------------------------------------------------
        // See if this is already on the stack.

        if (TlbImpCode.s_ImportingLibraries.Contains(Marshal.GetTypeLibGuid((UCOMITypeLib)TypeLib).ToString()))
        {
            // Print an error message and return null to stop importing the current type but
            // continue with the rest of the import.
            TlbImpCode.WriteErrorMsg(Resource.FormatString("Wrn_CircularReference", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib)));
            return null;
        }


        //----------------------------------------------------------------------
        // If we have not managed to load the assembly then import the typelib.

        if (TlbImpCode.s_Options.m_bVerboseMode)
            Console.WriteLine(Resource.FormatString("Msg_AutoImportingTypeLib", Marshal.GetTypeLibName((UCOMITypeLib)TypeLib), FullyQualifiedAsmFileName));
    
        try
        {
            rslt = TlbImpCode.DoImport((UCOMITypeLib)TypeLib, 
                                    FullyQualifiedAsmFileName, 
                                    null,
                                    null,
                                    TlbImpCode.s_Options.m_aPublicKey, 
                                    TlbImpCode.s_Options.m_sKeyPair, 
                                    TlbImpCode.s_Options.m_flags);

            // Remember the imported assembly.
            TlbImpCode.s_AlreadyImportedLibraries[Marshal.GetTypeLibGuid((UCOMITypeLib)TypeLib)] = rslt;
        }
        catch (ReflectionTypeLoadException e)
        {
            // Display the type load exceptions that occurred and rethrow the exception.
            int i;
            Exception[] exceptions;
            TlbImpCode.WriteErrorMsg(Resource.FormatString("Err_TypeLoadExceptions"));
            exceptions = e.LoaderExceptions;
            for (i = 0; i < exceptions.Length; i++)
            {
                try 
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayException", i, exceptions[i]));
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine(Resource.FormatString("Msg_DisplayNestedException", i, ex));
                }
            }
            throw e;
        }
        
        return rslt;
    }
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\afxres.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// This is a part of the Microsoft Foundation Classes C++ library.
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXRES_H__
#define __AFXRES_H__

#ifdef RC_INVOKED
#ifndef _INC_WINDOWS
#define _INC_WINDOWS
    #include "winres.h"           // extract from windows header
#endif
#endif

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// MFC resource types (see Technical note TN024 for implementation details)

#ifndef RC_INVOKED
#define RT_DLGINIT  MAKEINTRESOURCE(240)
#define RT_TOOLBAR  MAKEINTRESOURCE(241)
#endif

/////////////////////////////////////////////////////////////////////////////

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

/////////////////////////////////////////////////////////////////////////////
// General style bits etc

// ControlBar styles
#define CBRS_ALIGN_LEFT     0x1000L
#define CBRS_ALIGN_TOP      0x2000L
#define CBRS_ALIGN_RIGHT    0x4000L
#define CBRS_ALIGN_BOTTOM   0x8000L
#define CBRS_ALIGN_ANY      0xF000L

#define CBRS_BORDER_LEFT    0x0100L
#define CBRS_BORDER_TOP     0x0200L
#define CBRS_BORDER_RIGHT   0x0400L
#define CBRS_BORDER_BOTTOM  0x0800L
#define CBRS_BORDER_ANY     0x0F00L

#define CBRS_TOOLTIPS       0x0010L
#define CBRS_FLYBY          0x0020L
#define CBRS_FLOAT_MULTI    0x0040L
#define CBRS_BORDER_3D      0x0080L
#define CBRS_HIDE_INPLACE   0x0008L
#define CBRS_SIZE_DYNAMIC   0x0004L
#define CBRS_SIZE_FIXED     0x0002L
#define CBRS_FLOATING       0x0001L

#define CBRS_GRIPPER        0x00400000L

#define CBRS_ORIENT_HORZ    (CBRS_ALIGN_TOP|CBRS_ALIGN_BOTTOM)
#define CBRS_ORIENT_VERT    (CBRS_ALIGN_LEFT|CBRS_ALIGN_RIGHT)
#define CBRS_ORIENT_ANY     (CBRS_ORIENT_HORZ|CBRS_ORIENT_VERT)

#define CBRS_ALL            0x0040FFFFL

// the CBRS_ style is made up of an alignment style and a draw border style
//  the alignment styles are mutually exclusive
//  the draw border styles may be combined
#define CBRS_NOALIGN        0x00000000L
#define CBRS_LEFT           (CBRS_ALIGN_LEFT|CBRS_BORDER_RIGHT)
#define CBRS_TOP            (CBRS_ALIGN_TOP|CBRS_BORDER_BOTTOM)
#define CBRS_RIGHT          (CBRS_ALIGN_RIGHT|CBRS_BORDER_LEFT)
#define CBRS_BOTTOM         (CBRS_ALIGN_BOTTOM|CBRS_BORDER_TOP)

/////////////////////////////////////////////////////////////////////////////
// Standard window components

// Mode indicators in status bar - these are routed like commands
#define ID_INDICATOR_EXT                0xE700  // extended selection indicator
#define ID_INDICATOR_CAPS               0xE701  // cap lock indicator
#define ID_INDICATOR_NUM                0xE702  // num lock indicator
#define ID_INDICATOR_SCRL               0xE703  // scroll lock indicator
#define ID_INDICATOR_OVR                0xE704  // overtype mode indicator
#define ID_INDICATOR_REC                0xE705  // record mode indicator
#define ID_INDICATOR_KANA               0xE706  // kana lock indicator

#define ID_SEPARATOR                    0   // special separator value

#ifndef RC_INVOKED  // code only
// Standard control bars (IDW = window ID)
#define AFX_IDW_CONTROLBAR_FIRST        0xE800
#define AFX_IDW_CONTROLBAR_LAST         0xE8FF

#define AFX_IDW_TOOLBAR                 0xE800  // main Toolbar for window
#define AFX_IDW_STATUS_BAR              0xE801  // Status bar window
#define AFX_IDW_PREVIEW_BAR             0xE802  // PrintPreview Dialog Bar
#define AFX_IDW_RESIZE_BAR              0xE803  // OLE in-place resize bar
#define AFX_IDW_REBAR                   0xE804  // COMCTL32 "rebar" Bar
#define AFX_IDW_DIALOGBAR               0xE805  // CDialogBar

// Note: If your application supports docking toolbars, you should
//  not use the following IDs for your own toolbars.  The IDs chosen
//  are at the top of the first 32 such that the bars will be hidden
//  while in print preview mode, and are not likely to conflict with
//  IDs your application may have used succesfully in the past.

#define AFX_IDW_DOCKBAR_TOP             0xE81B
#define AFX_IDW_DOCKBAR_LEFT            0xE81C
#define AFX_IDW_DOCKBAR_RIGHT           0xE81D
#define AFX_IDW_DOCKBAR_BOTTOM          0xE81E
#define AFX_IDW_DOCKBAR_FLOAT           0xE81F

// Macro for mapping standard control bars to bitmask (limit of 32)
#define AFX_CONTROLBAR_MASK(nIDC)   (1L << (nIDC - AFX_IDW_CONTROLBAR_FIRST))

// parts of Main Frame
#define AFX_IDW_PANE_FIRST              0xE900  // first pane (256 max)
#define AFX_IDW_PANE_LAST               0xE9ff
#define AFX_IDW_HSCROLL_FIRST           0xEA00  // first Horz scrollbar (16 max)
#define AFX_IDW_VSCROLL_FIRST           0xEA10  // first Vert scrollbar (16 max)

#define AFX_IDW_SIZE_BOX                0xEA20  // size box for splitters
#define AFX_IDW_PANE_SAVE               0xEA21  // to shift AFX_IDW_PANE_FIRST
#endif //!RC_INVOKED

#ifndef APSTUDIO_INVOKED

// common style for form views
#define AFX_WS_DEFAULT_VIEW             (WS_CHILD | WS_VISIBLE | WS_BORDER)

#endif //!APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
// Standard app configurable strings

// for application title (defaults to EXE name or name in constructor)
#define AFX_IDS_APP_TITLE               0xE000
// idle message bar line
#define AFX_IDS_IDLEMESSAGE             0xE001
// message bar line when in shift-F1 help mode
#define AFX_IDS_HELPMODEMESSAGE         0xE002
// document title when editing OLE embedding
#define AFX_IDS_APP_TITLE_EMBEDDING     0xE003
// company name
#define AFX_IDS_COMPANY_NAME            0xE004
// object name when server is inplace
#define AFX_IDS_OBJ_TITLE_INPLACE       0xE005

/////////////////////////////////////////////////////////////////////////////
// Standard Commands

// File commands
#define ID_FILE_NEW                     0xE100
#define ID_FILE_OPEN                    0xE101
#define ID_FILE_CLOSE                   0xE102
#define ID_FILE_SAVE                    0xE103
#define ID_FILE_SAVE_AS                 0xE104
#define ID_FILE_PAGE_SETUP              0xE105
#define ID_FILE_PRINT_SETUP             0xE106
#define ID_FILE_PRINT                   0xE107
#define ID_FILE_PRINT_DIRECT            0xE108
#define ID_FILE_PRINT_PREVIEW           0xE109
#define ID_FILE_UPDATE                  0xE10A
#define ID_FILE_SAVE_COPY_AS            0xE10B
#define ID_FILE_SEND_MAIL               0xE10C

#define ID_FILE_MRU_FIRST               0xE110
#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
#define ID_FILE_MRU_FILE2               0xE111
#define ID_FILE_MRU_FILE3               0xE112
#define ID_FILE_MRU_FILE4               0xE113
#define ID_FILE_MRU_FILE5               0xE114
#define ID_FILE_MRU_FILE6               0xE115
#define ID_FILE_MRU_FILE7               0xE116
#define ID_FILE_MRU_FILE8               0xE117
#define ID_FILE_MRU_FILE9               0xE118
#define ID_FILE_MRU_FILE10              0xE119
#define ID_FILE_MRU_FILE11              0xE11A
#define ID_FILE_MRU_FILE12              0xE11B
#define ID_FILE_MRU_FILE13              0xE11C
#define ID_FILE_MRU_FILE14              0xE11D
#define ID_FILE_MRU_FILE15              0xE11E
#define ID_FILE_MRU_FILE16              0xE11F
#define ID_FILE_MRU_LAST                0xE11F

// Edit commands
#define ID_EDIT_CLEAR                   0xE120
#define ID_EDIT_CLEAR_ALL               0xE121
#define ID_EDIT_COPY                    0xE122
#define ID_EDIT_CUT                     0xE123
#define ID_EDIT_FIND                    0xE124
#define ID_EDIT_PASTE                   0xE125
#define ID_EDIT_PASTE_LINK              0xE126
#define ID_EDIT_PASTE_SPECIAL           0xE127
#define ID_EDIT_REPEAT                  0xE128
#define ID_EDIT_REPLACE                 0xE129
#define ID_EDIT_SELECT_ALL              0xE12A
#define ID_EDIT_UNDO                    0xE12B
#define ID_EDIT_REDO                    0xE12C

// Window commands
#define ID_WINDOW_NEW                   0xE130
#define ID_WINDOW_ARRANGE               0xE131
#define ID_WINDOW_CASCADE               0xE132
#define ID_WINDOW_TILE_HORZ             0xE133
#define ID_WINDOW_TILE_VERT             0xE134
#define ID_WINDOW_SPLIT                 0xE135
#ifndef RC_INVOKED      // code only
#define AFX_IDM_WINDOW_FIRST            0xE130
#define AFX_IDM_WINDOW_LAST             0xE13F
#define AFX_IDM_FIRST_MDICHILD          0xFF00  // window list starts here
#endif //!RC_INVOKED

// Help and App commands
#define ID_APP_ABOUT                    0xE140
#define ID_APP_EXIT                     0xE141
#define ID_HELP_INDEX                   0xE142
#define ID_HELP_FINDER                  0xE143
#define ID_HELP_USING                   0xE144
#define ID_CONTEXT_HELP                 0xE145      // shift-F1
// special commands for processing help
#define ID_HELP                         0xE146      // first attempt for F1
#define ID_DEFAULT_HELP                 0xE147      // last attempt

// Misc
#define ID_NEXT_PANE                    0xE150
#define ID_PREV_PANE                    0xE151

// Format
#define ID_FORMAT_FONT                  0xE160

// OLE commands
#define ID_OLE_INSERT_NEW               0xE200
#define ID_OLE_EDIT_LINKS               0xE201
#define ID_OLE_EDIT_CONVERT             0xE202
#define ID_OLE_EDIT_CHANGE_ICON         0xE203
#define ID_OLE_EDIT_PROPERTIES          0xE204
#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
#ifndef RC_INVOKED      // code only
#define ID_OLE_VERB_LAST                0xE21F
#endif //!RC_INVOKED

// for print preview dialog bar
#define AFX_ID_PREVIEW_CLOSE            0xE300
#define AFX_ID_PREVIEW_NUMPAGE          0xE301      // One/Two Page button
#define AFX_ID_PREVIEW_NEXT             0xE302
#define AFX_ID_PREVIEW_PREV             0xE303
#define AFX_ID_PREVIEW_PRINT            0xE304
#define AFX_ID_PREVIEW_ZOOMIN           0xE305
#define AFX_ID_PREVIEW_ZOOMOUT          0xE306

// View commands (same number used as IDW used for control bar)
#define ID_VIEW_TOOLBAR                 0xE800
#define ID_VIEW_STATUS_BAR              0xE801
#define ID_VIEW_REBAR                   0xE804
#define ID_VIEW_AUTOARRANGE         0xE805
    // E810 -> E81F must be kept in order for RANGE macros
#define ID_VIEW_SMALLICON               0xE810
#define ID_VIEW_LARGEICON               0xE811
#define ID_VIEW_LIST                   0xE812
#define ID_VIEW_DETAILS                 0xE813
#define ID_VIEW_LINEUP                  0xE814
#define ID_VIEW_BYNAME                  0xE815
#define AFX_ID_VIEW_MINIMUM              ID_VIEW_SMALLICON
#define AFX_ID_VIEW_MAXIMUM              ID_VIEW_BYNAME
    // E800 -> E8FF reserved for other control bar commands

// RecordForm commands
#define ID_RECORD_FIRST                 0xE900
#define ID_RECORD_LAST                  0xE901
#define ID_RECORD_NEXT                  0xE902
#define ID_RECORD_PREV                  0xE903

/////////////////////////////////////////////////////////////////////////////
// Standard control IDs

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls

/////////////////////////////////////////////////////////////////////////////
// Standard string error/warnings

#ifndef RC_INVOKED      // code only
#define AFX_IDS_SCFIRST                 0xEF00
#endif //!RC_INVOKED

#define AFX_IDS_SCSIZE                  0xEF00
#define AFX_IDS_SCMOVE                  0xEF01
#define AFX_IDS_SCMINIMIZE              0xEF02
#define AFX_IDS_SCMAXIMIZE              0xEF03
#define AFX_IDS_SCNEXTWINDOW            0xEF04
#define AFX_IDS_SCPREVWINDOW            0xEF05
#define AFX_IDS_SCCLOSE                 0xEF06
#define AFX_IDS_SCRESTORE               0xEF12
#define AFX_IDS_SCTASKLIST              0xEF13

#define AFX_IDS_MDICHILD                0xEF1F

#define AFX_IDS_DESKACCESSORY           0xEFDA

// General strings
#define AFX_IDS_OPENFILE                0xF000
#define AFX_IDS_SAVEFILE                0xF001
#define AFX_IDS_ALLFILTER               0xF002
#define AFX_IDS_UNTITLED                0xF003
#define AFX_IDS_SAVEFILECOPY            0xF004
#define AFX_IDS_PREVIEW_CLOSE           0xF005
#define AFX_IDS_UNNAMED_FILE            0xF006
#define AFX_IDS_HIDE                    0xF011

// MFC Standard Exception Error messages
#define AFX_IDP_NO_ERROR_AVAILABLE      0xF020
#define AFX_IDS_NOT_SUPPORTED_EXCEPTION 0xF021
#define AFX_IDS_RESOURCE_EXCEPTION      0xF022
#define AFX_IDS_MEMORY_EXCEPTION        0xF023
#define AFX_IDS_USER_EXCEPTION          0xF024

// Printing and print preview strings
#define AFX_IDS_PRINTONPORT             0xF040
#define AFX_IDS_ONEPAGE                 0xF041
#define AFX_IDS_TWOPAGE                 0xF042
#define AFX_IDS_PRINTPAGENUM            0xF043
#define AFX_IDS_PREVIEWPAGEDESC         0xF044
#define AFX_IDS_PRINTDEFAULTEXT         0xF045
#define AFX_IDS_PRINTDEFAULT            0xF046
#define AFX_IDS_PRINTFILTER             0xF047
#define AFX_IDS_PRINTCAPTION            0xF048
#define AFX_IDS_PRINTTOFILE             0xF049


// OLE strings
#define AFX_IDS_OBJECT_MENUITEM         0xF080
#define AFX_IDS_EDIT_VERB               0xF081
#define AFX_IDS_ACTIVATE_VERB           0xF082
#define AFX_IDS_CHANGE_LINK             0xF083
#define AFX_IDS_AUTO                    0xF084
#define AFX_IDS_MANUAL                  0xF085
#define AFX_IDS_FROZEN                  0xF086
#define AFX_IDS_ALL_FILES               0xF087
// dynamically changing menu items
#define AFX_IDS_SAVE_MENU               0xF088
#define AFX_IDS_UPDATE_MENU             0xF089
#define AFX_IDS_SAVE_AS_MENU            0xF08A
#define AFX_IDS_SAVE_COPY_AS_MENU       0xF08B
#define AFX_IDS_EXIT_MENU               0xF08C
#define AFX_IDS_UPDATING_ITEMS          0xF08D
// COlePasteSpecialDialog defines
#define AFX_IDS_METAFILE_FORMAT         0xF08E
#define AFX_IDS_DIB_FORMAT              0xF08F
#define AFX_IDS_BITMAP_FORMAT           0xF090
#define AFX_IDS_LINKSOURCE_FORMAT       0xF091
#define AFX_IDS_EMBED_FORMAT            0xF092
// other OLE utility strings
#define AFX_IDS_PASTELINKEDTYPE         0xF094
#define AFX_IDS_UNKNOWNTYPE             0xF095
#define AFX_IDS_RTF_FORMAT              0xF096
#define AFX_IDS_TEXT_FORMAT             0xF097
// OLE datatype format error strings
#define AFX_IDS_INVALID_CURRENCY        0xF098
#define AFX_IDS_INVALID_DATETIME        0xF099
#define AFX_IDS_INVALID_DATETIMESPAN    0xF09A

// General error / prompt strings
#define AFX_IDP_INVALID_FILENAME        0xF100
#define AFX_IDP_FAILED_TO_OPEN_DOC      0xF101
#define AFX_IDP_FAILED_TO_SAVE_DOC      0xF102
#define AFX_IDP_ASK_TO_SAVE             0xF103
#define AFX_IDP_FAILED_TO_CREATE_DOC    0xF104
#define AFX_IDP_FILE_TOO_LARGE          0xF105
#define AFX_IDP_FAILED_TO_START_PRINT   0xF106
#define AFX_IDP_FAILED_TO_LAUNCH_HELP   0xF107
#define AFX_IDP_INTERNAL_FAILURE        0xF108      // general failure
#define AFX_IDP_COMMAND_FAILURE         0xF109      // command failure
#define AFX_IDP_FAILED_MEMORY_ALLOC     0xF10A
#define AFX_IDP_UNREG_DONE              0xF10B
#define AFX_IDP_UNREG_FAILURE           0xF10C
#define AFX_IDP_DLL_LOAD_FAILED         0xF10D
#define AFX_IDP_DLL_BAD_VERSION         0xF10E

// DDV parse errors
#define AFX_IDP_PARSE_INT               0xF110
#define AFX_IDP_PARSE_REAL              0xF111
#define AFX_IDP_PARSE_INT_RANGE         0xF112
#define AFX_IDP_PARSE_REAL_RANGE        0xF113
#define AFX_IDP_PARSE_STRING_SIZE       0xF114
#define AFX_IDP_PARSE_RADIO_BUTTON      0xF115
#define AFX_IDP_PARSE_BYTE              0xF116
#define AFX_IDP_PARSE_UINT              0xF117
#define AFX_IDP_PARSE_DATETIME          0xF118
#define AFX_IDP_PARSE_CURRENCY          0xF119

// CFile/CArchive error strings for user failure
#define AFX_IDP_FAILED_INVALID_FORMAT   0xF120
#define AFX_IDP_FAILED_INVALID_PATH     0xF121
#define AFX_IDP_FAILED_DISK_FULL        0xF122
#define AFX_IDP_FAILED_ACCESS_READ      0xF123
#define AFX_IDP_FAILED_ACCESS_WRITE     0xF124
#define AFX_IDP_FAILED_IO_ERROR_READ    0xF125
#define AFX_IDP_FAILED_IO_ERROR_WRITE   0xF126

// OLE errors / prompt strings
#define AFX_IDP_STATIC_OBJECT           0xF180
#define AFX_IDP_FAILED_TO_CONNECT       0xF181
#define AFX_IDP_SERVER_BUSY             0xF182
#define AFX_IDP_BAD_VERB                0xF183
#define AFX_IDS_NOT_DOCOBJECT                0xF184
#define AFX_IDP_FAILED_TO_NOTIFY        0xF185
#define AFX_IDP_FAILED_TO_LAUNCH        0xF186
#define AFX_IDP_ASK_TO_UPDATE           0xF187
#define AFX_IDP_FAILED_TO_UPDATE        0xF188
#define AFX_IDP_FAILED_TO_REGISTER      0xF189
#define AFX_IDP_FAILED_TO_AUTO_REGISTER 0xF18A
#define AFX_IDP_FAILED_TO_CONVERT       0xF18B
#define AFX_IDP_GET_NOT_SUPPORTED       0xF18C
#define AFX_IDP_SET_NOT_SUPPORTED       0xF18D
#define AFX_IDP_ASK_TO_DISCARD          0xF18E
#define AFX_IDP_FAILED_TO_CREATE        0xF18F

// MAPI errors / prompt strings
#define AFX_IDP_FAILED_MAPI_LOAD        0xF190
#define AFX_IDP_INVALID_MAPI_DLL        0xF191
#define AFX_IDP_FAILED_MAPI_SEND        0xF192

#define AFX_IDP_FILE_NONE               0xF1A0
#define AFX_IDP_FILE_GENERIC            0xF1A1
#define AFX_IDP_FILE_NOT_FOUND          0xF1A2
#define AFX_IDP_FILE_BAD_PATH           0xF1A3
#define AFX_IDP_FILE_TOO_MANY_OPEN      0xF1A4
#define AFX_IDP_FILE_ACCESS_DENIED      0xF1A5
#define AFX_IDP_FILE_INVALID_FILE       0xF1A6
#define AFX_IDP_FILE_REMOVE_CURRENT     0xF1A7
#define AFX_IDP_FILE_DIR_FULL           0xF1A8
#define AFX_IDP_FILE_BAD_SEEK           0xF1A9
#define AFX_IDP_FILE_HARD_IO            0xF1AA
#define AFX_IDP_FILE_SHARING            0xF1AB
#define AFX_IDP_FILE_LOCKING            0xF1AC
#define AFX_IDP_FILE_DISKFULL           0xF1AD
#define AFX_IDP_FILE_EOF                0xF1AE

#define AFX_IDP_ARCH_NONE               0xF1B0
#define AFX_IDP_ARCH_GENERIC            0xF1B1
#define AFX_IDP_ARCH_READONLY           0xF1B2
#define AFX_IDP_ARCH_ENDOFFILE          0xF1B3
#define AFX_IDP_ARCH_WRITEONLY          0xF1B4
#define AFX_IDP_ARCH_BADINDEX           0xF1B5
#define AFX_IDP_ARCH_BADCLASS           0xF1B6
#define AFX_IDP_ARCH_BADSCHEMA          0xF1B7

#define AFX_IDS_OCC_SCALEUNITS_PIXELS   0xF1C0

// 0xf200-0xf20f reserved

// font names and point sizes
#define AFX_IDS_STATUS_FONT             0xF230
#define AFX_IDS_TOOLTIP_FONT            0xF231
#define AFX_IDS_UNICODE_FONT            0xF232
#define AFX_IDS_MINI_FONT               0xF233

// ODBC Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_SQL_FIRST                       0xF280
#endif //!RC_INVOKED
#define AFX_IDP_SQL_CONNECT_FAIL                0xF281
#define AFX_IDP_SQL_RECORDSET_FORWARD_ONLY      0xF282
#define AFX_IDP_SQL_EMPTY_COLUMN_LIST           0xF283
#define AFX_IDP_SQL_FIELD_SCHEMA_MISMATCH       0xF284
#define AFX_IDP_SQL_ILLEGAL_MODE                0xF285
#define AFX_IDP_SQL_MULTIPLE_ROWS_AFFECTED      0xF286
#define AFX_IDP_SQL_NO_CURRENT_RECORD           0xF287
#define AFX_IDP_SQL_NO_ROWS_AFFECTED            0xF288
#define AFX_IDP_SQL_RECORDSET_READONLY          0xF289
#define AFX_IDP_SQL_SQL_NO_TOTAL                0xF28A
#define AFX_IDP_SQL_ODBC_LOAD_FAILED            0xF28B
#define AFX_IDP_SQL_DYNASET_NOT_SUPPORTED       0xF28C
#define AFX_IDP_SQL_SNAPSHOT_NOT_SUPPORTED      0xF28D
#define AFX_IDP_SQL_API_CONFORMANCE             0xF28E
#define AFX_IDP_SQL_SQL_CONFORMANCE             0xF28F
#define AFX_IDP_SQL_NO_DATA_FOUND               0xF290
#define AFX_IDP_SQL_ROW_UPDATE_NOT_SUPPORTED    0xF291
#define AFX_IDP_SQL_ODBC_V2_REQUIRED            0xF292
#define AFX_IDP_SQL_NO_POSITIONED_UPDATES       0xF293
#define AFX_IDP_SQL_LOCK_MODE_NOT_SUPPORTED     0xF294
#define AFX_IDP_SQL_DATA_TRUNCATED              0xF295
#define AFX_IDP_SQL_ROW_FETCH                   0xF296
#define AFX_IDP_SQL_INCORRECT_ODBC              0xF297
#define AFX_IDP_SQL_UPDATE_DELETE_FAILED        0xF298
#define AFX_IDP_SQL_DYNAMIC_CURSOR_NOT_SUPPORTED    0xF299
#define AFX_IDP_SQL_FIELD_NOT_FOUND             0xF29A
#define AFX_IDP_SQL_BOOKMARKS_NOT_SUPPORTED     0xF29B
#define AFX_IDP_SQL_BOOKMARKS_NOT_ENABLED       0xF29C

// ODBC Database strings
#define AFX_IDS_DELETED                         0xF29D

// DAO Database errors / prompt strings
#ifndef RC_INVOKED      // code only
#define AFX_IDP_DAO_FIRST                       0xF2B0
#endif //!RC_INVOKED
#define AFX_IDP_DAO_ENGINE_INITIALIZATION       0xF2B0
#define AFX_IDP_DAO_DFX_BIND                    0xF2B1
#define AFX_IDP_DAO_OBJECT_NOT_OPEN             0xF2B2

// ICDAORecordset::GetRows Errors
//  These are not placed in DAO Errors collection
//  and must be handled directly by MFC.
#define AFX_IDP_DAO_ROWTOOSHORT                 0xF2B3
#define AFX_IDP_DAO_BADBINDINFO                 0xF2B4
#define AFX_IDP_DAO_COLUMNUNAVAILABLE           0xF2B5

/////////////////////////////////////////////////////////////////////////////
// Strings for ISAPI support

#define AFX_IDS_HTTP_TITLE              0xF2D1
#define AFX_IDS_HTTP_NO_TEXT            0xF2D2
#define AFX_IDS_HTTP_BAD_REQUEST        0xF2D3
#define AFX_IDS_HTTP_AUTH_REQUIRED      0xF2D4
#define AFX_IDS_HTTP_FORBIDDEN          0xF2D5
#define AFX_IDS_HTTP_NOT_FOUND          0xF2D6
#define AFX_IDS_HTTP_SERVER_ERROR       0xF2D7
#define AFX_IDS_HTTP_NOT_IMPLEMENTED    0xF2D8

/////////////////////////////////////////////////////////////////////////////
// AFX implementation - control IDs (AFX_IDC)

// Parts of dialogs
#define AFX_IDC_LISTBOX                 100
#define AFX_IDC_CHANGE                  101

// for print dialog
#define AFX_IDC_PRINT_DOCNAME           201
#define AFX_IDC_PRINT_PRINTERNAME       202
#define AFX_IDC_PRINT_PORTNAME          203
#define AFX_IDC_PRINT_PAGENUM           204

// Property Sheet control id's (determined with Spy++)
#define ID_APPLY_NOW                    0x3021
#define ID_WIZBACK                      0x3023
#define ID_WIZNEXT                      0x3024
#define ID_WIZFINISH                    0x3025
#define AFX_IDC_TAB_CONTROL             0x3020

/////////////////////////////////////////////////////////////////////////////
// IDRs for standard components

#ifndef RC_INVOKED  // code only
// These are really COMMDLG dialogs, so there usually isn't a resource
// for them, but these IDs are used as help IDs.
#define AFX_IDD_FILEOPEN                28676
#define AFX_IDD_FILESAVE                28677
#define AFX_IDD_FONT                    28678
#define AFX_IDD_COLOR                   28679
#define AFX_IDD_PRINT                   28680
#define AFX_IDD_PRINTSETUP              28681
#define AFX_IDD_FIND                    28682
#define AFX_IDD_REPLACE                 28683
#endif //!RC_INVOKED

// Standard dialogs app should leave alone (0x7801->)
#define AFX_IDD_NEWTYPEDLG              30721
#define AFX_IDD_PRINTDLG                30722
#define AFX_IDD_PREVIEW_TOOLBAR         30723

// Dialogs defined for OLE2UI library
#define AFX_IDD_INSERTOBJECT            30724
#define AFX_IDD_CHANGEICON              30725
#define AFX_IDD_CONVERT                 30726
#define AFX_IDD_PASTESPECIAL            30727
#define AFX_IDD_EDITLINKS               30728
#define AFX_IDD_FILEBROWSE              30729
#define AFX_IDD_BUSY                    30730

#define AFX_IDD_OBJECTPROPERTIES        30732
#define AFX_IDD_CHANGESOURCE            30733

// Standard cursors (0x7901->)
    // AFX_IDC = Cursor resources
#define AFX_IDC_CONTEXTHELP             30977       // context sensitive help
#define AFX_IDC_MAGNIFY                 30978       // print preview zoom
#define AFX_IDC_SMALLARROWS             30979       // splitter
#define AFX_IDC_HSPLITBAR               30980       // splitter
#define AFX_IDC_VSPLITBAR               30981       // splitter
#define AFX_IDC_NODROPCRSR              30982       // No Drop Cursor
#define AFX_IDC_TRACKNWSE               30983       // tracker
#define AFX_IDC_TRACKNESW               30984       // tracker
#define AFX_IDC_TRACKNS                 30985       // tracker
#define AFX_IDC_TRACKWE                 30986       // tracker
#define AFX_IDC_TRACK4WAY               30987       // tracker
#define AFX_IDC_MOVE4WAY                30988       // resize bar (server only)

// Mini frame window bitmap ID
#define AFX_IDB_MINIFRAME_MENU          30994

// CheckListBox checks bitmap ID
#define AFX_IDB_CHECKLISTBOX_NT         30995
#define AFX_IDB_CHECKLISTBOX_95         30996

// AFX standard accelerator resources
#define AFX_IDR_PREVIEW_ACCEL           30997

// AFX standard ICON IDs (for MFC V1 apps) (0x7A01->)
#define AFX_IDI_STD_MDIFRAME            31233
#define AFX_IDI_STD_FRAME               31234

/////////////////////////////////////////////////////////////////////////////
// AFX OLE control implementation - control IDs (AFX_IDC)

// Font property page
#define AFX_IDC_FONTPROP                1000
#define AFX_IDC_FONTNAMES               1001
#define AFX_IDC_FONTSTYLES              1002
#define AFX_IDC_FONTSIZES               1003
#define AFX_IDC_STRIKEOUT               1004
#define AFX_IDC_UNDERLINE               1005
#define AFX_IDC_SAMPLEBOX               1006

// Color property page
#define AFX_IDC_COLOR_BLACK             1100
#define AFX_IDC_COLOR_WHITE             1101
#define AFX_IDC_COLOR_RED               1102
#define AFX_IDC_COLOR_GREEN             1103
#define AFX_IDC_COLOR_BLUE              1104
#define AFX_IDC_COLOR_YELLOW            1105
#define AFX_IDC_COLOR_MAGENTA           1106
#define AFX_IDC_COLOR_CYAN              1107
#define AFX_IDC_COLOR_GRAY              1108
#define AFX_IDC_COLOR_LIGHTGRAY         1109
#define AFX_IDC_COLOR_DARKRED           1110
#define AFX_IDC_COLOR_DARKGREEN         1111
#define AFX_IDC_COLOR_DARKBLUE          1112
#define AFX_IDC_COLOR_LIGHTBROWN        1113
#define AFX_IDC_COLOR_DARKMAGENTA       1114
#define AFX_IDC_COLOR_DARKCYAN          1115
#define AFX_IDC_COLORPROP               1116
#define AFX_IDC_SYSTEMCOLORS            1117

// Picture porperty page
#define AFX_IDC_PROPNAME                1201
#define AFX_IDC_PICTURE                 1202
#define AFX_IDC_BROWSE                  1203
#define AFX_IDC_CLEAR                   1204

/////////////////////////////////////////////////////////////////////////////
// IDRs for OLE control standard components

// Standard propery page dialogs app should leave alone (0x7E01->)
#define AFX_IDD_PROPPAGE_COLOR         32257
#define AFX_IDD_PROPPAGE_FONT          32258
#define AFX_IDD_PROPPAGE_PICTURE       32259

#define AFX_IDB_TRUETYPE               32384

/////////////////////////////////////////////////////////////////////////////
// Standard OLE control strings

// OLE Control page strings
#define AFX_IDS_PROPPAGE_UNKNOWN        0xFE01
#define AFX_IDS_COLOR_DESKTOP           0xFE04
#define AFX_IDS_COLOR_APPWORKSPACE      0xFE05
#define AFX_IDS_COLOR_WNDBACKGND        0xFE06
#define AFX_IDS_COLOR_WNDTEXT           0xFE07
#define AFX_IDS_COLOR_MENUBAR           0xFE08
#define AFX_IDS_COLOR_MENUTEXT          0xFE09
#define AFX_IDS_COLOR_ACTIVEBAR         0xFE0A
#define AFX_IDS_COLOR_INACTIVEBAR       0xFE0B
#define AFX_IDS_COLOR_ACTIVETEXT        0xFE0C
#define AFX_IDS_COLOR_INACTIVETEXT      0xFE0D
#define AFX_IDS_COLOR_ACTIVEBORDER      0xFE0E
#define AFX_IDS_COLOR_INACTIVEBORDER    0xFE0F
#define AFX_IDS_COLOR_WNDFRAME          0xFE10
#define AFX_IDS_COLOR_SCROLLBARS        0xFE11
#define AFX_IDS_COLOR_BTNFACE           0xFE12
#define AFX_IDS_COLOR_BTNSHADOW         0xFE13
#define AFX_IDS_COLOR_BTNTEXT           0xFE14
#define AFX_IDS_COLOR_BTNHIGHLIGHT      0xFE15
#define AFX_IDS_COLOR_DISABLEDTEXT      0xFE16
#define AFX_IDS_COLOR_HIGHLIGHT         0xFE17
#define AFX_IDS_COLOR_HIGHLIGHTTEXT     0xFE18
#define AFX_IDS_REGULAR                 0xFE19
#define AFX_IDS_BOLD                    0xFE1A
#define AFX_IDS_ITALIC                  0xFE1B
#define AFX_IDS_BOLDITALIC              0xFE1C
#define AFX_IDS_SAMPLETEXT              0xFE1D
#define AFX_IDS_DISPLAYSTRING_FONT      0xFE1E
#define AFX_IDS_DISPLAYSTRING_COLOR     0xFE1F
#define AFX_IDS_DISPLAYSTRING_PICTURE   0xFE20
#define AFX_IDS_PICTUREFILTER           0xFE21
#define AFX_IDS_PICTYPE_UNKNOWN         0xFE22
#define AFX_IDS_PICTYPE_NONE            0xFE23
#define AFX_IDS_PICTYPE_BITMAP          0xFE24
#define AFX_IDS_PICTYPE_METAFILE        0xFE25
#define AFX_IDS_PICTYPE_ICON            0xFE26
#define AFX_IDS_COLOR_PPG               0xFE28
#define AFX_IDS_COLOR_PPG_CAPTION       0xFE29
#define AFX_IDS_FONT_PPG                0xFE2A
#define AFX_IDS_FONT_PPG_CAPTION        0xFE2B
#define AFX_IDS_PICTURE_PPG             0xFE2C
#define AFX_IDS_PICTURE_PPG_CAPTION     0xFE2D
#define AFX_IDS_PICTUREBROWSETITLE      0xFE30
#define AFX_IDS_BORDERSTYLE_0           0xFE31
#define AFX_IDS_BORDERSTYLE_1           0xFE32

// OLE Control verb names
#define AFX_IDS_VERB_EDIT               0xFE40
#define AFX_IDS_VERB_PROPERTIES         0xFE41

// OLE Control internal error messages
#define AFX_IDP_PICTURECANTOPEN         0xFE83
#define AFX_IDP_PICTURECANTLOAD         0xFE84
#define AFX_IDP_PICTURETOOLARGE         0xFE85
#define AFX_IDP_PICTUREREADFAILED       0xFE86

// Standard OLE Control error strings
#define AFX_IDP_E_ILLEGALFUNCTIONCALL       0xFEA0
#define AFX_IDP_E_OVERFLOW                  0xFEA1
#define AFX_IDP_E_OUTOFMEMORY               0xFEA2
#define AFX_IDP_E_DIVISIONBYZERO            0xFEA3
#define AFX_IDP_E_OUTOFSTRINGSPACE          0xFEA4
#define AFX_IDP_E_OUTOFSTACKSPACE           0xFEA5
#define AFX_IDP_E_BADFILENAMEORNUMBER       0xFEA6
#define AFX_IDP_E_FILENOTFOUND              0xFEA7
#define AFX_IDP_E_BADFILEMODE               0xFEA8
#define AFX_IDP_E_FILEALREADYOPEN           0xFEA9
#define AFX_IDP_E_DEVICEIOERROR             0xFEAA
#define AFX_IDP_E_FILEALREADYEXISTS         0xFEAB
#define AFX_IDP_E_BADRECORDLENGTH           0xFEAC
#define AFX_IDP_E_DISKFULL                  0xFEAD
#define AFX_IDP_E_BADRECORDNUMBER           0xFEAE
#define AFX_IDP_E_BADFILENAME               0xFEAF
#define AFX_IDP_E_TOOMANYFILES              0xFEB0
#define AFX_IDP_E_DEVICEUNAVAILABLE         0xFEB1
#define AFX_IDP_E_PERMISSIONDENIED          0xFEB2
#define AFX_IDP_E_DISKNOTREADY              0xFEB3
#define AFX_IDP_E_PATHFILEACCESSERROR       0xFEB4
#define AFX_IDP_E_PATHNOTFOUND              0xFEB5
#define AFX_IDP_E_INVALIDPATTERNSTRING      0xFEB6
#define AFX_IDP_E_INVALIDUSEOFNULL          0xFEB7
#define AFX_IDP_E_INVALIDFILEFORMAT         0xFEB8
#define AFX_IDP_E_INVALIDPROPERTYVALUE      0xFEB9
#define AFX_IDP_E_INVALIDPROPERTYARRAYINDEX 0xFEBA
#define AFX_IDP_E_SETNOTSUPPORTEDATRUNTIME  0xFEBB
#define AFX_IDP_E_SETNOTSUPPORTED           0xFEBC
#define AFX_IDP_E_NEEDPROPERTYARRAYINDEX    0xFEBD
#define AFX_IDP_E_SETNOTPERMITTED           0xFEBE
#define AFX_IDP_E_GETNOTSUPPORTEDATRUNTIME  0xFEBF
#define AFX_IDP_E_GETNOTSUPPORTED           0xFEC0
#define AFX_IDP_E_PROPERTYNOTFOUND          0xFEC1
#define AFX_IDP_E_INVALIDCLIPBOARDFORMAT    0xFEC2
#define AFX_IDP_E_INVALIDPICTURE            0xFEC3
#define AFX_IDP_E_PRINTERERROR              0xFEC4
#define AFX_IDP_E_CANTSAVEFILETOTEMP        0xFEC5
#define AFX_IDP_E_SEARCHTEXTNOTFOUND        0xFEC6
#define AFX_IDP_E_REPLACEMENTSTOOLONG       0xFEC7

/////////////////////////////////////////////////////////////////////////////

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif

#endif //__AFXRES_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\assemblyloadas.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// The ways that an Assembly can be loaded.
//

namespace Microsoft.CLRAdmin
  {
  // The technique to use when loading an Assembly from an AssemblyName.
  internal enum AssemblyLoadAs
    {
    // Use AssemblyName.GetAssemblyName to create AssemblyNames, and
    // use Assembly.Load to load the Assembly.  This causes the
    // assembly to be loaded into the Current AppDomain.
    Default,

    // Load AssemblyNames via AssemblyName.GetAssemblyName, and
    // create a new AppDomain to load the Assembly into.  This offers
    // the advantage that the custom paths can be used in creating the
    // new AppDomain, which may facilitate loading the Assembly.  The
    // paths that can change are the Application Base Path and the
    // Relative Search Path.
    Custom,

    // For testing /only/ (it's not exposed through the GUI);
    // Load AssemblyNames by setting the AssemblyName.CodeBase property.
    // Load Assemblies in a custom AppDomain.
    CustomGet

    } /* enum AssemblyLoadAs */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\assemblyref.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Cross-AppDomain Assembly References.
//

namespace Microsoft.CLRAdmin
{
    using System;
    using System.Reflection;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Security.Policy;
    using System.Collections;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Cryptography.X509Certificates;
    using System.Globalization;

  // A "reference" to an Assembly loaded into another AppDomain.
  //
  // This class must be a MarshalByRefObject, as attempting to pass an
  // Assembly between AppDomains causes "File not found" exceptions.
  //
  // This should attempt to mimic the interface exposed by the
  // System.Reflection.Assembly class as much as is feasable.
  internal class AssemblyRef : MarshalByRefObject
    {
    /** The Assembly we're interested in. */
    private Assembly m_a;

    /** Load the Assembly referred to by ``an'' into the current AppDomain. */
    internal void Load (AssemblyName an)
      {
      Trace.WriteLine ("AR: Loading Assembly: " + an.FullName);
        try
        {
            m_a = Assembly.Load (an);
        }
        catch(Exception)
        {
                m_a = Assembly.LoadFrom(an.CodeBase);
        }
      }
    internal void LoadFrom (String sName)
    {
        ChangeSecurityPolicyToFullTrust();
    
        if (CheckAgainstExecutingAssembly(sName))
            m_a = Assembly.GetExecutingAssembly();
        else
            m_a = Assembly.LoadFrom(sName);
    }

    void ChangeSecurityPolicyToFullTrust()
    {
        IEnumerator enumerator = SecurityManager.PolicyHierarchy();
                
        while (enumerator.MoveNext())
        {
            PolicyLevel level = (PolicyLevel)enumerator.Current;
            level.RootCodeGroup = new UnionCodeGroup(new AllMembershipCondition(), new PolicyStatement(new PermissionSet(PermissionState.Unrestricted)));
        }
    }// ChangeSecurityPolicyToFullTrust

    private bool CheckAgainstExecutingAssembly(String sName)
    {
        try
        {
            Uri u1 = new Uri(AssemblyName.GetAssemblyName(sName).CodeBase, true);
            Uri u2 = new Uri(Assembly.GetExecutingAssembly().GetName().CodeBase, true);
        
            return u1.ToString().ToLower(CultureInfo.InvariantCulture).Equals(u2.ToString().ToLower(CultureInfo.InvariantCulture));
        }
        catch(Exception)
        {
            return false;
        }
    }


    // Return an array of ModuleInfo objects, which provide information
    // for each Module loaded into the wrapped Assembly.

    /** Get the AssemblyName of the wrapped Assembly. */

    internal Evidence GetEvidence()
    {
        return m_a.Evidence;
    }// GetEvidence

    internal Hash GetHash()
    {
        return new Hash(m_a);
    }// GetHash   

    internal Assembly GetAssembly()
    { return m_a;}// GetAssembly
   
    internal AssemblyName GetName ()
    {return m_a.GetName();}

    internal X509Certificate GetCertificate()
    {
        IEnumerator enumerator = m_a.Evidence.GetHostEnumerator();

        while (enumerator.MoveNext())
        {
            Object o = (Object)enumerator.Current;
            if (o is Publisher)
                return ((Publisher)o).Certificate;
        }
        return null;
    }// GetCertificate

    /** Get the AssemblyName's that the wrapped Assembly is dependant on. */
    internal AssemblyName[] GetReferencedAssemblies ()
      {return m_a.GetReferencedAssemblies ();}

    /** Where the Assembly is located. */
    internal string CodeBase
      {get {return m_a.CodeBase;}}

    /** The Full Name of the Assembly. */
    internal string FullName
      {get {return m_a.FullName;}}

    } /* class AssemblyRef */
  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\assemblydependencies.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Contains the Assembly dependency information.
//

namespace Microsoft.CLRAdmin
  {
  using System;
  using System.Collections;
  using System.Reflection;
  using System.Diagnostics;


  /** Maps a Full Assembly Name to an AssemblyInfo object */
  using AssemblyMap = System.Collections.Hashtable;


  // Creates a list of AssemblyInfo objects, each accessible by the name of the
  // Assembly.
  //
  // The name of the Assembly manifest is available through the ManifestName
  // property.
  //
  // The array-index operator can be used on a manifest name to get the
  // AssemblyInfo object for the requested Assembly.
  internal class AssemblyDependencies
    {
    // map<string, AssemblyName>
    private AssemblyMap m_map = new AssemblyMap ();

    /** The name of the "root" Assembly of our dependency list */
    private string m_name;
    private ArrayList   m_alAssemInfo;

    LoadAssembly m_load;

    // Builds the list of Dependencies for the Assembly Manifest located in the
    // file ``name''.
    //
    // If ``name'' couldn't be loaded, an exception is thrown as the manifest
    // file doesn't exist or is invalid.  If one of ``names'' dependency's
    // can't be loaded, an exception is not thrown; instead, the
    // IAssemblyInfo object returned will hold exception information.
    //
    internal AssemblyDependencies (string name, LoadAssemblyInfo cai)
      {
      AssemblyRef ar= null;
      m_load = LoadAssembly.CreateLoader (cai);
      try
        {
        Trace.WriteLine ("Name: " + name);

        AssemblyName an = m_load.LoadAssemblyName (name);

        Trace.WriteLine ("assembly name: " + an.Name);
        Trace.WriteLine ("assembly full name: " + an.FullName);

        ar = m_load.LoadAssemblyFrom (an);

        Trace.WriteLine ("Successfully loaded assembly.");
        }
      catch (Exception e)
        {
        Trace.WriteLine ("m_load.LoadAssemblyFrom threw an exception:\n  " + 
          e.ToString());
        /* 
         * If ``m_load.LoadAssemblyFrom'' throws an exception, we want
         * our caller to get the exception.  However, since this is 
         * the constructor, we need to clean up any allocated resources --
         * in this case, the resouces of the LoadAssembly object.
         */
        m_load.Dispose ();
        throw e;
        }

      m_name = ar.FullName;

      IList search = new ArrayList ();
      m_alAssemInfo = new ArrayList();

      // Add the top-level object, the Assembly containing the manifest.
      // ``search'' will contain any Assemblies that the added object
      // references.
      m_map.Add (m_name, new AssemblyInfo (ar, search, m_alAssemInfo));

      // Get all referenced Assemblies.
      _traverse (search);
      }

    internal void DoneLoading()
    {
        m_load.Dispose ();
    }// DoneLoading

    // Overloading that specifies shared loading of Assemblies for the
    // file ``name''.
    internal AssemblyDependencies (String name)
      : this (name, new LoadAssemblyInfo ())
      {
      }

    // For each of the elements in l, if the Assembly name that it
    // references hasn't been followed, then we create an AssemblyInfo
    // object for it, and add it to m_map.
    private void _traverse (IList l)
      {
      while (l.Count != 0)
        {
        Object o = l[0];
        bool fError = false;
        l.Remove (o);
        AssemblyName an = (AssemblyName) o;

        AssemblyInfo ai;
        try
          {
          AssemblyRef assembly = m_load.LoadAssemblyFrom (an);
          ai = new AssemblyInfo (assembly, l, m_alAssemInfo);
          }
        catch (System.Exception e)
          {
          Trace.WriteLine ("Exception while loading dependency:\n  " +
            e.ToString());
            fError = true;  
          ai = new AssemblyInfo (an, m_alAssemInfo);

          }
        if (!fError)
            m_map.Add (an.FullName, ai);

        l = _minimize (l);
        }
      }

    internal ArrayList    Assems
    {
        get
        {
            return m_alAssemInfo;
        }
    }// Assems

    // Returns a new list of Assembly names consisting of names that
    // haven't already been visited (i.e., they aren't present in the
    // database).
    private IList _minimize (IList l)
      {
      IList r = new ArrayList ();
      foreach (AssemblyName an in l)
        {
        if (!m_map.Contains (an.FullName))
          r.Add (an);
        }
      return r;
      }

    // The name of the Assembly containing the Manifest File.
    internal String ManifestName
      {
      get
        {return m_name;}
      }
    
    // Accessor to access the AssemblyInfo object associated with 
    // an AssemblyName.
    internal AssemblyInfo this[String name]
      {
      get
        {return (AssemblyInfo) m_map[name];}
      }

    // Clean up all resources allocated to determine the dependencies.
    internal void Dispose ()
      {
      m_load.Dispose ();
      }

    // A collection of IAssemblyInfo objects for all the Assemblies
    // Loaded.
    internal ICollection Assemblies
      {
      get
        {
        Trace.WriteLine ("current map contents:");
        foreach (DictionaryEntry de in m_map)
          Trace.WriteLine ("  " + de.Key + ", " + de.Value);
        return m_map.Values;}
      }

    } /* class AssemblyDependencies */
  } // namespace namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\assemblyinfo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// Information about Assembly Manifests.
//

namespace Microsoft.CLRAdmin

  {
  using System;
  using System.Collections;
  using System.Reflection;
  using System.Diagnostics;


  // Contains (read-only) information about an Assembly, such as a list of the
  // Full Assembly Names of Assemblies it's dependant on, Modules that it
  // contains, it's name, and anything else useful.
  internal class AssemblyInfo
  {
    // list<AssemblyName>
    private ArrayList  m_dependencies = new ArrayList ();

    // list<ModuleInfo>
    private ArrayList  m_modules = new ArrayList ();

    private ArrayList  m_alAssemInfo;

    private string      m_name;

    private AssemblyRef m_assembly;

    // Determines the Assembly information.
    //
    internal AssemblyInfo (AssemblyRef assembly, IList next, ArrayList alAssemInfo)
      {
      m_name = assembly.FullName;
      m_assembly = assembly;
      m_alAssemInfo = alAssemInfo;
      _dependencies (assembly, next);
      }
    internal AssemblyInfo(AssemblyName an, ArrayList alAssemInfo)
    {
        m_name = an.FullName;
        m_assembly = null;
        m_alAssemInfo = alAssemInfo;

    }
    // Records all the Assemblies that the Assembly references (uses).
    private void _dependencies (AssemblyRef a, IList next)
      {
      AssemblyName[] aan = a.GetReferencedAssemblies ();

      Trace.WriteLine ("Assembly dependencies: ");
      foreach (AssemblyName an in aan)
        {
        Trace.WriteLine ("  " + an.FullName);
        m_dependencies.Add (an);
        next.Add (an);
        m_alAssemInfo.Add(an);
        }
      }

    /** Get the assembly this object is providing information for. */
    internal AssemblyRef GetAssembly ()
      {return m_assembly;}

    // The full name of this Assembly.
    //
    internal String Name
      {
      get
        {return m_name;}
      }

    // The error that occurred.
    //
    // If this object is actually created, then no error occurred.
    internal Exception Error
      {
      get
        {return null;}
      }

    // The assemblies that this Assembly is dependant on.
    internal ArrayList ReferencedAssemblies
      {
      get
        {return m_dependencies;}
      }
    }

  } /* namespace ADepends */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\lwhost\lwhost.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Drawing.Drawing2D;
using Microsoft.CLRAdmin;
using System.Runtime.InteropServices;
using System.Collections;

public struct PROPSHEETHEADER 
{
    public uint    dwSize;
    public uint    dwFlags;
    public IntPtr  hwndParent;
    public IntPtr  hInstance;
    // The following field is a union of 
    // HICON       hIcon;
    // LPCWSTR     pszIcon;

    public IntPtr hIcon;
    [MarshalAs(UnmanagedType.LPStr)] 
    public String  pszCaption;
    public uint    nPages;

    // The following field is a union of
    //        UINT        nStartPage;
    //        LPCWSTR     pStartPage;
    public uint    nStartPage;

    // The following field is a union of 
    //        LPCPROPSHEETPAGEW ppsp;
    //        HPROPSHEETPAGE FAR *phpage;
    public IntPtr  phpage;
    
    public PropSheetPageProc pfnCallback;

    // The following field is a union of
    //      HBITMAP hbmWatermark;
    //      LPCWSTR pszbmWatermark;
    public IntPtr  hbmWatermark;
    
    public IntPtr  hplWatermark;

    // The following field is a union of 
    //        HBITMAP hbmHeader;
    //        LPCWSTR pszbmHeader;
    public IntPtr  hbmHeader;
}// PROPSHEETHEADER


public class PSH
{
    public const uint DEFAULT             = 0x00000000;
    public const uint PROPTITLE           = 0x00000001;
    public const uint USEHICON            = 0x00000002;
    public const uint USEICONID           = 0x00000004;
    public const uint PROPSHEETPAGE       = 0x00000008;
    public const uint WIZARDHASFINISH     = 0x00000010;
    public const uint WIZARD              = 0x00000020;
    public const uint USEPSTARTPAGE       = 0x00000040;
    public const uint NOAPPLYNOW          = 0x00000080;
    public const uint USECALLBACK         = 0x00000100;
    public const uint HASHELP             = 0x00000200;
    public const uint MODELESS            = 0x00000400;
    public const uint RTLREADING          = 0x00000800;
    public const uint WIZARDCONTEXTHELP   = 0x00001000;

    public const uint WIZARD97            = 0x01000000;  
    public const uint WATERMARK           = 0x00008000;
    public const uint USEHBMWATERMARK     = 0x00010000;  // user pass in a hbmWatermark 
    public const uint USEHPLWATERMARK     = 0x00020000;  //
    public const uint STRETCHWATERMARK    = 0x00040000;  // stretchwatermark also applies 
    public const uint HEADER              = 0x00080000;
    public const uint USEHBMHEADER        = 0x00100000;
    public const uint USEPAGELANG         = 0x00200000;  // use frame dialog template 
    public const uint WIZARD_LITE         = 0x00400000;
    public const uint NOCONTEXTHELP       = 0x02000000;
 
}// class PSH




public class LWHost : Form, INonMMCHost, IConsole2, IConsoleNameSpace2, IConsoleVerb, IResultData, IPropertySheetProvider, IPropertySheetCallback
{
    // Spin up the Form
    [STAThread]
    public static void Main(string[] args)
    {
        Application.Run(new LWHost());
    }// Main

    // Winform controls
    private System.Windows.Forms.ListView m_lv;
    private System.Windows.Forms.Label m_lblHelp;
    private System.Windows.Forms.ImageList m_il;

    // MMC hosting stuff

    CData           m_cData;
    IComponent      m_component;
    PROPSHEETHEADER m_psh;
    Microsoft.CLRAdmin.IDataObject     m_doForPropSheet;
    ArrayList       m_alPropPages;

    public LWHost()
    {   

        // Create the form
        AddWinformsControls();

        // Now build our MMC stuff
        m_cData = new CData();

        // This will give CData access to the interfaces we implement
        m_cData.Initialize(this);
        m_cData.CreateComponent(out m_component);
        ExpandNodeList();
    }// LWHost

    void AddWinformsControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(LWHost));
        this.m_lv = new System.Windows.Forms.ListView();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_il = new System.Windows.Forms.ImageList();
        this.m_lv.Activation = System.Windows.Forms.ItemActivation.OneClick;
        this.m_lv.Alignment = ((System.Windows.Forms.ListViewAlignment)(resources.GetObject("m_lv.Alignment")));
        this.m_lv.LargeImageList = this.m_il;
        this.m_lv.Location = ((System.Drawing.Point)(resources.GetObject("m_lv.Location")));
        this.m_lv.MultiSelect = false;
        this.m_lv.Name = "m_lv";
        this.m_lv.Scrollable = true;
        this.m_lv.Size = ((System.Drawing.Size)(resources.GetObject("m_lv.Size")));
        this.m_lv.TabIndex = ((int)(resources.GetObject("m_lv.TabIndex")));
        
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Name = "m_lblHelp";
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        this.m_il.ColorDepth = System.Windows.Forms.ColorDepth.Depth8Bit;
        this.m_il.ImageSize = ((System.Drawing.Size)(resources.GetObject("m_il.ImageSize")));
        this.m_il.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("m_il.ImageStream")));
        this.m_il.TransparentColor = System.Drawing.Color.Transparent;
        this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
        this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lv,
                        this.m_lblHelp});
        this.Name = "Win32Form1";
        this.Text = resources.GetString("$this.Text");
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.MaximizeBox=false;
        this.MinimizeBox=false;
        this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
        // If this font doesn't exist on the system, we'll use the system default one
        try
        {
            this.Font = ((System.Drawing.Font)(resources.GetObject("$this.Font")));
        }
        catch(Exception)
        {}
    

        // Add the items to the listview
        m_lv.Items.Clear();
		m_lv.Items.Add(resources.GetString("AdjustSecurity.Text"), 0);
        m_lv.Items.Add(resources.GetString("TrustAssembly.Text"), 1);
        m_lv.Items.Add(resources.GetString("FixApp.Text"), 2);


		this.Closed += new EventHandler(onClose);
        m_lv.ItemActivate += new EventHandler(ButtonClicked);
    }// AddWinformsControls


    void onClose(Object o, EventArgs e)
    {
        m_cData.Destroy();
        Application.Exit();   
    }// onClose

    void ExpandNodeList()
    {
        // Ok, now this get interesting....
        Microsoft.CLRAdmin.IDataObject cdo;
        m_cData.QueryDataObject(0, 0, out cdo);
        m_cData.Notify(cdo, MMCN.EXPAND, (IntPtr)1, (IntPtr)((CDO)cdo).Node.Cookie);
    }// ExpandNodeList
    
    void ButtonClicked(Object o, EventArgs e)
    {
        if (m_lv.SelectedIndices.Count > 0)
            CCommandHistory.FireOffConsumerCommand(m_lv.SelectedIndices[0]);
    }// ButtonClick


    void Log(String s)
    {
       // m_lbLog.Items.Add(s);
    }// AddLog


    //-------------------------------------------------------
    // IPropertySheetProvider functions that we're going to implement
    //-------------------------------------------------------
    public void CreatePropertySheet(String title, int type, int cookie, Microsoft.CLRAdmin.IDataObject pIDataObject, uint dwOptions)
    {
        Log("CreatePropertySheet called");
        m_psh = new PROPSHEETHEADER();
        m_psh.dwSize = 52;
        m_psh.dwFlags = PSH.DEFAULT | PSH.NOCONTEXTHELP;
        // Set the flags

        if ((dwOptions & MMC_PSO.NOAPPLYNOW) > 0)
            m_psh.dwFlags |= PSH.NOAPPLYNOW;
        if ((dwOptions & MMC_PSO.HASHELP) > 0)
            m_psh.dwFlags |= PSH.HASHELP;
        // They want to do a wizard
        if (type == 0)
        {
            if ((dwOptions & MMC_PSO.NEWWIZARDTYPE) > 0)
                m_psh.dwFlags |= PSH.WIZARD97;
            else
                m_psh.dwFlags |= PSH.WIZARD;
        }
        if ((dwOptions & MMC_PSO.NO_PROPTITLE) == 0)
            m_psh.dwFlags |= PSH.PROPTITLE;

        m_psh.hwndParent = this.Handle;
        m_psh.hInstance = Marshal.GetHINSTANCE(this.GetType().Module);
        m_psh.pszCaption = title;
        m_psh.nStartPage = 0;
        m_doForPropSheet = pIDataObject;
        m_alPropPages = new ArrayList();
               
    }// CreatePropertySheet
    public void AddPrimaryPages(Object lpUnknown, int bCreateHandle, int hNotifyWindow,int bScopePane)
    {
        Log("AddPrimaryPages called");
        
        IExtendPropertySheet2 eps = (IExtendPropertySheet2)lpUnknown;
        eps.CreatePropertyPages(this, (IntPtr)(-1), m_doForPropSheet);


        // If this is a wizard, grab the bitmap and header info.
        if ((m_psh.dwFlags & PSH.WIZARD97) > 0)
        {
            Log("Creating a Wizard97");
            
            IntPtr  lphWatermark;
            IntPtr  lphHeader;
            IntPtr  lphPalette;
            int     fStretch;
            eps.GetWatermarks(m_doForPropSheet, out lphWatermark, out lphHeader, out lphPalette, out fStretch);

            if (fStretch > 0)
                m_psh.dwFlags|=PSH.STRETCHWATERMARK;

            if (lphWatermark != (IntPtr)0)
            {
                Log("Got a watermark: Value is " + lphWatermark.ToString());
                m_psh.dwFlags |= (PSH.WATERMARK | PSH.USEHBMWATERMARK);
                m_psh.hbmWatermark = lphWatermark;
            }

            if (lphHeader != (IntPtr)0)
            {
                Log("Got a header: Value is " + lphHeader.ToString());
                m_psh.dwFlags |= (PSH.HEADER | PSH.USEHBMHEADER);
                m_psh.hbmHeader = lphHeader;
            }            
        }

    }// AddPrimaryPages
    public void Show(IntPtr window, int page)
    {
        m_psh.nStartPage = (uint)page;
       
        // Create our array of Property Page handles
        IntPtr  hPages = Marshal.AllocHGlobal(m_alPropPages.Count*4);
        for(int i=0; i<m_alPropPages.Count; i++)
            Marshal.WriteIntPtr(hPages, i*4, (IntPtr)m_alPropPages[i]);
       


        m_psh.phpage = hPages;
        m_psh.nPages = (uint)m_alPropPages.Count;
        int nRet = PropertySheet(ref m_psh);
        Marshal.FreeHGlobal(hPages);

        Log("Property Sheet returned " + nRet);
    }// Show

    //-------------------------------------------------------
    // IPropertySheetCallback functions that we're going to implement
    //-------------------------------------------------------
    public void AddPage(IntPtr hPage)
    {
        Log("Adding Property Page");
        m_alPropPages.Add(hPage);
    }// AddPage

    //-------------------------------------------------------
    // IConsoleNameSpace2 functions that we're going to implement
    //-------------------------------------------------------
    public void Expand(int a)
    {
        // We need to do something here
        Log(a + " asked to be expanded");
        Microsoft.CLRAdmin.IDataObject cdo;
        m_cData.QueryDataObject(a, 0, out cdo);
        m_cData.Notify(cdo, MMCN.EXPAND, (IntPtr)1, (IntPtr)((CDO)cdo).Node.Cookie);

    }// Expand

    public void InsertItem(ref SCOPEDATAITEM a)
    {
        // We'll make the cookie the same as the HScope Item
        a.ID = a.lParam;
    }// InsertItem


    //-------------------------------------------------------
    // IConsole2 functions that we're going to implement
    //-------------------------------------------------------
    public void QueryResultView([MarshalAs(UnmanagedType.Interface)] out Object pUnknown)
    {
        pUnknown = this;
    }// QueryResultView
    public void QueryConsoleVerb(out IConsoleVerb ppConsoleVerb)
    {
        ppConsoleVerb = this;
    }// QueryConsoleVerb
    public void GetMainWindow(out IntPtr phwnd)
    {
        phwnd = this.Handle;
    }// GetMainWindow

    public void QueryScopeImageList(out IImageList ppImageList)
    {
        ppImageList = null;
    }// QueryScopeImageList


    //-------------------------------------------------------
    // IConsole2 functions that we're not going to implement
    //-------------------------------------------------------
    public void SetHeader(ref IHeaderCtrl pHeader)
    {}
    public void SetToolbar([MarshalAs(UnmanagedType.Interface)] ref Object pToolbar)
    {}
    public void QueryResultImageList(out IImageList ppImageList)
    {
        ppImageList = null;
    }
    public void UpdateAllViews(Microsoft.CLRAdmin.IDataObject lpDataObject, int data, int hint)
    {}
    public void MessageBox([MarshalAs(UnmanagedType.LPWStr)] String lpszText, [MarshalAs(UnmanagedType.LPWStr)] String lpszTitle, uint fuStyle, ref int piRetval)
    {}
    public void SelectScopeItem(int hScopeItem)
    {}
    public void NewWindow(int hScopeItem, uint lOptions)
    {}
    public void Expand(int hItem, int bExpand)
    {}
    public void IsTaskpadViewPreferred()
    {}
    public void SetStatusText([MarshalAs(UnmanagedType.LPWStr)]String pszStatusText)
    {}

    //-------------------------------------------------------
    // IConsoleNameSpace2 functions that we're not going to implement
    //-------------------------------------------------------
    public void DeleteItem(int a, int b)
    {}
    public void SetItem(ref SCOPEDATAITEM a)
    {}
    public void GetItem(ref SCOPEDATAITEM a)
    {}
    public void GetChildItem(uint a, ref uint b, ref int c)
    {}
    public void GetNextItem(uint a, ref uint b, ref int c)
    {}
    public void GetParentItem(int a, out int b, out int c)
    {
        b=0;c=0;
    }
    public void AddExtension(CLSID a, ref SCOPEDATAITEM b)
    {}

    //-------------------------------------------------------
    // IConsoleVerb functions that we're not going to implement
    //-------------------------------------------------------
    public void GetVerbState(uint eCmdID, uint nState, ref int pState)
    {}
    public void SetVerbState(uint eCmdID, uint nState, int bState)
    {}
    public void SetDefaultVerb(uint eCmdID)
    {}
    public void GetDefaultVerb(ref uint peCmdID)
    {}

    //-------------------------------------------------------
    // IResultData functions that we're not going to implement
    //-------------------------------------------------------
    public void InsertItem(ref RESULTDATAITEM item)
    {}
    public void DeleteItem(uint itemID, int nCol)
    {}
    public void FindItemByLParam(int lParam, out uint pItemID)
    {
        pItemID=0;
    }
    public void DeleteAllRsltItems()
    {}
    public void SetItem(ref RESULTDATAITEM item)
    {}
    public int  GetItem(ref RESULTDATAITEM item)
    {
        return -1;
    }
    public int  GetNextItem(ref RESULTDATAITEM item)
    {
        return -1;
    }
    public void ModifyItemState(int nIndex, uint itemID, uint uAdd, uint uRemove)
    {}
    public void ModifyViewStyle(int add, int remove)
    {}
    public void SetViewMode(int lViewMode)
    {}
    public void GetViewMode(out int lViewMode)
    {
        lViewMode = -1;
    }
    public void UpdateItem(uint itemID)
    {}
    public void Sort(int nColumn, uint dwSortOptions, int lUserParam)
    {}
    public void SetDescBarText(int DescText)
    {}
    public void SetItemCount(int nItemCount, uint dwOption)
    {}

    //-------------------------------------------------------
    // IPropertySheetProvider functions that we're not going to implement
    //-------------------------------------------------------
    public int FindPropertySheet(int cookie, IComponent lpComponent, Microsoft.CLRAdmin.IDataObject lpDataObject)
    {
        return 1;
    }
    public void AddExtensionPages()
    {}

    //-------------------------------------------------------
    // IPropertySheetCallback functions that we're not going to implement
    //-------------------------------------------------------
    public void RemovePage(IntPtr hPage)
    {}

    [DllImport("comctl32.dll")]
    public static extern int PropertySheet(ref PROPSHEETHEADER psp);



}// class LWHost
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cabout.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CAbout.cs
//
// This implements the object that is responsible for communicating
// "about" information to the MMC.
//
// Its GUID is {9F6932F1-4A16-49d0-9CCA-0DCC977C41AA}
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Runtime.InteropServices;

[Guid("9F6932F1-4A16-49d0-9CCA-0DCC977C41AA")]
public class CAbout : ISnapinAbout
{
    IntPtr m_hMainBMP16;        // Handle for the 16x16 main bitmap
    IntPtr m_hMainBMP32;        // Handle for the 32x32 main bitmap

    //-------------------------------------------------
    // CAbout - Constructor
    //
    // The constructor is responsible for loading the about images
    // that will be displayed in the MMC
    //-------------------------------------------------
    public CAbout()
    {

        // Load the main bitmap as a 16x16 bitmap
        m_hMainBMP16 = CResourceStore.GetHBitmap("IDB_NET",
                                                 16,
                                                 16,
                                                 false);

        // Load the main bitmap as a 32x32 bitmap

        m_hMainBMP32 = CResourceStore.GetHBitmap("IDB_NET",
                                                 32,
                                                 32,
                                                 false);
    }// CAbout

    ~CAbout()
    {
        DeleteObject(m_hMainBMP16);
        DeleteObject(m_hMainBMP32);
    }// ~CAbout


    //-------------------------------------------------
    // GetSnapinDescription
    //
    // This returns the Description of the snapin through
    // a reference parameter
    //-------------------------------------------------
    public void GetSnapinDescription(out IntPtr lpDescription)
    {
        lpDescription = CResourceStore.GetCoString("CAbout:SnapinDescription");
    }// GetSnapinDescription

    //-------------------------------------------------
    // GetProvider
    //
    // This returns the provider of the snapin through
    // a reference parameter
    //-------------------------------------------------
    public void GetProvider(out IntPtr pName)
    {
        pName = CResourceStore.GetCoString("CAbout:SnapinProvider");
    }// GetProvider

    //-------------------------------------------------
    // GetSnapinVersion
    //
    // This returns the version of the snapin through
    // a reference parameter
    //-------------------------------------------------
    public void GetSnapinVersion(out IntPtr lpVersion)
    {
        lpVersion = Marshal.StringToCoTaskMemAuto(Util.Version.VersionString);
    }// GetSnapinVersion

    //-------------------------------------------------
    // GetSnapinImage
    //
    // This returns the image of the snapin through
    // a reference parameter that is used in the About
    // page that is referenced from the Add/Remove snapin
    // page.
    //-------------------------------------------------
    public void GetSnapinImage(out IntPtr hAppIcon)
    {   
       hAppIcon=CResourceStore.GetHIcon("NETappicon_ico");
    }// GetSnapinImage

    //-------------------------------------------------
    // GetStaticFolderImage
    //
    // This returns the Description of the snapin through
    // a reference parameter
    //-------------------------------------------------
    public void GetStaticFolderImage(out IntPtr hSmallImage, out IntPtr hSmallImageOpen, out IntPtr hLargeImage, out int cMask)
    {
        hSmallImage=hSmallImageOpen=m_hMainBMP16;
        hLargeImage=m_hMainBMP32;

        // The color mask on these bitmaps is pure white.... it could be different
        // with different bitmaps
        cMask=0x00FFFFFF;
    }// GetStaticFolderImage

    [DllImport("gdi32.dll")]
    internal static extern int DeleteObject(IntPtr hObject);

}// class CAbout
}//namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\caddpermissionswizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Security.Policy;
using System.Security.Permissions;
using System.Security;

internal class CAddPermissionsWizard: CSecurityWizard
{
    CPSetWrapper   m_ps;
    bool           m_fFinished;

    internal CAddPermissionsWizard(CPSetWrapper ps)
    {
        m_ps = ps;
        m_sName="Add Permissions Wizard";
        m_aPropSheetPage = new CPropPage[] {new CNewPermSetWiz2(Security.CreatePermissionArray(m_ps.PSet))};
        m_fFinished = false;
    }// CNewPermSetWizard

    private CNewPermSetWiz2 Page1
    {
        get{return (CNewPermSetWiz2)m_aPropSheetPage[0];}
    }

    protected override int WizSetActive(IntPtr hwnd)
    {
        m_fFinished = false;
        switch(GetPropPage(hwnd))
        {
            // If this is the first page of our wizard, we want a 
            // disabled next button to show
            case 0:
                TurnOnFinish(true);
                break;
        }
        return base.WizSetActive(hwnd);
                    
    }// WizSetActive

    internal bool didFinish
    {
        get{return m_fFinished;}
    }// didFinish

    protected override int WizFinish()
    {

        IPermission[] perms = Page1.RemovedPermissions;
        // Remove all the permissions the user wanted removed
        for(int i=0; i<perms.Length; i++)
        {
            // This will throw an exception if the user opened the wizard page,
            // added a permission, then removed it. It's not in the permission
            // set, so when we try and remove it, we should have an exception
            // thrown
            try
            {
                m_ps.PSet.RemovePermission(perms[i].GetType());
            }
            catch(Exception)
            {
            }
        }

        // Now add the permissions the user selected
        perms = Page1.Permissions;

        for(int i=0; i<perms.Length; i++)
            m_ps.PSet.SetPermission(perms[i]);

        m_ps.PolLevel.ChangeNamedPermissionSet(m_ps.PSet.Name, m_ps.PSet);
        m_fFinished = true;
        return 0;
    }// WizFinish
   
}// class CAddPermissionsWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\caddtrustedassemwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;

class CAddTrustedAssemWizard : CConfigAssemWizard
{
    internal CAddTrustedAssemWizard() : base(null);
    {
        m_sName = CResourceStore.GetString("Configure Assembly Wizard");
        m_sDisplayName = CResourceStore.GetString("Trusted Assembly Wizard");
        m_aPropSheetPage = new CPropPage[] {new CAddTrustedAssemWizard1()};

    }// CConfigAssemWizard
}// class CAddTrustedAssemWizard

class CAddTrustedAssemWizard1 : CConfigAssemWiz1
{
    internal CAddTrustedAssemWizard1() : base(null);
    {
        m_sHeaderTitle = CResourceStore.GetString("Fully Trust an Assembly");
        m_sHeaderSubTitle = CResourceStore.GetString("Choose an existing assembly from the Shared Assemblies Cache or enter the assembly information manually");
        m_sTitle = CResourceStore.GetString("Fully Trust an Assembly");
    }// CConfigAssemWiz1
}// CAddTrustedAssemWizard1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\capplication.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CApplication.cs
//
// This class represents a single Application.
//
// Its GUID is {C338CBF6-2F60-4e1b-8FB5-12FEAE2DD937}
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.Drawing;
using System.Collections;
using System.Runtime.InteropServices;
using System.Diagnostics;
using System.Globalization;


class CApplication : CNode
{
    // Structure that contains data about the application location and the
    // application's configuration file name and location
    private AppFiles m_appInfo;

    private Bitmap  m_bBigPic;
    //-------------------------------------------------
    // CApplication - Constructor
    //
    // Initializes some variables, and determines the icon
    // we'll be displaying for this application.
    //-------------------------------------------------
    internal CApplication(AppFiles appInfo)
    {
        // Standard stuff we need to set for all nodes
        m_sGuid = "C338CBF6-2F60-4e1b-8FB5-12FEAE2DD937";
        m_sHelpSection = "";
        m_appInfo = appInfo;

        // Let's pull the path and extension off of the application filename
        // so we can display just the application name to the user

        // We're guarenteed to have at least the config file, but not necessarily the 
        // application file... let's get our best name 
   
        String sName = (m_appInfo.sAppFile.Length > 0) ? m_appInfo.sAppFile : m_appInfo.sAppConfigFile;

        // Get the file description
        FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(sName);

        if (fvi.FileDescription!= null && fvi.FileDescription.Length > 0 && !fvi.FileDescription.Equals(" "))
            m_sDisplayName = fvi.FileDescription;
        else
        {
            String[] sWords = sName.Split(new char[] {'\\'});
            m_sDisplayName = sWords[sWords.Length-1];
        }
        
        // Can't set this up until we know what our display name is
        m_oResults=new CApplicationTaskPad(this);

        // Let's try and get the icon that explorer would use to display this file
        m_hIcon = (IntPtr)(-1);
        SHFILEINFO finfo = new SHFILEINFO();
        uint iRetVal = 0;

        // Grab an icon for this application
        iRetVal = SHGetFileInfo(sName,0, out finfo, 20, SHGFI.ICON|SHGFI.SMALLICON);
        
        // If this function returned a zero, then we know it was a failure...
        // We'll just grab a default icon
        if (iRetVal == 0)
        {
            m_hIcon = CResourceStore.GetHIcon("application_ico");  
            m_bBigPic = new Bitmap(Bitmap.FromHicon(m_hIcon), new Size(32, 32));
        }
        // We could get a valid icon from the shell
        else
        {
            m_hIcon = finfo.hIcon;
            // Obtain a cookie for this icon
            int iIconCookie = CResourceStore.StoreHIcon(m_hIcon);
            // Put this icon in MMC's image list
            CNodeManager.ConsoleImageListSetIcon(m_hIcon, iIconCookie);

            // We can also get the 'big' icon to use in the property page
            iRetVal = SHGetFileInfo(sName,0, out finfo, 20, SHGFI.ICON);
            m_bBigPic = new Bitmap(Bitmap.FromHicon(finfo.hIcon));
        }
       
    }// CApplication

    internal AppFiles MyAppInfo
    {
        get{return m_appInfo;}
    }// MyAppInfo

    protected override void CreatePropertyPages()
    {
        m_aPropSheetPage = new CPropPage[] { new CAppProps(m_appInfo, m_bBigPic)};
    }// CreatePropertyPages

    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {  
                // See if we're allowed to insert an item in the "top" section
        if (m_appInfo.sAppFile != null && (pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
        {
            CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            newitem.strName = CResourceStore.GetString("CApplication:FixApplicationOption");
            newitem.strStatusBarText = CResourceStore.GetString("CApplication:FixApplicationOptionDes");
            newitem.lCommandID = COMMANDS.FIX_APPLICATION;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

        }
     }// AddMenuItems


     internal override void MenuCommand(int iCommandID)
     {
        if (iCommandID == COMMANDS.FIX_APPLICATION)
        {
            uint hr = PolicyManager(CNodeManager.MMChWnd, m_appInfo.sAppFile, m_sDisplayName, null);
            if (hr != HRESULT.S_OK)
            {
                if (hr == 0x80131075) /* NAR_E_NO_MANAGED_APPS_FOUND */
                    MessageBox(CResourceStore.GetString("CApplication:NoAppData"),
                               CResourceStore.GetString("CApplication:NoAppDataTitle"),
                               MB.ICONEXCLAMATION);
                else if (hr == 0x80131087) /* NAR_E_UNEXPECTED */
                    MessageBox(CResourceStore.GetString("CApplication:FixFailed"),
                               CResourceStore.GetString("CApplication:FixFailedTitle"),
                               MB.ICONEXCLAMATION);
                // We'll assume there will be visual clues of the other
                // error conditions (like the user hitting cancel, doing a revert, etc)
            }
        }               
            
     }// MenuCommand


    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        // We want to browse this apps properties
        if ((int)arg == 0)
        {
            OpenMyPropertyPage();
        }
    
        // We want to browse the Assembly Dependencies
        else if ((int)arg == 1)
        {
            CNode node = FindChild("Assembly Dependencies");
            CNodeManager.SelectScopeItem(node.HScopeItem);
            node.MenuCommand(COMMANDS.SHOW_LISTVIEW);
        }
        // We want to Configure Assemblies
        else if ((int)arg == 2)
        {
            CNode node = FindChild("Configured Assemblies");
            CNodeManager.SelectScopeItem(node.HScopeItem);
        }
        // We want to go to remoting node
        else if ((int)arg == 3)
        {
            CNode node = FindChild("Remoting Services");
            CNodeManager.SelectScopeItem(node.HScopeItem);
            node.OpenMyPropertyPage();
        }
        else if ((int)arg == 4)
        {
            MenuCommand(COMMANDS.FIX_APPLICATION);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.FIX_APPLICATION);

        }
    }// TaskPadTaskNotify



    internal override void onSelect(IConsoleVerb icv)
    {
        icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, 1);
    }// Showing


    internal override int onDelete(Object o)
    {
        int nRes = MessageBox(CResourceStore.GetString("CApplication:VerifyRemoveApp"),
                              CResourceStore.GetString("CApplication:VerifyRemoveAppTitle"),
                              MB.ICONQUESTION|MB.YESNO);
        if (nRes == MB.IDYES)
        {
            // Grab our parent node and tell him to remove us
            CNodeManager.GetNodeByHScope(ParentHScopeItem).RemoveSpecificChild(Cookie);
            // Change the XML...
            if (CConfigStore.SetSetting("RemoveAppConfigFile", m_appInfo))
                return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// onDelete

    //-------------------------------------------------
    // AppConfigFile - Accessor
    //
    // Exposes this application's AppConfigFile structure
    //-------------------------------------------------
    internal String AppConfigFile
    {
       get
       {
           return m_appInfo.sAppConfigFile;
       }
    }// AppConfigFile

    internal CApplicationDepends AppDependsNode
    {   
        get{
            // If we have an application depends node, it should be the 
            // first child.
            if (CNodeManager.GetNode(Child[0]) is CApplicationDepends)
                return (CApplicationDepends)CNodeManager.GetNode(Child[0]);
            else
                return null;
           }
    }// AppDependsNode
    
    //-------------------------------------------------
    // CreateChildren
    //
    // An application node has a binding policy node and a
    // subscribed services node
    //-------------------------------------------------
    internal override void CreateChildren()
    {
        CNode node=null;
        int iCookie=-1;

        // We'll only give an application depends node if we have an app file
        if (m_appInfo.sAppFile.Length > 0)
        {
            // add a application depencies node
            node = new CApplicationDepends(m_appInfo.sAppFile);
            iCookie = CNodeManager.AddNode(ref node);
            AddChild(iCookie);
        }
        
        // Now add a Version Policy node
        node = new CVersionPolicy(m_appInfo.sAppConfigFile);
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);

        // Now add a Remoting node
        node = new CRemoting(m_appInfo.sAppConfigFile);
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);
    }// CreateChildren

    [DllImport("shell32.dll")]
    private static extern uint SHGetFileInfo(String pszPath, uint dwFileAttributes, out SHFILEINFO fi, uint cbFileInfo, uint uFlags);

    [DllImport("shfusion.dll", CharSet=CharSet.Unicode)]
    internal static extern uint PolicyManager(IntPtr hWndParent, String pwzFullyQualifiedAppPath, String pwzAppName, String dwFlags);

}// class CApplication
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cassemblydialog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections;
using System.Data;

internal class CAssemblyDialog : Form
{
    TextBox     m_txtVersion;
    TextBox     m_txtPubKeyToken;
    Button      m_btnSelect;
    Label       m_lblVersion;
    Button      m_btnCancel;
    Label       m_lblAssemName;
    Label       m_lblPubKeyToken;
    TextBox     m_txtAssemName;
    ListView    m_lv;

    private bool      m_fShowVersion;
	private AssemInfo m_aSelectedAssem;
	protected ArrayList m_ol = null;
   
    internal CAssemblyDialog()
    {
        m_fShowVersion = true;
        SetupControls();
    }// CAssemblyDialog

   
    internal CAssemblyDialog(bool fShowVersion)
    {
        m_fShowVersion = fShowVersion;
        SetupControls();
    }// CAssemblyDialog


    internal AssemInfo Assem
    {
        get
        {
            return m_aSelectedAssem;
        }
    }// Assem

    private void SetupControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CAssemblyDialog));
        this.m_txtVersion = new System.Windows.Forms.TextBox();
        this.m_lv = new ListView();
        this.m_txtPubKeyToken = new System.Windows.Forms.TextBox();
        this.m_btnSelect = new System.Windows.Forms.Button();
        this.m_lblVersion = new System.Windows.Forms.Label();
        this.m_btnCancel = new System.Windows.Forms.Button();
        this.m_lblAssemName = new System.Windows.Forms.Label();
        this.m_lblPubKeyToken = new System.Windows.Forms.Label();
        this.m_txtAssemName = new System.Windows.Forms.TextBox();
        this.m_txtVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_txtVersion.Location")));
        this.m_txtVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_txtVersion.Size")));
        this.m_txtVersion.TabIndex = ((int)(resources.GetObject("m_txtVersion.TabIndex")));
        this.m_txtVersion.Text = "";
        m_txtVersion.Name = "Version";
        this.m_lv.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_lv.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_lv.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_lv.Name = "Assemblies";
        this.m_txtPubKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPubKeyToken.Location")));
        this.m_txtPubKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPubKeyToken.Size")));
        this.m_txtPubKeyToken.TabIndex = ((int)(resources.GetObject("m_txtPubKeyToken.TabIndex")));
        this.m_txtPubKeyToken.Text = "";
        m_txtPubKeyToken.Name = "PublicKeyToken";
        this.m_btnSelect.Location = ((System.Drawing.Point)(resources.GetObject("m_btnSelect.Location")));
        this.m_btnSelect.Size = ((System.Drawing.Size)(resources.GetObject("m_btnSelect.Size")));
        this.m_btnSelect.TabIndex = ((int)(resources.GetObject("m_btnSelect.TabIndex")));
        this.m_btnSelect.Text = resources.GetString("m_btnSelect.Text");
        m_btnSelect.Name = "Select";
        this.m_lblVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_lblVersion.Location")));
        this.m_lblVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_lblVersion.Size")));
        this.m_lblVersion.TabIndex = ((int)(resources.GetObject("m_lblVersion.TabIndex")));
        this.m_lblVersion.Text = resources.GetString("m_lblVersion.Text");
        m_lblVersion.Name = "VersionLabel";
        this.m_btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("m_btnCancel.Location")));
        this.m_btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("m_btnCancel.Size")));
        this.m_btnCancel.TabIndex = ((int)(resources.GetObject("m_btnCancel.TabIndex")));
        this.m_btnCancel.Text = resources.GetString("m_btnCancel.Text");
        m_btnCancel.Name = "Cancel";
        this.m_lblAssemName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAssemName.Location")));
        this.m_lblAssemName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAssemName.Size")));
        this.m_lblAssemName.TabIndex = ((int)(resources.GetObject("m_lblAssemName.TabIndex")));
        this.m_lblAssemName.Text = resources.GetString("m_lblAssemName.Text");
        m_lblAssemName.Name= "AssemblyNameLabel";
        this.m_lblPubKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPubKeyToken.Location")));
        this.m_lblPubKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPubKeyToken.Size")));
        this.m_lblPubKeyToken.TabIndex = ((int)(resources.GetObject("m_lblPubKeyToken.TabIndex")));
        this.m_lblPubKeyToken.Text = resources.GetString("m_lblPubKeyToken.Text");
        m_lblPubKeyToken.Name = "PublicKeyTokenLabel";
        this.m_txtAssemName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtAssemName.Location")));
        this.m_txtAssemName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtAssemName.Size")));
        this.m_txtAssemName.TabIndex = ((int)(resources.GetObject("m_txtAssemName.TabIndex")));
        this.m_txtAssemName.Text = "";
        m_txtAssemName.Name = "AssemblyName";
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
        this.Icon = null;
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblVersion,
                        this.m_lblPubKeyToken,
                        this.m_lblAssemName,
                        this.m_txtVersion,
                        this.m_txtPubKeyToken,
                        this.m_txtAssemName,
                        this.m_btnCancel,
                        this.m_btnSelect,
                        this.m_lv});
        // Some further tweaking of the controls
        m_lv.MultiSelect = false;
        m_lv.View = View.Details;
        m_lv.FullRowSelect = true;

        m_lblVersion.Visible = m_fShowVersion;
        m_txtVersion.Visible = m_fShowVersion;
        
        // m_lv.HeaderStyle = ColumnHeaderStyle.None;
        ColumnHeader ch = new ColumnHeader();
        ch.Text = CResourceStore.GetString("Name");
        // The 17 is for the width of the scrollbar
        ch.Width = ((System.Drawing.Size)(resources.GetObject("m_dg.Size"))).Width-200-17;

        m_lv.Columns.Add(ch);
        ch = new ColumnHeader();
        ch.Text = CResourceStore.GetString("PublicKeyToken");
        ch.Width = 125;
        m_lv.Columns.Add(ch);
        if (m_fShowVersion)
        {
            ch = new ColumnHeader();
            ch.Text = CResourceStore.GetString("Version");
            ch.Width = 75;
            m_lv.Columns.Add(ch);
        }
        
        m_btnSelect.Click += new EventHandler(onOKClick);
        m_btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
        
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.MaximizeBox=false;
        this.MinimizeBox=false;
        this.CancelButton = m_btnCancel;


        m_lv.SelectedIndexChanged += new EventHandler(onAssemChange);
        m_lv.DoubleClick += new EventHandler(onOKClick);
        m_txtVersion.ReadOnly=true;
        m_txtPubKeyToken.ReadOnly=true;
        m_txtAssemName.ReadOnly=true;


    }// SetupControls

    protected void PutInAssemblies()
    {

        if (m_ol != null)
        {
            for(int i=0; i<m_ol.Count; i++)
            {
                ListViewItem lvi;
                if (m_fShowVersion)

                    lvi = new ListViewItem(new String[] {
                                                        ((AssemInfo)m_ol[i]).Name,
                                                        ((AssemInfo)m_ol[i]).PublicKeyToken,
                                                        ((AssemInfo)m_ol[i]).Version
                                                                });
                else

                    lvi = new ListViewItem(new String[] {
                                                        ((AssemInfo)m_ol[i]).Name,
                                                        ((AssemInfo)m_ol[i]).PublicKeyToken
                                                                });
                    
                m_lv.Items.Add(lvi);
            }
        }            
    }// PutInAssemblies


    void onAssemChange(Object o, EventArgs arg)
    {
    	if (m_lv.SelectedIndices.Count > 0)
		{

            m_txtAssemName.Text=((AssemInfo)m_ol[m_lv.SelectedIndices[0]]).Name;
            m_txtPubKeyToken.Text=((AssemInfo)m_ol[m_lv.SelectedIndices[0]]).PublicKeyToken;
            if (m_fShowVersion)
                m_txtVersion.Text=((AssemInfo)m_ol[m_lv.SelectedIndices[0]]).Version;
        }
    }// onAssemChange
    
    internal void onOKClick(Object o, EventArgs arg)
    {
    	if (m_lv.SelectedIndices.Count > 0)
		{
			m_aSelectedAssem = (AssemInfo)m_ol[m_lv.SelectedIndices[0]];
	        this.DialogResult = System.Windows.Forms.DialogResult.OK;
		}
    }// onOKClick

    internal void onCancelClick(Object o, EventArgs arg)
    {
        this.DialogResult = System.Windows.Forms.DialogResult.Cancel;
    }// onCancelClick
}// class CAssemblyDialog

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\capplicationtaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Security;

class CApplicationTaskPad : CTaskPad
{
    private AppFiles            m_AppFiles;
    private String              m_sDisplayName;

    internal CApplicationTaskPad(CApplication n) : base(n)
    {
        m_AppFiles = n.MyAppInfo;
        m_sDisplayName = n.DisplayName;
    }// CSinglePermSetTaskPad

     protected override String GetHTMLFilename()
    {
        return "SINGLEAPPLICATION_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String[] args = new String[4];
    
        args[0] = m_sDisplayName;
        
        if (m_AppFiles.sAppFile != null && m_AppFiles.sAppFile.Length > 0)
        {
            args[1] = m_AppFiles.sAppFile;
        }
        // Else, we're dealing with just a config file. We shouldn't give the option
        // to view the Assembly Dependencies
        else
        {
            args[1] = m_AppFiles.sAppConfigFile;
            args[2] = "<!--";
            args[3] = "-->";
        }
       
        return GetHTMLFile(args);    
    }// GetHTMLFile
}// class CApplicationTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cappprops.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CAppProps.cs
//
// This displays the property page for a Application node. It allows
// the user to configure various application-specific settings 
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Reflection;

internal class CAppProps : CPropPage
{
    // Controls on the page
    private PictureBox m_pb;
    private Label m_lblGC;
    private Label m_lblSearchPathHelp;
    private Label m_lblLastModified;
    private CheckBox m_chkSafeBinding;
    private TextBox m_txtLocation;
    private TextBox m_txtSearchPath;
    private RadioButton m_radNormal;
    private RadioButton m_radConcurrent;
    private Label m_lblSearchPath;
    private Label m_lblLocation;
    private TextBox m_txtLastModified;
    private Label m_lblVersion;
    private Label m_lblBindingModeHelp;
    private Label m_lblAppName;
    private TextBox m_txtVersion;
    private PictureBox m_pbLine;
 

    // Structure containing the location of the application and it's config file
    AppFiles            m_appFiles;
    Bitmap              m_bBigPic;


    //-------------------------------------------------
    // CAppProps - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CAppProps(AppFiles appFiles, Bitmap bBigPic)
    {
        m_appFiles = appFiles;
        m_sTitle = CResourceStore.GetString("CAppProps:PageTitle");
        m_bBigPic = bBigPic;
    }// CAppProps

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CAppProps));
        this.m_pb = new System.Windows.Forms.PictureBox();
        this.m_lblGC = new System.Windows.Forms.Label();
        this.m_lblSearchPathHelp = new System.Windows.Forms.Label();
        this.m_lblLastModified = new System.Windows.Forms.Label();
        this.m_chkSafeBinding = new System.Windows.Forms.CheckBox();
        this.m_txtLocation = new System.Windows.Forms.TextBox();
        this.m_txtSearchPath = new System.Windows.Forms.TextBox();
        this.m_radNormal = new System.Windows.Forms.RadioButton();
        this.m_radConcurrent = new System.Windows.Forms.RadioButton();
        this.m_lblSearchPath = new System.Windows.Forms.Label();
        this.m_lblLocation = new System.Windows.Forms.Label();
        this.m_txtLastModified = new System.Windows.Forms.TextBox();
        this.m_pbLine = new System.Windows.Forms.PictureBox();
        this.m_lblVersion = new System.Windows.Forms.Label();
        this.m_lblBindingModeHelp = new System.Windows.Forms.Label();
        this.m_lblAppName = new System.Windows.Forms.Label();
        this.m_txtVersion = new System.Windows.Forms.TextBox();
        this.m_pb.Location = ((System.Drawing.Point)(resources.GetObject("m_pb.Location")));
        this.m_pb.Size = ((System.Drawing.Size)(resources.GetObject("m_pb.Size")));
        this.m_pb.TabIndex = ((int)(resources.GetObject("m_pb.TabIndex")));
        this.m_pb.TabStop = false;
        m_pb.Name = "AppIcon";
        this.m_lblGC.Location = ((System.Drawing.Point)(resources.GetObject("m_lblGC.Location")));
        this.m_lblGC.Size = ((System.Drawing.Size)(resources.GetObject("m_lblGC.Size")));
        this.m_lblGC.TabIndex = ((int)(resources.GetObject("m_lblGC.TabIndex")));
        this.m_lblGC.TabStop = false;
        this.m_lblGC.Text = resources.GetString("m_lblGC.Text");
        m_lblGC.Name = "GCLabel";
        this.m_lblSearchPathHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSearchPathHelp.Location")));
        this.m_lblSearchPathHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSearchPathHelp.Size")));
        this.m_lblSearchPathHelp.TabIndex = ((int)(resources.GetObject("m_lblSearchPathHelp.TabIndex")));
        this.m_lblSearchPathHelp.Text = resources.GetString("m_lblSearchPathHelp.Text");
        m_lblSearchPathHelp.Name = "SearchPathHelp";
        this.m_lblLastModified.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLastModified.Location")));
        this.m_lblLastModified.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLastModified.Size")));
        this.m_lblLastModified.TabIndex = ((int)(resources.GetObject("m_lblLastModified.TabIndex")));
        this.m_lblLastModified.Text = resources.GetString("m_lblLastModified.Text");
        m_lblLastModified.Name = "LastModifiedLabel";
        this.m_chkSafeBinding.Location = ((System.Drawing.Point)(resources.GetObject("m_chkSafeBinding.Location")));
        this.m_chkSafeBinding.Size = ((System.Drawing.Size)(resources.GetObject("m_chkSafeBinding.Size")));
        this.m_chkSafeBinding.TabIndex = ((int)(resources.GetObject("m_chkSafeBinding.TabIndex")));
        this.m_chkSafeBinding.Text = resources.GetString("m_chkSafeBinding.Text");
        m_chkSafeBinding.Name = "SafeBinding";
        this.m_txtLocation.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtLocation.Location = ((System.Drawing.Point)(resources.GetObject("m_txtLocation.Location")));
        this.m_txtLocation.ReadOnly = true;
        this.m_txtLocation.Size = ((System.Drawing.Size)(resources.GetObject("m_txtLocation.Size")));
        this.m_txtLocation.TabStop = false;
        m_txtLocation.Name = "Location";
        this.m_txtSearchPath.Location = ((System.Drawing.Point)(resources.GetObject("m_txtSearchPath.Location")));
        this.m_txtSearchPath.Size = ((System.Drawing.Size)(resources.GetObject("m_txtSearchPath.Size")));
        this.m_txtSearchPath.TabIndex = ((int)(resources.GetObject("m_txtSearchPath.TabIndex")));
        m_txtSearchPath.Name = "SearchPath";
        this.m_radNormal.Location = ((System.Drawing.Point)(resources.GetObject("m_radNormal.Location")));
        this.m_radNormal.Size = ((System.Drawing.Size)(resources.GetObject("m_radNormal.Size")));
        this.m_radNormal.TabIndex = ((int)(resources.GetObject("m_radNormal.TabIndex")));
        this.m_radNormal.Text = resources.GetString("m_radNormal.Text");
        m_radNormal.Name = "NormalGC";
        this.m_radConcurrent.Location = ((System.Drawing.Point)(resources.GetObject("m_radConcurrent.Location")));
        this.m_radConcurrent.Size = ((System.Drawing.Size)(resources.GetObject("m_radConcurrent.Size")));
        this.m_radConcurrent.TabIndex = ((int)(resources.GetObject("m_radConcurrent.TabIndex")));
        this.m_radConcurrent.Text = resources.GetString("m_radConcurrent.Text");
        m_radConcurrent.Name = "ConcurrentGC";
        this.m_lblSearchPath.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSearchPath.Location")));
        this.m_lblSearchPath.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSearchPath.Size")));
        this.m_lblSearchPath.TabIndex = ((int)(resources.GetObject("m_lblSearchPath.TabIndex")));
        this.m_lblSearchPath.Text = resources.GetString("m_lblSearchPath.Text");
        m_lblSearchPath.Name = "SearchPathLabel";
        this.m_lblLocation.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLocation.Location")));
        this.m_lblLocation.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLocation.Size")));
        this.m_lblLocation.TabIndex = ((int)(resources.GetObject("m_lblLocation.TabIndex")));
        this.m_lblLocation.Text = resources.GetString("m_lblLocation.Text");
        m_lblLocation.Name = "LocationLabel";
        this.m_txtLastModified.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtLastModified.Location = ((System.Drawing.Point)(resources.GetObject("m_txtLastModified.Location")));
        this.m_txtLastModified.ReadOnly = true;
        this.m_txtLastModified.Size = ((System.Drawing.Size)(resources.GetObject("m_txtLastModified.Size")));
        this.m_txtLastModified.TabStop = false;
        m_txtLastModified.Name = "LastModified";
        this.m_pbLine.Location = ((System.Drawing.Point)(resources.GetObject("m_pbLine.Location")));
        this.m_pbLine.Size = ((System.Drawing.Size)(resources.GetObject("m_pbLine.Size")));
        this.m_pbLine.TabIndex = ((int)(resources.GetObject("m_pbLine.TabIndex")));
        this.m_pbLine.TabStop = false;
        m_pbLine.Name = "Line";
        this.m_lblVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_lblVersion.Location")));
        this.m_lblVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_lblVersion.Size")));
        this.m_lblVersion.TabIndex = ((int)(resources.GetObject("m_lblVersion.TabIndex")));
        this.m_lblVersion.Text = resources.GetString("m_lblVersion.Text");
        m_lblVersion.Name = "VersionLabel";
        this.m_lblBindingModeHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblBindingModeHelp.Location")));
        this.m_lblBindingModeHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblBindingModeHelp.Size")));
        this.m_lblBindingModeHelp.TabIndex = ((int)(resources.GetObject("m_lblBindingModeHelp.TabIndex")));
        this.m_lblBindingModeHelp.TabStop = false;
        this.m_lblBindingModeHelp.Text = resources.GetString("m_lblBindingModeHelp.Text");
        m_lblBindingModeHelp.Name = "BindingModeHelp";
        this.m_lblAppName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAppName.Location")));
        this.m_lblAppName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAppName.Size")));
        this.m_lblAppName.TabIndex = ((int)(resources.GetObject("m_lblAppName.TabIndex")));
        m_lblAppName.Name = "AppName";
        this.m_txtVersion.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_txtVersion.Location")));
        this.m_txtVersion.ReadOnly = true;
        this.m_txtVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_txtVersion.Size")));
        this.m_txtVersion.TabStop = false;
        m_txtVersion.Name = "Version";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_pb,
                        this.m_pbLine,
                        this.m_lblAppName,
                        this.m_lblLocation,
                        this.m_txtLocation,
                        this.m_lblVersion,
                        this.m_txtVersion,
                        this.m_lblLastModified,
                        this.m_txtLastModified,
                        this.m_lblGC,
                        m_radConcurrent,
                        m_radNormal,
                        m_chkSafeBinding,
                        this.m_lblBindingModeHelp,
                        this.m_lblSearchPath,
                        this.m_txtSearchPath,
                        m_lblSearchPathHelp,
                        });

        // Draw a line that can be used to seperate stuff
        Bitmap bmLine = new Bitmap(m_pbLine.Width, 2);
        Graphics g = Graphics.FromImage(bmLine);
        g.DrawLine(Pens.Black, new Point(0, 0), new Point(m_pbLine.Width-1, 0));
        g.DrawLine(Pens.White, new Point(0, 1), new Point(m_pbLine.Width-1, 1));

        // Assign the pictures
        m_pb.Image = m_bBigPic;
        m_pbLine.Image = bmLine;

        // Fill in the data
        PutValuesinPage();

        // Hook up the event handlers
        m_radNormal.CheckedChanged+= new EventHandler(onChange);
        m_radConcurrent.CheckedChanged+= new EventHandler(onChange);
        m_chkSafeBinding.CheckedChanged+= new EventHandler(onChange);
        m_txtSearchPath.TextChanged += new EventHandler(onChange);

        m_txtLocation.Select(0,0);
        return 1;
    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // PutValuesinPage
    //
    // This function put data onto the property page
    //-------------------------------------------------
    private void PutValuesinPage()
    {
        // We're guaranteed that we have a config file, but if we have the Application file,
        // let's use that for our location.

        // Get info that we'll need from the node
        CNode node = CNodeManager.GetNode(m_iCookie);

        m_lblAppName.Text = node.DisplayName;        

        m_txtLocation.Text = (m_appFiles.sAppFile.Length == 0)?m_appFiles.sAppConfigFile:m_appFiles.sAppFile;


/*      The following code will be used when we look at different runtime versions

        // Let's grab the different versions of the runtime we know about
        // on this machine
        String[] versions = Directory.GetDirectories((String)CConfigStore.GetSetting("InstallRoot"));

        int iLen = versions.Length;
        for (int i=0; i<iLen; i++)
        {
            // Strip off everything but the last directory name
            String[] dirs = versions[i].Split(new char[] {'\\'});
            String sVersion = dirs[dirs.Length-1];
            m_cbRuntimeVersion.Items.Add(sVersion);
        }
        // Add a 'none' for good measure
        m_cbRuntimeVersion.Items.Add(CResourceStore.GetString("None"));
*/
        // Put in the 'last modified' data of the file
        try
        {
            DateTime dt = File.GetLastWriteTime(m_txtLocation.Text);
            m_txtLastModified.Text = dt.ToString();
        }
        // In the event the file doesn't exist (or we can't do this for some reason)
        catch(Exception)
        {   
            // If the file doesn't exist, what should we do?
        }

        // Get the version of this assembly
        m_txtVersion.Text = CResourceStore.GetString("<unknown>");

        if (m_appFiles.sAppFile.Length > 0)
        {
            AssemblyName an = AssemblyName.GetAssemblyName(m_appFiles.sAppFile);
            if(an != null)
            {
               m_txtVersion.Text = an.Version.ToString();
            }
        }
                   
        // Get the garbage collection settings
        try
        {
            String setting = (String)CConfigStore.GetSetting("GarbageCollector," + m_appFiles.sAppConfigFile);
            if (setting.Equals("true"))
                m_radConcurrent.Checked=true;
            else
                m_radNormal.Checked=true;

            // Get the binding settings
            setting = (String)CConfigStore.GetSetting("BindingMode," + m_appFiles.sAppConfigFile);
            m_chkSafeBinding.Checked=setting.Equals("yes");
        
            // Get the search path
            m_txtSearchPath.Text = (String)CConfigStore.GetSetting("SearchPath," + m_appFiles.sAppConfigFile);
        }
        catch(Exception)
        {
            // Most likely, an exception was thrown because we came across some
            // bad XML. We've already show a error dialog to the user. Let's
            // just put in some good dummy info
            m_radConcurrent.Checked=true;
        }

/*
        // Get the required Version of the runtime.
        m_cbRuntimeVersion.Text = (String)CConfigStore.GetSetting("RequiredRuntimeVersion," + m_appFiles.sAppConfigFile);
*/
    }// PutValuesinPage

    //-------------------------------------------------
    // ApplyData
    //
    // This function gets called when the user clicks the
    // OK or Apply button. We should take all our information
    // from the wizard and "Make it so".
    //-------------------------------------------------
    internal override bool ApplyData()
    {
        // Set the garbage collector setting
        String sGCSetting;
        sGCSetting = (m_radNormal.Checked == true)?"false":"true";
        
        if (!CConfigStore.SetSetting("GarbageCollector," + m_appFiles.sAppConfigFile, sGCSetting))
            return false;
            
        // Set the binding mode
        String sBindingSetting;
        sBindingSetting = (m_chkSafeBinding.Checked == true)?"yes":"no";
            
        if (!CConfigStore.SetSetting("BindingMode," + m_appFiles.sAppConfigFile, sBindingSetting))
            return false;

        // Set the Search Path
        if (!CConfigStore.SetSetting("SearchPath," + m_appFiles.sAppConfigFile, m_txtSearchPath.Text))
            return false;

        /*
        // Set the required version of the runtime
        CConfigStore.SetSetting("RequiredRuntimeVersion," + m_appFiles.sAppConfigFile, m_cbRuntimeVersion.Text);
*/
        return true;
    }// ApplyData

    //-------------------------------------------------
    // onChange
    //
    // This event is fired when any values on the page
    // are changed. This will cause us to activate the 
    // apply button
    //-------------------------------------------------
    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
}// class CAppProps

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cassemgenprops.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CAssemGenProps.cs
//
// This displays a property page for an assembly displayed in 
// the listview of the Shared Assemblies node. It shows basic
// information about an assembly, including name, last modified time,
// culture, version, internal key, and codebase
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;

internal class CAssemGenProps : CPropPage
{
    // Controls on the page
	TextBox m_txtLastModifed;
    TextBox m_txtCulture;
    Label m_lblPublicKeyToken;
    TextBox m_txtVersion;
    TextBox m_txtCacheType;
    TextBox m_txtPublicKeyToken;
    Label m_lblVersion;
    Label m_lblAssemName;
    Label m_lblLastMod;
    Label m_lblCacheType;
    Label m_lblCodebase;
    TextBox m_txtCodebase;
    Label m_lblCulture;
    TextBox m_txtAssemName;

    private AssemInfo   m_ai;

    //-------------------------------------------------
    // CAssemGenProps - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CAssemGenProps(AssemInfo ai)
    {
        m_ai=ai;
        m_sTitle = CResourceStore.GetString("CAssemGenProps:PageTitle");
    }// CAssemGenProps

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CAssemGenProps));
        this.m_txtLastModifed = new System.Windows.Forms.TextBox();
        this.m_txtCulture = new System.Windows.Forms.TextBox();
        this.m_lblPublicKeyToken = new System.Windows.Forms.Label();
        this.m_txtVersion = new System.Windows.Forms.TextBox();
        this.m_txtCacheType = new System.Windows.Forms.TextBox();
        this.m_txtPublicKeyToken = new System.Windows.Forms.TextBox();
        this.m_lblVersion = new System.Windows.Forms.Label();
        this.m_lblAssemName = new System.Windows.Forms.Label();
        this.m_lblLastMod = new System.Windows.Forms.Label();
        this.m_lblCacheType = new System.Windows.Forms.Label();
        this.m_lblCodebase = new System.Windows.Forms.Label();
        this.m_txtCodebase = new System.Windows.Forms.TextBox();
        this.m_lblCulture = new System.Windows.Forms.Label();
        this.m_txtAssemName = new System.Windows.Forms.TextBox();
        this.m_txtLastModifed.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtLastModifed.Location = ((System.Drawing.Point)(resources.GetObject("m_txtLastModifed.Location")));
        this.m_txtLastModifed.ReadOnly = true;
        this.m_txtLastModifed.Size = ((System.Drawing.Size)(resources.GetObject("m_txtLastModifed.Size")));
        this.m_txtLastModifed.TabStop = false;
        m_txtLastModifed.Name = "LastModified";
        this.m_txtCulture.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtCulture.Location = ((System.Drawing.Point)(resources.GetObject("m_txtCulture.Location")));
        this.m_txtCulture.ReadOnly = true;
        this.m_txtCulture.Size = ((System.Drawing.Size)(resources.GetObject("m_txtCulture.Size")));
        this.m_txtCulture.TabStop = false;
        m_txtCulture.Name = "Culture";
        this.m_lblPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublicKeyToken.Location")));
        this.m_lblPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublicKeyToken.Size")));
        this.m_lblPublicKeyToken.TabIndex = ((int)(resources.GetObject("m_lblPublicKeyToken.TabIndex")));
        this.m_lblPublicKeyToken.Text = resources.GetString("m_lblPublicKeyToken.Text");
        m_lblPublicKeyToken.Name = "PublicKeyTokenLabel";
        this.m_txtVersion.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_txtVersion.Location")));
        this.m_txtVersion.ReadOnly = true;
        this.m_txtVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_txtVersion.Size")));
        this.m_txtVersion.TabStop = false;
        m_txtVersion.Name = "Version";
        this.m_txtCacheType.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtCacheType.Location = ((System.Drawing.Point)(resources.GetObject("m_txtCacheType.Location")));
        this.m_txtCacheType.ReadOnly = true;
        this.m_txtCacheType.Size = ((System.Drawing.Size)(resources.GetObject("m_txtCacheType.Size")));
        this.m_txtCacheType.TabStop = false;
        m_txtCacheType.Name = "CacheType";
        this.m_txtPublicKeyToken.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPublicKeyToken.Location")));
        this.m_txtPublicKeyToken.ReadOnly = true;
        this.m_txtPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPublicKeyToken.Size")));
        this.m_txtPublicKeyToken.TabStop = false;
        m_txtPublicKeyToken.Name = "PublicKeyToken";
        this.m_lblVersion.Location = ((System.Drawing.Point)(resources.GetObject("m_lblVersion.Location")));
        this.m_lblVersion.Size = ((System.Drawing.Size)(resources.GetObject("m_lblVersion.Size")));
        this.m_lblVersion.TabIndex = ((int)(resources.GetObject("m_lblVersion.TabIndex")));
        this.m_lblVersion.Text = resources.GetString("m_lblVersion.Text");
        m_lblVersion.Name = "VersionLabel";
        this.m_lblAssemName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAssemName.Location")));
        this.m_lblAssemName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAssemName.Size")));
        this.m_lblAssemName.TabIndex = ((int)(resources.GetObject("m_lblAssemName.TabIndex")));
        this.m_lblAssemName.Text = resources.GetString("m_lblAssemName.Text");
        m_lblAssemName.Name = "AssemblyNameLabel";
        this.m_lblLastMod.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLastMod.Location")));
        this.m_lblLastMod.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLastMod.Size")));
        this.m_lblLastMod.TabIndex = ((int)(resources.GetObject("m_lblLastMod.TabIndex")));
        this.m_lblLastMod.Text = resources.GetString("m_lblLastMod.Text");
        m_lblLastMod.Name = "LastModifiedLabel";
        this.m_lblCacheType.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCacheType.Location")));
        this.m_lblCacheType.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCacheType.Size")));
        this.m_lblCacheType.TabIndex = ((int)(resources.GetObject("m_lblCacheType.TabIndex")));
        this.m_lblCacheType.Text = resources.GetString("m_lblCacheType.Text");
        m_lblCacheType.Name = "CacheTypeLabel";
        this.m_lblCodebase.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCodebase.Location")));
        this.m_lblCodebase.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCodebase.Size")));
        this.m_lblCodebase.TabIndex = ((int)(resources.GetObject("m_lblCodebase.TabIndex")));
        this.m_lblCodebase.Text = resources.GetString("m_lblCodebase.Text");
        m_lblCodebase.Name = "CodebaseLabel";
        this.m_txtCodebase.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtCodebase.Location = ((System.Drawing.Point)(resources.GetObject("m_txtCodebase.Location")));
        this.m_txtCodebase.ReadOnly = true;
        this.m_txtCodebase.Size = ((System.Drawing.Size)(resources.GetObject("m_txtCodebase.Size")));
        this.m_txtCodebase.TabStop = false;
        m_txtCodebase.Name = "Codebase";
        this.m_lblCulture.Location = ((System.Drawing.Point)(resources.GetObject("m_lblCulture.Location")));
        this.m_lblCulture.Size = ((System.Drawing.Size)(resources.GetObject("m_lblCulture.Size")));
        this.m_lblCulture.TabIndex = ((int)(resources.GetObject("m_lblCulture.TabIndex")));
        this.m_lblCulture.Text = resources.GetString("m_lblCulture.Text");
        m_lblCulture.Name = "CultureLabel";
        this.m_txtAssemName.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtAssemName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtAssemName.Location")));
        this.m_txtAssemName.ReadOnly = true;
        this.m_txtAssemName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtAssemName.Size")));
        this.m_txtAssemName.TabStop = false;
        m_txtAssemName.Name = "AssemblyName";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_txtCacheType,
                        this.m_txtCodebase,
                        this.m_txtPublicKeyToken,
                        this.m_txtVersion,
                        this.m_txtCulture,
                        this.m_txtLastModifed,
                        this.m_lblCacheType,
                        this.m_lblCodebase,
                        this.m_lblPublicKeyToken,
                        this.m_lblVersion,
                        this.m_lblCulture,
                        this.m_lblLastMod,
                        this.m_txtAssemName,
                        this.m_lblAssemName});

        // Fill in the data
        PutValuesinPage();

        m_txtCodebase.Select(0,0);
        m_txtPublicKeyToken.Select(0,0);
        m_txtVersion.Select(0,0);
        m_txtCulture.Select(0,0);
        m_txtLastModifed.Select(0,0);
        m_txtAssemName.Select(0,0);

		return 1;
    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // PutValuesinPage
    //
    // This function put data onto the property page
    //-------------------------------------------------
    private void PutValuesinPage()
    {
        // Fill this data
        m_txtAssemName.Text = m_ai.Name;
        m_txtLastModifed.Text = m_ai.Modified;
        m_txtCulture.Text = m_ai.Locale;
        m_txtVersion.Text = m_ai.Version;
        m_txtPublicKeyToken.Text = m_ai.PublicKeyToken;
        m_txtCodebase.Text = m_ai.Codebase;
        m_txtCacheType.Text = Fusion.GetCacheTypeString(m_ai.nCacheType);
    }// PutValuesinPage
}// class CAssemGenProps

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cassembindpolicyprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CAssemBindPolicyProp.cs
//
// This file defines a property page for a binding policy. This
// property page is displayed when the user selects properties
// on an assembly under the "Configured Assemblies" node.
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections.Specialized;
using System.ComponentModel;


internal class CAssemBindPolicyProp : CPropPage
{
    // Controls on the page
    
    private Button m_btnDeleteEntry;
    private MyDataGrid m_dg;
    private Label m_lblExamples;
    private Label m_lblBindingHelp;
    private Label m_lblExample1;
    private Label m_lblExample3;
    private Label m_lblExample2;
    private DataTable   m_dt;
    private DataSet     m_ds;

    // The current Binding Policy we have for this assembly
    private BindingRedirInfo    m_bri;
    // The file we're going to save our configuration to
    private String              m_sConfigFile;

    //-------------------------------------------------
    // CAssemBindPolicyProp - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CAssemBindPolicyProp(BindingRedirInfo bri)
    {
        m_bri=bri;
        m_sConfigFile=null;
        m_sTitle = CResourceStore.GetString("CAssemBindPolicyProp:PageTitle");
    }// CAssemBindPolicyProp

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CAssemBindPolicyProp));
        this.m_btnDeleteEntry = new System.Windows.Forms.Button();
        this.m_dg = new MyDataGrid();
        this.m_lblExamples = new System.Windows.Forms.Label();
        this.m_lblBindingHelp = new System.Windows.Forms.Label();
        this.m_lblExample1 = new System.Windows.Forms.Label();
        this.m_lblExample3 = new System.Windows.Forms.Label();
        this.m_lblExample2 = new System.Windows.Forms.Label();
        this.m_btnDeleteEntry.Location = ((System.Drawing.Point)(resources.GetObject("m_btnDeleteEntry.Location")));
        this.m_btnDeleteEntry.Size = ((System.Drawing.Size)(resources.GetObject("m_btnDeleteEntry.Size")));
        this.m_btnDeleteEntry.TabIndex = ((int)(resources.GetObject("m_btnDeleteEntry.TabIndex")));
        this.m_btnDeleteEntry.Text = resources.GetString("m_btnDeleteEntry.Text");
        m_btnDeleteEntry.Name = "Delete";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        this.m_lblExamples.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExamples.Location")));
        this.m_lblExamples.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExamples.Size")));
        this.m_lblExamples.TabIndex = ((int)(resources.GetObject("m_lblExamples.TabIndex")));
        this.m_lblExamples.Text = resources.GetString("m_lblExamples.Text");
        m_lblExamples.Name = "Examples";
        this.m_lblBindingHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblBindingHelp.Location")));
        this.m_lblBindingHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblBindingHelp.Size")));
        this.m_lblBindingHelp.TabIndex = ((int)(resources.GetObject("m_lblBindingHelp.TabIndex")));
        this.m_lblBindingHelp.Text = resources.GetString("m_lblBindingHelp.Text");
        m_lblBindingHelp.Name = "BindingHelp";
        this.m_lblExample1.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample1.Location")));
        this.m_lblExample1.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample1.Size")));
        this.m_lblExample1.TabIndex = ((int)(resources.GetObject("m_lblExample1.TabIndex")));
        this.m_lblExample1.Text = resources.GetString("m_lblExample1.Text");
        m_lblExample1.Name = "Example1";
        this.m_lblExample3.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample3.Location")));
        this.m_lblExample3.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample3.Size")));
        this.m_lblExample3.TabIndex = ((int)(resources.GetObject("m_lblExample3.TabIndex")));
        this.m_lblExample3.Text = resources.GetString("m_lblExample3.Text");
        m_lblExample3.Name = "Example3";
        this.m_lblExample2.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample2.Location")));
        this.m_lblExample2.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample2.Size")));
        this.m_lblExample2.TabIndex = ((int)(resources.GetObject("m_lblExample2.TabIndex")));
        this.m_lblExample2.Text = resources.GetString("m_lblExample2.Text");
        m_lblExample2.Name = "Example2";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblExample3,
                        this.m_lblExample2,
                        this.m_lblExample1,
                        this.m_dg,
                        this.m_btnDeleteEntry,
                        this.m_lblExamples,
                        this.m_lblBindingHelp});
        
        // ----------------- Let's build our data table --------------

        // We'll create these variables just so we can use their type...
        // we don't need to worry about their actual values.

        m_dt = new DataTable("Stuff");

        // Create the "Requested Version" Column
        DataColumn dcReqVersion = new DataColumn();
        dcReqVersion.ColumnName = "Requested Version";
        dcReqVersion.DataType = typeof(String);
        m_dt.Columns.Add(dcReqVersion);

        // Create the "New Version" Column
        DataColumn dcNewVersion = new DataColumn();
        dcNewVersion.ColumnName = "New Version";
        dcNewVersion.DataType = typeof(String);
        m_dt.Columns.Add(dcNewVersion);


        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcReqVer = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcRedirVer = new DataGridTextBoxColumn();
         
        m_dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;
        dgts.ReadOnly=false;
        // Set up the column info for the Requested Version column
        dgtbcReqVer.MappingName = "Requested Version";
        dgtbcReqVer.HeaderText = CResourceStore.GetString("CAssemBindPolicyProp:RVColumn");
        dgtbcReqVer.Width = ScaleWidth(CResourceStore.GetInt("CAssemBindPolicyProp:RVColumnWidth"));
        dgtbcReqVer.ReadOnly = false;
        dgtbcReqVer.NullText = "";
        // Allows us to filter what is typed into the box
         dgtbcReqVer.TextBox.KeyPress +=new KeyPressEventHandler(onKeyPress);
        dgtbcReqVer.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcReqVer);

        // Set up the column info for the New Version column
        dgtbcRedirVer.MappingName = "New Version";
        dgtbcRedirVer.HeaderText = CResourceStore.GetString("CAssemBindPolicyProp:NVColumn");
        dgtbcRedirVer.Width = ScaleWidth(CResourceStore.GetInt("CAssemBindPolicyProp:NVColumnWidth"));
        dgtbcRedirVer.NullText = "";
        // Allows us to filter what is typed into the box
        dgtbcRedirVer.TextBox.KeyPress +=new KeyPressEventHandler(onKeyPress);
        dgtbcRedirVer.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcRedirVer);

        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);
        m_dg.DataSource = m_dt;
        m_dg.BackgroundColor = Color.White;

        //--------------- End Building Data Table ----------------------------

        // Tweak some of the UI settings
        m_dg.ReadOnly=false;
        m_dg.CaptionVisible=false;

        // Fill in the data
        PutValuesinPage();

        // Set up any callbacks
        m_dg.TheVertScrollBar.VisibleChanged += new EventHandler(onVisibleChange);
        m_btnDeleteEntry.Click += new EventHandler(onDeleteEntireRow);
        m_dg.CurrentCellChanged += new EventHandler(onCellChange);

        onCellChange(null, null);
        // See if we need to adjust the width of the headers
        onVisibleChange(null, null);

        return 1;
    }// InsertPropSheetPageControls

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange

    void onKeyPress(Object o, KeyPressEventArgs e)
    {

        // We only care about a few characters that the user enters... specifically
        // digits, periods, and asteriks. If the user entered that, inform the text
        // box control that we did not handle the event, and so the text box should
        // take care of it. If the user enters a character we're not interested in,
        // like letters and all other punctuation, tell the textbox control that
        // we handled it, so the textbox control will ignore the input.

        // Swallow up letters... we don't want the user to be able to type them
        if (Char.IsLetter(e.KeyChar))
            e.Handled=true;

        // Swallow up punctionation
        if (Char.IsPunctuation(e.KeyChar) && e.KeyChar != '.' && e.KeyChar != '-')
            e.Handled=true;

        // If the character is a '-' and we're in the 'directed' version column
        // swallow that as well
        if (m_dg.CurrentCell.ColumnNumber == 1 && e.KeyChar == '-')
            e.Handled=true;
    }// onKeyPress

    void onDeleteEntireRow(Object o, EventArgs e)
    {
        if (m_dg.CurrentRowIndex != -1)
        {
            if (m_dg.CurrentRowIndex >= m_dt.Rows.Count)
            {
                // Try moving to a different cell to 'submit' this data
                int nOldRow = m_dg.CurrentRowIndex;
                m_dg.CurrentCell = new DataGridCell(0, 0);
                // And now move back to the original row                
                m_dg.CurrentCell = new DataGridCell(nOldRow, 0);
            }
            // They're trying to delete a non-existant row
            if (m_dg.CurrentRowIndex >= m_dt.Rows.Count)
                return;
                
            int nRet = MessageBox(CResourceStore.GetString("CAssemBindPolicyProp:VerifyDeleteEntry"), 
                                  CResourceStore.GetString("CAssemBindPolicyProp:VerifyDeleteEntryTitle"),
                                  MB.ICONQUESTION|MB.YESNO);

            if (nRet == MB.IDYES)
            {
                int nRowToDelete = m_dg.CurrentRowIndex;
                int nRowToMoveTo = 0;
        
                if (nRowToDelete == 0)
                    nRowToMoveTo=1;
            
                m_dg.CurrentCell = new DataGridCell(nRowToMoveTo, 0);

        
                m_dt.Rows.Remove(m_dt.Rows[nRowToDelete]);

                // See if we need to add more rows again....
        
                while(m_dt.Rows.Count < 1)
                {
                    DataRow newRow;
                    newRow = m_dt.NewRow();
                    newRow["Requested Version"]="";
                    newRow["New Version"]="";
                    m_dt.Rows.Add(newRow);
                }
                if (nRowToDelete >= m_dt.Rows.Count)
                    nRowToMoveTo = nRowToDelete-1;
                else
                    nRowToMoveTo = nRowToDelete;

                // End up with the cursor on the point right after the delete item    
                m_dg.CurrentCell = new DataGridCell(nRowToMoveTo,0);
                ActivateApply();
            }
        }
    }// onDeleteEntireRow


    private void PutValuesinPage()
    {
        // Get info that we'll need from the node
        CNode node = CNodeManager.GetNode(m_iCookie);
        // This should be ok now, but if we need this functionality
        // off of different nodes.....
        CVersionPolicy vp = (CVersionPolicy)node;


        String sGetSettingString = "BindingPolicyFor" + m_bri.Name + "," + m_bri.PublicKeyToken;
        // If we are getting this from an App config file, let's add that info
        m_sConfigFile = vp.ConfigFile;
        
        if (m_sConfigFile != null)
            sGetSettingString += "," + m_sConfigFile;
        
        BindingPolicy bp = (BindingPolicy)CConfigStore.GetSetting(sGetSettingString);

        int iLen = bp.scBaseVersion.Count;

        for(int i=0; i<iLen;i++)
        {
            DataRow newRow;
            newRow = m_dt.NewRow();
            newRow["Requested Version"]=bp.scBaseVersion[i];
            newRow["New Version"]=bp.scRedirectVersion[i];
            m_dt.Rows.Add(newRow);
        }

        // We want to have at least 1 row
        while(m_dt.Rows.Count < 1)
        {
            DataRow newRow;
            newRow = m_dt.NewRow();
            newRow["Requested Version"]="";
            newRow["New Version"]="";
            m_dt.Rows.Add(newRow);
        }
        m_dg.CurrentCell = new DataGridCell(iLen,0);


    }// PutValuesinPage

    internal override bool ValidateData()
    {
        // Let's jump to a new cell, to make sure the current cell we
        // were editing has it's changes 'saved'
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);

        int nRow=0;

        while(nRow <= m_dt.Rows.Count)
        {
            if (isValidColumn(nRow, 0) || isValidColumn(nRow, 1))
            {
                // Make sure both of these entries are valid versions
                for(int i=0; i< 2; i++)
                {
                    try
                    {   
                        // Catch the error that they didn't enter anything
                        if (!isValidColumn(nRow, i))
                        {
                            MessageBox(CResourceStore.GetString("CAssemBindPolicyProp:BothVersionNumbersRequired"),
                                       CResourceStore.GetString("CAssemBindPolicyProp:BothVersionNumbersRequiredTitle"),
                                       MB.ICONEXCLAMATION);
                                           
                            m_dg.CurrentCell = new DataGridCell(nRow,i);
                            return false;
                        }

                        // See if the user put a - in there.
                        if (((String)m_dg[nRow, i]).IndexOf('-') == -1)
                            new Version((String)m_dg[nRow, i]);

                        else
                        {
                            String[] sVersions = ((String)m_dg[nRow, i]).Split(new char[] {'-'});
                            if (sVersions.Length > 2)
                            {
                                MessageBox(CResourceStore.GetString("CAssemBindPolicyProp:MultipleHyphens"),
                                           CResourceStore.GetString("CAssemBindPolicyProp:MultipleHyphensTitle"),
                                           MB.ICONEXCLAMATION);
                                m_dg.CurrentCell = new DataGridCell(nRow,i);
                                return false;
                            }
                            new Version(sVersions[0]);
                            new Version(sVersions[1]);
                        }
                    }
                    catch(Exception)
                    {
                        // Catch the error that is was an invalid version
                        MessageBox(String.Format(CResourceStore.GetString("isanInvalidVersion"),(String)m_dg[nRow, i]),
                                   CResourceStore.GetString("isanInvalidVersionTitle"),
                                   MB.ICONEXCLAMATION);
                        m_dg.CurrentCell = new DataGridCell(nRow,i);

                        return false;                                       
                    }
                }// for each entry
            }// if both rows aren't empty
            nRow++;
        }// while loop

        return true;
    }// ValidateData

    internal override bool ApplyData()
    {
        // Make sure this page has been displayed before we apply data to it
        if (m_dg != null)
        {
            // Let's build a binding policy structure
            BindingPolicy bp = new BindingPolicy();
            bp.scBaseVersion = new StringCollection();
            bp.scRedirectVersion = new StringCollection();

            // Let's jump to a new cell, to make sure the current cell we
            // were editing has it's changes 'saved'
            m_dg.CurrentCell = new DataGridCell(0,1);
            m_dg.CurrentCell = new DataGridCell(0,0);


            // We need to do a try/catch block here since we getting the count of
            // rows from the data table isn't completely accurate, so we'll just loop
            // until the data grid throws us an exception about accessing an invalid row.
            int nRow=0;

            while(nRow <= m_dt.Rows.Count)
            {
                if (isValidRow(nRow))
                {
                    bp.scBaseVersion.Add((String)m_dg[nRow, 0]);
                    bp.scRedirectVersion.Add((String)m_dg[nRow, 1]);
                }
                nRow++;
            }

            String sSetSettingString = "BindingPolicyFor" + m_bri.Name + "," + m_bri.PublicKeyToken;
            if (m_sConfigFile != null)
                sSetSettingString+= "," + m_sConfigFile;

            
            if (!CConfigStore.SetSetting(sSetSettingString, bp))
                return false;

            CNodeManager.GetNode(m_iCookie).RefreshResultView();

            return true;
        }
        return false;
    }// ApplyData

    internal void onVisibleChange(Object o, EventArgs e)
    {
        if (m_dg.TheVertScrollBar.Visible)
        {       
            // We loose 13 pixels when we have a vertical scrollbar
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CAssemBindPolicyProp:NVColumnWidth")) - m_dg.TheVertScrollBar.Width;
            m_dg.Refresh();

        }   
        else
        {
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CAssemBindPolicyProp:NVColumnWidth"));
        }

    }// onVisibleChange

    void onCellChange(Object o, EventArgs e)
    {
        bool fEnable = false;
        
        if (m_dg.CurrentRowIndex != -1)
        {
            // See if we're on a valid row
            if (m_dg.CurrentRowIndex < m_dt.Rows.Count)
            {
                if (isValidColumn(m_dg.CurrentRowIndex, 0) || isValidColumn(m_dg.CurrentRowIndex, 1))
                    fEnable = true;
            }
        }
        m_btnDeleteEntry.Enabled = fEnable;
    }// onCellChange

    private bool isValidRow(int nRowNum)
    {
        return (isValidColumn(nRowNum, 0) && isValidColumn(nRowNum, 1));
    }// isValidRow
    
    private bool isValidColumn(int nRowNum, int nColumnNum)
    {
        // The value needs to be a string and it needs to be longer than 0
        try
        {
            if ((m_dg[nRowNum, nColumnNum] is String) && ((String)m_dg[nRowNum, nColumnNum]).Length > 0)
                return true;
        }
        catch(Exception)
        {}
        return false;            
    }// isValidColumn



    
}// class CAssemBindPolicyProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\capplicationdepends.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Drawing;
using System.Collections;
using System.Runtime.InteropServices;
using System.Threading;
using System.Reflection;
using System.Globalization;

internal class CApplicationDepends : CNode
{
    private static Thread               m_thread = new Thread(new ThreadStart(DependencyFinder));
    private static ArrayList            m_alNodes = ArrayList.Synchronized(new ArrayList());
    private static CApplicationDepends  m_ThreadNode = null;

    private ArrayList   m_olAssems;

    private bool        m_fShowHTMLPage;
    private bool        m_fReadShowHTML;
    
    private CTaskPad    m_taskPad;
    private CTaskPad    m_taskPadWaiting;
    
    private String      m_sAppFile;

    private bool        m_fIKnowMyDependencies;
    private bool        m_fAllowListView;

    private IntPtr      m_hAssemIcon;
    private int         m_iAssemIconIndex;

    internal CApplicationDepends(String sAppFile)
    {
        m_sGuid = "96821C0B-CBE2-4dc9-AC52-756A3361B07F";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("sharedassemblies_ico");  
        DisplayName = CResourceStore.GetString("CApplicationDepends:DisplayName");
        Name = "Assembly Dependencies";
        
        m_taskPadWaiting = new CGenericTaskPad(this, "WAITINGDEPENDASSEM_HTML"); 
        m_taskPad = new CGenericTaskPad(this, "DEPENDASSEM_HTML");

        m_fIKnowMyDependencies = false;
        m_fAllowListView = false;
        m_fAllowMultiSelectResults=true;


        m_fReadShowHTML = false;
        m_oResults = m_taskPadWaiting;
        m_olAssems = null;

        m_sAppFile = sAppFile;

        // Get icons for the assemblies we show
        m_hAssemIcon = CResourceStore.GetHIcon("gac_ico");  
        m_iAssemIconIndex = CResourceStore.GetIconCookie(m_hAssemIcon);


        // If we're not managed, then don't bother trying to have our dependencies
        // found
        if (!Fusion.isManaged(m_sAppFile))
        {
            m_taskPad = new CGenericTaskPad(this, "UNMANAGEDDEPENDASSEM_HTML");
            m_oResults = m_taskPad;
            m_fIKnowMyDependencies = true;
        }
        else
        {
            // Get ourselves in a queue to have our dependent assemblies discovered....
            if (m_alNodes == null)
                m_alNodes = ArrayList.Synchronized(new ArrayList());

            m_alNodes.Add(this);
    
            if (m_thread == null)
                m_thread = new Thread(new ThreadStart(DependencyFinder));
            if (!m_thread.IsAlive)
            {
                m_thread.Priority = ThreadPriority.Lowest;
                m_thread.Start();
            }
        }
    }// CApplicationDepends

    internal override void Shutdown()
    {
        if (m_thread != null)
        {
            m_thread.Abort();
            m_thread = null;
        }
    }// Shutdown

    internal bool HaveDepends
    {
        get
        {
            if (!m_fIKnowMyDependencies)
            {
                GenerateDependentAssemblies();
            }
            // If we have a list of things, then we have the assemblies
            return (m_olAssems!=null);
        }

    }


    static private void DependencyFinder()
    {
        while(true)
        {
            if (m_alNodes.Count != 0)
            {
                m_ThreadNode = (CApplicationDepends)m_alNodes[0];
                m_alNodes.RemoveAt(0);
                if (!m_ThreadNode.m_fIKnowMyDependencies)
                    FindDependenciesForThisNode(m_ThreadNode);
                m_ThreadNode.m_fIKnowMyDependencies = true;
                m_thread.Priority = ThreadPriority.Lowest;

            }
            // There was nothing for us to do... let's sleep for awhile
            else
            {
               Thread.Sleep(100);
            }
        }
    }// DependencyFinder

    static private void FindDependenciesForThisNode(CApplicationDepends cad)
    {
        // Let's dig into what assemblies this application depends upon
        cad.m_taskPadWaiting = new CGenericTaskPad(cad, "LOADINGDEPENDASSEM_HTML"); 
        cad.m_oResults = cad.m_taskPadWaiting;
        cad.RefreshResultView();

        if (cad.m_sAppFile != null && cad.m_olAssems == null)
        {
            AssemblyDependencies ad=null;
            try
            {
                // Grab the path off this sucker
                String[] sArgs = cad.m_sAppFile.Split(new char[] {'\\'});
                // Now join the directory together
                String sDir = String.Join("\\", sArgs, 0, sArgs.Length>1?sArgs.Length-1:1);

                // We want to give the assembly loader the path that this application
                // lives in. That way it will be able to find any private assemblies
                // that the app may depend on.
                ad = new AssemblyDependencies(cad.m_sAppFile, new LoadAssemblyInfo().AppPath(sDir));
                cad.m_olAssems = new ArrayList();
                ArrayList   al = ad.Assems;
                for(int i=0; i<al.Count; i++)
                {   
                    AssemInfo ai = new AssemInfo();
                    AssemblyName an = (AssemblyName)al[i];
                    ai.Name = an.Name;
                    ai.Version = an.Version.ToString();
                    ai.Locale = an.CultureInfo.ToString();
                    ai.PublicKeyToken = ByteArrayToString(an.GetPublicKeyToken());

                    AddAssemblyInfo(cad.m_olAssems, ai);
                }
                ad.DoneLoading();
                cad.m_fAllowListView = true;
            }
            catch(Exception)
            {
                cad.m_taskPad = new CGenericTaskPad(cad, "ERRORDEPENDASSEM_HTML");
                cad.m_olAssems = null;
            }

            if (ad != null)
            {
                ad.DoneLoading();
            }

        }
        else if (cad.m_sAppFile == null)
        {
            cad.m_olAssems = null;
            cad.m_taskPad = new CGenericTaskPad(cad, "ERRORDEPENDASSEM_HTML");
        }
        cad.m_oResults=cad.m_taskPad;
        cad.RefreshResultView();

    }// FindDependenciesForThisNode

    static private void AddAssemblyInfo(ArrayList al, AssemInfo ai)
    {
        // Look through this list and see if we have any other
        int nLen = al.Count;
        for(int i=0; i<nLen; i++)
        {
            AssemInfo aiMatch = (AssemInfo)al[i];
            if (String.Compare(ai.Name, aiMatch.Name, false, CultureInfo.InvariantCulture) == 0)
                if (String.Compare(ai.Version, aiMatch.Version, false, CultureInfo.InvariantCulture) == 0)
                    if (String.Compare(ai.Locale, aiMatch.Locale, false, CultureInfo.InvariantCulture) == 0)
                        if (String.Compare(ai.PublicKeyToken, aiMatch.PublicKeyToken, false, CultureInfo.InvariantCulture) == 0)
                        // We found a match! Don't add this into our list
                            return;
        }
        // We didn't find it... let's add it in. 
        al.Add(ai);

    }// AddAssemblyInfo
   
    internal void GenerateDependentAssemblies()
    {
        // Ok, let's see if we're currently being worked on....
        m_thread.Suspend();
        if (m_olAssems == null)
        {
            m_taskPadWaiting = new CGenericTaskPad(this, "LOADINGDEPENDASSEM_HTML"); 
            m_oResults = m_taskPadWaiting;
            CNodeManager.Console.SelectScopeItem(HScopeItem);

            // If the thread is currently working on this node, m_ThreadNode will be this node.
            // The second case is a little more tricky. If this node is next in line, there's
            // the possibility that our thread that handles this will be a few instructions
            // away from getting him. We won't bother working with it then.
            if (!m_fIKnowMyDependencies && m_ThreadNode != this && m_alNodes[0] != this)
            {
                FindDependenciesForThisNode(this);
                m_fIKnowMyDependencies=true;
            }
            // Our thread is working on it... let's give it high priority...
            else
            {
                m_thread.Priority = ThreadPriority.Highest;
            }
        }
        m_thread.Resume();
    }// GenerateDependentAssemblies

    internal override void ResultItemSelected(IConsole2 con, Object oResults)
    {
        IConsoleVerb icv;       
        // Get the IConsoleVerb interface from MMC
        con.QueryConsoleVerb(out icv);

        // We want to enable drag-drop actions
        icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, 1);
        icv.SetVerbState(MMC_VERB.PASTE, MMC_BUTTON_STATE.ENABLED, 1);
    }// ResultItemSelected

    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed, Object oResultItem)
    {  
         CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
         // See if we're allowed to insert an item in the "view" section
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
         {
            if (!m_fIKnowMyDependencies)
            {
                // Stuff common to the top menu
                newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
                newitem.fFlags = 0;
                newitem.fSpecialFlags=0;

                newitem.strName = CResourceStore.GetString("CApplicationDepends:DiscoverNowMenuOption");
                newitem.strStatusBarText = CResourceStore.GetString("CApplicationDepends:DiscoverNowMenuOptionDes");
                newitem.lCommandID = COMMANDS.FIND_DEPENDENTASSEMBLIES;
        
                piCallback.AddItem(ref newitem);
            }

         }
         // See if we can insert in the view menu
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_VIEW) > 0)
         {
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_VIEW;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // If we're showing the taskpad right now
            if (m_oResults is CGenericTaskPad && m_fAllowListView)
            {
                newitem.strName = CResourceStore.GetString("CApplicationDepends:ViewAssembliesOption");
                newitem.strStatusBarText = CResourceStore.GetString("CApplicationDepends:ViewAssembliesOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_LISTVIEW;
            }
            // Currently, we're showing the list view
            else if (!(m_oResults is CGenericTaskPad))
            {
                newitem.strName = CResourceStore.GetString("CApplicationDepends:ViewHTMLOption");
                newitem.strStatusBarText = CResourceStore.GetString("CApplicationDepends:ViewHTMLOptionDes");
                newitem.lCommandID = COMMANDS.SHOW_TASKPAD;
            }
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);
         }
     }// AddMenuItems

     internal override void MenuCommand(int iCommandID, Object oResultItem)
     {
    
        if (iCommandID == COMMANDS.FIND_DEPENDENTASSEMBLIES)
        {
            // Ok, let's see if we're currently being worked on....
            m_thread.Suspend();
            m_taskPadWaiting = new CGenericTaskPad(this, "LOADINGDEPENDASSEM_HTML"); 
            m_oResults = m_taskPadWaiting;
            RefreshResultView();

            // If the thread is currently working on this node, m_ThreadNode will be this node.
            // The second case is a little more tricky. If this node is next in line, there's
            // the possibility that our thread that handles this will be a few instructions
            // away from getting him. We won't bother working with it then.
            if (!m_fIKnowMyDependencies && m_ThreadNode != this && m_alNodes[0] != this)
            {
                FindDependenciesForThisNode(this);
                m_fIKnowMyDependencies=true;
            }
            // Our thread is working on it... let's give it high priority...
            else
            {
               m_thread.Priority = ThreadPriority.Highest;

            }

            m_thread.Resume();


        }
        else if (iCommandID == COMMANDS.SHOW_LISTVIEW && m_fAllowListView)
        {
            m_oResults=this;
            RefreshResultView();
            m_fShowHTMLPage = false;
        }

        else if (iCommandID == COMMANDS.SHOW_TASKPAD)
        {
            m_oResults=m_taskPad;
            m_fShowHTMLPage = true;
            // The HTML pages comes displayed with this checkbox marked. Make
            // sure we update the xml setting
            CConfigStore.SetSetting("ShowHTMLForDependAssem", "yes");
            RefreshResultView();
        }
            
    }// MenuCommand


     internal override void Showing()
     {
        if (m_oResults != m_taskPadWaiting)
        {
            // See if we've read from the XML file yet whether we're supposed to
            // show the HTML file
            if (!m_fReadShowHTML)
            {
                // Now tell my taskpad that I'm ready....
                m_fShowHTMLPage = ((String)CConfigStore.GetSetting("ShowHTMLForDependAssem")).Equals("yes");

                if (m_fShowHTMLPage || m_olAssems == null)
                    m_oResults=m_taskPad;
                else
                    m_oResults=this;

                m_fReadShowHTML = true;
            }
        }
     }// Showing

    internal override int onRestoreView(MMC_RESTORE_VIEW mrv, IntPtr param)
    {
        // See if we should be displaying our HTML page or the result view
        if (mrv.pViewType == (IntPtr)0)
        {
            // We should display the column view
            m_oResults = this;
        }
        else
        {
            m_fShowHTMLPage = true;
            m_oResults = m_taskPad;
        }
        // Now we need to tell MMC we handled this.
        Marshal.WriteIntPtr(param, (IntPtr)1);
        return HRESULT.S_OK;
    }// onRestoreView

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
       if ((int)arg == 1)
       {
            CConfigStore.SetSetting("ShowHTMLForDependAssem", (bool)param?"yes":"no");
            m_fShowHTMLPage = (bool)param;

            // We'll change the result object but we won't refresh our result view
            // because the user doesn't necesarily want that to happen. However, 
            // the next time the user visits this node, they will see the new result
            // view
            m_oResults = m_fShowHTMLPage?(Object)m_taskPad:(Object)this;                

       }
       else if ((int)arg == 0)
       {
            m_oResults = this;
            RefreshResultView();
       }
       else if ((int)arg == 2)
       {
            MenuCommand(COMMANDS.FIND_DEPENDENTASSEMBLIES, null);
       }
    }// TaskPadTaskNotify

    internal AssemInfo GetAssemInfo(int iIndex)
    {
        return (AssemInfo)m_olAssems[iIndex];
    }// GetAssemInfo

    internal ArrayList DependentAssemblies
    {
        get
        {
            m_thread.Suspend();
            while(m_olAssems == null)
            {
                m_thread.Resume();
                // We'll sleep so the other thread can finish up
                Thread.Sleep(100);
                m_thread.Suspend();
            }

            m_thread.Resume();
            return m_olAssems;
        }
    }// DependentAssemblies
    

    //-------------------------------------------------
    // Methods to implement the IColumnResultView interface
    //-------------------------------------------------

    public override void AddImages(ref IImageList il)
    {
        il.ImageListSetIcon(m_hAssemIcon, m_iAssemIconIndex);
    }// AddImages
    public override int GetImageIndex(int i)
    {
        return m_iAssemIconIndex;
    }// GetImageIndex


    
    public override int getNumColumns()
    {
        // We will always have 4 columns in the result view
        return 4;
    }// getNumColumns
    public override int getNumRows()
    {
        return (m_olAssems != null)?m_olAssems.Count:0;
    }// GetNumRows
    public override String getColumnTitles(int iIndex)
    {
        String[] Titles= new String[] { CResourceStore.GetString("Assembly Name"), 
                                        CResourceStore.GetString("Version"),
                                        CResourceStore.GetString("Locale"),
                                        CResourceStore.GetString("Public Key Token"),
                                      };
        // Make sure they're in range
        if (iIndex >= 0 && iIndex< getNumColumns())
            return Titles[iIndex];
        else
            throw new Exception("Index out of bounds");
    }// getColumnTitles
    public override String getValues(int nRow, int nColumn)
    {
         // Make sure the indicies they give us are valid
        if (nRow >=0 && nRow<getNumRows() && nColumn>=0 && nColumn<getNumColumns())
        {
            switch(nColumn)
            {
                case 0:
                    return GetAssemInfo(nRow).Name;
                case 1:
                    return GetAssemInfo(nRow).Version;
                case 2:
                    return GetAssemInfo(nRow).Locale;
                case 3:
                    return GetAssemInfo(nRow).PublicKeyToken;
            }                    
            // This shouldn't happen, but the compiler thinks it could
            return null;
            
        }
        else
            return "";
    }// getValues

    [DllImport("shell32.dll")]
    internal static extern uint DragQueryFile(IntPtr hDrop, uint iFile, IntPtr lpszFile, uint cch);

    [DllImport("ole32.dll")]
    internal static extern void ReleaseStgMedium(ref STGMEDIUM pmedium);

}// class CSharedAssemblies
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cassemvercodebases.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections.Specialized;
using System.ComponentModel;


internal class CAssemVerCodebases : CPropPage
{
    // Controls on the page
	
    private Label m_lblExample4;
    private Button m_btnDeleteEntry;
    private MyDataGrid m_dg;
    private Label m_lblExamples;
    private Label m_lblBindingHelp;
    private Label m_lblExample1;
    private Label m_lblExample3;
    private Label m_lblExample2;
    private DataTable m_dt;
    private DataSet     m_ds;
    // The current Binding Policy we have for this assembly
    private BindingRedirInfo    m_bri;
    // The file we're going to save our configuration to
    private String              m_sConfigFile;

    internal CAssemVerCodebases(BindingRedirInfo bri)
    {
        m_bri=bri;
        m_sConfigFile=null;
        m_sTitle=CResourceStore.GetString("CAssemVerCodebases:PageTitle"); 

    }// CAssemVerCodebases

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CAssemVerCodebases));
        this.m_lblExample4 = new System.Windows.Forms.Label();
        this.m_btnDeleteEntry = new System.Windows.Forms.Button();
        this.m_dg = new MyDataGrid();
        this.m_lblExamples = new System.Windows.Forms.Label();
        this.m_lblBindingHelp = new System.Windows.Forms.Label();
        this.m_lblExample1 = new System.Windows.Forms.Label();
        this.m_lblExample3 = new System.Windows.Forms.Label();
        this.m_lblExample2 = new System.Windows.Forms.Label();
        this.m_lblExample4.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample4.Location")));
        this.m_lblExample4.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample4.Size")));
        this.m_lblExample4.TabIndex = ((int)(resources.GetObject("m_lblExample4.TabIndex")));
        this.m_lblExample4.Text = resources.GetString("m_lblExample4.Text");
        m_lblExample4.Name = "Example4";
        this.m_btnDeleteEntry.Location = ((System.Drawing.Point)(resources.GetObject("m_btnDeleteEntry.Location")));
        this.m_btnDeleteEntry.Size = ((System.Drawing.Size)(resources.GetObject("m_btnDeleteEntry.Size")));
        this.m_btnDeleteEntry.TabIndex = ((int)(resources.GetObject("m_btnDeleteEntry.TabIndex")));
        this.m_btnDeleteEntry.Text = resources.GetString("m_btnDeleteEntry.Text");
        m_btnDeleteEntry.Name = "Delete";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        this.m_lblExamples.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExamples.Location")));
        this.m_lblExamples.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExamples.Size")));
        this.m_lblExamples.TabIndex = ((int)(resources.GetObject("m_lblExamples.TabIndex")));
        this.m_lblExamples.Text = resources.GetString("m_lblExamples.Text");
        m_lblExamples.Name = "Examples";
        this.m_lblBindingHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblBindingHelp.Location")));
        this.m_lblBindingHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblBindingHelp.Size")));
        this.m_lblBindingHelp.TabIndex = ((int)(resources.GetObject("m_lblBindingHelp.TabIndex")));
        this.m_lblBindingHelp.Text = resources.GetString("m_lblBindingHelp.Text");
        m_lblBindingHelp.Name = "BindingHelp";
        this.m_lblExample1.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample1.Location")));
        this.m_lblExample1.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample1.Size")));
        this.m_lblExample1.TabIndex = ((int)(resources.GetObject("m_lblExample1.TabIndex")));
        this.m_lblExample1.Text = resources.GetString("m_lblExample1.Text");
        m_lblExample1.Name = "Example1";
        this.m_lblExample3.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample3.Location")));
        this.m_lblExample3.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample3.Size")));
        this.m_lblExample3.TabIndex = ((int)(resources.GetObject("m_lblExample3.TabIndex")));
        this.m_lblExample3.Text = resources.GetString("m_lblExample3.Text");
        m_lblExample3.Name = "Example3";
        this.m_lblExample2.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExample2.Location")));
        this.m_lblExample2.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExample2.Size")));
        this.m_lblExample2.TabIndex = ((int)(resources.GetObject("m_lblExample2.TabIndex")));
        this.m_lblExample2.Text = resources.GetString("m_lblExample2.Text");
        m_lblExample2.Name = "Example2";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblExample4,
                        this.m_lblExample3,
                        this.m_lblExample2,
                        this.m_lblExample1,
                        this.m_dg,
                        this.m_btnDeleteEntry,
                        this.m_lblExamples,
                        this.m_lblBindingHelp});
       
        // ----------------- Let's build our data table --------------

        // We'll create these variables just so we can use their type...
        // we don't need to worry about their actual values.
        
        m_dt = new DataTable("Stuff");

        // Create the columns for this table
        DataColumn dcReqVersion = new DataColumn();
        dcReqVersion.ColumnName = "Requested Version";
        dcReqVersion.DataType = typeof(String);
        m_dt.Columns.Add(dcReqVersion);

        DataColumn dcURL = new DataColumn();
        dcURL.ColumnName = "URI";
        dcURL.DataType = typeof(String);
        m_dt.Columns.Add(dcURL);

        // Now set up any column-specific behavioral stuff....
        // like not letting the checkboxes allow null, setting
        // column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcReqVer = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcURL = new DataGridTextBoxColumn();
         
        m_dg.TableStyles.Add(dgts);
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;
        dgts.ReadOnly=false;
        // Set up the column info for the Requested Version column
        dgtbcReqVer.MappingName = "Requested Version";
        dgtbcReqVer.HeaderText = CResourceStore.GetString("CAssemVerCodebases:RVColumn");
        dgtbcReqVer.Width = ScaleWidth(CResourceStore.GetInt("CAssemVerCodebases:RVColumnWidth"));
        dgtbcReqVer.ReadOnly = false;
        dgtbcReqVer.NullText = "";
        // Allows us to filter what is typed into the box
        dgtbcReqVer.TextBox.KeyPress +=new KeyPressEventHandler(onVersionKeyPress);
        dgtbcReqVer.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcReqVer);

        // Set up the column info for the New Version column
        dgtbcURL.MappingName = "URI";
        dgtbcURL.HeaderText = CResourceStore.GetString("CAssemVerCodebases:URIColumn");
        dgtbcURL.Width = ScaleWidth(CResourceStore.GetInt("CAssemVerCodebases:URIColumnWidth"));
        dgtbcURL.NullText = "";
        dgtbcURL.TextBox.TextChanged +=new EventHandler(onChange);
        dgts.GridColumnStyles.Add(dgtbcURL);
        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);

        m_dg.DataSource = m_dt;
		m_dg.BackgroundColor = Color.White;
        //--------------- End Building Data Table ----------------------------



        // Some UI Tweaks        
        m_dg.ReadOnly=false;
        m_dg.CaptionVisible=false;
        PageControls.Add(m_dg);

        // Fill in the data
        PutValuesinPage();

        // Set up any callbacks
        m_btnDeleteEntry.Click += new EventHandler(onDeleteEntireRow);
        m_dg.TheVertScrollBar.VisibleChanged += new EventHandler(onVisibleChange);
        // Allows us to enable/disable the delete button
        m_dg.CurrentCellChanged += new EventHandler(onCellChange);

        onCellChange(null, null);
        // See if we need to adjust the width of the headers
        onVisibleChange(null, null);
		return 1;
    }// InsertPropSheetPageControls

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onKeyPress
    
    void onVersionKeyPress(Object o, KeyPressEventArgs e)
    {

        // We only care about a few characters that the user enters... specifically
        // digits, periods, and astericks. If the user entered that, inform the text
        // box control that we did not handle the event, and so the text box should
        // take care of it. If the user enters a character we're not interested in,
        // like letters and all other punctuation, tell the textbox control that
        // we handled it, so the textbox control will ignore the input.

        // Swallow up letters... we don't want the user to be able to type them
        if (Char.IsLetter(e.KeyChar))
            e.Handled=true;

        // Swallow up punctionation
        if (Char.IsPunctuation(e.KeyChar) && e.KeyChar != '.')
            e.Handled=true;
    }// onVersionKeyPress

    void onDeleteEntireRow(Object o, EventArgs e)
    {
        if (m_dg.CurrentRowIndex != -1)
        {
            if (m_dg.CurrentRowIndex >= m_dt.Rows.Count)
            {
                // Try moving to a different cell to 'submit' this data
                int nOldRow = m_dg.CurrentRowIndex;
                m_dg.CurrentCell = new DataGridCell(0, 0);
                // And now move back to the original row                
                m_dg.CurrentCell = new DataGridCell(nOldRow, 0);
            }
            // They're trying to delete a non-existant row
            if (m_dg.CurrentRowIndex >= m_dt.Rows.Count)
                return;
        
            int nRet = MessageBox(CResourceStore.GetString("CAssemVerCodebases:VerifyDeleteEntry"), 
                                  CResourceStore.GetString("CAssemVerCodebases:VerifyDeleteEntryTitle"),
                                  MB.ICONQUESTION|MB.YESNO);

            if (nRet == MB.IDYES)
            {
                int nRowToDelete = m_dg.CurrentRowIndex;
                int nRowToMoveTo = 0;
        
                if (nRowToDelete == 0)
                    nRowToMoveTo=1;
            
                m_dg.CurrentCell = new DataGridCell(nRowToMoveTo, 0);

        
                m_dt.Rows.Remove(m_dt.Rows[nRowToDelete]);

                // See if we need to add more rows again....
        
                while(m_dt.Rows.Count < 1)
                {
                    DataRow newRow;
                    newRow = m_dt.NewRow();
                    newRow["Requested Version"]="";
                    newRow["URI"]="";
                    m_dt.Rows.Add(newRow);
                }
                if (nRowToDelete >= m_dt.Rows.Count)
                    nRowToMoveTo = nRowToDelete-1;
                else
                    nRowToMoveTo = nRowToDelete;

                // End up with the cursor on the point right after the delete item    
                m_dg.CurrentCell = new DataGridCell(nRowToMoveTo,0);
                ActivateApply();
            }
        }
    }// onDeleteEntireRow

    private void PutValuesinPage()
    {
        // Get info that we'll need from the node
        CNode node = CNodeManager.GetNode(m_iCookie);
        // This should be ok now, but if we need this functionality
        // off of different nodes.....
        CVersionPolicy vp = (CVersionPolicy)node;

        String sGetSettingString = "CodeBasesFor" + m_bri.Name + "," + m_bri.PublicKeyToken;
        // If we are getting this from an App config file, let's add that info
        m_sConfigFile = vp.ConfigFile;
        
        if (m_sConfigFile != null)
            sGetSettingString += "," + m_sConfigFile;
        
        CodebaseLocations cbl = (CodebaseLocations)CConfigStore.GetSetting(sGetSettingString);

        int iLen = cbl.scVersion.Count;
        for(int i=0; i<iLen; i++)
        {
            DataRow newRow;
            newRow = m_dt.NewRow();
            newRow["Requested Version"]=cbl.scVersion[i];
            newRow["URI"]=cbl.scCodeBase[i];
            m_dt.Rows.Add(newRow);
        }

        // We want to have at least 1 row
        while(m_dt.Rows.Count < 1)
        {
            DataRow newRow;
            newRow = m_dt.NewRow();
            newRow["Requested Version"]="";
            newRow["URI"]="";
            m_dt.Rows.Add(newRow);
        }
        m_dg.CurrentCell = new DataGridCell(iLen,0);
    }// PutValuesinPage


    internal override bool ValidateData()
    {
        // Let's jump to a new cell, to make sure the current cell we
        // were editing has it's changes 'saved'
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);


    
        // We need to do a try/catch block here since we getting the count of
        // rows from the data table isn't completely accurate, so we'll just loop
        // until the data grid throws us an exception about accessing an invalid row.
        int nRow=0;
        while(nRow <= m_dt.Rows.Count)
        {
            if (isValidColumn(nRow, 0) || isValidColumn(nRow, 1))
            {
                // Make sure both of these entries are valid

                // Check the Version...
                try
                {
                    // Catch the error that they didn't enter anything
                    if (!isValidColumn(nRow, 0))
                    {
                        MessageBox(CResourceStore.GetString("CAssemVerCodebases:NeedVersion"),
                                   CResourceStore.GetString("CAssemVerCodebases:NeedVersionTitle"),
                                   MB.ICONEXCLAMATION);
                                           
                        m_dg.CurrentCell = new DataGridCell(nRow,0);
                        return false;
                    }
                    new Version((String)m_dg[nRow, 0]);
                }
                catch(Exception)
                {
                    // Catch the error that is was an invalid version
                    MessageBox(String.Format(CResourceStore.GetString("isanInvalidVersion"),(String)m_dg[nRow, 0]),
                               CResourceStore.GetString("isanInvalidVersionTitle"),
                               MB.ICONEXCLAMATION);
                    m_dg.CurrentCell = new DataGridCell(nRow,0);

                    return false;                                       
                }
                // Now check the URL
                try
                {
                    // Catch the error that they didn't enter anything
                    if (!isValidColumn(nRow, 1))
                    {
                        MessageBox(CResourceStore.GetString("CAssemVerCodebases:NeedURI"),
                                   CResourceStore.GetString("CAssemVerCodebases:NeedURITitle"),
                                   MB.ICONEXCLAMATION);
                                           
                        m_dg.CurrentCell = new DataGridCell(nRow,1);
                        return false;
                    }
                    // Catch the error that they entered in an invalid URI
                    new Uri((String)m_dg[nRow, 1]);
                }
                catch(Exception)
                {
                    // Catch the error that is was an invalid URI
                    MessageBox(String.Format(CResourceStore.GetString("CAssemVerCodebases:isanInvalidURI"), (String)m_dg[nRow, 1]),
                               CResourceStore.GetString("CAssemVerCodebases:isanInvalidURITitle"),
                               MB.ICONEXCLAMATION);
                    m_dg.CurrentCell = new DataGridCell(nRow,1);

                    return false;                                       
                }
            }// if both fields aren't empty                    
            nRow++;
        }// while loop
        
        return true;
    }// ValidateData


    internal override bool ApplyData()
    {
        // Make sure we've displayed this page first
        if (m_dg != null)
        {
            // Let's build a CodebaseLocations structure and put all our data in it.
            CodebaseLocations cbl = new CodebaseLocations();
            cbl.scVersion = new StringCollection();
            cbl.scCodeBase = new StringCollection();

            // Let's jump to a new cell, to make sure the current cell we
            // were editing has it's changes 'saved'
            m_dg.CurrentCell = new DataGridCell(0,1);
            m_dg.CurrentCell = new DataGridCell(0,0);


            // We need to do a try/catch block here since we getting the count of
            // rows from the data table isn't completely accurate, so we'll just loop
            // until the data grid throws us an exception about accessing an invalid row.
            int nRow=0;

            while(nRow <= m_dt.Rows.Count)
            {
                if (isValidRow(nRow))
                {
                    cbl.scVersion.Add((String)m_dg[nRow, 0]);
                    cbl.scCodeBase.Add((String)m_dg[nRow, 1]);
                }
                nRow++;
            }

            String sSetSettingString = "CodeBasesFor" + m_bri.Name + "," + m_bri.PublicKeyToken;
            if (m_sConfigFile != null)
                sSetSettingString+= "," + m_sConfigFile;


            if (!CConfigStore.SetSetting(sSetSettingString, cbl))   
                return false;
                
            CNodeManager.GetNode(m_iCookie).RefreshResultView();

            
            return true;
        }
        return false;
    }// ApplyData

    internal void onVisibleChange(Object o, EventArgs e)
    {
        if (m_dg.TheVertScrollBar.Visible)
        {   
            // If the scrollbar is visible, we've lost 13 pixels
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CAssemVerCodebases:URIColumnWidth")) - m_dg.TheVertScrollBar.Width;
            m_dg.Refresh();
        }   
        else
        {
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CAssemVerCodebases:URIColumnWidth"));
        }

    }// onVisibleChange

    void onCellChange(Object o, EventArgs e)
    {
        bool fEnable = false;
        
        if (m_dg.CurrentRowIndex != -1)
        {
            // See if we're on a valid row
            if (m_dg.CurrentRowIndex < m_dt.Rows.Count)
            {
                if (isValidColumn(m_dg.CurrentRowIndex, 0) || isValidColumn(m_dg.CurrentRowIndex, 1))
                    fEnable = true;
            }
        }
        m_btnDeleteEntry.Enabled = fEnable;
    }// onCellChange   

    private bool isValidRow(int nRowNum)
    {
        return (isValidColumn(nRowNum, 0) && isValidColumn(nRowNum, 1));
    }// isValidRow
    
    private bool isValidColumn(int nRowNum, int nColumnNum)
    {
        // The value needs to be a string and it needs to be longer than 0
        try
        {
            if ((m_dg[nRowNum, nColumnNum] is String) && ((String)m_dg[nRowNum, nColumnNum]).Length > 0)
                return true;
        }
        catch(Exception)
        {}
        return false;            
    }// isValidColumn
    
}// class CAssemVerCodebases

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cchooseappdialog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections.Specialized;
using System.Security;
using System.Runtime.InteropServices;
using System.IO;
using System.Diagnostics;
using System.ComponentModel;
using System.Globalization;


class CChooseAppDialog : Form
{
    private Label m_lblHelp;
    private Label m_lblChooseApp;
    private ListView m_lvApps;
    private Label m_lblBrowse;
    private Button m_btnBrowse;
    private Button m_btnOK;
    private Button m_btnCancel;
    private ImageList m_ilIcons;


    private String  m_sFilename;
    
    internal CChooseAppDialog()
    {
        SetupControls();
    }// CChooseAppDialog

    internal String Filename
    {
        get
        {
            return m_sFilename;
        }
    }// Filename

    private void SetupControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CChooseAppDialog));
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblChooseApp = new System.Windows.Forms.Label();
        this.m_lvApps = new System.Windows.Forms.ListView();
        this.m_lblBrowse = new System.Windows.Forms.Label();
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_btnOK = new System.Windows.Forms.Button();
        this.m_btnCancel = new System.Windows.Forms.Button();
        this.SuspendLayout();
        // 
        // m_lblHelp
        // 
        this.m_lblHelp.AccessibleDescription = ((string)(resources.GetObject("m_lblHelp.AccessibleDescription")));
        this.m_lblHelp.AccessibleName = ((string)(resources.GetObject("m_lblHelp.AccessibleName")));
        this.m_lblHelp.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblHelp.Anchor")));
        this.m_lblHelp.AutoSize = ((bool)(resources.GetObject("m_lblHelp.AutoSize")));
        this.m_lblHelp.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblHelp.Cursor")));
        this.m_lblHelp.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblHelp.Dock")));
        this.m_lblHelp.Enabled = ((bool)(resources.GetObject("m_lblHelp.Enabled")));
        this.m_lblHelp.Font = ((System.Drawing.Font)(resources.GetObject("m_lblHelp.Font")));
        this.m_lblHelp.Image = ((System.Drawing.Image)(resources.GetObject("m_lblHelp.Image")));
        this.m_lblHelp.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblHelp.ImageAlign")));
        this.m_lblHelp.ImageIndex = ((int)(resources.GetObject("m_lblHelp.ImageIndex")));
        this.m_lblHelp.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblHelp.ImeMode")));
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Name = "Help";
        this.m_lblHelp.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblHelp.RightToLeft")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        this.m_lblHelp.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblHelp.TextAlign")));
        this.m_lblHelp.Visible = ((bool)(resources.GetObject("m_lblHelp.Visible")));
        // 
        // m_lblChooseApp
        // 
        this.m_lblChooseApp.AccessibleDescription = ((string)(resources.GetObject("m_lblChooseApp.AccessibleDescription")));
        this.m_lblChooseApp.AccessibleName = ((string)(resources.GetObject("m_lblChooseApp.AccessibleName")));
        this.m_lblChooseApp.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblChooseApp.Anchor")));
        this.m_lblChooseApp.AutoSize = ((bool)(resources.GetObject("m_lblChooseApp.AutoSize")));
        this.m_lblChooseApp.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblChooseApp.Cursor")));
        this.m_lblChooseApp.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblChooseApp.Dock")));
        this.m_lblChooseApp.Enabled = ((bool)(resources.GetObject("m_lblChooseApp.Enabled")));
        this.m_lblChooseApp.Font = ((System.Drawing.Font)(resources.GetObject("m_lblChooseApp.Font")));
        this.m_lblChooseApp.Image = ((System.Drawing.Image)(resources.GetObject("m_lblChooseApp.Image")));
        this.m_lblChooseApp.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblChooseApp.ImageAlign")));
        this.m_lblChooseApp.ImageIndex = ((int)(resources.GetObject("m_lblChooseApp.ImageIndex")));
        this.m_lblChooseApp.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblChooseApp.ImeMode")));
        this.m_lblChooseApp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseApp.Location")));
        this.m_lblChooseApp.Name = "ChooseAppLabel";
        this.m_lblChooseApp.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblChooseApp.RightToLeft")));
        this.m_lblChooseApp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseApp.Size")));
        this.m_lblChooseApp.TabIndex = ((int)(resources.GetObject("m_lblChooseApp.TabIndex")));
        this.m_lblChooseApp.Text = resources.GetString("m_lblChooseApp.Text");
        this.m_lblChooseApp.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblChooseApp.TextAlign")));
        this.m_lblChooseApp.Visible = ((bool)(resources.GetObject("m_lblChooseApp.Visible")));
        // 
        // m_lvApps
        // 
        this.m_lvApps.AccessibleDescription = ((string)(resources.GetObject("m_lvApps.AccessibleDescription")));
        this.m_lvApps.AccessibleName = ((string)(resources.GetObject("m_lvApps.AccessibleName")));
        this.m_lvApps.Alignment = ((System.Windows.Forms.ListViewAlignment)(resources.GetObject("m_lvApps.Alignment")));
        this.m_lvApps.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lvApps.Anchor")));
        this.m_lvApps.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_lvApps.BackgroundImage")));

        ColumnHeader chApplication = new ColumnHeader();
        ColumnHeader chLocation = new ColumnHeader();;

        chApplication.Text = resources.GetString("Application.Text");
        chApplication.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("Application.TextAlign")));
        chApplication.Width = ((int)(resources.GetObject("Application.Width")));

        chLocation.Text = resources.GetString("Location.Text");
        chLocation.TextAlign = ((System.Windows.Forms.HorizontalAlignment)(resources.GetObject("Location.TextAlign")));
        chLocation.Width = ((int)(resources.GetObject("Location.Width")));

        this.m_lvApps.Columns.AddRange(new System.Windows.Forms.ColumnHeader[] {
                            chApplication,
                            chLocation});
        this.m_lvApps.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lvApps.Cursor")));
        this.m_lvApps.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lvApps.Dock")));
        this.m_lvApps.Enabled = ((bool)(resources.GetObject("m_lvApps.Enabled")));
        this.m_lvApps.Font = ((System.Drawing.Font)(resources.GetObject("m_lvApps.Font")));
        this.m_lvApps.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lvApps.ImeMode")));
        this.m_lvApps.LabelWrap = ((bool)(resources.GetObject("m_lvApps.LabelWrap")));
        this.m_lvApps.Location = ((System.Drawing.Point)(resources.GetObject("m_lvApps.Location")));
        this.m_lvApps.Name = "AppsList";
        this.m_lvApps.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lvApps.RightToLeft")));
        this.m_lvApps.Size = ((System.Drawing.Size)(resources.GetObject("m_lvApps.Size")));
        this.m_lvApps.TabIndex = ((int)(resources.GetObject("m_lvApps.TabIndex")));
        this.m_lvApps.Text = resources.GetString("m_lvApps.Text");
        this.m_lvApps.Visible = ((bool)(resources.GetObject("m_lvApps.Visible")));
        this.m_lvApps.FullRowSelect = true;

        // 
        // m_lblBrowse
        // 
        this.m_lblBrowse.AccessibleDescription = ((string)(resources.GetObject("m_lblBrowse.AccessibleDescription")));
        this.m_lblBrowse.AccessibleName = ((string)(resources.GetObject("m_lblBrowse.AccessibleName")));
        this.m_lblBrowse.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_lblBrowse.Anchor")));
        this.m_lblBrowse.AutoSize = ((bool)(resources.GetObject("m_lblBrowse.AutoSize")));
        this.m_lblBrowse.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_lblBrowse.Cursor")));
        this.m_lblBrowse.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_lblBrowse.Dock")));
        this.m_lblBrowse.Enabled = ((bool)(resources.GetObject("m_lblBrowse.Enabled")));
        this.m_lblBrowse.Font = ((System.Drawing.Font)(resources.GetObject("m_lblBrowse.Font")));
        this.m_lblBrowse.Image = ((System.Drawing.Image)(resources.GetObject("m_lblBrowse.Image")));
        this.m_lblBrowse.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblBrowse.ImageAlign")));
        this.m_lblBrowse.ImageIndex = ((int)(resources.GetObject("m_lblBrowse.ImageIndex")));
        this.m_lblBrowse.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_lblBrowse.ImeMode")));
        this.m_lblBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_lblBrowse.Location")));
        this.m_lblBrowse.Name = "BrowseLabel";
        this.m_lblBrowse.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_lblBrowse.RightToLeft")));
        this.m_lblBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_lblBrowse.Size")));
        this.m_lblBrowse.TabIndex = ((int)(resources.GetObject("m_lblBrowse.TabIndex")));
        this.m_lblBrowse.Text = resources.GetString("m_lblBrowse.Text");
        this.m_lblBrowse.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_lblBrowse.TextAlign")));
        this.m_lblBrowse.Visible = ((bool)(resources.GetObject("m_lblBrowse.Visible")));
        // 
        // m_btnBrowse
        // 
        this.m_btnBrowse.AccessibleDescription = ((string)(resources.GetObject("m_btnBrowse.AccessibleDescription")));
        this.m_btnBrowse.AccessibleName = ((string)(resources.GetObject("m_btnBrowse.AccessibleName")));
        this.m_btnBrowse.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_btnBrowse.Anchor")));
        this.m_btnBrowse.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_btnBrowse.BackgroundImage")));
        this.m_btnBrowse.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_btnBrowse.Cursor")));
        this.m_btnBrowse.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_btnBrowse.Dock")));
        this.m_btnBrowse.Enabled = ((bool)(resources.GetObject("m_btnBrowse.Enabled")));
        this.m_btnBrowse.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_btnBrowse.FlatStyle")));
        this.m_btnBrowse.Font = ((System.Drawing.Font)(resources.GetObject("m_btnBrowse.Font")));
        this.m_btnBrowse.Image = ((System.Drawing.Image)(resources.GetObject("m_btnBrowse.Image")));
        this.m_btnBrowse.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_btnBrowse.ImageAlign")));
        this.m_btnBrowse.ImageIndex = ((int)(resources.GetObject("m_btnBrowse.ImageIndex")));
        this.m_btnBrowse.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_btnBrowse.ImeMode")));
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Name = "Browse";
        this.m_btnBrowse.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_btnBrowse.RightToLeft")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        this.m_btnBrowse.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_btnBrowse.TextAlign")));
        this.m_btnBrowse.Visible = ((bool)(resources.GetObject("m_btnBrowse.Visible")));
        // 
        // m_btnOK
        // 
        this.m_btnOK.AccessibleDescription = ((string)(resources.GetObject("m_btnOK.AccessibleDescription")));
        this.m_btnOK.AccessibleName = ((string)(resources.GetObject("m_btnOK.AccessibleName")));
        this.m_btnOK.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_btnOK.Anchor")));
        this.m_btnOK.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_btnOK.BackgroundImage")));
        this.m_btnOK.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_btnOK.Cursor")));
        this.m_btnOK.DialogResult = System.Windows.Forms.DialogResult.OK;
        this.m_btnOK.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_btnOK.Dock")));
        this.m_btnOK.Enabled = ((bool)(resources.GetObject("m_btnOK.Enabled")));
        this.m_btnOK.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_btnOK.FlatStyle")));
        this.m_btnOK.Font = ((System.Drawing.Font)(resources.GetObject("m_btnOK.Font")));
        this.m_btnOK.Image = ((System.Drawing.Image)(resources.GetObject("m_btnOK.Image")));
        this.m_btnOK.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_btnOK.ImageAlign")));
        this.m_btnOK.ImageIndex = ((int)(resources.GetObject("m_btnOK.ImageIndex")));
        this.m_btnOK.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_btnOK.ImeMode")));
        this.m_btnOK.Location = ((System.Drawing.Point)(resources.GetObject("m_btnOK.Location")));
        this.m_btnOK.Name = "OK";
        this.m_btnOK.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_btnOK.RightToLeft")));
        this.m_btnOK.Size = ((System.Drawing.Size)(resources.GetObject("m_btnOK.Size")));
        this.m_btnOK.TabIndex = ((int)(resources.GetObject("m_btnOK.TabIndex")));
        this.m_btnOK.Text = resources.GetString("m_btnOK.Text");
        this.m_btnOK.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_btnOK.TextAlign")));
        this.m_btnOK.Visible = ((bool)(resources.GetObject("m_btnOK.Visible")));
        // 
        // m_btnCancel
        // 
        this.m_btnCancel.AccessibleDescription = ((string)(resources.GetObject("m_btnCancel.AccessibleDescription")));
        this.m_btnCancel.AccessibleName = ((string)(resources.GetObject("m_btnCancel.AccessibleName")));
        this.m_btnCancel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("m_btnCancel.Anchor")));
        this.m_btnCancel.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("m_btnCancel.BackgroundImage")));
        this.m_btnCancel.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("m_btnCancel.Cursor")));
        this.m_btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
        this.m_btnCancel.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("m_btnCancel.Dock")));
        this.m_btnCancel.Enabled = ((bool)(resources.GetObject("m_btnCancel.Enabled")));
        this.m_btnCancel.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("m_btnCancel.FlatStyle")));
        this.m_btnCancel.Font = ((System.Drawing.Font)(resources.GetObject("m_btnCancel.Font")));
        this.m_btnCancel.Image = ((System.Drawing.Image)(resources.GetObject("m_btnCancel.Image")));
        this.m_btnCancel.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_btnCancel.ImageAlign")));
        this.m_btnCancel.ImageIndex = ((int)(resources.GetObject("m_btnCancel.ImageIndex")));
        this.m_btnCancel.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("m_btnCancel.ImeMode")));
        this.m_btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("m_btnCancel.Location")));
        this.m_btnCancel.Name = "Cancel";
        this.m_btnCancel.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("m_btnCancel.RightToLeft")));
        this.m_btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("m_btnCancel.Size")));
        this.m_btnCancel.TabIndex = ((int)(resources.GetObject("m_btnCancel.TabIndex")));
        this.m_btnCancel.Text = resources.GetString("m_btnCancel.Text");
        this.m_btnCancel.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("m_btnCancel.TextAlign")));
        this.m_btnCancel.Visible = ((bool)(resources.GetObject("m_btnCancel.Visible")));
        // 
        // Win32Form2
        // 
        this.AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
        this.AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
        this.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("$this.Anchor")));
        this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
        this.AutoScroll = ((bool)(resources.GetObject("$this.AutoScroll")));
        this.AutoScrollMargin = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMargin")));
        this.AutoScrollMinSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMinSize")));
        this.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
        this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
        this.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_btnCancel,
                        this.m_btnOK,
                        this.m_btnBrowse,
                        this.m_lblBrowse,
                        this.m_lvApps,
                        this.m_lblChooseApp,
                        this.m_lblHelp});
        this.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("$this.Cursor")));
        this.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("$this.Dock")));
        this.Enabled = ((bool)(resources.GetObject("$this.Enabled")));
        this.Font = ((System.Drawing.Font)(resources.GetObject("$this.Font")));
        this.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("$this.ImeMode")));
        this.Location = ((System.Drawing.Point)(resources.GetObject("$this.Location")));
        this.MaximumSize = ((System.Drawing.Size)(resources.GetObject("$this.MaximumSize")));
        this.MinimumSize = ((System.Drawing.Size)(resources.GetObject("$this.MinimumSize")));
        this.Name = "Win32Form2";
        this.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("$this.RightToLeft")));
        this.StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
        this.Text = resources.GetString("$this.Text");
        this.Visible = ((bool)(resources.GetObject("$this.Visible")));
        this.ResumeLayout(false);
        this.MaximizeBox=false;
        this.MinimizeBox=false;
        this.Icon = null;
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.CancelButton = m_btnCancel;
        // Do some customization of controls...

        // Set up the image list for the listview
        m_ilIcons = new ImageList();

        m_lvApps.SmallImageList = m_ilIcons;
        m_lvApps.MultiSelect = false;
        m_lvApps.View = View.Details;
        
        m_btnOK.Enabled=false;
        m_lvApps.SelectedIndexChanged += new EventHandler(onAppChange);
        m_btnBrowse.Click += new EventHandler(onBrowse);
        m_lvApps.DoubleClick += new EventHandler(onListDoubleClick);


        // Put in the known Fusion apps
        StringCollection sc = Fusion.GetKnownFusionApps();
        if (sc != null)
        {
            for(int i=0; i<sc.Count; i++)
            {
                AddAppToList(sc[i], false);
            }
        }
       
    }// SetupControls

    void onAppChange(Object o, EventArgs e)
    {
        
        if (m_lvApps.SelectedIndices.Count > 0)
        {
            m_sFilename = m_lvApps.SelectedItems[0].SubItems[1].Text;
            m_btnOK.Enabled=true;
        }
        else
        {
            m_btnOK.Enabled=false;
            m_sFilename = null;
        }    

    }// onTextChange

    void CheckFile(Object o, CancelEventArgs e)
    {
        OpenFileDialog fd = (OpenFileDialog)o;
        try
        {
            String sFilename = fd.FileName;
            // Check to see if this is a http path....
            if (!File.Exists(sFilename))
            {
                MessageBox.Show(String.Format(CResourceStore.GetString("CChooseAppDialog:FileNotExist"), sFilename),
                                CResourceStore.GetString("CChooseAppDialog:FileNotExistTitle"),
                                MessageBoxButtons.OK,
                                MessageBoxIcon.Exclamation);
                e.Cancel = true;
            }
        }
        catch(Exception)
        {
            MessageBox.Show(CResourceStore.GetString("CChooseAppDialog:BadFile"),
                            CResourceStore.GetString("CChooseAppDialog:BadFileTitle"),
                            MessageBoxButtons.OK,
                            MessageBoxIcon.Exclamation);
            e.Cancel = true;
        }
    }// CheckFile

    void onBrowse(Object o, EventArgs e)
    {
        // Pop up a file dialog so the user can find an assembly
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("CGenApplications:FDTitle");
        fd.Filter = CResourceStore.GetString("CGenApplications:FDMask");
        fd.FileOk += new CancelEventHandler(CheckFile);
        fd.ValidateNames = false;
        
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
           
            String sAppFilename=fd.FileName;

            // If this is an executable or Dll, verify that it is managed
            int iLen = sAppFilename.Length;
            if (iLen > 6) 
            {
                // Check to see if they selected a config file
                String sExtension = sAppFilename.Substring(fd.FileName.Length-6).ToUpper(CultureInfo.InvariantCulture);

                if (sExtension.ToUpper(CultureInfo.InvariantCulture).Equals("CONFIG"))
                {
                    // They've selected a config file. Let's see if there is an assembly around there as well.
                    String sAssemName = sAppFilename.Substring(0, fd.FileName.Length-7);
                    if (File.Exists(sAssemName))
                        sAppFilename = sAssemName;
                }                          
            }
            m_sFilename = sAppFilename;
            this.DialogResult = DialogResult.OK;
        }
    }// onBrowse

    private void onListDoubleClick(Object o, EventArgs e)
    {
        this.DialogResult = DialogResult.OK;
    }// onListDoubleClick

    private void AddAppToList(String sFilename, bool fShouldSelect)
    {
        // Let's try and get the icon that explorer would use to display this file
        IntPtr hIcon = (IntPtr)(-1);
        SHFILEINFO finfo = new SHFILEINFO();
        uint nRetVal = 0;

        // Grab an icon for this application
        nRetVal = SHGetFileInfo(sFilename,0, out finfo, 20, SHGFI.ICON|SHGFI.SMALLICON);
        
        // If this function returned a zero, then we know it was a failure...
        // We'll just grab a default icon
        if (nRetVal == 0)
            hIcon = CResourceStore.GetHIcon("application_ico");  

        // We could get a valid icon from the shell
        else
            hIcon = finfo.hIcon;


        int nIndex = m_ilIcons.Images.Count;
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(hIcon));

        // If we had a shell icon, we should free it
        if (nRetVal != 0)
            DestroyIcon(hIcon);

        // Get the file description
        FileVersionInfo fvi = FileVersionInfo.GetVersionInfo(sFilename);

        String sDescription;
        if (fvi.FileDescription!= null && fvi.FileDescription.Length > 0 && !fvi.FileDescription.Equals(" "))
            sDescription = fvi.FileDescription;
        else
        {
            String[] sWords = sFilename.Split(new char[] {'\\'});
            sDescription = sWords[sWords.Length-1];
        }

        // Add this app to the list
        ListViewItem lvi = new ListViewItem(new String[] {sDescription, sFilename}, nIndex);

        lvi.Focused = fShouldSelect;
        lvi.Selected = fShouldSelect;
        m_lvApps.Focus();
        m_lvApps.Items.Add(lvi);
        // Make sure the item we just added is visible
        m_lvApps.EnsureVisible(m_lvApps.Items.Count-1);
    }// AddAppToList


    [DllImport("shell32.dll")]
    private static extern uint SHGetFileInfo(String pszPath, uint dwFileAttributes, out SHFILEINFO fi, uint cbFileInfo, uint uFlags);

    [DllImport("user32.dll")]
    internal static extern int DestroyIcon(IntPtr hIcon);

}// class CChooseAppDialog

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccodegroups.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CCodeGroups.cs
//
// This class presents the a code group node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

    using System;
    using System.Drawing;
    using System.Security;
    using System.Collections;
    using System.Security.Policy;
    using System.Runtime.InteropServices;

    class CCodeGroups : CSecurityNode
    {

     internal CCodeGroups(ref PolicyLevel pl, bool fReadOnly)
     {
         ReadOnly = fReadOnly;
         
         m_sGuid = "CA57E69B-C2E6-4791-9F03-D7C83D63C6DA";
         m_sHelpSection = "";
         m_hIcon = CResourceStore.GetHIcon("codegroups_ico");  
         m_oResults = new CGenericTaskPad(this, "CODEGROUPS_HTML");
         m_sDisplayName = CResourceStore.GetString("CCodeGroups:DisplayName");
         m_aPropSheetPage = null;

         m_pl = pl;
         
     }// CCodeGroups

    internal CSingleCodeGroup GetRootCodeGroupNode()
    {
        // We only have one child, and it should be the root codegroup
        int nCookie = Child[0];
        CSingleCodeGroup sgc = (CSingleCodeGroup)CNodeManager.GetNode(nCookie);

        return sgc;
    }// GetRootCodeGroupNode

    //-------------------------------------------------
    // CreateChildren
    //
    // This function will create all the codegroup nodes
    // for this policy level
    //-------------------------------------------------
    internal override void CreateChildren()
	{
        SuperCodeGroupArrayList al;

        Security.ListifyCodeGroup(m_pl.RootCodeGroup.Copy(), null, out al);

 
        // Now run through all the others and put them in too
        for(int i=0; i< al.Count; i++)
        {
            CNode parentNode;
            // If this is the root codegroup, it has a different parent    
            if (i == 0)
                parentNode = this;
            else
                parentNode = (CNode)(al[al[i].nParent].o);

            CodeGroup cg = al[i].cg;
            CNode childNode = new CSingleCodeGroup(ref m_pl, ref cg, ReadOnly);
            int iCookie = CNodeManager.AddNode(ref childNode);
            parentNode.AddChild(iCookie);
            
            // Now set this codegroup's node
            al[i].o = childNode;
        }
    }// CreateChildren
}// class CCodeGroups
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccomboboxpermissioncontrols.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Security;
using System.Security.Permissions;


internal class CComboBoxPermissionControls : CPermControls
{
    // Controls on the page
    private Label m_lblOptionDescription;
    protected ComboBox m_cbOptions;

    internal CComboBoxPermissionControls(IPermission perm, Object oParent) : base(perm, oParent)
    {
    }// CComboBoxPermissionControls


    internal override int InsertPropSheetPageControls(Control.ControlCollection cc)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CComboBoxPermissionControls));
        this.m_lblOptionDescription = new System.Windows.Forms.Label();
        this.m_ucOptions = new System.Windows.Forms.UserControl();
        this.m_radUnrestricted = new System.Windows.Forms.RadioButton();
        this.m_radGrantFollowingPermission = new System.Windows.Forms.RadioButton();
        this.m_cbOptions = new System.Windows.Forms.ComboBox();
        this.m_lblOptionDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblOptionDescription.Location")));
        this.m_lblOptionDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblOptionDescription.Size")));
        this.m_lblOptionDescription.TabIndex = ((int)(resources.GetObject("m_lblOptionDescription.TabIndex")));
        m_lblOptionDescription.Name = "OptionDescription";
        this.m_ucOptions.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lblOptionDescription,
                        this.m_cbOptions});
        this.m_ucOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_ucOptions.Location")));
        this.m_ucOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_ucOptions.Size")));
        this.m_ucOptions.TabIndex = ((int)(resources.GetObject("m_ucOptions.TabIndex")));
        m_ucOptions.Name = "Options";
        this.m_radUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_radUnrestricted.Location")));
        this.m_radUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_radUnrestricted.Size")));
        this.m_radUnrestricted.TabIndex = ((int)(resources.GetObject("m_radUnrestricted.TabIndex")));
        m_radUnrestricted.Name = "Unrestricted";
        this.m_radGrantFollowingPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_radGrantPermissions.Location")));
        this.m_radGrantFollowingPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_radGrantPermissions.Size")));
        this.m_radGrantFollowingPermission.TabIndex = ((int)(resources.GetObject("m_radGrantPermissions.TabIndex")));
        m_radGrantFollowingPermission.Name = "Restricted";
        this.m_cbOptions.DropDownWidth = 320;
        this.m_cbOptions.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_cbOptions.Location")));
        this.m_cbOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_cbOptions.Size")));
        this.m_cbOptions.TabIndex = ((int)(resources.GetObject("m_cbOptions.TabIndex")));
        m_cbOptions.Name = "ComboOptions";
        cc.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radGrantFollowingPermission,
                        this.m_ucOptions,
                        this.m_radUnrestricted
                        });
        
        // Fill in the data
        PutValuesinPage();

        // Hook up event handlers
        m_radGrantFollowingPermission.CheckedChanged += new EventHandler(onChangeUnRestrict);
        m_cbOptions.SelectedIndexChanged += new EventHandler(onChange);
        m_cbOptions.SelectedIndexChanged += new EventHandler(onOptionChange);
        m_radUnrestricted.CheckedChanged += new EventHandler(onChangeUnRestrict);
        

        return 1;
    }// InsertPropSheetPageControls


    protected virtual String GetTextForIndex(int nIndex)
    {
        return "";
    }// GetTextForIndex
    
    protected void onOptionChange(Object o, EventArgs e)
    {
        m_lblOptionDescription.Text = GetTextForIndex(m_cbOptions.SelectedIndex);
    }// onUsageChange

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange

}// class CComboBoxPermissionControls
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccommandhistory.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Collections;
using System.Collections.Specialized;
using System.Runtime.InteropServices;
using System.Web;

internal struct CommandHistory
{
    internal StringCollection scPathToNode;
    internal StringCollection scResultItem;
    internal int              iNumHits;
    internal int              iMenuCommand;
    internal String           sCommand;
}// struct CommandHistory

public class CCommandHistory
{
    static private ArrayList m_olCommands;
    static private ArrayList m_alConsumerCommands;
    static CCommandHistory()
    {
        // Read our stuff from the configuration
        try
        {
            m_olCommands = (ArrayList)CConfigStore.GetSetting("CommandHistory");
        }
        catch(Exception)
        {
            m_olCommands = null;
        }
        AgeCommands();
        // Make sure we can execute the commands this time around

        // This is bad. VerifyCommands needs the entire tree view 
        // to be completely filled in so it can run verifications on all
        // the 'most recently used commands' to make sure that all the nodes
        // are there that need to be.
        
        // However, this method is fired before the entire tree view is completely
        // built. So one would think we could wait until the tree view is done
        // before verifying commands and such, right?
        //
        // Unfortunately, we need to generate a web page that has the recently
        // used commands BEFORE the tree finishes. Such problems we have, don't
        // we?

        //VerifiyCommands();

        // Read the list of consumer commands.... will be useful for our lite container

        // Only try and do this if we're on a non-MMC host. If this fails, then
        // we should let the exception propgate up
        if (CNodeManager.Console is INonMMCHost)
            m_alConsumerCommands = (ArrayList)CConfigStore.GetSetting("ConsumerCommands");
        
    }// CCommandHistory

    static internal void Shutdown()
    {
        // Write our stuff to the configuration file
        WeedOutOldCommands();
        CConfigStore.SetSetting("CommandHistory", m_olCommands);
    }// Shutdown

    static internal bool IgnoreCommandForHistory(int iMenuCommand)
    {
        return (iMenuCommand >= 1000 || iMenuCommand == -1);
    }// IgnoreCommandForHistory

    static internal void CommandExecuted(CDO cdo, int iMenuCommand)
    {
        // See if we actually care about this command
        if (IgnoreCommandForHistory(iMenuCommand))
            return;

        // If this is a command on a result item, but we don't have an
        // index number, then we can't create a shortcut for this item
        if (cdo.Data != null && !(cdo.Data is int))
            return;
        

        // Pull the data we need out of the CDO interface
        CNode node = cdo.Node;
        int iResultNum = cdo.Data==null?-1:(int)cdo.Data;

        // Let's build the string of what the user actually did
        String sAction = TranslateMenuCommandToString(node, iResultNum, iMenuCommand);

        if (sAction == null)
            // We don't know how to represent this command as a string... let's bail
            return;
        
        // IncrementCommand will return false if we don't know about this command.
        if (!IncrementCommand(sAction))
        {
            // We need to add this command
            CommandHistory ch = new CommandHistory();
            ch.scPathToNode = BuildPathToNode(cdo.Node);
            ch.iNumHits = 3;
            ch.iMenuCommand = iMenuCommand;
            ch.sCommand = sAction;

            // Let's get the result item name
            ch.scResultItem = new StringCollection();
            if (iResultNum != -1)
            {
                // We're dealing with a result item here
                IColumnResultView crv = (IColumnResultView)node;
                int iNumCols = crv.getNumColumns();

                // iResultNum needs to be zero-based
                for(int i=0; i<iNumCols; i++)
                ch.scResultItem.Add(crv.getValues(iResultNum-1,i)); 
            }

            m_olCommands.Add(ch);
        }
    
    }// CommandExecuted

    static private void WeedOutOldCommands()
    {
        int iLen = m_olCommands.Count;
        for(int i=0; i<iLen; i++)
            if (((CommandHistory)m_olCommands[i]).iNumHits<=0)
            {
                m_olCommands.RemoveAt(i);
                i--;
                iLen--;
            }

    }// WeedOutOldCommands

    static private void VerifiyCommands()
    {
        int iLen = m_olCommands.Count;
        for(int i=0; i<iLen; i++)
            if (!ExecuteCommand((CommandHistory)m_olCommands[i], false))
            {
                m_olCommands.RemoveAt(i);
                i--;
                iLen--;
            }
    }// VerifyCommands


    static private void AgeCommands()
    {
        int iLen = m_olCommands.Count;
        for(int i=0; i<iLen; i++)
        {
            CommandHistory ch = (CommandHistory)m_olCommands[i];
            ch.iNumHits--;
            m_olCommands[i] = ch;
        }
    }// AgeCommands

    static private bool IncrementCommand(String sCommandName)
    {
        // Let's find this command in list
        int iLen = m_olCommands.Count;
        for(int i=0; i<iLen; i++)
            if (((CommandHistory)m_olCommands[i]).sCommand.Equals(sCommandName))
            {
                CommandHistory tmp = (CommandHistory)m_olCommands[i];
                tmp.iNumHits += 2;
                m_olCommands[i] = tmp;
                return true;
            }

        // We didn't find it
        return false;
    }// IncrementCommand

    static private StringCollection BuildPathToNode(CNode node)
    {
        StringCollection sc = new StringCollection();
        int iParentHScope = node.ParentHScopeItem;
       
        sc.Add(node.Name);
        while (iParentHScope != -1)
        {
            node = CNodeManager.GetNodeByHScope(iParentHScope); 
            iParentHScope = node.ParentHScopeItem;
            sc.Add(node.Name);
        }
        return sc;
    }// BuildPathToNode

    static private bool DoesNodeBelongToAnApplication(CNode node, out String sAppName)
    {
        int iParentHScope = node.ParentHScopeItem;
        node = null;
        while (iParentHScope != -1 && ! (node is CApplication))
        {
            node = CNodeManager.GetNodeByHScope(iParentHScope);
            iParentHScope = node.ParentHScopeItem;
        }

        sAppName = node.DisplayName;
        if (node is CApplication)
            return true;
        else
            return false;

    }// DoesNodeBelongToAnApplication

    static private String TranslateMenuCommandToString(CNode node, int iResultNum, int iMenuCommand)
    {
        switch (iMenuCommand)
        {
            case COMMANDS.ADD_GACASSEMBLY:
                    return CResourceStore.GetString("CCommandHistory:AddGacAssembly");
            case COMMANDS.ADD_APPLICATION:
                    return CResourceStore.GetString("CCommandHistory:AddApplication");
            case COMMANDS.NEW_PERMISSIONSET:
                    // We need to figure out what policy level this is for
                    // The node should be a CPermissionSet node
                    if (node is CPermissionSet)
                    {
                        // The parent should be a CSecurityPolicyNode....
                        CSecurityPolicy spn = CNodeManager.GetNodeByHScope(node.ParentHScopeItem) as CSecurityPolicy;
                        if (spn != null)
                            return String.Format(CResourceStore.GetString("CCommandHistory:NewPermissionSet"), spn.LocalizedPolicyName);
                    }
                    return null;
            case COMMANDS.NEW_SECURITYPOLICY:
                    return CResourceStore.GetString("CCommandHistory:CreateNewSecurityPolicy");
            case COMMANDS.OPEN_SECURITYPOLICY:
                    return CResourceStore.GetString("CCommandHistory:OpenSecurityPolicy");
            case COMMANDS.EVALUATE_ASSEMBLY:
                    return CResourceStore.GetString("CCommandHistory:EvaluatePolicy");
            case COMMANDS.ADJUST_SECURITYPOLICY:
                    return CResourceStore.GetString("CCommandHistory:AdjustPolicy");
            case COMMANDS.CREATE_MSI:
                    return CResourceStore.GetString("CCommandHistory:CreateDeploymentPackage");
            case COMMANDS.TRUST_ASSEMBLY:
                    return CResourceStore.GetString("CCommandHistory:TrustAssembly");
            case COMMANDS.FIX_APPLICATION:
                    // See if they're doing a generic fix or fixing a specific application
                    if (node is CApplication)
                        return String.Format(CResourceStore.GetString("CCommandHistory:FixApplication"), node.DisplayName);
                    else // This is just the generic fix application
                        return CResourceStore.GetString("CCommandHistory:FixGenApplication");
            case COMMANDS.RESET_POLICY:
                    // See if we're resetting all of them or just a specific one
                    if (node is CSecurityPolicy)
                        return String.Format(CResourceStore.GetString("CCommandHistory:ResetSinglePolicy"), ((CSecurityPolicy)node).LocalizedPolicyName);
                    else
                        // We're resetting all of them
                        return CResourceStore.GetString("CCommandHistory:ResetAllPolicy");
        }            
        return null;
    }// TranslateMenuCommandToString

    static internal void FireOffCommand(int iCommandNum)
    {
        // Our CommandNum is 100 more than the index of our item in the ArrayList
        ExecuteCommand((CommandHistory)m_olCommands[iCommandNum-100], true);

        // When we execute this command, its "Number of times command has executed" counter
        // will increase automagically by 2. However, we really scored here if the user was
        // able to use one of our shortcut actions, so let's increase the count by an additional
        // 1
        CommandHistory tmp = (CommandHistory)m_olCommands[iCommandNum-100];
        tmp.iNumHits++;
        m_olCommands[iCommandNum-100] = tmp;
    }// FireOffCommand(int)


    static private bool ExecuteCommand(CommandHistory chCommand, bool fActuallyExecute)
    {
       // Ok, let's run through the nodes until we find the node we want
       CNode node = CNodeManager.GetNode(CNodeManager.RootNodeCookie);
       int iTreeLevel = chCommand.scPathToNode.Count-1;
       while(node != null && iTreeLevel >= 0)
       {
            // Expand this node
            node = GetChild(node, chCommand.scPathToNode[iTreeLevel]);
            iTreeLevel--;            
       }

       // Ok, now let's see if we were just trying to figure out if this command existed...
       if (!fActuallyExecute)
       {
            // Yes, this command will work
            if (node != null)
                return true;
            else
                return false;
       }


       if (node != null)
       {
           int iResultNum = GetResultNum(node, chCommand.scResultItem);

           // We have the node. Let's do something to it
           // If it was a property page, let's fire that off
           if (chCommand.iMenuCommand == -1)
           {
                // See if we're just opening up the node's property page
                if (iResultNum == -1)
                    node.OpenMyPropertyPage();
                else
                {
                    CDO cdo = new CDO(node);
                    // Make sure the result num is 1-based
                    cdo.Data = iResultNum + 1;
                    node.OpenMyResultPropertyPage(node.DisplayName, cdo);
                }
           }
           // It was some sort of menu command. Let's fire that off
           else
           {   
                if (iResultNum == -1)
                    node.MenuCommand(chCommand.iMenuCommand);
                else // This is a result item's command
                    // Make sure we make the result number 1-based
                    node.MenuCommand(chCommand.iMenuCommand, iResultNum+1);
           }


           // Last but not least, let's go visit that node.
           CNodeManager.Console.SelectScopeItem(node.HScopeItem);

           
           return true;
       }
       return false;
    }// ExecuteCommand(int, bool)

    static private int GetResultNum(CNode node, StringCollection scResults)
    {
        // See if we can bail on this really quickly
        if (scResults.Count == 0)
            return -1;

        // Grab the columnresultview interface
        IColumnResultView crv = (IColumnResultView)node;

        int iNumRows = crv.getNumRows();
        // Let's start looking through the result items until we find the one we want
        for(int i=0; i<iNumRows; i++)
        {
            // We have a good chance at a match
            int j;
            for(j=0; j<scResults.Count; j++)
            {   
                String sResultString = crv.getValues(i,j);
                if (!scResults[j].Equals(sResultString))
                    break;
            }
            if (j == scResults.Count)
                // We found our match!
                return i;
        }
        // We couldn't find the item.
        return -1;
    }// GetResultNum



    static private CNode GetChild(CNode node, String sNodeToOpen)
    {
        if (node.Name.Equals(sNodeToOpen))
            return node;
            
        CNode nChild = node.FindChild(sNodeToOpen);
        // If we couldn't find the child, then that means, this node probably hasn't
        // added it's children yet. We'll do that now
        if (nChild == null)
        {
            CNodeManager.CNamespace.Expand(node.HScopeItem);
            nChild = node.FindChild(sNodeToOpen);
        }

        return nChild;
    }// GetChild
 
    static internal String GetFavoriteCommandsHTML()
    {
        int iNumCommands=0;

        String sHTML = "";

        if (m_olCommands.Count > 0)
            sHTML += "<HR><BR>";
            
        for(int i=0; i<m_olCommands.Count; i++)
        {
            // The user needs to do something a couple times before we consider it
            // a common command
            if (((CommandHistory)m_olCommands[i]).iNumHits > 4)
            {
                sHTML += "<p style=\"margin-top:5; margin-bottom:0\"><A HREF=\"1\" OnClick=\"NotifyMMC(" + (i+100).ToString() + "); return false\"></p>";

                // First, escape this string so nothing funky can get in it
                String sCommand = HttpUtility.HtmlEncode(((CommandHistory)m_olCommands[i]).sCommand);

                // We only want the first word to be hyper-linked
                String[] sCommands = sCommand.Split(new char[] {' '});
                sHTML += sCommands[0] + "</A> ";
                sHTML += String.Join(" ", sCommands, 1, sCommands.Length-1) + "<BR><BR>";
                iNumCommands++;
            }
        }

        // Only return something if we added a command
        if (iNumCommands > 0)
            return sHTML;
        else
            return "";
    }// GetFavoriteCommands

    static public void FireOffConsumerCommand(int nIndex)
    {
        ExecuteCommand((CommandHistory)m_alConsumerCommands[nIndex], true);
    }// FireOffConsumerCommand
    

    static public String[] GetConsumerCommandsArray()
    {
        ArrayList alCommands = new ArrayList();
            
        for(int i=0; i<m_alConsumerCommands.Count; i++)
            alCommands.Add(((CommandHistory)m_alConsumerCommands[i]).sCommand);

        String[] sCommands = new String[alCommands.Count];
        for(int i=0; i< alCommands.Count; i++)
            sCommands[i] = (String)alCommands[i];
            

        return sCommands;
    }// GetAllFavoriteCommandsArray
}// class CCommandHistory
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cconfigassemgeneralprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CConfigAssemGeneralProp.cs
//
// This displays the property page for an assembly that is found in
// the list view (the right hand side) or the Version Policy (Configured 
// Assembles) node. It display general information about an assembly,
// including the Name and  Public Key
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;

internal class CConfigAssemGeneralProp : CPropPage
{
    // Controls on the page
    private CheckBox m_chkPubPolicy;
    private Label m_lblPublicKeyToken;
    private TextBox m_txtPublicKeyToken;
    private Label m_lblPublisherPolicyHelp;
    private TextBox m_txtAssemName;
    private Label m_lblAssemName;
    private Label m_lblHelp;

    private BindingRedirInfo    m_bri;
    private String              m_sConfigFile;

    //-------------------------------------------------
    // CConfigAssemGeneralProp - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CConfigAssemGeneralProp(BindingRedirInfo bri)
    {
        m_bri = bri;
        m_sTitle = CResourceStore.GetString("CConfigAssemGeneralProp:PageTitle");
    }// CConfigAssemGeneralProp

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CConfigAssemGeneralProp));
        this.m_chkPubPolicy = new System.Windows.Forms.CheckBox();
        this.m_lblPublicKeyToken = new System.Windows.Forms.Label();
        this.m_txtPublicKeyToken = new System.Windows.Forms.TextBox();
        this.m_lblPublisherPolicyHelp = new System.Windows.Forms.Label();
        this.m_txtAssemName = new System.Windows.Forms.TextBox();
        this.m_lblAssemName = new System.Windows.Forms.Label();
        m_lblHelp = new Label();
        this.m_chkPubPolicy.Location = ((System.Drawing.Point)(resources.GetObject("m_chkPubPolicy.Location")));
        this.m_chkPubPolicy.Size = ((System.Drawing.Size)(resources.GetObject("m_chkPubPolicy.Size")));
        this.m_chkPubPolicy.TabIndex = ((int)(resources.GetObject("m_chkPubPolicy.TabIndex")));
        this.m_chkPubPolicy.Text = resources.GetString("m_chkPubPolicy.Text");
        m_chkPubPolicy.Name = "PublisherPolicy";
        this.m_lblPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublicKeyToken.Location")));
        this.m_lblPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublicKeyToken.Size")));
        this.m_lblPublicKeyToken.TabIndex = ((int)(resources.GetObject("m_lblPublicKeyToken.TabIndex")));
        this.m_lblPublicKeyToken.Text = resources.GetString("m_lblPublicKeyToken.Text");
        m_lblPublicKeyToken.Name = "PublicKeyTokenLabel";
        this.m_txtPublicKeyToken.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPublicKeyToken.Location")));
        this.m_txtPublicKeyToken.ReadOnly = true;
        this.m_txtPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPublicKeyToken.Size")));
        this.m_txtPublicKeyToken.TabStop = false;
        m_txtPublicKeyToken.Name = "PublicKeyToken";
        this.m_lblPublisherPolicyHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublisherPolicyHelp.Location")));
        this.m_lblPublisherPolicyHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublisherPolicyHelp.Size")));
        this.m_lblPublisherPolicyHelp.TabIndex = ((int)(resources.GetObject("m_lblPublisherPolicyHelp.TabIndex")));
        this.m_lblPublisherPolicyHelp.Text = resources.GetString("m_lblPublisherPolicyHelp.Text");
        m_lblPublisherPolicyHelp.Name = "PublisherPolicyHelp";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublisherPolicy.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublisherPolicy.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblPublisherPolicy.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblPublisherPolicy.Text");
        m_lblHelp.Name = "Help";
        this.m_txtAssemName.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtAssemName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtAssemName.Location")));
        this.m_txtAssemName.ReadOnly = true;
        this.m_txtAssemName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtAssemName.Size")));
        this.m_txtAssemName.TabStop = false;
        m_txtAssemName.Name = "AssemblyName";
        this.m_lblAssemName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAssemName.Location")));
        this.m_lblAssemName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAssemName.Size")));
        this.m_lblAssemName.Text = resources.GetString("m_lblAssemName.Text");
        m_lblAssemName.Name = "AssemblyNameLabel";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_chkPubPolicy,
                        this.m_lblPublisherPolicyHelp,
                        this.m_txtPublicKeyToken,
                        this.m_txtAssemName,
                        this.m_lblPublicKeyToken,
                        this.m_lblAssemName,
                        m_lblHelp});

        // Fill in the data
        PutValuesinPage();
        m_chkPubPolicy.CheckStateChanged += new EventHandler(onChange);
        m_txtAssemName.Select(0, 0);
        return 1;
    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // PutValuesinPage
    //
    // This function put data onto the property page
    //-------------------------------------------------
    private void PutValuesinPage()
    {
        // Get info that we'll need from the node
        CNode node = CNodeManager.GetNode(m_iCookie);
        // This should be ok now, but if we need this functionality
        // off of different nodes.....
        CVersionPolicy vp = (CVersionPolicy)node;



        m_txtAssemName.Text = m_bri.Name;
        m_txtPublicKeyToken.Text = m_bri.PublicKeyToken;
        
        // Figure out the current Publisher Policy Setting

        String sGetSettingString = "PublisherPolicyFor" + m_bri.Name + "," + m_bri.PublicKeyToken;

        // If we are getting this from an App config file, let's add that info
        m_sConfigFile = vp.ConfigFile;
        
        if (m_sConfigFile != null)
        {   
            sGetSettingString += "," + m_sConfigFile;
            bool fUsePubPolicy= (bool)CConfigStore.GetSetting(sGetSettingString);
            m_chkPubPolicy.Checked = fUsePubPolicy;
        }
        // If this isn't an app config file, we don't want to show the
        // 'Apply Publisher Policy' Checkbox or description
        else 
        {
            m_chkPubPolicy.Visible=false;
            m_lblPublisherPolicyHelp.Visible = false;
        }
    }// PutValuesinPage

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange

    internal override bool ApplyData()
    {
        
        if (m_sConfigFile != null)
        {
            String sSetSettingString = "PublisherPolicyFor" + m_bri.Name + "," + m_bri.PublicKeyToken;
            sSetSettingString+= "," + m_sConfigFile;
            return CConfigStore.SetSetting(sSetSettingString, m_chkPubPolicy.Checked);
        }
        return true;
    }// ApplyData
}// class CConfigAssemGeneralProp
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cconfigassemwiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CConfigAssemWiz1.cs
//
// This implements the wizard page that comes up when a user
// chooses "Add..." from the configured assemblies node.
//
// It allows a user to pick an assembly to configure, either by
// choosing the assembly from a file dialog, or entering in
// assembly information in a couple text boxes
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;


internal class CConfigAssemWiz1 : CWizardPage
{
    // Controls on the page

    private GroupBox m_gbAssemInfo;
    private TextBox m_txtName;
    private Button m_btnChooseAssem;
    private RadioButton m_radManEnter;
    private RadioButton m_radChooseDepends;
    private TextBox m_txtPublicKeyToken;
    private Label m_lblName;
    private Label m_lblPublicKeyToken;
    private RadioButton m_radChooseShared;

    // A node that will tell us what our dependencies are
    CApplicationDepends m_appDepends;

    //-------------------------------------------------
    // CConfigAssemWiz1 - Constructor
    //
    // Initializes some variables.
    // sf is a delegate that, when called, will turn on
    // the "Finish" button on the wizard
    //-------------------------------------------------
    internal CConfigAssemWiz1(CApplicationDepends appDepends)
    {
        m_sHeaderTitle = CResourceStore.GetString("CConfigAssemWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CConfigAssemWiz1:HeaderSubTitle");
        m_sTitle = CResourceStore.GetString("CConfigAssemWiz1:Title");
        m_appDepends = appDepends;
    }// CConfigAssemWiz1
  
    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CConfigAssemWiz1));
        this.m_gbAssemInfo = new System.Windows.Forms.GroupBox();
        this.m_txtName = new System.Windows.Forms.TextBox();
        this.m_btnChooseAssem = new System.Windows.Forms.Button();
        this.m_radManEnter = new System.Windows.Forms.RadioButton();
        this.m_radChooseDepends = new System.Windows.Forms.RadioButton();
        this.m_txtPublicKeyToken = new System.Windows.Forms.TextBox();
        this.m_lblName = new System.Windows.Forms.Label();
        this.m_lblPublicKeyToken = new System.Windows.Forms.Label();
        this.m_radChooseShared = new System.Windows.Forms.RadioButton();
        this.m_gbAssemInfo.Controls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblName,
		                this.m_txtName,
                        this.m_lblPublicKeyToken,
                        this.m_txtPublicKeyToken}); 
        this.m_gbAssemInfo.Location = ((System.Drawing.Point)(resources.GetObject("m_gbAssemInfo.Location")));
        this.m_gbAssemInfo.Size = ((System.Drawing.Size)(resources.GetObject("m_gbAssemInfo.Size")));
        this.m_gbAssemInfo.Text = resources.GetString("m_gbAssemInfo.Text");
        m_gbAssemInfo.Name = "GBAssemInfo";
        this.m_txtName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtName.Location")));
        this.m_txtName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtName.Size")));
        this.m_txtName.TabIndex = 4;
        m_txtName.Name = "Name";
        this.m_btnChooseAssem.Location = ((System.Drawing.Point)(resources.GetObject("m_btnChooseAssem.Location")));
        this.m_btnChooseAssem.Size = ((System.Drawing.Size)(resources.GetObject("m_btnChooseAssem.Size")));
        this.m_btnChooseAssem.TabIndex = 2;
        this.m_btnChooseAssem.Text = resources.GetString("m_btnChooseAssem.Text");
        m_btnChooseAssem.Name = "ChooseAssembly";
        this.m_radManEnter.Location = ((System.Drawing.Point)(resources.GetObject("m_radManEnter.Location")));
        this.m_radManEnter.Size = ((System.Drawing.Size)(resources.GetObject("m_radManEnter.Size")));
        this.m_radManEnter.TabIndex = 3;
        this.m_radManEnter.Text = resources.GetString("m_radManEnter.Text");
        m_radManEnter.Name = "EnterAssem";
        this.m_radChooseDepends.Location = ((System.Drawing.Point)(resources.GetObject("m_radChooseDepends.Location")));
        this.m_radChooseDepends.Size = ((System.Drawing.Size)(resources.GetObject("m_radChooseDepends.Size")));
        this.m_radChooseDepends.TabIndex = 1;
        this.m_radChooseDepends.Text = resources.GetString("m_radChooseDepends.Text");
        m_radChooseDepends.Name = "DependAssem";
        this.m_txtPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_txtPublicKeyToken.Location")));
        this.m_txtPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_txtPublicKeyToken.Size")));
        this.m_txtPublicKeyToken.TabIndex = 5;
        m_txtPublicKeyToken.Name = "PublicKeyToken";
        this.m_lblName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblName.Location")));
        this.m_lblName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblName.Size")));
        this.m_lblName.TabIndex = ((int)(resources.GetObject("m_lblName.TabIndex")));
        this.m_lblName.Text = resources.GetString("m_lblName.Text");
        m_lblName.Name = "NameLabel";
        this.m_lblPublicKeyToken.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPublicKeyToken.Location")));
        this.m_lblPublicKeyToken.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPublicKeyToken.Size")));
        this.m_lblPublicKeyToken.TabIndex = ((int)(resources.GetObject("m_lblPublicKeyToken.TabIndex")));
        this.m_lblPublicKeyToken.Text = resources.GetString("m_lblPublicKeyToken.Text");
        m_lblPublicKeyToken.Name = "PublicKeyTokenLabel";
        this.m_radChooseShared.Location = ((System.Drawing.Point)(resources.GetObject("m_radChooseShared.Location")));
        this.m_radChooseShared.Size = ((System.Drawing.Size)(resources.GetObject("m_radChooseShared.Size")));
        this.m_radChooseShared.TabIndex = 0;
        this.m_radChooseShared.Text = resources.GetString("m_radChooseShared.Text");
        m_radChooseShared.Name = "SharedAssem";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radChooseShared,
                        this.m_radChooseDepends,
                        this.m_radManEnter,
                        this.m_btnChooseAssem,
                        this.m_gbAssemInfo
                        });

        // Hook up some event handlers
        m_radChooseShared.CheckedChanged +=new EventHandler(onChange);
        m_radChooseDepends.CheckedChanged +=new EventHandler(onChange);
        m_radManEnter.CheckedChanged +=new EventHandler(onChange);
        m_btnChooseAssem.Click += new EventHandler(onChooseAssemClick);
        m_txtName.TextChanged+= new EventHandler(onTextChange);

        // Let's set up the default values
        m_radChooseShared.Checked=true;
        m_txtName.Enabled=false;
        m_txtPublicKeyToken.Enabled=false;

        // See if we should show the 'dependent assemblies' option
        if (m_appDepends == null || !m_appDepends.HaveDepends)
            m_radChooseDepends.Visible = false;
        
        
        return 1;
    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // onChange
    //
    // This event is fired when the value of the radio
    // buttons changes. If the user wants to choose from
    // the global assembly cache, then they shouldn't be
    // allowed to type in the text fields, so we disable them
    //-------------------------------------------------
    void onChange(Object o, EventArgs e)
    {
        bool fEnable;
    
        if (m_radChooseShared.Checked || m_radChooseDepends.Checked)
            fEnable=false;
        else
            fEnable=true;

        m_txtName.Enabled=fEnable;
        m_txtPublicKeyToken.Enabled=fEnable;
        m_btnChooseAssem.Enabled=!fEnable;
    }// onChange

    //-------------------------------------------------
    // onTextChange
    //
    // This event fires when the contents of either text
    // box change. We need to have a value in the name
    // box to have the potiential of valid assembly information,
    // so we don't enable the finish button until we have
    // values for both.
    //-------------------------------------------------
    void onTextChange(Object o, EventArgs e)
    {
        CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);
    
        // See if we should turn on the Finish button
        if (m_txtName.Text.Length > 0)
            wiz.TurnOnFinish(true);
        // Nope, we want the Finish button off
        else
            wiz.TurnOnFinish(false);
    }// onTextChange

    //-------------------------------------------------
    // onChooseAssemClick
    //
    // This event fires when the user clicks the "Choose
    // Assembly" button. This will bring up a dialog with
    // a list of all the assemblies in the GAC, and allow
    // the user to select one of them.
    //-------------------------------------------------
    void onChooseAssemClick(Object o, EventArgs e)
    {
        CAssemblyDialog ad;

        // Choose which dialog to show
        if (m_radChooseShared.Checked)
            ad = new CFusionDialog();
        else
            ad = new CDependAssembliesDialog(m_appDepends);
            
        System.Windows.Forms.DialogResult dr = ad.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            // Let's put the info we get into text boxes
            m_txtName.Text = ad.Assem.Name;
            m_txtPublicKeyToken.Text = ad.Assem.PublicKeyToken;
            // Turn on the Finish button
            ((CWizard)CNodeManager.GetNode(m_iCookie)).TurnOnFinish(true);
        }
    }// onChooseAssemClick

    //-------------------------------------------------
    // Assembly - Property
    //
    // This allows access to the currently selected assembly
    //-------------------------------------------------
    internal BindingRedirInfo Assembly
    {
        get
        {
            BindingRedirInfo bri = new BindingRedirInfo();
            bri.Name = m_txtName.Text;
            bri.PublicKeyToken = m_txtPublicKeyToken.Text;

            return bri;
        }
    }// Assembly
}// class CConfigAssemWiz1
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cconfigassemwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;

class CConfigAssemWizard: CWizard
{
    BindingRedirInfo m_bri;
    internal CConfigAssemWizard(CApplicationDepends appDepends)
    {
        m_sName="Configure Assembly Wizard";
        m_sDisplayName = "Assembly Wizard";

        m_aPropSheetPage = new CPropPage[] {new CConfigAssemWiz1(appDepends)};
        m_bri = null;
        
    }// CConfigAssemWizard

    protected override int WizSetActive(IntPtr hwnd)
    {
        TurnOnFinish(false);
        return base.WizSetActive(hwnd);
    }// WizSetActive

    protected override int WizFinish()
    {
        m_bri= ((CConfigAssemWiz1)m_aPropSheetPage[0]).Assembly;
        return 0;
    }// WizFinish

    internal BindingRedirInfo NewAssembly
    {
        get{return m_bri;}
    }// NewAssembly

        
}// class CConfigAssemWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccomputernode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CComputerNode.cs
//
// This class represents the root node of the snapin
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.IO;

class CComputerNode : CNode
{
    internal CComputerNode()
    {
        m_sGuid = "B114511B-F0C4-469b-9928-674781D1B12B";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("mycomputer_ico");  

        m_oResults = new CNetTaskPad(this);
        DisplayName = CResourceStore.GetString("CComputerNode:DisplayName");
        Name="My Computer";
        m_aPropSheetPage = null;
    }// CComputerNodeNode

    // Ok, this looks funky... what's going on?
    //
    // MMC 1.2 has this weird bug. When starting up a snapin using a .msc file,
    // IE doesn't get created right and always shows a 'Page cannot be displayed'
    // page for a split second before our 'good' HTML page is displayed. That sucks.
    //
    // So what we do is we tell this node that it has a listview. That prevents MMC
    // from showing the IE 'Page cannot be displayed' page. So, when MMC starts, it 
    // displays an empty screen because we haven't populated any items in the listview
    // yet.
    //
    // Then, when MMC asks us to populate the listview, we inform MMC that we now
    // have a HTML page to show. MMC then displays the page correctly.

/*  Don't do this. This exposes a race condition in MMC which will cause the snapin to not
     start up.
    

    public override int getNumRows()
    {
        m_oResults = new CNetTaskPad(this);
        RefreshResultView();
        return -1;
    }// getNumRows
*/
    internal override bool HavePropertyPages
    {
        get
        {
                return true;
        }
    }// HavePropertyPages


    protected override void CreatePropertyPages()
    {
        m_aPropSheetPage = new CPropPage[] { new CGeneralMachineProps()};
    }// CreatePropertyPages

    //-------------------------------------------------
    // CreateChildren
    //
    // This function creates the node's children, registers
    // the nodes with the node manager, and places the node's
    // cookies in it's child array
    //-------------------------------------------------
    internal override void CreateChildren()
	{
        CNode   node=null;
        int     iCookie=0;

        bool fNonMMC = CNodeManager.Console is INonMMCHost;


        // Some of these nodes we shouldn't add if we're not MMC

        
        // This node is only valid on the local machine
        if (Data == 1 && !fNonMMC)
        {
	        node = new CSharedAssemblies();
            iCookie = CNodeManager.AddNode(ref node);
            AddChild(iCookie);
        }

        if (!fNonMMC)
        {
            // Now add a Version Policy node
            node = new CVersionPolicy();
            iCookie = CNodeManager.AddNode(ref node);
            AddChild(iCookie);
        
            // Now add a Subscribed services node
            node = new CRemoting();
            iCookie = CNodeManager.AddNode(ref node);
            AddChild(iCookie);
        }
        // Add a Security policy node
        node = new CGenSecurity();
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);

        // And add an Applications Node
        node = new CGenApplications();
        iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);
        

    }// CreateChildren
}// class CComputerNode
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccreatedeploymentpackagewiz2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security;

class CCreateDeploymentPackageWiz2 : CWizardPage
{
    // Controls on the page
    Label m_lblHelpText;
    CheckBox m_chkSavePolicy;
       	
    internal CCreateDeploymentPackageWiz2()
    {
        m_sTitle=CResourceStore.GetString("CCreateDeploymentPackageWiz2:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz2:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz2:HeaderSubTitle");
    }// CCreateDeploymentPackageWiz2

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CCreateDeploymentPackageWiz2));
        this.m_lblHelpText = new System.Windows.Forms.Label();
        this.m_chkSavePolicy = new System.Windows.Forms.CheckBox();
        this.m_lblHelpText.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelpText.Location")));
        this.m_lblHelpText.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelpText.Size")));
        this.m_lblHelpText.TabIndex = ((int)(resources.GetObject("m_lblHelpText.TabIndex")));
        this.m_lblHelpText.Text = resources.GetString("m_lblHelpText.Text");
        m_lblHelpText.Name = "Help";
        this.m_chkSavePolicy.Location = ((System.Drawing.Point)(resources.GetObject("m_chkSavePolicy.Location")));
        this.m_chkSavePolicy.Size = ((System.Drawing.Size)(resources.GetObject("m_chkSavePolicy.Size")));
        this.m_chkSavePolicy.TabIndex = ((int)(resources.GetObject("m_chkSavePolicy.TabIndex")));
        this.m_chkSavePolicy.Text = resources.GetString("m_chkSavePolicy.Text");
        m_chkSavePolicy.Name = "SavePolicy";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_chkSavePolicy,
                        this.m_lblHelpText});

        // The checkbox should be off by default
        m_chkSavePolicy.Checked = false;
        m_chkSavePolicy.Click += new EventHandler(onSavePolicyClick);
        return 1;
    }// InsertPropSheetPageControls

    void onSavePolicyClick(Object o, EventArgs e)
    {
        CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);
   
        if (m_chkSavePolicy.Checked)
            wiz.TurnOnNext(true);
        else
            wiz.TurnOnNext(false);
    }// onSavePolicyClick


}// class CCreateDeploymentPackageWiz2
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccomponent.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CComponent.cs
//
// This implements the IComponent, IExtendContextMenu and 
// IExtendControlbar, and IExtendTaskPad MMC interfaces
//-------------------------------------------------------------
using System;
using System.Collections;
using System.Runtime.InteropServices;


namespace Microsoft.CLRAdmin
{
internal class CComponent: IComponent, IExtendContextMenu, IExtendControlbar, IExtendTaskPad, IExtendPropertySheet2
{
	
	private IConsole2     m_ucsole;        // Holds the MMC Console interface
	private IDisplayHelp  m_DisplayHelp;    // Holds the MMC IDisplayHelp interface
	private IToolbar      m_Toolbar;        // Holds the MMC IToolbar interface
	private IntPtr        m_hToolbarBMP;    // Holds the bitmap for the toolbar
    private CData         m_Data;           // Holds the ComponentData

	//-------------------------------------------------
    // CComponent
    //
    // The constructor takes in a reference to the nodes
    // used in the snapin and saves it
    //-------------------------------------------------
    internal CComponent(CData data)
    {
        m_hToolbarBMP = (IntPtr)0;
        m_Data=data;
    }// CComponent

	//-------------------------------------------------
    // Initialize
    //
    // This is where we'll get the interfaces for
    // IConsole2 and IDisplayHelp 
    //-------------------------------------------------
    public void Initialize(Object pConsole)
    { 
        // Let's query for the interfaces needed
        m_ucsole = (IConsole2)pConsole;
        m_DisplayHelp = (IDisplayHelp)pConsole;
        CNodeManager.CConsole = m_ucsole;
    }// Initialize
    
    //-------------------------------------------------
    // Notify
    //
    // This is where most of the interesting stuff happens.
    // Whenever MMC needs something from the snapin, it will
    // send a message to Notify, and notify is responsible 
    // to take care (or delegate) whatever MMC wants
    //-------------------------------------------------
    public int Notify(IntPtr lpDataObject, uint aevent, IntPtr arg, IntPtr param)
    {
        // We don't handle any of the special data objects here
        if (lpDataObject == (IntPtr)DOBJ.CUSTOMOCX || lpDataObject == (IntPtr)DOBJ.CUSTOMWEB)
            return HRESULT.S_FALSE;

        IDataObject ido = null;
        
        if (lpDataObject != (IntPtr)0)
            ido = (IDataObject)Marshal.GetObjectForIUnknown(lpDataObject);
        
        CDO Data;    // This will hold the object MMC wants action performed on

        // lpDataObject is just a CDO... we're going to obtain the CDO interface.
        // if lpDataObject is null, then there needs to be action performed on the root
        // node.
        if (ido != null)
            Data = (CDO)ido;
        else
        {
            CNode   node = CNodeManager.GetNode(CNodeManager.RootNodeCookie);
            Data = new CDO(node);
        }

        switch(aevent)
        {
            // The user clicked the 'forward' or 'back' button on the MMC browser.
            // We need to sync up our node to the new result view
            case MMCN.RESTORE_VIEW:
                return Data.Node.onRestoreView((MMC_RESTORE_VIEW)Marshal.PtrToStructure(arg, typeof(MMC_RESTORE_VIEW)), param);
        

            // We're being asked if we will accept an item to be pasted
            // (Used here to tell MMC if this node is a valid drag-and-drop
            // location)
            case MMCN.QUERY_PASTE:
            // See if it's asking about result items or scope items
                return Data.Node.doAcceptPaste((IDataObject)Marshal.GetObjectForIUnknown((IntPtr)arg));
            
            // We're being given an item to paste. (Used here to tell MMC that
            // something is being dropped here from a drag and drop operation)
            case MMCN.PASTE:
                return Data.Node.Paste((IDataObject)Marshal.GetObjectForIUnknown((IntPtr)arg));
                
            // The selected item needs to show something in the result pane
            case MMCN.SHOW:
                // If we're selecting this item
                if ((uint)arg == 1)
                    CNodeManager.SelectedNode = Data.Node;
                Data.Node.onShow(m_ucsole, arg, param);
                break;

            // If an item is selected, we should set flags for verbs available
            // for the item (from the dropdown menu)
            case MMCN.SELECT:

                bool fEnablePropPages=false;
                // See if this is selected from the result view
                if (((uint)arg & 0x0000FFFF) == 0)
                {
                    // See if we selected it or de-selected it
                    if (((uint)arg & 0xFFFF0000) == 0)
                        Data.Node.ResultItemUnSelected(m_ucsole, Data.Data);
                    else
                        Data.Node.ResultItemSelected(m_ucsole, Data.Data);


                    // Let's see if this result item has a property page
                    if(Data.Node.DoesResultHavePropertyPage(Data.Data))
                        fEnablePropPages=true;
                }
                // This item was selected in the scope view
                else
                    if (Data.Node.HavePropertyPages)
                        fEnablePropPages=true;
                

                IConsoleVerb icv;       
                // Get the IConsoleVerb interface from MMC
                m_ucsole.QueryConsoleVerb(out icv);

                // See if we need to enable then property sheets item on the popup menu
                if (fEnablePropPages)
                    icv.SetVerbState(MMC_VERB.PROPERTIES, MMC_BUTTON_STATE.ENABLED, 1);
                else
                    icv.SetVerbState(MMC_VERB.PROPERTIES, MMC_BUTTON_STATE.ENABLED, 0);


                // We'll only call this onSelect method if the user selected the 
                // scope item
                if (((uint)arg & 0x0000FFFF) > 0 && ((uint)arg & 0xFFFF0000) > 0)
                {
                    icv.SetVerbState(MMC_VERB.PASTE, MMC_BUTTON_STATE.ENABLED, 1);
                    Data.Node.onSelect(icv);
                }
                break;

            // This is to add images for the result pane
            case MMCN.ADD_IMAGES:
                // arg actually contains the IImageList interface. We need to tell
                // C# that it is a Object and not a integer.

                IImageList il = (IImageList)Marshal.GetObjectForIUnknown((IntPtr)arg);

                // param contains the HScopeItem. Let's get the node it represents
                CNode nLuckyGuy = CNodeManager.GetNodeByHScope((int)param);

                il.ImageListSetIcon(nLuckyGuy.IconHandle, CResourceStore.GetIconCookie(nLuckyGuy.IconHandle));

                // Now add all the children images
                CNode nChild = null;
                for(int i=0; i<nLuckyGuy.NumChildren; i++)
                {
                    nChild = CNodeManager.GetNode(nLuckyGuy.Child[i]);
                    il.ImageListSetIcon(nChild.IconHandle, CResourceStore.GetIconCookie(nChild.IconHandle));
                }

                // Now add any images that the node might have for it's listview
                if (nLuckyGuy.m_oResults != null && nLuckyGuy.m_oResults is IColumnResultView)
                    ((IColumnResultView)nLuckyGuy.m_oResults).AddImages(ref il);
                  
                break;  

            // The user double clicked on something
            case MMCN.DBLCLICK:
                return Data.Node.onDoubleClick(Data.Data);

            case MMCN.DELETE:
                return Data.Node.onDelete(Data.Data);

            default:
                // We don't support the Notification message we got
                return HRESULT.S_FALSE;
        }
        return HRESULT.S_OK;
    }// Notify

    //-------------------------------------------------
    // Destroy
    //
    // This cleans up whatever needs to be cleaned up.
    //-------------------------------------------------
    public void Destroy(int i)
    {
        // We need to prevent anything from modifying the clipboard
        // on shutdown, otherwise MMC will try and update the paste button
        // and end up AVing since it . Hacky, yes, I know.
        OpenClipboard((IntPtr)0);
    }// Destroy
    
    //-------------------------------------------------
    // QueryDataObject
    //
    // When MMC wants a data object for a specific cookie,
    // this function will be called.
    //-------------------------------------------------
    public void QueryDataObject(int cookie, uint type, out IDataObject ppDataObject)
    {
        // Our cookies for results are a little bit 'munged'
        // The low word is the actual cookie, while the high word is
        // the row # of the result item (1-based)

        // Crap.... we have a multi-selection to worry about
        if (cookie == MMC.MULTI_SELECT_COOKIE)
        {
            IResultData ResultData = (IResultData)m_ucsole;
            ArrayList al = new ArrayList();
            bool isLastSelected = false;
            int nGoodCookie = -1;
            int  nIndex = -1;

            while(!isLastSelected)
            {
                RESULTDATAITEM rdi = new RESULTDATAITEM();
                rdi.mask = RDI.STATE;
                rdi.nCol = 0;
                rdi.nIndex = nIndex;
                rdi.nState = LVIS.SELECTED;
                
                ResultData.GetNextItem(ref rdi);

                if (rdi.nIndex != -1)
                {
                    al.Add((int)((rdi.lParam & 0xFFFF0000) >> 16));
                    nGoodCookie = rdi.lParam;
                    nIndex = rdi.nIndex;
                }
                else
                    isLastSelected = true;
            }
            if (nGoodCookie != -1)
            {
                int iRealCookie = nGoodCookie & 0x0000FFFF;
                CNode node = CNodeManager.GetNode(iRealCookie);
                CDO cdo = new CDO(node);
                cdo.Data = al;
                ppDataObject = cdo;
            }
            else
                ppDataObject = null;
        }
        else
        {
            int iRealCookie = cookie & 0x0000FFFF;
            CNode node = CNodeManager.GetNode(iRealCookie);
            CDO cdo = new CDO(node);
            Object o;
            if (node.ResultQDO(cookie, out o))
                cdo.Data = o;
            else  
                cdo.Data = (int)((cookie & 0xFFFF0000) >> 16);

            ppDataObject = cdo;
        }
    }// QueryDataObject
    
    //-------------------------------------------------
    // GetResultViewType
    //
    // This function is called when MMC needs to display
    // a specific node's information in the result pane.
    //-------------------------------------------------
    public int GetResultViewType(int cookie, out IntPtr ppViewType, out uint pViewOptions)
	{
        CNode node = CNodeManager.GetNode(cookie);

        CNodeManager.DisplayedNode = node;
        node.Showing();
        // We never want the "view" menu to appear
        pViewOptions=MMC_VIEW_OPTIONS.NOLISTVIEWS|MMC_VIEW_OPTIONS.CREATENEW;
        
        // CNode.Result can be potientially expensive... make sure
        // we catch the result here.
        
        String res = node.Result;

        // We don't have a HTML (or taspad) to display, so we'll just show a 
        // standard list view
        if (res == null)
        {
            ppViewType=(IntPtr)0;
            return HRESULT.S_FALSE;
        }

        // Ok, we're displaying a HTML page or a Taskpad

	    ppViewType=Marshal.StringToCoTaskMemUni(res);
        return HRESULT.S_OK;
	}// GetResultViewType

    //-------------------------------------------------
    // GetDisplayInfo
    //
    // This function is called by MMC whenever it needs to
    // display a node in the result view.
    //-------------------------------------------------
    public void GetDisplayInfo(ref RESULTDATAITEM ResultDataItem)
    {
        // The low word in the lParam contains the index of the node
        // we're interested in.
        
        CNode NodeWeWant = CNodeManager.GetNode((int)ResultDataItem.lParam & 0xffff);

        // We'll let the node take care of its own Result Data
        NodeWeWant.GetResultDisplayInfo(ref ResultDataItem);
    }// GetDisplayInfo
    
    //-------------------------------------------------
    // CompareObjects
    //
    // This function will compare two data objects. In this
    // snapin, if the cookies are identical for each data object,
    // then the items are the same
    //-------------------------------------------------
    public int CompareObjects(IDataObject lpDataObjectA, IDataObject lpDataObjectB)
    {
        CDO doItem1, doItem2;

        // These data items should be CDO's in disguise.....
        doItem1 = (CDO)lpDataObjectA;
        doItem2 = (CDO)lpDataObjectB;
        
        if (doItem1.Node.Cookie != doItem2.Node.Cookie)
            return HRESULT.S_FALSE;

        // Do a simple compare
        if (doItem1.Data == doItem2.Data)
            return HRESULT.S_OK;

        // If these aren't ints, let's ask the node for some help in comparing these
        if (!(doItem1.Data is int) && !(doItem2.Data is int))
        {
            bool fEqual;
       
            if (doItem1.Node.ResultCompareObjects(doItem1.Data, doItem2.Data, out fEqual))
            {
                if (fEqual)
                    return HRESULT.S_OK;
                else
                    return HRESULT.S_FALSE;
            }
        }

        // Make sure both of the Data members of the CDO are integers
        // If they're not integers, we can't do good comparisons...
        
        if (!(doItem1.Data is int) || !(doItem2.Data is int))
            return HRESULT.S_FALSE;
   
        if ((int)doItem1.Data != (int)doItem2.Data)
        {
            // These are different objects. We need to return S_FALSE
            return HRESULT.S_FALSE;
        }

        return HRESULT.S_OK;
    }// CompareObjects

    //-------------------------------------------------------
    // Methods to extend IContextMenu
    //-------------------------------------------------------

    //-------------------------------------------------
    // AddMenuItems
    //
    // This function allows us to add items to the context menus
    //-------------------------------------------------
    public void AddMenuItems(IDataObject piDataObject, IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {
        // The piDataObject is really a CDO is disguise....
        CDO item = (CDO)piDataObject;

        item.Node.AddMenuItems(ref piCallback, ref pInsertionAllowed, item.Data);
   
    }// AddMenuItems

    //-------------------------------------------------
    // Command
    //
    // This function is called whenever an item that we
    // added to the context menus is called
    //-------------------------------------------------
    public void Command(int lCommandID, IDataObject piDataObject)
    {
        CDO item = (CDO)piDataObject;
        // Tell our command history about this
        CCommandHistory.CommandExecuted(item, lCommandID);
        item.Node.MenuCommand(lCommandID, item.Data);
    }// Command

    //-------------------------------------------------------
    // Methods for IExtendControlbar
    //-------------------------------------------------------

    //-------------------------------------------------
    // SetControlbar
    //
    // This function will add items to the toolbar
    //-------------------------------------------------
     public void SetControlbar(IControlbar pControlbar)
     {
        if (pControlbar != null && false)
        {
        
           Object newcontrol;
           // Create a toolbar that we can "integrate" into the default toolbar
           pControlbar.Create(MMC_CONTROL_TYPE.TOOLBAR, this, out newcontrol);

           m_Toolbar = (IToolbar)newcontrol;

           // Add our bitmap to the toolbar's imagelist                                      
           m_Toolbar.AddBitmap(1, m_hToolbarBMP, 16, 16, 0x00FFFFFF);

           // Now create the button we'll be adding to the toolbar
           MMCBUTTON    newButton = new MMCBUTTON();
           newButton.nBitmap = 0;
           newButton.idCommand = 1;
           newButton.fsState = TBSTATE.ENABLED;
           newButton.fsType = TBSTYLE.BUTTON;
           newButton.lpButtonText = "Go to the Black Page";
           newButton.lpTooltipText = "This button will take you to the Black page";
                            
           m_Toolbar.AddButtons(1, ref newButton);

           // Now attach the toolbar we just created to MMC's toolbar 
           pControlbar.Attach(MMC_CONTROL_TYPE.TOOLBAR, m_Toolbar);
        }

     }// SetControlbar

    //-------------------------------------------------
    // ControlbarNotify
    //
    // This function is called whenever one of our added
    // buttons on the toolbar is click
    //-------------------------------------------------
     public int ControlbarNotify(uint aevent, int arg, int param)
     {
        // If they clicked a button......
        if (aevent == MMCN.BTN_CLICK)
        {
            // Query the Console interface we have for the namespace
            IConsoleNameSpace2 ConsoleNameSpace = (IConsoleNameSpace2)m_ucsole;

            // If they clicked our button we added
            // (This check is unnecessary since we only added one button
            if (param == 1)
            {
                // We want to open up the tree and center on the black icon.
                
                // We'll expand the root node for kicks...
               // ConsoleNameSpace.Expand((uint)m_Nodes[0].HScopeItem);
                // Now we'll expand each parent node for this guy
               // ConsoleNameSpace.Expand((uint)m_Nodes[1].HScopeItem);
                // Now let's set the focus on the black node
               // m_ucsole.SelectScopeItem(m_Nodes[3].HScopeItem);   
            }
        }
        
        // Else we don't handle the event
        else
        {
            return HRESULT.S_FALSE;
        }

        return HRESULT.S_OK;
     }// ControlbarNotify

    //-------------------------------------------------------
    // Methods for IExtendTaskPad
    //-------------------------------------------------------

    //-------------------------------------------------
    // TaskNotify
    //
    // This function is called from the ActiveX control
    // on the HTML page in the result pane. We direct
    // whatever message was sent to the appropriate node.
    //-------------------------------------------------
    public void TaskNotify(IDataObject pdo, ref Object arg, ref Object param)
    {
        CDO data = (CDO)pdo;
        data.Node.BaseTaskPadTaskNotify(arg, param, m_ucsole, m_Data);
    }// TaskNotify

    //-------------------------------------------------
    // EnumTasks
    //
    // This function can be called either by MMC or by 
    // the ActiveX control on our webpage. Again, we
    // route it to the appropiate node.
    //-------------------------------------------------
    public void EnumTasks(IDataObject pdo, String szTaskGroup, out IEnumTASK ppEnumTASK)
    {
       CDO data = (CDO)pdo;
       ppEnumTASK = data.Node.GetIEnumTASK(szTaskGroup);
    }// EnumTasks

    //-------------------------------------------------
    // GetTitle
    //
    // This function returns the title of the specified
    // taskpad
    //-------------------------------------------------
    public void GetTitle(String pszGroup, [MarshalAs(UnmanagedType.LPWStr)] out String pszTitle)
    {
       CNode node = CNodeManager.GetNodeByTaskPadGroupName(pszGroup);
       pszTitle = node.GetTaskPadTitle(pszGroup);
    }// GetTitle

    //-------------------------------------------------
    // GetDescriptiveText
    //
    // This function returns a description of the specified
    // taskpad
    //-------------------------------------------------
    public void GetDescriptiveText(String pszGroup, [MarshalAs(UnmanagedType.LPWStr)] out String pszDescriptiveText)
    {
       CNode node = CNodeManager.GetNodeByTaskPadGroupName(pszGroup);
       pszDescriptiveText = node.GetTaskPadDescription(pszGroup);
    }// GetDescriptiveText

    //-------------------------------------------------
    // GetBackground
    //
    // This returns some background info for our taskpad
    //-------------------------------------------------
    public void GetBackground(String pszGroup, out MMC_TASK_DISPLAY_OBJECT pTDO)
    {
       CNode node = CNodeManager.GetNodeByTaskPadGroupName(pszGroup);
       pTDO = node.GetTaskPadBackground(pszGroup);
    }// GetBackground

    //-------------------------------------------------
    // GetListPadInfo
    //
    // This returns info pertaining to a ListPad
    //-------------------------------------------------
    public void GetListPadInfo(String pszGroup, out MMC_LISTPAD_INFO lpListPadInfo)
    {
       CNode node = CNodeManager.GetNodeByTaskPadGroupName(pszGroup);
       lpListPadInfo = node.GetTaskPadListPadInfo(pszGroup);
    }// GetListPadInfo

    //-------------------------------------------------------
    // Stuff for IExtendPropertySheet2 - This will only be called
    // on Property sheets in the result view
    //-------------------------------------------------------

    //-------------------------------------------------
    // CreatePropertyPages
    //
    // MMC calls this function when it wants a property
    // page for a specified node.
    //-------------------------------------------------
    public int CreatePropertyPages(IPropertySheetCallback lpProvider, IntPtr handle, IDataObject lpIDataObject)
    {
	    // This is really a CDO in disguise
        CDO victim = (CDO)lpIDataObject;
       
        // See if we're asking for property pages based on a result item
        if (victim.Data != null && victim.Node.DoesResultHavePropertyPage(victim.Data)) 
        {
            CCommandHistory.CommandExecuted(victim, -1);
            victim.Node.CreateResultPropertyPages(lpProvider, handle, victim.Data);
        }
        // We don't have any property pages, let's return false
        else
        {
            MessageBox(0, "Got a false positive", "", 0);
            return HRESULT.S_FALSE;
        }

        return HRESULT.S_OK;
    }// CreatePropertyPages

    //-------------------------------------------------
    // QueryPagesFor
    //
    // MMC calls this function once at the beginning when
    // everything is being initialized, asking if we have any
    // property pages. If we tell it we don't, we can never
    // have any property pages in our snapin. (It will never
    // call CreatePropertyPages)
    //-------------------------------------------------
    public int QueryPagesFor(IDataObject lpDataObject)
    {
        // This snapin does have property pages, so we should return S_OK
        // If the snapin didn't have any property pages, then we should return S_FALSE

        return HRESULT.S_OK;
    }// QueryPagesFor

    public int GetWatermarks(IDataObject lpIDataObject, out IntPtr lphWatermark, out IntPtr lphHeader, out IntPtr lphPalette, out int bStretch)
    {
        IntPtr hBitmap = CResourceStore.CreateWindowBitmap(49,
                                                           49);

        lphWatermark = hBitmap;
        lphHeader = hBitmap;
        lphPalette = IntPtr.Zero;
        bStretch = 0;
        
        return HRESULT.S_OK;
       }// GetWatermarks

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int OpenClipboard(IntPtr hWndNewOwner);

}// class CComponent
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccreatedeploymentpackagewiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Reflection;
using System.Security;

internal class CCreateDeploymentPackageWiz1 : CWizardPage
{
    // Controls on the page

	private RadioButton m_radEnterprise;
    private Label m_lblChooseSecurityPolicy;
    private Button m_btnBrowse;
    private RadioButton m_radMachine;
    private Label m_lblHelp;
    private Label m_lblHelp2;
    private Label m_lblChooseMSIFile;
    private TextBox m_txtFilename;
    private RadioButton m_radUser;
           
    internal CCreateDeploymentPackageWiz1()
    {
        m_sTitle=CResourceStore.GetString("CCreateDeploymentPackageWiz1:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz1:HeaderSubTitle");
    }// CCreateDeploymentPackageWiz1

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CCreateDeploymentPackageWiz1));
        this.m_radEnterprise = new System.Windows.Forms.RadioButton();
        this.m_lblChooseSecurityPolicy = new System.Windows.Forms.Label();
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_radMachine = new System.Windows.Forms.RadioButton();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblHelp2 = new System.Windows.Forms.Label();
        this.m_lblChooseMSIFile = new System.Windows.Forms.Label();
        this.m_txtFilename = new System.Windows.Forms.TextBox();
        this.m_radUser = new System.Windows.Forms.RadioButton();
        this.m_radEnterprise.Location = ((System.Drawing.Point)(resources.GetObject("m_radEnterprise.Location")));
        this.m_radEnterprise.Size = ((System.Drawing.Size)(resources.GetObject("m_radEnterprise.Size")));
        this.m_radEnterprise.TabIndex = ((int)(resources.GetObject("m_radEnterprise.TabIndex")));
        this.m_radEnterprise.Text = resources.GetString("m_radEnterprise.Text");
        m_radEnterprise.Name = "Enterprise";
        this.m_lblChooseSecurityPolicy.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseSecurityPolicy.Location")));
        this.m_lblChooseSecurityPolicy.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseSecurityPolicy.Size")));
        this.m_lblChooseSecurityPolicy.TabIndex = ((int)(resources.GetObject("m_lblChooseSecurityPolicy.TabIndex")));
        this.m_lblChooseSecurityPolicy.Text = resources.GetString("m_lblChooseSecurityPolicy.Text");
        m_lblChooseSecurityPolicy.Name = "ChoosePolicyLabel";
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        m_btnBrowse.Name = "Browse";
        this.m_radMachine.Location = ((System.Drawing.Point)(resources.GetObject("m_radMachine.Location")));
        this.m_radMachine.Size = ((System.Drawing.Size)(resources.GetObject("m_radMachine.Size")));
        this.m_radMachine.TabIndex = ((int)(resources.GetObject("m_radMachine.TabIndex")));
        this.m_radMachine.Text = resources.GetString("m_radMachine.Text");
        m_radMachine.Name = "Machine";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblHelp2.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp2.Location")));
        this.m_lblHelp2.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp2.Size")));
        this.m_lblHelp2.TabIndex = ((int)(resources.GetObject("m_lblHelp2.TabIndex")));
        this.m_lblHelp2.Text = resources.GetString("m_lblHelp2.Text");
        m_lblHelp2.Name = "Help2";
        this.m_lblChooseMSIFile.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseMSIFile.Location")));
        this.m_lblChooseMSIFile.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseMSIFile.Size")));
        this.m_lblChooseMSIFile.TabIndex = ((int)(resources.GetObject("m_lblChooseMSIFile.TabIndex")));
        this.m_lblChooseMSIFile.Text = resources.GetString("m_lblChooseMSIFile.Text");
        m_lblChooseMSIFile.Name = "ChooseMSIFile";
        this.m_txtFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_txtFilename.Location")));
        this.m_txtFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_txtFilename.Size")));
        this.m_txtFilename.TabIndex = ((int)(resources.GetObject("m_txtFilename.TabIndex")));
        this.m_txtFilename.Text = resources.GetString("m_txtFilename.Text");
        m_txtFilename.Name = "Filename";
        this.m_radUser.Location = ((System.Drawing.Point)(resources.GetObject("m_radUser.Location")));
        this.m_radUser.Size = ((System.Drawing.Size)(resources.GetObject("m_radUser.Size")));
        this.m_radUser.TabIndex = ((int)(resources.GetObject("m_radUser.TabIndex")));
        this.m_radUser.Text = resources.GetString("m_radUser.Text");
        m_radUser.Name = "User";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblHelp2,
                        this.m_btnBrowse,
                        this.m_txtFilename,
                        this.m_lblChooseMSIFile,
                        this.m_radUser,
                        this.m_radMachine,
                        this.m_radEnterprise,
                        this.m_lblChooseSecurityPolicy,
                        this.m_lblHelp});

        PutValuesinPage();
        
        m_txtFilename.TextChanged += new EventHandler(onTextChange);
        m_btnBrowse.Click += new EventHandler(onBrowse);
        
        return 1;
    }// InsertPropSheetPageControls

    internal String Filename
    {
        get
        {
            return m_txtFilename.Text;
        }
    }// Filename

    internal PolicyLevelType MyPolicyLevel
    {
        get
        {
            if (m_radEnterprise.Checked)
                return PolicyLevelType.Enterprise;
            if (m_radMachine.Checked)
                return PolicyLevelType.Machine;
            if (m_radUser.Checked)
                return PolicyLevelType.User;
            throw new Exception("Unknown policy level");
        }

    }// PolicyLevel

    internal String FileToPackage
    {
        get
        {
            return Security.GetPolicyLevelFromType(MyPolicyLevel).StoreLocation;
        }
    }// FileToPackage
    

    void PutValuesinPage()
    {
        m_radEnterprise.Checked = true;   
    }// PutValuesinPage

    void onBrowse(Object o, EventArgs e)
    {
        // Pop up a file dialog so the user can find an assembly
        SaveFileDialog fd = new SaveFileDialog();
        fd.Title = CResourceStore.GetString("CCreateDeploymentPackageWiz1:FileDialogTitle");
        fd.Filter = CResourceStore.GetString("CCreateDeploymentPackageWiz1:FileDialogMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            m_txtFilename.Text = fd.FileName;
            CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);
            wiz.TurnOnNext(true);
        }
    }// onBrowse

    void onTextChange(Object o, EventArgs e)
    {
        CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);
    
        // See if we should turn on the Finish button
        if (m_txtFilename.Text.Length>0)
            wiz.TurnOnNext(true);
        // Nope, we want the Finish button off
        else
            wiz.TurnOnNext(false);
    }// onTextChange


}// class CCreateDeploymentPackageWiz1
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cdo.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CDO.cs
//
// This implements the object that is responsible for transfering
// data about nodes to the MMC.
//-------------------------------------------------------------
using System;
using System.Runtime.InteropServices;


namespace Microsoft.CLRAdmin
{

public class CDO : IDataObject
{
    private ushort      m_cfDisplayName; // Clipboard format # for Display Name
    private ushort      m_cfNodeType;    // Clipboard format # for NodeType
    private ushort      m_cfSZNodeType;  // Clipboard format # for SZNodeType
    private ushort      m_cfSnapinClsid; // Clipboard format # for SnapinClsid
    private ushort      m_cfMultiSelect; // Clipboard format # for multiselection
    
    private CNode       m_NodeData;      // The node that this Data object is
                                         // responsible for

    private Object      m_Data;          // Some data that could be passed                                          

    //-------------------------------------------------
    // CDO
    //
    // The constructor is responsible for loading the about images
    // that will be displayed in the MMC
    //-------------------------------------------------
    internal CDO(CNode initData)
    {
        // Set the Node this Data Object will be responsible for
        m_NodeData = initData;
        m_Data = null;

        // Get the Clipboard Format Numbers for these various items.
        // MMC should have already registered these Clipboard Formats,
        // so this call just gives us the id assigned for each format.
        
        m_cfDisplayName = RegisterClipboardFormat("CCF_DISPLAY_NAME");
        m_cfNodeType = RegisterClipboardFormat("CCF_NODETYPE");
        m_cfSZNodeType = RegisterClipboardFormat("CCF_SZNODETYPE");
        m_cfSnapinClsid = RegisterClipboardFormat("CCF_SNAPIN_CLASSID");
        m_cfMultiSelect = RegisterClipboardFormat("CCF_OBJECT_TYPES_IN_MULTI_SELECT");
    }// CDO
    
    //-------------------------------------------------
    // Node
    //
    // Provides access to the Data Object's Node
    //-------------------------------------------------
    public CNode Node
    {
        get
        {
            return m_NodeData;
        }
    }// Node

    //-------------------------------------------------
    // Data
    //
    // Provides access to the some misc data
    //-------------------------------------------------
    internal Object Data
    {
        get
        {
            return m_Data;
        }
        set
        {
            m_Data=value;
        }

    }// Object
    
    //-------------------------------------------------
    // GetDataHere
    //
    // This function will send certain data to the MMC. Note
    // this function uses the "unsafe" context... we need to
    // send a pointer to a byte array to IStream:Write, and this
    // is the easiest way to do it.
    //-------------------------------------------------
    public unsafe int GetDataHere(ref FORMATETC pFormat, ref STGMEDIUM pMedium)
    {
        IStream         pStream=null;   
        byte[]           bDataToSend;
        int             iLengthOfData;
        uint             iDataSent=0;

        try
        {
        // We'll send this array if we don't know what to send
        byte[] Nothing = {0x0, 0x0};

        ushort cf = (ushort)pFormat.cfFormat;

        CreateStreamOnHGlobal(pMedium.hGlobal, 0, out pStream );

        // If we couldn't open a global handle....
        if (pStream == null)
            throw new Exception("Fail on CreateStreamOnHGlobal");


        // NOTE: the use of pointers is only possible because the function was marked
        // unsafe. Also, pData will only point to a valid address inside the "fixed"
        // block... outside of the "fixed" block the GC could move our memory around, resulting
        // in pData pointing to garbage.

        
        // See if we need to send a string....
        if (cf == m_cfDisplayName || cf == m_cfSZNodeType)
        {
            if (cf == m_cfDisplayName)
                bDataToSend = m_NodeData.bDisplayName;
            else
                bDataToSend = Nothing;

            iLengthOfData = bDataToSend.Length;
            fixed(byte* pData = bDataToSend)
	        {
    	        pStream.Write((IntPtr)pData, (uint)iLengthOfData, out iDataSent);
            }
        }
        // We need to send a GUID
        else if (cf == m_cfNodeType || cf == m_cfSnapinClsid)
        {
            CLSID cls = new CLSID();

            if (cf == m_cfNodeType)
            {
                cls = m_NodeData.Guid;
            }

            else //if (cf == m_cfSnapinClsid)
            {
                // The GUID for this snapin
                cls.x = 0x18ba7139;
                cls.s1 = 0xd98b;
                cls.s2 = 0x43c2;;
                cls.c = new byte[8] {0x94, 0xda, 0x26, 0x04, 0xe3, 0x4e, 0x17, 0x5d};
            }

            IntPtr pData = Marshal.AllocCoTaskMem(16);

            // We need to marshal this structure ourselves
            Marshal.WriteInt32(pData, 0, (int)cls.x);
            Marshal.WriteInt16(pData, 4, (short)cls.s1);
            Marshal.WriteInt16(pData, 6, (short)cls.s2);
            for(int i=0; i<8; i++)
                Marshal.WriteByte(pData, 8+i, cls.c[i]); 

            pStream.Write(pData, 16, out iDataSent);
            Marshal.FreeCoTaskMem(pData);

        }
        
         // Close/Flush the stream
         Marshal.ReleaseComObject(pStream);
        }
        catch(Exception e)
        {
           if (pStream != null)
                Marshal.ReleaseComObject(pStream);
           throw e;
        }
        return HRESULT.S_OK;

    }// GetDataHere

    //-------------------------------------------------
    // Other IDataObject Methods
    //
    // We don't need to implement any of these other 
    // methods, so if they are called, we'll just return
    // E_NOTIMPL
    //-------------------------------------------------

    public int GetData(ref FORMATETC pFormat, ref STGMEDIUM pMedium)
    {
    
        try
        {
        pMedium.hGlobal = (IntPtr)0;
        // We'll send this array if we don't know what to send
        byte[] Nothing = {0x0, 0x0};

        ushort cf = (ushort)pFormat.cfFormat;

        if (cf != m_cfMultiSelect)
            return HRESULT.E_NOTIMPL;

        CLSID cls = m_NodeData.Guid;

        SMMCObjectTypes ot = new SMMCObjectTypes();
        ot.count = 1;
        ot.guid = new CLSID[] {cls};
                
        pMedium.tymed = TYMED.HGLOBAL;
        pMedium.hGlobal = Marshal.AllocHGlobal(4 + 16);

        // We need to marshal this structure ourselves
        Marshal.WriteInt32(pMedium.hGlobal, 0, (int)ot.count);
        Marshal.WriteInt32(pMedium.hGlobal, 4, (int)ot.guid[0].x);
        Marshal.WriteInt16(pMedium.hGlobal, 8, (short)ot.guid[0].s1);
        Marshal.WriteInt16(pMedium.hGlobal, 10, (short)ot.guid[0].s2);
        for(int i=0; i<8; i++)
            Marshal.WriteByte(pMedium.hGlobal, 12+i, ot.guid[0].c[i]); 
    
        }
        catch(Exception e)
        {
           if ((int)pMedium.hGlobal != 0)
                Marshal.FreeHGlobal(pMedium.hGlobal);
           throw e;
        }
        return HRESULT.S_OK;
    }// GetData

    public int QueryGetData(IntPtr a)
    {
        return HRESULT.E_NOTIMPL;
    }// QueryGetData

    public int GetCanonicalFormatEtc(IntPtr a, IntPtr b)
    {
        return HRESULT.E_NOTIMPL;
    }// GetCanonicalFormatEtc

    public int SetData(IntPtr a, IntPtr b, int c)
    {
        return HRESULT.E_NOTIMPL;
    }// SetData
    
    public int EnumFormatEtc(uint a, IntPtr b)
    {
        return HRESULT.E_NOTIMPL;
    }// EnumFormatEtc
    
    public int DAdvise(IntPtr a, uint b, IntPtr c, ref uint d)
    {
        return HRESULT.E_NOTIMPL;
    }// DAdvise

    public int DUnadvise(uint a)
    {
        return HRESULT.E_NOTIMPL;
    }// DUnadvise

    public int EnumDAdvise(IntPtr a)
    {
        return HRESULT.E_NOTIMPL;
    }// EnumDAdvise

    //-------------------------------------------------
    // We need to import the Win32 API calls used to deal with
    // clipboard formats and HGlobal streams.
    //-------------------------------------------------

	[DllImport("ole32.dll")]
    internal static extern int CreateStreamOnHGlobal(IntPtr hGlobal, int fDeleteOnRelease, out IStream ppstm);

    // All the MMC stuff is done in Unicode, which is why we're using
    // that character set here
  
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern ushort RegisterClipboardFormat(String format);
}// class CDO
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cevalassemwiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Threading;
using System.Security.Policy;


internal class CEvalAssemWiz1 : CWizardPage
{
    // Controls on the page

    private Label m_lblChooseOption;
    private Label m_lblChooseFile;
    private Label m_lblFilename;
    private Label m_lblPolLevel;
    private ComboBox m_cbLevels;
    private Button m_btnBrowse;
    private RadioButton m_radViewCodegroup;
    private Label m_lblChoosePolicy;
    private TextBox m_txtFilename;
    private RadioButton m_radViewPerms;


    // For ahead-of-time computing of evidence
    Thread          m_tEvidence;
    AssemblyLoader  m_al;  

    String          m_sEvalAssem;
    
    internal CEvalAssemWiz1()
    {
        m_sTitle=CResourceStore.GetString("CEvalAssemWiz1:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CEvalAssemWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CEvalAssemWiz1:HeaderSubTitle");
        m_tEvidence = new Thread(new ThreadStart(NewAssembly));
        m_tEvidence.Priority = ThreadPriority.AboveNormal;
        m_al = new AssemblyLoader();
    }// CEvalAssemWiz1

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CEvalAssemWiz1));
        this.m_lblChooseOption = new System.Windows.Forms.Label();
        this.m_lblChooseFile = new System.Windows.Forms.Label();
        this.m_lblFilename = new System.Windows.Forms.Label();
        this.m_lblPolLevel = new System.Windows.Forms.Label();
        this.m_cbLevels = new System.Windows.Forms.ComboBox();
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_radViewCodegroup = new System.Windows.Forms.RadioButton();
        this.m_lblChoosePolicy = new System.Windows.Forms.Label();
        this.m_txtFilename = new System.Windows.Forms.TextBox();
        this.m_radViewPerms = new System.Windows.Forms.RadioButton();
        this.m_lblChooseOption.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseOption.Location")));
        this.m_lblChooseOption.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseOption.Size")));
        this.m_lblChooseOption.TabIndex = ((int)(resources.GetObject("m_lblChooseOption.TabIndex")));
        this.m_lblChooseOption.Text = resources.GetString("m_lblChooseOption.Text");
        m_lblChooseOption.Name = "ChooseOptionLabel";
        this.m_lblChooseFile.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseFile.Location")));
        this.m_lblChooseFile.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseFile.Size")));
        this.m_lblChooseFile.TabIndex = ((int)(resources.GetObject("m_lblChooseFile.TabIndex")));
        this.m_lblChooseFile.Text = resources.GetString("m_lblChooseFile.Text");
        m_lblChooseFile.Name = "ChooseFileLabel";
        this.m_lblFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_lblFilename.Location")));
        this.m_lblFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_lblFilename.Size")));
        this.m_lblFilename.TabIndex = ((int)(resources.GetObject("m_lblFilename.TabIndex")));
        this.m_lblFilename.Text = resources.GetString("m_lblFilename.Text");
        m_lblFilename.Name = "FilenameLabel";
        this.m_lblPolLevel.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPolLevel.Location")));
        this.m_lblPolLevel.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPolLevel.Size")));
        this.m_lblPolLevel.TabIndex = ((int)(resources.GetObject("m_lblPolLevel.TabIndex")));
        this.m_lblPolLevel.Text = resources.GetString("m_lblPolLevel.Text");
        m_lblPolLevel.Name = "PolicyLevelLabel";
        this.m_cbLevels.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbLevels.DropDownWidth = 256;
        this.m_cbLevels.Location = ((System.Drawing.Point)(resources.GetObject("m_cbLevels.Location")));
        this.m_cbLevels.Size = ((System.Drawing.Size)(resources.GetObject("m_cbLevels.Size")));
        this.m_cbLevels.TabIndex = ((int)(resources.GetObject("m_cbLevels.TabIndex")));
        m_cbLevels.Name = "PolicyLevels";
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        m_btnBrowse.Name = "Browse";
        this.m_radViewCodegroup.Location = ((System.Drawing.Point)(resources.GetObject("m_radViewCodegroup.Location")));
        this.m_radViewCodegroup.Size = ((System.Drawing.Size)(resources.GetObject("m_radViewCodegroup.Size")));
        this.m_radViewCodegroup.TabIndex = ((int)(resources.GetObject("m_radViewCodegroup.TabIndex")));
        this.m_radViewCodegroup.Text = resources.GetString("m_radViewCodegroup.Text");
        m_radViewCodegroup.Name = "ViewCodegroups";
        this.m_lblChoosePolicy.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChoosePolicy.Location")));
        this.m_lblChoosePolicy.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChoosePolicy.Size")));
        this.m_lblChoosePolicy.TabIndex = ((int)(resources.GetObject("m_lblChoosePolicy.TabIndex")));
        this.m_lblChoosePolicy.Text = resources.GetString("m_lblChoosePolicy.Text");
        m_lblChoosePolicy.Name = "ChoosePolicyLabel";
        this.m_txtFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_txtFilename.Location")));
        this.m_txtFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_txtFilename.Size")));
        this.m_txtFilename.TabIndex = ((int)(resources.GetObject("m_txtFilename.TabIndex")));
        m_txtFilename.Name = "Filename";
        this.m_radViewPerms.Location = ((System.Drawing.Point)(resources.GetObject("m_radViewPerms.Location")));
        this.m_radViewPerms.Size = ((System.Drawing.Size)(resources.GetObject("m_radViewPerms.Size")));
        this.m_radViewPerms.TabIndex = ((int)(resources.GetObject("m_radViewPerms.TabIndex")));
        this.m_radViewPerms.Text = resources.GetString("m_radViewPerms.Text");
        m_radViewPerms.Name = "ViewPermissions";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblChoosePolicy,
                        this.m_lblFilename,
                        this.m_txtFilename,
                        this.m_btnBrowse,
                        this.m_radViewPerms,
                        this.m_radViewCodegroup,
                        this.m_lblPolLevel,
                        this.m_cbLevels,
                        this.m_lblChooseOption,
                        this.m_lblChooseFile});
        PutValuesinPage();

        // Hook up the event handlers
        m_txtFilename.TextChanged += new EventHandler(onTextChange);
        m_btnBrowse.Click += new EventHandler(onBrowse);
        m_cbLevels.SelectedIndexChanged += new EventHandler(onLevelChange);
        m_radViewPerms.CheckedChanged += new EventHandler(onObjectiveChange);
        m_radViewCodegroup.CheckedChanged += new EventHandler(onObjectiveChange);
        return 1;
    }// InsertPropSheetPageControls

    internal String Filename
    {
        get
        {
            return m_txtFilename.Text;
        }
    }// Filename

    internal bool ShowPermissions
    {
        get
        {
            return m_radViewPerms.Checked;
        }
    }// ShowPermissions

    internal int PolicyLevel
    {
        get
        {
            switch(m_cbLevels.SelectedIndex)
            {
                case 0:
                    return CEvalAssemWizard.ALL_CODEGROUPS;
                case 1:
                    return CEvalAssemWizard.ENTERPRISE_CODEGROUPS;
                case 2:
                    return CEvalAssemWizard.MACHINE_CODEGROUPS;
                case 3:
                    return CEvalAssemWizard.USER_CODEGROUPS;
                default:
                    // As a default, just return all (we should never hit this)
                    return CEvalAssemWizard.ALL_CODEGROUPS;
            }
        }

    }// PolicyLevel

    void PutValuesinPage()
    {
        // By default, let's check the 'view permissions' box
        m_radViewPerms.Checked=true;

        // Let's populate the combo box with all our options
        m_cbLevels.Items.Clear();
        m_cbLevels.Items.Add(CResourceStore.GetString("All Levels"));
        m_cbLevels.Items.Add(CResourceStore.GetString("Enterprise"));
        m_cbLevels.Items.Add(CResourceStore.GetString("Machine"));
        m_cbLevels.Items.Add(CResourceStore.GetString("User"));
        m_cbLevels.SelectedIndex=0;
       
    }// PutValuesinPage

    void onBrowse(Object o, EventArgs e)
    {
        // Pop up a file dialog so the user can find an assembly
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("CEvalAssemWiz1:FDTitle");
        fd.Filter = CResourceStore.GetString("CEvalAssemWiz1:FDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            if(Fusion.isManaged(fd.FileName))
            {
                m_txtFilename.Text = fd.FileName;
                onTextChange(null, null);

                // Get a jump on the loading of this assembly
                if (m_tEvidence != null)
                    m_tEvidence.Abort();
                    
                m_tEvidence = new Thread(new ThreadStart(NewAssembly));
                m_tEvidence.Start();
            }
            else
                MessageBox(CResourceStore.GetString("isNotManagedCode"),
                           CResourceStore.GetString("isNotManagedCodeTitle"),
                           MB.ICONEXCLAMATION);
        }
    }// onBrowse

    void onObjectiveChange(Object o, EventArgs e)
    {
        // Get a jump on the loading of this assembly
        if (m_tEvidence == null && m_txtFilename.Text.Length > 0)
        {                    
            m_tEvidence = new Thread(new ThreadStart(NewAssembly));
            m_tEvidence.Start();
        }
    
        CEvalAssemWizard wiz = (CEvalAssemWizard)CNodeManager.GetNode(m_iCookie);
        wiz.NewObjectiveReceived(m_radViewPerms.Checked);
    }// onObjectiveChange

    void onLevelChange(Object o, EventArgs e)
    {   
        // Get a jump on the loading of this assembly
        if (m_tEvidence == null && m_txtFilename.Text.Length > 0)
        {                    
            m_tEvidence = new Thread(new ThreadStart(NewAssembly));
            m_tEvidence.Start();
        }
   
        CEvalAssemWizard wiz = (CEvalAssemWizard)CNodeManager.GetNode(m_iCookie);
        wiz.RestartEvaluation();
    }// onLevelChange

    void onTextChange(Object o, EventArgs e)
    {
        CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);
        // See if we should turn on the Finish button
        if (m_txtFilename.Text.Length>0)
        {
            if (m_tEvidence != null)
                m_tEvidence.Abort();
            m_tEvidence = null;
            wiz.TurnOnNext(true);
        }
        // Nope, we want the Finish button off
        else
            wiz.TurnOnNext(false);
    }// onTextChange

    void NewAssembly()
    {
        CEvalAssemWizard wiz = (CEvalAssemWizard)CNodeManager.GetNode(m_iCookie);

        try
        {
            AssemblyRef ar = m_al.LoadAssemblyInOtherAppDomainFrom(m_txtFilename.Text);
            wiz.NewEvidenceReceived(ar.GetEvidence());
            m_al.Finished();
        }
        catch(Exception)
        {   
            wiz.NewEvidenceReceived(null);
            m_al.Finished();
        }
    }// NewAssembly

    internal bool HaveCurrentEvidence
    {
        get
        {   return (m_sEvalAssem!= null && m_sEvalAssem.Equals(m_txtFilename.Text));}
    }// HaveCurrentEvidence

    internal Evidence GetEvidence()
    {
        // If we have a thread that is doing this right now, abort
        // it.
        if (m_tEvidence != null)
            m_tEvidence.Abort();
        try
        {
            AssemblyRef ar = m_al.LoadAssemblyInOtherAppDomainFrom(m_txtFilename.Text);
            Evidence e = ar.GetEvidence();
            m_al.Finished();
            m_sEvalAssem = m_txtFilename.Text; 
            return e;
        }
        catch(Exception)
        {   
            // Let's see if can can figure out what failed...
            if (File.Exists(m_txtFilename.Text) && !Fusion.isManaged(m_txtFilename.Text))
                MessageBox(CResourceStore.GetString("isNotManagedCode"),
                           CResourceStore.GetString("isNotManagedCodeTitle"),
                           MB.ICONEXCLAMATION);

            else
                MessageBox(String.Format(CResourceStore.GetString("CantLoadAssembly"), m_txtFilename.Text),
                           CResourceStore.GetString("CantLoadAssemblyTitle"),
                           MB.ICONEXCLAMATION);
            m_al.Finished();
            return null;                           
        }
    }// GetEvidence

    
}// class CEvalAssemWiz1
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccreatedeploymentpackagewiz3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;

internal class CCreateDeploymentPackageWiz3 : CWizardPage
{
    // Controls on the page
    private Label m_lblSummary;
           
    internal CCreateDeploymentPackageWiz3()
    {
        m_sTitle=CResourceStore.GetString("CCreateDeploymentPackageWiz3:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz3:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CCreateDeploymentPackageWiz3:HeaderSubTitle");
    }// CCreateDeploymentPackageWiz3

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CCreateDeploymentPackageWiz3));
        this.m_lblSummary = new System.Windows.Forms.Label();
        this.m_lblSummary.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSummary.Location")));
        this.m_lblSummary.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSummary.Size")));
        this.m_lblSummary.TabIndex = ((int)(resources.GetObject("m_lblSummary.TabIndex")));
        this.m_lblSummary.Text = resources.GetString("m_lblSummary.Text");
        m_lblSummary.Name = "Summary";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_lblSummary});
        return 1;
    }// InsertPropSheetPageControls


}// class CCreateDeploymentPackageWiz3
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cduplicatepermissiondialog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;

class CDuplicatePermissionDialog : Form
{
    internal const int CANCEL     = 0;
    internal const int REPLACE    = 1;
    internal const int MERGE      = 2;
    internal const int INTERSECT  = 3;
    

    private Button m_btnMerge;
    private Label m_lblDes;
    private Button m_btnIntersect;
    private Button m_btnCancel;
    private Button m_btnReplace;
    private Label m_lblHowToHandle;

    private int     m_nChoice;
    private String  m_sPermissionName;

    internal CDuplicatePermissionDialog(String sPermissionName)
    {
        m_sPermissionName = sPermissionName;
        SetupControls();
    }// CDuplicatePermissionDialog

    internal int Result
    {
        get
        {
            return m_nChoice;
        }
    }// SecPolType

    private void SetupControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CDuplicatePermissionDialog));
        this.m_btnMerge = new System.Windows.Forms.Button();
        this.m_lblDes = new System.Windows.Forms.Label();
        this.m_btnIntersect = new System.Windows.Forms.Button();
        this.m_btnCancel = new System.Windows.Forms.Button();
        this.m_btnReplace = new System.Windows.Forms.Button();
        this.m_lblHowToHandle = new System.Windows.Forms.Label();
        this.SuspendLayout();
        // 
        // m_btnMerge
        // 
        this.m_btnMerge.Location = ((System.Drawing.Point)(resources.GetObject("m_btnMerge.Location")));
        this.m_btnMerge.Name = "Merge";
        this.m_btnMerge.Size = ((System.Drawing.Size)(resources.GetObject("m_btnMerge.Size")));
        this.m_btnMerge.TabIndex = ((int)(resources.GetObject("m_btnMerge.TabIndex")));
        this.m_btnMerge.Text = resources.GetString("m_btnMerge.Text");
        // 
        // m_lblDes
        // 
        this.m_lblDes.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDes.Location")));
        this.m_lblDes.Name = "Help";
        this.m_lblDes.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDes.Size")));
        this.m_lblDes.TabIndex = ((int)(resources.GetObject("m_lblDes.TabIndex")));
        this.m_lblDes.Text = resources.GetString("m_lblDes.Text");
        // 
        // m_btnIntersect
        // 
        this.m_btnIntersect.Location = ((System.Drawing.Point)(resources.GetObject("m_btnIntersect.Location")));
        this.m_btnIntersect.Name = "Intersect";
        this.m_btnIntersect.Size = ((System.Drawing.Size)(resources.GetObject("m_btnIntersect.Size")));
        this.m_btnIntersect.TabIndex = ((int)(resources.GetObject("m_btnIntersect.TabIndex")));
        this.m_btnIntersect.Text = resources.GetString("m_btnIntersect.Text");
        // 
        // m_btnCancel
        // 
        this.m_btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("m_btnCancel.Location")));
        this.m_btnCancel.Name = "Cancel";
        this.m_btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("m_btnCancel.Size")));
        this.m_btnCancel.TabIndex = ((int)(resources.GetObject("m_btnCancel.TabIndex")));
        this.m_btnCancel.Text = resources.GetString("m_btnCancel.Text");
        // 
        // m_btnReplace
        // 
        this.m_btnReplace.Location = ((System.Drawing.Point)(resources.GetObject("m_btnReplace.Location")));
        this.m_btnReplace.Name = "Replace";
        this.m_btnReplace.Size = ((System.Drawing.Size)(resources.GetObject("m_btnReplace.Size")));
        this.m_btnReplace.TabIndex = ((int)(resources.GetObject("m_btnReplace.TabIndex")));
        this.m_btnReplace.Text = resources.GetString("m_btnReplace.Text");
        // 
        // m_lblHowToHandle
        // 
        this.m_lblHowToHandle.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHowToHandle.Location")));
        this.m_lblHowToHandle.Name = "HowToHandle";
        this.m_lblHowToHandle.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHowToHandle.Size")));
        this.m_lblHowToHandle.TabIndex = ((int)(resources.GetObject("m_lblHowToHandle.TabIndex")));
        this.m_lblHowToHandle.Text = resources.GetString("m_lblHowToHandle.Text");
        // 
        // The Form
        // 
        this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
        this.ClientSize = new System.Drawing.Size(421, 154);
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnCancel,
                        this.m_btnIntersect,
                        this.m_btnMerge,
                        this.m_btnReplace,
                        this.m_lblHowToHandle,
                        this.m_lblDes});
        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
        this.MaximizeBox = false;
        this.MinimizeBox = false;
        this.Name = "Win32Form1";
        this.ResumeLayout(false);
        this.Text = m_sPermissionName + " " + CResourceStore.GetString("CDuplicatePermissionDialog:PermExists");
        this.Icon = null;

        // Set up the event handlers
        m_btnCancel.Click += new EventHandler(onCancelClick);
        m_btnIntersect.Click += new EventHandler(onIntersectClick);
        m_btnMerge.Click += new EventHandler(onMergeClick);
        m_btnReplace.Click += new EventHandler(onReplaceClick);
    }// SetupControls

    void onCancelClick(Object o, EventArgs e)
    {
        m_nChoice = CANCEL;
        this.DialogResult = System.Windows.Forms.DialogResult.Cancel;
    }// onCancelClick
    
    void onIntersectClick(Object o, EventArgs e)
    {
        m_nChoice = INTERSECT;
        this.DialogResult = System.Windows.Forms.DialogResult.OK;
    }// onCancelClick

    void onMergeClick(Object o, EventArgs e)
    {
        m_nChoice = MERGE;
        this.DialogResult = System.Windows.Forms.DialogResult.OK;
    }// onCancelClick

    void onReplaceClick(Object o, EventArgs e)
    {
        m_nChoice = REPLACE;
        this.DialogResult = System.Windows.Forms.DialogResult.OK;
    }// onCancelClick
    
}// class CDuplicatePermissionDialog

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cdata.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CData.cs
//
// This implements the IComponentData, ISnapinHelp2, and IExtendPropertySheet
// MMC interfaces.
//
// Its GUID is {1270e004-f895-42be-8070-df90d60cbb75}
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Collections;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Drawing;


[Guid("1270e004-f895-42be-8070-df90d60cbb75")] 
public class CData : IComponentData, IExtendPropertySheet2, IExtendContextMenu
{
    private ArrayList           m_Component;        // The IComponent object
    private IConsole2           m_ucsole;          // A reference to the MMC console
    private IConsoleNameSpace2  m_ucsoleNameSpace; // A reference to the MMC console namespace
    private static CNode        m_rn;

    //-------------------------------------------------
    // CData - Constructor
    //
    // The constructor is responsible for constructing
    // the nodes that will be displayed in the snapin
    //-------------------------------------------------	
    public CData()
    {
        if (m_rn != null)
        {
            throw new Exception(CResourceStore.GetString("CData::OnlyOneInstanceofSnapin"));
        }
        
        // First, null out all the member variables
        m_Component = new ArrayList();
        m_ucsole = null;
        m_ucsoleNameSpace = null;
        
        m_rn = new CRootNode();
        // Register ourselves with the Node Manager
        CNodeManager.Data = this;

        // Let's generate our own computer node
        CNodeManager.Init();
        CNodeManager.RootNodeCookie = CNodeManager.AddNode(ref m_rn);
    
    }// CData

    //-------------------------------------------------
    // Initialize
    //
    // This function is responsible for recieving the
    // MMC Console interface, and I also have it inserting
    // all the images MMC will need to display the snapin
    //-------------------------------------------------	
    public void Initialize(Object pUnknown)
    {
        try
        {
            m_ucsole          = (IConsole2)pUnknown;
            m_ucsoleNameSpace = (IConsoleNameSpace2)pUnknown;
        }
        catch(Exception)
        {
            // If this fails, it's because we're not on MMC 1.2 or later
            MessageBox(0, 
                        CResourceStore.GetString("CData:RequireVersionofMMC"),
                        CResourceStore.GetString("CData:RequireVersionofMMCTitle"),
                        MB.ICONEXCLAMATION);
            return;                        
        }

        
        CNodeManager.Console = m_ucsole;
        IntPtr hWnd;
        m_ucsole.GetMainWindow(out hWnd);
        CNodeManager.MMChWnd = hWnd;

        CNodeManager.CNamespace = m_ucsoleNameSpace;

        // Now we'll add the images we need for the snapin
        IImageList il=null;
        m_ucsole.QueryScopeImageList(out il);

        // ALL icons that need to be displayed in the lefthand pane MUST be
        // 'registered' here

        if (il != null)
        {

            il.ImageListSetIcon(CResourceStore.GetHIcon("NETappicon_ico"), 
                                CResourceStore.GetIconCookie("NETappicon_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("mycomputer_ico"), 
                                CResourceStore.GetIconCookie("mycomputer_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("configassemblies_ico"), 
                                CResourceStore.GetIconCookie("configassemblies_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("enterprisepolicy_ico"), 
                                CResourceStore.GetIconCookie("enterprisepolicy_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("machinepolicy_ico"), 
                                CResourceStore.GetIconCookie("machinepolicy_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("userpolicy_ico"), 
                                CResourceStore.GetIconCookie("userpolicy_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("codegroups_ico"), 
                                CResourceStore.GetIconCookie("codegroups_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("singlecodegroup_ico"), 
                                CResourceStore.GetIconCookie("singlecodegroup_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("customcodegroup_ico"), 
                                CResourceStore.GetIconCookie("customcodegroup_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("permissionsets_ico"), 
                                CResourceStore.GetIconCookie("permissionsets_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("permissionset_ico"), 
                                CResourceStore.GetIconCookie("permissionset_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("policyassemblies_ico"), 
                                CResourceStore.GetIconCookie("policyassemblies_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("assemblies_ico"), 
                                CResourceStore.GetIconCookie("assemblies_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("sharedassemblies_ico"), 
                                CResourceStore.GetIconCookie("sharedassemblies_ico"));
                            
            il.ImageListSetIcon(CResourceStore.GetHIcon("remoting_ico"), 
                                CResourceStore.GetIconCookie("remoting_ico"));
                            
            il.ImageListSetIcon(CResourceStore.GetHIcon("security_ico"), 
                                CResourceStore.GetIconCookie("security_ico"));
                            
            il.ImageListSetIcon(CResourceStore.GetHIcon("applications_ico"), 
                                CResourceStore.GetIconCookie("applications_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("application_ico"), 
                                CResourceStore.GetIconCookie("application_ico"));

            il.ImageListSetIcon(CResourceStore.GetHIcon("readonlypolicy_ico"), 
                                CResourceStore.GetIconCookie("readonlypolicy_ico"));

        }
    }// Initialize

    //-------------------------------------------------
    // CreateComponent
    //
    // This function creates the component object and
    // passes it back to the MMC
    //-------------------------------------------------	
	public void CreateComponent(out IComponent ppComponent)
	{

        CComponent c = new CComponent(this);
        m_Component.Add(c);

        // We could be called here multiple times, especially when the user loads up
        // the snapin via MMC and then does a bunch of 'New Window Here' calls.

   	    ppComponent = c;
   	    CNodeManager.Component = c;
   	}// CreateComponent

    //-------------------------------------------------
    // Notify
    //
    // This notify function is much less complex than
    // the notify function found in CComponent.
    // Its main responsiblity is to insert data items into
    // the console namespace when requested.
    //-------------------------------------------------	
	public int Notify(IDataObject lpDataObject, uint aevent, IntPtr arg, IntPtr param)
	{
        try
        {
	
        CDO test= (CDO)lpDataObject;
 
        switch(aevent)
        {
            // If a data item is expanding, we need to tell MMC about it's children.
            // Note, this case doesn't necessarily mean the data item is expanding
            // visually.... MMC is just requesting information about it.
            case MMCN.EXPAND:
           
                // See if we're expanding the item (as opposed to collapsing it)
                if ((int)arg > 0)
                    test.Node.onExpand((int)param);
                break;

            case MMCN.RENAME:
                return test.Node.onRename(Marshal.PtrToStringUni(param));

            case MMCN.DELETE:
                return test.Node.onDelete(null);

                
            default:
                // We don't support any other messages
                return HRESULT.S_FALSE;
        }
        }
        catch(Exception)
        {
            // There's some sort of failure here. Rather than letting MMC
            // deal with the error (which could mean a crash) let's just swallow
            // the exception and cross our fingers.
        }


        return HRESULT.S_OK;
	}// Notify

    //-------------------------------------------------
    // Destroy
    //
    // This cleans up whatever needs to be cleaned up.
    // Normally, this would be used to release any interfaces
    // we had that traced back to the console. We can do this
    // by removing any references we have to the interfaces...
    //-------------------------------------------------
    public void Destroy()
    {
        if(m_Component != null)
        {
           CNodeManager.Shutdown();
           CResourceStore.Shutdown();
           CHTMLFileGen.Shutdown();
           CCommandHistory.Shutdown();
           m_Component = null;
           m_rn = null;
        }

        if ((m_ucsole != null)&&(Marshal.IsComObject(m_ucsole)))
           Marshal.ReleaseComObject(m_ucsole);
    }// Destroy

    //-------------------------------------------------
    // QueryDataObject
    //
    // When MMC wants a data object for a specific cookie,
    // this function will be called.
    //-------------------------------------------------
    public void QueryDataObject(int cookie, uint type, out IDataObject ppDataObject)
    {
        CNode node = CNodeManager.GetNode(cookie);
        if (node == null)
            node = m_rn;
        ppDataObject = new CDO(node); 
    }// QueryDataObject

    //-------------------------------------------------
    // GetDisplayInfo
    //
    // This function is called by MMC whenever it needs to
    // display a node in the scope pane. 
    //-------------------------------------------------
    public void GetDisplayInfo(ref SCOPEDATAITEM sdi)
    {

        // First let's find this node we want info on....
        CNode NodeWeWant = CNodeManager.GetNode((int)sdi.lParam);

        NodeWeWant.GetDisplayInfo(ref sdi);
    }// GetDisplayInfo

   
   //-------------------------------------------------
   // CompareObjects
   //
   // This function will compare two data objects. In this
   // snapin, if the cookies are identical for each data object,
   // then the items are the same
   //-------------------------------------------------
   public int CompareObjects(IDataObject lpDataObjectA, IDataObject lpDataObjectB)
   {
        CDO doItem1, doItem2;
        // These data items should be CDO's in disguise.....
        doItem1 = (CDO)lpDataObjectA;
        doItem2 = (CDO)lpDataObjectB;
        
        if (doItem1.Node.Cookie != doItem2.Node.Cookie)
        {
            // These are different objects. We need to return S_FALSE
           return HRESULT.S_FALSE;
        }

        return HRESULT.S_OK;
    }// CompareObjects

    //-------------------------------------------------------
    // Methods to extend IContextMenu
    //-------------------------------------------------------

    //-------------------------------------------------
    // AddMenuItems
    //
    // This function allows us to add items to the context menus
    //-------------------------------------------------
    public void AddMenuItems(IDataObject piDataObject, IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {
        // The piDataObject is really a CDO is disguise....
        CDO item = (CDO)piDataObject;

        item.Node.AddMenuItems(ref piCallback, ref pInsertionAllowed, item.Data);
   
    }// AddMenuItems

    //-------------------------------------------------
    // Command
    //
    // This function is called whenever an item that we
    // added to the context menus is called
    //-------------------------------------------------
    public void Command(int lCommandID, IDataObject piDataObject)
    {
        CDO item = (CDO)piDataObject;
        CCommandHistory.CommandExecuted(item, lCommandID);
        if (item.Data != null)
            item.Node.MenuCommand(lCommandID, item.Data);
        else
            item.Node.MenuCommand(lCommandID);
    }// Command


    //-------------------------------------------------------
    // Stuff for IExtendPropertySheet2 - This will only be
    // called for stuff in the scope view
    //-------------------------------------------------------

    //-------------------------------------------------
    // CreatePropertyPages
    //
    // MMC calls this function when it wants a property
    // page for a specified node.
    //-------------------------------------------------
    public int CreatePropertyPages(IPropertySheetCallback lpProvider, IntPtr handle, IDataObject lpIDataObject)
    {

	    // This is really a CDO in disguise
        CDO victim = (CDO)lpIDataObject;

        // See if I really need to do this....
        if (m_ucsole != null)
        {
            IPropertySheetProvider psp = (IPropertySheetProvider)m_ucsole;

            if (psp.FindPropertySheet(victim.Node.Cookie, null, victim) == HRESULT.S_OK)
                return HRESULT.S_FALSE;
        }
        // Let's see if this node has property pages
        if (victim.Node != null && victim.Node.HavePropertyPagesCreate)
        {
            // If we've fired up a wizard, then that command has already been
            // logged (either from the menu command or the history list command.
            // We don't need to record this any further.
            if (!(victim.Node is CWizard))
                CCommandHistory.CommandExecuted(victim, -1);
            victim.Node.CreatePropertyPages(lpProvider, handle);

            return HRESULT.S_OK;
        }
        // We don't have any property pages, let's return false
        else
            return HRESULT.S_FALSE;
    }// CreatePropertyPages

    //-------------------------------------------------
    // QueryPagesFor
    //
    // MMC calls this function once at the beginning when
    // everything is being initialized, asking if we have any
    // property pages. If we tell it we don't, we can never
    // have any property pages in our snapin. (It will never
    // call CreatePropertyPages)
    //-------------------------------------------------
    public int QueryPagesFor(IDataObject lpDataObject)
    {
        // This snapin does have property pages, so we should return S_OK
        // If the snapin didn't have any property pages, then we should return S_FALSE

        return HRESULT.S_OK;
    }// QueryPagesFor

    public int GetWatermarks(IDataObject lpIDataObject, out IntPtr lphWatermark, out IntPtr lphHeader, out IntPtr lphPalette, out int bStretch)
    {
        IntPtr hBitmap = CResourceStore.CreateWindowBitmap(49,
                                                           49);

        lphWatermark = hBitmap;
        lphHeader = hBitmap;
        lphPalette = IntPtr.Zero;
        bStretch = 0;

        return HRESULT.S_OK;
       }// GetWatermarks

    

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, uint type);
}// class CData

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cconfigstore.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CConfigStore.cs
//
// This will handle storage of all configuration information.
// It deals with the registry, Security Settings, and information
// stored in XML Files
//
// The big thing is that XML tags are case-insensitive, so we convert
// all our strings to lower case before we compare them.
//
// How to use:
//
// The config store exports two very simple APIs... 
//
// (bool) SetSetting((String) Setting name, (Object) Value)
//
// SetSetting returns whether it was able to make the changes
//
// (Object) GetSetting((String) Setting name)
//
// The config store is responsible for routing to the appropriate data source
// to get/set the data.
//
// With all settings, a ',' that be appended to the end of the setting with a config
// file following to get a setting from the non-global XML file.
//
// For example:
//
// GetSetting("GarbageCollector");
//
// will return the setting for the garbage collector from the runtime XML file.
//
// GetSetting("GarbageCollector,c:\\c#\\myapp.cfg");
//
// will return the setting for the garbage collector from the myapp.cfg XML file.
//
// Below is a list of all the config settings that can be obtained, and how to use
// each one.
//
// Show Security Policy Changed Dialog
// --------------------------------
// Get:
//      GetSetting("DisplaySecurityChangedDialog")
// Returns:
//      A string, either "yes" or "no"
// Set:
//      SetSetting("DisplaySecurityChangedDialog", String (either yes or no))
//
// NOTE: This is an Admin UI setting only. There is no enforcement to ensure "yes" or "no" are the actual strings
//
// Remoting Channels
// -----------------
// Get:
//      GetSetting("RemotingChannels")
// Returns:
//      An ArrayList of  RemotingChannel classes
// Set:
//      SetSetting("RemotingChannels", an array list of RemotingChannel classes)
//
// NOTE: Currently, we can only change the attribute values for a channel. We can't
// add new channels or new attributes
//
// Exposed Types (more remoting junk)
// ----------------------------------
// Get:
//      GetSetting("ExposedTypes")
// Returns:
//      An ExposedTypes class
// Set:
//      SetSetting("ExposedTypes", an ExposedTypes class)
//
// NOTE: Right now, we can only change the Lease Time, Renew On Call, and URI fields
//
// Remoting Applications
// ---------------------
// Get:
//      GetSetting("RemotingApplications")
// Returns:
//      An ArrayList of RemotingApplicationInfo classes
// Set:
//      SetSetting("RemotingApplications", ArrayList of RemotingApplicationInfo classes)
//
// NOTE: Right now, we only change URLs in the XML file
//
// GarbageCollector
// ----------------
// Get:
//      GetSetting("GarbageCollector")
// Returns 
//      Either "enabled" or "disabled"
// Set:
//      SetSetting("GarbageCollector", "enabled" or "disabled")
//
// NOTE: There is no validation to verify we are Getting/Setting the string 
// 'enabled' or 'disabled'. 
//
// ConfiguredAssemblies
// --------------------
//
// Get:
//      GetSetting("ConfiguredAssemblies");
// Return
//      An ArrayList of BindingRedirInfo structures
//
// Set:
//      SetSetting("ConfiguredAssemblies", BindingRedirInfo structure)
//
// Delete:
//      SetSetting("ConfiguredAssembliesDelete", BindingRedirInfo structure)
//  
//
// AppConfigFiles
// --------------
//
// Get:
//      GetSetting("AppConfigFiles");
// Return:
//      An ArrayList of AppFiles structures
// Set:
//      SetSetting("AppConfigFiles", AppFiles structure);
//
// NOTE: a ',' cannot be used in this instance to direct to a different
// config file. This information is taken out of the UI's own config file,
// and is CLR independent.
//
// BindingMode
// -----------
//
// Get:
//      GetSetting("BindingMode,<app config file>");
// Return:
//      Either "safe" or "normal"
// Set:
//      SetSetting("BindingMode,<app config file>", "safe" or "normal");
//
// NOTE: The AppConfig Filename must be specified here, for this setting is only
// valid per app. Also, no validation for 'safe' or 'normal'
//
// SearchPath
// -----------
//
// Get:
//      GetSetting("SearchPath,<app config file>");
// Return:
//      a String containing the search path
// Set:
//      SetSetting("BindingMode,<app config file>", (string) Search Path);
//
// NOTE: The AppConfig Filename must be specified here, for this setting is only
// valid per app. 
//
//
// VerifierOff
// -----------
//
// Get:
//      GetSetting("VerifierOff");
// Return:
//      Either 1 if the Verifier is off, or either null or 0 if it is on.
// Set:
//      SetSetting("VerifierOff", 0 or 1);
//   
//
// SecurityEnabled
// ---------------
//
// Get:
//      GetSetting("SecurityEnabled");
// Return:
//      Either true is security is enabled or false if it's not.
// Set:
//      SetSetting("SecurityEnabled", true or false);
// 
// PublisherPolicy
// ---------------
//
// Get:
//      GetSetting("PublisherPolicyFor<Assembly Name>,<PublicKeyToken>")
// Returns:
//      A bool.
// Set:
//      SetSetting("PublisherPolicyFor<Assembly Name>,<PublicKeyToken>", bool)
//
// BindingPolicy
// -------------
//
// Get:
//      GetSetting("BindingPolicyFor<Assembly Name>,<PublicKeyToken>")
// Returns:
//      A BindingPolicy structure.
// Set:
//      SetSetting("BindingPolicyFor<Assembly Name>,<PublicKeyToken>", BindingPolicy structure)
//
// Note: Setting the binding policy will replace all the stored binding policies associated
// with the assembly name and public key token passed in.
//
// CodeBases
// ---------
// Get:
//      GetSetting("CodeBasesFor<Assembly Name>,<PublicKeyToken>");
// Returns:
//      A CodebaseLocations structure.
// Set:
//      SetSetting("CodeBasesFor<Assembly Name>,<PublicKeyToken>", CodebaseLocations structure)
//
// Note: Setting the codebases will replace all the stored codebases associated with the 
// assembly name and public key token with the codebases passed in on the set. So don't think 
// of this set as adding a codebase... in reality, the codebases are being replaced.
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using Microsoft.Win32;
using System.Runtime.InteropServices;
using System.Security;
using System.Xml;
using System.IO;
using System.Collections;
using System.Collections.Specialized;
using System.Reflection;
using System.Globalization;

internal class CConfigStore
{
    // This array consists of two dimensions... the first element is the config name, and
    // the second is the subkey the setting belongs in. We automatically assume everything
    // is stored under HKLM, but if we want a setting under HKCU, put a $ in front of the
    // subkey
    static private String[,] SettingsForRegistry = { 
                            {"VerifierOff", "$Software\\Microsoft\\.NETFramework"},
                            {"GlobalSettings", "Software\\Microsoft\\.NETFramework\\Security\\policy"}
                                                   };

    // This array holds all the settings that the Security APIs deal with
    static private String[] SettingsForSecurity = {"SecurityEnabled"};

    // This array holds the location of various settings in the XML.
    // The 3 fields are
    // 1) Name of the setting
    // 2) Location of XML under the Configuration/System element
    // 3) The attribute name that holds the setting
    static private String[,] LocationOfXMLValues = {
                {"GarbageCollector", "configuration/runtime/gcConcurrent", "enabled"},
                {"ConfiguredAssemblies", "configuration/runtime/assemblyBinding:xmlns=urn:schemas-microsoft-com:asm.v1", ""},
                {"AppConfigFiles","configuration/applications", ""},
                {"BindingMode", "configuration/runtime/assemblyBinding:xmlns=urn:schemas-microsoft-com:asm.v1/publisherPolicy", "apply"},
                {"SearchPath", "configuration/runtime/assemblyBinding:xmlns=urn:schemas-microsoft-com:asm.v1/probing", "privatePath"},
                {"RequiredRuntimeVersion", "configuration/startup/requiredRuntime", "version"},
                {"ShowHTMLForGenApp", "configuration/HTMLViews/GenApp", "ShowHTML"},
                {"ShowHTMLForSharedAssem", "configuration/HTMLViews/SharedAssem", "ShowHTML"},
                {"ShowHTMLForFullTrustAssem", "configuration/HTMLViews/FullTrustAssem", "ShowHTML"},
                {"ShowHTMLForConfigAssem", "configuration/HTMLViews/ConfigAssem", "ShowHTML"},
                {"ShowHTMLForDependAssem", "configuration/HTMLViews/DependAssem", "ShowHTML"},
                {"ShowHTMLForPermissionSet", "configuration/HTMLViews/SinglePermissionSet", "ShowHTML"},
                {"DisplaySecurityChangedDialog", "configuration/Misc/SecurityChangedDialog", "ShowDialog"},
                {"CommandHistory", "configuration/CommandHistory", ""},
                {"ConsumerCommands", "configuration/commands", ""},
                {"RemotingApplications", "configuration/system.runtime.remoting/application", ""},
                {"ExposedTypes", "configuration/system.runtime.remoting/application/service", ""},
                {"RemotingChannels", "configuration/system.runtime.remoting/application/channels", ""}

               };
    // This holds the default values for all XML data
    static private String[,] DefaultXMLValues = { {"GarbageCollector", "true"},
                                                  {"BindingMode", "yes"},
                                                  {"SearchPath", ""},
                                                  {"RequiredRuntimeVersion", "none"},
                                                  {"ShowHTMLForGenApp", "yes"},
                                                  {"ShowHTMLForSharedAssem", "yes"},
                                                  {"ShowHTMLForFullTrustAssem", "yes"},
                                                  {"ShowHTMLForConfigAssem", "yes"},
                                                  {"ShowHTMLForDependAssem", "yes"},
                                                  {"ShowHTMLForPermissionSet", "yes"},
                                                  {"DisplaySecurityChangedDialog", "yes"}
                                                };

    // This holds the name of the XML file we'll be writing too. It should be updated 
    // each time there is a call which will read/write from the XML file, since the
    // file location could change while the UI is running.
    static private String m_sXMLFilename = null;


    // Allows us to create our own XML Navigator
    internal class XMLData
    {
        internal XmlDocument       xDoc;
        internal XmlElement     xCurrentElement;
        internal XmlAttribute       xCurrentAttribute;
        internal int                nCurrentAttributeIndex;
    }// XMLData

    // Allows us to do a search for a specific element based on
    // conditions
    private class ElementConditions
    {
        internal ElementConditions(String ElementName)
        {
            sElementName = ElementName;
            sAttributeNames = null;
            sAttributeValues = null;
        }// ElementConditions

        internal ElementConditions(String ElementName, StringCollection scNames, StringCollection scValues)
        {
            sElementName = ElementName;
            SetAttributes(scNames, scValues);
        }// ElementConditions

        internal void SetAttributes(StringCollection scNames, StringCollection scValues)
        {
            sAttributeNames = new String[scNames.Count];
            scNames.CopyTo(sAttributeNames, 0);
            
            sAttributeValues = new String[scValues.Count];
            scValues.CopyTo(sAttributeValues, 0);
        }// SetAttributes
        
        internal String sElementName;
        internal String[] sAttributeNames;
        internal String[] sAttributeValues;
    }// ElementConditions

    private const int FOUNDATTRIBUTE=0;
    private const int CREATEDATTRIBUTE=1;
    private const int NOATTRIBUTE=2;
    
    private const int FOUNDELEMENT=3;
    private const int CREATEDELEMENT=4;
    private const int NOELEMENT=5;

    //-------------------------------------------------
    // IsSettingInRegistry
    //
    // This function will determine if a setting is
    // placed in the registry
    //-------------------------------------------------
    static private int IsSettingInRegistry(String s)
    {
        // We need to divide by two since this is a 2d array and the second dimension
        // is of length 2
        int iLen = SettingsForRegistry.Length/2;
        for(int i=0; i<iLen; i++)
            if (SettingsForRegistry[i,0].Equals(s))
                return i;

        // We didn't find it... 
        return -1;
    }// IsSettingInRegistry

    //-------------------------------------------------
    // IsSettingInSecurity
    //
    // This function will determine if a supplied setting
    // is controlled by the security APIs
    //-------------------------------------------------
    static private bool IsSettingInSecurity(String s)
    {
        int iLen = SettingsForSecurity.Length;
        for(int i=0; i<iLen; i++)
            if (SettingsForSecurity[i].Equals(s))
                return true;

        // We didn't find it
        return false;
    }// isSettingInSecurity

    //-------------------------------------------------
    // IsSettingHandledSpecially
    //
    // This function will determine if a supplied setting
    // is controlled by the security APIs
    //-------------------------------------------------
    static private bool IsSettingHandledSpecially(String s)
    {
        if (s.Length > 18 && s.Substring(0,18).Equals("PublisherPolicyFor"))
            return true;
        if (s.Length > 16 && s.Substring(0,16).Equals("BindingPolicyFor"))
            return true;
        if (s.Length > 12 && s.Substring(0,12).Equals("CodeBasesFor"))
            return true;
        if (s.Length >=20 && s.Substring(0, 20).Equals("ConfiguredAssemblies"))
            return true;
        if (s.Equals("AppConfigFiles"))
            return true;
        if (s.Equals("RemoveAppConfigFile"))
            return true;
        if (s.Equals("CommandHistory"))
            return true;
        if (s.Equals("ConsumerCommands"))
            return true;
        if (s.Length >19 && s.Substring(0, 20).Equals("RemotingApplications"))
            return true;
        if (s.Length > 11 && s.Substring(0,12).Equals("ExposedTypes"))
            return true;
        if (s.Length > 15 && s.Substring(0,16).Equals("RemotingChannels"))
            return true;
        // This isn't a special setting
        return false;
    }// isSettingInSecurity


    //-------------------------------------------------
    // IsSettingStoredInUIXML
    //
    // This function will check to see if a setting is
    // stored in the UI XML file
    //-------------------------------------------------
    static private bool IsSettingStoredInUIXML(String s)
    {
        if (s.Length > 11 && s.Substring(0,11).Equals("ShowHTMLFor"))
            return true;
        else if (s.Equals("DisplaySecurityChangedDialog"))
            return true;
        return false;
    }// IsSettingStoredInUIXML


    //-------------------------------------------------
    // GetSecuritySetting
    //
    // This function will return a setting managed by
    // the security APIs
    //-------------------------------------------------
    static private Object GetSecuritySetting(String MachineName, String s)
    {
        if (s.Equals("SecurityEnabled"))
        {
            Object val=0;
            int iIndex = IsSettingInRegistry("GlobalSettings");
            
            RegistryKey regKey = GetRegKey(MachineName, iIndex , false);
            if (regKey == null)
                return true;
            val = regKey.GetValue(SettingsForRegistry[iIndex,0]);
            if (val == null)
                return true;
            return (((byte[])val)[3]&0x1F) == 0;
        }
        throw new Exception("I can't handle the security setting " + s);
    }// GetSecuritySetting

    //-------------------------------------------------
    // SetSecuritySetting
    //
    // This function will 'write' out a setting that is
    // managed by security APIs
    //-------------------------------------------------
    static private bool SetSecuritySetting(String MachineName, String s, Object val)
    {
        if (s.Equals("SecurityEnabled"))
        {
            int iIndex = IsSettingInRegistry("GlobalSettings");
            
            RegistryKey regKey = GetRegKey(MachineName, iIndex , true);
            if (regKey == null)
                return false;
                
            Object o = regKey.GetValue(SettingsForRegistry[iIndex,0]);

            byte[] bData = new byte[4];
        
            if (o != null)
                bData = (byte[])o;
           
            // Zero out the last byte to turn on security
            if ((bool)val)
                bData[3] = 0;
            // Place a 1F in the last byte to turn off security.
            else
                bData[3] = (byte)(bData[3] | 0x1F);

            regKey.SetValue(SettingsForRegistry[iIndex,0], bData);
            return true;
        }
        return false;
    }// SetSecuritySetting

    //-------------------------------------------------
    // GetBaseRegKey
    //
    // This function will get the base registry key needed,
    // whether it be on the local machine or on a remote
    // machine
    //-------------------------------------------------
    static private RegistryKey GetBaseRegKey(String MachineName, RegistryKey kbase)
    {
        if (MachineName == null)
            return kbase;
        else
        {
            if (kbase == Registry.LocalMachine)
                return RegistryKey.OpenRemoteBaseKey(RegistryHive.LocalMachine, MachineName);
            else if (kbase == Registry.CurrentUser)
                return RegistryKey.OpenRemoteBaseKey(RegistryHive.CurrentUser, MachineName);
        }
        throw new Exception("Ack! Programming Error! I don't know what to do with" + kbase);
    }// GetBaseRegKey

    //-------------------------------------------------
    // GetRegKey
    //
    // After a function has obtained a base registry key,
    // this function can be used to drill down to a subkey
    //-------------------------------------------------
    static private RegistryKey GetRegKey(String MachineName, int iIndex, bool fWrite)
    {
        String subKey = SettingsForRegistry[iIndex,1];
        RegistryKey regKey = Registry.LocalMachine;
        RegistryKey regSubKey = null;
        // If a $ is the first character in this subkey, we should open the 
        // HKCU subkey... otherwise, we will default to the HKLM
        if (subKey[0] == '$')
        {
            regKey = Registry.CurrentUser;
            subKey = subKey.Remove(0, 1);
        }
        regKey = GetBaseRegKey(MachineName, regKey);

        regSubKey = regKey.OpenSubKey(subKey, fWrite);

        if (regSubKey == null && fWrite)
        {
            regSubKey = regKey.CreateSubKey(subKey);
            if (regSubKey == null)
                MessageBox(0,
                           String.Format(CResourceStore.GetString("CConfigStore:CantCreateRegKey"), subKey),
                           CResourceStore.GetString("CConfigStore:CantCreateRegKeyTitle"),
                           MB.ICONEXCLAMATION);
        }
            
        return regSubKey;  
    }// GetRegKey

    //-------------------------------------------------
    // GetSetting
    //
    // This function will be called to obtain a setting
    // on the local machine
    //-------------------------------------------------
    static internal Object GetSetting(String s)
    {
        // We'll just redirect this to the remote path
        return GetRemoteSetting(null, s);
    }// GetSetting

    //-------------------------------------------------
    // SetSetting
    //
    // This function will be called to write a setting
    // on the local machine
    //-------------------------------------------------
    static internal bool SetSetting(String s, Object val)
    {
        return SetRemoteSetting(null, s, val);
    }// SetSetting

    //-------------------------------------------------
    // GetRemoteSetting
    //
    // This function will obtain a setting on either a remote
    // or local machine
    //-------------------------------------------------
    static internal Object GetRemoteSetting(String MachineName, String s)
    {
        // First, let's determine who owns this setting
        int iIndex = IsSettingInRegistry(s);
        // Does the registry?
        if (iIndex != -1)
            return GetRegSetting(MachineName, iIndex);
        // Does security?
        else if (IsSettingInSecurity(s))
            return GetSecuritySetting(MachineName, s);
        // A special case?
        else if (IsSettingHandledSpecially(s))
            return GetSpecialSetting(MachineName, s);
        // Is it a setting stored in the UI XML File?
        else if (IsSettingStoredInUIXML(s))
            return GetXMLSettingInUIXML(MachineName, s);
        // It must be stored in the GenPurpose XML File
        else
            return GetXMLSetting(MachineName, s);
    }// GetRemoteSetting

    //-------------------------------------------------
    // SetRemoteSetting
    //
    // This function will write out a setting on either
    // a remote or local machine
    //-------------------------------------------------
    static internal bool SetRemoteSetting(String MachineName, String s, Object val)
    {
        // See who owns this setting
        int iIndex = IsSettingInRegistry(s);
        if (iIndex != -1)
            return SetRegSetting(MachineName, iIndex, val);
        else if (IsSettingInSecurity(s))
            return SetSecuritySetting(MachineName, s, val);
        // A special case?
        else if (IsSettingHandledSpecially(s))
            return SetSpecialSetting(MachineName, s, val);
        else if (IsSettingStoredInUIXML(s))
            return SetXMLSettingInUIXML(MachineName, s, val);
        // Has to be XML
        else
            return SetXMLSetting(MachineName, s, val);
    }// SetRemoteSetting

    //-------------------------------------------------
    // GetRegSetting
    //
    // This will obtain a setting from a registry - either
    // local or remote
    //-------------------------------------------------
    static private Object GetRegSetting(String Machine, int iIndex)
    {
        Object obj=null;
        RegistryKey regKey = GetRegKey(Machine, iIndex, false);
        if (regKey != null)
            obj = regKey.GetValue(SettingsForRegistry[iIndex,0]);
        return obj;
    }// GetRegSetting 

    //-------------------------------------------------
    // SetRegSetting
    //
    // This will write a setting from a registry - either
    // local or remote
    //-------------------------------------------------
    static private bool SetRegSetting(String Machine, int iIndex, Object val)
    {
        RegistryKey regKey = GetRegKey(Machine, iIndex, true);
        regKey.SetValue(SettingsForRegistry[iIndex,0], val);
        return true;
    }// SetRegSetting

    //-------------------------------------------------
    // GetXMLSettingInUIXML
    //
    // This function will retrieve standard XML info from
    // the UI's XML File
    //-------------------------------------------------
    static private Object GetXMLSettingInUIXML(String sMachineName, String sSetting)
    {
        SetXMLFilenameForUI(sMachineName);
        // Find the info on this tag
        int iLoc = GetLocationOfElement(sSetting);
        String sValue = ReadTag(LocationOfXMLValues[iLoc,1], LocationOfXMLValues[iLoc,2]);
        
        if (sValue == null)
            sValue = GetDefaultXMLValue(sSetting);
        return sValue;
    }// GetXMLSettingInUIXML

    //-------------------------------------------------
    // SetXMLSettingInUIXML
    //
    // This function will set standard XML info from
    // the UI's XML File
    //-------------------------------------------------
    static private bool SetXMLSettingInUIXML(String sMachineName, String sSetting, Object value)
    {
        SetXMLFilenameForUI(sMachineName);
        // Find the info on this tag
        int iLoc = GetLocationOfElement(sSetting);
        return WriteTag(LocationOfXMLValues[iLoc,1], LocationOfXMLValues[iLoc,2], (String)value);
    }// SetXMLSettingInUIXML

    //-------------------------------------------------
    // SetXMLSetting
    //
    // This will write a setting to the XML file
    //-------------------------------------------------
    static private bool SetXMLSetting(String sMachineName, String s, Object value)
    {
        // Check to see if we're adding this to a XML file other than the global one
        String[] args = s.Split(new char[] {','});
        if (args.Length > 1)
        {
            SetXMLFilenameForApp(sMachineName, args[1]);
            s = args[0];
        }
        else
            SetXMLFilename(sMachineName);

        // Find the info on this tag
        int iLoc = GetLocationOfElement(s);
        return WriteTag(LocationOfXMLValues[iLoc,1], LocationOfXMLValues[iLoc,2], (String)value);
    }// SetXMLSetting
    

    //-------------------------------------------------
    // GetXMLSetting
    //
    // This will get a setting from the XML
    //-------------------------------------------------
    static private Object GetXMLSetting(String sMachineName, String s)
    {
        // Check to see if we're adding this to a XML file other than the global one
        String[] args = s.Split(new char[] {','});
        if (args.Length > 1)
        {
            SetXMLFilenameForApp(sMachineName, args[1]);
            s = args[0];
        }
        else
            SetXMLFilename(sMachineName);

        String sSetting=null;

        // Find the info on this tag
        int iLoc = GetLocationOfElement(s);
        sSetting = ReadTag(LocationOfXMLValues[iLoc,1], LocationOfXMLValues[iLoc,2]);
        
        if (sSetting == null)
            sSetting = GetDefaultXMLValue(s);
            
        return sSetting;
    }// GetXMLSetting

    //-------------------------------------------------
    // GetDefaultXMLSetting
    //
    // This will get the default setting that would be
    // otherwise found in the XML. Note these default
    // settings need to be defined in the DefaultXMLValues
    // array declared at the top of this file
    //-------------------------------------------------
    static private String GetDefaultXMLValue(String s)
    {
        // Divided by 2 because of the multi-dim array
        int iLen = DefaultXMLValues.Length/2; 
        for(int i=0; i<iLen; i++)
            if (DefaultXMLValues[i,0].Equals(s))
                return DefaultXMLValues[i,1];

        // We don't know what this value is...
        throw new Exception("Ack! Programming Error! I don't know what the default XML value for " + s + " is!");
    }// GetDefaultXMLValue


    private static void SetXMLFilenameFromCommand(String sMachine, String sCommand)
    {
        // Check to see if we should use the global XML file or an app specific one
        String[] args = sCommand.Split(new char[] {','});
        if (args.Length > 1)
            SetXMLFilenameForApp(sMachine, args[1]);
        else
            SetXMLFilename(sMachine);
    }// SetXMLFilenameFromCommand


    //-------------------------------------------------
    // SetXMLFilename(String)
    //
    // This function will determine the global configuration
    // filename
    //-------------------------------------------------
    private static void SetXMLFilename(String sMachineName)
    {
        // We'll get the version of mscorlib that we're running with....
        // Mscorlib should be providing us with the int type
        Assembly ast = Assembly.GetAssembly(typeof(int));

        // This should give us something like
        // c:\winnt\complus\v1.x86chk\mscorlib.dll
        // We need to strip off the filename
        
        String sBase = ast.Location.Replace('/', '\\');
        String[] sPieces = sBase.Split(new char[] {'\\'});

        m_sXMLFilename = String.Join("\\", sPieces, 0, (sPieces.Length==1)?1:sPieces.Length-1);
       
        // Check to see if we need to add the '\'
        if (m_sXMLFilename[m_sXMLFilename.Length-1] != '\\')
            m_sXMLFilename += "\\";

        m_sXMLFilename += "Config\\machine.config";
    }// SetXMLFilename

    //-------------------------------------------------
    // SetXMLFilenameForUI
    //
    // This function will determine the location of the 
    // configuration file of the UI
    //-------------------------------------------------
    private static void SetXMLFilenameForUI(String sMachineName)
    {
        // Buid this filename
        m_sXMLFilename = Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData);

        // See if we need to add a '\' to the end of this
        if (m_sXMLFilename[m_sXMLFilename.Length-1] != '\\')
            m_sXMLFilename += "\\";

        // We'll get the version of mscorlib that we're running with....
        // Mscorlib should be providing us with the int type
        Assembly ast = Assembly.GetAssembly(typeof(int));
        String sVersion = ast.GetName().Version.ToString();

        // Put on the next directory info stuff
        m_sXMLFilename += "Microsoft\\.NET Framework Config\\v" + sVersion + "\\";

        // And last but not least, put in the name of the file

        m_sXMLFilename += "settings.xml";
    }// SetXMLFilenameForUI

    private static void SetXMLFilenameForCC(String sMachineName)
    {
        // We'll get the version of mscorlib that we're running with....
        // Mscorlib should be providing us with the int type
        Assembly ast = Assembly.GetAssembly(typeof(int));

        // This should give us something like
        // c:\winnt\complus\v1.x86chk\mscorlib.dll
        // We need to strip off the filename
        
        String sBase = ast.Location.Replace('/', '\\');
        String[] sPieces = sBase.Split(new char[] {'\\'});

        m_sXMLFilename = String.Join("\\", sPieces, 0, (sPieces.Length==1)?1:sPieces.Length-1);
       
        // Check to see if we need to add the '\'
        if (m_sXMLFilename[m_sXMLFilename.Length-1] != '\\')
            m_sXMLFilename += "\\";

        m_sXMLFilename += "ConsumerCommands.xml";
    }// SetXMLFilenameForCC

    //-------------------------------------------------
    // SetXMLFilenameForApp
    //
    // This function will determine the config filename
    // for a specific app
    //-------------------------------------------------
    private static void SetXMLFilenameForApp(String sMachineName, String sAppConfigName)
    {
        m_sXMLFilename = sAppConfigName;
    }// SetXMLFilenameForApp

    //-------------------------------------------------
    // WriteTag
    //
    // This function will write out a plain XML setting
    // with plain being defined as a single String value
    //-------------------------------------------------
    private static bool WriteTag(String sLocation, String sAttribute, String sValue)
    {
        // Pass true as the second argument to force the element to be created
        XMLData xData = MoveToElement(CreateElementConditions(sLocation), true);
        if (xData.xCurrentElement != null)
          if (MoveToAttribute(xData, sAttribute, true) != NOATTRIBUTE)
          {
            xData.xCurrentAttribute.Value = sValue;
            return SaveXML(xData);
          }
        return false;
    }// WriteTag

    //-------------------------------------------------
    // ReadTag
    //
    // This function will read a single string setting
    // from an XML file
    //-------------------------------------------------
    private static String ReadTag(String sLocation, String sAttribute)
    {
        XMLData xData = MoveToElement(CreateElementConditions(sLocation), false);
        if (xData.xCurrentElement != null)
          if (MoveToAttribute(xData, sAttribute, false) == FOUNDATTRIBUTE)
            return xData.xCurrentAttribute.Value;
        // We couldn't find the setting
        return null;
    }// ReadTag

    //-------------------------------------------------
    // GetLocationOfElement
    //
    // This function will run through the LocationOfXMLValues
    // array looking for the index of the given ConfigSetting
    //-------------------------------------------------
    private static int GetLocationOfElement(String s)
    {
        int iLen = LocationOfXMLValues.Length/3;
        for(int i=0; i<iLen; i++)
            if (LocationOfXMLValues[i,0].Equals(s))
                return i;
        return -1;

    }// GetLocationOfElement
    
    //-------------------------------------------------
    // SetSpecialSetting
    //
    // This function handles settings that need special
    // attention
    //-------------------------------------------------
    private static bool SetSpecialSetting(String MachineName, String s, Object val)
    {
        if (s.Length >19 && s.Substring(0,20).Equals("ConfiguredAssemblies"))
            return SetConfiguredAssemblies(MachineName, s, val);
        else if (s.Length > 16 && s.Substring(0, 16).Equals("BindingPolicyFor"))
            return SetBindingPolicy(MachineName, s.Substring(16), val);
        else if (s.Length > 12 && s.Substring(0, 12).Equals("CodeBasesFor"))
            return SetCodeBaseInfo(MachineName, s.Substring(12), val);
        else if (s.Length > 18 && s.Substring(0,18).Equals("PublisherPolicyFor"))
            return SetPublisherPolicy(MachineName, s.Substring(18), val);
        else if (s.Equals("AppConfigFiles"))
            return SetAppConfigFiles(MachineName, val);
        else if (s.Equals("RemoveAppConfigFile"))
            return RemoveAppConfigFile(MachineName, val);
        else if (s.Equals("CommandHistory"))
            return SetCommandHistory(MachineName, val);
        else if (s.Length >19 && s.Substring(0,20).Equals("RemotingApplications"))
            return SetRemotingApplications(MachineName, s, val);
        else if (s.Length > 11 && s.Substring(0,12).Equals("ExposedTypes"))
            return SetExposedTypes(MachineName, s, val);
        else if (s.Length > 15 && s.Substring(0,16).Equals("RemotingChannels"))
            return SetRemotingChannels(MachineName, s, val);

        else
            throw new Exception("I don't know about this special setting " + s);
    }// SetSpecialSetting

    //-------------------------------------------------
    // GetSpecialSetting
    //
    // This function handles settings that need special
    // attention
    //-------------------------------------------------
    private static Object GetSpecialSetting(String MachineName, String s)
    {
        if (s.Length >19 && s.Substring(0,20).Equals("ConfiguredAssemblies"))
            return GetConfiguredAssemblies(MachineName, s);
        else if (s.Equals("AppConfigFiles"))
            return GetAppConfigFiles(MachineName);
        else if (s.Equals("CommandHistory"))
            return GetCommandHistory(MachineName);
        else if (s.Equals("ConsumerCommands"))
            return GetConsumerCommands(MachineName);
        else if (s.Length >19 && s.Substring(0,20).Equals("RemotingApplications"))
            return GetRemotingApplications(MachineName, s);
        else if (s.Length > 11 && s.Substring(0,12).Equals("ExposedTypes"))
            return GetExposedTypes(MachineName, s);
        else if (s.Length >16 && s.Substring(0, 16).Equals("BindingPolicyFor"))
            return GetBindingPolicy(MachineName, s.Substring(16));
        else if (s.Length>12 && s.Substring(0, 12).Equals("CodeBasesFor"))
            return GetCodeBaseInfo(MachineName, s.Substring(12));
        else if (s.Length > 15 && s.Substring(0,16).Equals("RemotingChannels"))
            return GetRemotingChannels(MachineName, s);
        else if (s.Length > 18 && s.Substring(0,18).Equals("PublisherPolicyFor"))
            return GetPublisherPolicy(MachineName, s.Substring(18));
        else
            throw new Exception("I don't know about this special setting " + s);
    }// GetSpecialSetting

    private static bool SetRemotingChannels(String sMachineName, String sCommand, Object val)
    {
        SetXMLFilenameFromCommand(sMachineName, sCommand);

        int iLoc = GetLocationOfElement("RemotingChannels");
        
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Let's wipe out all the different channels in this tag
            ElementConditions ec = new ElementConditions("channel");
            // Let's delete all this element's binding policy children
            RemoveElementChildren(xData, ec);

            // Now, let's add back in all the remoting channels
            ArrayList al = (ArrayList)val;
            for(int i=0; i<al.Count; i++)
            {
                // Build up nodes for each item
                RemotingChannel rc = (RemotingChannel)al[i];
                ElementConditions ecChannel = new ElementConditions("channel", rc.scAttributeName, rc.scAttributeValue);
                InsertElement(xData, ecChannel);
                SetRemotingChannelsChildren(xData, rc);
                // InsertElement moves to the currently added element. Let's move back to the parent.
                MoveToParent(xData);
                
            }
        }
        // Save our changes
        return SaveXML(xData);
    }// SetRemotingChannels

    private static void SetRemotingChannelsChildren(XMLData xData, RemotingChannel rcParent)
    {
        for(int i=0; i<rcParent.alChildren.Count; i++)
        {
            RemotingChannel rc = (RemotingChannel)rcParent.alChildren[i];
            ElementConditions ecChannel = new ElementConditions(rc.sName, rc.scAttributeName, rc.scAttributeValue);
            InsertElement(xData, ecChannel);
            // Insert this guy's children
            SetRemotingChannelsChildren(xData, rc);
            MoveToParent(xData);
        }
    }// SetRemotingChannelsChildren


    private static String GetRemotingValue(RemotingChannel rc, String sAttribName)
    {
        // Let's dig through the Remoting channel, find the given attribute, and
        // return its value

        for(int i=0; i<rc.scAttributeName.Count; i++)
            if (rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals(sAttribName.ToLower(CultureInfo.InvariantCulture)))
                return rc.scAttributeValue[i];
                
        // If we got here, then we don't know about this attribute
        return null;
    }// GetRemotingValue

    private static Object GetRemotingChannels(String sMachineName, String sCommand)
    {
        ArrayList al = new ArrayList();

        SetXMLFilenameFromCommand(sMachineName, sCommand);

        int iLoc = GetLocationOfElement("RemotingChannels");
        
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Make sure we have child nodes
            if (MoveToFirstChild(xData))
            {
                ElementConditions ec = new ElementConditions("channel");

                while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
                {
                    RemotingChannel rc = new RemotingChannel();
                    // Suck in the first level of the remoting info
                    if (MoveToFirstAttribute(xData))
                    {
                        rc.scAttributeName.Add(xData.xCurrentAttribute.LocalName);
                        rc.scAttributeValue.Add(xData.xCurrentAttribute.Value);
                        while(MoveToNextAttribute(xData))
                        {
                            rc.scAttributeName.Add(xData.xCurrentAttribute.LocalName);
                            rc.scAttributeValue.Add(xData.xCurrentAttribute.Value);
                        }
                    }

                    // Now, go grab it's children
                    if (MoveToFirstChild(xData))
                    {
                        do
                        {
                            ReadRemotingChannelChildren(xData, rc);
                        }while(MoveToNextNode(xData));
                        MoveToParent(xData);
                    }
                    
                    al.Add(rc);
                    // Try to move onto the next element            
                    if (!MoveToNextNode(xData))
                        break;
                }
           }
        }
        return al;
    }// GetRemotingChannels

    private static void ReadRemotingChannelChildren(XMLData xData, RemotingChannel rcParent)
    {
        // Suck in all the info for this child
        RemotingChannel rcChild = new RemotingChannel();
        rcChild.sName = xData.xCurrentElement.LocalName;
        
        if (MoveToFirstAttribute(xData))
        {
            rcChild.scAttributeName.Add(xData.xCurrentAttribute.LocalName);
            rcChild.scAttributeValue.Add(xData.xCurrentAttribute.Value);
            while(MoveToNextAttribute(xData))
            {
                rcChild.scAttributeName.Add(xData.xCurrentAttribute.LocalName);
                rcChild.scAttributeValue.Add(xData.xCurrentAttribute.Value);
            }
        }
        if (MoveToFirstChild(xData))
        {
            do
            {
                ReadRemotingChannelChildren(xData, rcChild);
            }while(MoveToNextNode(xData));
            MoveToParent(xData);
        }
        rcParent.alChildren.Add(rcChild);
    }// ReadRemotingChannelChildren

    
    private static bool SetExposedTypes(String sMachineName, String sCommand, Object val)
    {
        SetXMLFilenameFromCommand(sMachineName, sCommand);

        int iLoc = GetLocationOfElement("ExposedTypes");
        
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Make sure we have child nodes
            if (MoveToFirstChild(xData))
            {
                // Let's start digging for stuff
                SwapExposedActivateObjectsValues(xData, (ExposedTypes)val);
                // Start looking at the children again from scratch
                MoveToParent(xData);
                MoveToFirstChild(xData);
                SwapExposedWellKnownObjectsValues(xData, (ExposedTypes)val);
            }
            // Save our changes
            return SaveXML(xData);
        }
        return false;
    }// SetExposedTypes

    private static void SwapExposedWellKnownObjectsValues(XMLData xData, ExposedTypes et)
    {
        ElementConditions ec = new ElementConditions("wellknown");

        while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
        {
            if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
            {
                // Find out what type this is...
                String[] sTypes = ((String)xData.xCurrentAttribute.Value).Split(new char[] {','});

                String sMode = "";
                if (MoveToAttribute(xData, "mode", false) == FOUNDATTRIBUTE)
                    sMode = xData.xCurrentAttribute.Value;
                    
                int nIndex=0;
                int nCount = et.scWellKnownType.Count;
                while(nIndex < nCount && 
                        ! (sTypes[0].Equals(et.scWellKnownType[nIndex]) &&
                           sTypes[1].Equals(et.scWellKnownAssem[nIndex]) &&
                           sMode.Equals(et.scWellKnownMode[nIndex])))
                    nIndex++;

                // See if we found a match
                if (nIndex < nCount)
                {
                    MoveToAttribute(xData, "objectUri", true);
                    xData.xCurrentAttribute.Value = et.scWellKnownUri[nIndex];
                }
            }
            // Try to move onto the next element            
            if (!MoveToNextNode(xData))
                break;
        }
    }// SwapExposedWellKnownObjectsValues

    private static void SwapExposedActivateObjectsValues(XMLData xData, ExposedTypes et)
    {
        ElementConditions ec = new ElementConditions("activated");

        while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
        {
            if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
            {
                // Find out what type this is...
                String[] sTypes = ((String)xData.xCurrentAttribute.Value).Split(new char[] {','});
                int nIndex=0;
                int nCount = et.scActivatedType.Count;
                while(nIndex < nCount && 
                        ! (sTypes[0].Equals(et.scActivatedType[nIndex]) &&
                           sTypes[1].Equals(et.scActivatedAssem[nIndex])))
                    nIndex++;

                // See if we found a match
                if (nIndex < nCount)
                {
                    if (MoveToFirstChild(xData))
                    {
                        // Go looking for the "lifetime" child tag of the activated tag
                        ElementConditions ec2 = new ElementConditions("lifetime");

                        if (MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
                        {
                            // Now set some lifetime stuff
                            MoveToAttribute(xData, "leaseTime", true);
                            xData.xCurrentAttribute.Value = et.scActivatedLease[nIndex];

                            MoveToAttribute(xData, "renewOnCallTime", true);
                            xData.xCurrentAttribute.Value = et.scActivatedRenew[nIndex];
                        }
                        MoveToParent(xData);
                    }
                }
            }
            // Try to move onto the next element            
            if (!MoveToNextNode(xData))
                break;
        }
    }// SwapExposedActivateObjectsValues


    private static Object GetExposedTypes(String sMachineName, String sCommand)
    {
        ExposedTypes et = new ExposedTypes();

        SetXMLFilenameFromCommand(sMachineName, sCommand);

        int iLoc = GetLocationOfElement("ExposedTypes");
        
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Make sure we have child nodes
            if (MoveToFirstChild(xData))
            {
                // Let's start digging for stuff
                DigForExposedActivateObjects(xData, ref et);
                // Start looking at the children again from scratch
                MoveToParent(xData);
                MoveToFirstChild(xData);
                DigForExposedWellKnownObjects(xData, ref et);
            }
        }
        return et;
    }// GetExposedTypes

    private static void DigForExposedActivateObjects(XMLData xData, ref ExposedTypes et)
    {
        ElementConditions ec = new ElementConditions("activated");

        while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
        {
            bool fGotLeaseTime=false;
            bool fGotRenew=false;
            bool fFoundName = false;

            if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
            {
                String[] sTypes = ((String)xData.xCurrentAttribute.Value).Split(new char[] {','});
                et.scActivatedType.Add(sTypes[0]);
                et.scActivatedAssem.Add(sTypes[1]);
            }

            if (MoveToAttribute(xData, "displayName", false) == FOUNDATTRIBUTE)
            {
                fFoundName=true;
                et.scActivatedName.Add(xData.xCurrentAttribute.Value);
            }
            // Now look for specific items for this activated object
            MoveToFirstChild(xData);
            ElementConditions ec2 = new ElementConditions("lifetime");

            if (MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
            {
                if (MoveToAttribute(xData, "leaseTime", false) == FOUNDATTRIBUTE)
                {
                    fGotLeaseTime = true;
                    et.scActivatedLease.Add((String)xData.xCurrentAttribute.Value);
                }

                if (MoveToAttribute(xData, "renewOnCallTime", false) == FOUNDATTRIBUTE)
                {
                    fGotRenew = true;
                    et.scActivatedRenew.Add((String)xData.xCurrentAttribute.Value);
                }
            }
            // Reset our position in the XML
            MoveToParent(xData);

            // Put in place holders if we need to
            if (!fGotLeaseTime)
                et.scActivatedLease.Add("");
            if (!fGotRenew)
                et.scActivatedRenew.Add("");
            if (!fFoundName)
                et.scActivatedName.Add("");

            // Try to move onto the next element            

            if (!MoveToNextNode(xData))
                break;
        }
    }// DigForExposedActivateObjects
    

    private static void DigForExposedWellKnownObjects(XMLData xData, ref ExposedTypes et)
    {
        ElementConditions ec = new ElementConditions("wellknown");

        while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
        {
            bool fGotMode=false;
            bool fGotType=false;
            bool fGotURI=false;
            bool fFoundName=false;
            
            // Gather info on this well known object
            if (MoveToAttribute(xData, "mode", false) == FOUNDATTRIBUTE)
            {
                fGotMode = true;
                et.scWellKnownMode.Add(xData.xCurrentAttribute.Value);
            }

            if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
            {
                fGotType = true;
                String[] sTypes = ((String)xData.xCurrentAttribute.Value).Split(new char[] {','});
                et.scWellKnownType.Add(sTypes[0]);
                et.scWellKnownAssem.Add(sTypes[1]);
            }

            if (MoveToAttribute(xData, "objectUri", false) == FOUNDATTRIBUTE)
            {
                fGotURI = true;
                et.scWellKnownUri.Add(xData.xCurrentAttribute.Value);
            }

            if (MoveToAttribute(xData, "displayName", false) == FOUNDATTRIBUTE)
            {
                fFoundName=true;
                et.scWellKnownObjectName.Add(xData.xCurrentAttribute.Value);
            }


            // Put in place holders if we need to
            if (!fGotMode)
                et.scWellKnownMode.Add("");
            if (!fGotType)
            {
                et.scWellKnownType.Add("");
                et.scWellKnownAssem.Add("");
            }
            if (!fGotURI)
                et.scWellKnownUri.Add("");
            if (!fFoundName)
                et.scWellKnownObjectName.Add("");
                
            // Try to move onto the next element            
            if (!MoveToNextNode(xData))
                break;
        }
    }// DigForExposedActivateObjects

    private static bool SetRemotingApplications(String sMachineName, String sCommand, Object val)
    {
        SetXMLFilenameFromCommand(sMachineName, sCommand);
        int iLoc = GetLocationOfElement("RemotingApplications");
        
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Create a condition for us to find our client stuff
            ElementConditions ec = new ElementConditions("client");

            // Let's wipe out all the client stuff and put them back in again
            RemoveElementChildren(xData, ec);

            // Why do we need to do all this? We can identify each client by either 
            // a display name or a URL. However, the display name is an optional attribute
            // and the user has the ability to change the URL... hence, he really have
            // no good way to identify client blocks of activated or well-known objects.


            // Now let's add all the client well-known objects back again
            for(int i=0; i<((ArrayList)val).Count; i++)
            {
                RemotingApplicationInfo rai = (RemotingApplicationInfo)((ArrayList)val)[i];
            
                // Add the 'client' tag
                StringCollection scNames = new StringCollection();
                StringCollection scValues = new StringCollection();

                if (rai.sURL != null && rai.sURL.Length > 0)
                {
                    scNames.Add("url");
                    scValues.Add(rai.sURL);
                }
                if (rai.sName != null && rai.sName.Length > 0)
                {
                    scNames.Add("displayName");
                    scValues.Add(rai.sName);
                }
                ElementConditions ecClient = new ElementConditions("client", scNames, scValues);

                InsertElement(xData, ecClient);
                // Let's add all the well-known objects
                for(int j=0; j<rai.scWellKnownAssembly.Count; j++)
                {
                    ElementConditions ecWKA = new ElementConditions("wellknown");
                    ecWKA.sAttributeNames = new String[] {"type", "url"};
                    // The type is the concation of the Object type and the assembly, seperated
                    // by a comma
                    ecWKA.sAttributeValues = new String[] {rai.scWellKnownObjectType[j] + "," + rai.scWellKnownAssembly[j],
                                                           rai.scWellKnownURL[j]};
                    InsertElement(xData, ecWKA);
                    // InsertElement puts the 'current' node on the added node. Back up so we're
                    // on the client tag
                    MoveToParent(xData);
                }

                // Now add all the client activated objects
                for(int j=0; j<rai.scActObjectType.Count; j++)
                {
                    ElementConditions ecCAO = new ElementConditions("activated");
                    ecCAO.sAttributeNames = new String[]{"type"};
                    ecCAO.sAttributeValues = new String[] {rai.scActObjectType[j] + "," + rai.scActAssembly[j]};

                    InsertElement(xData, ecCAO);
                    // InsertElement puts the 'current' node on the added node. Back up so we're
                    // on the client tag
                    MoveToParent(xData);
                }

                // Move up one so we can add another client block (if we need to)
                MoveToParent(xData);
            }

            // Save our changes
            return SaveXML(xData);
        }
        return false;
    }// SetRemotingApplications

    private static void SwapWellKnownObjectURLs(XMLData xData, RemotingApplicationInfo rai)
    {
        // Let's start digging for application-specific stuff
        if (MoveToFirstChild(xData))
        {
            ElementConditions ec = new ElementConditions("wellknown");

            while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
            {
                // Go looking for the type info
                if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
                {
                    String sTypeInfo = xData.xCurrentAttribute.Value;
                    // The typeinfo is actually the type and assembly, seperated by a comma
                    String[] sTypes = sTypeInfo.Split(new char[] {','});

                    // Ok, let's find the type/assembly info for this item....
                    int nIndex=0;
                    int nCount = rai.scWellKnownObjectType.Count;
                    while(nIndex < nCount && 
                          ! (sTypes[0].Equals(rai.scWellKnownObjectType[nIndex]) &&
                             sTypes[1].Equals(rai.scWellKnownAssembly[nIndex])))
                         nIndex++;
                    // See if we found a match
                    if (nIndex < nCount)
                    {
                        // Re-write this guy's URL
                        if (MoveToAttribute(xData, "url", false) == FOUNDATTRIBUTE)
                            xData.xCurrentAttribute.Value = rai.scWellKnownURL[nIndex];
                    }
                }
                
                if (!MoveToNextNode(xData))
                    break;
            }
        }
        MoveToParent(xData);
    }// SwapWellKnownObjectURLs

    private static Object GetRemotingApplications(String sMachineName, String sCommand)
    {
        ArrayList al = new ArrayList();

        SetXMLFilenameFromCommand(sMachineName, sCommand);

        int iLoc = GetLocationOfElement("RemotingApplications");
        
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Create a condition for us to find our client stuff
            ElementConditions ec = new ElementConditions("client");

            // Make sure we have child nodes
            if (MoveToFirstChild(xData))
            {
                // Let's start looking for remoting applications
                while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
                {
                    RemotingApplicationInfo rai = new RemotingApplicationInfo();

                    // If the url exists....
                    if (MoveToAttribute(xData, "url", false) == FOUNDATTRIBUTE)
                        rai.sURL = xData.xCurrentAttribute.Value;

                    if (MoveToAttribute(xData, "displayName", false) == FOUNDATTRIBUTE)
                        rai.sName = xData.xCurrentAttribute.Value;
                    
                    // Let's start digging for application-specific stuff
                    DigForActivatedObjects(ref rai, xData);
                    DigForWellKnownObjects(ref rai, xData);
                        
                    al.Add(rai);
                    if (!MoveToNextNode(xData))
                        break;
                }
            }
        }

        return al;
    }// GetRemotingApplications
    
    private static void DigForWellKnownObjects(ref RemotingApplicationInfo rai,  XMLData xData)
    {
        // Let's start digging for application-specific stuff
        if (MoveToFirstChild(xData))
        {
            ElementConditions ec = new ElementConditions("wellknown");

            while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
            {
                bool fFoundType=false;
                bool fFoundURL=false;
                // Go looking for the type info
                if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
                {
                    fFoundType=true;
                    String sTypeInfo = xData.xCurrentAttribute.Value;
                    // The typeinfo is actually the type and assembly, seperated by a comma
                    String[] sTypes = sTypeInfo.Split(new char[] {','});
                    rai.scWellKnownObjectType.Add(sTypes[0]);
                    rai.scWellKnownAssembly.Add(sTypes[1]);
                }

                if (MoveToAttribute(xData, "url", false) == FOUNDATTRIBUTE)
                {
                    fFoundURL=true;
                    rai.scWellKnownURL.Add(xData.xCurrentAttribute.Value);
                }

                // See if we need to pad any of the string collections
                if (fFoundURL && !fFoundType)
                {
                    rai.scWellKnownObjectType.Add("");
                    rai.scWellKnownAssembly.Add("");
                }
                if (fFoundType && !fFoundURL)
                    rai.scWellKnownURL.Add("");
                                
                if (!MoveToNextNode(xData))
                    break;
            }
        }
        MoveToParent(xData);
    }// DigForWellKnownObjects

    private static void DigForActivatedObjects(ref RemotingApplicationInfo rai,  XMLData xData)
    {
        // Let's start digging for application-specific stuff
        if (MoveToFirstChild(xData))
        {
            ElementConditions ec = new ElementConditions("activated");

            while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
            {
                if (MoveToAttribute(xData, "type", false) == FOUNDATTRIBUTE)
                {
                    String sTypeInfo = xData.xCurrentAttribute.Value;
                    // The typeinfo is actually the type and assembly, seperated by a comma
                    String[] sTypes = sTypeInfo.Split(new char[] {','});
                    rai.scActObjectType.Add(sTypes[0]);
                    rai.scActAssembly.Add(sTypes[1]);
                }

                if (!MoveToNextNode(xData))
                    break;
            }
        }
        MoveToParent(xData);

    }// DigForActivatedObjects

    private static Object GetConsumerCommands(String sMachineName)
    {
        ArrayList ol = new ArrayList();
        // The command history is stored in the UI XML file
        SetXMLFilenameForCC(sMachineName);

        int iLoc = GetLocationOfElement("ConsumerCommands");

        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        if (xData.xCurrentElement != null)
        {
            // Make sure we have child nodes
            if (MoveToFirstChild(xData))
            {
              do
              {
                 ol.Add(GrabCommandHistory (xData));
              }while(MoveToNextNode(xData));
            }
        }

        return ol;
    }// GetConsumerCommands




    private static Object GetCommandHistory(String sMachineName)
    {
        ArrayList ol = new ArrayList();
        // The command history is stored in the UI XML file
        SetXMLFilenameForUI(sMachineName);

        int iLoc = GetLocationOfElement("CommandHistory");

        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        
        if (xData.xCurrentElement != null)
        {
            // Make sure we have child nodes
            if (MoveToFirstChild(xData))
            {
              do
              {
                 ol.Add(GrabCommandHistory (xData));
              }while(MoveToNextNode(xData));
            }
        }

        return ol;

    }// GetCommandHistory

    private static CommandHistory GrabCommandHistory(XMLData xData)
    {
        CommandHistory cmdHist = new CommandHistory();   
        // Grab the stuff we care about
        if (MoveToAttribute(xData, "Command", false) == FOUNDATTRIBUTE)
            cmdHist.sCommand = xData.xCurrentAttribute.Value;

        if (MoveToAttribute(xData, "NumHits", false) == FOUNDATTRIBUTE)
            cmdHist.iNumHits = Int32.Parse(xData.xCurrentAttribute.Value);
        
        if (MoveToAttribute(xData, "MenuCommand", false) == FOUNDATTRIBUTE)
            cmdHist.iMenuCommand = Int32.Parse(xData.xCurrentAttribute.Value);
        
        if (MoveToFirstChild(xData))
        {
            // Remember where we are right now
            XmlElement xElement = xData.xCurrentElement;
            
            // First grab the command tree info            
            cmdHist.scPathToNode = new StringCollection();
     
            while(MoveToSpecificElement(xData, CreateElementConditions("Tree")[0], false) == FOUNDELEMENT)
            {
                if (MoveToAttribute(xData, "Name", false) == FOUNDATTRIBUTE)
                    cmdHist.scPathToNode.Add(xData.xCurrentAttribute.Value);
                if (!MoveToNextNode(xData))
                    break;
            }
            // Go back to the first child here
            xData.xCurrentElement = xElement;
            // Now grab the result info
            cmdHist.scResultItem = new StringCollection();
            while (MoveToSpecificElement(xData, CreateElementConditions("ResultItem")[0], false) == FOUNDELEMENT)
            {
                if (MoveToAttribute(xData, "Value", false) == FOUNDATTRIBUTE)
                    cmdHist.scResultItem.Add(xData.xCurrentAttribute.Value);
                if (!MoveToNextNode(xData))
                    break;
            }
            // Now go back to the parent node
            MoveToParent(xData);
        }
        return cmdHist;
    }// GrabCommandHistory

    private static void PutInCommandHistory(XMLData xData, CommandHistory ch)
    {
        // Let's first add the Item node
        ElementConditions ec = new ElementConditions("Item");
        ec.sAttributeNames = new String[] {"Command", "NumHits", "MenuCommand"};
        ec.sAttributeValues = new String[] {ch.sCommand, ch.iNumHits.ToString(), ch.iMenuCommand.ToString()};

        InsertElement(xData, ec);
        MoveToLastChild(xData);
        // Now let's fill in the command tree
        for(int i=0; i < ch.scPathToNode.Count; i++)
        {
            ec = CreateElementConditions("Tree:Name=" + ch.scPathToNode[i])[0];
            InsertElement(xData, ec);
            MoveToParent(xData);
        }
        // Now let's put in the result info
        for(int i=0; i < ch.scResultItem.Count; i++)
        {
            ec = CreateElementConditions("ResultItem:Value=" + ch.scResultItem[i])[0];
            InsertElement(xData, ec);
            MoveToParent(xData);
        }
 
        // Get us back to the CommandHistory Node
        MoveToParent(xData);
    }// PutInCommandHistory

    private static bool SetCommandHistory(String sMachineName, Object val)
    {
        ArrayList ol = (ArrayList)val;
        
        // The command history is stored in the UI XML file
        SetXMLFilenameForUI(sMachineName);

        int iLoc = GetLocationOfElement("CommandHistory");

        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), true);

        // Let's wipe out the existing CommandHistory Data
        ElementConditions ec = new ElementConditions("Item");
        RemoveElementChildren(xData, ec);

        // Now, let's add all the Command Info we have
        int iLen = ol.Count;
        for(int i=0; i<iLen; i++)
            PutInCommandHistory(xData, (CommandHistory)ol[i]);

        return SaveXML(xData);
    }// SetCommandHistory

    //-------------------------------------------------
    // RemoveAppConfigFile
    //
    // This function will remove the given app configuration
    // file from our knowledge
    //-------------------------------------------------
    private static bool RemoveAppConfigFile(String sMachineName, Object appFile)
    {
        SetXMLFilenameForUI(sMachineName);
        int iLoc = GetLocationOfElement("AppConfigFiles");
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        // Ok, now set up the element condition to get to this particular application
        ElementConditions ec = new ElementConditions("Application");
        ec.sAttributeNames = new String[2] {"ConfigFile", "AppFile"};
        ec.sAttributeValues = new String[2] {((AppFiles)appFile).sAppConfigFile, ((AppFiles)appFile).sAppFile};
        RemoveElementChildren(xData, ec);
        return SaveXML(xData);
    }// RemoveAppConfigFile

    //-------------------------------------------------
    // GetAppConfigFiles
    //
    // This function will return a list of Application
    // Configuration Files that the UI knows about.
    //-------------------------------------------------
    private static Object GetAppConfigFiles(String sMachineName)
    {
        SetXMLFilenameForUI(sMachineName);
        ArrayList olConfigFiles = new ArrayList();
        int iLoc = GetLocationOfElement("AppConfigFiles");
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), false);
        // We'll move to each Application node and get its configfile info
        if (xData.xCurrentElement != null)
        {
            if (MoveToFirstChild(xData))
            {
                do
                {
                    AppFiles appFiles = new AppFiles();   
                    // Grab the two items we care about
                    if (MoveToAttribute(xData, "ConfigFile", false) == FOUNDATTRIBUTE)
                        appFiles.sAppConfigFile = xData.xCurrentAttribute.Value;

                    if (MoveToAttribute(xData, "AppFile", false) == FOUNDATTRIBUTE)
                        appFiles.sAppFile = xData.xCurrentAttribute.Value;
                    olConfigFiles.Add(appFiles);
                }while(MoveToNextNode(xData));
            }          

        }
        return olConfigFiles;
    }// GetAppConfigFiles

    //-------------------------------------------------
    // SetAppConfigFiles
    //
    // This function will add an app config file to the
    // files we already know.
    //-------------------------------------------------
    private static bool SetAppConfigFiles(String sMachineName, Object appFile)
    {
        SetXMLFilenameForUI(sMachineName);
        int iLoc = GetLocationOfElement("AppConfigFiles");
        XMLData xData = MoveToElement(CreateElementConditions(LocationOfXMLValues[iLoc, 1]), true);
        // We'll move to each Application node and add a config file
        ElementConditions ec = new ElementConditions("Application");
        ec.sAttributeNames = new String[2] {"ConfigFile", "AppFile"};
        ec.sAttributeValues = new String[2] {((AppFiles)appFile).sAppConfigFile, ((AppFiles)appFile).sAppFile};
        InsertElement(xData, ec);
        return SaveXML(xData);
    }// SetAppConfigFiles


    //-------------------------------------------------
    // CreateAssemIdentEC
    //
    // This function will create an ElementConditions structure
    // that is used for Assembly Identity
    //-------------------------------------------------

    private static ElementConditions CreateAssemIdentEC(String[] sGivenConds)
    {
        ElementConditions ec = new ElementConditions("assemblyIdentity");
        // Only add the publicKeyToken if it's not empty or null
        if (sGivenConds[1] != null && sGivenConds[1].Length > 0)
        {
            ec.sAttributeNames = new String[] {"name", "publicKeyToken"};
            ec.sAttributeValues = new String[] {sGivenConds[0], sGivenConds[1]};
        }
        else
        {
            ec.sAttributeNames = new String[] {"name"};
            ec.sAttributeValues = new String[] {sGivenConds[0]};
        }
        return ec;
    }// CreateAssemIdentEC
       


    //-------------------------------------------------
    // SetAppConfigFiles
    //
    // This function will add an app config file to the
    // files we already know.
    //-------------------------------------------------
    private static bool SetCodeBaseInfo(String sMachineName, String sConds, Object val)
    {
        String[] sGivenConds = sConds.Split(new char[] {','});

        if (sGivenConds.Length < 3)
            SetXMLFilename(sMachineName);
        else
            SetXMLFilenameForApp(sMachineName, sGivenConds[2]);

        CodebaseLocations cbl = (CodebaseLocations)val;
        
        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");
        String sBaseElementLocation = LocationOfXMLValues[iLoc,1];

        // Let's get our XML pointer to the Binding Policy node
        XMLData xData = MoveToElement(CreateElementConditions(sBaseElementLocation), true);

        ElementConditions ec = CreateAssemIdentEC(sGivenConds);
            
        if (MoveToCorrectDependentAssembly(xData, ec, false) == NOELEMENT)
            throw new Exception("Can't find the assembly to configure");

        // Let's back up one to the dependent assembly node
        MoveToParent(xData);
            
        // Now lets go looking for each binding policy
        ElementConditions ec2 = new ElementConditions("codeBase");
            
        // Let's delete all this element's binding policy children
        RemoveElementChildren(xData, ec2);

        // Now let's add in all the binding policy stuff again
        for(int i=0; i<cbl.scVersion.Count; i++)
        {
            ec2.sAttributeNames = new String[] {"version", "href"};
            ec2.sAttributeValues = new String[] {cbl.scVersion[i], cbl.scCodeBase[i]};
            InsertElement(xData, ec2);
            MoveToParent(xData);  
        }
     
        return SaveXML(xData);
    }// SetCodeBaseInfo

    //-------------------------------------------------
    // GetCodeBaseInfo
    //
    // This function will return code base information
    // given an assembly name and public key token
    //-------------------------------------------------
    private static Object GetCodeBaseInfo(String sMachineName, String sConds)
    {
        String[] sGivenConds = sConds.Split(new char[] {','});

        if (sGivenConds.Length < 3)
            SetXMLFilename(sMachineName);
        else
            SetXMLFilenameForApp(sMachineName, sGivenConds[2]);

        // Set up our CodeBaseInfo structure
        CodebaseLocations cbl = new CodebaseLocations();
        cbl.scVersion = new StringCollection();
        cbl.scCodeBase = new StringCollection();
        
        // Ok, now we have the criteria we need to get appropriate the BindingPolicy Info

        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");
        String sBaseElementLocation = LocationOfXMLValues[iLoc,1];

        // Let's get our XML pointer to the Binding Policy node
        XMLData xData = MoveToElement(CreateElementConditions(sBaseElementLocation), false);

        if (xData.xCurrentElement == null)
            return cbl;


        ElementConditions ec = CreateAssemIdentEC(sGivenConds);
            
        if (MoveToCorrectDependentAssembly(xData, ec, false) == NOELEMENT)
            throw new Exception("Can't find the assembly to configure");

        // Let's back up one to the dependent assembly node
        MoveToParent(xData);
        MoveToFirstChild(xData);
            
        // Now lets go looking for each binding policy
        ElementConditions ec2 = new ElementConditions("codeBase");

        // Now let's start looking for them.
        while(MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
        {
            // If the attribute exists....
            if (MoveToAttribute(xData, "version", false) == FOUNDATTRIBUTE)
                cbl.scVersion.Add(xData.xCurrentAttribute.Value);
            else
                cbl.scVersion.Add("");
                
            if (MoveToAttribute(xData, "href", false) == FOUNDATTRIBUTE)
                cbl.scCodeBase.Add(xData.xCurrentAttribute.Value);
            else
                cbl.scCodeBase.Add("");

            // See if we ran out of redir structures
            if (!MoveToNextNode(xData))
                break;
        }
          
        return cbl;
    }// GetCodeBaseInfo

    //-------------------------------------------------
    // SetPublisherPolicy
    //
    //-------------------------------------------------
    private static bool SetPublisherPolicy(String sMachineName, String sConds, Object val)
    {
        
        String[] sGivenConds = sConds.Split(new char[] {','});

        if (sGivenConds.Length < 3)
            SetXMLFilename(sMachineName);
        else
            SetXMLFilenameForApp(sMachineName, sGivenConds[2]);

        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");
        String sBaseElementLocation = LocationOfXMLValues[iLoc,1];

        // Let's get our XML pointer to the Binding Policy node
        XMLData xData = MoveToElement(CreateElementConditions(sBaseElementLocation), true);

        ElementConditions ec = CreateAssemIdentEC(sGivenConds);
            
        if (MoveToCorrectDependentAssembly(xData, ec, false) == NOELEMENT)
            throw new Exception("Can't find the assembly to configure");

        // Let's back up one to the dependent assembly node
        MoveToParent(xData);
            
        // Now lets go looking for each binding policy
        ec.sElementName = "publisherPolicy";
        ec.sAttributeNames = null;
        ec.sAttributeValues = null;
        
        // See if the item already exists
        if (MoveToFirstChild(xData))
            MoveToSpecificElement(xData, ec, true);
        // If there's no possibility the item exists, then we'll have to insert it
        else
            InsertElement(xData, ec);

        MoveToAttribute(xData, "apply", true);
        xData.xCurrentAttribute.Value = (bool)val?"yes":"no";

        return SaveXML(xData);
    }// SetPublisherPolicy

    //-------------------------------------------------
    // GetPublisherPolicy
    //
    //-------------------------------------------------
    private static Object GetPublisherPolicy(String sMachineName, String sConds)
    {
        String[] sGivenConds = sConds.Split(new char[] {','});

        if (sGivenConds.Length < 3)
            SetXMLFilename(sMachineName);
        else
            SetXMLFilenameForApp(sMachineName, sGivenConds[2]);

        // Ok, now we have the criteria we need to get appropriate the BindingPolicy Info

        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");
        String sBaseElementLocation = LocationOfXMLValues[iLoc,1];

        // Let's get our XML pointer to the Binding Policy node
        XMLData xData = MoveToElement(CreateElementConditions(sBaseElementLocation), false);
        // We couldn't find the file we needed
        if (xData.xCurrentElement == null)
            return true;

        ElementConditions ec = CreateAssemIdentEC(sGivenConds);
            
        if (MoveToCorrectDependentAssembly(xData, ec, false) == NOELEMENT)
            throw new Exception("Can't find the assembly to configure");

        // Let's back up one to the dependent assembly node
        MoveToParent(xData);
        MoveToFirstChild(xData);
            
        // Now lets go looking for each binding policy
        ec.sElementName = "publisherPolicy";
        ec.sAttributeNames = null;
        ec.sAttributeValues = null;
        if (MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
            if (MoveToAttribute(xData, "apply", false) == FOUNDATTRIBUTE)
                return xData.xCurrentAttribute.Value.ToLower(CultureInfo.InvariantCulture).Equals("yes");

        // True is the default setting  
        return true;
    }// GetPublisherPolicy

    //-------------------------------------------------
    // SetBindingPolicy
    //
    // This function will set the binding policy
    // given an assembly name and public key token
    //-------------------------------------------------
    private static bool SetBindingPolicy(String sMachineName, String sConds, Object val)
    {
        
        String[] sGivenConds = sConds.Split(new char[] {','});

        if (sGivenConds.Length < 3)
            SetXMLFilename(sMachineName);
        else
            SetXMLFilenameForApp(sMachineName, sGivenConds[2]);

        BindingPolicy bp = (BindingPolicy)val;


        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");
        String sBaseElementLocation = LocationOfXMLValues[iLoc,1];

        // Let's get our XML pointer to the Binding Policy node
        XMLData xData = MoveToElement(CreateElementConditions(sBaseElementLocation), true);

        ElementConditions ec = CreateAssemIdentEC(sGivenConds);
        
        if (MoveToCorrectDependentAssembly(xData, ec, false) == NOELEMENT)
            throw new Exception("Can't find the assembly to configure");

        // Let's back up one to the dependent assembly node
        MoveToParent(xData);
            
        // Now lets go looking for each binding policy
        ElementConditions ec2 = new ElementConditions("bindingRedirect");
            
        // Let's delete all this element's binding policy children
        RemoveElementChildren(xData, ec2);

        // Now let's add in all the binding policy stuff again
        for(int i=0; i<bp.scBaseVersion.Count; i++)
        {
            ec2.sAttributeNames = new String[] {"oldVersion", "newVersion"};
            ec2.sAttributeValues = new String[] {bp.scBaseVersion[i], bp.scRedirectVersion[i]};
            InsertElement(xData, ec2);
            MoveToParent(xData);  
        }
           
        return SaveXML(xData);
    }// SetBindingPolicy

    //-------------------------------------------------
    // GetBindingPolicy
    //
    // This function will return the binding policy
    // given an assembly name and public key token
    //-------------------------------------------------
    private static Object GetBindingPolicy(String sMachineName, String sConds)
    {
        String[] sGivenConds = sConds.Split(new char[] {','});

        if (sGivenConds.Length < 3)
            SetXMLFilename(sMachineName);
        else
            SetXMLFilenameForApp(sMachineName, sGivenConds[2]);


        // Set up our BindingPolicy structure
        BindingPolicy dp = new BindingPolicy();
        dp.scBaseVersion = new StringCollection();
        dp.scRedirectVersion = new StringCollection();

        // Ok, now we have the criteria we need to get appropriate the BindingPolicy Info

        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");
        String sBaseElementLocation = LocationOfXMLValues[iLoc,1];

        // Let's get our XML pointer to the Binding Policy node
        XMLData xData = MoveToElement(CreateElementConditions(sBaseElementLocation), false);
        // We couldn't find the file we needed
        if (xData.xCurrentElement == null)
            return dp;


        ElementConditions ec = CreateAssemIdentEC(sGivenConds);
        
        if (MoveToCorrectDependentAssembly(xData, ec, false) == NOELEMENT)
            throw new Exception("Can't find the assembly to configure");

        // Let's back up one to the dependent assembly node
        MoveToParent(xData);
        MoveToFirstChild(xData);
            
        // Now lets go looking for each binding policy
        ElementConditions ec2 = new ElementConditions("bindingRedirect");
        ec2.sElementName = "bindingRedirect";

        // Now let's start looking for them.
        while(MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
        {
            // If the attribute exists....
            if (MoveToAttribute(xData, "oldVersion", false) == FOUNDATTRIBUTE)
                dp.scBaseVersion.Add(xData.xCurrentAttribute.Value);
            else
                dp.scBaseVersion.Add("");

            if (MoveToAttribute(xData, "newVersion", false) == FOUNDATTRIBUTE)
                dp.scRedirectVersion.Add(xData.xCurrentAttribute.Value);
            else
                dp.scRedirectVersion.Add("");

            // See if we ran out of redir structures
            if (!MoveToNextNode(xData))
                break;
        }
         
        return dp;
    }// GetBindingPolicy

    //-------------------------------------------------
    // SetConfiguredAssemblies
    //
    // This function will add another assembly to the list
    // of assemblies we're configuring
    //-------------------------------------------------
    private static bool SetConfiguredAssemblies(String sMachineName, String sCommand, Object val)
    {
        BindingRedirInfo bri = (BindingRedirInfo)val;
    
        // Check to see if we should use the global XML file or an app specific one
        String[] args = sCommand.Split(new char[] {','});
        if (args.Length > 1)
        {
            SetXMLFilenameForApp(sMachineName, args[1]);
            sCommand = args[0];
        }
        else
            SetXMLFilename(sMachineName);

        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");

        String sLocation = LocationOfXMLValues[iLoc,1];       
        // Let's get our XML pointer to the Binding Policy node

        XMLData xData = MoveToElement(CreateElementConditions(sLocation), true);

        ElementConditions ec = CreateAssemIdentEC(new String[] {bri.Name, bri.PublicKeyToken});
            
        MoveToCorrectDependentAssembly(xData, ec, true);

        // See if they wanted to delete this item instead
        if (sCommand.Equals("ConfiguredAssembliesDelete"))
        {
            MoveToParent(xData);
            RemoveNode(xData);
        }

        return SaveXML(xData);
    }// SetConfiguratedAssemblies

    //-------------------------------------------------
    // MoveToCorrectDependentAssembly
    //
    // Assumes we're on the assemblybinding node
    //-------------------------------------------------
    private static int MoveToCorrectDependentAssembly(XMLData xData, ElementConditions ec, bool fCreate)
    {
        // Check each dependentAssembly node
        ElementConditions MyEc = new ElementConditions("dependentAssembly");

        if (MoveToFirstChild(xData))
        {
            while(MoveToSpecificElement(xData, MyEc, false) == FOUNDELEMENT)
            {
                // Ok, now let's look for the assemblyIdentity tag under "dependentAssembly" tag
                if (MoveToFirstChild(xData))
                {
                    int nRet = MoveToSpecificElement(xData, ec, false);
                    if (nRet == FOUNDELEMENT)
                        return FOUNDELEMENT;
                    MoveToParent(xData);
                }
                // Move onto the next tag
                if (!MoveToNextNode(xData))
                   break;   
            }
            // Move back to the assembly binding tag
            MoveToParent(xData);
        }
        // See if we should create this item if it doesn't exist
        if (fCreate)
        {
            // Insert the "dependentAssembly" node
            InsertElement(xData, MyEc);
            // Insert the assemblyidentity tag
            InsertElement(xData, ec);
            return CREATEDELEMENT;
        }

        return NOELEMENT;

    }// MoveToCorrectDependentAssembly

    //-------------------------------------------------
    // GetConfiguredAssemblies
    //
    // This function will run through all the binding policies
    // we have to get a list of assemblies that we've actually
    // configured
    //-------------------------------------------------
    private static Object GetConfiguredAssemblies(String sMachineName, String sCommand)
    {
        ArrayList ol = new ArrayList();


        // Check to see if we should use the global XML file or an app specific one
        String[] args = sCommand.Split(new char[] {','});
        if (args.Length > 1)
        {
            SetXMLFilenameForApp(sMachineName, args[1]);
            sCommand = args[0];
        }
        else
            SetXMLFilename(sMachineName);

        // Let's figure out where the Binding Policy Node is
        int iLoc = GetLocationOfElement("ConfiguredAssemblies");

        String sLocation = LocationOfXMLValues[iLoc,1];       
        // Let's get our XML pointer to the Binding Policy node

        XMLData xData = MoveToElement(CreateElementConditions(sLocation), false);
        if (xData.xCurrentElement != null)
        {
            // Now move to each Item in the binding policy
            ElementConditions ec = new ElementConditions("dependentAssembly");

            if (MoveToFirstChild(xData))
            {
                while(MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
                {
                    // Ok, now let's look for various tags under the "dependentAssembly" tag
                    if (MoveToFirstChild(xData))
                    {
                        ElementConditions ec2 = new ElementConditions("assemblyIdentity");
                    
                        if (MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
                        {
                            String sTempName=null;
                            String sTempPublicKeyToken=null;
    
                            // Let's start grabing info
                            // If the attribute exists....
                            if (MoveToAttribute(xData, "name", false) == FOUNDATTRIBUTE)
                                sTempName = xData.xCurrentAttribute.Value;

                            if (MoveToAttribute(xData, "publicKeyToken", false) == FOUNDATTRIBUTE)
                                sTempPublicKeyToken = xData.xCurrentAttribute.Value;

                            if (sTempName != null && !isBindingRedirRepeat(ol, sTempName, sTempPublicKeyToken))
                            {
                                BindingRedirInfo bri = new BindingRedirInfo();
                                bri.Name = sTempName;
                                bri.PublicKeyToken=sTempPublicKeyToken;
        
                                // Now check to see if this item has a binding policy
                                ec2.sElementName = "bindingRedirect";
                                MoveToParent(xData);
                                MoveToFirstChild(xData);
                                
                                if (MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
                                    bri.fHasBindingPolicy=true;
                                else
                                    bri.fHasBindingPolicy=false;

                                // Check to see if this item has a codebase
                                ec2.sElementName = "codeBase";
                                MoveToParent(xData);
                                MoveToFirstChild(xData);
                                if (MoveToSpecificElement(xData, ec2, false) == FOUNDELEMENT)
                                    bri.fHasCodebase=true;
                                else
                                    bri.fHasCodebase=false;

                                ol.Add(bri);
                            }
                        }
                        MoveToParent(xData);
                    }
                            
                    // We ran out of tags
                    if (!MoveToNextNode(xData))
                        break;
                }
            }
       }

        return ol;       
    }// GetConfiguratedAssemblies

    //-------------------------------------------------
    // isBindingRedirRepeat
    //
    // This function will run through an object list and
    // check to see if a potiential assembly is already
    // in the object list.
    //-------------------------------------------------
    private static bool isBindingRedirRepeat(ArrayList ol, String sName, String sPublicKeyToken)
    {
        int iLen = ol.Count;
        for(int i=0; i<iLen; i++)
        {
            BindingRedirInfo bri = (BindingRedirInfo)ol[i];
            if (bri.Name.Equals(sName))
            {
                // Ok, now let's check to see if public key tokens are ok...

                // If they're both null, we have a match
                if (bri.PublicKeyToken==null && sPublicKeyToken == null)
                    return true;

                // Check the tokens...
                if (bri.PublicKeyToken != null && bri.PublicKeyToken.Equals(sPublicKeyToken))
                    return true;
            }
        }
        // We didn't find a match
        return false;
    }// isBindingRedirRepeat


    private static bool SaveXML(XMLData xData)
    {
        try
        {
            xData.xDoc.Save(m_sXMLFilename);
            return true;
        }
        catch(Exception)
        {
            MessageBox(0,
                    String.Format(CResourceStore.GetString("CConfigStore:CantSaveXMLFile"), m_sXMLFilename),
                    CResourceStore.GetString("CConfigStore:CantSaveXMLFileTitle"),
                    MB.ICONEXCLAMATION);
            return false;
        }
    }// SaveXML

    //-------------------------------------------------
    // GetXMLDocument
    //
    // This function will attempt to open a XML file.
    // If the file doesn't exist, then depending on the
    // fCreate flag, it could create it.
    //-------------------------------------------------
    private static XmlDocument GetXMLDocument(bool fCreate)
    {
        XmlDocument xDoc=null; 
        Stream xmlFile=null; 
        try
        {
            xmlFile = File.Open(m_sXMLFilename, FileMode.Open, FileAccess.Read);
        }
        catch(Exception)
        {
            // Ok, either the file doesn't exist or we don't have permissions
            if (fCreate && !File.Exists(m_sXMLFilename))
            {
                try
                {
                   xmlFile = File.Create(m_sXMLFilename);
                }
                catch(Exception)
                {
                    // Ok, we're here because the path to this file didn't exist. Let's try
                    // creating the directory, and then going at this again.

                    // First, we need to figure out the path
                    String[] sArgs = m_sXMLFilename.Split(new char[] {'\\'});
                    // Now join the directory together
                    String sDir = String.Join("\\", sArgs, 0, sArgs.Length>1?sArgs.Length-1:1);
                    try
                    {
                        // If this stuff fails, then we're screwed. There's nothing more we can do
                        Directory.CreateDirectory(sDir);
                        xmlFile = File.Create(m_sXMLFilename);
                    }
                    catch(Exception)
                    {
                        MessageBox(0,
                                    String.Format(CResourceStore.GetString("CConfigStore:CantCreateXMLFile"), m_sXMLFilename),
                                    CResourceStore.GetString("CConfigStore:CantCreateXMLFileTitle"),
                                    MB.ICONEXCLAMATION);
                        return null;
                    }
                }
                StreamWriter sw = new StreamWriter(xmlFile);
                sw.Write("<?xml version=\"1.0\"?>\n<configuration>\n</configuration>");
                sw.Close();
                return GetXMLDocument(fCreate);
            }
            else
            {
                // We don't want to show this dialog
                /*
                MessageBox(0,
                            String.Format(CResourceStore.GetString("CConfigStore:CantOpenXMLFile"), m_sXMLFilename),
                            CResourceStore.GetString("CConfigStore:CantOpenXMLFileTitle"),
                            MB.ICONEXCLAMATION);
                */
                return null;
            }
        }

        // Now try and parse this XML
        try
        {
            XmlTextReader xReader = new XmlTextReader(xmlFile);
            xReader.WhitespaceHandling = WhitespaceHandling.All;
            xDoc = new XmlDocument();
            xDoc.Load(xReader);
            xmlFile.Close();
            xmlFile = null;
        }
        catch(Exception)
        {
            if (xmlFile != null)
                xmlFile.Close();
           
            MessageBox(0,
                        String.Format(CResourceStore.GetString("CConfigStore:BadXMLFile"),m_sXMLFilename),
                        CResourceStore.GetString("CConfigStore:BadXMLFileTitle"),
                        MB.ICONEXCLAMATION);
            // If we wanted to create this file if it didn't exist, then we'll be making
            // changes to the XML file. In that case, we want to return a null XML Document
            // so an error will get bubbled up to the user.
            //
            // If they just want to read the XML, we'll need to throw an exception, otherwise
            // we'll just return default info for everything they ask and they'll keep getting
            // bombarded with "Bad XML File" error dialogs
            if (fCreate)
                return null;
            else
                throw;
        }
        return xDoc;
    }// GetXMLDocument

    //-------------------------------------------------
    // GetXMLData
    //
    // This function will get a XML Document and a
    // XML navigator, bundle the two into a XMLData structure
    // and return it.
    //-------------------------------------------------
    private static XMLData GetXMLData(bool fCreate)
    {
        XmlDocument xDoc = GetXMLDocument(fCreate);
        XMLData xData = new XMLData();
        
        xData.xCurrentAttribute = null;
        
        if (xDoc != null)
        {
        
            xData.xCurrentElement = xDoc.DocumentElement;
            xData.xDoc = xDoc;
        }
        else
        {
            xData.xDoc = null;
            xData.xCurrentElement = null;
        }
        return xData;
    }// GetXMLData

    //-------------------------------------------------
    // CreateElementConditions
    //
    // This function will take a string and create an array
    // of ElementConditions. 
    // Format of this string is as follows:
    //
    // <Element>:<AttributeName>=<Value>,<AttributeName>=<Value>/<AnotherElement>
    //
    // There can be an infinite # of attribute names and values, including none.
    // There can also be an infinite # of Elements as well.
    //-------------------------------------------------
    private static ElementConditions[] CreateElementConditions(String s)
    {
        // Let's count the number of element conditions we have (the number of '/' + 1)
        int iNumConditions=1;
        for(int i=0; i<s.Length; i++)
            if (s[i] == '/')
                iNumConditions++;
        // Let's start building the conditions
        ElementConditions[] ec = new ElementConditions[iNumConditions];
        int iIndex=0;
        int iLength = s.Length;
        int iEndString=-1;
        for (int i=0; i<iNumConditions; i++)
        {
            iIndex = ++iEndString;
            while(iEndString < iLength && s[iEndString] != '/'  && s[iEndString] != ':')
                iEndString++;

            ec[i] = new ElementConditions(s.Substring(iIndex, iEndString-iIndex));
            
            // See if there's any attribute conditions
            if (iEndString!= iLength && s[iEndString] == ':')
            {
                int iBase = ++iEndString;
                // First, find when the next item appears
                while(iEndString < iLength && s[iEndString] != '/')
                    iEndString++;

                // We know how many of these there are based on the number of ','
                int iNumAttribute=1;
                for(int j=iBase; j< iEndString; j++)
                    if (s[j] == ',')
                        iNumAttribute++;

                ec[i].sAttributeNames = new String[iNumAttribute];
                ec[i].sAttributeValues = new String[iNumAttribute];
                // Let's grab these element conditions
                for(int j=0; j<iNumAttribute; j++)
                {
                    // Let's get the attribute name
                    iEndString=iBase;
                    while(s[iEndString] != '=')
                        iEndString++;
                    ec[i].sAttributeNames[j] = s.Substring(iBase, iEndString-iBase);
                    // Now let's get the attribute value
                    iBase=++iEndString;
                    while(iEndString < iLength && s[iEndString] != ',' && s[iEndString]!='/')
                        iEndString++;
                    ec[i].sAttributeValues[j] = s.Substring(iBase, iEndString-iBase); 
                    iBase = ++iEndString;
                }
                iEndString--;
            }// if we had attribute conditions
            
        }// for loop to run through the different elements to run through

        return ec;
   }// CreateElementConditions

    //-------------------------------------------------
    // MoveToAttribute
    //
    // This will move to an attribute
    //-------------------------------------------------
    private static int MoveToAttribute(XMLData xData, String sAttribute, bool fCreate)
    {
        // See if this attribute exists in the current node
        int nLen = xData.xCurrentElement.Attributes.Count;
        for(int i=0; i<nLen; i++)
        {
            if (xData.xCurrentElement.Attributes[i].LocalName.Equals(sAttribute))
            {
                xData.xCurrentAttribute = xData.xCurrentElement.Attributes[i];
                return FOUNDATTRIBUTE;
            }
        }

        // If we're here, the attribute didn't exist....
        if (!fCreate)
            return NOATTRIBUTE;
            
        // We need to add the attribute to this node
        xData.xCurrentAttribute = xData.xCurrentElement.Attributes.Append(xData.xDoc.CreateAttribute(sAttribute));
        return CREATEDATTRIBUTE;
    }// MoveToAttribute
   
    //-------------------------------------------------
    // MoveToSpecificElement
    //
    // This will move to a single element, given
    // some conditions
    //-------------------------------------------------
    private static int MoveToSpecificElement(XMLData xData, ElementConditions Elements, bool fCreate)
    {
        // Make sure the current element isn't null
        if (xData.xCurrentElement == null)
            return NOELEMENT;
    
        while(!xData.xCurrentElement.LocalName.Equals(Elements.sElementName))
            if (!MoveToNextNode(xData))
                break;
            
        // See if we found our element
        if (xData.xCurrentElement.LocalName.Equals(Elements.sElementName))
        {
            // Ok, we found an element... Let's see if it matches our attribute values
            int iLen = Elements.sAttributeNames == null?0:Elements.sAttributeNames.Length;
            int ret=0; 
            int i;
            for(i=0; i<iLen; i++)
            {
                // We don't want to add any attributes if we've already found a pre-existing element
                ret = MoveToAttribute(xData, Elements.sAttributeNames[i], false);
                // It's not this one.... let's move onto the next
                if (ret == NOATTRIBUTE || !xData.xCurrentAttribute.Value.Equals(Elements.sAttributeValues[i]))
                {
                    if (MoveToNextNode(xData))
                        return MoveToSpecificElement(xData, Elements, fCreate);
                    // We've run out of possibilites... either create this or be done
                    else
                        break;
                }
            }
            // See if we left the for loop naturally
            if (i == iLen)
            {   
                // If we're here, we've made it to our guy
                // Set the navigator to the element (instead of the navigator) and return
                return FOUNDELEMENT;
            }
        }
      // Our element didn't exist
      if (fCreate)
      {
        // We need to create our element
        xData.xCurrentElement = (XmlElement)xData.xCurrentElement.ParentNode;
        InsertElement(xData, Elements);

        // Let's let our caller know we created this
        return CREATEDELEMENT;
      }  
      // The element didn't exist
      return NOELEMENT;
    }// MoveToSpecificElement

    //-------------------------------------------------
    // RemoveElementChildren
    //
    // This function will remove all the children from an
    // element that satisfy the conditions in an ElementConditions
    // structure
    //-------------------------------------------------
    private static void RemoveElementChildren(XMLData xData, ElementConditions ec)
    {
        // Save the parent's position
        XmlElement xElement = xData.xCurrentElement;
        
        // We'll go through and delete all the children that match the element condition
        while(MoveToFirstChild(xData) && MoveToSpecificElement(xData, ec, false) == FOUNDELEMENT)
        {
            RemoveNode(xData);
            // Go back to the parent...
            xData.xCurrentElement = xElement;
        }
        // And let's go back to the parent position then
        xData.xCurrentElement = xElement;
    }// RemoveElementChildren

    //-------------------------------------------------
    // InsertElement
    //
    // This will insert an element into the tree and any
    // attributes/values that are passed along in the 
    // ElementConditions structure
    //-------------------------------------------------
    private static void InsertElement(XMLData xData, ElementConditions Elements)
    {
        // We'll use the parent's namespace to do this.
        XmlElement xElement = xData.xDoc.CreateElement(Elements.sElementName, xData.xCurrentElement.NamespaceURI);
        xData.xCurrentElement = (XmlElement)xData.xCurrentElement.AppendChild(xElement);
            
        // Now, let's insert all our Attributes we wanted
        int iLen = Elements.sAttributeNames == null?0:Elements.sAttributeNames.Length;
        for(int i=0; i<iLen; i++)
        {
            MoveToAttribute(xData, Elements.sAttributeNames[i], true);
            xData.xCurrentAttribute.Value = Elements.sAttributeValues[i];
        }
    }// InsertElements

    //-------------------------------------------------
    // MoveToElement
    //
    // This will move to an element given an array of
    // elements to get there. This overload will assume
    // the user doesn't have a current XMLData structure
    //-------------------------------------------------
    private static XMLData MoveToElement(ElementConditions[] sElements, bool fCreate)
    {
        XMLData xData = GetXMLData(fCreate);
        // See if we were able to get a navigator
        if (xData.xDoc == null || xData.xCurrentElement == null)
            return xData;

        int nRet = MoveToElement(ref xData, sElements, fCreate);
        if (nRet == NOELEMENT)
            xData.xCurrentElement = null;
        return xData;

    }// MoveToElement
    
    //-------------------------------------------------
    // MoveToElement
    //
    // This will move to an element given an array of
    // elements to get there. This overload will assume
    // the user has a current XMLData structure
    //-------------------------------------------------
    private static int MoveToElement(ref XMLData xData, ElementConditions[] sElements, bool fCreate)
    {
        int iLen = sElements.Length;
        int res=0;
        bool fCreated=false;

        for(int i=0; i<iLen; i++)
        {
            res = MoveToSpecificElement(xData, sElements[i], fCreate);
            // See if we needed to create the node (and thus make sure we save the XML)
            if (res == CREATEDELEMENT)
            {
                fCreated = true;
                // If we can't create this element, just bail
                if (!SaveXML(xData))
                {
                   xData.xCurrentElement = null;
                   return NOELEMENT;
                }
            }
            // The node didn't exist
            else if (res == NOELEMENT)
            {
                xData.xCurrentElement = null;
                return NOELEMENT;
            }
            
            // See if we're going to be doing another loop
            if (i+1 < iLen)
            {
                // We need to 'move down' to the first child.
                if (!MoveToFirstChild(xData) && fCreate)
                {                   
                    // Ok, we need a child with this node and no child exists. Fantastic!
                    InsertElement(xData, sElements[i+1]);
                  
                    SaveXML(xData);
                }
            }
        }
        // Ok, we should be at the requested node
        if (fCreated)
            return CREATEDELEMENT;
        else
            return FOUNDELEMENT;
    }// MoveToElement

    internal static bool MoveToFirstChild(XMLData xData)
    {
        bool fHaveChild = false;
        
        XmlNode xNode = xData.xCurrentElement.FirstChild;
        while (xNode != null && !(xNode is XmlElement))
            xNode = xNode.NextSibling;
        
        if (xNode != null)
        {
            xData.xCurrentElement = (XmlElement)xNode;
            fHaveChild = true;
        }

        return fHaveChild;
    }// MoveToFirstChild
    
    internal static bool MoveToLastChild(XMLData xData)
    {
        bool fHaveChild = false;
        if (xData.xCurrentElement.LastChild != null)
        {
            fHaveChild = true;
            xData.xCurrentElement = (XmlElement)xData.xCurrentElement.LastChild;
        }
        return fHaveChild;
    }// MoveToLastChild

    internal static bool MoveToFirstAttribute(XMLData xData)
    {
        bool fHaveAttribute = false;
        if (xData.xCurrentElement.Attributes.Count > 0)
        {
            fHaveAttribute = true;
            xData.xCurrentAttribute = xData.xCurrentElement.Attributes[0];
            xData.nCurrentAttributeIndex = 0;
        }
        return fHaveAttribute;
    }// MoveToLastChild

    internal static bool MoveToNextAttribute(XMLData xData)
    {
        bool fHaveAttribute = false;
        
        if (xData.xCurrentElement.Attributes.Count > xData.nCurrentAttributeIndex+1)
        {
            xData.nCurrentAttributeIndex++;
            xData.xCurrentAttribute = xData.xCurrentElement.Attributes[xData.nCurrentAttributeIndex];
            fHaveAttribute = true;
        }

        return fHaveAttribute;
    }// MoveToLastChild

    internal static bool MoveToNextNode(XMLData xData)
    {
        bool fAnother = false;
        
        XmlNode xNode = xData.xCurrentElement.NextSibling;
        while (xNode != null && !(xNode is XmlElement))
            xNode = xNode.NextSibling;
        
        if (xNode != null)
        {
            xData.xCurrentElement = (XmlElement)xNode;
            fAnother = true;
        }
        return fAnother;
    }// MoveToNextNode

    internal static bool MoveToParent(XMLData xData)
    {
        bool fHaveParent = false;
        if (xData.xCurrentElement.ParentNode != null)
        {
            xData.xCurrentElement = (XmlElement)xData.xCurrentElement.ParentNode;
            fHaveParent = true;
        }
        return fHaveParent;
    }// MoveToParent

    internal static bool RemoveNode(XMLData xData)
    {
        bool fCanRemove = false;
        
        if (xData.xCurrentElement != null)
        {
            xData.xCurrentElement.ParentNode.RemoveChild(xData.xCurrentElement);
            xData.xCurrentElement = null;
            fCanRemove = true;
        }
        return fCanRemove;
    }// RemoveNode



    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, uint type);

}// class CConfigStore
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccustomcodegroupprop.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Security.Policy;

internal class CCustomCodeGroupProp : CSecurityPropPage
{
    // Controls on the page
    Label m_lblHelp;
    TextBox m_txtXML;
    Label m_lblURL;

    // internal data
    CodeGroup       m_cg;

    internal CCustomCodeGroupProp(CodeGroup cg)
    {
        m_sTitle = CResourceStore.GetString("CCustomCodeGroupProp:PageTitle"); 
        m_cg = cg;
    }// CCustomCodeGroupProp 

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CCustomCodeGroupProp));
        this.m_txtXML = new System.Windows.Forms.TextBox();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblURL = new System.Windows.Forms.Label();
        this.m_txtXML.Location = ((System.Drawing.Point)(resources.GetObject("m_txtXML.Location")));
        this.m_txtXML.Multiline = true;
        this.m_txtXML.Size = ((System.Drawing.Size)(resources.GetObject("m_txtXML.Size")));
        this.m_txtXML.TabStop = false;
        m_txtXML.Name = "XML";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblURL.Location = ((System.Drawing.Point)(resources.GetObject("m_lblURL.Location")));
        this.m_lblURL.Size = ((System.Drawing.Size)(resources.GetObject("m_lblURL.Size")));
        this.m_lblURL.TabIndex = ((int)(resources.GetObject("m_lblURL.TabIndex")));
        this.m_lblURL.Text = resources.GetString("m_lblURL.Text");
        m_lblURL.Name = "Help2";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_txtXML,
                        this.m_lblURL,
                        this.m_lblHelp});
        // Some 'tweaks'
        m_txtXML.ReadOnly = true;
        // Fill in the data
        PutValuesinPage();
        return 1;
    }// InsertPropSheetPageControls

    private void PutValuesinPage()
    {
        // Get info that we'll need from the node
        m_txtXML.Text = m_cg.ToXml().ToString();
    }// PutValuesinPage
}// class CCustomCodeGroupProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\ccreatedeploymentpackagewizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security;
using System.Security.Policy;
using System.Reflection;
using System.Security.Permissions;
using System.Collections;
using System.Runtime.InteropServices;
using System.IO;
using System.Globalization;

class CCreateDeploymentPackageWizard: CSecurityWizard
{
    private const int PIDSI_REVNUMBER   =  9;
    private const int VT_LPSTR          =  30;

    private CGenSecurity m_secNode;
    internal CCreateDeploymentPackageWizard(CGenSecurity node)
    {
        m_secNode = node;
        m_aPropSheetPage = new CPropPage[] {
                                            new CCreateDeploymentPackageWiz1(),
                                            new CCreateDeploymentPackageWiz3(),
                                            new CCreateDeploymentPackageWiz2()
                                           };
                                                    
    }// CCreateDeploymentPackageWizard

    private CCreateDeploymentPackageWiz1 Page1
    {get{return (CCreateDeploymentPackageWiz1)m_aPropSheetPage[0];}}
    private CCreateDeploymentPackageWiz2 Page2
    {get{return (CCreateDeploymentPackageWiz2)m_aPropSheetPage[1];}}
    private CCreateDeploymentPackageWiz3 Page3
    {get{return (CCreateDeploymentPackageWiz3)m_aPropSheetPage[2];}}
    

    private String MSIFilename
    {
        get{ return Page1.Filename;}
    }// MSIFilename

    private PolicyLevelType MyPolicyLevel
    {
        get{ return Page1.MyPolicyLevel;}
    }// MyPolicyLevel
    
    private String FileToPackage
    {
        get{ return Page1.FileToPackage;}
    }// FileToPackage

    protected override int WizSetActive(IntPtr hwnd)
    {
        // Find out which property page this is....
        switch(GetPropPage(hwnd))
        {
            case 0:
                    if (MSIFilename.Length == 0)
                        TurnOnNext(false);
                    else
                        TurnOnNext(true);
                    break;

            case 1:
                    TurnOnFinish(true);
                    break;
            case 2:
                    TurnOnFinish(true);
                    break;
            default:
                   break;
                
        }
        return base.WizSetActive(hwnd);

                    
    }// WizSetActive

    protected override int WizNext(IntPtr hwnd)
    {
        // Find out which property page this is....
        switch(GetPropPage(hwnd))
        {
            case 0:
                if (!m_secNode.GetSecurityPolicyNode(MyPolicyLevel).isNoSave)
                    m_secNode.GetSecurityPolicyNode(MyPolicyLevel).SavePolicy(true);
            
                // Make sure that filename exists
                if (!File.Exists(FileToPackage))
                {
                    MessageBox(String.Format(CResourceStore.GetString("CCreateDeploymentPackageWizard:NoFile"), FileToPackage),
                               CResourceStore.GetString("CCreateDeploymentPackageWizard:NoFileTitle"),
                               MB.ICONEXCLAMATION);
                                                   
                    return -1;
                }
                break;
        }
        return base.WizNext(hwnd);
    }// WizNext


    protected override int WizFinish()
    {
        return CreateMyMSIFile(FileToPackage, MSIFilename, MyPolicyLevel)?0:-1;
    }// WizFinish

    internal bool CreateMyMSIFile(String sNameOfFileToPackage, String sNameOfMSIFile, PolicyLevelType polType)
    {
        int nRet=0;
        IntPtr hDatabase = (IntPtr)0;   

        try
        {
            // Get the path off of the MSI File to create.
            int nEndOfDirectory = sNameOfMSIFile.LastIndexOf('\\');
            String sDirectory = sNameOfMSIFile.Substring(0, nEndOfDirectory + 1);

            int nEndOfXMLDirectory = sNameOfFileToPackage.LastIndexOf('\\');
            String sFileName = sNameOfFileToPackage.Substring(nEndOfXMLDirectory+1);
        
            // First, create the cab file
            CreateCab(sNameOfFileToPackage, sDirectory + "SECXML.CAB");

            // Ok, now we need to create our MSI file.... ugh
            IntPtr hView = (IntPtr)0;
            IntPtr hNewRecord = (IntPtr)0;

            // Create a GUID unique to this installation package
            String sMyGuid = "{" + System.Guid.NewGuid().ToString().ToUpper(CultureInfo.InvariantCulture) + "}";

            // Copy our template file to the file we want to create
            byte[] bMSITemplate = null;

            if (polType == PolicyLevelType.User)
                bMSITemplate = CResourceStore.GetMSI("USER_MSI");
            else
                bMSITemplate = CResourceStore.GetMSI("MACHINE_MSI");


            // Save this template....
            try
            {
                FileStream fs = new FileStream(sNameOfMSIFile, FileMode.Create);
                fs.Write(bMSITemplate, 0, bMSITemplate.Length);
                fs.Close();
            }
            catch(Exception)
            {
                MessageBox(String.Format(CResourceStore.GetString("CCreateDeploymentPackageWizard:ErrorWritingFile"), sNameOfMSIFile),
                           CResourceStore.GetString("CCreateDeploymentPackageWizard:ErrorWritingFileTitle"),
                           MB.ICONEXCLAMATION);
                return false;

            }
            nRet = MsiOpenDatabase(sNameOfMSIFile, 1, out hDatabase);

            if (nRet != 0)
                throw new Exception("Error opening database file 1");

            //-----------------------------------------
            // First, add a GUID to this MSI (so we don't need to worry about cached MSIs)
            //-----------------------------------------
            IntPtr hSummaryInfo;
            nRet = MsiGetSummaryInformation(hDatabase, null, 15, out hSummaryInfo);
            if (nRet != 0)
                throw new Exception("MsiGetSummaryInformation failed 2");

            // Place the guid in our table
            nRet = MsiSummaryInfoSetProperty(hSummaryInfo, PIDSI_REVNUMBER, VT_LPSTR, 0, 0, sMyGuid);
            if (nRet != 0)
             throw new Exception("MsiSummaryInfoSetProperty failed 3");

            // Save this change
            nRet = MsiSummaryInfoPersist(hSummaryInfo);
            if (nRet != 0)
                throw new Exception("MsiSummaryInfoPersist 4");

            MsiCloseHandle(hSummaryInfo);

            //-----------------------------------------
            // Now put this guid in as the product code
            //-----------------------------------------
        
            hNewRecord = MsiCreateRecord(2);
            nRet = MsiRecordSetString(hNewRecord, 1, "ProductCode");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 5");
        
            nRet = MsiRecordSetString(hNewRecord, 2, sMyGuid);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 6");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO Property (Property, Value) VALUES (?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView 7");

            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute 8");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);

            //-----------------------------------------
            // Now put this Product Name in 
            //-----------------------------------------
            String sProductName;
            if (polType == PolicyLevelType.User)
                sProductName = CResourceStore.GetString("CCreateDeploymentPackageWizard:UserPolicy");
            else if (polType == PolicyLevelType.Machine)
                sProductName = CResourceStore.GetString("CCreateDeploymentPackageWizard:MachinePolicy");
            else  // an Enterprise level
                sProductName = CResourceStore.GetString("CCreateDeploymentPackageWizard:EnterprisePolicy");

            hNewRecord = MsiCreateRecord(2);
            nRet = MsiRecordSetString(hNewRecord, 1, "ProductName");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 5");
        
            nRet = MsiRecordSetString(hNewRecord, 2, sProductName);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 6");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO Property (Property, Value) VALUES (?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView 7");

            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute 8");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);
          
            //-----------------------------------------
            // Now put in the Version 
            //-----------------------------------------
            
            // We'll get the version of mscorlib that we're running with....
            // Mscorlib should be providing us with the int type
            Assembly ast = Assembly.GetAssembly(typeof(object));

            // This should give us something like
            // c:\winnt\complus\v1.x86chk\mscorlib.dll
            // We need to strip off the version... aka, we're after
            // v1.x86chk
        
            String sBase = ast.Location.Replace('/', '\\');
            String[] sPieces = sBase.Split(new char[] {'\\'});
            String sVersion = sPieces[sPieces.Length-2];
            
            hNewRecord = MsiCreateRecord(2);
            nRet = MsiRecordSetString(hNewRecord, 1, "ProductVersion");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 5");

            // The version needs to be a real version, and not something funky,
            // like v1.x86chk or even v1.2.3.4. Right now, we'll just put in 
            // the version of mscorlib.dll as a hard coded string, and replace it
            // in RTM when SBS isn't completely screwed up. When everything is working
            // correctly, we will be able to put in sVersion and we'll be set.
            nRet = MsiRecordSetString(hNewRecord, 2, "1.0.2411.0");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 6");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO Property (Property, Value) VALUES (?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView 7");

            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute 8");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);
        
            //-----------------------------------------
            // Now put the file info in....
            //-----------------------------------------
        
            hNewRecord = MsiCreateRecord(5);

            // Put in the File "Key"
            nRet = MsiRecordSetString(hNewRecord, 1, sFileName);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 9");
            // Put in the Component value
            nRet = MsiRecordSetString(hNewRecord, 2, "NETSECURITY");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 10");
            // Put in the filename    
            nRet = MsiRecordSetString(hNewRecord, 3, sFileName + "|" + sFileName);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 11");
            // Put in the file length
            nRet = MsiRecordSetInteger(hNewRecord, 4, (int)(new FileInfo(sNameOfFileToPackage).Length));
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 12");
            // Put in the sequence number
            nRet = MsiRecordSetInteger(hNewRecord, 5, 1);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO File (File, Component_, FileName, FileSize, Sequence) VALUES (?, ?, ?, ?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView 13");
                
            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute 14");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);

            //-----------------------------------------
            // MSI has this nasty habit in that it won't write
            // over a pre-existing file if that pre-existing file
            // is newer than the file that we're trying to install.
            // We'll get around that by having MSI delete any file
            // that might exist before we try and install our packaged one
            //-----------------------------------------

            hNewRecord = MsiCreateRecord(5);

            // Put in the FileKey
            nRet = MsiRecordSetString(hNewRecord, 1, sFileName);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 9");
            // Put in the Component value
            nRet = MsiRecordSetString(hNewRecord, 2, "NETSECURITY");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 10");
            // Put in the filename    
            nRet = MsiRecordSetString(hNewRecord, 3, sFileName);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 11");
            // Put in the Directory
            if (polType == PolicyLevelType.User)
                nRet = MsiRecordSetString(hNewRecord, 4, "VERSIONDIRECTORY");
            else
                nRet = MsiRecordSetString(hNewRecord, 4, "CONFIGDIRECTORY");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 12");
            // Put in the install mode
            // We'll put in an install mode of '1'. That means that this
            // file will only be removed when we are installing a package.
            nRet = MsiRecordSetInteger(hNewRecord, 5, 1);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO RemoveFile (FileKey, Component_, FileName, DirProperty, InstallMode) VALUES (?, ?, ?, ?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView 13");
                
            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute 14");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);

        


            //-----------------------------------------
            // Now put the directory entry....
            //-----------------------------------------
        
            hNewRecord = MsiCreateRecord(3);

            // Put in the Directory "Key"
            nRet = MsiRecordSetString(hNewRecord, 1, "VERSIONDIRECTORY");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 9");

            // Put in the Display Parent value
            if (polType == PolicyLevelType.User)
                nRet = MsiRecordSetString(hNewRecord, 2, "CLRSECURITYCONFIG");
            else
                nRet = MsiRecordSetString(hNewRecord, 2, "CLRINSTALLROOT");
            
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 10");
            // Put in the filename    
            nRet = MsiRecordSetString(hNewRecord, 3, sVersion + "|" + sVersion);
            if (nRet != 0)
                throw new Exception("MsiRecordSetString 11");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO Directory (Directory, Directory_Parent, DefaultDir) VALUES (?, ?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView 13");
                
            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute 14");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);
      

            //-----------------------------------------
            // Now add the new cab to the MSI file
            //-----------------------------------------
               
    	    hNewRecord = MsiCreateRecord(2);
            if (hNewRecord == (IntPtr)0)
                throw new Exception("MsiCreateRecord failed 15");

            nRet = MsiRecordSetString(hNewRecord, 1, "SECXML.CAB");
            if (nRet != 0)
                throw new Exception("MsiRecordSetString failed 16");

            nRet=MsiRecordSetStream(hNewRecord, 2, sDirectory + "SECXML.CAB");
            if (nRet != 0)
                throw new Exception("MsiRecordSetStream failed 17");

            nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO `_Streams` (Name, Data) VALUES (?, ?)", out hView);
            if (nRet != 0)
                throw new Exception("MsiDatabaseOpenView failed 19");
        
            nRet = MsiViewExecute(hView, hNewRecord);
            if (nRet != 0)
                throw new Exception("MsiViewExecute failed 20");

            MsiCloseHandle(hView);
            MsiCloseHandle(hNewRecord);

            //-----------------------------------------
            // Now put in the error message we'll display
            // if the .NET framework isn't installed on the machine
            // the user tries to deploy this package to. But, we'll only
            // do this if we're dealing with a machine or enterprise policy
            // deployment
            //-----------------------------------------
            if (polType != PolicyLevelType.User)
            {
                hNewRecord = MsiCreateRecord(3);
                if (hNewRecord == (IntPtr)0)
                    throw new Exception("MsiCreateRecord failed");

                nRet = MsiRecordSetString(hNewRecord, 1, "VERIFYINSTALLROOT");
                if (nRet != 0)
                    throw new Exception("MsiRecordSetString failed");

                nRet=MsiRecordSetInteger(hNewRecord, 2, 19);
                if (nRet != 0)
                    throw new Exception("MsiRecordSetInteger");
                
                nRet=MsiRecordSetString(hNewRecord, 3, CResourceStore.GetString("CCreateDeploymentPackageWizard:FrameworkNotExist"));
                if (nRet != 0)
                    throw new Exception("MsiRecordSetString");

                nRet = MsiDatabaseOpenView(hDatabase, "INSERT INTO `CustomAction` (Action, Type, Target) VALUES (?, ?, ?)", out hView);
                if (nRet != 0)
                    throw new Exception("MsiDatabaseOpenView failed");
        
                nRet = MsiViewExecute(hView, hNewRecord);
                if (nRet != 0)
                    throw new Exception("MsiViewExecute failed");

                MsiCloseHandle(hView);
                MsiCloseHandle(hNewRecord);
            }


            //-----------------------------------------
            // Update the LockPermissions table
            //
            // We only need to worry about this if we're working with either the 
            // machine policy or the enterprise policy
            //-----------------------------------------
            if (polType != PolicyLevelType.User)
            {
                nRet = MsiDatabaseOpenView(hDatabase, "SELECT * FROM `LockPermissions`", out hView);
                if (nRet != 0)
                    throw new Exception("MsiDatabaseOpenView failed " + nRet.ToString());
        
                nRet = MsiViewExecute(hView, (IntPtr)0);
                if (nRet != 0)
                    throw new Exception("MsiViewExecute failed");

                IntPtr hRecord;
        
                nRet = MsiViewFetch(hView, out hRecord);
                if (nRet != 0)
                    throw new Exception("MsiViewFetch failed " + nRet.ToString());
    
                nRet = MsiRecordSetString(hRecord, 1, sFileName);
                if (nRet != 0)
                    throw new Exception("MsiRecordSetString failed " + nRet.ToString());
            
                /*nRet = MsiViewModify(hView, 2, hRecord);
                if (nRet != 0)
                    throw new Exception("MsiRecordSetStream failed");
*/
                MsiCloseHandle(hView);
                MsiCloseHandle(hRecord);
            }
            //-----------------------------------------
            // Commit the change to the MSI file
            //-----------------------------------------
           
            MsiDatabaseCommit(hDatabase);
            MsiCloseHandle(hDatabase);

            //-----------------------------------------
            // Now remove the cab file we created on the disk
            //-----------------------------------------
            File.Delete(sDirectory + "SECXML.CAB");
            return true;
        }
        catch (Exception)
        {
            MsiCloseHandle(hDatabase);
            MessageBox(String.Format(CResourceStore.GetString("CCreateDeploymentPackageWizard:ErrorEditingFile"), sNameOfMSIFile),
                       CResourceStore.GetString("CCreateDeploymentPackageWizard:ErrorEditingFileTitle"),
                       MB.ICONEXCLAMATION);
            // Try and delete the file we were creating.
            File.Delete(sNameOfMSIFile);
            return false;
        }
    }// CreateMyMSIFile

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiOpenDatabase(String szDatabasePath, int szPersist, out IntPtr phDatabase);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiDatabaseOpenView(IntPtr hDatabase, String szQuery, out IntPtr phView);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiViewExecute(IntPtr hView, IntPtr hRecord);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiCloseHandle(IntPtr handle);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiDatabaseCommit(IntPtr handle);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiViewFetch(IntPtr hView, out IntPtr phRecord);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiRecordSetStream(IntPtr hRecord, uint iField, String szFilePath);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiViewModify(IntPtr hView, uint eModifyMode, IntPtr hRecord);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern IntPtr MsiCreateRecord(uint cParams);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiRecordSetString(IntPtr hRecord, uint iField, String szValue);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiRecordSetInteger(IntPtr hRecord, uint iField, int iValue);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiRecordGetString(IntPtr hRecord, uint iField, IntPtr szValue, ref int pcchValueBuf);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiGetSummaryInformation(IntPtr hRecord, String szDatabasePath, uint uiUpdateCount, out IntPtr phSummaryInfo);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiSummaryInfoSetProperty(IntPtr hSummaryInfo, uint uiProperty, uint uiDataType, int iValue, int pftValue, String szValue);

    [DllImport("msi.dll", CharSet=CharSet.Auto)]
    internal static extern int MsiSummaryInfoPersist(IntPtr hSummaryInfo);

    [DllImport("mscortim.dll", CharSet=CharSet.Ansi)]
    internal static extern int CreateCab(String szFileToCompress, String szCabFilename);
 
}// class CCreateDeploymentPackageWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cgenapptaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;

class CGenAppTaskPad : CTaskPad
{
    internal CGenAppTaskPad(CNode node) : base (node)
    {
    }// CGenAppTaskPad
    
    internal override void Notify(Object arg, Object param, IConsole2 con, CData com)
    {
        if ((int)arg == 1)
        {
            // We need to fire up the Add application wizard.
            m_myNode.MenuCommand(COMMANDS.ADD_APPLICATION);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(m_myNode), COMMANDS.ADD_APPLICATION);

        }
        else if ((int)arg == 2)
        {
            m_myNode.MenuCommand(COMMANDS.FIX_APPLICATION);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(m_myNode), COMMANDS.FIX_APPLICATION);
        }

    }// Notify

    protected override String GetHTMLFilename()
    {
        return "GENAPP_HTML";
    }// GetHTMLFilename
    
}// class CGenAppTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cevalassemwiz3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security;
using System.Security.Permissions;
using System.Reflection;
using System.Security.Policy;


internal class CEvalAssemWiz3 : CWizardPage
{
    // Controls on the page

    private TextBox m_txtAssemEval;
    private TreeView m_tvCodegroups;
    private TextBox m_txtLevelEval;
    private Label m_lblAssemEval;
    private Label m_lblViewCodegroups;
    private Label m_lblLevelEval;
    
    // Internal data
    String              m_sAssemName;
    int                 m_nPolicyLevel;
    ImageList           m_ilIcons;
    CodeGroup[]         m_cgMatchingCGs;

    const int   ENTERPRISENODE      = 0;
    const int   MACHINENODE         = 1;
    const int   USERNODE            = 2;
    const int   UNIONCODEGROUP      = 3;
    const int   NONUNIONCODEGROUP   = 4;
    const int   INFOICON            = 5;

    internal class MyTreeNode : TreeNode
    {
        CodeGroup m_cg;
        
        internal MyTreeNode(String sName, CodeGroup cg) : base(sName)
        {
            m_cg = cg;
        }// MyTreeNode

        internal CodeGroup cg
        {
            get{return m_cg;}
        }// CG
    }// MyTreeNode

       
    internal CEvalAssemWiz3()
    {
        m_sTitle=CResourceStore.GetString("CEvalAssemWiz3:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CEvalAssemWiz3:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CEvalAssemWiz3:HeaderSubTitle");
    }// CEvalAssemWiz2

    internal bool Init(String sAssemName, int nPolicyLevel, CodeGroup[] cg)
    {
        m_sAssemName=sAssemName;
        m_nPolicyLevel = nPolicyLevel;
        m_cgMatchingCGs = cg;
        return true;
    }// Init

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CEvalAssemWiz3));
        this.m_txtAssemEval = new System.Windows.Forms.TextBox();
        this.m_tvCodegroups = new System.Windows.Forms.TreeView();
        this.m_txtLevelEval = new System.Windows.Forms.TextBox();
        this.m_lblAssemEval = new System.Windows.Forms.Label();
        this.m_lblViewCodegroups = new System.Windows.Forms.Label();
        this.m_lblLevelEval = new System.Windows.Forms.Label();
        this.m_txtAssemEval.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtAssemEval.Location = ((System.Drawing.Point)(resources.GetObject("m_txtAssemEval.Location")));
        this.m_txtAssemEval.ReadOnly = true;
        this.m_txtAssemEval.Size = ((System.Drawing.Size)(resources.GetObject("m_txtAssemEval.Size")));
        this.m_txtAssemEval.TabStop = false;
        m_txtAssemEval.Name = "Assembly";
        this.m_tvCodegroups.Location = ((System.Drawing.Point)(resources.GetObject("m_tvCodegroups.Location")));
        this.m_tvCodegroups.Size = ((System.Drawing.Size)(resources.GetObject("m_tvCodegroups.Size")));
        this.m_tvCodegroups.TabIndex = ((int)(resources.GetObject("m_tvCodegroups.TabIndex")));
        m_tvCodegroups.Name = "Codegroups";
        this.m_txtLevelEval.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_txtLevelEval.Location = ((System.Drawing.Point)(resources.GetObject("m_txtLevelEval.Location")));
        this.m_txtLevelEval.ReadOnly = true;
        this.m_txtLevelEval.Size = ((System.Drawing.Size)(resources.GetObject("m_txtLevelEval.Size")));
        this.m_txtLevelEval.TabStop = false;
        m_txtLevelEval.Name = "PolicyLevel";
        this.m_lblAssemEval.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAssemEval.Location")));
        this.m_lblAssemEval.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAssemEval.Size")));
        this.m_lblAssemEval.TabIndex = ((int)(resources.GetObject("m_lblAssemEval.TabIndex")));
        this.m_lblAssemEval.Text = resources.GetString("m_lblAssemEval.Text");
        m_lblAssemEval.Name = "AssemblyLabel";
        this.m_lblViewCodegroups.Location = ((System.Drawing.Point)(resources.GetObject("m_lblViewCodegroups.Location")));
        this.m_lblViewCodegroups.Size = ((System.Drawing.Size)(resources.GetObject("m_lblViewCodegroups.Size")));
        this.m_lblViewCodegroups.TabIndex = ((int)(resources.GetObject("m_lblViewCodegroups.TabIndex")));
        this.m_lblViewCodegroups.Text = resources.GetString("m_lblViewCodegroups.Text");
        m_lblViewCodegroups.Name = "ViewCodegroupLabel";
        this.m_lblLevelEval.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLevelEval.Location")));
        this.m_lblLevelEval.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLevelEval.Size")));
        this.m_lblLevelEval.TabIndex = ((int)(resources.GetObject("m_lblLevelEval.TabIndex")));
        this.m_lblLevelEval.Text = resources.GetString("m_lblLevelEval.Text");
        m_lblLevelEval.Name = "PolicyLevelLabel";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_txtLevelEval,
                        this.m_lblViewCodegroups,
                        this.m_tvCodegroups,
                        this.m_txtAssemEval,
                        this.m_lblLevelEval,
                        this.m_lblAssemEval});

        // Create an image list of icons we'll be displaying
        m_ilIcons = new ImageList();
        // Keep the order of these consistant with the const's declared at the top
        // of this class
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("enterprisepolicy_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("machinepolicy_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("userpolicy_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("singlecodegroup_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("customcodegroup_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("info_ico")));

        m_tvCodegroups.ImageList = m_ilIcons;

        
        return 1;
    }// InsertPropSheetPageControls


    internal bool PutValuesinPage()
    {
        m_txtAssemEval.Text = m_sAssemName;
        m_txtAssemEval.Select(0, 0);
        m_txtLevelEval.Select(0, 0);
        m_txtLevelEval.Text = CEvalAssemWizard.GetDisplayString(m_nPolicyLevel);

        m_tvCodegroups.Nodes.Clear();

        // Figure out the real policy level
        if (m_nPolicyLevel != CEvalAssemWizard.ALL_CODEGROUPS)
        {
            // We only want to show one policy level
            
            // Figure out what Icon, index, and display string to use
            int nImageIndex = ENTERPRISENODE;

            if (m_nPolicyLevel == CEvalAssemWizard.ENTERPRISE_CODEGROUPS)
                nImageIndex = ENTERPRISENODE;
            else if (m_nPolicyLevel == CEvalAssemWizard.MACHINE_CODEGROUPS)
                nImageIndex = MACHINENODE;
            else 
                nImageIndex = USERNODE;
            // Let's start walking our tree
            MyTreeNode tn = new MyTreeNode(m_txtLevelEval.Text, null);
            tn.ImageIndex = tn.SelectedImageIndex = nImageIndex;
            m_tvCodegroups.Nodes.Add(tn);
            
            PutInCodeGroup(m_cgMatchingCGs[m_nPolicyLevel], tn);
        }
        else // They want to look at all the code groups...
        {
            String[] sNodeNames = new String[] {CResourceStore.GetString("Enterprise Policy"),
                                                CResourceStore.GetString("Machine Policy"),
                                                CResourceStore.GetString("User Policy")};

            int[] nImageIndex = new int[] {ENTERPRISENODE,MACHINENODE,USERNODE};
            for(int i=0; i<3; i++)
            {
                MyTreeNode tn = new MyTreeNode(sNodeNames[i], null);
                tn.ImageIndex = tn.SelectedImageIndex = nImageIndex[i];
                m_tvCodegroups.Nodes.Add(tn);

                // If no codegroups evaulated for this level....
                if (m_cgMatchingCGs == null || m_cgMatchingCGs[i] == null)
                {   
                    MyTreeNode newtn = new MyTreeNode(CResourceStore.GetString("CEvalAssemWiz3:NoCodegroups"), null);
                    newtn.ImageIndex = newtn.SelectedImageIndex = INFOICON;
                    tn.Nodes.Add(newtn);
                }
                // If we didn't evaluate codegroups for this policy level because
                // a higher policy level contained a 'Level Final' codegroup
                else if (m_cgMatchingCGs[i] is NotEvalCodegroup)
                {   
                    MyTreeNode newtn = new MyTreeNode(CResourceStore.GetString("CEvalAssemWiz3:NotEvalCodegroups"), null);
                    newtn.ImageIndex = newtn.SelectedImageIndex = INFOICON;
                    tn.Nodes.Add(newtn);
                }
                // We actually did get some codegroups
                else
                    PutInCodeGroup(m_cgMatchingCGs[i], tn);
            }                    
        }
        return true;
    }// PutValuesinPage

    void PutInCodeGroup(CodeGroup cg, TreeNode tn)
    {
        MyTreeNode newtn = new MyTreeNode(cg.Name, cg);
        newtn.ImageIndex = newtn.SelectedImageIndex = (cg is UnionCodeGroup)?UNIONCODEGROUP:NONUNIONCODEGROUP;
        tn.Nodes.Add(newtn);

        // Now run through this codegroup's children
        IEnumerator enumCodeGroups = cg.Children.GetEnumerator();

        while (enumCodeGroups.MoveNext())
        {
            CodeGroup group = (CodeGroup)enumCodeGroups.Current;
            PutInCodeGroup(group, newtn);
        }
    }// PutInCodeGroup
}// class CEvalAssemWiz3
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cevalassemwiz2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security;
using System.Security.Policy;
using System.Security.Permissions;
using System.Reflection;
using System.Net;


internal class CEvalAssemWiz2 : CWizardPage
{
    const int   UNRESTRICTEDIMAGEINDEX  = 0;
    const int   PARTIALIMAGEINDEX       = 1;

    // Controls on the page

    ListView m_lvPermissions;
    Label m_lblLevelEval;
    Label m_lblHelpPerm;
    TextBox m_txtAssemEval;
    Label m_lblHelp;
    Label m_lblAssemEval;
    Label m_lblLevelEvalVal;
    Button m_btnViewPerm;

    ImageList   m_ilIcons;

    // Internal data
    String              m_sAssemName;
    int                 m_nPolicyLevel;
    PermissionSet       m_ps;

    internal CEvalAssemWiz2()
    {
        m_sTitle=CResourceStore.GetString("CEvalAssemWiz2:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CEvalAssemWiz2:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CEvalAssemWiz2:HeaderSubTitle");
    }// CEvalAssemWiz2

    internal bool Init(String sAssemName, int nPolicyLevel, PermissionSet ps)
    {
        m_sAssemName=sAssemName;
        m_nPolicyLevel = nPolicyLevel;
        m_ps = ps;
        return true;
    }// Init

    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CEvalAssemWiz2));
        this.m_lvPermissions = new System.Windows.Forms.ListView();
        this.m_lblLevelEval = new System.Windows.Forms.Label();
        this.m_lblHelpPerm = new System.Windows.Forms.Label();
        this.m_txtAssemEval = new System.Windows.Forms.TextBox();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblAssemEval = new System.Windows.Forms.Label();
        this.m_lblLevelEvalVal = new System.Windows.Forms.Label();
        this.m_btnViewPerm = new System.Windows.Forms.Button();
        this.m_lvPermissions.Location = ((System.Drawing.Point)(resources.GetObject("m_lvPermissions.Location")));
        this.m_lvPermissions.Size = ((System.Drawing.Size)(resources.GetObject("m_lvPermissions.Size")));
        this.m_lvPermissions.TabIndex = ((int)(resources.GetObject("m_lvPermissions.TabIndex")));
        m_lvPermissions.Name = "Permissions";
        this.m_lblLevelEval.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLevelEval.Location")));
        this.m_lblLevelEval.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLevelEval.Size")));
        this.m_lblLevelEval.TabIndex = ((int)(resources.GetObject("m_lblLevelEval.TabIndex")));
        this.m_lblLevelEval.Text = resources.GetString("m_lblLevelEval.Text");
        m_lblLevelEval.Name = "PolicyLevelLabel";
        this.m_lblHelpPerm.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelpPerm.Location")));
        this.m_lblHelpPerm.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelpPerm.Size")));
        this.m_lblHelpPerm.TabIndex = ((int)(resources.GetObject("m_lblHelpPerm.TabIndex")));
        this.m_lblHelpPerm.Text = resources.GetString("m_lblHelpPerm.Text");
        m_lblHelpPerm.Name = "HelpPerm";
        this.m_txtAssemEval.Location = ((System.Drawing.Point)(resources.GetObject("m_txtAssemEval.Location")));
        this.m_txtAssemEval.ReadOnly = true;
        this.m_txtAssemEval.Size = ((System.Drawing.Size)(resources.GetObject("m_txtAssemEval.Size")));
        this.m_txtAssemEval.TabStop = false;
        this.m_txtAssemEval.Text = resources.GetString("m_txtAssemEval.Text");
        m_txtAssemEval.Name = "Assembly";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblAssemEval.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAssemEval.Location")));
        this.m_lblAssemEval.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAssemEval.Size")));
        this.m_lblAssemEval.TabIndex = ((int)(resources.GetObject("m_lblAssemEval.TabIndex")));
        this.m_lblAssemEval.Text = resources.GetString("m_lblAssemEval.Text");
        m_lblAssemEval.Name = "AssemblyLabel";
        this.m_lblLevelEvalVal.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLevelEvalVal.Location")));
        this.m_lblLevelEvalVal.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLevelEvalVal.Size")));
        this.m_lblLevelEvalVal.TabIndex = ((int)(resources.GetObject("m_lblLevelEvalVal.TabIndex")));
        this.m_lblLevelEvalVal.Text = resources.GetString("m_lblLevelEvalVal.Text");
        m_lblLevelEvalVal.Name = "PolicyLevel";
        this.m_btnViewPerm.Location = ((System.Drawing.Point)(resources.GetObject("m_btnViewPerm.Location")));
        this.m_btnViewPerm.Size = ((System.Drawing.Size)(resources.GetObject("m_btnViewPerm.Size")));
        this.m_btnViewPerm.TabIndex = ((int)(resources.GetObject("m_btnViewPerm.TabIndex")));
        this.m_btnViewPerm.Text = resources.GetString("m_btnViewPerm.Text");
        m_btnViewPerm.Name = "ViewPermissions";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblHelpPerm,
                        this.m_lblHelp,
                        this.m_lvPermissions,
                        this.m_btnViewPerm,
                        this.m_txtAssemEval,
                        this.m_lblLevelEvalVal,
                        this.m_lblLevelEval,
                        this.m_lblAssemEval});

        // Create an image list of icons we'll be displaying
        m_ilIcons = new ImageList();
        // Keep the order of these consistant with the const's declared at the top
        // of this class
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("permission_ico")));
        m_ilIcons.Images.Add(System.Drawing.Icon.FromHandle(CResourceStore.GetHIcon("permission_ico")));

        // Some customizations we've made....
        m_lvPermissions.DoubleClick += new EventHandler(onViewPermsClick);
        m_btnViewPerm.Click += new EventHandler(onViewPermsClick);

        m_lvPermissions.SmallImageList = m_ilIcons;
        m_lvPermissions.MultiSelect = false;
        m_lvPermissions.View = View.Details;

        m_lvPermissions.HeaderStyle = ColumnHeaderStyle.None;
        ColumnHeader ch = new ColumnHeader();
        ch.Text = "Permission";
        ch.Width = ((System.Drawing.Size)(resources.GetObject("m_lvPermissions.Size"))).Width-17;
        m_lvPermissions.Columns.Add(ch);
        m_txtAssemEval.BorderStyle = BorderStyle.None;
        return 1;
    }// InsertPropSheetPageControls

    internal bool PutValuesinPage()
    {
        m_txtAssemEval.Text = m_sAssemName;
        // Make sure this starts off enabled
        m_btnViewPerm.Enabled=true;

        m_lblLevelEvalVal.Text = CEvalAssemWizard.GetDisplayString(m_nPolicyLevel);
    
        // Display the various permissions in the currently selected permission set
        m_lvPermissions.Items.Clear();
        if (m_ps != null)
        {
            if (m_ps.IsUnrestricted())
            {
                ListViewItem lvi = new ListViewItem(CResourceStore.GetString("Unrestricted"), UNRESTRICTEDIMAGEINDEX);
                m_lvPermissions.Items.Add(lvi);
                m_btnViewPerm.Enabled=false;
            }
            else
            {
                IEnumerator permEnumerator = m_ps.GetEnumerator();
                while (permEnumerator.MoveNext())
                {
                    IPermission perm = (IPermission)permEnumerator.Current;
                    int nImageIndex = DeterminePermissionIcon(perm);
                    ListViewItem lvi = new ListViewItem(Security.GetDisplayStringForPermission(perm), nImageIndex);
                    m_lvPermissions.Items.Add(lvi);
                }
            }
        }

        m_txtAssemEval.Select(0,0);
        return true;
    }// PutValuesinPage

    private int DeterminePermissionIcon(IPermission perm)
    {
        if (perm is IUnrestrictedPermission)
        {
            IUnrestrictedPermission permission = (IUnrestrictedPermission)perm;
            // If this is unrestricted....
            if (permission.IsUnrestricted())
                return UNRESTRICTEDIMAGEINDEX;

            // else, this has partial permissions....
            return PARTIALIMAGEINDEX;
        }
        // Otherwise... we don't know...
        return PARTIALIMAGEINDEX;
    }// DeterminePermissionIcon

    void onViewPermsClick(Object o, EventArgs e)
    {
        int iIndex=0;
        if (m_ps != null && !m_ps.IsUnrestricted() && m_lvPermissions.SelectedIndices.Count > 0)
        {
            IEnumerator permEnumerator = m_ps.GetEnumerator();
            while (permEnumerator.MoveNext() && iIndex != m_lvPermissions.SelectedIndices[0])
                iIndex++;

            new CReadOnlyPermission((IPermission)permEnumerator.Current).ShowDialog();
        }
    }// onViewPermsClick
}// class CEvalAssemWiz2
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cevalassemwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security;
using System.Security.Policy;
using System.Threading;

internal class CEvalAssemWizard: CSecurityWizard
{
    PermissionSet   m_psGrantedPermissionSet;
    CodeGroup[]     m_cgMatchingCodeGroups;
    Evidence        m_ev;
    bool            m_fGetPermissions;

    Thread          m_tPermissionSet;
    ThreadPriority  m_tpPermissionSet;
    
    Thread          m_tCodegroup;
    ThreadPriority  m_tpCodegroup;

    // These get set if we run into error conditions
    bool            m_fPermErrors;
    String          m_sPermErrorMessage;

    bool            m_fCGErrors;
    String          m_sCGErrorMessage;

    internal const int ENTERPRISE_CODEGROUPS = 0;
    internal const int MACHINE_CODEGROUPS = 1;
    internal const int USER_CODEGROUPS = 2;
    internal const int ALL_CODEGROUPS = 3;
    
    internal CEvalAssemWizard()
    {
        m_sName="Evaluate an Assembly Wizard";
        m_aPropSheetPage = new CPropPage[] {new CEvalAssemWiz1(), new CEvalAssemWiz2(), new CEvalAssemWiz3()};
        m_psGrantedPermissionSet = null;
        m_fGetPermissions = true;
        m_fPermErrors = false;
        m_sPermErrorMessage = null;
        m_fCGErrors = false;
        m_sCGErrorMessage = null;


        // Setup the threads we use to determine policy, and give them
        // appropriate priorities
        m_tPermissionSet = new Thread(new ThreadStart(CreateGrantedPermissionSet));
        m_tpPermissionSet = ThreadPriority.Normal;
        SetThreadPriority(m_tPermissionSet, m_tpPermissionSet);
        m_tCodegroup = new Thread(new ThreadStart(CreateGrantedCodegroups));
        m_tpCodegroup = ThreadPriority.Lowest;
        SetThreadPriority(m_tCodegroup, m_tpCodegroup);
        
    }// CEvalAssemWizard

    private CEvalAssemWiz1 Page1
    {
        get{return (CEvalAssemWiz1)m_aPropSheetPage[0];}
    }// Page1

    private CEvalAssemWiz2 Page2
    {
        get{return (CEvalAssemWiz2)m_aPropSheetPage[1];}
    }// Page1

    private CEvalAssemWiz3 Page3
    {
        get{return (CEvalAssemWiz3)m_aPropSheetPage[2];}
    }// Page1


    protected override int WizSetActive(IntPtr hwnd)
    {
        // Find out which property page this is....
        switch(GetPropPage(hwnd))
        {
            // If this is the first page of our wizard, we want a 
            // disabled next button to show
            case 0:
                if (Page1.Filename == null || Page1.Filename.Length==0)
                    TurnOnNext(false);
                else
                    TurnOnNext(true);
                break;
            case 1:
                Page2.PutValuesinPage();
                TurnOnFinish(true);
                break;
            case 2:
                Page3.PutValuesinPage();
                TurnOnFinish(true);
                break;
        }
        return base.WizSetActive(hwnd);
                    
    }// WizSetActive

    protected override int WizBack(IntPtr hwnd)
    {
        int nIndex = GetPropPage(hwnd);
        if (nIndex == 2)
        {
            SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)0, (IntPtr)(-1));
            return -1;
        }
        else 
            return base.WizBack(hwnd);

    }// WizBack

    protected override int WizNext(IntPtr hwnd)
    {
        int nIndex = GetPropPage(hwnd);
        int nReturnCode = -1;
        int nPageToGo = 0;

        switch(nIndex)
        {
            case 0:
                    // If we don't have any evidence, then something is wrong...
                    if (m_ev == null || !Page1.HaveCurrentEvidence)
                    {
                        m_ev = Page1.GetEvidence();
                        // Their assembly is bogus... don't let them leave this page
                        if (m_ev == null)
                            return -1;
                        NewEvidenceReceived(m_ev);
                    }
            
                    Thread tImportant = m_fGetPermissions?m_tPermissionSet:m_tCodegroup;
                    // Now give this thread top priority so it can get done with what
                    // it needs to do
                    SetThreadPriority(tImportant, ThreadPriority.Highest);
                    tImportant.Join();

                    // If they want to jump to page 3....
                    if (!Page1.ShowPermissions)
                    {
                        if (m_cgMatchingCodeGroups == null)
                        {
                            // This is screwy. If that's the case, then our thread completed
                            // but didn't do anything. We'll do the codegroup evaulation on 
                            // this thread.
                            CreateGrantedCodegroups();
                        }
                        
                        if (m_fCGErrors)
                        {
                            MessageBox(m_sCGErrorMessage,
                                       CResourceStore.GetString("CEvalAssemWizard:ErrorTitle"),
                                       MB.ICONEXCLAMATION);
                            return -1;                                   

                        }
                        
                        if (Page3.Init(Page1.Filename, Page1.PolicyLevel, m_cgMatchingCodeGroups))
                            nPageToGo = 2;
                    }
                    else 
                    {
                        if (m_fPermErrors)
                        {
                            MessageBox(m_sPermErrorMessage,
                                       CResourceStore.GetString("CEvalAssemWizard:ErrorTitle"),
                                       MB.ICONEXCLAMATION);
                            return -1;                                   

                        }

                    
                        if (Page2.Init(Page1.Filename, Page1.PolicyLevel, m_psGrantedPermissionSet))
                            nPageToGo = 1;
                    }
                    SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)nPageToGo, (IntPtr)(-1));
                    break;
        }
        int nBaseRet = base.WizNext(hwnd);
        if (nBaseRet == 0)
            return nReturnCode;
        else
            return nBaseRet;

    }// WizNext

    protected override int WizFinish()
    {
        // Kill off the threads we have working right now
        m_tPermissionSet.Abort();
        m_tCodegroup.Abort();
        return 0;
    }// WizFinish

    internal void NewEvidenceReceived(Evidence e)
    {
        // Crud.... we need to start over with everything
        m_tPermissionSet.Abort();
        m_tCodegroup.Abort();
        m_psGrantedPermissionSet = null;
        m_cgMatchingCodeGroups = null;
        // Put in the new evidence
        m_ev = e;
        if (m_ev != null)
        {
            // Let these guys start again
            RestartThread(ref m_tPermissionSet, m_tpPermissionSet, new ThreadStart(CreateGrantedPermissionSet));
            RestartThread(ref m_tCodegroup, m_tpCodegroup, new ThreadStart(CreateGrantedCodegroups));
        }
    }// NewEvidenceReceived

    internal void NewObjectiveReceived(bool fGetPermissions)
    {
        if (fGetPermissions)
        {
            m_tpCodegroup = ThreadPriority.Lowest;
            m_tpPermissionSet = ThreadPriority.Normal;
        }
        else
        {
            m_tpPermissionSet = ThreadPriority.Lowest;
            m_tpCodegroup = ThreadPriority.Normal;
        }
        
        Thread tImportant = fGetPermissions?m_tPermissionSet:m_tCodegroup;
        Thread tUnImportant = !fGetPermissions?m_tPermissionSet:m_tCodegroup;

        // Set the thread priorities on these
        SetThreadPriority(tImportant, ThreadPriority.Normal);
        SetThreadPriority(tUnImportant, ThreadPriority.Lowest);
    }// NewObjectiveReceived

    private void RestartThread(ref Thread t, ThreadPriority tp, ThreadStart ts)
    {
        t = new Thread(ts);
        SetThreadPriority(t, tp);
        t.Start();
    }// RestartThread

    private void SetThreadPriority(Thread t, ThreadPriority tp)
    {
        try
        {
            t.Priority = tp;
        }
        // This exception will get thrown if the thread is already dead
        catch(ThreadStateException)
        {}
    }// SetThreadPriority

    internal void RestartEvaluation()
    {
        // Crud.... we need to start over with everything
        m_tPermissionSet.Abort();
        m_tCodegroup.Abort();
        m_psGrantedPermissionSet = null;
        m_cgMatchingCodeGroups = null;
        // Let these guys start again
        RestartThread(ref m_tPermissionSet, m_tpPermissionSet, new ThreadStart(CreateGrantedPermissionSet));
        RestartThread(ref m_tCodegroup, m_tpCodegroup, new ThreadStart(CreateGrantedCodegroups));
    }// RestartEvaluation

    private PolicyLevel GetPolicyLevel(int nPolLevel)
    {
        String sPolLevel = "Enterprise";
        switch(nPolLevel)
        {
            case ENTERPRISE_CODEGROUPS:
                sPolLevel = "Enterprise";
                break;
            case MACHINE_CODEGROUPS:
                sPolLevel = "Machine";
                break;
            case USER_CODEGROUPS:
                sPolLevel = "User";
                break;
        }
    
        return Security.GetPolicyLevelFromLabel(sPolLevel);
    }// GetPolicyLevel

    internal static String GetDisplayString(int nPolicyLevel)
    {
        switch(nPolicyLevel)
        {
            case ENTERPRISE_CODEGROUPS:
                return CResourceStore.GetString("Enterprise Policy");
            case MACHINE_CODEGROUPS:
                return CResourceStore.GetString("Machine Policy");
            case USER_CODEGROUPS:
                return CResourceStore.GetString("User Policy");
            case ALL_CODEGROUPS:
                return CResourceStore.GetString("All Levels");
        }
        return "";
    }// GetDisplayString


    private void CreateGrantedPermissionSet()
    {
        PolicyStatement polstate;
        int nIndex = -1;
        try
        {
            // Figure out the real policy level
            if (Page1.PolicyLevel != ALL_CODEGROUPS)
            {
                PolicyLevel PolLevel = GetPolicyLevel(Page1.PolicyLevel);
                nIndex = Page1.PolicyLevel;
                polstate = PolLevel.Resolve(m_ev);
                m_psGrantedPermissionSet = polstate.PermissionSet;
            }
            else // Ugh... now this is no fun. We need to evalute the security policy ourselves....
                m_psGrantedPermissionSet = Security.CreatePermissionSetFromAllLoadedPolicy(m_ev);

            m_fPermErrors = false;
        }
        catch(PolicyException pe)
        {

            if (pe is IndexPolicyException)
                nIndex = ((IndexPolicyException)pe).Index;

            // Make sure these stay in the same order as the ENTERPRISE_CODEGROUP enum
            String[] sPolLevels = new String[] {
                                    CResourceStore.GetString("Enterprise"),
                                    CResourceStore.GetString("Machine"),
                                    CResourceStore.GetString("User")};

            m_fPermErrors = true;

            m_sPermErrorMessage = String.Format(CResourceStore.GetString("CEvalAssemWizard:ErrorEvaluate"),
                                                sPolLevels[nIndex],
                                                pe.Message);
            m_psGrantedPermissionSet = null;
        }
            
    }// CreateGrantedPermissionSet

    private void CreateGrantedCodegroups()
    {
        CodeGroup[] cgs = new CodeGroup[] {new NotEvalCodegroup(), 
                                           new NotEvalCodegroup(),
                                           new NotEvalCodegroup()};
        int nIndex = -1;
        try
        {
            if (Page1.PolicyLevel != ALL_CODEGROUPS)
            {
                nIndex = Page1.PolicyLevel;
                PolicyLevel pl = GetPolicyLevel(Page1.PolicyLevel);
                cgs[nIndex] = pl.RootCodeGroup.ResolveMatchingCodeGroups(m_ev);
            }
            else
            {
                // We need to run through all the levels

                // The ordering of Enterprise, Machine, and User is very important.
                //
                // If this ordering gets changed, please update the constants located at
                // the top of the file (ENTERPRISE_CODEGROUPS, MACHINE_CODEGROUPS, etc)
                
                String[] sPolLevels = new String[] {"Enterprise", "Machine", "User"};
                for(nIndex = 0; nIndex < sPolLevels.Length; nIndex++)
                {
                    PolicyLevel pl = Security.GetPolicyLevelFromLabel(sPolLevels[nIndex]);
                    cgs[nIndex] = pl.RootCodeGroup.ResolveMatchingCodeGroups(m_ev);           

                    // Now check to see if this codegroup tree has a level final...
                    if (cgs[nIndex] != null)
                    {
                        PolicyStatement ps = cgs[nIndex].Resolve(m_ev);
                        if (ps != null)
                        {
                            if ((ps.Attributes & PolicyStatementAttribute.LevelFinal) == PolicyStatementAttribute.LevelFinal)
                                break;
                        }
                    }
                }
            }
            // All done
            m_cgMatchingCodeGroups = cgs;
            m_fCGErrors = false;
        }
        catch(PolicyException pe)
        {
            String[] sPolLevels = new String[] {
                                    CResourceStore.GetString("Enterprise"),
                                    CResourceStore.GetString("Machine"),
                                    CResourceStore.GetString("User")};

        
            m_fCGErrors = true;
            m_sCGErrorMessage = String.Format(CResourceStore.GetString("CEvalAssemWizard:ErrorEvaluate"),
                                              sPolLevels[nIndex],
                                              pe.Message);
            m_cgMatchingCodeGroups = null;
        }
    }// CreateGrantedCodegroups

}// class CEvalAssemWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cgeneralmachineprops.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.ComponentModel;
using System.Globalization;

internal class CGeneralMachineProps : CPropPage
{
    // Controls on the page
    PictureBox  m_imgLine;
    Label m_lblMyComputer;
    RadioButton m_radConcurrent;
    RadioButton m_radNormal;
    Label m_lblGarbageCollector;
    Label m_lblGarbageCollectorHelp;
    Label m_lblSecurityHelp;
    CheckBox m_chkUseSecurity;
    PictureBox m_pbComputer;

    internal CGeneralMachineProps()
    {
        m_sTitle=CResourceStore.GetString("CGeneralMachineProps:PageTitle"); 
    }// CGeneralMachineProps

    
    internal override int InsertPropSheetPageControls()
    {
        m_imgLine = new PictureBox();
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CGeneralMachineProps));
        this.m_pbComputer = new System.Windows.Forms.PictureBox();
        this.m_lblMyComputer = new System.Windows.Forms.Label();
        this.m_radConcurrent = new System.Windows.Forms.RadioButton();
        this.m_radNormal = new System.Windows.Forms.RadioButton();
        this.m_lblGarbageCollector = new System.Windows.Forms.Label();
        this.m_lblGarbageCollectorHelp = new System.Windows.Forms.Label();
        this.m_lblSecurityHelp = new System.Windows.Forms.Label();
        this.m_chkUseSecurity = new System.Windows.Forms.CheckBox();
        this.m_pbComputer.Location = ((System.Drawing.Point)(resources.GetObject("m_pbComputer.Location")));
        this.m_pbComputer.Size = ((System.Drawing.Size)(resources.GetObject("m_pbComputer.Size")));
        this.m_pbComputer.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;
        this.m_pbComputer.TabIndex = ((int)(resources.GetObject("m_pbComputer.TabIndex")));
        this.m_pbComputer.TabStop = false;
        m_pbComputer.Name = "ComputerPicture";
        this.m_lblMyComputer.Location = ((System.Drawing.Point)(resources.GetObject("m_lblMyComputer.Location")));
        this.m_lblMyComputer.Size = ((System.Drawing.Size)(resources.GetObject("m_lblMyComputer.Size")));
        this.m_lblMyComputer.TabIndex = ((int)(resources.GetObject("m_lblMyComputer.TabIndex")));
        this.m_lblMyComputer.Text = resources.GetString("m_lblMyComputer.Text");
        m_lblMyComputer.Name = "MyComputer";
        this.m_radConcurrent.Location = ((System.Drawing.Point)(resources.GetObject("m_radConcurrent.Location")));
        this.m_radConcurrent.Size = ((System.Drawing.Size)(resources.GetObject("m_radConcurrent.Size")));
        this.m_radConcurrent.TabIndex = ((int)(resources.GetObject("m_radConcurrent.TabIndex")));
        this.m_radConcurrent.Text = resources.GetString("m_radConcurrent.Text");
        m_radConcurrent.Name = "Concurrent";
        this.m_radNormal.Location = ((System.Drawing.Point)(resources.GetObject("m_radNormal.Location")));
        this.m_radNormal.Size = ((System.Drawing.Size)(resources.GetObject("m_radNormal.Size")));
        this.m_radNormal.TabIndex = ((int)(resources.GetObject("m_radNormal.TabIndex")));
        this.m_radNormal.Text = resources.GetString("m_radNormal.Text");
        m_radNormal.Name = "Normal";
        this.m_lblGarbageCollector.Location = ((System.Drawing.Point)(resources.GetObject("m_lblGarbageCollector.Location")));
        this.m_lblGarbageCollector.Size = ((System.Drawing.Size)(resources.GetObject("m_lblGarbageCollector.Size")));
        this.m_lblGarbageCollector.TabIndex = ((int)(resources.GetObject("m_lblGarbageCollector.TabIndex")));
        this.m_lblGarbageCollector.Text = resources.GetString("m_lblGarbageCollector.Text");
        m_lblGarbageCollector.Name = "GCLabel";
        this.m_lblGarbageCollectorHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblGarbageCollectorHelp.Location")));
        this.m_lblGarbageCollectorHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblGarbageCollectorHelp.Size")));
        this.m_lblGarbageCollectorHelp.TabIndex = ((int)(resources.GetObject("m_lblGarbageCollectorHelp.TabIndex")));
        this.m_lblGarbageCollectorHelp.Text = resources.GetString("m_lblGarbageCollectorHelp.Text");
        m_lblGarbageCollectorHelp.Name = "GCHelp";

        this.m_lblSecurityHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblSecurityHelp.Location")));
        this.m_lblSecurityHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblSecurityHelp.Size")));
        this.m_lblSecurityHelp.TabIndex = ((int)(resources.GetObject("m_lblSecurityHelp.TabIndex")));
        this.m_lblSecurityHelp.Text = resources.GetString("m_lblSecurityHelp.Text");
        m_lblSecurityHelp.Name = "SecurityHelp";
        this.m_lblSecurityHelp.Visible = false;

        this.m_chkUseSecurity.Location = ((System.Drawing.Point)(resources.GetObject("m_chkUseSecurity.Location")));
        this.m_chkUseSecurity.Size = ((System.Drawing.Size)(resources.GetObject("m_chkUseSecurity.Size")));
        this.m_chkUseSecurity.TabIndex = ((int)(resources.GetObject("m_chkUseSecurity.TabIndex")));
        this.m_chkUseSecurity.Text = resources.GetString("m_chkUseSecurity.Text");
        m_chkUseSecurity.Name = "UseSecurity";
        this.m_chkUseSecurity.Visible = false;

        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_pbComputer,
                        this.m_radNormal,
                        this.m_radConcurrent,
                        this.m_chkUseSecurity,
                        this.m_lblGarbageCollector,
                        m_lblGarbageCollectorHelp,
                        m_lblSecurityHelp,
                        this.m_lblMyComputer});
        this.m_pbComputer.Image = Bitmap.FromHicon(CResourceStore.GetHIcon("mycomputer_ico"));

        // Draw a line seperating that stuff
        Bitmap bp = new Bitmap(370, 2);
        Graphics g = Graphics.FromImage(bp);
        g.DrawLine(Pens.Black, new Point(0, 0), new Point(370, 0));
        g.DrawLine(Pens.White, new Point(0, 1), new Point(370, 1));
        m_imgLine.Location = new Point(5, 60);
        m_imgLine.Size = new Size(370, 2);
        m_imgLine.TabIndex = 0;
        m_imgLine.TabStop = false;
        m_imgLine.Image = bp;
        PageControls.Add(m_imgLine);

        // Some more tweaking....
        m_radNormal.CheckedChanged +=new EventHandler(onChange);
        m_radConcurrent.CheckedChanged +=new EventHandler(onChange);
        this.m_chkUseSecurity.CheckedChanged += new System.EventHandler(onChange);

      
        // Fill in the data
        PutValuesinPage();

        return 1;
    }// InsertPropSheetPageControls

    private void PutValuesinPage()
    {
        m_chkUseSecurity.Checked = (bool)CConfigStore.GetSetting("SecurityEnabled");

        String setting = (String)CConfigStore.GetSetting("GarbageCollector");

        if (setting != null && setting.ToLower(CultureInfo.InvariantCulture).Equals("true"))
            m_radConcurrent.Checked=true;
        else
            m_radNormal.Checked=true;
    }// PutValuesinPage

    internal override bool ApplyData()
    {
        if (!CConfigStore.SetSetting("SecurityEnabled", m_chkUseSecurity.Checked))
            return false;

        if (!CConfigStore.SetSetting("GarbageCollector",m_radConcurrent.Checked?"true":"false"))
            return false;

        PutValuesinPage();

        return true;
    }// ApplyData

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onChange
}// class CGeneralMachineProps

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cgenapplications.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CGenApplications.cs
//
// This class represents the general applications node 
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Collections;
using System.Collections.Specialized;
using System.IO;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Globalization;


class CGenApplications : CNode
{
    internal CGenApplications()
    {
        m_sGuid = "5CE2BA30-BCFC-4876-AE9F-31255557BE28";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("applications_ico");  
        DisplayName = CResourceStore.GetString("CGenApplications:DisplayName");
        Name="Applications";
        m_aPropSheetPage = null;
        m_oResults = new CGenAppTaskPad(this);

    }// CGenApplications

         
     internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
     {  
         // See if we're allowed to insert an item in the "view" section
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
         {
            // Stuff common to the top menu
            CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            newitem.strName = CResourceStore.GetString("CGenApplications:AddApplicationOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenApplications:AddApplicationOptionDes");
            newitem.lCommandID = COMMANDS.ADD_APPLICATION;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            
            newitem.strName = CResourceStore.GetString("CGenApplications:FixApplicationOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenApplications:FixApplicationOptionDes");
            newitem.lCommandID = COMMANDS.FIX_APPLICATION;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

         }
      }// AddMenuItems


     internal override void MenuCommand(int iCommandID)
     {
        if (iCommandID == COMMANDS.ADD_APPLICATION)
        {
            // Pop up a dialog so the user can find an assembly
            CChooseAppDialog cad = new CChooseAppDialog();

            System.Windows.Forms.DialogResult dr = cad.ShowDialog();
            if (dr == System.Windows.Forms.DialogResult.OK)
            {
                String sConfigFile=cad.Filename; 
                String sAppFilename="";

                // If this is an executable or Dll, or if it is managed
                int iLen = sConfigFile.Length;
                if (iLen > 3)
                {
                    String sExtension = sConfigFile.Substring(sConfigFile.Length-3).ToUpper(CultureInfo.InvariantCulture);
                    if (sExtension.ToUpper(CultureInfo.InvariantCulture).Equals("EXE") || sExtension.ToUpper(CultureInfo.InvariantCulture).Equals("DLL") || Fusion.isManaged(sConfigFile))
                    {
                       sAppFilename = sConfigFile;
                       // Let's add a config extension
                       sConfigFile = sConfigFile + ".config";
                    }
                    else if (iLen > 6) 
                    {
                        // Check to see if they selected a config file
                        sExtension = sConfigFile.Substring(sConfigFile.Length-6).ToUpper(CultureInfo.InvariantCulture);

                        if (sExtension.ToUpper(CultureInfo.InvariantCulture).Equals("CONFIG"))
                        {
                            // They've selected a config file. Let's see if there is an assembly around there as well.
                            String sAssemName = sConfigFile.Substring(0, sConfigFile.Length-7);
                            if (File.Exists(sAssemName))
                                sAppFilename = sAssemName;
                        }
                    }                          
                }
                AppFiles appFile = new AppFiles();
                appFile.sAppFile = sAppFilename;
                appFile.sAppConfigFile = sConfigFile;

                // Check to see if we already have this app file shown
                CNode node = CheckForDuplicateApp(appFile);
                if (node == null)
                {
                    CConfigStore.SetSetting("AppConfigFiles",appFile);
                    node = new CApplication(appFile);
                    int iCookie = CNodeManager.AddNode(ref node);
                    AddChild(iCookie);
                    InsertSpecificChild(iCookie);
                }
                CNodeManager.Console.SelectScopeItem(node.HScopeItem);
            }
        }
        else if (iCommandID == COMMANDS.FIX_APPLICATION)
        {
            
            PolicyManager(CNodeManager.MMChWnd, null, null, null);  
        }
            
     }// MenuCommand

    private CNode CheckForDuplicateApp(AppFiles af)
    {
        // Run through this node's children to see if a node with this app file exists
        int iNumChildren = NumChildren;
        for(int i=0; i<iNumChildren; i++)
        {
            CNode node = CNodeManager.GetNode(Child[i]);
            if (node is CApplication)
            {
                AppFiles afNode = ((CApplication)node).MyAppInfo;
                // Check the App file's name
                if ((af.sAppFile == null && afNode.sAppFile == null) ||
                    af.sAppFile.Equals(afNode.sAppFile))
                // Check the App File's config file
                    if ((af.sAppConfigFile == null && afNode.sAppConfigFile == null) ||
                        af.sAppConfigFile.Equals(afNode.sAppConfigFile))
                        return node;
            }
        }
        // We couldn't find a node with that app info
        return null;
    }// CheckForDuplicateApp

    //-------------------------------------------------
    // CreateChildren
    //
    // This function creates the node's children, registers
    // the nodes with the node manager, and places the node's
    // cookies in it's child array
    //-------------------------------------------------
    internal override void CreateChildren()
    {
        // Don't bother doing any of this if we're not using MMC
        if (!(CNodeManager.Console is INonMMCHost))
        {
            // Grab all the applications we know about and display the names to the
            // user
            ArrayList alApps = (ArrayList)CConfigStore.GetSetting("AppConfigFiles");

            int iLen = alApps.Count;
            for(int i=0; i<iLen; i++)
            {
                // Check to see if this App still exists
                AppFiles af = (AppFiles)alApps[i];

                // We need either an exe or a config file to do this
                bool fHaveSomething = false;

                // Verify the exe still exists....
                if (af.sAppFile != null && af.sAppFile.Length > 0)
                {
                    if (File.Exists(af.sAppFile))
                        fHaveSomething = true;
                    else
                    {
                        // The exe doesn't exist anymore. Let's update the record
                        CConfigStore.SetSetting("RemoveAppConfigFile", af);
                        af.sAppFile = "";
                        CConfigStore.SetSetting("AppConfigFiles",af);
                    }
                }

                // Verify the config file exists
                if (af.sAppConfigFile != null && af.sAppConfigFile.Length > 0)
                {
                    // If we don't have an exe, let's see if we can find it
                    if ((af.sAppFile == null || af.sAppFile.Length == 0) && af.sAppConfigFile.Length > 6)
                    {
                        String sExtension = af.sAppConfigFile.Substring(af.sAppConfigFile.Length-6).ToUpper(CultureInfo.InvariantCulture);

                        if (sExtension.ToUpper(CultureInfo.InvariantCulture).Equals("CONFIG"))
                        {
                            // This is an appropriately named config file. Let's see if there is an assembly around there as well.
                            String sAssemName = af.sAppConfigFile.Substring(0, af.sAppConfigFile.Length-7);
                            if (File.Exists(sAssemName))
                            {
                                // Cool. When the user first added the application, they only had a config
                                // file. Now they have an exe too. We'll take note of that
                                CConfigStore.SetSetting("RemoveAppConfigFile", af);
                                af.sAppFile = sAssemName;
                                CConfigStore.SetSetting("AppConfigFiles",af);
                                fHaveSomething = true;
                            }
                        }                          
                    }
                    // Check to see if the config file is still valid
                    if (File.Exists(af.sAppConfigFile))
                        fHaveSomething = true;
                    // If it doesn't exist... not a big deal. Config files could get
                    // deleted. No worries.
                }

                // See if we snagged something to go off of
                if (fHaveSomething)
                {
                    CNode node = new CApplication(af);
                    int iCookie = CNodeManager.AddNode(ref node);
                    AddChild(iCookie);
                }
                // This entry is now bogus. Get rid of it
                else
                    CConfigStore.SetSetting("RemoveAppConfigFile", af);
            }
        }            
    }// CreateChildren

    private void MergeFusionAndMyApps(ArrayList alApps, StringCollection sc)
    {
        int nLen = sc.Count;
        for(int i=0; i<nLen; i++)
            if (!SearchForAppName(alApps, sc[i]))
            {
                AppFiles af = new AppFiles();
                af.sAppFile = sc[i];
                af.sAppConfigFile = sc[i] + ".config";
                alApps.Add(af);
            }
      
    }// MergeFusionAndMyApps

    private bool SearchForAppName(ArrayList al, String s)
    {
        int nLen = al.Count;
        for(int i=0; i<nLen; i++)
            if (((AppFiles)al[i]).sAppFile.ToLower(CultureInfo.InvariantCulture).Equals(s.ToLower(CultureInfo.InvariantCulture)))
                return true;
        return false;

    }// SearchForAppName

    [DllImport("shfusion.dll", CharSet=CharSet.Unicode)]
    internal static extern int PolicyManager(IntPtr hWndParent, String pwzFullyQualifiedAppPath, String pwzAppName, String dwFlags);

}// class CGenApplications
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cgenerictaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;

class CGenericTaskPad : CTaskPad
{
    String m_sHTMLName;

    internal CGenericTaskPad(CNode node, String sHTMLName):base(node)
    {
        m_sHTMLName = sHTMLName;
    }// CGenericTaskPad

    protected override String GetHTMLFilename()
    {
        return m_sHTMLName;
    }// GetHTMLFilename



}// class CGenAppTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cfulltrustwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security;
using System.Security.Policy;
using System.Reflection;
using System.Security.Permissions;
using System.Security.Cryptography.X509Certificates;
using System.Security.Cryptography;
using System.Collections;
using System.Net;
using System.Text.RegularExpressions;
using System.IO;
using System.Threading;

internal class TrustBy
{
    
    internal const int    PUBCERT      = 1;
    internal const int    HASH         = 2;
    internal const int    SNAME        = 4;
    internal const int    SNAMEVER     = 8;
    internal const int    SNAMENAME    = 16;
}// TrustBy

internal class CFullTrustWizard: CWizard
{
    bool                m_fHasCertOrSName;
    int                 m_nPageToGetPermissionLevel;

    Thread              m_tAssemblyLoader;
    AssemblyLoader      m_al;
    Evidence            m_ev;
    bool                m_fChangesMade;
   
    internal CFullTrustWizard(bool fMachineReadOnly, bool fUserReadOnly)
    {
        m_aPropSheetPage = new CPropPage[] {new CTrustAppWiz1(fMachineReadOnly, fUserReadOnly), 
                                            new CTrustAppWiz2(), 
                                            new CTrustAppWiz3(), 
                                            new CTrustAppWiz4(), 
                                            new CTrustAppWiz5(),
                                            new CTrustAppWiz7(),
                                            new CTrustAppWiz8()};

        m_fHasCertOrSName = false;   
        m_fChangesMade = false;
        m_al = new AssemblyLoader();
    }// CFullTrustWizard

    // Keep these constants in line with the ordering of the property pages
    private const int Page1Index = 0;
    private const int Page2Index = 1;
    private const int Page3Index = 2;
    private const int Page4Index = 3;
    private const int Page5Index = 4;
    private const int Page6Index = 5;
    private const int Page7Index = 6;
    
    private CTrustAppWiz1 Page1
    {   get{return (CTrustAppWiz1)m_aPropSheetPage[Page1Index];}}
    private CTrustAppWiz2 Page2
    {   get{return (CTrustAppWiz2)m_aPropSheetPage[Page2Index];}}
    private CTrustAppWiz3 Page3
    {   get{return (CTrustAppWiz3)m_aPropSheetPage[Page3Index];}}
    private CTrustAppWiz4 Page4
    {   get{return (CTrustAppWiz4)m_aPropSheetPage[Page4Index];}}
    private CTrustAppWiz5 Page5
    {   get{return (CTrustAppWiz5)m_aPropSheetPage[Page5Index];}}
    private CTrustAppWiz7 Page6
    {   get{return (CTrustAppWiz7)m_aPropSheetPage[Page6Index];}}
    private CTrustAppWiz8 Page7
    {   get{return (CTrustAppWiz8)m_aPropSheetPage[Page7Index];}}
    
    protected override int WizSetActive(IntPtr hwnd)
    {
        // Find out which property page this is....

        switch(GetPropPage(hwnd))
        {
            // This page corresponds to the "Do you want to make changes to the machine
            // or the user policy" page
            case Page1Index:
                TurnOnNext(true);
                break;
            // This page corresponds to the "Choose an assembly to trust" page                
            case Page2Index:
                if (Page2.Filename != null && Page2.Filename.Length > 0)
                    TurnOnNext(true);
                else
                    TurnOnNext(false);
                break;
            // This page corresponds to the 'how do you want to trust this assembly' when
            // the assembly has a publisher certificate
            case Page3Index:
                Page3.Filename = Page2.Filename;
                Page3.PutValuesInPage();
                TurnOnNext(true);
                break;
            // This page is for the "You can only give this assembly full trust" page
            case Page4Index:
                TurnOnNext(Page4.GiveFullTrust);
                break;
            // This page gives the slider and allows the user to choose the permission level
            // they want
            case Page5Index:
                TurnOnNext(true);
                break;
            // This page says "Sorry, policy is too complicated.... we can't make any changes"  
            case Page6Index:
                TurnOnFinish(true);
                break;
            // This page shows the summary of what we're doing
            case Page7Index:
                // We should send some info to the table to display...
                String[] sInfo = {CResourceStore.GetString("Assembly"),
                                  Page2.Filename,
                                  CResourceStore.GetString("User Type"),
                                  Page1.isForHomeUser?CResourceStore.GetString("Home User"):CResourceStore.GetString("Corporate User"),
                                  CResourceStore.GetString("New Permission Level"),
                                  GetNameOfNewPermissionLevel()};
                Page7.TableInfo = sInfo;                                  
                TurnOnFinish(true);
                break;
        }
        return base.WizSetActive(hwnd);

                    
    }// WizSetActive

    protected override int WizBack(IntPtr hwnd)
    {
        int nIndex = GetPropPage(hwnd);
        int nPageToGoTo = -1;
        switch(nIndex)
        {
            // This page is for the "You can only give this assembly full trust" page
            case Page4Index:
            // This page gives the slider and allows the user to choose the permission level
            // they want
            case Page5Index:
            // This page says "Sorry, policy is too complicated.... we can't make any changes"  
            case Page6Index:
                // We're going to take them back to the page that will give the user the option
                // to choose how they want to trust the app
                if (!m_fHasCertOrSName)
                    nPageToGoTo = Page2Index;
                else
                    nPageToGoTo = Page3Index;
                break;

            // This page shows the summary of what we're doing
            case Page7Index:
                nPageToGoTo = m_nPageToGetPermissionLevel;
                break;
        }
        if (nPageToGoTo != -1)
        {
            SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)nPageToGoTo, (IntPtr)(-1));
            return -1;
        }
        return base.WizBack(hwnd);

    }// WizBack

    protected override int WizNext(IntPtr hwnd)
    {
        int nIndex = GetPropPage(hwnd);
        int nReturnCode = 0;

        switch(nIndex)
        {
            // This page corresponds to the "Choose an assembly to trust" page                
            case Page2Index:
                    // Get our assembly to finish loading
                    if (m_tAssemblyLoader != null)
                        m_tAssemblyLoader.Join();
                                        
                    if (m_ev == null)
                    {
                        // We don't have evidence yet. Let's try and get it
                        LoadAssembly();
                        // We had a problem with the load
                        if (m_ev == null)
                        {
                            // Let's see if can can figure out what failed...
                            if (File.Exists(Page2.Filename) && !Fusion.isManaged(Page2.Filename))
                                MessageBox(CResourceStore.GetString("isNotManagedCode"),
                                           CResourceStore.GetString("isNotManagedCodeTitle"),
                                           MB.ICONEXCLAMATION);

                            else
                                MessageBox(String.Format(CResourceStore.GetString("CantLoadAssembly"), Page2.Filename),
                                           CResourceStore.GetString("CantLoadAssemblyTitle"),
                                           MB.ICONEXCLAMATION);
                            nReturnCode = -1;
                            break;
                        }
                    }

                    X509Certificate x509 = GetCertificate();
                    StrongName sn = GetStrongName();
                    Hash hash = GetHash();
                    
                    // Check to see if the assembly they've selected has a certificate
                    if (x509 != null || sn != null)
                    {
                        Page3.x509 = x509;
                        Page3.sn = sn;
                        m_fHasCertOrSName = true;
                        break;
                    }
                    else
                    {
                        // The assembly doesn't have a certificate or a strong name. We'll go to the
                        // page that let's them choose the permission set they want to assign
                        m_fHasCertOrSName = false;

                        // I'd like to just fall through to the next case statement, but that
                        // isn't allowed in C#. We'll need to use a goto instead
                        goto case Page3Index;
                    }
            // This page corresponds to the 'how do you want to trust this assembly' when
            // the assembly has a publisher certificate
            case Page3Index:
                    // Let's figure out how we can change the policy.

                    // First, let's see what happens if we give this app full trust.
                    
                    // If we can't get any permissions, then this severely hampers what
                    // the wizard can do. This might occur if the level of trust we can grant is
                    // limited by an upper policy level. If this is the case, then we need
                    // to bail
                    int nLevelFromFullTrust = TryToCreateFullTrust();
                    if (nLevelFromFullTrust != PermissionSetType.UNKNOWN && nLevelFromFullTrust != PermissionSetType.NONE) 
                    {
                        // Now, lets see if we can identify the permission set that it currently gets
                        int nCurPerm = FindCurrentPermissionSet(); 
                        if (nCurPerm != PermissionSetType.UNKNOWN)
                        {    
                            // Go to the Slider bar page
                            Page5.MyTrustLevel = nCurPerm;
                            Page5.MaxTrustLevel = nLevelFromFullTrust;
                            Page5.PutValuesInPage();
                            m_nPageToGetPermissionLevel=Page5Index;
                        }
                        else
                            // Go to the 'You can only assign full trust' page
                            m_nPageToGetPermissionLevel=Page4Index;
                            
                    }
                    else
                    {
                        // Else, we can't do anything. The app's permission level is limited by 
                        // an upper policy level. Puke out now.
                        m_nPageToGetPermissionLevel=Page6Index;
                    }
                    // Head off to the page that will let us get a permission set to assign
                    SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)m_nPageToGetPermissionLevel, (IntPtr)(-1));
                    nReturnCode = -1;
                    break;
            // This page is for the "You can only give this assembly full trust" page
            case Page4Index:
            // This page gives the slider and allows the user to choose the permission level
            // they want
            case Page5Index:
                    // Head off to the summary page
                    SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)Page7Index, (IntPtr)(-1));
                    nReturnCode = -1;
                    break;

        }
        int nBaseRet = base.WizNext(hwnd);
        if (nBaseRet == 0)
            return nReturnCode;
        else
            return nBaseRet;

    }// WizNext

    protected override int WizFinish()
    {
        // See if we're on the bail-out page...
        if (m_nPageToGetPermissionLevel == Page6Index)
            return 0;
    
        // Choose the permission set we want to use....
        PermissionSet permSet = null;
        String sPolicyLevel = Page1.isForHomeUser?"Machine":"User";
        PolicyLevel pl = Security.GetPolicyLevelFromLabel(sPolicyLevel);

        if (m_nPageToGetPermissionLevel == Page4Index)
        {
            // If the user decided to not give full trust, end the wizard without doing anything
            if (!Page4.GiveFullTrust)
                    return 0;
            else
                // Else, go ahead and give the FullTrust permission set       
                permSet = pl.GetNamedPermissionSet("FullTrust");
        }
        else
        {
            if (Page5.MyTrustLevel == PermissionSetType.FULLTRUST)
                permSet = pl.GetNamedPermissionSet("FullTrust");          
            else if (Page5.MyTrustLevel == PermissionSetType.INTERNET)
                permSet = pl.GetNamedPermissionSet("Internet");          
            else if (Page5.MyTrustLevel == PermissionSetType.INTRANET)
                permSet = pl.GetNamedPermissionSet("LocalIntranet");          
            else if (Page5.MyTrustLevel == PermissionSetType.NONE)
                permSet = pl.GetNamedPermissionSet("Nothing"); 
            else
                permSet = null;
        }

        m_fChangesMade = (CreateCodegroup(permSet, true) != null);
        return 0;
    }// WizFinish

    internal void NewAssembly()
    {
        if (m_tAssemblyLoader != null)
            m_tAssemblyLoader.Abort();
        m_tAssemblyLoader = new Thread(new ThreadStart(LoadAssembly));
        m_tAssemblyLoader.Start();
    }// NewAssembly

    internal void WipeEvidence()
    {
        if (m_tAssemblyLoader != null)
        {
            m_tAssemblyLoader.Abort();
            m_tAssemblyLoader= null;
        }
        m_ev = null;
    }// NewAssembly

    void LoadAssembly()
    {
        try
        {
            AssemblyRef ar = m_al.LoadAssemblyInOtherAppDomainFrom(Page2.Filename);
            m_ev = ar.GetEvidence();
            m_al.Finished();
        }
        catch(Exception)
        {   
            m_ev = null;
            m_al.Finished();
        }
    }// LoadAssembly

    // This function is used to create the strings to put in the summary table
    private String GetNameOfNewPermissionLevel()
    {
        if (m_nPageToGetPermissionLevel == 3)
            return CResourceStore.GetString("CSecurityAdjustmentWiz3:FullTrustName");
        else
        {
            if (Page5.MyTrustLevel == PermissionSetType.FULLTRUST)
                return CResourceStore.GetString("CSecurityAdjustmentWiz3:FullTrustName");
            else if (Page5.MyTrustLevel == PermissionSetType.INTERNET)
                return CResourceStore.GetString("CSecurityAdjustmentWiz3:InternetName");
            else if (Page5.MyTrustLevel == PermissionSetType.INTRANET)
                return CResourceStore.GetString("CSecurityAdjustmentWiz3:LocalIntranetName");
            else if (Page5.MyTrustLevel == PermissionSetType.NONE)
                return CResourceStore.GetString("CSecurityAdjustmentWiz3:NoTrustName");
        }
        return CResourceStore.GetString("<unknown>");
    }// GetNameOfNewPermissionLevel

    internal bool MadeChanges
    {
        get{return m_fChangesMade;}
    }// NewCodeGroup

    internal PolicyLevel PolLevel
    {
        get
        {
            String sPolicyLevel = Page1.isForHomeUser?"Machine":"User";
            return Security.GetPolicyLevelFromLabel(sPolicyLevel);
        }    
    }// PolLevel
  
    private int TryToCreateFullTrust()
    {
        CodeGroup cg = CreateCodegroup(new PermissionSet(PermissionState.Unrestricted), false);
        if (cg == null)
            return PermissionSetType.NONE;
        // See if we can get full trust....
        int nType = FindCurrentPermissionSet();
        // Now remove the codegroup we just created....
        String sPolicyLevel = Page1.isForHomeUser?"Machine":"User";
        PolicyLevel pl = Security.GetPolicyLevelFromLabel(sPolicyLevel);
        // Ok to use CodeGroup.RemoveChild here because we're guaranteed that
        // the codegroup (cg) that we created has a name and a description
        pl.RootCodeGroup.RemoveChild(cg);
        return nType;
    }// TryToCreateFullTrust
    
    private CodeGroup CreateCodegroup(PermissionSet pSet, bool fHighjackExisting)
    {
        // Now create our codegroup
        // Figure out what membership condition to use
        IMembershipCondition mc=null;
        // If the assembly didn't have a publisher certificate or a strong name,
        // then we must trust it by hash
        int nTrustBy = m_fHasCertOrSName?Page3.HowToTrust:TrustBy.HASH;
       
        if ((nTrustBy & TrustBy.SNAME) > 0)
        {
            // Let's get the strong name stuff together
            StrongName sn = GetStrongName();
            StrongNamePublicKeyBlob snpkb = sn.PublicKey;
            Version v=null;
            String sName = null;
            if ((nTrustBy & TrustBy.SNAMEVER) > 0)
                v = sn.Version;

            if ((nTrustBy & TrustBy.SNAMENAME) > 0)
                sName = sn.Name;
                
            mc = new StrongNameMembershipCondition(snpkb, sName, v);            
        }
        else if ((nTrustBy & TrustBy.PUBCERT) > 0)
        {
            // We're using the publisher certificate stuff
            mc = new PublisherMembershipCondition(GetCertificate());    
        }
        else // We'll trust by hash
        {
            Hash h = GetHash();
            mc = new HashMembershipCondition(SHA1.Create(), h.SHA1); 
        }
        
        // Figure out the policy level that we should put this in....
        String sPolicyLevel = Page1.isForHomeUser?"Machine":"User";
        PolicyLevel pl = Security.GetPolicyLevelFromLabel(sPolicyLevel);

        // See if a codegroup for this already exists... and if it does, we'll just
        // modify that.
        CSingleCodeGroup scg = null;
        CodeGroup cg = null;

        if (fHighjackExisting)
        {
            scg = FindExistingCodegroup(pl, mc);

            if (scg != null)
            {
                cg = scg.MyCodeGroup;
                
                // Cool. We were able to find a codegroup to use. We'll
                // need to strip off all the File and Net child codegroups
                IEnumerator enumChildCodeGroups = cg.Children.GetEnumerator();
                while (enumChildCodeGroups.MoveNext())
                {
                    CodeGroup cgChild = (CodeGroup)enumChildCodeGroups.Current;
                    if (cgChild is NetCodeGroup || cgChild is FileCodeGroup)
                    // Ok to use CodeGroup.RemoveChild here we want to toast all
                    // File and Net codegroups... we don't care if the security system
                    // gets confused about which are which (if they don't have names)
                        cg.RemoveChild(cgChild);
                }
            }


        }
        
        // Create the codegroup... we're going to make this a level final
        // codegroup, so if policy gets changes such that a lower-level policy
        // level tries to deny permissions to this codegroup it will be unsuccessful.
        PolicyStatement policystatement = new PolicyStatement(pSet, PolicyStatementAttribute.LevelFinal);
        
        if (cg == null)
        {
            cg = new UnionCodeGroup(mc, policystatement);
            String sCGName = Security.FindAGoodCodeGroupName(pl, "Wizard_");
            cg.Name = sCGName;
            cg.Description = CResourceStore.GetString("GeneratedCodegroup");
        }
        else
            cg.PolicyStatement = policystatement;
            
            
        // If this is a internet or intranet permission set, we also need to add some codegroups
        if (pSet is NamedPermissionSet)
        {
            NamedPermissionSet nps = (NamedPermissionSet)pSet;
            
            if (nps.Name.Equals("LocalIntranet"))
            {
                CodeGroup cgChild = new NetCodeGroup(new AllMembershipCondition());
                cgChild.Name = Security.FindAGoodCodeGroupName(pl, "NetCodeGroup_");
                cgChild.Description = CResourceStore.GetString("GeneratedCodegroup");

                cg.AddChild(cgChild);
                cgChild = new FileCodeGroup(new AllMembershipCondition(), FileIOPermissionAccess.Read|FileIOPermissionAccess.PathDiscovery);
                cgChild.Name = Security.FindAGoodCodeGroupName(pl, "FileCodeGroup_");
                cgChild.Description = CResourceStore.GetString("GeneratedCodegroup");

                cg.AddChild(cgChild);
            }
            else if (nps.Name.Equals("Internet"))
            {
                CodeGroup cgChild = new NetCodeGroup(new AllMembershipCondition());
                cgChild.Name = Security.FindAGoodCodeGroupName(pl, "NetCodeGroup_");
                cgChild.Description = CResourceStore.GetString("GeneratedCodegroup");

                cg.AddChild(cgChild);
            }
        }


        // Add this codegroup to the root codegroup of the policy
        // If there was already an existing one, just replace that...
        if (scg != null)
            Security.UpdateCodegroup(pl, scg);
        else
            pl.RootCodeGroup.AddChild(cg);

        return cg;
    }// CreateCodegroup

    private CSingleCodeGroup FindExistingCodegroup(PolicyLevel pl, IMembershipCondition mc)
    {
        // If we have an existing one, it should be right under the root node
        CSingleCodeGroup scgParent = Security.GetRootCodeGroupNode(pl);
        
        for(int i=0; i<scgParent.NumChildren; i++)
        {
            CSingleCodeGroup scg = (CSingleCodeGroup)CNodeManager.GetNode(scgParent.Child[i]);

            // See if we have a matching membership condition and the description
            // says it's one the wizard created
            if (scg.MyCodeGroup.MembershipCondition.ToString().Equals(mc.ToString()) && scg.MyCodeGroup.Description.Equals(CResourceStore.GetString("GeneratedCodegroup")))
                return scg;
        }

        // We weren't able to find one
        return null;
    }// FindExistingCodegroup

    private int FindCurrentPermissionSet()
    {
        // We're only going to give the security manager evidence pertaining to 
        // how we want to trust the app. If the user wants to trust it by publisher,
        // we'll only give it the publisher evidence, and so on.
        Evidence e = new Evidence();
        int nTrustBy = m_fHasCertOrSName?Page3.HowToTrust:TrustBy.HASH;
       
        if ((nTrustBy & TrustBy.SNAME) > 0)
        {
            // Let's get the strong name stuff together
            StrongName sn = GetStrongName();

            if ((nTrustBy & TrustBy.SNAMEVER) > 0)
            {
                e.AddHost(new StrongName(sn.PublicKey, sn.Name, sn.Version)); 
                return Security.FindCurrentPermissionSet(e);
            }
            // We need to obtain a permission set that isn't based on version.
            // We can't create a piece of strong name evidence without a version,
            // so instead we'll take a guess... we'll pick 3 unlike versions, and let
            // the majority rule.
            int[] nSets = new int[3];
            e.AddHost(new StrongName(sn.PublicKey, sn.Name, new Version("9999.0.0.9999")));
            nSets[0] = Security.FindCurrentPermissionSet(e);
            e = new Evidence();
            e.AddHost(new StrongName(sn.PublicKey, sn.Name, new Version("1111.1111.111.1111")));
            nSets[1] = Security.FindCurrentPermissionSet(e);
            e = new Evidence();
            e.AddHost(new StrongName(sn.PublicKey, sn.Name, new Version("1234.0.5678.0")));
            nSets[2] = Security.FindCurrentPermissionSet(e);

            // Ok, now we'll implement the complicated but important "majority rules" algorithm
            if (nSets[0] == nSets[1] || nSets[0] == nSets[2])
                return nSets[0];
            if (nSets[1] == nSets[2])
                return nSets[1];
            // Ok, not a single one was in the majority. This is just too messed up. Since this
            // is my first Microsoft product, we'll return #1
            return nSets[1];
        }
        else if ((nTrustBy & TrustBy.PUBCERT) > 0)
        {
            // Feed it the Publisher Certificate evidence
            e.AddHost(new Publisher(GetCertificate()));    
        }
        else // We'll trust by hash
        {
            // Feed it the hash evidence 
            e.AddHost(GetHash());
        }

        // Try and find some good url evidence (a url that doesn't trigger any codegroups
        // with url membership conditions).
        // We need the url evidence in order to trigger the File and Net Custom codegroups
        // that typically reside off of the Internet and LocalIntranet codegroups
        Url localUrlEvidence = null;
        int nCount=0;
        Evidence eTmp;
        // Note, it doesn't matter if c: actually exists or if it is on the local machine or not.
        // We just need the piece of evidence.... If c: is actually a mapped drive, there is no
        // harm because we control the evidence that tells the security manager where the drive
        // is located.
        do
        {
            nCount++;
            String sURL = "file://c:\\";
            for(int i=0; i< nCount; i++)
                sURL += "z";
            sURL += "\\app.exe";
            localUrlEvidence = new Url(sURL);
            eTmp = new Evidence();
            eTmp.AddHost(localUrlEvidence);
        }while (Security.DoesHitURLCodegroup(eTmp));

        // We'll do the same for URL evidence
        Url RemoteUrlEvidence = null;
        nCount = 0;
        // Note, it doesn't matter if http://z (or http://zzzzzz, or whatever) is the actual name
        // of the machine... we just need the evidence. There is no harm because we control 
        // the evidence that tells the security manager where the http address is located.
        
        do
        {
            nCount++;
            String sURL = "http://";
            for(int i=0; i< nCount; i++)
                sURL += "z";
                
            RemoteUrlEvidence = new Url(sURL);
            eTmp = new Evidence();
            eTmp.AddHost(RemoteUrlEvidence);
        }while (Security.DoesHitURLCodegroup(eTmp));

        // Evaluate it with both local and remote evidence
        Evidence eVal = new Evidence(e);
        eVal.AddHost(localUrlEvidence);
        int nLocalLevel = Security.FindCurrentPermissionSet(eVal);
        eVal = new Evidence(e);
        eVal.AddHost(RemoteUrlEvidence);
        int nRemoteLevel = Security.FindCurrentPermissionSet(eVal);

        if (nRemoteLevel == nLocalLevel)
            return nRemoteLevel;

        else
        // Something is messed up. We don't know what's going on here
            return PermissionSetType.UNKNOWN;
    }// FindCurrentPermissionSet


    X509Certificate GetCertificate()
    {
        // Let's dig through the evidence and look for a Publisher object
        // so we can get a X509 certificate
        IEnumerator enumerator = m_ev.GetHostEnumerator();

        while (enumerator.MoveNext())
        {
            Object o = (Object)enumerator.Current;
            if (o is Publisher)
                return ((Publisher)o).Certificate;
        }
        return null;
    }// GetCertificate

    StrongName GetStrongName()
    {
        // Let's dig through the evidence and look for a StrongName object
        IEnumerator enumerator = m_ev.GetHostEnumerator();

        while (enumerator.MoveNext())
        {
            Object o = (Object)enumerator.Current;
            if (o is StrongName)
                return (StrongName)o;
        }
        return null;
    }// GetCertificate

    Hash GetHash()
    {
        // Let's dig through the evidence and look for a Hash object
        IEnumerator enumerator = m_ev.GetHostEnumerator();

        while (enumerator.MoveNext())
        {
            Object o = (Object)enumerator.Current;
            if (o is Hash)
                return (Hash)o;
        }
        return null;
    }// GetCertificate

}// class CFullTrustWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnettaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;

class CNetTaskPad : CTaskPad
{
    internal CNetTaskPad(CNode n): base(n)
    {
    }// CIntroTaskPad

    internal override void Notify(Object arg, Object param, IConsole2 con, CData com)
    {
        String sNodeToOpen = null;

    
        // We want to browse the shared assemblies
        if ((int)arg == 1)
        {
            sNodeToOpen = "Assembly Cache";
        }
        // We want to Configure Assemblies
        else if ((int)arg == 2)
        {
            sNodeToOpen = "Configured Assemblies";
        }
        // We want to set Security Policy
        else if ((int)arg == 3)
        {
            sNodeToOpen = "Runtime Security Policy";
        }
        // We want to go to remoting node
        else if ((int)arg == 4)
        {
            CNode node = m_myNode.FindChild("Remoting Services");
            CNodeManager.SelectScopeItem(node.HScopeItem);
            node.OpenMyPropertyPage();

        }
        // We want to go to the applications node
        else if ((int)arg == 5)
        {
            sNodeToOpen = "Applications";
        }



        // This is a CommandHistory item
        else if ((int)arg >=100)
            CCommandHistory.FireOffCommand((int)arg);
        else
            MessageBox(0, "Error in web page! I don't know what to do!", "", 0);

       if (sNodeToOpen != null)
       {
            CNode node = m_myNode.FindChild(sNodeToOpen);
            // This node must have a shared assemblies node... if it doesn't, then the 
            // node hasn't added it's children yet. We'll force it to do that, and try
            // again
            if (node == null)
            {
                m_myNode.CreateChildren();
                node = m_myNode.FindChild(sNodeToOpen);
            }
            CNodeManager.Console.SelectScopeItem(node.HScopeItem);
       }

        
    }// Notify

    protected override String GetHTMLFilename()
    {
        return "NET_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String[] args = new String[2] {Util.Version.VersionString,
                                       CCommandHistory.GetFavoriteCommandsHTML()};
        return GetHTMLFile(args);    
    }// GetHTMLFile
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);

}// class CIntroTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\chtmlfilegen.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CHTMLFileGen.cs
//
// This implements our own little HTML parser for 'server-side'
// includes.
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Reflection;
using System.Text;
using System.IO;
using System.Collections.Specialized;
using System.Web;
using System.Globalization;

internal class CHTMLFileGen
{
    static private StringCollection m_scGifs;          // Holds filenames of GIFs we've sucked down

    static private String[] m_sGIFs = {"NET_GIF",
                                       "NETTOP_GIF"};

    static private StringCollection m_scPages;

    //-------------------------------------------------
    // CHTMLFileGen - Constructor
    //
    // Not much exciting going on here
    //-------------------------------------------------
    static CHTMLFileGen()
    {
        m_scGifs = new StringCollection();
        m_scPages = new StringCollection();
        // Currently, we don't have any GIFs to load. If we ever
        // get GIFs that we have to put in the HTML, we can uncomment this
        // call and put the resource names in m_sGIFS
        // LoadGIFs();
    }// CHTMLFileGen


    //-------------------------------------------------
    // LoadGIFs
    // 
    // This function will pull the GIFs out of the resource
    // file and stash them in a temp directory somewhere
    //-------------------------------------------------
    private static void LoadGIFs()
    {
        int iLen = m_sGIFs.Length;
        for(int i=0; i<iLen; i++)
        {
            Byte[] pGif = CResourceStore.GetGIF(m_sGIFs[i]);
            String sOutFileName = Path.GetTempFileName().ToLower(CultureInfo.InvariantCulture);
            // GetTempFileName actually creates a file. We don't want that
            File.Delete(sOutFileName);
            // The filename we have has a '.tmp' extension. We need a 
            // .gif extension to our file
            StringBuilder GoodFilename = new StringBuilder(sOutFileName);
            GoodFilename.Replace(".tmp", ".gif");
            sOutFileName = GoodFilename.ToString();
            
            // Now let's write this info
            BinaryWriter bw = new BinaryWriter(File.OpenWrite(sOutFileName));
            bw.Write(pGif);
            bw.Close();
            // Add this filename to our list of stuff
            m_scGifs.Add(sOutFileName);
        }
    }// LoadGifs

    //-------------------------------------------------
    // Shutdown
    // 
    // This function should be called before the process
    // exits in order to clean up any temp files that were
    // generated during execution
    //-------------------------------------------------
    static internal void Shutdown()
    {
        // Now delete all the GIFs we created
        for(int i=0; i<m_scGifs.Count; i++)
            File.Delete(m_scGifs[i]);

        // And delete all the HTML pages we generated
        for(int i=0; i<m_scPages.Count; i++)
            File.Delete(m_scPages[i]);
        
    }// Shutdown

    //-------------------------------------------------
    // GenHTMLFile
    //
    // This function will load an HTML file, parse it, 
    // save it into a temporary file, and return that
    // temporary file's name.
    // The function will look for <*-#-*> where # can be
    // any number. It is then substituted with that phrase
    // found in that index in the String array passed into it.
    //-------------------------------------------------
    static internal String GenHTMLFile(String sFilename, String[] args)
    {
        String sHTMLContents = CResourceStore.GetHTMLFile(sFilename);

        if (args != null)
        {
            // Let's do some escaping....
            // We don't want to escape any '<!--' or '-->' blocks, but everything
            // else is open game

            // Ok, this is a semi-hack, but we don't want to do this for the
            // 'intro' page of the UI. We dynamically generate some HTML links
            // that can't be stomped on by this.

            if (!sFilename.Equals("NET_HTML")) 
                for(int i=0; i< args.Length; i++)
                {
                    if (args[i] != null && !args[i].Equals("<!--") && !args[i].Equals("-->"))
                        args[i] = HttpUtility.HtmlEncode(args[i]);
                }

        
            // Run through the strings we're supposed to add in looking for any international characters
            for(int i=0; i<args.Length; i++)
            {
                if (args[i] != null)
                {
                    for(int j=0; j<args[i].Length; j++)
                    {
                        if (((uint)args[i][j]) > 255)
                        {
                            // Ok, so we want to put in an international character. Generally, the font
                            // that the HTML renderer uses does not support international characters,
                            // so we'll tell the renderer to use a different font for this string.
                            
                            //args[i] = "<span style='font-family:\"MS Mincho\"'>" + args[i] + "</span>";
                            args[i] = "<span style='font-family:\"MS UI Gothic\"'>" + args[i] + "</span>";
                            // We don't need to look at this string anymore... let's go
                            // look at the next one.
                            break;
                        }
                    }
                }
            }
        }
                
        // Make our substitutions
        StringBuilder sb = new StringBuilder(sHTMLContents);
        if (args != null)
        {
            int iLen = args.Length;
            for(int i=0; i<iLen; i++)
             sb.Replace("<*-" + i + "-*>", args[i]);
        }

        // Now run through and add in any GIFs we have laying around
        // The GIF filenames will all be marked with negative numbers
        int iNumGifs = m_scGifs.Count;
        for(int i=-1; i>=iNumGifs*-1; i--)
        {
           // We do the funky (i*-1)-1 to make our i postive, zero
           // based... so if i = -1, then we go to the 0 index, if i = -2,
           // we go to the 1 index, and so on.
           sb.Replace("<*-" + i + "-*>", m_scGifs[(i*-1)-1]);
        }


        String sOutFileName = Path.GetTempFileName().ToLower(CultureInfo.InvariantCulture);

        // Replace the <*-9999-*> with the name of this file
        sb.Replace("<*-9999-*>", sOutFileName);



        // Write Parsed HTMLFile
        StreamWriter sw = new StreamWriter(File.Create(sOutFileName));
        sw.Write(sb.ToString());
        sw.Close();
        m_scPages.Add(sOutFileName);

        return sOutFileName;
        
    }// GenHTMLFile
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, int type);

}// class CHTMLFileGen

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cgensectaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;

class CGenSecTaskPad : CTaskPad
{
    internal CGenSecTaskPad(CNode node) : base(node)
    {
    }// CGenSecTaskPad


    protected override String GetHTMLFilename()
    {
        return "GENSEC_HTML";
    }// Init
    
    internal override void Notify(Object arg, Object param, IConsole2 con, CData com)
    {
       if ((int)arg == 1)
       {
            // We want to add a code condition for this machine
       }
       else if ((int)arg == 2)
       {
            // We want to edit a code condition for this machine
       }
       else if ((int)arg == 3)
       {
            // We want to Add a code condition for a specific user
            
       }
       else if ((int)arg == 4)
       {
            // We want to edit a code condition for a specific user
       }
       else if ((int)arg == 5)
       {
            // We want to add a permission set for a specific machine
       }
       else if ((int)arg == 6)
       {
            // We want to edit a permission set for a specific machine
       }
       else if ((int)arg == 7)
       {
            // We want to add a permission set for a specific user
       }
       else if ((int)arg == 8)
       {
            // We want to edit a permission set for a specific user
       }
       else if ((int)arg == 9)
       {
            // We want to add permissions
       }
       else if ((int)arg == 10)
       {
            // We want to remove permissions
       }
       else if ((int)arg == 11)
       {
       }
       else
            base.Notify(arg, param, con, com);
    }// Notify

     internal override String GetHTMLFile()
    {
        // Let's generate our user list
        String sUserOptions="";
        String[] args = new String[2] {sUserOptions,"<OPTION>Some machine</OPTION>"};
        return GetHTMLFile(args);
    }// GetHTMLFile
}// class CIntroTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\chelpdialog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Runtime.InteropServices;

internal class CHelpDialog : Form 
{
    private System.Windows.Forms.Label m_lbl;
    private PictureBox m_pb1;
    private PictureBox m_pb2;
    private PictureBox m_pb3;
    private PictureBox m_pb4;
    //private Point m_pLocation;

    internal CHelpDialog(String sHelp, Point pPosition)
    {
        InitializeComponent();
        m_lbl.Text = sHelp;

        // Let's figure out how big to make the label....
        SizeF sf = m_lbl.CreateGraphics().MeasureString(sHelp, m_lbl.Font, new SizeF(400, 0));
        sf = new SizeF(sf.Width+1, sf.Height+1);
        m_lbl.Size = sf.ToSize();

        // We want to pop up just below this control
        pPosition.Y+=10;

        // Make sure we won't go off the top of the screen
   
        if (pPosition.X < 0)
            pPosition.X = 1;
        if (pPosition.Y < 0)
            pPosition.Y = 1;

        // We should probably also make sure we don't fly off the bottom or the
        // right, but we need some text sizes to be able to make that call.

           Location = pPosition;
    }// CHelpDialog

    private void InitializeComponent()
    {
        this.m_lbl = new System.Windows.Forms.Label();
        m_pb1 = new PictureBox();
        m_pb2 = new PictureBox();
        m_pb3 = new PictureBox();
        m_pb4 = new PictureBox();
        
        // 
        // m_lbl
        // 
        this.m_lbl.BackColor = System.Drawing.SystemColors.Info;
        this.m_lbl.BorderStyle = System.Windows.Forms.BorderStyle.None;
        this.m_lbl.Location = new System.Drawing.Point(16, 8);
        this.m_lbl.Name = "Help";
        this.m_lbl.Size = new System.Drawing.Size(1, 1);
        this.m_lbl.TabIndex = 0;
        this.m_lbl.ForeColor = SystemColors.InfoText;
        m_lbl.TextAlign = ContentAlignment.MiddleLeft;
        // 
        // Win32Form1
        // 
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.BackColor = System.Drawing.SystemColors.Info;
        this.ClientSize = new System.Drawing.Size(320, 230);
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_lbl, m_pb1, m_pb2, m_pb3, m_pb4});
        this.MaximizeBox = false;
        this.MinimizeBox = false;
        this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
        this.ShowInTaskbar = false;
        this.StartPosition = FormStartPosition.Manual;
        this.AutoScale = false;
        this.m_lbl.Click += new EventHandler(onClose);
        this.Click += new EventHandler(onClose);
        this.KeyPress += new KeyPressEventHandler(onKeyClose);
        this.LostFocus += new EventHandler(onClose);
        this.Name = "Win32Form1";
        m_lbl.SizeChanged+=new EventHandler(onSizeChange);


        int nFlags = GetWindowLong(m_lbl.Handle, -20 /* GWL_EXSTYLE */);

        // Remove the WS_EX_LAYOUTRTL style
        nFlags = nFlags & ~0x00400000;

        SetWindowLong(m_lbl.Handle, -20 /* GWL_EXSTYLE */, nFlags);


    }// InitializeComponent

    void onSizeChange(Object o, EventArgs e)
    {
        int nNewWidth = m_lbl.Size.Width+32;
        int nNewHeight = m_lbl.Size.Height+14;

        this.ClientSize = new Size(nNewWidth, nNewHeight);

        // Create the pens to draw the border
        Pen pOuterBorder = new Pen(SystemColors.WindowFrame);
        Pen pInnerBorder = new Pen(SystemColors.WindowFrame);
        

        // Draw the border....
        Bitmap bmp;
        Graphics g;
              
        // Draw the top half
        bmp = new Bitmap(nNewWidth, 2);
        g = Graphics.FromImage(bmp);
        g.DrawLine(pOuterBorder, new Point(0, 0), new Point(nNewWidth, 0));
        g.DrawLine(pOuterBorder, new Point(0, 1), new Point(nNewWidth, 1));
        g.DrawLine(pInnerBorder, new Point(1, 1), new Point(nNewWidth-2, 1));
        m_pb1.Location = new Point(0, 0);
        m_pb1.Size = new Size(nNewWidth, 2);
        m_pb1.Image = bmp;

        // Draw the bottom Half
        bmp = new Bitmap(nNewWidth, 2);
        g = Graphics.FromImage(bmp);
        g.DrawLine(pOuterBorder, new Point(0, 1), new Point(nNewWidth, 1));
        g.DrawLine(pOuterBorder, new Point(0, 0), new Point(nNewWidth, 0));
        g.DrawLine(pInnerBorder, new Point(1, 0), new Point(nNewWidth-2, 0));
        m_pb2.Location = new Point(0, nNewHeight-2);
        m_pb2.Size = new Size(nNewWidth, 2);
        m_pb2.Image = bmp;

        // Draw the left side
        bmp = new Bitmap(2, nNewHeight-2);
        g = Graphics.FromImage(bmp);
        g.DrawLine(pOuterBorder, new Point(0, 0), new Point(0, nNewHeight-2));
        g.DrawLine(pInnerBorder, new Point(1, 0), new Point(1, nNewHeight-2));
        m_pb3.Location = new Point(0, 1);
        m_pb3.Size = new Size(2, nNewHeight-2);
        m_pb3.Image = bmp;

        // Draw the right side
        bmp = new Bitmap(2, nNewHeight-2);
        g = Graphics.FromImage(bmp);
        g.DrawLine(pInnerBorder, new Point(0, 0), new Point(0, nNewHeight-2));
        g.DrawLine(pOuterBorder, new Point(1, 0), new Point(1, nNewHeight-2));
        m_pb4.Location = new Point(nNewWidth-2, 1);
        m_pb4.Size = new Size(2, nNewHeight-2);
        m_pb4.Image = bmp;

    }// onSizeChange

    void onClose(Object o, EventArgs e)
    {
        this.Close();
    }

    void onKeyClose(Object o, KeyPressEventArgs e)
    {
        onClose(0, null);
    }
    [DllImport("user32.dll")]
	internal static extern int GetWindowLong(IntPtr hWnd, int nIndex);
	[DllImport("user32.dll")]
	internal static extern int SetWindowLong(IntPtr hWnd, int nIndex, int 
dwNewLong);

}// class CHelpDialog

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewcodegroupwiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security.Policy;

internal class CNewCodeGroupWiz1 : CNewPermSetWiz1
{
 
    internal CNewCodeGroupWiz1(PolicyLevel pl) : base(pl)
    {
        m_sTitle=CResourceStore.GetString("CNewCodeGroupWiz1:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CNewCodeGroupWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CNewCodeGroupWiz1:HeaderSubTitle");
    }// CNewCodeGroupWiz1

    
    internal override int InsertPropSheetPageControls()
    {
        base.InsertPropSheetPageControls();
        m_radCreateNew.Text = CResourceStore.GetString("CNewCodeGroupWiz1:m_radCreateNew.Text");
        m_radImportXML.Text = CResourceStore.GetString("CNewCodeGroupWiz1:m_radImportXML.Text");
        return 1;
    }// InsertPropSheetPageControls

    internal override bool ValidateData()
    {
        // Make sure this code group's name is not already taken
        if (Security.isCodeGroupNameUsed(m_pl.RootCodeGroup, Name))
        {
            MessageBox(String.Format(CResourceStore.GetString("Codegroupnameisbeingused"),Name),
                       CResourceStore.GetString("CodegroupnameisbeingusedTitle"),
                       MB.ICONEXCLAMATION);
            return false;
        }
        return true;
        
    }// ValidateData
   
}// class CNewCodeGroupWiz1

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cgensecurity.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CGenSecurity.cs
//
// This class presents the top level security node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Security.Policy;
using System.Security;
using System.IO;
using System.Threading;
using System.Reflection;


internal class CGenSecurity : CSecurityNode
{
    bool            m_fUICanRun;
    Mutex           m_mutex;
    Mutex           m_mutexOnFlag;

    internal CGenSecurity()
    {
        m_sGuid = "D823B36A-8700-4227-8EA8-8ED4B96F4E4A";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("security_ico");  
        m_oResults=new CGenSecTaskPad(this);
        DisplayName = CResourceStore.GetString("CGenSecurity:DisplayName");
        Name = "Runtime Security Policy";
        m_aPropSheetPage = null;
        Security.GenSecurityNode = this;
        m_fUICanRun = true;
        m_mutex = new Mutex();
        m_mutexOnFlag = new Mutex();

    }// CGenSecurity

    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {  
         // See if we're allowed to insert an item in the "view" section
         if ((pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
         {
            // Stuff common to the top menu
            CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            // Add the new... item to the menu
            newitem.strName = CResourceStore.GetString("CGenSecurity:NewOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:NewOptionDes");
            newitem.lCommandID = COMMANDS.NEW_SECURITYPOLICY;
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            // Add the open... item to the menu
            newitem.strName = CResourceStore.GetString("CGenSecurity:OpenOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:OpenOptionDes");
            newitem.lCommandID = COMMANDS.OPEN_SECURITYPOLICY;
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            // Add the Reset... item to the menu
            newitem.strName = CResourceStore.GetString("CGenSecurity:ResetOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:ResetOptionDes");
            newitem.lCommandID = COMMANDS.RESET_POLICY;
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            // This option should only be available if the user can write to either
            // the machine policy level or the user policy level
            if(!MachineNode.ReadOnly || !UserNode.ReadOnly)
            {
                // Add the Adjust Security Policy... item to the menu
                newitem.strName = CResourceStore.GetString("CGenSecurity:AdjustSecurityOption");
                newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:AdjustSecurityOptionDes");
                newitem.lCommandID = COMMANDS.ADJUST_SECURITYPOLICY;
                // Now add this item through the callback
                piCallback.AddItem(ref newitem);
            }
            
            // Add the evaulate... item to the menu
            newitem.strName = CResourceStore.GetString("CGenSecurity:EvaluateAssemOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:EvaluateAssemOptionDes");
            newitem.lCommandID = COMMANDS.EVALUATE_ASSEMBLY;
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);

            // This option should only be available if the user can write to either
            // the machine policy level or the user policy level
            if(!MachineNode.ReadOnly || !UserNode.ReadOnly)
            {
                // Add the Add fully trusted... item to the menu
                newitem.strName = CResourceStore.GetString("CGenSecurity:TrustAssemOption");
                newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:TrustAssemOptionDes");
                newitem.lCommandID = COMMANDS.TRUST_ASSEMBLY;
                // Now add this item through the callback
                piCallback.AddItem(ref newitem);
            }
            
            // Add the Create Deployment Package... item to the menu
            newitem.strName = CResourceStore.GetString("CGenSecurity:CreateDeployOption");
            newitem.strStatusBarText = CResourceStore.GetString("CGenSecurity:CreateDeployOptionDes");
            newitem.lCommandID = COMMANDS.CREATE_MSI;
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);



         }
    }// AddMenuItems

    internal override void MenuCommand(int iCommandID)
    {
        // All these menu commands are going to require the policy nodes to be created and expanded.
        // Let's check to see if we've done that already....
        if (NumChildren == 0)
            CNodeManager.CNamespace.Expand(HScopeItem);
    
        if (iCommandID == COMMANDS.NEW_SECURITYPOLICY)
        {
            CNewSecurityPolicyDialog nspd = new CNewSecurityPolicyDialog();
            System.Windows.Forms.DialogResult dr = nspd.ShowDialog();
            if (dr == System.Windows.Forms.DialogResult.OK)
            {
                // To get a 'New' Security policy, we just load a policy from a file that doesn't exist
                CSecurityPolicy secpolnode = GetSecurityPolicyNode(nspd.SecPolType); 

                // Ok, this is really dumb. I need to create a security file where the user
                // wants to store the policy before I can tell the Security Manager about it.
                File.Copy(secpolnode.MyPolicyLevel.StoreLocation, nspd.Filename, true);
                PolicyLevel pl = SecurityManager.LoadPolicyLevelFromFile(nspd.Filename, nspd.SecPolType);
                pl.Reset();
                secpolnode.SetNewSecurityPolicyLevel(pl);
                secpolnode.SecurityPolicyChanged();
                // Select the policy node the user just mucked with
                CNodeManager.SelectScopeItem(secpolnode.HScopeItem);
            }
        }
        else if (iCommandID == COMMANDS.OPEN_SECURITYPOLICY)
        {
            COpenSecurityPolicyDialog ospd = new COpenSecurityPolicyDialog(new String[] {EnterpriseNode.ComputerPolicyFilename,
                                                                                         MachineNode.ComputerPolicyFilename,
                                                                                         UserNode.ComputerPolicyFilename});
            System.Windows.Forms.DialogResult dr = ospd.ShowDialog();
            if (dr == System.Windows.Forms.DialogResult.OK)
            {
                // Try and load the given security policy
                PolicyLevel pl;
                try
                {
                    pl=SecurityManager.LoadPolicyLevelFromFile(ospd.Filename, ospd.SecPolType);
                }
                catch
                {
                    MessageBox(String.Format(CResourceStore.GetString("CGenSecurity:isNotASecurityFile"), ospd.Filename),
                               CResourceStore.GetString("CGenSecurity:isNotASecurityFileTitle"),
                               MB.ICONEXCLAMATION);
                    return;
                }
                CSecurityPolicy secpolnode = GetSecurityPolicyNode(ospd.SecPolType); 
                secpolnode.SetNewSecurityPolicyLevel(pl);
                // Select the policy node the user just mucked with
                CNodeManager.SelectScopeItem(secpolnode.HScopeItem);

            }
        }
        else if (iCommandID == COMMANDS.EVALUATE_ASSEMBLY)
        {
            CWizard wiz = new CEvalAssemWizard();
            wiz.LaunchWizard(Cookie);
        }
        else if (iCommandID == COMMANDS.TRUST_ASSEMBLY)
        {
            // Let's create a new wizard now to dump any old settings we have
            CFullTrustWizard wiz = new CFullTrustWizard(MachineNode.ReadOnly, UserNode.ReadOnly);

            wiz.LaunchWizard(Cookie);

            // See if it updated anything a codegroup
            if (wiz.MadeChanges)
            {
                CSecurityPolicy sp = GetSecurityPolicyNode(Security.GetPolicyLevelTypeFromLabel(wiz.PolLevel.Label));
                sp.RedoChildren();
                sp.SecurityPolicyChanged();
            }
        }
        else if (iCommandID == COMMANDS.ADJUST_SECURITYPOLICY)
        {
            CSecurityAdjustmentWizard wiz = new CSecurityAdjustmentWizard(MachineNode.ReadOnly, UserNode.ReadOnly);
            wiz.LaunchWizard(Cookie);

            // Check to see if we need to tell any policies that we changed them
            if (wiz.didUserPolicyChange)
            {
                UserNode.RedoChildren();
                UserNode.SecurityPolicyChanged();
            }

            if (wiz.didMachinePolicyChange)
            {
                MachineNode.RedoChildren();
                MachineNode.SecurityPolicyChanged();
            }            
            
        }
        else if (iCommandID == COMMANDS.CREATE_MSI)
        {
            CWizard wiz = new CCreateDeploymentPackageWizard(this);
            wiz.LaunchWizard(Cookie);
        }
        else if (iCommandID == COMMANDS.RESET_POLICY)
        {
            int nRes = MessageBox(CResourceStore.GetString("CGenSecurity:ConfirmResetAll"),
                                  CResourceStore.GetString("CGenSecurity:ConfirmResetAllTitle"),
                                  MB.YESNO|MB.ICONQUESTION);
            if (nRes == MB.IDYES)
            {
                if (!EnterpriseNode.ReadOnly)
                    EnterpriseNode.ResetSecurityPolicy();
                if (!MachineNode.ReadOnly)
                    MachineNode.ResetSecurityPolicy();
                if (!UserNode.ReadOnly)
                    UserNode.ResetSecurityPolicy();
                MessageBox(CResourceStore.GetString("CGenSecurity:PoliciesResetAll"),
                           CResourceStore.GetString("CGenSecurity:PoliciesResetAllTitle"),
                           MB.ICONINFORMATION);               
            }
        }

     }// MenuCommand

    internal override void SecurityPolicyChanged(bool fShowDialog)
    {       
        // Let's check to see if we just hosed the security policy so our tool
        // can't do anything anymore.
        CheckCurrentPermissions();
    }// SecurityPolicyChanged

    internal void CheckCurrentPermissions()
    {
        // This can be a somewhat lengthy process (2-3 seconds), so we'll have another thread
        // handle it.
        Thread thread = new Thread(new ThreadStart(CheckCurrentPermissionsThreadStart));
        thread.Start();
    }// CheckCurrentPermissions

    internal void CheckCurrentPermissionsThreadStart()
    {
        m_mutex.WaitOne();
        m_mutexOnFlag.WaitOne();
        bool fInitValue = m_fUICanRun;
        m_mutexOnFlag.ReleaseMutex();
    
        // Now do our thing that takes awhile    
        PermissionSet permSet = Security.CreatePermissionSetFromAllMachinePolicy(Assembly.GetExecutingAssembly().Evidence);

        // Now double check to see if this value has changed since we last looked at it
        m_mutexOnFlag.WaitOne();
        bool fEndValue = m_fUICanRun;
        m_mutexOnFlag.ReleaseMutex();

        // If our user didn't change the security policy on us... keep going
        if (fInitValue == fEndValue)
        {
            // We'll check to see if we're unrestricted. We can be a little more granular later
            if (fEndValue && (permSet == null || !permSet.IsUnrestricted()))
            {
                // This is really bad. If they save the policy, the tool won't work anymore
                MessageBox(CResourceStore.GetString("CSecurityPolicy:MachinePolicyChangedNotAdminFriendly"),
                           CResourceStore.GetString("CSecurityPolicy:MachinePolicyChangedNotAdminFriendlyTitle"),
                           MB.ICONEXCLAMATION|MB.SYSTEMMODAL);
                
                m_mutexOnFlag.WaitOne();
                // See if we should modify this value
                if (fEndValue == m_fUICanRun)
                    m_fUICanRun = false;
                m_mutexOnFlag.ReleaseMutex();

            }
            else if (permSet != null && permSet.IsUnrestricted())
            {
                if (!fEndValue)
                {
                
                    MessageBox(CResourceStore.GetString("CSecurityPolicy:PolicyChangedNowAdminFriendly"),
                               CResourceStore.GetString("CSecurityPolicy:PolicyChangedNowAdminFriendlyTitle"),
                               MB.ICONASTERISK|MB.SYSTEMMODAL);
                }
                m_mutexOnFlag.WaitOne();
                // See if we should modify this value
                if (fEndValue == m_fUICanRun)
                    m_fUICanRun = true;
                m_mutexOnFlag.ReleaseMutex();
            }
        }
            m_mutex.ReleaseMutex();
    }// CheckCurrentPermissions

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
       if ((int)arg == 0)
       {
            // We need to pop up the "Trust an App Wizard"
            MenuCommand(COMMANDS.TRUST_ASSEMBLY);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.TRUST_ASSEMBLY);

       }

       if ((int)arg == 1)
       {
            // We need to pop up the "Adjust Security Settings Wizard"
            MenuCommand(COMMANDS.ADJUST_SECURITYPOLICY);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.ADJUST_SECURITYPOLICY);
       }

       if ((int)arg == 2)
       {
            // We need to pop up the "Evaluate Assembly"
            MenuCommand(COMMANDS.EVALUATE_ASSEMBLY);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.EVALUATE_ASSEMBLY);
       }

       if ((int)arg == 3)
       {
            // We need to pop up the "Create Deployment Package Wizard"
            MenuCommand(COMMANDS.CREATE_MSI);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.CREATE_MSI);
       }

       if ((int)arg == 4)
       {
            // We need to do the reset thing
            MenuCommand(COMMANDS.RESET_POLICY);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.RESET_POLICY);
       }


       
    }// TaskPadTaskNotify

    internal CSecurityPolicy GetSecurityPolicyNode(PolicyLevelType nType)
    {
        switch(nType)
        {
            case PolicyLevelType.Enterprise:
                return EnterpriseNode;
            case PolicyLevelType.Machine:
                return MachineNode;
            case PolicyLevelType.User:
                return UserNode;
        }
        throw new Exception("I don't know this policy type");
    }// GetSecurityPolicyNode

    internal CSecurityPolicy EnterpriseNode
    {
        get
        {
            return (CSecurityPolicy)CNodeManager.GetNode(Child[0]); 
        }

    }// EnterpriseNode

    internal CSecurityPolicy MachineNode
    {
        get
        {
            return (CSecurityPolicy)CNodeManager.GetNode(Child[1]);
        }
    }// MachineNode

    internal CSecurityPolicy UserNode
    {
        get
        {
            return (CSecurityPolicy)CNodeManager.GetNode(Child[2]);
        }
    }// UserNode

    private int GetNodeIndexNumber(PolicyLevelType nType)
    {
        switch(nType)
        {
            case PolicyLevelType.Enterprise:
                return 0;
            case PolicyLevelType.Machine:
                return 1;
            case PolicyLevelType.User:
                return 2;
            default:
                throw new Exception("I don't know about this type");
        }
    }// GetNodeIndexNumber

    internal CSinglePermissionSet AddPermissionSet(PolicyLevel pl, NamedPermissionSet ps)
    {
        // Find the policy level we're after
        if (UserNode.MyPolicyLevel == pl)
            return UserNode.AddPermissionSet(ps);

        else if (MachineNode.MyPolicyLevel == pl)
            return MachineNode.AddPermissionSet(ps);

        else if (EnterpriseNode.MyPolicyLevel == pl)
            return EnterpriseNode.AddPermissionSet(ps);

        else
            throw new Exception("I don't know about this policy level");
    }// AddPermissionSet

    private CSecurityPolicy CreatePolicyNode(PolicyLevelType nType, PolicyLevel pl)
    {
        int             iCookie=0;
        int             nIndex=0;
        CSecurityPolicy node;

        // This node's ordering of the children nodes it inserts is very important
        if (m_iChildren == null || m_iChildren.Length != 3)
            m_iChildren = new int[3];

        switch(nType)
        {
            case PolicyLevelType.Enterprise:
                node = new CSecurityPolicy("Enterprise", pl);
                break;
            case PolicyLevelType.Machine:
                node = new CSecurityPolicy("Machine", pl);
                break;
            case PolicyLevelType.User:
                node = new CSecurityPolicy("User", pl);
                break;
            default:
                throw new Exception("I don't know about this type");
        }

        nIndex=GetNodeIndexNumber(nType);
        CNode gennode = (CNode)node;
        iCookie = CNodeManager.AddNode(ref gennode);
        m_iChildren[nIndex]=iCookie;
        
        return node;
    }// CreatePolicyNode

    //-------------------------------------------------
    // CreateChildren
    //
    // This function creates the node's children, registers
    // the nodes with the node manager, and places the node's
    // cookies in it's child array
    //-------------------------------------------------
    internal override void CreateChildren()
    {
        CreatePolicyNode(PolicyLevelType.Enterprise, null);
        CreatePolicyNode(PolicyLevelType.Machine, null);
        CreatePolicyNode(PolicyLevelType.User, null);
        
    }// CreateChildren
}// class CGenSecurity
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewcodegroupwiz3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security.Policy;
using System.Security;
using System.Security.Permissions;


internal class CNewCodeGroupWiz3 : CWizardPage
{
    // Controls on the page
	private ComboBox m_cbPermissionSets;
    private RadioButton m_radCreatePermissionSet;
    private Label m_lblHelp;
    private RadioButton m_radUseExisting;

    PolicyLevel         m_pl;
  	
    internal CNewCodeGroupWiz3(PolicyLevel pl)
    {
        m_sTitle=CResourceStore.GetString("CNewCodeGroupWiz3:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CNewCodeGroupWiz3:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CNewCodeGroupWiz3:HeaderSubTitle");
        m_pl = pl;
    }// CNewCodeGroupWiz3
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewCodeGroupWiz3));
        this.m_cbPermissionSets = new System.Windows.Forms.ComboBox();
        this.m_radCreatePermissionSet = new System.Windows.Forms.RadioButton();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_radUseExisting = new System.Windows.Forms.RadioButton();
        this.m_cbPermissionSets.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbPermissionSets.DropDownWidth = 288;
        this.m_cbPermissionSets.Location = ((System.Drawing.Point)(resources.GetObject("m_cbPermissionSets.Location")));
        this.m_cbPermissionSets.Size = ((System.Drawing.Size)(resources.GetObject("m_cbPermissionSets.Size")));
        this.m_cbPermissionSets.TabIndex = ((int)(resources.GetObject("m_cbPermissionSets.TabIndex")));
        m_cbPermissionSets.Name = "PermissionSets";
        this.m_radCreatePermissionSet.Location = ((System.Drawing.Point)(resources.GetObject("m_radCreatePermissionSet.Location")));
        this.m_radCreatePermissionSet.Size = ((System.Drawing.Size)(resources.GetObject("m_radCreatePermissionSet.Size")));
        this.m_radCreatePermissionSet.TabIndex = ((int)(resources.GetObject("m_radCreatePermissionSet.TabIndex")));
        this.m_radCreatePermissionSet.Text = resources.GetString("m_radCreatePermissionSet.Text");
        m_radCreatePermissionSet.Name = "CreatePermissionSet";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_radUseExisting.Location = ((System.Drawing.Point)(resources.GetObject("m_radUseExisting.Location")));
        this.m_radUseExisting.Size = ((System.Drawing.Size)(resources.GetObject("m_radUseExisting.Size")));
        this.m_radUseExisting.TabIndex = ((int)(resources.GetObject("m_radUseExisting.TabIndex")));
        this.m_radUseExisting.Text = resources.GetString("m_radUseExisting.Text");
        m_radUseExisting.Name = "UseExistingPermissionSet";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_radCreatePermissionSet,
                        this.m_cbPermissionSets,
                        this.m_radUseExisting,
                        this.m_lblHelp});
        PutValuesinPage();

	    return 1;
    }// InsertPropSheetPageControls

    internal NamedPermissionSet    PermSet
    {
        get
        {
            if (m_radCreatePermissionSet.Checked)
                return null;
            else
            {
                // Let's assign one of the defined permission sets
                    return GetCurrentPermissionSet();
            }
        }
    }// PermissionSet

    private NamedPermissionSet GetCurrentPermissionSet()
    {
        IEnumerator permsetEnumerator = m_pl.NamedPermissionSets.GetEnumerator();
        permsetEnumerator.MoveNext();     
        while (!((NamedPermissionSet)permsetEnumerator.Current).Name.Equals(m_cbPermissionSets.Text))
            permsetEnumerator.MoveNext();

        return (NamedPermissionSet)permsetEnumerator.Current;
    }// GetCurrentPermissionSet

    private void PutValuesinPage()
    {
        // We need to populate our combo box with all the possible Permission Sets available
        // in the current policy level

        // Fill the Permission Set Combo Box
        m_cbPermissionSets.Items.Clear();
        IEnumerator permsetEnumerator = m_pl.NamedPermissionSets.GetEnumerator();
                   
        while (permsetEnumerator.MoveNext())
        {
            NamedPermissionSet permSet = (NamedPermissionSet)permsetEnumerator.Current;
            m_cbPermissionSets.Items.Add(permSet.Name); 
        }    
        m_cbPermissionSets.SelectedIndex=0;
        m_radUseExisting.Checked = true;
    }// PutValuesinPage

}// class CNewCodeGroupWiz3

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewcodegroupwiz2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security.Permissions;
using System.Security.Policy;
using System.Security;

internal class CNewCodeGroupWiz2 : CSingleCodeGroupMemCondProp
{
    internal CNewCodeGroupWiz2() : base(null)
    {
        // Since we're inheriting off of a property page and not a wizard
        // page, we need to set our size ourselves....
        CWizardPage wizPage = new CWizardPage();
        PageSize = wizPage.PageSize;
        
    
        m_sTitle=CResourceStore.GetString("CNewCodeGroupWiz2:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CNewCodeGroupWiz2:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CNewCodeGroupWiz2:HeaderSubTitle");
        m_cg = new UnionCodeGroup(new AllMembershipCondition(), new PolicyStatement(new PermissionSet(PermissionState.None))); 
        MyCodeGroup = m_cg;
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewCodeGroupWiz2));
        m_point2ndPiece = ((System.Drawing.Point)(resources.GetObject("m_uc.Location")));
    }// CNewCodeGroupWiz2
    
    internal override int InsertPropSheetPageControls() 
    {
        base.InsertPropSheetPageControls();
    
        m_lblMCHelp.Visible = false;
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewCodeGroupWiz2));
        this.m_lblConditionType.Location = ((System.Drawing.Point)(resources.GetObject("m_lblConditionType.Location")));
        this.m_lblConditionType.Size = ((System.Drawing.Size)(resources.GetObject("m_lblConditionType.Size")));
        this.m_lblConditionType.TabIndex = ((int)(resources.GetObject("m_lblConditionType.TabIndex")));
        this.m_lblConditionType.Text = resources.GetString("m_lblConditionType.Text");
        m_lblConditionType.Name = "ConditionTypeLabel";
        this.m_cbConditionType.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbConditionType.DropDownWidth = 288;
        this.m_cbConditionType.Location = ((System.Drawing.Point)(resources.GetObject("m_cbConditionType.Location")));
        this.m_cbConditionType.Size = ((System.Drawing.Size)(resources.GetObject("m_cbConditionType.Size")));
        this.m_cbConditionType.TabIndex = ((int)(resources.GetObject("m_cbConditionType.TabIndex")));
        m_cbConditionType.Name = "ConditionType";
        m_ucTop.Size = ((System.Drawing.Size)(resources.GetObject("$this.Size")));

        CWizardPage wizPage = new CWizardPage();

        PageSize = wizPage.WizardPageSize;
        return 1;
    }
}// class CNewCodeGroupWiz2

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewcodegroupwiz4.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security.Policy;
using System.Security;

internal class CNewCodeGroupWiz4 : CWizardPage
{
    // Controls on the page

	private CheckBox m_chkExclusive;
    private CheckBox m_chkLevelFinal;
    private Label m_lblHelp;
    private Label m_lblExclusive;
    private Label m_lblLevelFinal;
    private Label m_lblTwoOptions;
   	
    internal CNewCodeGroupWiz4()
    {
        m_sTitle=CResourceStore.GetString("CNewCodeGroupWiz4:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CNewCodeGroupWiz4:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CNewCodeGroupWiz4:HeaderSubTitle");
    }// CNewCodeGroupWiz4
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewCodeGroupWiz4));
        this.m_chkExclusive = new System.Windows.Forms.CheckBox();
        this.m_chkLevelFinal = new System.Windows.Forms.CheckBox();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblExclusive = new System.Windows.Forms.Label();
        this.m_lblLevelFinal = new System.Windows.Forms.Label();
        this.m_lblTwoOptions = new System.Windows.Forms.Label();
        this.m_chkExclusive.Location = ((System.Drawing.Point)(resources.GetObject("m_chkExclusive.Location")));
        this.m_chkExclusive.Size = ((System.Drawing.Size)(resources.GetObject("m_chkExclusive.Size")));
        this.m_chkExclusive.TabIndex = ((int)(resources.GetObject("m_chkExclusive.TabIndex")));
        this.m_chkExclusive.Text = resources.GetString("m_chkExclusive.Text");
        m_chkExclusive.Name = "Exclusive";
        m_chkExclusive.Visible = false;
        this.m_chkLevelFinal.Location = ((System.Drawing.Point)(resources.GetObject("m_chkLevelFinal.Location")));
        this.m_chkLevelFinal.Size = ((System.Drawing.Size)(resources.GetObject("m_chkLevelFinal.Size")));
        this.m_chkLevelFinal.TabIndex = ((int)(resources.GetObject("m_chkLevelFinal.TabIndex")));
        this.m_chkLevelFinal.Text = resources.GetString("m_chkLevelFinal.Text");
        m_chkLevelFinal.Name = "LevelFinal";
        m_chkLevelFinal.Visible = false;
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblExclusive.Location = ((System.Drawing.Point)(resources.GetObject("m_lblExclusive.Location")));
        this.m_lblExclusive.Size = ((System.Drawing.Size)(resources.GetObject("m_lblExclusive.Size")));
        this.m_lblExclusive.TabIndex = ((int)(resources.GetObject("m_lblExclusive.TabIndex")));
        this.m_lblExclusive.Text = resources.GetString("m_lblExclusive.Text");
        m_lblExclusive.Name = "ExclusiveLabel";
        this.m_lblLevelFinal.Location = ((System.Drawing.Point)(resources.GetObject("m_lblLevelFinal.Location")));
        this.m_lblLevelFinal.Size = ((System.Drawing.Size)(resources.GetObject("m_lblLevelFinal.Size")));
        this.m_lblLevelFinal.TabIndex = ((int)(resources.GetObject("m_lblLevelFinal.TabIndex")));
        this.m_lblLevelFinal.Text = resources.GetString("m_lblLevelFinal.Text");
        m_lblLevelFinal.Name = "LevelFinalLabel";
        this.m_lblTwoOptions.Location = ((System.Drawing.Point)(resources.GetObject("m_lblTwoOptions.Location")));
        this.m_lblTwoOptions.Size = ((System.Drawing.Size)(resources.GetObject("m_lblTwoOptions.Size")));
        this.m_lblTwoOptions.TabIndex = ((int)(resources.GetObject("m_lblTwoOptions.TabIndex")));
        this.m_lblTwoOptions.Text = resources.GetString("m_lblTwoOptions.Text");
        m_lblTwoOptions.Name = "OptionsLabel";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_chkLevelFinal,
                        this.m_lblLevelFinal,
                        this.m_chkExclusive,
                        this.m_lblExclusive,
                        this.m_lblTwoOptions,
                        this.m_lblHelp});
        return 1;
    }// InsertPropSheetPageControls

    internal bool Final
    {
        get
        {
            return m_chkLevelFinal.Checked;
        }
    }// Final

    internal bool Exclusive
    {
        get
        {
            return m_chkExclusive.Checked;
        }
    }// Exclusive
}// class CNewCodeGroupWiz4

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewpermsetwiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security;
using System.Security.Policy;


internal class CNewPermSetWiz1 : CWizardPage
{
    // Controls on the page
    private Button m_btnBrowse;
    private Label m_lblDescription;
    private Label m_lblName;
    private TextBox m_txtFilename;
    private TextBox m_txtName;
    private TextBox m_txtDescription;
    protected RadioButton m_radCreateNew;
    protected RadioButton m_radImportXML;

    protected PolicyLevel     m_pl;
  
    internal CNewPermSetWiz1(PolicyLevel pl)
    {
        m_pl = pl;
        m_sTitle=CResourceStore.GetString("CNewPermSetWiz1:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CNewPermSetWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CNewPermSetWiz1:HeaderSubTitle");
    }// CNewPermSetWiz1
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewPermSetWiz1));
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_lblDescription = new System.Windows.Forms.Label();
        this.m_radCreateNew = new System.Windows.Forms.RadioButton();
        this.m_lblName = new System.Windows.Forms.Label();
        this.m_radImportXML = new System.Windows.Forms.RadioButton();
        this.m_txtDescription = new System.Windows.Forms.TextBox();
        this.m_txtFilename = new System.Windows.Forms.TextBox();
        this.m_txtName = new System.Windows.Forms.TextBox();
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        m_btnBrowse.Name = "Browse";
        this.m_lblDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_lblDescription.Location")));
        this.m_lblDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_lblDescription.Size")));
        this.m_lblDescription.TabIndex = ((int)(resources.GetObject("m_lblDescription.TabIndex")));
        this.m_lblDescription.Text = resources.GetString("m_lblDescription.Text");
        m_lblDescription.Name = "DescriptionLabel";
        this.m_radCreateNew.Location = ((System.Drawing.Point)(resources.GetObject("m_radCreateNew.Location")));
        this.m_radCreateNew.Size = ((System.Drawing.Size)(resources.GetObject("m_radCreateNew.Size")));
        this.m_radCreateNew.TabIndex = ((int)(resources.GetObject("m_radCreateNew.TabIndex")));
        this.m_radCreateNew.Text = resources.GetString("m_radCreateNew.Text");
        m_radCreateNew.Name = "CreateNew";
        this.m_lblName.Location = ((System.Drawing.Point)(resources.GetObject("m_lblName.Location")));
        this.m_lblName.Size = ((System.Drawing.Size)(resources.GetObject("m_lblName.Size")));
        this.m_lblName.TabIndex = ((int)(resources.GetObject("m_lblName.TabIndex")));
        this.m_lblName.Text = resources.GetString("m_lblName.Text");
        m_lblName.Name = "NameLabel";
        this.m_radImportXML.Location = ((System.Drawing.Point)(resources.GetObject("m_radImportXML.Location")));
        this.m_radImportXML.Size = ((System.Drawing.Size)(resources.GetObject("m_radImportXML.Size")));
        this.m_radImportXML.TabIndex = ((int)(resources.GetObject("m_radImportXML.TabIndex")));
        this.m_radImportXML.Text = resources.GetString("m_radImportXML.Text");
        m_radImportXML.Name = "ImportXML";
        this.m_txtDescription.Location = ((System.Drawing.Point)(resources.GetObject("m_txtDescription.Location")));
        this.m_txtDescription.Multiline = true;
        this.m_txtDescription.Size = ((System.Drawing.Size)(resources.GetObject("m_txtDescription.Size")));
        this.m_txtDescription.TabIndex = ((int)(resources.GetObject("m_txtDescription.TabIndex")));
        this.m_txtDescription.Text = resources.GetString("m_txtDescription.Text");
        m_txtDescription.Name = "Description";
        this.m_txtFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_txtFilename.Location")));
        this.m_txtFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_txtFilename.Size")));
        this.m_txtFilename.TabIndex = ((int)(resources.GetObject("m_txtFilename.TabIndex")));
        this.m_txtFilename.Text = resources.GetString("m_txtFilename.Text");
        m_txtFilename.Name = "Filename";
        this.m_txtName.Location = ((System.Drawing.Point)(resources.GetObject("m_txtName.Location")));
        this.m_txtName.Size = ((System.Drawing.Size)(resources.GetObject("m_txtName.Size")));
        this.m_txtName.TabIndex = ((int)(resources.GetObject("m_txtName.TabIndex")));
        this.m_txtName.Text = resources.GetString("m_txtName.Text");
        m_txtName.Name = "Name";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_radCreateNew,
                        this.m_radImportXML,
                        this.m_lblName,
                        this.m_txtName,
                        this.m_lblDescription,
                        this.m_txtDescription,
                        this.m_btnBrowse,
                        this.m_txtFilename
                        });

        // Hook up event handlers
        m_txtName.TextChanged += new EventHandler(onTextChange);
        m_txtFilename.TextChanged +=new EventHandler(onTextChange);
        m_btnBrowse.Click += new EventHandler(onBrowseClick);
        m_radCreateNew.Click += new EventHandler(onNewRadioButton);
        m_radImportXML.Click += new EventHandler(onNewRadioButton);
        
        m_radCreateNew.Checked = true;
        onNewRadioButton(null, null);
        return 1;
    }// InsertPropSheetPageControls

    void onNewRadioButton(Object o, EventArgs e)
    {
        bool fEnableNewStuff = m_radCreateNew.Checked;
        
        m_txtFilename.Enabled = !fEnableNewStuff;
        m_btnBrowse.Enabled = !fEnableNewStuff;
        m_txtName.Enabled = fEnableNewStuff;
        m_txtDescription.Enabled = fEnableNewStuff;

        // Turn the next/finish button onto a state we want
        onTextChange(null, null);
        
    }// onNewRadioButton

    internal String Name
    {
        get
        {
            return m_txtName.Text;
        }
    }// PermSetName

    internal String Description
    {
        get
        {
            return m_txtDescription.Text;
        }
    }// PermSetDescription

    internal String Filename
    {
        get
        {
            if (m_radImportXML != null && m_radImportXML.Checked)
                return m_txtFilename.Text;
            else
                return null;
        }
    }// ImportedPermissionSet

    void onTextChange(Object o, EventArgs e)
    {
        CWizard wiz = (CWizard)CNodeManager.GetNode(m_iCookie);

        if (m_radCreateNew.Checked)
        {
            // See if we should turn on the Next button
            bool fTurnOnNext = m_txtName.Text.Length>0;
            wiz.TurnOnNext(fTurnOnNext);
        }
        else
        {
            // If they have a filename, then we be messing with the finish button
            bool fTurnOnFinish = m_txtFilename.Text.Length > 0;
        
            wiz.TurnOnFinish(fTurnOnFinish);
        }
    }// onTextChange

    private void onBrowseClick(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("XMLFD");
        fd.Filter = CResourceStore.GetString("XMLFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr != System.Windows.Forms.DialogResult.OK)
            return;
        else
            m_txtFilename.Text = fd.FileName;

    }// onImportClick

    internal override bool ValidateData()
    {
        // Make sure this code group's name is not already taken
        if (Security.isPermissionSetNameUsed(m_pl, m_txtName.Text))
        {
            MessageBox(String.Format(CResourceStore.GetString("PermissionSetnameisbeingused"),m_txtName.Text),
                       CResourceStore.GetString("PermissionSetnameisbeingusedTitle"),
                       MB.ICONEXCLAMATION);
            return false;
        }
        return true;
        
    }// ValidateData
    
}// class CNewPermSetWiz1
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewsecuritypolicydialog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections;
using System.Security;

class CNewSecurityPolicyDialog : Form
{
    private RadioButton m_radEnterprise;
    private GroupBox m_gbFilename;
    private Label m_lblFilename;
    private Label m_lblChoosePolHelp;
    private RadioButton m_radUser;
    private RadioButton m_radMachine;
    private GroupBox gm_gbPolicyType;
    private Button m_btnBrowse;
    private Button m_btnCancel;
    private TextBox m_txtFilename;
    private Button m_btnOK;
    
    internal CNewSecurityPolicyDialog()
    {
        SetupControls();
    }// CNewSecurityPolicyDialog

    internal PolicyLevelType SecPolType
    {
        get
        {
            if (m_radEnterprise.Checked == true)
                return PolicyLevelType.Enterprise;
            else if (m_radMachine.Checked == true)
                return PolicyLevelType.Machine;
            else
                return PolicyLevelType.User;
        }
    }// SecPolType

    internal String Filename
    {
        get
        {
            return m_txtFilename.Text;
        }
    }// Filename

    private void SetupControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewSecurityPolicyDialog));
        this.m_radEnterprise = new System.Windows.Forms.RadioButton();
        this.m_gbFilename = new System.Windows.Forms.GroupBox();
        this.m_lblFilename = new System.Windows.Forms.Label();
        this.m_lblChoosePolHelp = new System.Windows.Forms.Label();
        this.m_radUser = new System.Windows.Forms.RadioButton();
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_radMachine = new System.Windows.Forms.RadioButton();
        this.gm_gbPolicyType = new System.Windows.Forms.GroupBox();
        this.m_btnCancel = new System.Windows.Forms.Button();
        this.m_txtFilename = new System.Windows.Forms.TextBox();
        this.m_btnOK = new System.Windows.Forms.Button();
        this.m_radEnterprise.Location = ((System.Drawing.Point)(resources.GetObject("m_radEnterprise.Location")));
        this.m_radEnterprise.Size = ((System.Drawing.Size)(resources.GetObject("m_radEnterprise.Size")));
        this.m_radEnterprise.TabIndex = ((int)(resources.GetObject("m_radEnterprise.TabIndex")));
        this.m_radEnterprise.Text = resources.GetString("m_radEnterprise.Text");
        m_radEnterprise.Name = "Enterprise";
        this.m_gbFilename.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnBrowse,
                        this.m_txtFilename,
                        this.m_lblFilename});
        this.m_gbFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_gbFilename.Location")));
        this.m_gbFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_gbFilename.Size")));
        this.m_gbFilename.TabIndex = ((int)(resources.GetObject("m_gbFilename.TabIndex")));
        this.m_gbFilename.TabStop = false;
        this.m_gbFilename.Text = resources.GetString("m_gbFilename.Text");
        m_gbFilename.Name = "FilenameBox";
        this.m_lblFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_lblFilename.Location")));
        this.m_lblFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_lblFilename.Size")));
        this.m_lblFilename.TabIndex = ((int)(resources.GetObject("m_lblFilename.TabIndex")));
        this.m_lblFilename.Text = resources.GetString("m_lblFilename.Text");
        m_lblFilename.Name = "FilenameLabel";
        this.m_lblChoosePolHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChoosePolHelp.Location")));
        this.m_lblChoosePolHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChoosePolHelp.Size")));
        this.m_lblChoosePolHelp.TabIndex = ((int)(resources.GetObject("m_lblChoosePolHelp.TabIndex")));
        this.m_lblChoosePolHelp.Text = resources.GetString("m_lblChoosePolHelp.Text");
        m_lblChoosePolHelp.Name = "ChoosePolicyHelp";
        this.m_radUser.Location = ((System.Drawing.Point)(resources.GetObject("m_radUser.Location")));
        this.m_radUser.Size = ((System.Drawing.Size)(resources.GetObject("m_radUser.Size")));
        this.m_radUser.TabIndex = ((int)(resources.GetObject("m_radUser.TabIndex")));
        this.m_radUser.Text = resources.GetString("m_radUser.Text");
        m_radUser.Name = "User";
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        m_btnBrowse.Name = "Browse";
        this.m_radMachine.Location = ((System.Drawing.Point)(resources.GetObject("m_radMachine.Location")));
        this.m_radMachine.Size = ((System.Drawing.Size)(resources.GetObject("m_radMachine.Size")));
        this.m_radMachine.TabIndex = ((int)(resources.GetObject("m_radMachine.TabIndex")));
        this.m_radMachine.Text = resources.GetString("m_radMachine.Text");
        m_radMachine.Name = "Machine";
        this.gm_gbPolicyType.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_radUser,
                        this.m_radMachine,
                        this.m_radEnterprise,
                        this.m_lblChoosePolHelp});
        this.gm_gbPolicyType.Location = ((System.Drawing.Point)(resources.GetObject("gm_gbPolicyType.Location")));
        this.gm_gbPolicyType.Size = ((System.Drawing.Size)(resources.GetObject("gm_gbPolicyType.Size")));
        this.gm_gbPolicyType.TabIndex = ((int)(resources.GetObject("gm_gbPolicyType.TabIndex")));
        this.gm_gbPolicyType.TabStop = false;
        this.gm_gbPolicyType.Text = resources.GetString("gm_gbPolicyType.Text");
        gm_gbPolicyType.Name = "PolicyTypeBox";
        this.m_btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("m_btnCancel.Location")));
        this.m_btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("m_btnCancel.Size")));
        this.m_btnCancel.TabIndex = ((int)(resources.GetObject("m_btnCancel.TabIndex")));
        this.m_btnCancel.Text = resources.GetString("m_btnCancel.Text");
        m_btnCancel.Name = "Cancel";
        this.m_txtFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_txtFilename.Location")));
        this.m_txtFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_txtFilename.Size")));
        this.m_txtFilename.TabIndex = ((int)(resources.GetObject("m_txtFilename.TabIndex")));
        m_txtFilename.Name = "Filename";
        this.m_btnOK.Location = ((System.Drawing.Point)(resources.GetObject("m_btnOK.Location")));
        this.m_btnOK.Size = ((System.Drawing.Size)(resources.GetObject("m_btnOK.Size")));
        this.m_btnOK.TabIndex = ((int)(resources.GetObject("m_btnOK.TabIndex")));
        this.m_btnOK.Text = resources.GetString("m_btnOK.Text");
        m_btnOK.Name = "OK";
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnCancel,
                        this.m_btnOK,
                        this.m_gbFilename,
                        this.gm_gbPolicyType});
        this.Text = resources.GetString("$this.Text");
        this.MaximizeBox=false;
        this.MinimizeBox=false;
        this.Icon = null;


        // Do some customization of controls...
        
	    m_btnOK.DialogResult=System.Windows.Forms.DialogResult.OK;
        m_btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;

        m_btnOK.Enabled=false;
        m_txtFilename.TextChanged += new EventHandler(onTextChange);
        m_btnBrowse.Click += new EventHandler(onBrowse);
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.CancelButton = m_btnCancel;
        this.AcceptButton = m_btnOK;

		m_radEnterprise.Checked = true;
    }// SetupControls

    void onTextChange(Object o, EventArgs e)
    {
        if (m_txtFilename.Text.Length == 0)
            m_btnOK.Enabled=false;
        else
            m_btnOK.Enabled=true;

    }// onTextChange

    void onBrowse(Object o, EventArgs e)
    {
        SaveFileDialog fd = new SaveFileDialog();
        fd.Title = CResourceStore.GetString("CNewSecurityPolicyDialog:FDTitle");
        fd.Filter = CResourceStore.GetString("SecurityPolicyFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
            m_txtFilename.Text = fd.FileName;
    }// onBrowse

}// class CChooseSecPolDialog

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewpermsetwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Security.Policy;
using System.Security.Permissions;
using System.Security;

internal class CNewPermSetWizard: CSecurityWizard
{
    NamedPermissionSet   m_ps;
    PolicyLevel          m_pl;

   
    internal CNewPermSetWizard(PolicyLevel pl)
    {
        m_sName="Add Permission Set Wizard";
        m_aPropSheetPage = new CPropPage[] {new CNewPermSetWiz1(pl), new CNewPermSetWiz2()};
        m_pl = pl;
    }// CNewPermSetWizard

    protected override int WizSetActive(IntPtr hwnd)
    {
        // Make sure this sucker stays null
        m_ps = null;
    
        switch(GetPropPage(hwnd))
        {
            // If this is the first page of our wizard, we want a 
            // disabled next button to show
            case 0:
                    if (NewPermissionSetName.Equals(""))
                        TurnOnNext(false);
                    else
                        TurnOnNext(true);
                    break;
            case 1:
                TurnOnFinish(true);
                break;
        }
        return base.WizSetActive(hwnd);
                    
    }// WizSetActive

    private String NewPermissionSetName
    {
        get {return ((CNewPermSetWiz1)m_aPropSheetPage[0]).Name;}
    }// NewPermissionSetName

    private String NewPermissionSetDescription
    {
        get {return ((CNewPermSetWiz1)m_aPropSheetPage[0]).Description;}
    }// NewPermissionSetDescription
   
    private String XMLFilename
    {
        get {return ((CNewPermSetWiz1)m_aPropSheetPage[0]).Filename;}
    }// NewPermissionSetDescription
   
   
    private bool isImportXMLFile
    {
        get
        {
        
               if (XMLFilename == null || XMLFilename.Length == 0)
                   return false;
               return true;
          }
      }// isImportXMLFile
   
    private IPermission[] NewPermissions
    {
        get {return ((CNewPermSetWiz2)m_aPropSheetPage[1]).Permissions;}
    }// NewPermissions
    
    protected override int WizFinish(IntPtr hwnd)
    {
    
        if (isImportXMLFile)
        {
            // We're importing a permission set
            try
            {
                SecurityElement se = SecurityXMLStuff.GetSecurityElementFromXMLFile(XMLFilename);
                if (se == null)
                    throw new Exception("Invalid XML");

                m_ps = new NamedPermissionSet("Hi");
                m_ps.FromXml(se);

                if (m_ps.Name == null || m_ps.Name.Length == 0)
                    m_ps.Name = Security.FindAGoodPermissionSetName(m_pl, "CustomPermissionSet");
                
                return 0;
            }
            catch(Exception)
            {
                MessageBox(CResourceStore.GetString("XMLNoPermSet"),
                           CResourceStore.GetString("XMLNoPermSetTitle"),
                           MB.ICONEXCLAMATION);
                   SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)0, (IntPtr)(-1));
                return -1;

                   
               
            }
       
        }
    
        // Ok, let's create our permission set
        NamedPermissionSet nps = new NamedPermissionSet(NewPermissionSetName, PermissionState.None);
        nps.Description = NewPermissionSetDescription;

        IPermission[] perms = NewPermissions;

        for(int i=0; i<perms.Length; i++)
        nps.SetPermission(perms[i]);
        // Ok, now that we have this permission set, let's add it to 
        // our other ones....
        m_ps = nps;
        return 0;
    }// WizFinish

    internal NamedPermissionSet CreatedPermissionSet
    {
        get {return m_ps;}
    }// CreatedPermissionSet
    
}// class CNewPermSetWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewcodegroupwizard.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security;
using System.Security.Policy;
using System.Reflection;


internal class CNewCodeGroupWizard: CSecurityWizard
{
    PolicyLevel         m_pl;
    NamedPermissionSet  m_ps;
    CodeGroup           m_cg;
    bool                m_fOnPage1;
    bool                m_fNewPermissionSet;
   
   
    internal CNewCodeGroupWizard(PolicyLevel pl)
    {
        m_sName="Create CodeGroup Wizard";
        m_aPropSheetPage = new CPropPage[] {new CNewCodeGroupWiz1(pl), 
                                            new CNewCodeGroupWiz2(), 
                                            new CNewCodeGroupWiz3(pl), 
                                            new CNewCodeGroupWiz4(),
        /* This wizard also allows the */   new CNewPermSetWiz1(pl),
        /* user to create a permission */   new CNewPermSetWiz2()
        /* set, which is why we are    */   };
        /* including those wizard pages*/


        m_pl = pl;        
        m_fOnPage1 = true;
        m_fNewPermissionSet = false;
    }// CNewCodeGroupWizard

    protected override int WizSetActive(IntPtr hwnd)
    {
        // Make sure these things stay null until we really want them to be something else
        m_ps = null;
        m_cg = null;
        m_fOnPage1 = false;
        // Find out which property page this is....
        switch(GetPropPage(hwnd))
        {
            // If this is the first page of our wizard, we want a 
            // disabled next button to show
            case 0:
                if (NewCodeGroupName.Length == 0)
                    TurnOnNext(false);
                else
                    TurnOnNext(true);

                m_fOnPage1 = true;
    
                if (CodeGroupFilename != null)
                    TurnOnFinish(true);
                    
                break;
            case 1:
            case 2:
                    TurnOnNext(true);
                    break;
            case 3:
                base.TurnOnFinish(true);
                break;
        }
        return base.WizSetActive(hwnd);
                    
    }// WizSetActive

    // One of the property pages we pirate from another wizard tries
    // to turn on the finish button, but in reality, we just want it to
    // turn on the next button... so we'll intercept his TurnOnFinish
    // call and redirect it where it needs to be
    internal override void TurnOnFinish(bool fOn)
    {
        if (!m_fOnPage1)
            TurnOnNext(fOn);
        else
            base.TurnOnFinish(fOn);
    }// TurnOnFinish

    protected override int WizBack(IntPtr hwnd)
    {
        int nPropPageIndex = GetPropPage(hwnd);

        switch(nPropPageIndex)
        {
        
            case 3:
                // If the user came from the permission set creation wizard, we need to go back
                // to that
                if (PermissionSetFilename != null && PermissionSetFilename.Length > 0)
                {
                    SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)4, (IntPtr)(-1));
                    return -1;
                }
                else if (PermissionSet == null)
                {
                    SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)5, (IntPtr)(-1));
                    return -1;
                }
                break;
               case 4:
                   // The user is trying to go back from the 'Create a permission set' wizard page
                   // We should return them to the 'Choose permission set' page
                   SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)2, (IntPtr)(-1));
                return -1;
                   
        }
        
        return base.WizBack(hwnd);
    }// WizBack
        


    protected override int WizNext(IntPtr hwnd)
    {
        int nPropPageIndex = GetPropPage(hwnd);
        int nReturnCode = 0;

        if (nPropPageIndex == 2)
        {
            // We could have a branch in the wizard. If the user decided to create
            // a new permission set, we need to launch that wizard too.
            if (((CNewCodeGroupWiz3)m_aPropSheetPage[2]).PermSet == null)
            {
                SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)4, (IntPtr)(-1));
                nReturnCode = -1;
            }
        }
        else if (nPropPageIndex == 4)
        {
            // We could have a branch in the wizard. If the user decided to 
            // import a permission set, we need to jump to the last page in our wizard.
            if (PermissionSetFilename != null && PermissionSetFilename.Length > 0)
            {
                SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)3, (IntPtr)(-1));
                nReturnCode = -1;
            }
        }
        
        else if (nPropPageIndex == 5)
        {
            SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)3, (IntPtr)(-1));
            nReturnCode = -1;
        }

        int nBaseRet = base.WizNext(hwnd);
        if (nBaseRet == 0)
            return nReturnCode;
        else
            return nBaseRet;
    }// WizNext

    private NamedPermissionSet PermissionSet
    {
        get {return ((CNewCodeGroupWiz3)m_aPropSheetPage[2]).PermSet;}
    }// NewPermissionSet

    private String NewPermissionSetName
    {
        get {return ((CNewPermSetWiz1)m_aPropSheetPage[4]).Name;}
    }// NewPermissionSet

    private String NewPermissionSetDescription
    {
        get {return ((CNewPermSetWiz1)m_aPropSheetPage[4]).Description;}
    }// NewPermissionSet

    private IPermission[] NewPermissions
    {
        get {return ((CNewPermSetWiz2)m_aPropSheetPage[5]).Permissions;}
    }// NewPermissions

    private bool IsLevelFinal
    {
        get {return ((CNewCodeGroupWiz4)m_aPropSheetPage[3]).Final;}
    }// IsLevelFinal

    private bool IsExclusive
    {
        get {return ((CNewCodeGroupWiz4)m_aPropSheetPage[3]).Exclusive;}
    }// IsExclusive

    private IMembershipCondition NewMembershipCondition
    {
        get {return ((CNewCodeGroupWiz2)m_aPropSheetPage[1]).GetCurrentMembershipCondition();}
    }// NewMembershipCondition

    private String NewCodeGroupName
    {
        get {return ((CNewCodeGroupWiz1)m_aPropSheetPage[0]).Name;}
    }// NewCodeGroupName

    private String NewCodeGroupDescription
    {
        get {return ((CNewCodeGroupWiz1)m_aPropSheetPage[0]).Description;}
    }// NewCodeGroupName

    private String CodeGroupFilename
    {
        get {return ((CNewCodeGroupWiz1)m_aPropSheetPage[0]).Filename;}
    }// CodeGroupFilename

    private String PermissionSetFilename
    {
        get {return ((CNewPermSetWiz1)m_aPropSheetPage[4]).Filename;}
    }// NewPermissionSetDescription


    private CodeGroup ImportCodegroup()
    {
        CodeGroup cg = null;
        try
        {
            SecurityElement se = SecurityXMLStuff.GetSecurityElementFromXMLFile(CodeGroupFilename);
            if (se == null)
                throw new Exception("Invalid XML");

            Type t = Type.GetType((String)se.Attributes["class"]);

            if (t != null)
            {
                cg = (CodeGroup)Activator.CreateInstance (t, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null ,null);
            }
            if (cg == null)
            {
                MessageBox(CResourceStore.GetString("CNewCodeGroupWizard:UnknownClass"),
                           String.Format(CResourceStore.GetString("CNewCodeGroupWizard:UnknownClassTitle"), (String)se.Attributes["class"]),
                           MB.ICONEXCLAMATION);
            }
            else
            {
                
                cg.FromXml(se);

                if (cg.Name == null || cg.Name.Length == 0)
                    cg.Name = Security.FindAGoodCodeGroupName(m_pl, "CustomCodegroup");
                
                return cg;
            }
        }
        catch(Exception)
        {
            MessageBox(CResourceStore.GetString("CNewCodeGroupWizard:XMLNoCodegroup"),
                       CResourceStore.GetString("CNewCodeGroupWizard:XMLNoCodegroupTitle"),
                       MB.ICONEXCLAMATION);
        }
        return null;
    }// ImportCodegroup


    private NamedPermissionSet ImportPermissionSet()
    {
        // We're importing a permission set
        NamedPermissionSet nps = null;
        try
        {
            SecurityElement se = SecurityXMLStuff.GetSecurityElementFromXMLFile(PermissionSetFilename);
            if (se == null)
                throw new Exception("Invalid XML");

            nps = new NamedPermissionSet("Hi");
            nps.FromXml(se);

            if (nps.Name == null || nps.Name.Length == 0)
                nps.Name = Security.FindAGoodPermissionSetName(m_pl, "CustomPermissionSet");
                
            return nps;
        }
        catch(Exception)
        {
            MessageBox(CResourceStore.GetString("XMLNoPermSet"),
                       CResourceStore.GetString("XMLNoPermSetTitle"),
                       MB.ICONEXCLAMATION);
        }
        return null;
    }// ImportPermissionSet

    protected override int WizFinish(IntPtr hwnd)
    {
        // Let's see if we're importing the codegroup from a file
        if (CodeGroupFilename != null)
        {
            m_cg = ImportCodegroup();
            if (m_cg != null)
                return 0;
            
            // Else, we had problems
            SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)0, (IntPtr)(-1));
            return -1;
        }
    
        // This is the case where we need to create a code group from scratch
        
        // Ok, let's get our permission set
        if (PermissionSet == null)
        {
            NamedPermissionSet nps = null;

            if (PermissionSetFilename != null && PermissionSetFilename.Length > 0)
            {
                nps = ImportPermissionSet();
                if (nps == null)
                {
                    SendMessage(GetParent(hwnd), PSM.SETCURSEL, (IntPtr)3, (IntPtr)(-1));
                    return -1;
                }
            }
            
            else // They built a new permission set
            {
                nps = new NamedPermissionSet(NewPermissionSetName);

                nps.Description = NewPermissionSetDescription;

                IPermission[] perms = NewPermissions;
              
                for(int i=0; i<perms.Length; i++)
                nps.SetPermission(perms[i]);
            }
            // Ok, now that we have this permission set, let's make it available
            // so it can be added it to our other ones....
            m_fNewPermissionSet = true;
            m_ps = nps;            
        }
        else
        {
            m_fNewPermissionSet = false;
            m_ps = PermissionSet;
        }
        // Now create our codegroup
        PolicyStatement pols = new PolicyStatement(m_ps);
        pols.Attributes = PolicyStatementAttribute.Nothing;

        if (IsLevelFinal)
            pols.Attributes |= PolicyStatementAttribute.LevelFinal;

        if (IsExclusive)
            pols.Attributes |= PolicyStatementAttribute.Exclusive;

            
        UnionCodeGroup ucg = new UnionCodeGroup(NewMembershipCondition, pols);
        ucg.Name = NewCodeGroupName;
        ucg.Description = NewCodeGroupDescription;
            
        m_cg = ucg;
        return 0;
    }// WizFinish

    internal NamedPermissionSet CreatedPermissionSet
    {
        get
        {
            if (m_fNewPermissionSet)
                return m_ps;
            else
                return null;
        }
    }// CreatedPermissionSet

    internal CodeGroup CreatedCodeGroup
    {
        get
        {
            return m_cg;
        }
    }// CreatedCodeGroup



    }// class CNewCodeGroupWizard
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CNode.cs
//
// This class represents individual nodes in the snapin.
// It is responsible for virtually all aspects involving individual
// nodes, ranging from adding children to displaying property pages.
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Collections;
using System.Threading;


public class CNode : IColumnResultView, IEnumTASK
{
    protected String              m_sGuid;                 // The guid for this Node
    protected String              m_sHelpSection;          // The link into the help file for this node
    protected int[]               m_iChildren;             // The children this node has
    protected String              m_sDisplayName;          // The display name
    protected String              m_sIDName;               // The non-localized name to id this node
    protected int                 m_iCookie;               // The unique identifier for this node
    private   int                 m_iHScopeItem;           // MMC's unique identifier for this object 
    internal    Object              m_oResults;              // The items that will be displayed in the result pane
    protected int                 m_iResultNum;            // If there are multiple results, the result to use 
    protected IntPtr              m_hIcon;                 // The icon for this node
    protected int                 m_iParentHScopeItem;     // MMC's unique identifier for the parent
    protected IntPtr              m_hPropertyPageRouter;   // MMC's handle for handling a Property sheet
    protected CPropPage[]         m_aPropSheetPage;        // The property pages for this item
    protected IntPtr              m_hModule;               // A handle to this module
    private   int                 m_iData;                 // Misc data the node can hold
    protected String              m_sPropPageTemplate;     // The template used for property pages
    protected bool                m_fAllowMultiSelectResults;
    private   bool                m_fInsertedChildrenOnExpand;
    private   IntPtr              m_hBlankIcon;
    private   int                 m_iBlankIconIndex;
    private   IntPtr              m_hOldCursor;
    private   bool                m_fStartResultRefresh;
    private   bool                m_fWantToMakePropertyPageVisible;
    private   bool                m_fWantToRefreshResult;
    private static bool           m_fInitialCreationDone = false;
    
    //-------------------------------------------------
    // CNode - Constructor
    //
    // This transfers data for the node information structure
    // into the class and loads the node's icon.
    //-------------------------------------------------
    internal CNode()
    {
        // Zero out all the info out of the structure
        m_sGuid = null;
        m_sHelpSection = null;
        m_sDisplayName = null;
        m_sIDName = null;
        m_oResults = null;
        m_aPropSheetPage = null;
        m_hModule = Marshal.GetHINSTANCE(this.GetType().Module);
        m_iResultNum = 0;
        m_iHScopeItem = 0;
        m_iData = 0;
        m_hPropertyPageRouter=(IntPtr)(-1);
        m_iParentHScopeItem=-1;
        m_sPropPageTemplate = "IDD_WFCWRAPPERPROP";
        m_fAllowMultiSelectResults=false;
        m_fInsertedChildrenOnExpand = false;
        m_fStartResultRefresh=false;
        m_fWantToMakePropertyPageVisible=false;
        m_fWantToRefreshResult=false;
        
        // Set up the blank icon
        m_hBlankIcon = CResourceStore.GetHIcon("blank_ico");  
        m_iBlankIconIndex = CResourceStore.GetIconCookie(m_hBlankIcon);
    }// CNode

    //-------------------------------------------------
    // ~CNode - Destructor
    //
    //-------------------------------------------------
    ~CNode()
    {
    }// ~CNode

    internal virtual void Shutdown()
    {
    }// Shutdown

    //-------------------------------------------------
    // The following methods allow access to the node's
    // private data members.
    //-------------------------------------------------
    internal int Data
    {
        get
        {
            return m_iData;
        }
        set
        {
            m_iData = value;
        }
    }// Data

    
    internal virtual bool HavePropertyPages
    {
        get
        {
            if (m_aPropSheetPage == null)
                CreatePropertyPages();
                
            return m_aPropSheetPage != null;
        }
    }// HavePropertyPages

    internal bool HavePropertyPagesCreate
    {
        get
        {
            if (m_aPropSheetPage == null)
                CreatePropertyPages();
                
            return m_aPropSheetPage != null;
        }
    }// HavePropertyPages


    internal int ResultNum
    {
        get
        {
            return m_iResultNum;
        }
        set
        {
            m_iResultNum = value;
        }
    }// ResultNum

    internal int ParentHScopeItem
    {
        get
        {
            return m_iParentHScopeItem;
        }
    }// ParentHScopeItem
    
    internal IntPtr IconHandle
    {
        get
        {
            return m_hIcon;
        }
    }// IconHandle

    // This function will only return a result if the
    // result pane view is going to be an HTML page or Taskpad. All
    // other views are handled internally by the node.
    internal String Result
    {
        get
        {
            if (m_oResults is CTaskPad)
                return ((CTaskPad)m_oResults).GetHTMLFile();
            else
                return null;
        }
    }// Result

    internal int HScopeItem
    {
        get
        {
            return m_iHScopeItem;
        }
        set
        {
            m_iHScopeItem = value;
        }
    }// HScopeItem

    public int Cookie
    {
        get
        {
            return m_iCookie;
        }
        set
        {
            m_iCookie = value;
        }
    }// Cookie
   
    internal String DisplayName
    {
        get
        {
            return m_sDisplayName;
        }
        set
        {
            m_sDisplayName = value;
        }
    }// DisplayName

    internal String Name
    {
        get
        {
            if (m_sIDName != null)
                return m_sIDName;
            else
                return DisplayName;
        }
        set
        {
            m_sIDName = value;
        }
    }// DisplayName




    // This returns the displayname in a byte array, which
    // is required by IDataObject to send the name over a stream
    internal byte[] bDisplayName
    {
        get
        {
            return StringToByteArray(m_sDisplayName);
        }
    }// bDisplayName


    internal CLSID Guid
    {
        get
        {
            CLSID cls = new CLSID();

            // Let's parse the string to get a GUID structure
            String sFirstPart = m_sGuid.Substring(0, 8);
            String sSecondPart = m_sGuid.Substring(9, 4);
            String sThirdPart = m_sGuid.Substring(14, 4);

            cls.x = (uint)UInt32.Parse(sFirstPart, NumberStyles.HexNumber);
            cls.s1 = (ushort)UInt16.Parse(sSecondPart,NumberStyles.HexNumber);
            cls.s2 = (ushort)UInt16.Parse(sThirdPart, NumberStyles.HexNumber);
            cls.c = new byte[8];
            int iBeginSubString = 19;
            for(int i=0; i<8; i++)
            {
                String sPart = m_sGuid.Substring(iBeginSubString, 2);
                cls.c[i] = Byte.Parse(sPart, NumberStyles.HexNumber);
                iBeginSubString +=2;
                if ( i <7 && m_sGuid[iBeginSubString] == '-')
                    iBeginSubString++;
            }
           
            return cls;
        }
    }// Guid

    internal String HelpSection
    {
        get
        {
            return m_sHelpSection;
        }
        set
        {
            m_sHelpSection = value;
        }
    }// HelpSection

    internal int NumChildren
    {
        get
        {
           if (m_iChildren == null)
            return 0;
           else 
            return m_iChildren.Length;
        }
    }// NumChildren

    internal int[] Child
    {
        get
        {
            return m_iChildren;
        }
    }// Child

    protected virtual void CreatePropertyPages()
    {
    }// CreatePropertyPages

    internal virtual bool ResultQDO(int nCookie, out Object o)
    {
        o = null;
        return false;
    }// QDO

    internal virtual bool ResultCompareObjects(Object o1, Object o2, out bool fEqual)
    {
        fEqual = false;
        return false;
    }// CompareObjects
    
    internal virtual int doAcceptPaste(IDataObject ido)
    {
        return HRESULT.S_FALSE;
    }// doAcceptPaste

    internal virtual int doResultItemAcceptPaste(Object o, IDataObject ido)
    {
        return HRESULT.S_FALSE;
    }// doResultItemAcceptPaste
    internal virtual int Paste(IDataObject ido)
    {
        return HRESULT.S_FALSE;
    }// Paste

    internal bool HaveThisGroup(String group)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            if (padinfo.HaveGroup(group))
                return true;
        }
        return false;
    }// HaveThisGroup

    // Methods to implement IColumnResultView
    
    public virtual int getNumColumns()
    {
        return -1;
    }
    public virtual int getNumRows()
    {
        return -1;
    }
    public virtual String getColumnTitles(int iIndex)
    {
        return null;
    }
    public virtual String getValues(int iX, int iY)
    {
        return null;
    }
    public virtual void AddImages(ref IImageList il)
    {
        il.ImageListSetIcon(m_hBlankIcon, m_iBlankIconIndex);
    }
    public virtual int GetImageIndex(int i)
    {
        return m_iBlankIconIndex;
    }
    public virtual bool DoesItemHavePropPage(Object o)
    {
        return false;
    }
    public virtual CPropPage[] CreateNewPropPages(Object o)
    {
        return null;
    }



    // Methods to implement IEnumTask
    internal void BaseTaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        // Check to see if this is a HTML page telling us that it finished
        // loading....
        if (arg is int && (int)arg == 100)
        {
            m_fStartResultRefresh=false;
            if (m_fWantToMakePropertyPageVisible)
                ShowMyPropertyPageIfOpen();
        }
        TaskPadTaskNotify(arg, param, con, com);
    }// TaskPadTaskNotify


    internal virtual void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            padinfo.Notify(arg, param, con, com);
        }
        else
            throw new Exception("I don't have a taskpad!");
    }// TaskPadTaskNotify

    internal IEnumTASK GetIEnumTASK(String szTaskGroup)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            if (padinfo.HaveGroup(szTaskGroup))
            {
                if (padinfo is IEnumTASK)
                    return (IEnumTASK)padinfo;
                // We'll be using custom HTML pages to put in 
                // tasks, so we'll give MMC a generic (aka dummy) IEnumTASK implementation
                else
                    return (IEnumTASK)this;
            }    
            throw new Exception("I don't have that group!");
        }
        throw new Exception("I don't have a taskpad!");

    }// GetIEnumTASK

    internal String GetTaskPadTitle(String pszGroup)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            return padinfo.GetTitle();
        }
        throw new Exception("I don't have a taskpad!");        
    }// GetTaskPadTitle

    internal String GetTaskPadDescription(String pszGroup)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            return padinfo.GetDescription();
        }
        throw new Exception("I don't have a taskpad!");        
    }// GetTaskPadDescription
    
    internal MMC_TASK_DISPLAY_OBJECT GetTaskPadBackground(String pszGroup)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            return padinfo.GetBackground();
        }
        throw new Exception("I don't have a taskpad!");        
    }// GetTaskPadBackground

    internal MMC_LISTPAD_INFO GetTaskPadListPadInfo(String pszGroup)
    {
        if (m_oResults is CTaskPad)
        {
            CTaskPad padinfo = (CTaskPad)m_oResults;
            return padinfo.GetListPadInfo();
        }
        throw new Exception("I don't have a taskpad!");        

    }// GetTaskPadListPadInfo
    
    // Dummy functions to implement IEnumTASK

    public int Next(uint celt, ref MMC_TASK rgelt, ref uint pceltFetched)
    {
        return HRESULT.S_OK;
    }// Next
    public int Skip(uint celt)
    {
        return HRESULT.E_NOTIMPL;
    }// Skip
    public int Reset()
    {
        return HRESULT.S_OK;
    }// Reset
    public int Clone(ref IEnumTASK ppenum)
    {
        return HRESULT.E_NOTIMPL;
    }// Clone

    
    //-------------------------------------------------
    // AddChild
    //
    // This function is called whenever we want to add
    // a child node to this node
    //-------------------------------------------------
    internal void AddChild(int iNewChild)
    {
        int i;

        int[] temp = new int[NumChildren + 1];

        for(i=0; i<NumChildren; i++)
            temp[i] = m_iChildren[i];

        // Now add the new element
        temp[i] = iNewChild;

        // Now assign this new array to the internal array
        m_iChildren = temp;
    }// AddChild

    internal virtual void CreateChildren()
    {}// CreateChildren


    internal void onExpand(int thisHScopeItem)
    {
        // Only respond to the Expand message for the root node
        // or if we're on an non-mmc host.
        // For all others, expand them on another thread
        if ((Cookie == CNodeManager.RootNodeCookie || m_fInitialCreationDone || CNodeManager.Console is INonMMCHost) && !m_fInsertedChildrenOnExpand)
        {
            InsertChildren(thisHScopeItem);
            m_fInsertedChildrenOnExpand=true;
        }
    }// onExpand

    internal void LazyExpand()
    {
        // Expand all non-root nodes on another thread to free
        // up the main thread so it can do what it needs to do when
        // starting up
        if (Cookie != CNodeManager.RootNodeCookie && !m_fInsertedChildrenOnExpand)
        {
            ArrayList al = new ArrayList();
            al.Add(Cookie);
            
            // We need to expand all the children in a non-recursive way.
            // We'll use a queue approach
            while (al.Count > 0)
            {
                CNode node = CNodeManager.GetNode((int)al[0]);
            
                // First "expand" this node so it can receive children
                CNodeManager.ExpandNodeNamespace(node.HScopeItem);
    
                node.InsertChildren(node.HScopeItem);
                
                node.m_fInsertedChildrenOnExpand=true;

                // Push this node's children into our queue
                for(int i=0; i<node.NumChildren; i++)
                    al.Add(node.Child[i]);
                    
                // Remove this node we're working on    
                al.RemoveAt(0);
            }

            // All done with the initial slew of nodes
            m_fInitialCreationDone = true;
            // Let the node manager know, in case there's something else we want to do
            CNodeManager.FinishedNodeLoading();
            
        }
    }// LazyExpand

    //-------------------------------------------------
    // InsertChildren
    //
    // This function sends all the node's children
    // information to MMC
    //-------------------------------------------------
    internal void InsertChildren(int thisHScopeItem)
    {

        // In the case of the first node, it won't have its HScopeItem field set yet.
        // We'll set that now
        m_iHScopeItem = thisHScopeItem;

        // Insert our children
        CreateChildren();

        int numChildren = NumChildren;

        for(int i=0; i<numChildren; i++)
            InsertSpecificChild(Child[i]);
    }// InsertChildren

    internal void InsertSpecificChild(int iChild)
    {
        SCOPEDATAITEM sdi = new SCOPEDATAITEM();

        CNode nChild = CNodeManager.GetNode(iChild);
        
        sdi.mask = SDI.STR       |   
                   SDI.PARAM     |   
                   SDI.PARENT    |
                   SDI.IMAGE     |
                   SDI.OPENIMAGE |
                   SDI.CHILDREN;

        // The image index is going to be the same as the cookie value
        sdi.nImage      = CResourceStore.GetIconCookie(nChild.IconHandle);
        // The open image is the same as the closed image
        sdi.nOpenImage  = sdi.nImage;
        sdi.relativeID  = m_iHScopeItem;
        // We set displayname to -1 to initiate a callback for the string
        // (We need to do it this way... it's an MMCism)
        sdi.displayname = (IntPtr)(-1);
            
        sdi.lParam      = nChild.Cookie;

        // The children field is set to either 0 or 1 (if it has children or not)
        sdi.cChildren   = (nChild.NumChildren==0)?0:1; 

        // Once the item has been inserted, we're given the HScopeItem value for the node
        // MMC uses this value to uniquely identify the node. We'll store it for future
        // use.
        nChild.HScopeItem = CNodeManager.InsertItem(sdi);

        // We'll also put in the parent's HScopeItem
        nChild.m_iParentHScopeItem = HScopeItem;

        // Also, we can be slick and expand this child's node too

        // We don't care about perf savings after startup... do the expansion now
        // Also, if we have a non MMC host, we're not sure how it will behave
        // if it doesn't have all the nodes. Let's force the expand if we're not
        // running under MMC
        if (m_fInitialCreationDone || CNodeManager.Console is INonMMCHost)
        {
            // Expand this child
            CNodeManager.ExpandNodeNamespace(nChild.HScopeItem);
        }
        else if (Cookie == 0)
        {
            Thread t = new Thread(new ThreadStart(nChild.LazyExpand));
            t.Start();
        }
    }// InsertSpecificChild

    internal CNode FindChild(String s)
    {
        int iNumChildren = NumChildren;
        for(int i=0; i<iNumChildren; i++)
        {
            CNode node = CNodeManager.GetNode(Child[i]);
            if (node.Name.Equals(s))
                return node;
        }
        // We couldn't find that child
        return null;
    }// FindChild

    internal void RemoveChildren()
    {
        for(int i=0; i<NumChildren; i++)
            RemoveSpecificChildByIndex(i);
        m_iChildren = null;

    }// RemoveChildren

    internal void RemoveSpecificChild(int nCookie)
    {
        // Let's find the index # of this child
        int nChildIndex=0;
        while(Child[nChildIndex] != nCookie)
            nChildIndex++;

        RemoveSpecificChildByIndex(nChildIndex);

        // Now let's wipe him from our array
        int[] tmp = new int[m_iChildren.Length-1];
        int nOldIndex=0;
        int nNewIndex=0;

        while(nOldIndex < m_iChildren.Length)
        {
            // Make sure we don't copy over the child we're trying to 
            // delete
            if (nOldIndex != nChildIndex)
              tmp[nNewIndex++] = m_iChildren[nOldIndex];                  
            nOldIndex++;
        }

        // Assign our new child array....
        m_iChildren = tmp;

        // Ok, we should be set

    }// RemoveSpecificChild

    protected void RemoveSpecificChildByIndex(int nIndex)
    {
        // Have this child remove all his children nodes as well
        ArrayList al = new ArrayList();
        al.Add(CNodeManager.GetNode(Child[nIndex]));
        int i = 0;
        while (i < al.Count)
        {
            // Put all this guy's children in the queue as well
            CNode node = (CNode)al[i];
            for(int j=0; j<node.NumChildren; j++)
                al.Add(CNodeManager.GetNode(node.Child[j]));
            i++;
        }

        // Start from the bottom and work our way up
        while (al.Count > 0)
        {
            CNode node = (CNode)al[al.Count-1];
            // First, close any property pages associated with it
            node.CloseAllMyPropertyPages();

            // Inform MMC of this removal
            CNodeManager.CNamespace.DeleteItem(node.HScopeItem, 1);

            // Remove this node from the list
            CNodeManager.RemoveNode(node.Cookie);
            al.RemoveAt(al.Count-1);
        }
    }// RemoveSpecificChildByIndex

    internal void RedoChildren()
    {
        // Let's see if we've expanded this item yet...
        if (NumChildren == 0)
            CNodeManager.CNamespace.Expand(HScopeItem);
    
        RemoveChildren();
        InsertChildren(HScopeItem);
    }// RedoChildren

    internal virtual void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed, Object oResultItem)
    {
        AddMenuItems(ref piCallback, ref pInsertionAllowed);
    }// AddMenuItems

    internal virtual void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {
    }// AddMenuItems

    internal virtual void MenuCommand(int uCommandID, Object oResultItem)
    {
    }// MenuCommand

    internal virtual void MenuCommand(int uCommandID)
    {
        MenuCommand(uCommandID, null);
    }// MenuCommand

    internal virtual int onDoubleClick(Object o)
    {
        return HRESULT.S_FALSE;
    }// onDoubleClick

    internal virtual int onDelete(Object o)
    {
        return HRESULT.S_FALSE;
    }// onDelete

    internal virtual int onRestoreView(MMC_RESTORE_VIEW mrv, IntPtr param)
    {
        return HRESULT.S_FALSE;
    }
    
    internal virtual void Showing()
    {}// Showing

    internal virtual void Leaving()
    {}// Leaving

    private IColumnResultView GetColumnResultView()
    {
        IColumnResultView crv = null;
        if (m_oResults is IColumnResultView)
            crv = (IColumnResultView)m_oResults;
        else
        {
            // We want to do this if we're trying to pop up a result item's property
            // page when the result view currently is showing HTML.
            // This can occur from a menu item or from the most-often used commands
            crv = (IColumnResultView)this;
        }
        return crv;
    }// GetIColumnResultView

    //-------------------------------------------------
    // onShow
    //
    // This function will be used only if a column view is
    // to be presented in the result pane.
    //-------------------------------------------------
    internal void onShow(IConsole2 Console, IntPtr arg, IntPtr param)
    {
        if ((int)arg == 0)
            Leaving();

        // Let's make sure we do have a list view item to display
        if ((int)arg > 0 && m_oResults != null && m_oResults is IColumnResultView)
        {
        IColumnResultView crv = (IColumnResultView)m_oResults;
            
        // If we're here then we have stuff to add to the result
        // view (beyond the standard view)

        // Query the Conole for a couple interfaces to use
        IHeaderCtrl HeaderCtrl = (IHeaderCtrl)Console;
        IResultData ResultData = (IResultData)Console;

        // Add/Remove Multi-Select ability
        if (m_fAllowMultiSelectResults)
            ResultData.ModifyViewStyle(0, MMC.SINGLESEL);
        else
            ResultData.ModifyViewStyle(MMC.SINGLESEL, 0);
        

        // Let's put in the column titles and find out how wide 
        // each column should be
        int iNumCols = crv.getNumColumns();
        int iNumRows = crv.getNumRows();
        for (int i=0; i<iNumCols; i++)
        {
            int iMaxLength = crv.getColumnTitles(i).Length;
            for(int j=0; j<iNumRows; j++)
            {
                if (crv.getValues(j, i) != null)
                {
                    int iTempLength = crv.getValues(j, i).Length;
                    if (iTempLength > iMaxLength)
                        iMaxLength = iTempLength;
                }
            }
            int nWidth = GetColumnWidth(i, iMaxLength);
            HeaderCtrl.InsertColumn(i, crv.getColumnTitles(i), LVCFMT.LEFT, nWidth);
        }
        RESULTDATAITEM rdi = new RESULTDATAITEM();
        for (int n = 0; n < iNumRows; n++)
        {
            rdi.mask  = RDI.STR    |   
                        RDI.PARAM;     

            rdi.nImage      = crv.GetImageIndex(n); 
            // If we have a valid image, tell MMC to display it.
            if (rdi.nImage != -1)
                rdi.mask |= RDI.IMAGE;

            rdi.str         = (IntPtr)(-1);
            rdi.nCol        = 0;

            // We're doing the lParam a little differently. The low word contains the cookie
            // for this node, while the high word contains the row number + 1 we're inserting
            rdi.lParam      = m_iCookie | ((n+1) << 16);
                
            ResultData.InsertItem(ref rdi);
        }

       }
    }// onShow

    //-------------------------------------------------
    // GetColumnWidth
    //
    // This function will determine how widt a column
    // should be
    //-------------------------------------------------
    protected virtual int GetColumnWidth(int nColumn, int nMaxStrLength)
    {
        // TODO: Don't be lazy, and actually figure this out
        return nMaxStrLength*10;
    }// GetColumnWidth

    //-------------------------------------------------
    // RefreshDisplayName
    //
    // Our nodes will call this when they need their display
    // name refreshed
    //-------------------------------------------------
    protected void RefreshDisplayName()
    {
        SCOPEDATAITEM sdi = new SCOPEDATAITEM();   
        sdi.mask = SDI.STR;
        sdi.displayname = (IntPtr)(-1);
        sdi.ID = HScopeItem;

        CNodeManager.SetItem(sdi);
    }// RefreshDisplayName

    //-------------------------------------------------
    // RefreshResultView
    //
    // Our nodes will call this when they need their Result
    // view refreshed
    //-------------------------------------------------
    internal virtual void RefreshResultView()
    {
        // We'll only refresh ourselves if we're currently selected
        if (this == CNodeManager.SelectedNode)
        {
            if(m_hPropertyPageRouter != (IntPtr)(-1))
               m_fWantToRefreshResult = true;
            else
            {
               // Record who orginally had focus. If we had a property page
               // or something that had focus first, we're going to piss people
               // off if we hide it with MMC
               IntPtr hOriginalActive = GetActiveWindow();
               m_fStartResultRefresh = true;
               CNodeManager.SelectScopeItem(HScopeItem);
               IntPtr hFinalActive = GetActiveWindow();
               if (hOriginalActive != hFinalActive)
                   SetActiveWindow(hOriginalActive);
               m_fWantToRefreshResult = false;
            }
        }
    }// RefreshDisplayName



    //-------------------------------------------------
    // GetDisplayInfo
    //
    // This function is called by MMC whenever it needs to
    // display a node in the scope pane. 
    //-------------------------------------------------
    internal void GetDisplayInfo(ref SCOPEDATAITEM sdi)
    {
        // See if they want the display name
        if ((sdi.mask & SDI.STR) > 0)
            sdi.displayname = Marshal.StringToCoTaskMemUni(DisplayName);

        // The snapin was set up so the cookie is the same
        // value as the image index
        if ((sdi.mask & SDI.IMAGE) > 0)
            sdi.nImage = Cookie;

        // We're using the same image for the "open" image as
        // we are the "closed" image
        if ((sdi.mask & SDI.OPENIMAGE) > 0)
            sdi.nOpenImage = Cookie;

        // We shouldn't need to set this.... but if we need to...
        if ((sdi.mask & SDI.STATE) > 0)
            sdi.nState = 0; 

        // If we're inquiring about children....
        if ((sdi.mask & SDI.CHILDREN) > 0)
            sdi.cChildren = NumChildren;

    }// GetDisplayInfo

    //-------------------------------------------------
    // GetResultDisplayInfo
    //
    // This function will provide MMC with information on how
    // to display data items in the result pane. This function
    // is used to get data both for a column view and a list view.
    //-------------------------------------------------
    internal void GetResultDisplayInfo(ref RESULTDATAITEM ResultDataItem)
    {
        IColumnResultView crv = null;

        // See if we have info to display a column-view result
        if (m_oResults is IColumnResultView)
            crv = (IColumnResultView)m_oResults;

        // If we need a display name
        if ((ResultDataItem.mask & RDI.STR) > 0)
        {
            // See if MMC is requesting an item for the column view
            if (crv != null && (ResultDataItem.lParam >> 16) > 0)
                ResultDataItem.str = Marshal.StringToCoTaskMemUni(crv.getValues((ResultDataItem.lParam >> 16) -1 , ResultDataItem.nCol));
            // Nope, it's just looking for the display name for the node
            else
                ResultDataItem.str = Marshal.StringToCoTaskMemUni(m_sDisplayName);
        }
        // This snapin was set up so the node's image index is the 
        // same as the node's cookie unless we're getting an image for a listview
        if ((ResultDataItem.mask & RDI.IMAGE) > 0)
        {

            if (crv != null && (ResultDataItem.lParam >> 16) > 0)
                ResultDataItem.nImage = crv.GetImageIndex((ResultDataItem.lParam >> 16) -1);
            else
                ResultDataItem.nImage = CResourceStore.GetIconCookie(IconHandle);
        }

        if ((ResultDataItem.mask & RDI.PARAM) > 0)
            ResultDataItem.lParam = m_iCookie;

        // Don't know what this field is for, MSDN isn't clear
        // on it... just set it to 0 if we need to
        if ((ResultDataItem.mask & (uint)RDI.INDEX) > 0)
            ResultDataItem.nIndex = 0;
                
        // Reserved
        if ((ResultDataItem.mask & (uint)RDI.INDENT) > 0)
            ResultDataItem.iIndent = 0;
    }// GetResultDisplayInfo

    internal virtual void ResultItemSelected(IConsole2 con, Object oResults)
    {
        IConsoleVerb icv;       
        // Get the IConsoleVerb interface from MMC
        con.QueryConsoleVerb(out icv);

        // We want to disable drag-drop actions
        icv.SetVerbState(MMC_VERB.COPY, MMC_BUTTON_STATE.ENABLED, 0);
        icv.SetVerbState(MMC_VERB.DELETE, MMC_BUTTON_STATE.ENABLED, 0);
        icv.SetVerbState(MMC_VERB.PASTE, MMC_BUTTON_STATE.ENABLED, 0);
    
    }// ResultItemSelected

    internal virtual void ResultItemUnSelected(IConsole2 con, Object oResults)
    {
    }// ResultItemUnSelected

    internal virtual void onSelect(IConsoleVerb icv)
    {
    }// onSelect

    internal virtual int onRename(String sNewName)
    {
        // We don't support this event
        return HRESULT.S_FALSE;
    }// onRename

    internal virtual bool DoesResultHavePropertyPage(Object oResultNum)
    {
        // This doesn't apply unless we have a column view
        if (m_oResults != null && m_oResults is IColumnResultView)
            return ((IColumnResultView)m_oResults).DoesItemHavePropPage(oResultNum);
        // There is the possibility that we do have property pages, but our
        // current result if a taskpad. Let's see if this node implements the 
        // IColumnResultView interface
        return ((IColumnResultView)this).DoesItemHavePropPage(oResultNum);
    }// DoesResultHavePropertyPage

    internal void CreateResultPropertyPages(IPropertySheetCallback lpProvider, IntPtr handle, Object oResultData)
    {
       IColumnResultView crv = GetColumnResultView();
        
       if (crv!= null)
       {
            // Grab onto the handle that MMC gives us
            m_hPropertyPageRouter = handle;
            // If we don't have a router handle yet, store one.
            if (CNodeManager.GoodRouterHandle == (IntPtr)(-1))
                CNodeManager.GoodRouterHandle = handle;

            CPropPage[]  ppages = crv.CreateNewPropPages(oResultData);

            int iLen = ppages.Length;
            for(int i=0; i< iLen; i++)
            {
                ppages[i].Init(Cookie, handle);
                CreateSinglePropertyPage(lpProvider, ppages[i]);
            }
       }
    }// CreateResultPropertyPages
        
    //-------------------------------------------------
    // CreatePropertyPages
    //
    // This function will create property sheet pages based
    // on the information stored in its m_aPropSheetPage field.
    // It registers the property page along with the callback
    // functions.
    //-------------------------------------------------

    internal void CreatePropertyPages(IPropertySheetCallback lpProvider, IntPtr handle)
    {
        // Grab onto the handle that MMC gives us
        m_hPropertyPageRouter = handle;
        CPropPage[] ppages;

        ppages = m_aPropSheetPage;

        for(int i=0; i<ppages.Length; i++)
        {
            // Initialize each property sheet
            ppages[i].Init(Cookie, handle);
            CreateSinglePropertyPage(lpProvider, ppages[i]);
        }
    }// CreatePropertyPages

    internal void CreateSinglePropertyPage(IPropertySheetCallback lpProvider, CPropPage ppage)
    {
        PROPSHEETPAGE psp = new PROPSHEETPAGE();
        IntPtr hPage;

        // Fill in the property sheet page structure with the appropriate info
        psp.dwSize = 48;
        psp.dwFlags = PSP.DEFAULT | PSP.DLGINDIRECT | PSP.USETITLE | PSP.USEHEADERTITLE | PSP.USEHEADERSUBTITLE; 
        psp.hInstance = m_hModule;
        // We're using just a plain resource file as a "placeholder" for our WFC
        // placed controls
        psp.pResource = ppage.GetDialogTemplate();

        psp.pszTitle = ppage.Title();
        psp.hIcon = ppage.Icon();
        psp.pszHeaderTitle = ppage.HeaderTitle();
        psp.pszHeaderSubTitle = ppage.HeaderSubTitle();

        // See if our property page uses a icon
        if (psp.hIcon != (IntPtr)(-1))
            psp.dwFlags |= PSP.USEHICON;
                    
        // See if our property page uses a title
        if (ppage.Title()!=null)
            psp.dwFlags |= PSP.USETITLE;

        // See if the property page uses a header title
        if (psp.pszHeaderTitle != null)
            psp.dwFlags |= PSP.USEHEADERTITLE;

        // See if the property page uses a header subtitle
        if (psp.pszHeaderSubTitle != null)
            psp.dwFlags |= PSP.USEHEADERSUBTITLE;


        psp.pfnDlgProc=ppage.DialogProc;

        hPage = CreatePropertySheetPage(ref psp);

        // See if we were able to register the property page
        if (hPage == (IntPtr)0)
        {
            MessageBox("Couldn't create the property page", "", 0);
            throw new Exception("Unable to RegisterPropertyPage");
        }
        else
            // Add the page to the property sheet
            lpProvider.AddPage(hPage);
    }// CreateSinglePropertyPage

    internal void FreePropertySheetNotifyHandle()
    {
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        if (m_hPropertyPageRouter != (IntPtr)(-1) && CNodeManager.GoodRouterHandle != m_hPropertyPageRouter)
            callMMCFreeNotifyHandle(m_hPropertyPageRouter);

        m_hPropertyPageRouter = (IntPtr)(-1);
        if(m_fWantToRefreshResult) 
            RefreshResultView();

    }// FreePropertySheetNotifyHandle

    internal void ShowMyPropertyPageIfOpen()
    {
        // We can't do this if the HTML page is refreshing itself
        if (m_fStartResultRefresh)
            m_fWantToMakePropertyPageVisible = true;
        else
        {
            CDO cdo = new CDO(this);
            OpenPropertyPage(DisplayName, cdo, CNodeManager.Data, 1, false);
            m_fWantToMakePropertyPageVisible = false;
        }
    }// ShowMyPropertyPageIfOpen

    internal void OpenMyPropertyPage()
    {
        CDO cdo = new CDO(this);
        OpenPropertyPage(DisplayName, cdo, CNodeManager.Data, 1, true);
    }// OpenMyPropertyPage

    internal void OpenMyResultPropertyPage(String sTitle, CDO cdo)
    {
        OpenPropertyPage(sTitle, cdo, CNodeManager.Component, 0, true);   
    }// OpenMyResultPropertyPage

    private void OpenPropertyPage(String sTitle, CDO cdo, Object o, int nScopeItem, bool fReallyOpen)
    {
        if (CNodeManager.FindPropertyPage(cdo) != HRESULT.S_OK && fReallyOpen)
 
        {
            // Note, doing this stuff will only work if called from the main MMC thread.
            // If it needs to be called from a helper thread or from a property page
            // thread then marshalling should be set up using the framework provided
            // in CNodeManager
            IPropertySheetProvider psp = (IPropertySheetProvider)new NodeManager();

            psp.CreatePropertySheet(sTitle, 1, Cookie, cdo, 0);
            psp.AddPrimaryPages(o, 1, 0, nScopeItem);
            psp.Show(IntPtr.Zero,0);
        }
    }// OpenPropertyPage
    
    protected virtual void CloseAllMyPropertyPages()
    {
        if (m_aPropSheetPage != null)
            m_aPropSheetPage[0].CloseSheet();
    }// CloseAllMyPropertyPages


    //-------------------------------------------------
    // StringToByteArray
    //
    // This function will convert a string to a byte array so
    // it can be sent across the global stream in CDO 
    //-------------------------------------------------
    protected unsafe byte[] StringToByteArray(String input)
    {
        int i;
        int iStrLength = input.Length;

        // Since MMC treats all its strings as unicode, 
        // each character must be 2 bytes long
        byte[] output = new byte[(iStrLength + 1)*2];
        char[] cinput = input.ToCharArray();

        int j=0;
        
        for(i=0; i<iStrLength; i++)
        {
            output[j++] = (byte)cinput[i];
            output[j++] = 0;
        }

        output[j++]=0;
        // For the double null
        output[j]=0;
        
        return output;

     }// StringToByteArray

    protected static String ByteArrayToString(Byte[] b)
    {
        String s = "";
        String sPart;
        if (b != null)
        {
            for(int i=0; i<b.Length; i++)
            {
                sPart = b[i].ToString("X");
                // If the byte was only one character in length, make sure we add
                // a zero. We want all bytes to be 2 characters long
                if (b[i] < 0x10)
                    sPart = "0" + sPart;
                
                s+=sPart;
            }
        }
        return s.ToLower(CultureInfo.InvariantCulture);
    }// ByteArrayToString

    internal int MessageBox(String Message, String Header, uint type)
    {
        return MessageBox(CNodeManager.MMChWnd, Message, Header, type);
    }// MessageBox

    protected void StartWaitCursor()
    {
        // Change to a wait cursor
        // 32514 is IDC_WAIT
        IntPtr hWaitCursor = LoadCursor((IntPtr)0, 32514);
        // Make sure we grab onto the current cursor
        m_hOldCursor = SetCursor(hWaitCursor);
    }// UseWaitIcon
    
    protected void EndWaitCursor()
    {
        SetCursor(m_hOldCursor);
    }// EndWaitIcon

    //-------------------------------------------------
    // We need to import the Win32 API calls used to deal with
    // image loading and messaging.
    //-------------------------------------------------
    [DllImport("comctl32.dll", CharSet=CharSet.Auto)]
    internal static extern IntPtr CreatePropertySheetPage(ref PROPSHEETPAGE psp);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(IntPtr hWnd, String Message, String Header, uint type);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern IntPtr SetClipboardData(uint uFormat, IntPtr hMem);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern IntPtr SetActiveWindow(IntPtr hWnd);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern IntPtr GetActiveWindow();

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern uint GetDialogBaseUnits();

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern uint MapDialogRect(IntPtr hDlg, ref RECT lpRect);

    //-------------------------------------------------
    // Import the functions provided by our native helper-DLL
    //-------------------------------------------------
    [DllImport("mscortim.dll")]
    internal static extern int callMMCFreeNotifyHandle(IntPtr lNotifyHandle);
    [DllImport("mscortim.dll")]
    internal static extern int callMMCPropertyChangeNotify(IntPtr lNotifyHandle, int lparam);
    [DllImport("user32.dll")]
    private static extern IntPtr SetCursor(IntPtr hCursor);
    [DllImport("user32.dll")]
    private static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);


}// class CNode
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\copensecuritypolicydialog.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Windows.Forms;
using System.Drawing;
using System.Collections;
using System.Security;

class COpenSecurityPolicyDialog : Form
{
    RadioButton m_radEnterprise;
    GroupBox m_gbFilename;
    Label m_lblFilename;
    Label m_lblChoosePolHelp;
    RadioButton m_radUser;
    RadioButton m_radMachine;
    GroupBox m_gbPolicyType;
    Button m_btnBrowse;
    Button m_btnCancel;
    TextBox m_txtFilename;
    Button m_btnOK;
    Label m_lblWhichFile;
    RadioButton m_radOpenFile;
    RadioButton m_radOpenDefault;

    String[]    m_sDefaultLocations;
    internal COpenSecurityPolicyDialog(String [] sDefaultPolicyFileLocations)
    {
        m_sDefaultLocations = sDefaultPolicyFileLocations;
        SetupControls();
    }// COpenSecurityPolicyDialog

    internal PolicyLevelType SecPolType
    {
        get
        {
            if (m_radEnterprise.Checked == true)
                return PolicyLevelType.Enterprise;
            else if (m_radMachine.Checked == true)
                return PolicyLevelType.Machine;
            else
                return PolicyLevelType.User;
        }
    }// SecPolType

    internal String Filename
    {
        get
        {
            return m_txtFilename.Text;
        }
    }// Filename

    private void SetupControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(COpenSecurityPolicyDialog));
        this.m_radEnterprise = new System.Windows.Forms.RadioButton();
        this.m_gbFilename = new System.Windows.Forms.GroupBox();
        this.m_lblFilename = new System.Windows.Forms.Label();
        this.m_lblChoosePolHelp = new System.Windows.Forms.Label();
        this.m_radUser = new System.Windows.Forms.RadioButton();
        this.m_btnBrowse = new System.Windows.Forms.Button();
        this.m_radMachine = new System.Windows.Forms.RadioButton();
        this.m_lblWhichFile = new System.Windows.Forms.Label();
        this.m_gbPolicyType = new System.Windows.Forms.GroupBox();
        this.m_radOpenFile = new System.Windows.Forms.RadioButton();
        this.m_btnCancel = new System.Windows.Forms.Button();
        this.m_txtFilename = new System.Windows.Forms.TextBox();
        this.m_radOpenDefault = new System.Windows.Forms.RadioButton();
        this.m_btnOK = new System.Windows.Forms.Button();
        this.m_radEnterprise.Location = ((System.Drawing.Point)(resources.GetObject("m_radEnterprise.Location")));
        this.m_radEnterprise.Size = ((System.Drawing.Size)(resources.GetObject("m_radEnterprise.Size")));
        this.m_radEnterprise.TabIndex = ((int)(resources.GetObject("m_radEnterprise.TabIndex")));
        this.m_radEnterprise.Text = resources.GetString("m_radEnterprise.Text");
        m_radEnterprise.Name = "Enterprise";
        this.m_gbFilename.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_radOpenFile,
                        this.m_radOpenDefault,
                        this.m_lblWhichFile,
                        this.m_btnBrowse,
                        this.m_txtFilename,
                        this.m_lblFilename});
        this.m_gbFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_gbFilename.Location")));
        this.m_gbFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_gbFilename.Size")));
        this.m_gbFilename.TabIndex = ((int)(resources.GetObject("m_gbFilename.TabIndex")));
        this.m_gbFilename.TabStop = false;
        this.m_gbFilename.Text = resources.GetString("m_gbFilename.Text");
        m_gbFilename.Name = "FilenameBox";
        this.m_lblFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_lblFilename.Location")));
        this.m_lblFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_lblFilename.Size")));
        this.m_lblFilename.TabIndex = ((int)(resources.GetObject("m_lblFilename.TabIndex")));
        this.m_lblFilename.Text = resources.GetString("m_lblFilename.Text");
        m_lblFilename.Name = "FilenameLabel";
        this.m_lblChoosePolHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChoosePolHelp.Location")));
        this.m_lblChoosePolHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChoosePolHelp.Size")));
        this.m_lblChoosePolHelp.TabIndex = ((int)(resources.GetObject("m_lblChoosePolHelp.TabIndex")));
        this.m_lblChoosePolHelp.Text = resources.GetString("m_lblChoosePolHelp.Text");
        m_lblChoosePolHelp.Name = "ChoosePolicyHelp";
        this.m_radUser.Location = ((System.Drawing.Point)(resources.GetObject("m_radUser.Location")));
        this.m_radUser.Size = ((System.Drawing.Size)(resources.GetObject("m_radUser.Size")));
        this.m_radUser.TabIndex = ((int)(resources.GetObject("m_radUser.TabIndex")));
        this.m_radUser.Text = resources.GetString("m_radUser.Text");
        m_radUser.Name = "User";
        this.m_btnBrowse.Location = ((System.Drawing.Point)(resources.GetObject("m_btnBrowse.Location")));
        this.m_btnBrowse.Size = ((System.Drawing.Size)(resources.GetObject("m_btnBrowse.Size")));
        this.m_btnBrowse.TabIndex = ((int)(resources.GetObject("m_btnBrowse.TabIndex")));
        this.m_btnBrowse.Text = resources.GetString("m_btnBrowse.Text");
        m_btnBrowse.Name = "Browse";
        this.m_radMachine.Location = ((System.Drawing.Point)(resources.GetObject("m_radMachine.Location")));
        this.m_radMachine.Size = ((System.Drawing.Size)(resources.GetObject("m_radMachine.Size")));
        this.m_radMachine.TabIndex = ((int)(resources.GetObject("m_radMachine.TabIndex")));
        this.m_radMachine.Text = resources.GetString("m_radMachine.Text");
        m_radMachine.Name = "Machine";
        this.m_lblWhichFile.Location = ((System.Drawing.Point)(resources.GetObject("m_lblWhichFile.Location")));
        this.m_lblWhichFile.Size = ((System.Drawing.Size)(resources.GetObject("m_lblWhichFile.Size")));
        this.m_lblWhichFile.TabIndex = ((int)(resources.GetObject("m_lblWhichFile.TabIndex")));
        this.m_lblWhichFile.Text = resources.GetString("m_lblWhichFile.Text");
        m_lblWhichFile.Name = "ChooseFile";
        this.m_gbPolicyType.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_radUser,
                        this.m_radMachine,
                        this.m_radEnterprise,
                        this.m_lblChoosePolHelp});
        this.m_gbPolicyType.Location = ((System.Drawing.Point)(resources.GetObject("m_gbPolicyType.Location")));
        this.m_gbPolicyType.Size = ((System.Drawing.Size)(resources.GetObject("m_gbPolicyType.Size")));
        this.m_gbPolicyType.TabIndex = ((int)(resources.GetObject("m_gbPolicyType.TabIndex")));
        this.m_gbPolicyType.TabStop = false;
        this.m_gbPolicyType.Text = resources.GetString("m_gbPolicyType.Text");
        m_gbPolicyType.Name = "PolicyTypeBox";
        this.m_radOpenFile.Location = ((System.Drawing.Point)(resources.GetObject("m_radOpenFile.Location")));
        this.m_radOpenFile.Size = ((System.Drawing.Size)(resources.GetObject("m_radOpenFile.Size")));
        this.m_radOpenFile.TabIndex = ((int)(resources.GetObject("m_radOpenFile.TabIndex")));
        this.m_radOpenFile.Text = resources.GetString("m_radOpenFile.Text");
        m_radOpenFile.Name = "OpenFile";
        this.m_btnCancel.Location = ((System.Drawing.Point)(resources.GetObject("m_btnCancel.Location")));
        this.m_btnCancel.Size = ((System.Drawing.Size)(resources.GetObject("m_btnCancel.Size")));
        this.m_btnCancel.TabIndex = ((int)(resources.GetObject("m_btnCancel.TabIndex")));
        this.m_btnCancel.Text = resources.GetString("m_btnCancel.Text");
        m_btnCancel.Name = "Cancel";
        this.m_txtFilename.Location = ((System.Drawing.Point)(resources.GetObject("m_txtFilename.Location")));
        this.m_txtFilename.Size = ((System.Drawing.Size)(resources.GetObject("m_txtFilename.Size")));
        this.m_txtFilename.TabIndex = ((int)(resources.GetObject("m_txtFilename.TabIndex")));
        m_txtFilename.Name = "Filename";
        this.m_radOpenDefault.Location = ((System.Drawing.Point)(resources.GetObject("m_radOpenDefault.Location")));
        this.m_radOpenDefault.Size = ((System.Drawing.Size)(resources.GetObject("m_radOpenDefault.Size")));
        this.m_radOpenDefault.TabIndex = ((int)(resources.GetObject("m_radOpenDefault.TabIndex")));
        this.m_radOpenDefault.Text = resources.GetString("m_radOpenDefault.Text");
        m_radOpenDefault.Name = "OpenDefault";
        this.m_btnOK.Location = ((System.Drawing.Point)(resources.GetObject("m_btnOK.Location")));
        this.m_btnOK.Size = ((System.Drawing.Size)(resources.GetObject("m_btnOK.Size")));
        this.m_btnOK.TabIndex = ((int)(resources.GetObject("m_btnOK.TabIndex")));
        this.m_btnOK.Text = resources.GetString("m_btnOK.Text");
        m_btnOK.Name = "OK";
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
        this.Controls.AddRange(new System.Windows.Forms.Control[] {this.m_btnCancel,
                        this.m_btnOK,
                        this.m_gbFilename,
                        this.m_gbPolicyType});
        this.Text = resources.GetString("$this.Text");
        this.MaximizeBox=false;
        this.MinimizeBox=false;
        this.Icon = null;

        // Custom 'tweaks' on these controls

        this.m_txtFilename.TextChanged += new System.EventHandler(onTextChange);
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.CancelButton = m_btnCancel;
        this.AcceptButton = m_btnOK;

		m_btnOK.DialogResult=System.Windows.Forms.DialogResult.OK;
        m_btnCancel.DialogResult = System.Windows.Forms.DialogResult.Cancel;
        m_radOpenDefault.Click += new EventHandler(onSourceChange);
        m_radOpenFile.Click += new EventHandler(onSourceChange);
        m_radEnterprise.Click += new EventHandler(onSourceChange);
        m_radMachine.Click += new EventHandler(onSourceChange);
        m_radUser.Click += new EventHandler(onSourceChange);
        m_btnBrowse.Click += new EventHandler(onBrowse);
        m_radEnterprise.Checked = true;
        m_radOpenFile.Checked = true;
    }// SetupControls


    void onSourceChange(Object o, EventArgs e)
    {
        bool fEnableStuff = true;
        if (m_radOpenDefault.Checked)
        {
            fEnableStuff = false;
            // Figure out what the filename is
            if (m_radEnterprise.Checked)
                m_txtFilename.Text = m_sDefaultLocations[0];
            else if (m_radMachine.Checked)
                m_txtFilename.Text = m_sDefaultLocations[1];
            else // User 
                m_txtFilename.Text = m_sDefaultLocations[2];
                
        }
        else
            fEnableStuff = true;

        m_txtFilename.Enabled = fEnableStuff;
        m_btnBrowse.Enabled = fEnableStuff;
            
    }// onSourceChange

    void onTextChange(Object o, EventArgs e)
    {
        if (m_txtFilename.Text.Length == 0)
            m_btnOK.Enabled=false;
        else
            m_btnOK.Enabled=true;

    }// onTextChange

    void onBrowse(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("COpenSecurityPolicyDialog:FDTitle");
        fd.Filter = CResourceStore.GetString("SecurityPolicyFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
            m_txtFilename.Text = fd.FileName;
    }// onBrowse

}// class COpenSecurityPolicyDialog

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnonunioncgtaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Security.Policy;
using System.Runtime.InteropServices;

class CNonUnionCGTaskPad : CTaskPad
{
    CodeGroup   m_cg;

    internal CNonUnionCGTaskPad(CNode node, CodeGroup cg) : base(node)
    {   
        m_cg = cg;
    }// CNonUnionCGTaskPad

    protected override String GetHTMLFilename()
    {
        return "NONUNIONCODEGROUP_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String [] args = new String[2];
        // The first element should be the name of the code group
        args[0] = (m_cg.Name != null && m_cg.Name.Length > 0)?m_cg.Name:CResourceStore.GetString("Unnamed");

        // The second element should be the description of the code group
        args[1] = m_cg.Description;

        return GetHTMLFile(args);
    }// GetHTMLFile
}// class CNonUnionCGTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnewpermsetwiz2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;
using System.Security;
using System.Security.Permissions;
using System.Net;
using System.DirectoryServices;
using System.Diagnostics;
using System.Drawing.Printing;
using System.ServiceProcess;
using System.Data.SqlClient;
using System.Data.OleDb;
using System.Messaging;
using System.Reflection;


internal class CNewPermSetWiz2 : CWizardPage
{
    // Controls on the page
    private Button m_btnRemove;
    private Label m_lblAvailPermissions;
    private Button m_btnProperties;
    private Button m_btnImport;
    private Button m_btnAdd;
    private ListBox m_lbAvailPerm;
    private ListBox m_lbAssignedPerm;
    private Label m_lblAssignedPerm;

    // Internal data
    ArrayList m_alPermissions;
    ArrayList m_alRemovedPermissions;

    private class PermissionPair
    {
        internal String      sPermName;
        internal IPermission perm;
    }// struct PermissionPair
    
    internal CNewPermSetWiz2()
    {
        Init(null);
    }

    internal CNewPermSetWiz2(IPermission[] perms)
    {
        Init(perms);
    }

    private void Init(IPermission[] perms)
    {
        m_sTitle=CResourceStore.GetString("CNewPermSetWiz2:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CNewPermSetWiz2:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CNewPermSetWiz2:HeaderSubTitle");
        m_alPermissions = new ArrayList();
        m_alRemovedPermissions = new ArrayList();

        // We have permissions we need to add in
        if (perms != null)
        {
            for (int i=0; i<perms.Length; i++)
            {
                PermissionPair pp = new PermissionPair();
                pp.sPermName = Security.GetDisplayStringForPermission(perms[i]);
                pp.perm = perms[i];
                m_alPermissions.Add(pp);
            }
        }

    }// CNewPermSetWiz2
    
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CNewPermSetWiz2));
        this.m_btnRemove = new System.Windows.Forms.Button();
        this.m_lblAvailPermissions = new System.Windows.Forms.Label();
        this.m_btnProperties = new System.Windows.Forms.Button();
        this.m_btnImport = new System.Windows.Forms.Button();
        this.m_btnAdd = new System.Windows.Forms.Button();
        this.m_lbAvailPerm = new System.Windows.Forms.ListBox();
        this.m_lbAssignedPerm = new System.Windows.Forms.ListBox();
        this.m_lblAssignedPerm = new System.Windows.Forms.Label();
        this.m_btnRemove.Location = ((System.Drawing.Point)(resources.GetObject("m_btnRemove.Location")));
        this.m_btnRemove.Size = ((System.Drawing.Size)(resources.GetObject("m_btnRemove.Size")));
        this.m_btnRemove.TabIndex = ((int)(resources.GetObject("m_btnRemove.TabIndex")));
        this.m_btnRemove.Text = resources.GetString("m_btnRemove.Text");
        m_btnRemove.Name = "Remove";
        this.m_lblAvailPermissions.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAvailPermissions.Location")));
        this.m_lblAvailPermissions.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAvailPermissions.Size")));
        this.m_lblAvailPermissions.TabIndex = ((int)(resources.GetObject("m_lblAvailPermissions.TabIndex")));
        this.m_lblAvailPermissions.Text = resources.GetString("m_lblAvailPermissions.Text");
        m_lblAvailPermissions.Name = "AvailablePermissionsLabel";
        this.m_btnProperties.Location = ((System.Drawing.Point)(resources.GetObject("m_btnProperties.Location")));
        this.m_btnProperties.Size = ((System.Drawing.Size)(resources.GetObject("m_btnProperties.Size")));
        this.m_btnProperties.TabIndex = ((int)(resources.GetObject("m_btnProperties.TabIndex")));
        this.m_btnProperties.Text = resources.GetString("m_btnProperties.Text");
        m_btnProperties.Name = "Properties";
        this.m_btnImport.Location = ((System.Drawing.Point)(resources.GetObject("m_btnImport.Location")));
        this.m_btnImport.Size = ((System.Drawing.Size)(resources.GetObject("m_btnImport.Size")));
        this.m_btnImport.TabIndex = ((int)(resources.GetObject("m_btnImport.TabIndex")));
        this.m_btnImport.Text = resources.GetString("m_btnImport.Text");
        m_btnImport.Name = "Import";
        this.m_btnAdd.Location = ((System.Drawing.Point)(resources.GetObject("m_btnAdd.Location")));
        this.m_btnAdd.Size = ((System.Drawing.Size)(resources.GetObject("m_btnAdd.Size")));
        this.m_btnAdd.TabIndex = ((int)(resources.GetObject("m_btnAdd.TabIndex")));
        this.m_btnAdd.Text = resources.GetString("m_btnAdd.Text");
        m_btnAdd.Name = "Add";
        this.m_lbAvailPerm.Location = ((System.Drawing.Point)(resources.GetObject("m_lbAvailPerm.Location")));
        this.m_lbAvailPerm.Size = ((System.Drawing.Size)(resources.GetObject("m_lbAvailPerm.Size")));
        this.m_lbAvailPerm.TabIndex = ((int)(resources.GetObject("m_lbAvailPerm.TabIndex")));
        m_lbAvailPerm.Name = "AvailablePermissions";
        this.m_lbAssignedPerm.Location = ((System.Drawing.Point)(resources.GetObject("m_lbAssignedPerm.Location")));
        this.m_lbAssignedPerm.Size = ((System.Drawing.Size)(resources.GetObject("m_lbAssignedPerm.Size")));
        this.m_lbAssignedPerm.TabIndex = ((int)(resources.GetObject("m_lbAssignedPerm.TabIndex")));
        m_lbAssignedPerm.Name = "AssignedPermissions";
        this.m_lblAssignedPerm.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAssignedPerm.Location")));
        this.m_lblAssignedPerm.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAssignedPerm.Size")));
        this.m_lblAssignedPerm.TabIndex = ((int)(resources.GetObject("m_lblAssignedPerm.TabIndex")));
        this.m_lblAssignedPerm.Text = resources.GetString("m_lblAssignedPerm.Text");
        m_lblAssignedPerm.Name = "AssignedPermissionsLabel";
        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_btnImport,
                        this.m_btnProperties,
                        this.m_btnRemove,
                        this.m_btnAdd,
                        this.m_lblAssignedPerm,
                        this.m_lbAssignedPerm,
                        this.m_lblAvailPermissions,
                        this.m_lbAvailPerm});
        PutValuesinPage();

        m_lbAssignedPerm.DoubleClick += new EventHandler(onPropertiesClick);
        m_lbAvailPerm.DoubleClick += new EventHandler(onAddClick);
        m_btnAdd.Click += new EventHandler(onAddClick);
        m_btnRemove.Click += new EventHandler(onRemoveClick);
        m_btnProperties.Click += new EventHandler(onPropertiesClick);        
        m_btnImport.Click += new EventHandler(onImport);        

        return 1;
    }// InsertPropSheetPageControls

    private void PutValuesinPage()
    {
        // Let's fill the left listbox with all of the standard permissions
        m_lbAvailPerm.Items.Clear();
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Directory Services"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("DNS"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Event Log"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Environment Variables"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("File & Folder"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("File Dialog"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Isolated Storage"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Message Queue"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("OLE DB"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Performance Counter"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Printing"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Registry"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Reflection"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Security"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Service Controller"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Socket Access"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("SQL Client"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Web Access"));
        m_lbAvailPerm.Items.Add(CResourceStore.GetString("Windowing"));

        // Make sure we don't have anything in the 'selected permissions' column
        m_lbAssignedPerm.Items.Clear();
        // Now move our current permissions onto the right side
        for(int i=0; i<m_alPermissions.Count; i++)
        {
            m_lbAssignedPerm.Items.Add(((PermissionPair)m_alPermissions[i]).sPermName);
            // Now remove permissions from this listbox that we already have
            m_lbAvailPerm.Items.Remove(((PermissionPair)m_alPermissions[i]).sPermName);
        }

    }// PutValuesinPage

    void onAddClick(Object o, EventArgs e)
    {
        // See if we have any selected items
        if (m_lbAvailPerm.SelectedIndex >= 0)
        {
            // Create the permission and hold onto it
            PermissionPair pp = new PermissionPair();
            pp.sPermName = (String)m_lbAvailPerm.SelectedItem;
            pp.perm = GetPermission((String)m_lbAvailPerm.SelectedItem, null);
            
            // If they clicked cancel, we'll abort this
            if (pp.perm == null)
                return;
            
            m_alPermissions.Add(pp);

            // Add this permission to the 'assigned permissions' list
            AddPermissionType(m_lbAvailPerm, m_lbAvailPerm.SelectedIndex, m_lbAssignedPerm);


            // Remove this permission from the 'available permissions' list
            m_lbAvailPerm.Items.RemoveAt(m_lbAvailPerm.SelectedIndex);
        }
    }// onAddClick

    void AddPermissionType(ListBox src, int nIndex, ListBox dest)
    {
        // Get the string of the item we want to add
        String sItem = (String)src.Items[nIndex];

        // If we're here, then the item didn't exist in the right listbox. Let's add it in.
        dest.Items.Add(sItem);
    }// AddPermissionType


    void onRemoveClick(Object o, EventArgs e)
    {
        // See if we have any selected items
        if (m_lbAssignedPerm.SelectedIndex >= 0)
        {
            // Add this permission back to the 'available permissions' list
            AddPermissionType(m_lbAssignedPerm, m_lbAssignedPerm.SelectedIndex, m_lbAvailPerm);

            // Now remove this permission from our array list of stuff
            for(int i=0; i<m_alPermissions.Count; i++)
                if (((PermissionPair)m_alPermissions[i]).sPermName.Equals((String)m_lbAssignedPerm.SelectedItem))
                {
                    // Store this permission we're removing
                    m_alRemovedPermissions.Add(m_alPermissions[i]);
                    m_alPermissions.RemoveAt(i);
                }
            // Remove this item from the 'assigned' permission list
            m_lbAssignedPerm.Items.RemoveAt(m_lbAssignedPerm.SelectedIndex);
        }


    }// onRemoveClick

    void onPropertiesClick(Object o, EventArgs e)
    {
        // See if we have any selected items
        if (m_lbAssignedPerm.SelectedIndex >= 0)
        {
            int nIndex=0;
            PermissionPair pp = (PermissionPair)m_alPermissions[nIndex];
            while(!pp.sPermName.Equals((String)m_lbAssignedPerm.SelectedItem))
                pp = (PermissionPair)m_alPermissions[++nIndex];
        
            // Pull up a properties dialog for this permission
            pp.perm = GetPermission((String)m_lbAssignedPerm.SelectedItem, pp.perm);
            m_alPermissions[nIndex] = pp;
        }
    }// onPropertiesClick

    void onImport(Object o, EventArgs e)
    {
        OpenFileDialog fd = new OpenFileDialog();
        fd.Title = CResourceStore.GetString("CNewPermSetWiz2:FDTitle");
        fd.Filter = CResourceStore.GetString("XMLFDMask");
        System.Windows.Forms.DialogResult dr = fd.ShowDialog();
        if (dr == System.Windows.Forms.DialogResult.OK)
        {
            try
            {
                SecurityElement se = SecurityXMLStuff.GetSecurityElementFromXMLFile(fd.FileName);
                if (se == null)
                {
                    throw new Exception("Null Element");
                }
                Type type;
                String className = se.Attribute( "class" );

                if (className == null)
                    throw new Exception("Bad classname");
        
                type = Type.GetType( className );

                IPermission perm = (IPermission)Activator.CreateInstance (type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, new Object[] {PermissionState.None}, null);

                if (perm == null)
                    throw new Exception("Unable to create class");
    
                perm.FromXml(se);
                // We should check to see if this permission is already being stored
                if (CheckForDuplicatePermission(ref perm))
                {
                    PermissionPair pp = new PermissionPair();
                    int nIndexOfPermName = className.LastIndexOf('.');
                    String sPermissionName = className.Substring(nIndexOfPermName + 1);
                   
                    pp.sPermName = sPermissionName;
                    pp.perm = perm;
                    m_alPermissions.Add(pp);
                    m_lbAssignedPerm.Items.Add(pp.sPermName);
                    RemoveThisTypeFromAvailablePermissions(perm);
                }
                
            }
            catch(Exception)
            {
                MessageBox(CResourceStore.GetString("Csinglecodegroupmemcondprop:BadXML"),
                           CResourceStore.GetString("Csinglecodegroupmemcondprop:BadXMLTitle"),
                           MB.ICONEXCLAMATION);
            }
        }
    }// onImport
    
    bool CheckForDuplicatePermission(ref IPermission perm)
    {
        String sItemToAdd = Security.GetDisplayStringForPermission(perm);
    
        // See if we know about this type
        if (sItemToAdd != null)
        {
            for(int i=0; i<m_lbAssignedPerm.Items.Count; i++)
                if (m_lbAssignedPerm.Items[i].Equals(sItemToAdd))
                {
                    // Ok, we're trying to import a permission that we already have selected. Pop
                    // up a dialog box and find out what the user wants to do.
                    CDuplicatePermissionDialog dpd = new CDuplicatePermissionDialog(sItemToAdd);
                    System.Windows.Forms.DialogResult dr = dpd.ShowDialog();
                    if (dr == System.Windows.Forms.DialogResult.OK)
                    {
                        // Get the permission we're after
                        int nIndex=0;
                        PermissionPair pp = (PermissionPair)m_alPermissions[nIndex];
                        while(!pp.sPermName.Equals(sItemToAdd))
                            pp = (PermissionPair)m_alPermissions[++nIndex];

                        if (dpd.Result == CDuplicatePermissionDialog.MERGE)
                            perm = perm.Union(pp.perm);
                        else if (dpd.Result == CDuplicatePermissionDialog.INTERSECT)
                            perm = perm.Intersect(pp.perm);
                        // else, replace... and we don't need to do anything about that
                                                
                        // Now remove the current assigned permission
                        m_alPermissions.RemoveAt(nIndex);
                        m_lbAssignedPerm.Items.RemoveAt(i);
                    }
                    else
                        // We don't want to add this permission after all
                        return false;
                    break;
                }
        }

        // We don't have this permission to worry about
        return true;
    }// CheckForDuplicationPermissions

    void RemoveThisTypeFromAvailablePermissions(IPermission perm)
    {
        String sItemToRemove = Security.GetDisplayStringForPermission(perm);
    
        // See if we know about this type
        if (sItemToRemove != null)
        {
            for(int i=0; i<m_lbAvailPerm.Items.Count; i++)
                if (m_lbAvailPerm.Items[i].Equals(sItemToRemove))
                {
                    m_lbAvailPerm.Items.RemoveAt(i);
                    break;
                }
        }
    }// RemoveThisTypeFromAvailablePermissions
   
    IPermission GetPermission(String sPermissionString, IPermission perm)
    {
        CPermDialog pd=null;
    
        if (sPermissionString.Equals(CResourceStore.GetString("Directory Services")))
            pd = new CDirectoryServicesPermDialog((DirectoryServicesPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("DNS")))
            pd = new CDNSPermDialog((DnsPermission)perm);
        
        else if (sPermissionString.Equals(CResourceStore.GetString("Event Log")))
            pd = new CEventLogPermDialog((EventLogPermission)perm);
        
        else if (sPermissionString.Equals(CResourceStore.GetString("Environment Variables")))
            pd = new CEnvPermDialog((EnvironmentPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("File & Folder")))
            pd = new CFileIOPermDialog((FileIOPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("File Dialog")))
            pd = new CFileDialogPermDialog((FileDialogPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Isolated Storage")))
            pd = new CIsoStoragePermDialog((IsolatedStoragePermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Message Queue")))
            pd = new CMessageQueuePermDialog((MessageQueuePermission)perm);
        
        else if (sPermissionString.Equals(CResourceStore.GetString("Socket Access")))
            pd = new CSocketPermDialog((SocketPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("OLE DB")))
            pd = new COleDbPermDialog((OleDbPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Performance Counter")))
            pd = new CPerformanceCounterPermDialog((PerformanceCounterPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Printing")))
            pd = new CPrintingPermDialog((PrintingPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Registry")))
            pd = new CRegPermDialog((RegistryPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Reflection")))
            pd = new CReflectPermDialog((ReflectionPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Security")))
            pd = new CSecPermDialog((SecurityPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Service Controller")))
            pd = new CServiceControllerPermDialog((ServiceControllerPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("SQL Client")))
            pd = new CSQLClientPermDialog((SqlClientPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Windowing")))
            pd = new CUIPermDialog((UIPermission)perm);

        else if (sPermissionString.Equals(CResourceStore.GetString("Web Access")))
            pd = new CWebPermDialog((WebPermission)perm);

        if (pd == null)
        {
            if (perm == null)
            {
                MessageBox("I don't know how to make this permission", "", 0);
                return null;
            }

            pd = new CCustomPermDialog(perm);
        }

        // If they canceled the box, return the original permission we had
        if (pd.ShowDialog() == DialogResult.Cancel)
            return perm;

        // If they didn't cancel the box, return the permission they just constructed
        return pd.GetPermission();
    }// GetPermission

    internal IPermission[] Permissions
    {
        get
        {
            IPermission[] tmp = new IPermission[m_alPermissions.Count];

            for(int i=0; i<m_alPermissions.Count; i++)
                tmp[i] = ((PermissionPair)m_alPermissions[i]).perm;
        
            return tmp;
        }
    
    }// Permissions

    internal IPermission[] RemovedPermissions
    {
        get
        {
            IPermission[] tmp = new IPermission[m_alRemovedPermissions.Count];

            for(int i=0; i<m_alRemovedPermissions.Count; i++)
                tmp[i] = ((PermissionPair)m_alRemovedPermissions[i]).perm;
        
            return tmp;
        }
    
    }// Permissions

  
}// class CNewPermSetWiz2

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cnodemanager.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CNodeManager.cs
//
// This will be used to manage all the different nodes the
// snapin will be using
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Reflection;

internal class CNodeManager    
{   
    static private CNode[] m_nNodes;            // The nodes used in the snapin
    static private int m_iNumSlots;
    static private int m_iCookieCount;          // Keeps track of cookies
    static private IConsole2 m_ucsole;
    static private IConsole2 m_CConsole;
    static private IConsoleNameSpace2 m_Namespace;
    static private int m_iCookieOfDisplayedNode;
    static private int m_nRootNodeCookie;
    static private CData m_CData;
    static private CComponent m_CComponent;
    static private bool m_fDisplayedTwice;
    static private IntPtr m_hGoodRouterHandle;
    static private IntPtr m_hMMCWnd;
    static private IntPtr m_hMessageWnd;
    static private CNode  m_nodeSelected;

    static private MessageProc m_dlgMessageProc = null;


    private const int WM_USER                = 0x0400;
    private const int WM_NAMESPACEEXPAND     = WM_USER+1;
    private const int WM_INSERTITEM          = WM_USER+2;
    private const int WM_SETITEM             = WM_USER+3;    
    private const int WM_SELECTSCOPEITEM     = WM_USER+4;    
    private const int WM_FINDPROPPAGE        = WM_USER+5; 
    private const int WM_SETCONSOLEICON      = WM_USER+6;
    
    //-------------------------------------------------
    // CNodeManager - Constructor
    //
    // The constructor initializes our node store with the
    // ability to initially store 1 node
    //-------------------------------------------------
    static internal void Init()
    {
        m_nNodes=new CNode[1];
        NullOutArray(ref m_nNodes);
        m_iCookieCount=0;
        m_iNumSlots=1;
        m_fDisplayedTwice = false;

        // We create a hidden window to allow us to communicate with modeless
        // dialogs and other things which run in a seperate thread.

        // I could do all this using Windows.Forms classes, but I don't want to 
        // take the hit loading that module to start
        IntPtr hInst = (IntPtr)Marshal.GetHINSTANCE((Assembly.GetExecutingAssembly().GetLoadedModules())[0]);   

        if (m_dlgMessageProc == null)
            m_dlgMessageProc = new MessageProc(NodeManagerMessageProc);  

        WNDCLASS wc = new WNDCLASS();
        wc.lpfnWndProc   = m_dlgMessageProc;
        wc.hInstance     = hInst;
        wc.lpszClassName = "NodeManagerMessagePump";

        RegisterClass(ref wc);
        m_hMessageWnd = CreateWindowEx(0, "NodeManagerMessagePump", null, 
                                0, 0, 0, 0, 0, IntPtr.Zero, IntPtr.Zero, hInst, IntPtr.Zero);

    }// Init

    //---------------------------------------------------------------------------
    //  This is our hidden window which is just used for handling messages.  We
    //  go to all this trouble so that we don't ever pass interface pointers or
    //  other objects across threads.
    //
    static internal IntPtr NodeManagerMessageProc(IntPtr hWnd, uint uMsg, IntPtr wParam, IntPtr lParam)
    {
        SCOPEDATAITEM sdi;
        switch( uMsg )
        {
            case WM_NAMESPACEEXPAND:
                CNamespace.Expand((int)wParam);
                break;
                
            case WM_INSERTITEM:
                sdi = (SCOPEDATAITEM)Marshal.PtrToStructure(wParam, typeof(SCOPEDATAITEM));
                CNamespace.InsertItem(ref sdi);
                return (IntPtr)sdi.ID;

            case WM_SETITEM:
                sdi = (SCOPEDATAITEM)Marshal.PtrToStructure(wParam, typeof(SCOPEDATAITEM));
                CNamespace.SetItem(ref sdi);
                break;

            case WM_SELECTSCOPEITEM:
                CNodeManager.Console.SelectScopeItem((int)wParam);
                break;   

            case WM_FINDPROPPAGE:
                IPropertySheetProvider psp = (IPropertySheetProvider)new NodeManager();
                CDO cdo = (CDO)Marshal.GetObjectForIUnknown(wParam);
                return (IntPtr)psp.FindPropertySheet(cdo.Node.Cookie, Component, cdo); 

            case WM_SETCONSOLEICON:
                IImageList il=null;
                Console.QueryScopeImageList(out il);
                if (il != null)
                    il.ImageListSetIcon(wParam, (int)lParam);
                break;

       
            default:
                return DefWindowProc( hWnd, uMsg, wParam, lParam );
        }
        return IntPtr.Zero;
    }// NodeManagerMessageProc


    static internal void Shutdown()
    {
        // Run through all our nodes and inform them of the shutdown
        for(int i=0; i<m_nNodes.Length; i++)
            if (m_nNodes[i] != null)
                m_nNodes[i].Shutdown();

        m_nNodes=new CNode[1];
        NullOutArray(ref m_nNodes);
        m_iCookieCount=0;
        m_iNumSlots=1;
        m_fDisplayedTwice = false;  

        if(m_hMessageWnd != IntPtr.Zero)
        {
            DestroyWindow( m_hMessageWnd );
            m_hMessageWnd = IntPtr.Zero;
        }            
        
    }// Shutdown

    static internal void ExpandNodeNamespace(int HScopeItem)
    {
        SendMessage(m_hMessageWnd, WM_NAMESPACEEXPAND, (IntPtr)HScopeItem, IntPtr.Zero);
    }// ExpandNodeNamespace

    static internal int InsertItem(SCOPEDATAITEM sdi)
    {
        // Need to make this a pointer
        IntPtr p = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SCOPEDATAITEM)));
        Marshal.StructureToPtr(sdi, p, false);
    
        int nRet = (int)SendMessage(m_hMessageWnd, WM_INSERTITEM, p, IntPtr.Zero);
        Marshal.FreeHGlobal(p);
        return nRet;
    }// InsertItem

    static internal int SetItem(SCOPEDATAITEM sdi)
    {
        // Need to make this a pointer
        IntPtr p = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(SCOPEDATAITEM)));
        Marshal.StructureToPtr(sdi, p, false);
    
        int nRet = (int)SendMessage(m_hMessageWnd, WM_SETITEM, p, IntPtr.Zero);
        Marshal.FreeHGlobal(p);
        return nRet;
    }// SetItem

    static internal int SelectScopeItem(int hScopeItem)
    {
        // Need to make this a pointer
    
        int nRet = (int)SendMessage(m_hMessageWnd, WM_SELECTSCOPEITEM, (IntPtr)hScopeItem, IntPtr.Zero);
        return nRet;
    }// SelectScopeItem

    static internal int FindPropertyPage(CDO cdo)
    {
        // Need to make this a pointer
        IntPtr pCDO = Marshal.GetIUnknownForObject(cdo);
    
        return (int)SendMessage(m_hMessageWnd, WM_FINDPROPPAGE, pCDO, IntPtr.Zero);
    }// FindPropertyPage

    static internal int ConsoleImageListSetIcon(IntPtr hIcon, int nIndex)
    {
        return SendMessage(m_hMessageWnd, WM_SETCONSOLEICON, hIcon, (IntPtr)nIndex);
    }// ConsoleImageListSetIcon


    //-------------------------------------------------
    // FinishedNodeLoading
    //
    // This function gets called when the tree has finished
    // loading. Hopefully, we're on another thread, so we can
    // start loading assemblies that this snapin might use
    // that haven't already been loaded.
    //-------------------------------------------------
    static internal void FinishedNodeLoading()
    {
        // This is the beefy one. If we don't get any other
        // assembly's loaded besides this one, we're doing good
        Assembly.Load("System.Windows.Forms");
        Assembly.Load("accessibility");
        Assembly.Load("System.Web");
        Assembly.Load("System.Web.RegularExpressions");
    }// FinishedNodeLoading
  
    //-------------------------------------------------
    // Console
    //-------------------------------------------------
    static internal IConsole2 Console
    {
        get
        {
            return m_ucsole;
        }
        set
        {
            m_ucsole=value;
        }
    }// Console

    //-------------------------------------------------
    // Console
    //-------------------------------------------------
    static internal IConsole2 CConsole
    {
        get
        {
            return m_CConsole;
        }
        set
        {
            m_CConsole=value;
        }
    }// Console


    //-------------------------------------------------
    // CData Storage
    //-------------------------------------------------
    static internal CData Data
    {
        get
        {
            return m_CData;
        }
        set
        {
            m_CData=value;
        }
    }// Data

    static internal CComponent Component
    {
        get
        {
            return m_CComponent;
        }
        set
        {
            m_CComponent=value;
        }
    }// Component

    static internal IntPtr MMChWnd
    {
        get
        {
            return m_hMMCWnd;
        }
        set
        {
           m_hMMCWnd = value; 
        }
    }// MMChWnd

    static internal int RootNodeCookie
    {
        get
        {
            return m_nRootNodeCookie;
        }
        set
        {
           m_nRootNodeCookie = value; 
        }
    }// MMChWnd


    static internal CNode SelectedNode
    {
        get{return m_nodeSelected;}
        set{m_nodeSelected = value;}
    }// SelectedNode
    //-------------------------------------------------
    // Namespace
    //-------------------------------------------------
    static internal IConsoleNameSpace2 CNamespace
    {
        get
        {
            return m_Namespace;
        }
        set
        {
            m_Namespace = value;
        }
    }// Namespace

    //-------------------------------------------------
    // DisplayedNode
    //-------------------------------------------------
    static internal CNode DisplayedNode
    {
        get
        {
            return GetNode(m_iCookieOfDisplayedNode);
        }
        set
        {
            if (m_iCookieOfDisplayedNode != value.Cookie)
                m_fDisplayedTwice = false;
            else
                m_fDisplayedTwice = true;
            m_iCookieOfDisplayedNode = value.Cookie;
        }
    }// DisplayedNode

    //-------------------------------------------------
    // ReallyChanged
    //-------------------------------------------------
    static internal bool ReallyChanged
    {
        get
        {
            return !m_fDisplayedTwice;
        }
    }// ReallyChanged

    //-------------------------------------------------
    // GoodRouterHandle
    //-------------------------------------------------
    static internal IntPtr GoodRouterHandle
    {
        get
        {
            return m_hGoodRouterHandle;
        }
        set
        {
            m_hGoodRouterHandle = value;
        }
        
    }// ReallyChanged


        
    //-------------------------------------------------
    // GetNode
    //
    // This function will return a node based on the
    // node's cookie
    //-------------------------------------------------
    static internal CNode GetNode(int iCookie)
    {
        if (iCookie > m_iCookieCount || iCookie<0)
            throw new Exception("Invalid Cookie");   

        return m_nNodes[iCookie];
    }// GetNode

    //-------------------------------------------------
    // GetNodeByHScope
    //
    // This function will return a node based on it's
    // HScopeItem value
    //-------------------------------------------------
    static internal CNode GetNodeByHScope(int iHScope)
    {
        for(int i=0; i<m_iCookieCount; i++)
            if (m_nNodes[i] != null  && m_nNodes[i].HScopeItem == iHScope)
                return m_nNodes[i];
        return null;
    }// GetNodeByHScope

    //-------------------------------------------------
    // GetNodeByTaskPadGroupName
    //
    // This function is called when we need to find the
    // owner of a specific taskpad. This will search
    // through the nodes to find the owner of that taskpad
    //-------------------------------------------------
    static internal CNode GetNodeByTaskPadGroupName(String pszGroup)
    {   
        for(int i=0; i<m_iCookieCount; i++)
            if (m_nNodes[i] != null && m_nNodes[i].HaveThisGroup(pszGroup))
                return m_nNodes[i];
        return null;
    }// GetNodeByTaskPadGroupName

    //-------------------------------------------------
    // GetNodeByDisplayName
    //
    // Still yet another way of getting a node. This time,
    // we will search for the display name
    //-------------------------------------------------
    static internal CNode GetNodeByDisplayName(String sName)
    {
        for(int i=0; i<m_iCookieCount; i++)
            if (m_nNodes[i] != null && sName.Equals(m_nNodes[i].DisplayName))
                return m_nNodes[i];
        return null;
    }// GetNodeByTitle

    //-------------------------------------------------
    // AddNode
    //
    // This function is called when we have created another
    // node and we want that node tracked by our Node Manager
    //-------------------------------------------------
    static internal int AddNode(ref CNode node)
    {
        // See if we have room from our last previous memory
        // allocation to fit in this new node.
        if (m_iNumSlots <= m_iCookieCount)
        {
            // Let's see if there are any other left-over
            // node slots
            int iOpenSpace = FindAvailableNode(m_nNodes);
            if (iOpenSpace != -1)
            {
                m_nNodes[iOpenSpace] = node;
                node.Cookie = iOpenSpace;
                return iOpenSpace;
            }

            // Make our node array larger
            int iNewSlots = m_iNumSlots*2;
            CNode[] newArray = new CNode[iNewSlots];
            NullOutArray(ref newArray);
            for(int i=0; i<m_iNumSlots; i++)
                newArray[i] = m_nNodes[i];
            m_iNumSlots = iNewSlots;
            m_nNodes = newArray;
        }

        // Insert this node in the array
        m_nNodes[m_iCookieCount] = node;
        node.Cookie = m_iCookieCount;
        return m_iCookieCount++;
    }// AddNode

    //-------------------------------------------------
    // RemoveNode
    //
    // This function will remove a node from the internal store
    //-------------------------------------------------
    static internal void RemoveNode(int iNodeNum)
    {
        if (iNodeNum >= m_iNumSlots)
            throw new Exception("Invalid index");

        if (m_nNodes[iNodeNum] == null)
            throw new Exception("Node has already been removed");

        // Whew! Done with the error checking....
        m_nNodes[iNodeNum] = null;
    }// RemoveNode

    //-------------------------------------------------
    // FindAvailableNode
    //
    // This function is called to find an available slot
    // in the array 
    //-------------------------------------------------
    static private int FindAvailableNode(CNode[] slots)
    {
        int iLen = slots.Length;
        for(int i=0; i<iLen; i++)
            if (slots[i] == null)
                return i;
        // We couldn't find an open slot.
        return -1;
    }// FindAvailableNode

    //-------------------------------------------------
    // NullOutArray
    //
    // This function will null out a given array
    //-------------------------------------------------
    static private void NullOutArray(ref CNode[] arr)
    {
        int iLen = arr.Length;

        for(int i=0; i<iLen; i++)
            arr[i]=null;
    }// NullOutArray
    
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern ushort RegisterClass(ref WNDCLASS lpWndClass);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern IntPtr CreateWindowEx(
                                uint dwExStyle,
                                String lpClassName,  // registered class name
                                String lpWindowName, // window name
                                uint dwStyle,        // window style
                                int x,                // horizontal position of window
                                int y,                // vertical position of window
                                int nWidth,           // window width
                                int nHeight,          // window height
                                IntPtr hWndParent,      // handle to parent or owner window
                                IntPtr hMenu,          // menu handle or child identifier
                                IntPtr hInstance,  // handle to application instance
                                IntPtr lpParam        // window-creation data
                               );
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern IntPtr DefWindowProc(IntPtr hWnd,      // handle to window
                                 uint Msg,       // message identifier
                                 IntPtr wParam,  // first message parameter
                                 IntPtr lParam   // second message parameter
                                 );

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern uint DestroyWindow(IntPtr hWnd   // handle to window to destroy
                                            );
    [DllImport("user32.dll")]
    internal static extern int SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    [DllImport("user32.dll")]
    internal static extern int PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);


    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern int MessageBox(int hWnd, String Message, String Header, uint type);

   }// class CNodeManager
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cpermsettaskpad.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Security;

class CPermSetTaskPad : CTaskPad
{
    private bool                m_fReadOnly;

    internal CPermSetTaskPad(CPermissionSet n) : base(n)
    {
        m_fReadOnly = n.ReadOnly;
    }// CPermSetTaskPad

     protected override String GetHTMLFilename()
    {
        return "PERMISSIONSETS_HTML";
    }// GetHTMLFilename

    internal override String GetHTMLFile()
    {
        String[] args = new String[2];
        if (m_fReadOnly)
        {
            args[0] = "<!--";
            args[1] = "-->";
        }

       
        return GetHTMLFile(args);    
    }// GetHTMLFile
}// class CSinglePermSetTaskPad
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\creadonlypermission.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin 
{

using System.Windows.Forms;
using System.Security;
using System.Data;
using System;
using System.Security.Permissions;
using System.Net;
using System.Collections.Specialized;
using System.Collections;
using System.Text.RegularExpressions;
using System.DirectoryServices;
using System.Diagnostics;
using System.Drawing.Printing;
using System.ServiceProcess;
using System.Data.SqlClient;
using System.Data.OleDb;
using System.Messaging;
using System.Drawing;

internal class CReadOnlyPermission : Form 
{
    DataTable   m_dt;
    DataSet     m_ds;
    TextBox m_txtUnrestricted;
    Button m_btnOk;
    MyDataGrid m_dg;
    Label m_lblPermission;
    TextBox m_txtPermission;

    private class ColumnInfo
    {
        internal String   sColName;
        internal int      nColWidth;
        internal ColumnInfo(String ColName, int ColWidth)
        {
            sColName = ColName;
            nColWidth = ColWidth;
        }// ColumnInfo

    }// class ColumnInfo

    private class RowInfo
    {
        internal String[] saData;
        internal RowInfo(String[] sData)
        {
            saData = sData;
        }// RowInfo
    }// class RowInfo
    

    internal CReadOnlyPermission(IPermission perm)
    {
        InitControls(perm);
    }

    private void InitControls(IPermission perm)
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CReadOnlyPermission));
        this.m_txtUnrestricted = new System.Windows.Forms.TextBox();
        this.m_lblPermission = new System.Windows.Forms.Label();
        this.m_btnOk = new System.Windows.Forms.Button();
        this.m_dg = new MyDataGrid();
        this.m_txtPermission = new System.Windows.Forms.TextBox();

        this.m_txtUnrestricted.Location = ((System.Drawing.Point)(resources.GetObject("m_txtUnrestricted.Location")));
        this.m_txtUnrestricted.Size = ((System.Drawing.Size)(resources.GetObject("m_txtUnrestricted.Size")));
        this.m_txtUnrestricted.TabIndex = ((int)(resources.GetObject("m_txtUnrestricted.TabIndex")));
        this.m_txtUnrestricted.Text = resources.GetString("m_txtUnrestricted.Text");
        m_txtUnrestricted.Name = "Unrestricted";
        this.m_lblPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_lblPermission.Location")));
        this.m_lblPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_lblPermission.Size")));
        this.m_lblPermission.TabIndex = ((int)(resources.GetObject("m_lblPermission.TabIndex")));
        this.m_lblPermission.Text = resources.GetString("m_lblPermission.Text");
        m_lblPermission.Name = "PermissionLabel";
        this.m_btnOk.Location = ((System.Drawing.Point)(resources.GetObject("m_btnOk.Location")));
        this.m_btnOk.Size = ((System.Drawing.Size)(resources.GetObject("m_btnOk.Size")));
        this.m_btnOk.TabIndex = ((int)(resources.GetObject("m_btnOk.TabIndex")));
        this.m_btnOk.Text = resources.GetString("m_btnOk.Text");
        m_btnOk.Name = "OK";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        this.m_txtPermission.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_txtPermission.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_txtPermission.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_txtPermission.Name = "Permission";
            
        this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
        this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
        this.Text = resources.GetString("$this.Text");
        this.Icon = null;
        this.Name = "Win32Form1";

           
        // Do some tweaking on the controls
        m_dg.ReadOnly=true;
        m_dg.CaptionVisible=false;
		m_dg.BackgroundColor = Color.White;

        m_txtUnrestricted.Visible = false;
        m_txtUnrestricted.ReadOnly = true;
        m_txtUnrestricted.Multiline = true;
            
        m_txtPermission.Visible = false;
    	m_txtPermission.Multiline = true;
	    m_txtPermission.Visible = false;
	    m_txtPermission.ReadOnly = true;
        m_txtPermission.ScrollBars = ScrollBars.Both;
            
        m_btnOk.DialogResult = System.Windows.Forms.DialogResult.OK;
        this.FormBorderStyle = FormBorderStyle.FixedDialog;
        this.CancelButton = m_btnOk;

        this.Text = CResourceStore.GetString("CReadOnlyPermission:Title");
        this.MaximizeBox=false;
        this.MinimizeBox=false;

            
        this.Controls.Add(m_txtUnrestricted);
        this.Controls.Add(m_lblPermission);
        this.Controls.Add(m_btnOk);
        this.Controls.Add(m_dg);
        this.Controls.Add(m_txtPermission);


        FillInData(perm);

        if (m_txtUnrestricted.Text.Length > 0)
            m_txtUnrestricted.Select(0, 0);
    }
    
    private void FillInData(IPermission perm)
    {
        if (perm is UIPermission)
            DoUIPermission((UIPermission)perm);
       
        else if (perm is SecurityPermission)
            DoSecurityPermission((SecurityPermission)perm);
        
        else if (perm is ReflectionPermission)
            DoReflectionPermission((ReflectionPermission)perm);

        else if (perm is IsolatedStoragePermission)
            DoIsolatedStoragePermission((IsolatedStoragePermission)perm);

        else if (perm is DnsPermission)
            DoDnsPermission((DnsPermission)perm);

        else if (perm is EnvironmentPermission)
            DoEnvironmentPermission((EnvironmentPermission)perm);
            
        else if (perm is FileIOPermission)
            DoFileIOPermission((FileIOPermission)perm);

        else if (perm is RegistryPermission)
            DoRegistryPermission((RegistryPermission)perm);

        else if (perm is SocketPermission)
            DoSocketPermission((SocketPermission)perm);

        else if (perm is WebPermission)
            DoWebPermission((WebPermission)perm);
           
		else if (perm is DirectoryServicesPermission)
            DoDirectoryServicesPermission((DirectoryServicesPermission)perm);
        
        else if (perm is EventLogPermission)
            DoEventLogPermission((EventLogPermission)perm);
       
        else if (perm is FileDialogPermission)
            DoFileDialogPermission((FileDialogPermission)perm);

        else if (perm is MessageQueuePermission)
            DoMessageQueuePermission((MessageQueuePermission)perm);

        else if (perm is OleDbPermission)
            DoOleDbPermission((OleDbPermission)perm);

        else if (perm is PerformanceCounterPermission)
            DoPerformanceCounterPermission((PerformanceCounterPermission)perm);
    
		else if (perm is PrintingPermission)
            DoPrintingPermission((PrintingPermission)perm);
        
		else if (perm is ServiceControllerPermission)
            DoServiceControllerPermission((ServiceControllerPermission)perm);

		else if (perm is SqlClientPermission)
            DoSqlClientPermission((SqlClientPermission)perm);


        else
            DoCustomPermission(perm);    
    }// FillInData

    void DoCustomPermission(IPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:CustomPermission");
    
        if ((perm is IUnrestrictedPermission) && (((IUnrestrictedPermission)perm).IsUnrestricted()))
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedCustomPermission");
        }
        else
        {
            m_dg.Visible = false;
            m_txtPermission.Visible = true;
            m_txtPermission.Text = perm.ToXml().ToString();
            m_txtPermission.Select(0,0);
        }
        

    }// DoCustomPermission

    void DoWebPermission(WebPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:WebPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedWebPermission");
        }
        else
        {

            ColumnInfo[] cols = new ColumnInfo[3];
            cols[0] = new ColumnInfo(CResourceStore.GetString("WebPermission:Hostname"), CResourceStore.GetInt("CReadOnlyPermission:WebPermHostNameWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("WebPermission:Accept"), CResourceStore.GetInt("CReadOnlyPermission:WebPermAcceptWidth"));
            cols[2] = new ColumnInfo(CResourceStore.GetString("WebPermission:Connect"), CResourceStore.GetInt("CReadOnlyPermission:WebPermConnectWidth"));

            ArrayList al = new ArrayList();
            RowInfo row = null;
            String sYes = CResourceStore.GetString("Yes");
            String sNo = CResourceStore.GetString("No");
            
    
            // Run through the list of web permissions we have to accept connections
            IEnumerator enumer = perm.AcceptList;
            while (enumer.MoveNext())
            {
                String sHost;
                
                if (enumer.Current is Regex)
                    sHost = ((Regex)enumer.Current).ToString();
                else
                    sHost = (String)enumer.Current;

                row = new RowInfo(new String[] {sHost, 
                                                sYes,
                                                sNo});
                al.Add(row);
            }
            
            // Run through the list of web permissions we have to connect through
            enumer = perm.ConnectList;
            while (enumer.MoveNext())
            {
                String sHost;
                
                if (enumer.Current is Regex)
                    sHost = ((Regex)enumer.Current).ToString();
                else
                    sHost = (String)enumer.Current;

                // Check to see if this already exists in our table
                int i;
                for(i=0; i<al.Count; i++)
                    if (((RowInfo)al[i]).saData[0].Equals(sHost))
                    {
                        ((RowInfo)al[i]).saData[2] = sYes;
                        break;
                    }

                // If we didn't have a match, make a new row
                if (i == al.Count)
                {
                    row = new RowInfo(new String[] {sHost, 
                                                sNo,
                                                sYes});
                    al.Add(row);
                }
            }


            // Now change our Array List to an Array
            RowInfo[] rows = new RowInfo[al.Count];
            for(int i=0; i<al.Count; i++)
                rows[i] = (RowInfo)al[i];
                
            CreateTable(cols, rows);
        }
    }// DoWebPermission


    void DoSocketPermission(SocketPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:SocketPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedSocketPermission");
        }
        else
        {

            ColumnInfo[] cols = new ColumnInfo[5];
            cols[0] = new ColumnInfo(CResourceStore.GetString("SocketPermission:Hostname"), CResourceStore.GetInt("CReadOnlyPermission:SocketPermHostNameWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("SocketPermission:Port"), CResourceStore.GetInt("CReadOnlyPermission:SocketPermPortWidth"));
            cols[2] = new ColumnInfo(CResourceStore.GetString("SocketPermission:Direction"), CResourceStore.GetInt("CReadOnlyPermission:SocketPermDirectionWidth"));
            cols[3] = new ColumnInfo(CResourceStore.GetString("SocketPermission:TCP"), CResourceStore.GetInt("CReadOnlyPermission:SocketPermTCPWidth"));
            cols[4] = new ColumnInfo(CResourceStore.GetString("SocketPermission:UDP"), CResourceStore.GetInt("CReadOnlyPermission:SocketPermUDPWidth"));

            ArrayList al = new ArrayList();
            RowInfo row = null;
            String sYes = CResourceStore.GetString("Yes");
            String sNo = CResourceStore.GetString("No");
            
    
            // Run through the list of socket permissions we have to accept connections
            IEnumerator enumer = perm.AcceptList;
            while (enumer.MoveNext())
            {
                EndpointPermission epp = (EndpointPermission)enumer.Current;
                row = new RowInfo(new String[] {epp.Hostname, 
                                                epp.Port.ToString(),
                                                CResourceStore.GetString("SocketPermission:Accept"),
                                                ((epp.Transport&TransportType.Tcp) == TransportType.Tcp)?sYes:sNo,
                                                ((epp.Transport&TransportType.Udp) == TransportType.Udp)?sYes:sNo});
                al.Add(row);
            }
            
            // Run through the list of socket permissions we have to connect through

            enumer = perm.ConnectList;
            while (enumer.MoveNext())
            {
                EndpointPermission epp = (EndpointPermission)enumer.Current;
                row = new RowInfo(new String[] {epp.Hostname, 
                                                epp.Port.ToString(),
                                                CResourceStore.GetString("SocketPermission:Connect"),
                                                ((epp.Transport&TransportType.Tcp) == TransportType.Tcp)?sYes:sNo,
                                                ((epp.Transport&TransportType.Udp) == TransportType.Udp)?sYes:sNo});
                al.Add(row);
            }


            // Now change our Array List to an Array
            RowInfo[] rows = new RowInfo[al.Count];
            for(int i=0; i<al.Count; i++)
                rows[i] = (RowInfo)al[i];
                
            CreateTable(cols, rows);
        }
    }// DoSocketPermission

	void DoDirectoryServicesPermission(DirectoryServicesPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:DirectoryServicesPermission");
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedDirectoryServicesPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("DirectoryServicesPermission:Path"), CResourceStore.GetInt("CReadOnlyPermission:DirectServPermPathWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("DirectoryServicesPermission:Access"), CResourceStore.GetInt("CReadOnlyPermission:DirectServPermAccessWidth"));

			RowInfo[] rows = new RowInfo[perm.PermissionEntries.Count];
			
			for(int i=0; i<perm.PermissionEntries.Count; i++)
			{
				rows[i] = new RowInfo(new String[] {perm.PermissionEntries[i].Path,
												  perm.PermissionEntries[i].PermissionAccess.ToString()});
			}

            CreateTable(cols, rows);

		}
	}// DoDirectoryServicesPermission

	void DoEventLogPermission(EventLogPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:EventLogPermission");
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedEventLogPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("EventLogPermission:Machine"), CResourceStore.GetInt("CReadOnlyPermission:EventLogPermMachineWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("EventLogPermission:Access"), CResourceStore.GetInt("CReadOnlyPermission:EventLogPermAccessWidth"));

			RowInfo[] rows = new RowInfo[perm.PermissionEntries.Count];
			
			for(int i=0; i<perm.PermissionEntries.Count; i++)
			{
				String sAccessString = "";
				EventLogPermissionAccess elpa = perm.PermissionEntries[i].PermissionAccess;
				if ((elpa&EventLogPermissionAccess.Instrument) == EventLogPermissionAccess.Instrument)
					sAccessString = CResourceStore.GetString("EventLogPermission:Instrument");
				if ((elpa&EventLogPermissionAccess.Audit) == EventLogPermissionAccess.Audit)
					sAccessString += (sAccessString.Length>0?"/":"") + CResourceStore.GetString("EventLogPermission:Audit");
				// If we haven't had anything yet...
				if (sAccessString.Length==0)
				{
					if ((elpa&EventLogPermissionAccess.Browse) == EventLogPermissionAccess.Browse)
						sAccessString = CResourceStore.GetString("EventLogPermission:Browse");
					else
						sAccessString = CResourceStore.GetString("None");
				}
			
				rows[i] = new RowInfo(new String[] {perm.PermissionEntries[i].MachineName,
												  sAccessString});
			}

            CreateTable(cols, rows);

		}
	}// DoEventLogPermission


	void DoPerformanceCounterPermission(PerformanceCounterPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:PerformanceCounterPermission");
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedPerformanceCounterPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[3];
            cols[0] = new ColumnInfo(CResourceStore.GetString("PerformanceCounterPermission:Machine"), CResourceStore.GetInt("CReadOnlyPermission:PerfCounterPermMachineWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("PerformanceCounterPermission:Category"), CResourceStore.GetInt("CReadOnlyPermission:PerfCounterPermCategoryWidth"));
            cols[2] = new ColumnInfo(CResourceStore.GetString("PerformanceCounterPermission:Access"), CResourceStore.GetInt("CReadOnlyPermission:PerfCounterPermAccessWidth"));


			RowInfo[] rows = new RowInfo[perm.PermissionEntries.Count];
			
			for(int i=0; i<perm.PermissionEntries.Count; i++)
			{
				String sName = perm.PermissionEntries[i].MachineName;
				String sCategory = perm.PermissionEntries[i].CategoryName;
							
			
				String sAccessString = "";
				PerformanceCounterPermissionAccess pcpa = perm.PermissionEntries[i].PermissionAccess;
				// Determine the Access String
				if ((pcpa&PerformanceCounterPermissionAccess.Administer) == PerformanceCounterPermissionAccess.Administer)
					sAccessString = CResourceStore.GetString("PerformanceCounterPermission:Administer");
				else if ((pcpa&PerformanceCounterPermissionAccess.Instrument) == PerformanceCounterPermissionAccess.Instrument)
					sAccessString = CResourceStore.GetString("PerformanceCounterPermission:Instrument");
				else if ((pcpa&PerformanceCounterPermissionAccess.Browse) == PerformanceCounterPermissionAccess.Browse)
					sAccessString = CResourceStore.GetString("PerformanceCounterPermission:Browse");
				else 
					sAccessString = CResourceStore.GetString("None");
		
				rows[i] = new RowInfo(new String[] {sName,
												 sCategory,
												  sAccessString});
			}

            CreateTable(cols, rows);

		}
	
	}// DoPerformanceCounterPermission
	
	void DoServiceControllerPermission(ServiceControllerPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:ServiceControllerPermission");
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedServiceControllerPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[3];
            cols[0] = new ColumnInfo(CResourceStore.GetString("ServiceControllerPermission:Machine"), CResourceStore.GetInt("CReadOnlyPermission:ServControlPermMachineWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("ServiceControllerPermission:Service"), CResourceStore.GetInt("CReadOnlyPermission:ServControlPermServiceWidth"));
            cols[2] = new ColumnInfo(CResourceStore.GetString("ServiceControllerPermission:Access"), CResourceStore.GetInt("CReadOnlyPermission:ServControlPermAccessWidth"));


			RowInfo[] rows = new RowInfo[perm.PermissionEntries.Count];
			
			for(int i=0; i<perm.PermissionEntries.Count; i++)
			{
				String sName = perm.PermissionEntries[i].MachineName;
				String sService = perm.PermissionEntries[i].ServiceName;
							
			
				String sAccessString = "";
				ServiceControllerPermissionAccess scpa = perm.PermissionEntries[i].PermissionAccess;

				// Determine the Access String
				if ((scpa&ServiceControllerPermissionAccess.Control) == ServiceControllerPermissionAccess.Control)
					sAccessString = CResourceStore.GetString("ServiceControllerPermission:Control");
				else if ((scpa&ServiceControllerPermissionAccess.Browse) == ServiceControllerPermissionAccess.Browse)
					sAccessString = CResourceStore.GetString("ServiceControllerPermission:Browse");
				else 
					sAccessString = CResourceStore.GetString("None");
		
				rows[i] = new RowInfo(new String[] {sName,
												 sService,
												  sAccessString});
			}

            CreateTable(cols, rows);

		}
	}// DoServiceControllerPermission

    void DoMessageQueuePermission(MessageQueuePermission perm)
    {
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:MessageQueuePermission");
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedMessageQueuePermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("MessageQueuePermission:Conditions"), CResourceStore.GetInt("CReadOnlyPermission:MQPermConditionsWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("MessageQueuePermission:Access"), CResourceStore.GetInt("CReadOnlyPermission:MQPermAccessWidth"));


			RowInfo[] rows = new RowInfo[perm.PermissionEntries.Count];
			
			for(int i=0; i<perm.PermissionEntries.Count; i++)
			{
				String sName = perm.PermissionEntries[i].MachineName;
				String sCategory = perm.PermissionEntries[i].Category;
				String sLabel = perm.PermissionEntries[i].Label;
				String sPath = perm.PermissionEntries[i].Path;

                // Make sure we don't have any nulls....
                String[] sConditions = new String[4];
                sConditions[0] = (sName==null|| sName.Length == 0 )?"":CResourceStore.GetString("MessageQueuePermission:MachineName") + " = " + sName;
                sConditions[1] = (sCategory==null || sCategory.Length == 0)?"":CResourceStore.GetString("MessageQueuePermission:Category") + " = " + sCategory;
                sConditions[2] = (sLabel==null || sLabel.Length == 0)?"":CResourceStore.GetString("MessageQueuePermission:Label") + " = " + sLabel;
                sConditions[3] = (sPath==null || sPath.Length == 0)?"":CResourceStore.GetString("MessageQueuePermission:Path") + " = " + sPath;

                String sCondition = "";
                for(int j=0; j<4; j++)
                {   
                    // See if we're going to add this Condition
                    if (sConditions[j].Length > 0)
                    {
                        // If we already have a string, let's add a "," to seperate the items
                        if (sCondition.Length > 0)
                            sCondition+=", ";
                        
                        sCondition+=sConditions[j];
                    }
                }
                			
				MessageQueuePermissionAccess mqpa = perm.PermissionEntries[i].PermissionAccess;

				// Determine the Access String
                String sAccess = CResourceStore.GetString("None");

                if ((mqpa&MessageQueuePermissionAccess.Administer) == MessageQueuePermissionAccess.Administer)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Administer");
                else if ((mqpa&MessageQueuePermissionAccess.Receive) == MessageQueuePermissionAccess.Receive)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Receive");
                else if ((mqpa&MessageQueuePermissionAccess.Peek) == MessageQueuePermissionAccess.Peek)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Peek");
                else if ((mqpa&MessageQueuePermissionAccess.Send) == MessageQueuePermissionAccess.Send)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Send");
                else if ((mqpa&MessageQueuePermissionAccess.Browse) == MessageQueuePermissionAccess.Browse)
                    sAccess = CResourceStore.GetString("MessageQueuePermission:Browse");
               	
				rows[i] = new RowInfo(new String[] {sCondition, sAccess});
			}

            CreateTable(cols, rows);

		}


    }// DoMessageQueuePermission

        
    void DoRegistryPermission(RegistryPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:RegistryPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedRegistryPermission");
        }
        else
        {
            StringCollection scReadKeys = new StringCollection();
            StringCollection scWriteKeys = new StringCollection();
            StringCollection scCreateKeys = new StringCollection();
            StringCollection scRWKeys = new StringCollection();
            StringCollection scRCKeys = new StringCollection();
            StringCollection scWCKeys = new StringCollection();
            StringCollection scRWCKeys = new StringCollection();
    
            // Get the paths the user has access to
            String ReadPathList = perm.GetPathList(RegistryPermissionAccess.Read);
            String WritePathList = perm.GetPathList(RegistryPermissionAccess.Write);
            String CreatePathList = perm.GetPathList(RegistryPermissionAccess.Create);
            if(ReadPathList != null) scReadKeys.AddRange(ReadPathList.Split(new char[] {';'}));
            if(WritePathList != null) scWriteKeys.AddRange(WritePathList.Split(new char[] {';'}));
            if(CreatePathList != null) scCreateKeys.AddRange(CreatePathList.Split(new char[] {';'}));

            // Careful with the order of these calls... make sure the final IntersectAllCollections
            // is the last function to get called. Also, make sure each of the base
            // string collections (Read, Write, and Append) all are the 1st argument in the
            // IntersectCollections call at least once, to clean up any "" that might be floating around
            scRWKeys = PathListFunctions.CondIntersectCollections(ref scReadKeys, ref scWriteKeys, ref scCreateKeys);
            scRCKeys = PathListFunctions.CondIntersectCollections(ref scCreateKeys, ref scReadKeys,  ref scWriteKeys);
            scWCKeys = PathListFunctions.CondIntersectCollections(ref scWriteKeys, ref scCreateKeys, ref scReadKeys);
            scRWCKeys = PathListFunctions.IntersectAllCollections(ref scReadKeys, ref scWriteKeys, ref scCreateKeys);

            // Now we have 7 different combinations we have to run through
            String[] sFilePaths = new String[] {
                                                PathListFunctions.JoinStringCollection(scReadKeys),
                                                PathListFunctions.JoinStringCollection(scWriteKeys),
                                                PathListFunctions.JoinStringCollection(scCreateKeys),
                                                PathListFunctions.JoinStringCollection(scRWKeys),
                                                PathListFunctions.JoinStringCollection(scRCKeys),
                                                PathListFunctions.JoinStringCollection(scWCKeys),
                                                PathListFunctions.JoinStringCollection(scRWCKeys)
                                                };

            String[] sPermissionString = new String[]
                                                {
                                                CResourceStore.GetString("RegistryPermission:Read"),
                                                CResourceStore.GetString("RegistryPermission:Write"),
                                                CResourceStore.GetString("RegistryPermission:Create"),
                                                CResourceStore.GetString("RegistryPermission:Read/Write"),
                                                CResourceStore.GetString("RegistryPermission:Read/Create"),
                                                CResourceStore.GetString("RegistryPermission:Write/Create"),
                                                CResourceStore.GetString("RegistryPermission:Read/Write/Create")};

            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("RegistryPermission:RegistryKey"), CResourceStore.GetInt("CReadOnlyPermission:RegPermRegKeyWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("RegistryPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:RegPermGrantedWidth"));


            // Count the number of rows we have
            int nNumRows = 0;
            for(int i=0; i<7; i++)
                if (sFilePaths[i].Length > 0)
                    nNumRows++;

            
            RowInfo[] rows = new RowInfo[nNumRows];
            int nRowNum=0;
            
            // Ok, let's add these items to our grid
            for(int i=0; i<7; i++)
                if (sFilePaths[i].Length > 0)
                    rows[nRowNum++] = new RowInfo(new String[] {sFilePaths[i], sPermissionString[i]});

            
            CreateTable(cols, rows);
        }

    }// DoRegistryPermission


    void DoFileIOPermission(FileIOPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:FileIOPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedFileIOPermission");
        }
        else
        {
            ArrayList alFiles = new ArrayList();

            CFileIOPermControls.AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.Read), FILEPERMS.READ);
            CFileIOPermControls.AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.Write), FILEPERMS.WRITE);
            CFileIOPermControls.AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.Append), FILEPERMS.APPEND);
            CFileIOPermControls.AddFiles(alFiles, perm.GetPathList(FileIOPermissionAccess.PathDiscovery), FILEPERMS.PDISC);
            

            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("FileIOPermission:FilePath"), CResourceStore.GetInt("CReadOnlyPermission:FileIOPermFilePathWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("FileIOPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:FileIOPermGrantedWidth"));


           
            RowInfo[] rows = new RowInfo[alFiles.Count];
            
            // Ok, let's add these items to our grid
            for(int i=0; i<alFiles.Count; i++)
                rows[i] = new RowInfo(new String[] {((FilePermInfo)alFiles[i]).sPath, 
                                                    ((FilePermInfo)alFiles[i]).GetPermissionString()});

            
            CreateTable(cols, rows);
        }

    }// DoFileIOPermission



    void DoEnvironmentPermission(EnvironmentPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:EnvironmentPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedEnvironmentPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("EnvironmentPermission:Variable"), CResourceStore.GetInt("CReadOnlyPermission:EnvPermVariableWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("EnvironmentPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:EnvPermGrantedWidth"));


            StringCollection scReadVars = new StringCollection();
            StringCollection scWriteVars = new StringCollection();
            StringCollection scAllVars = new StringCollection();
    
            // Get the environment variables the user has access to
            String sReads = perm.GetPathList(EnvironmentPermissionAccess.Read);
            if (sReads != null && sReads.Length > 0)
                scReadVars.AddRange(sReads.Split(new char[] {';'}));

            String sWrites = perm.GetPathList(EnvironmentPermissionAccess.Write);
            if (sWrites != null && sWrites.Length > 0)
                scWriteVars.AddRange(sWrites.Split(new char[] {';'})); 

            // Intersect these to find those variables that can be both read and written
            scAllVars = PathListFunctions.IntersectCollections(ref scReadVars, ref scWriteVars);

            StringCollection[] scCollections = new StringCollection[] {scReadVars, scWriteVars, scAllVars};

            // Figure out the number of rows we have
            int nNumRows = scCollections[0].Count + scCollections[1].Count + scCollections[2].Count; 
            String[] sPermString = new String[] {CResourceStore.GetString("EnvironmentPermission:Read"),
                                                 CResourceStore.GetString("EnvironmentPermission:Write"),
                                                 CResourceStore.GetString("EnvironmentPermission:Read/Write")};

            RowInfo[] rows = new RowInfo[nNumRows];
            int nRowNum=0;
            
            // Ok, let's add these items to our grid
            for(int i=0; i<scCollections.Length; i++)
                for(int j=0; j<scCollections[i].Count; j++)
                    rows[nRowNum++] = new RowInfo(new String[] {scCollections[i][j], sPermString[i]});

            
            CreateTable(cols, rows);

        }
    }// DoEnvironmentPermission



    void DoDnsPermission(DnsPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:DNSPermission");

        ColumnInfo[] cols = new ColumnInfo[2];
        cols[0] = new ColumnInfo(CResourceStore.GetString("Permission"), CResourceStore.GetInt("CReadOnlyPermission:DnsPermPermissionWidth"));
        cols[1] = new ColumnInfo(CResourceStore.GetString("DNSPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:DnsPermGrantedWidth"));

        RowInfo[] rows = new RowInfo[1];

        rows[0] = new RowInfo(new String[] {CResourceStore.GetString("DNS"),
                                            perm.IsUnrestricted()?CResourceStore.GetString("Yes"):CResourceStore.GetString("No")});


        CreateTable(cols, rows);


    }// DoDnsPermission

	void DoFileDialogPermission(FileDialogPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:FileDialogPermission");

        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedFileDialogPermission");
        }
        else
        {
			ColumnInfo[] cols = new ColumnInfo[1];
        	cols[0] = new ColumnInfo(CResourceStore.GetString("FileDialogPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:FileDlgPermGrantedWidth"));

        	RowInfo[] rows = new RowInfo[1];

			String sAccessString = CResourceStore.GetString("None");
			
			if ((perm.Access&FileDialogPermissionAccess.Open) == FileDialogPermissionAccess.Open)
				sAccessString = CResourceStore.GetString("FileDialogPermission:Open");
			else if ((perm.Access&FileDialogPermissionAccess.Save) == FileDialogPermissionAccess.Save)
				sAccessString = CResourceStore.GetString("FileDialogPermission:Save");
			else if ((perm.Access&FileDialogPermissionAccess.OpenSave) == FileDialogPermissionAccess.OpenSave)
				sAccessString = CResourceStore.GetString("FileDialogPermission:OpenandSave");
		

        	rows[0] = new RowInfo(new String[] {sAccessString});


        	CreateTable(cols, rows);
		}
	}// DoFileDialogPermission

	void DoPrintingPermission(PrintingPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:PrintingPermission");

        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedPrintingPermission");
        }
        else
        {
			ColumnInfo[] cols = new ColumnInfo[1];
        	cols[0] = new ColumnInfo(CResourceStore.GetString("PrintingPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:PrintingPermGrantedWidth"));

        	RowInfo[] rows = new RowInfo[1];

			String sAccessString = CResourceStore.GetString("None");
			
			if ((perm.Level&PrintingPermissionLevel.AllPrinting) == PrintingPermissionLevel.AllPrinting)
				sAccessString = CResourceStore.GetString("PrintingPermission:AllPrinting");
			else if ((perm.Level&PrintingPermissionLevel.DefaultPrinting) == PrintingPermissionLevel.DefaultPrinting)
				sAccessString = CResourceStore.GetString("PrintingPermission:DefaultPrinting");
			else if ((perm.Level&PrintingPermissionLevel.SafePrinting) == PrintingPermissionLevel.SafePrinting)
				sAccessString = CResourceStore.GetString("PrintingPermission:SafePrinting");
			else
				sAccessString = CResourceStore.GetString("PrintingPermission:NoPrinting");
		

        	rows[0] = new RowInfo(new String[] {sAccessString});


        	CreateTable(cols, rows);
		}
	
	}// DoPrintingPermission


	void DoSqlClientPermission(SqlClientPermission perm)
	{
		m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:SQLClientPermission");

        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedSQLClientPermission");
        }
        else
        {
			ColumnInfo[] cols = new ColumnInfo[1];
        	cols[0] = new ColumnInfo(CResourceStore.GetString("SQLClientPermission:AllowEmptyPasswords"), CResourceStore.GetInt("CReadOnlyPermission:SQLClientPermAllowEmptyPassWidth"));

        	RowInfo[] rows = new RowInfo[1];

			String sAccessString = perm.AllowBlankPassword?CResourceStore.GetString("Yes"):CResourceStore.GetString("No");

        	rows[0] = new RowInfo(new String[] {sAccessString});

        	CreateTable(cols, rows);
		}

	
	}// DoSqlClientPermission


    void DoIsolatedStoragePermission(IsolatedStoragePermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:IsolatedStorageFilePermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedIsolatedStorageFilePermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("IsolatedStorageFilePermission:Permission"), CResourceStore.GetInt("CReadOnlyPermission:IsoFilePermWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("IsolatedStorageFilePermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:IsoFilePermGrantedWidth"));

            RowInfo[] rows = new RowInfo[2];

            String sUsageAllowedString = CResourceStore.GetString("IsolatedStorageFilePermission:Unknown");

            if (perm.UsageAllowed == IsolatedStorageContainment.AdministerIsolatedStorageByUser)
                sUsageAllowedString = CResourceStore.GetString("IsolatedStorageFilePermission:AdministerIsolatedStorageByUser");
            else if (perm.UsageAllowed == IsolatedStorageContainment.AssemblyIsolationByUser)
                sUsageAllowedString = CResourceStore.GetString("IsolatedStorageFilePermission:AssemblyIsolatationByUser");
            else if (perm.UsageAllowed == IsolatedStorageContainment.AssemblyIsolationByRoamingUser)
                sUsageAllowedString = CResourceStore.GetString("IsolatedStorageFilePermission:AssemblyIsolatationByUserRoam");
            else if (perm.UsageAllowed == IsolatedStorageContainment.DomainIsolationByUser)
                sUsageAllowedString = CResourceStore.GetString("IsolatedStorageFilePermission:DomainIsolatationByUser");
            else if (perm.UsageAllowed == IsolatedStorageContainment.DomainIsolationByRoamingUser)
                sUsageAllowedString = CResourceStore.GetString("IsolatedStorageFilePermission:DomainIsolatationByUserRoam");
            else if (perm.UsageAllowed == IsolatedStorageContainment.None)
                sUsageAllowedString = CResourceStore.GetString("None");


            rows[0] = new RowInfo(new String[] {CResourceStore.GetString("IsolatedStorageFilePermission:UsageAllowed"),
                                                sUsageAllowedString});

            rows[1] = new RowInfo(new String[] {CResourceStore.GetString("IsolatedStorageFilePermission:DiskQuota"),
                                                perm.UserQuota.ToString()});

            CreateTable(cols, rows);
        }

    }// DoIsolatedStoragePermission

    void DoReflectionPermission(ReflectionPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:ReflectionPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedReflectionPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("ReflectionPermission:Permission"), CResourceStore.GetInt("CReadOnlyPermission:ReflectionPermWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("ReflectionPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:ReflectionPermGrantedWidth"));

            RowInfo[] rows = new RowInfo[3];
            String sYes = CResourceStore.GetString("Yes");
            String sNo = CResourceStore.GetString("No");

            rows[0] = new RowInfo(new String[] {CResourceStore.GetString("ReflectionPermission:MemberAccess"),
                                           ((perm.Flags & ReflectionPermissionFlag.MemberAccess) > 0)?sYes:sNo});

            rows[1] = new RowInfo(new String[] {CResourceStore.GetString("ReflectionPermission:TypeInformation"),
                                           ((perm.Flags & ReflectionPermissionFlag.TypeInformation) > 0)?sYes:sNo});

            rows[2] = new RowInfo(new String[] {CResourceStore.GetString("ReflectionPermission:ReflectionEmit"),
                                           ((perm.Flags & ReflectionPermissionFlag.ReflectionEmit) > 0)?sYes:sNo});


            CreateTable(cols, rows);

        }
    }// DoReflectionPermission

    void DoOleDbPermission(OleDbPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:OleDBPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedOleDBPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("OleDBPermission:Setting"), CResourceStore.GetInt("CReadOnlyPermission:OleDBPermSettingWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("OleDBPermission:Value"), CResourceStore.GetInt("CReadOnlyPermission:OleDBPermValueWidth"));


            // Find out how many providers we have
            String[] sProviders = perm.Provider.Split(new char[] {';'});

            // We need a row for each provider plus a row for the 'Providers' title plus
            // a row to tell if we're allowing blank passwords
            RowInfo[] rows = new RowInfo[sProviders.Length+2];

            rows[0] = new RowInfo(new String[] {CResourceStore.GetString("OleDBPermission:AllowBlankpasswords"),
                                                perm.AllowBlankPassword?CResourceStore.GetString("Yes"):CResourceStore.GetString("No")});
                                                
            rows[1] = new RowInfo(new String[] {CResourceStore.GetString("OleDBPermission:Providers:"), ""});

            // Add in the providers
            for(int i=2; i< rows.Length; i++)
                rows[i] = new RowInfo(new String[] {sProviders[i-2], ""});

            CreateTable(cols, rows);
        }
    }// DoOleDbPermission




    void DoSecurityPermission(SecurityPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:SecurityPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedSecurityPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("SecurityPermission:Permission"), CResourceStore.GetInt("CReadOnlyPermission:SecPermWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("SecurityPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:SecPermGrantedWidth"));

            RowInfo[] rows = new RowInfo[13];
            String sYes = CResourceStore.GetString("Yes");
            String sNo = CResourceStore.GetString("No");
            SecurityPermissionFlag spf = perm.Flags;

            rows[0] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:CodeExecution"),
                                           ((spf & SecurityPermissionFlag.Execution) > 0)?sYes:sNo});

            rows[1] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:UnmanagedCode"),
                                           ((spf & SecurityPermissionFlag.UnmanagedCode) > 0)?sYes:sNo});
            
            rows[2] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:AssertPermission"),
                                           ((spf & SecurityPermissionFlag.Assertion) > 0)?sYes:sNo});

            rows[3] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:SkipVerification"),
                                           ((spf & SecurityPermissionFlag.SkipVerification) > 0)?sYes:sNo});

            rows[4] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:ThreadControl"),
                                           ((spf & SecurityPermissionFlag.ControlThread) > 0)?sYes:sNo});

            rows[5] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:PolicyControl"),
                                           ((spf & SecurityPermissionFlag.ControlPolicy) > 0)?sYes:sNo});

            rows[6] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:DomainControl"),
                                           ((spf & SecurityPermissionFlag.ControlDomainPolicy) > 0)?sYes:sNo});
                                           
            rows[7] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:PrincipalControl"),
                                           ((spf & SecurityPermissionFlag.ControlPrincipal) > 0)?sYes:sNo});

            rows[8] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:ControlAppDomain"),
                                           ((spf & SecurityPermissionFlag.ControlAppDomain) > 0)?sYes:sNo});

            rows[9] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:SerializationFormatter"),
                                           ((spf & SecurityPermissionFlag.SerializationFormatter) > 0)?sYes:sNo});

            rows[10] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:EvidenceControl"),
                                           ((spf & SecurityPermissionFlag.ControlEvidence) > 0)?sYes:sNo});

            rows[11] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:ExtendInfrastructure"),
                                           ((spf & SecurityPermissionFlag.Infrastructure) > 0)?sYes:sNo});

            rows[12] = new RowInfo(new String[] {CResourceStore.GetString("SecurityPermission:Remoting"),
                                           ((spf & SecurityPermissionFlag.RemotingConfiguration) > 0)?sYes:sNo});

            CreateTable(cols, rows);

        }

    }// DoSecurityPermission



    void DoUIPermission(UIPermission perm)
    {
        m_lblPermission.Text = CResourceStore.GetString("CReadOnlyPermission:UIPermission");
    
        if (perm.IsUnrestricted())
        {
            m_dg.Visible = false;
            m_txtUnrestricted.Visible = true;
            m_txtUnrestricted.Text = CResourceStore.GetString("CReadOnlyPermission:UnrestrictedUIPermission");
        }
        else
        {
            ColumnInfo[] cols = new ColumnInfo[2];
            cols[0] = new ColumnInfo(CResourceStore.GetString("UIPermission:Permission"), CResourceStore.GetInt("CReadOnlyPermission:UIPermWidth"));
            cols[1] = new ColumnInfo(CResourceStore.GetString("UIPermission:Granted"), CResourceStore.GetInt("CReadOnlyPermission:UIPermGrantedWidth"));

            RowInfo[] rows = new RowInfo[2];

            // Get the permission for the Windowing stuff
            String sWindowPermString = CResourceStore.GetString("UIPermission:Unknown");
            if (perm.Window == UIPermissionWindow.AllWindows)
                sWindowPermString = CResourceStore.GetString("UIPermission:Allwindows");
            else if (perm.Window == UIPermissionWindow.NoWindows)
                sWindowPermString = CResourceStore.GetString("UIPermission:Nowindows");
            else if (perm.Window == UIPermissionWindow.SafeSubWindows)
                sWindowPermString = CResourceStore.GetString("UIPermission:safesubwindows");
            else if (perm.Window == UIPermissionWindow.SafeTopLevelWindows) 
                sWindowPermString = CResourceStore.GetString("UIPermission:Safetopwindows");

            // Now get the permission for the Clipboard stuff
            String sClipboardPermString = CResourceStore.GetString("UIPermission:Unknown");

            if (perm.Clipboard == UIPermissionClipboard.AllClipboard)
                sClipboardPermString = CResourceStore.GetString("UIPermission:Allclipboard");
            else if (perm.Clipboard == UIPermissionClipboard.NoClipboard)
                sClipboardPermString = CResourceStore.GetString("UIPermission:Noclipboard");
            else if (perm.Clipboard == UIPermissionClipboard.OwnClipboard)
                sClipboardPermString = CResourceStore.GetString("UIPermission:pastingfromsamedomain");

            rows[0] = new RowInfo(new String[] {CResourceStore.GetString("UIPermission:Windowing"), sWindowPermString});
            rows[1] = new RowInfo(new String[] {CResourceStore.GetString("UIPermission:Clipboard"), sClipboardPermString});

            CreateTable(cols, rows);
        }
        
    }// DoUIPermission
    
    void CreateTable(ColumnInfo[] columns, RowInfo[] Rows)
    {
        m_dt = new DataTable("Stuff");
        // Put the columns in our data table
        for(int i=0; i< columns.Length; i++)
        {
            DataColumn dc = new DataColumn();
            dc.ColumnName = columns[i].sColName;
            dc.DataType = typeof(String);
            m_dt.Columns.Add(dc);
        }

        // Now tell our datagrid how to display these columns
        DataGridTableStyle dgts = new DataGridTableStyle();
        dgts.MappingName = "Stuff";
        dgts.RowHeadersVisible=false;
        dgts.AllowSorting=false;

        m_dg.TableStyles.Add(dgts);

        for(int i=0; i< columns.Length; i++)
        {
            DataGridTextBoxColumn dgtbc = new DataGridTextBoxColumn();

            // Set up the column info for the Property column
            dgtbc.MappingName = columns[i].sColName;
            dgtbc.HeaderText = columns[i].sColName;
            dgtbc.ReadOnly = true;
            dgtbc.Width = columns[i].nColWidth;
            dgts.GridColumnStyles.Add(dgtbc);
        }

        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);

        m_dg.DataSource = m_dt;

        // Now put the data into the datagrid
        DataRow newRow;
        for(int i=0; i<Rows.Length; i++)
        {
            newRow = m_dt.NewRow();
            for(int j=0; j< Rows[i].saData.Length; j++)
                newRow[j]=Rows[i].saData[j];

            m_dt.Rows.Add(newRow);
        }
       
        // Shrink the first field if we ended up needing a verticle scroll bar
        if (m_dg.TheVertScrollBar.Visible)
            m_dg.TableStyles[0].GridColumnStyles[0].Width = columns[0].nColWidth-13;
    }// CreateTable
    
}// class CReadOnlyPermission

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cpermissionset.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CPermissionSet.cs
//
// This class presents the a code group node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.Drawing;
using System.Collections;
using System.Security;
using System.Runtime.InteropServices;
using System.Security.Policy;

class CPermissionSet : CSecurityNode
{

    internal CPermissionSet(PolicyLevel pl, bool fReadOnly)
    {
        ReadOnly = fReadOnly;
        
        m_sGuid = "4E10E9F3-0B56-416e-A715-403C418CDE6F";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("permissionsets_ico");  
        m_oResults=new CPermSetTaskPad(this);

        m_sDisplayName = CResourceStore.GetString("CPermissionSet:DisplayName");
        m_aPropSheetPage = null;
        m_pl = pl;
    }// CPermissionSet

    internal override void AddMenuItems(ref IContextMenuCallback piCallback, ref int pInsertionAllowed)
    {  
        // See if we're allowed to insert an item in the "view" section
        if (!ReadOnly && (pInsertionAllowed & (int)CCM.INSERTIONALLOWED_TOP) > 0)
        {
            // Stuff common to the top menu
            CONTEXTMENUITEM newitem = new CONTEXTMENUITEM();
            newitem.lInsertionPointID = CCM.INSERTIONPOINTID_PRIMARY_TOP;
            newitem.fFlags = 0;
            newitem.fSpecialFlags=0;

            
            newitem.strName = CResourceStore.GetString("CPermissionSet:NewOption");
            newitem.strStatusBarText = CResourceStore.GetString("CPermissionSet:NewOptionDes");
            newitem.lCommandID = COMMANDS.NEW_PERMISSIONSET;
            
            // Now add this item through the callback
            piCallback.AddItem(ref newitem);
         }
     }// AddMenuItems

     internal override void MenuCommand(int iCommandID)
     {
        if (iCommandID == COMMANDS.NEW_PERMISSIONSET)
        {
            CNewPermSetWizard wiz = new CNewPermSetWizard(m_pl);
            wiz.LaunchWizard(Cookie);
            if (wiz.CreatedPermissionSet != null)
            {
                CNode node = AddPermissionSet(wiz.CreatedPermissionSet);
                SecurityPolicyChanged();
                // Now select the permission set we just created
                CNodeManager.SelectScopeItem(node.HScopeItem);
            }
        }
    }// MenuCommand

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
       if ((int)arg == 0)
       {
            // We need to pop up the Create New Permission Set wizard
            MenuCommand(COMMANDS.NEW_PERMISSIONSET);
            // Inform our Command History that we did this
            CCommandHistory.CommandExecuted(new CDO(this), COMMANDS.NEW_PERMISSIONSET);

       }
    }// TaskPadTaskNotify


    internal override int doAcceptPaste(IDataObject ido)
    {
        // Only accept a CSingleCodeGroup Node
        if (ido is CDO)
        {
            CDO cdo = (CDO)ido;
            if (cdo.Node is CSinglePermissionSet)
                // Check to make sure it's not one of our permission sets...
                if (cdo.Node.ParentHScopeItem != HScopeItem)
                    return HRESULT.S_OK;
        }
        return HRESULT.S_FALSE;
    }// doAcceptPaste

    internal override int Paste(IDataObject ido)
    {
        // Make sure the permission set is ok to use....
        if (ido is CDO)
        {
            CDO cdo = (CDO)ido;
            if (cdo.Node is CSinglePermissionSet)
            {
                CSinglePermissionSet sps = (CSinglePermissionSet)cdo.Node;
                
                AddPermissionSet(sps.PSet.Copy(sps.PSet.Name));
            }
        }
        return HRESULT.S_OK;
    }// Paste



    //-------------------------------------------------
    // CreateChildren
    //
    // This function creates the node's children, registers
    // the nodes with the node manager, and places the node's
    // cookies in it's child array
    //-------------------------------------------------
    internal override void CreateChildren()
	{
        CNode   node=null;
        int     iCookie=0;

        // Let's scrounge together a permission set enumerator
        IEnumerator permsetEnumerator = m_pl.NamedPermissionSets.GetEnumerator();
                  
        while (permsetEnumerator.MoveNext())
        {
            NamedPermissionSet permSet = (NamedPermissionSet)permsetEnumerator.Current;
            node = new CSinglePermissionSet(permSet, m_pl, ReadOnly);
            iCookie = CNodeManager.AddNode(ref node);
            AddChild(iCookie);

        }    
    }// CreateChildren

    internal CSinglePermissionSet AddPermissionSet(NamedPermissionSet nps)
    {
        // Make sure we have a unique permission set name
        int nCounter = 1;
        String sBase = nps.Name;
        while(Security.isPermissionSetNameUsed(m_pl, nps.Name))
        {
            if (nCounter == 1)
                nps.Name = String.Format(CResourceStore.GetString("CSinglePermissionSet:NewDupPermissionSet"), sBase);
            else
                nps.Name = String.Format(CResourceStore.GetString("CSinglePermissionSet:NumNewDupPermissionSet"), nCounter.ToString(), sBase);
            nCounter++;
        }

        // Now add the new permission set
        m_pl.AddNamedPermissionSet(nps);
        CNode node = new CSinglePermissionSet(nps, m_pl, ReadOnly);
        int nCookie = CNodeManager.AddNode(ref node);
        AddChild(nCookie);
        InsertSpecificChild(nCookie);
        // Return the node we created
        return (CSinglePermissionSet)node;
    }// AddPermissionSet

    
}// class CPermissionSet
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cremoting.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CRemoting.cs
//
// This class presents a version policy node
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Windows.Forms;

class CRemoting : CNode
{
    String m_sConfigFilename;
    
    internal CRemoting()
    {
        Init(null);
    }// CRemoting

    internal CRemoting(String sConfigFilename)
    {
        Init(sConfigFilename);
    }// CRemoting(String)

    private void Init(String sConfigFilename)
    {
        m_sConfigFilename = sConfigFilename;
        m_sGuid = "005DF24D-56B1-45d4-838F-780CEBBBFD3E";
        m_sHelpSection = "";
        m_hIcon = CResourceStore.GetHIcon("remoting_ico");  
        m_oResults=new CGenericTaskPad(this, "REMOTING_HTML");
        DisplayName = CResourceStore.GetString("CRemoting:DisplayName");
        Name="Remoting Services";
        m_aPropSheetPage = null;
    }// CRemoting

    internal override void TaskPadTaskNotify(Object arg, Object param, IConsole2 con, CData com)
    {
       if ((int)arg == 0)
       {
            // We need to pop up this node's property page
            OpenMyPropertyPage();
       }
    }// TaskPadTaskNotify


    protected override void CreatePropertyPages()
    {
        // If this is for an application....
        if (m_sConfigFilename != null)
        {
            m_aPropSheetPage = new CPropPage[] {new CRemotingProp1(m_sConfigFilename), 
                                                new CRemotingProp2(m_sConfigFilename),
                                                new CRemotingProp3(m_sConfigFilename)};
        }
        else
            // For the machine level, we only get 1 property page
            m_aPropSheetPage = new CPropPage[] {new CRemotingProp3(m_sConfigFilename)};
            
    }// CreatePropertyPages

}// class CSubServices
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\crootnode.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CRootNode.cs
//
// This class represents the root node of the snapin
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{

using System;
using System.Runtime.InteropServices;
using System.Threading;

class CRootNode : CNode
{
    
    internal CRootNode()
    {
        m_sGuid = "44598DFB-E95E-4419-B0FE-D4369829A48E";
        m_sHelpSection = "";
        m_oResults=null;
        m_hIcon = CResourceStore.GetHIcon("NETappicon_ico");       
        DisplayName = CResourceStore.GetString("CRootNode:DisplayName");
        Name=".NET Configuration";
    }// CRootNode

    //-------------------------------------------------
    // CreateChildren
    //
    // This function creates the node's children, registers
    // the nodes with the node manager, and places the node's
    // cookies in it's child array
    //-------------------------------------------------
    internal override void CreateChildren()
    {
        CNode   node = new CComputerNode();

        // We'll mark this as the local machine
        node.Data = 1;
        int iCookie = CNodeManager.AddNode(ref node);
        AddChild(iCookie);
    }// CreateChildren

    }// class CRootNode
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cremotingprop1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CRemotingProp1.cs
//
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Collections;
using System.Security.Policy;


internal class CRemotingProp1 : CPropPage
{
    // Controls on the page
	
    Label m_lblAppLivesHere;
    Label m_lblHelp;
    Label m_lblWellKnownObjectsHelp;
    MyDataGrid m_dg;
    Label m_lblChooseApp;
    ComboBox m_cbRemoteApps;
    TextBox m_txtAppLocation;

	private DataTable        m_dt;
	private DataSet          m_ds;

	// Internal data
	private ArrayList        m_alRemotingAppInfo;
	private int              m_nPrevSelection;
	private bool             m_fWatchChange;
    private String           m_sConfigFile;

    //-------------------------------------------------
    // CRemotingProp1 - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CRemotingProp1(String sConfigFile)
    {
        m_sConfigFile = sConfigFile;
        m_sTitle = CResourceStore.GetString("CRemotingProp1:PageTitle");
        m_fWatchChange = true;
    }// CRemotingProp1

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CRemotingProp1));
        this.m_lblAppLivesHere = new System.Windows.Forms.Label();
        m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblWellKnownObjectsHelp = new System.Windows.Forms.Label();
        this.m_dg = new MyDataGrid();
        this.m_lblChooseApp = new System.Windows.Forms.Label();
        this.m_cbRemoteApps = new System.Windows.Forms.ComboBox();
        this.m_txtAppLocation = new System.Windows.Forms.TextBox();
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblAppLivesHere.Location = ((System.Drawing.Point)(resources.GetObject("m_lblAppLivesHere.Location")));
        this.m_lblAppLivesHere.Size = ((System.Drawing.Size)(resources.GetObject("m_lblAppLivesHere.Size")));
        this.m_lblAppLivesHere.TabIndex = ((int)(resources.GetObject("m_lblAppLivesHere.TabIndex")));
        this.m_lblAppLivesHere.Text = resources.GetString("m_lblAppLivesHere.Text");
        m_lblAppLivesHere.Name = "AppLivesHereLabel";
        this.m_lblWellKnownObjectsHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblWellKnownObjectsHelp.Location")));
        this.m_lblWellKnownObjectsHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblWellKnownObjectsHelp.Size")));
        this.m_lblWellKnownObjectsHelp.TabIndex = ((int)(resources.GetObject("m_lblWellKnownObjectsHelp.TabIndex")));
        this.m_lblWellKnownObjectsHelp.Text = resources.GetString("m_lblWellKnownObjectsHelp.Text");
        m_lblWellKnownObjectsHelp.Name = "WellKnownObjectsHelp";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        this.m_lblChooseApp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseApp.Location")));
        this.m_lblChooseApp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseApp.Size")));
        this.m_lblChooseApp.TabIndex = ((int)(resources.GetObject("m_lblChooseApp.TabIndex")));
        this.m_lblChooseApp.Text = resources.GetString("m_lblChooseApp.Text");
        m_lblChooseApp.Name = "ChooseApp";
        this.m_cbRemoteApps.DropDownWidth = 328;
        this.m_cbRemoteApps.Location = ((System.Drawing.Point)(resources.GetObject("m_cbRemoteApps.Location")));
        this.m_cbRemoteApps.Size = ((System.Drawing.Size)(resources.GetObject("m_cbRemoteApps.Size")));
        this.m_cbRemoteApps.TabIndex = ((int)(resources.GetObject("m_cbRemoteApps.TabIndex")));
        m_cbRemoteApps.Name = "RemoteApps";
        this.m_txtAppLocation.Location = ((System.Drawing.Point)(resources.GetObject("m_txtAppLocation.Location")));
        this.m_txtAppLocation.Size = ((System.Drawing.Size)(resources.GetObject("m_txtAppLocation.Size")));
        this.m_txtAppLocation.TabIndex = ((int)(resources.GetObject("m_txtAppLocation.TabIndex")));
        m_txtAppLocation.Name = "AppLocation";
        PageControls.AddRange(new System.Windows.Forms.Control[] {
                        this.m_lblWellKnownObjectsHelp,
                        m_lblHelp,
                        this.m_lblChooseApp,
                        this.m_cbRemoteApps,
                        this.m_lblAppLivesHere,
                        this.m_txtAppLocation,
                        this.m_dg
                        });

        //---------- Build the  Data Table ----------------
        
        m_dt = new DataTable("Remoting");
        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);

        m_dt.DefaultView.AllowNew=false;

        // Create the "Object Name" Column
        DataColumn dcObjectName = new DataColumn();
        dcObjectName.ColumnName = "Object Name";
        dcObjectName.DataType = typeof(String);
        m_dt.Columns.Add(dcObjectName);

        // Create the "URL" Column
        DataColumn dcKnownURL = new DataColumn();
        dcKnownURL.ColumnName = "URL";
        dcKnownURL.DataType = typeof(String);
        m_dt.Columns.Add(dcKnownURL);

        m_dg.ReadOnly=false;
        m_dg.CaptionVisible=false;
        m_dg.ParentRowsVisible=false;
        m_dg.BackgroundColor = Color.White;

        // Now set up any column-specific behavioral stuff....
        // like setting column widths, etc.

        DataGridTableStyle dgts = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcObjectName = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcURL = new DataGridTextBoxColumn();

        m_dg.TableStyles.Add(dgts);
        dgts.MappingName = "Remoting";
        dgts.RowHeadersVisible = false;


        // Set up the column info for the Object Type column
        dgtbcObjectName.MappingName = "Object Name";
        dgtbcObjectName.HeaderText = CResourceStore.GetString("CRemotingProp1:ObjectNameColumn");
        dgtbcObjectName.ReadOnly=true;
        dgtbcObjectName.Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp1:ObjectNameColumnWidth"));
        dgts.GridColumnStyles.Add(dgtbcObjectName);
    
        // Set up the column info for the URL column
        dgtbcURL.MappingName = "URL";
        dgtbcURL.HeaderText = CResourceStore.GetString("CRemotingProp1:URLColumn");
        dgtbcURL.ReadOnly=false;
        dgtbcURL.Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp1:URLColumnWidth"));
        dgtbcURL.TextBox.TextChanged +=new EventHandler(onTextChange);

        dgts.GridColumnStyles.Add(dgtbcURL);

        m_dg.DataSource = m_dt;

        //---------- End Data Table stuff ----------------


		m_cbRemoteApps.SelectedIndexChanged += new EventHandler(onRemotingAppChange);

        // Fill in the data
        PutValuesinPage();

        // Now finally hook up this event handler
       
        m_txtAppLocation.TextChanged +=new EventHandler(onTextChange);
		return 1;
    }// InsertPropSheetPageControls

    void onTextChange(Object o, EventArgs e)
    {
        // We don't always want to activate the apply button if this 
        // text changes. Sometimes it will change when the user just
        // selects a different remote app and we programmatically change
        // it
        if (m_fWatchChange)
            ActivateApply();

    }// onTextChange

    internal override bool ValidateData()
    {
        return ValidateData(m_cbRemoteApps.SelectedIndex);
    }

    private bool ValidateData(int nIndex)
    {
        // Make sure this is a valid index
        if (nIndex == -1)
            return true;

        // Verify the location is correct
        try
        {
            new Uri(m_txtAppLocation.Text);
        }
        catch(Exception)
        {
            // Catch the error that is was an invalid version
            MessageBox(String.Format(CResourceStore.GetString("IsNotAValidURL"),m_txtAppLocation.Text),
                        CResourceStore.GetString("IsNotAValidURLTitle"),
                        MB.ICONEXCLAMATION);
            m_txtAppLocation.Select(0, m_txtAppLocation.Text.Length);
            return false;                                       
        }

    
        // Let's jump to a new cell, to make sure the current cell we
        // were editing has it's changes 'saved'
        m_dg.CurrentCell = new DataGridCell(0,1);
        m_dg.CurrentCell = new DataGridCell(0,0);


        RemotingApplicationInfo rai = (RemotingApplicationInfo)m_alRemotingAppInfo[nIndex];

        int nLen = rai.scWellKnownURL.Count;
        
        for(int i=0; i<nLen; i++)
        {
            try
            {
                new Uri((String)m_dg[i,1]);
            }
            catch(Exception)
            {
                // Catch the error that is was an invalid version
                MessageBox(String.Format(CResourceStore.GetString("IsNotAValidURL"),(String)m_dg[i,1]),
                           CResourceStore.GetString("IsNotAValidURLTitle"),
                           MB.ICONEXCLAMATION);
                m_dg.CurrentCell = new DataGridCell(i,1);

                return false;                                       
            }
        }
        
        return true;
    }// ValidateData



    private void PutValuesinPage()
    {
        m_nPrevSelection=-1;

        String sSettingCommand = "RemotingApplications";
        if (m_sConfigFile != null)
            sSettingCommand += "," + m_sConfigFile;

        try
        {
            m_alRemotingAppInfo = (ArrayList)CConfigStore.GetSetting(sSettingCommand);

            m_cbRemoteApps.Items.Clear();
            for(int i=0; i<m_alRemotingAppInfo.Count; i++)
            {
             	String sName = ((RemotingApplicationInfo)m_alRemotingAppInfo[i]).sName;
         	    if (sName == null || sName.Length == 0)
                    sName = CResourceStore.GetString("CRemotingProp1:NoDisplayName");

                m_cbRemoteApps.Items.Add(sName);
		    }
            if (m_alRemotingAppInfo.Count > 0)
            {
                m_cbRemoteApps.DropDownStyle = ComboBoxStyle.DropDownList;
                m_cbRemoteApps.SelectedIndex=0;
                onRemotingAppChange(null, null);
            }
            else
            {
                m_cbRemoteApps.Text = CResourceStore.GetString("CRemotingProp1:NoRemoteApps");
                m_cbRemoteApps.Enabled = false;
                m_txtAppLocation.Enabled = false;
            }
        }
        catch(Exception)
        {
            // An exception will get thrown if there was an error reading
            // the remoting config info. Don't allow the property page to open.
            CloseSheet();
        }

    }// PutValuesinPage

    void onRemotingAppChange(Object o, EventArgs e)
    {
        if (m_cbRemoteApps.SelectedIndex != -1)
        {
            if (m_nPrevSelection != -1 && m_nPrevSelection != m_cbRemoteApps.SelectedIndex)
            {
                // Check these values first
                if (!ValidateData(m_nPrevSelection))
                {
                    m_cbRemoteApps.SelectedIndex = m_nPrevSelection;
                    return;
                }
 
            }
          
            RemotingApplicationInfo rai;
            
            if (m_nPrevSelection != -1)
            {
           
                rai = (RemotingApplicationInfo)m_alRemotingAppInfo[m_nPrevSelection];
               
                // Capture the changes the user made to the URL 

                rai.sURL = m_txtAppLocation.Text;
                
                for (int i=0; i<rai.scWellKnownURL.Count; i++)
                    rai.scWellKnownURL[i]=(String)m_dt.Rows[i]["URL"];           
            }
            m_fWatchChange=false;
            m_dt.Clear();            


            rai = (RemotingApplicationInfo)m_alRemotingAppInfo[m_cbRemoteApps.SelectedIndex];

            // Put in the application's location
            m_txtAppLocation.Text = rai.sURL;

            DataRow newRow;

            // Now build the Well Known objects table
            for (int i=0; i<rai.scWellKnownObjectType.Count; i++)
            {
                newRow = m_dt.NewRow();
                String sName = rai.scWellKnownObjectType[i];
				if (sName == null || sName.Length == 0)
            		sName = CResourceStore.GetString("Unnamed");

                newRow["Object Name"]=sName;
                newRow["URL"]=rai.scWellKnownURL[i];
                m_dt.Rows.Add(newRow);
            }

        }
        m_nPrevSelection = m_cbRemoteApps.SelectedIndex;
        m_fWatchChange=true;

        // See if we should shrink one of the columns
        if (m_dg.TheVertScrollBar.Visible)
        {
            // The vertical scrollbar is visible. It takes up 13 pixels
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp1:URLColumnWidth")) - m_dg.TheVertScrollBar.Width;
        }
        else
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp1:URLColumnWidth"));
        

        
    }// onRemotingAppChange


    internal override bool ApplyData()
    {
        // Get our currently displayed data into our array list
        if (m_alRemotingAppInfo.Count > 0)
        {
            m_dg.CurrentCell = new DataGridCell(0,0);
            m_dg.CurrentCell = new DataGridCell(0,1);
        }
        
        onRemotingAppChange(null, null);
        String sSettingCommand = "RemotingApplications";
        if (m_sConfigFile != null)
            sSettingCommand += "," + m_sConfigFile;
    
        return CConfigStore.SetSetting(sSettingCommand, m_alRemotingAppInfo);               
    }// ApplyData
}// class CAssemBindPolicyProp

}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cproppage.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CPropPage.cs
//
// This file defines the base class that all property sheet pages
// must derive from.
//-------------------------------------------------------------
namespace Microsoft.CLRAdmin
{
using System;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using System.Drawing;
using System.Reflection;
using System.Globalization;
using System.Threading;

public class CWizardPage : CPropPage
{
    private int       ms_nDlgWidth=-1;
    private int       ms_nDlgHeight=-1;

    public CWizardPage() : base()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CWizardPage));
        PageSize = ((System.Drawing.Size)(resources.GetObject("$this.Size")));
    }
    public Size WizardPageSize
    {
        get
        { 
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CWizardPage));
            return ((System.Drawing.Size)(resources.GetObject("$this.Size")));
        }
    }
    
    internal override int DlgWidth
    {
        get
        {
            return ms_nDlgWidth;
        }
        set
        {
            ms_nDlgWidth = value;
        }
    }
    
    internal override int DlgHeight
    {
        get
        {
            return ms_nDlgHeight;
        }
        set
        {
            ms_nDlgHeight = value;
        }
    }


}// CWizardPage

public class CPropPage
{
    protected String    m_sTitle;          // The title of the Property Page
    internal  IntPtr    m_hWnd;            // The window handle the page will be inserted on
    protected IntPtr    m_hIcon;           // Handle of the icon we should display
    protected String    m_sHeaderTitle;    // The header title of a wizard
    protected String    m_sHeaderSubTitle; // The sub title/description of a wizard
    protected int       m_iCookie;         // Cookie of the node we're parented by
    protected IntPtr    m_hPropertyPageRouter;
    private DialogProc  m_dlgHook;         // Hook to allow subclassing of a property page
    private DialogProc  m_dlgProc;
    private bool        m_fChanges;
    private Size        m_Size;
    private UserControl m_uc;
    private IntPtr      m_pDlgTemplate;
    private double      m_dWidthScaleFactor;
    private double      m_dHeightScaleFactor;
    

    private static bool      ms_fLoadedHelper=false;
    private int       ms_nDlgWidth=-1;
    private int       ms_nDlgHeight=-1;
    

    //-------------------------------------------------
    // CPropPage - Constructor
    //
    // Initialize all our member variables to invalid
    // values. We'll expect anybody that inherits us
    // to actually put good values in here.
    //-------------------------------------------------
    internal CPropPage()
    {
        m_sTitle="Title-less";
        m_hWnd = (IntPtr)0;
        m_hIcon = (IntPtr)(-1);
        m_sHeaderTitle = null;
        m_sHeaderSubTitle = null;
        m_iCookie = -1;
        m_dlgHook = null;
        m_dlgProc = new DialogProc(PropPageDialogProc);
        m_fChanges=false;
        m_uc = null;
        m_pDlgTemplate = (IntPtr)0;
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CPropPage));
        m_Size = ((System.Drawing.Size)(resources.GetObject("$this.Size")));

        // There's the possiblity that our helper DLL is not going to be on the 
        // path, so when the runtime tries to do a loadlibrary for some P/Invoke calls,
        // we will fail. We'll get around this by loading the DLL into memory 
        // (since we'll know where it is) and then when the runtime calls LoadLibrary,
        // windows will return the one we've already loaded
        
        if (!ms_fLoadedHelper)
        {
            String sLocation = Assembly.GetAssembly(typeof(object)).Location;
            // This will return the location of mscorlib.dll. We are going to
            // be setup so mscortim.dll is in the same directory as mscorlib.dll.
            // We'll load that DLL now

            String sHelperLocation = sLocation.Replace("mscorlib.dll", "mscortim.dll");
            // Now we'll load that DLL
            if (LoadLibrary(sHelperLocation) != (IntPtr)0)
                ms_fLoadedHelper = true;
            // Else... it failed. What should we do? This is not good... we'll just try
            // again sometime
        }
    }// CPropPage

    ~CPropPage()
    {
        if (m_pDlgTemplate != (IntPtr)0)
        {
            Marshal.FreeHGlobal(m_pDlgTemplate);
            m_pDlgTemplate = (IntPtr)0;
        }
    }// ~CPropPage

    internal virtual int DlgWidth
    {
        get
        {
            return ms_nDlgWidth;
        }
        set
        {
            ms_nDlgWidth = value;
        }
    }
    
    internal virtual int DlgHeight
    {
        get
        {
            return ms_nDlgHeight;
        }
        set
        {
            ms_nDlgHeight = value;
        }
    }

    internal Size PageSize
    {
        get
        {
            if (m_uc == null)
                return m_Size;
            else 
                return m_uc.Size;
        }
        set
        {
            if (m_uc == null)
            {
                m_Size = value;
            }
            else 
                m_uc.Size = value;
        }
    }// PageSize

    internal IntPtr GetDialogTemplate()
    {
        if (m_pDlgTemplate != (IntPtr)0)
            return m_pDlgTemplate;

        CreateUserControl();

        DLGTEMPLATE dlg = new DLGTEMPLATE();

        // Convert the size (in pixels) of the property page to 
        // the size in dialog units
        // We add the 1 to round up...

        if (DlgWidth == -1)
            FindGoodSizes();

        dlg.cx = (short)(DlgWidth * m_dWidthScaleFactor);
        dlg.cy = (short)(DlgHeight * m_dHeightScaleFactor);
        
        m_pDlgTemplate = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(DLGTEMPLATE)));

        Marshal.StructureToPtr(dlg, m_pDlgTemplate, false);

        return m_pDlgTemplate;
    }// GetDialogTemplate

    protected Control.ControlCollection PageControls
    {
        get{return m_uc.Controls;}
    }// BaseControl

    //-------------------------------------------------
    // hWnd - Property
    //
    // Allows read-only access to this property page's
    // hwnd.
    //-------------------------------------------------

    internal IntPtr hWnd
    {
        get
        {
            return m_hWnd;
        }
    }// hWnd

    internal Point Location
    {
        get
        {
            WINDOWINFO wi= new WINDOWINFO();
            wi.cbSize = (uint)Marshal.SizeOf(typeof(WINDOWINFO));
            
            if (hWnd == (IntPtr)0 || GetWindowInfo(hWnd, out wi) == 0)
            {
                return new Point(0,0);
            }
            return new Point(wi.rcClient.left, wi.rcClient.top);
        }
    }// Location

    //-------------------------------------------------
    // Init
    //
    // This function is called when we're ready to use
    // the property page. We pass in the cookie of the
    // node that this property page belongs to, and we
    // should do any setup information (with the exception
    // of creating Winform controls) here.
    //-------------------------------------------------
    internal virtual void Init(int iCookie, IntPtr routerhandle)
    {
        m_iCookie=iCookie;
        // We won't cache the node, in case it changes somehow 
        // during the life of the property page
        CNode node = CNodeManager.GetNode(m_iCookie);
        m_hIcon = node.IconHandle;
        m_hPropertyPageRouter = routerhandle;
    }// Init

    private void CreateUserControl()
    {
        if (m_uc != null)
        {
            m_uc.Visible = false;
        }
        m_uc = new UserControl();
        CultureInfo ciOld = Thread.CurrentThread.CurrentCulture;
        
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CPropPage));
        m_uc.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("$this.RightToLeft")));
        // If this font doesn't exist on the system, we'll use the system default one
        try
        {
            m_uc.Font = ((System.Drawing.Font)(resources.GetObject("$this.Font")));
        }
        catch(Exception)
        {}
            
        m_uc.Size = m_Size;

        m_uc.Location = new System.Drawing.Point (0, 0);
        m_uc.Name = "uc";

        SizeF size = Form.GetAutoScaleSize(m_uc.Font);

        // Switch to the english culture so we can parse these strings
        Thread.CurrentThread.CurrentCulture = new CultureInfo("en-US");
        double xScale = Double.Parse(CResourceStore.GetString("CPropPage:XScale"));
        double yScale = Double.Parse(CResourceStore.GetString("CPropPage:YScale"));

        // Flip back to the prior culture
        Thread.CurrentThread.CurrentCulture = ciOld;

        m_dWidthScaleFactor = size.Width/xScale;
        m_dHeightScaleFactor = size.Height/yScale;

            
    }// CreateUserControl

    internal int BeginInsertPropSheetPageControls(IntPtr hWnd)
    {

        // Set cursor to wait cursor
        IntPtr hOldCursor = SetCursorToWait();

        int nRetVal=0;
        CreateUserControl();
        
        m_hWnd = hWnd;
        SetParent(m_uc.Handle, m_hWnd);

        int nFlags = GetWindowLong(m_uc.Handle, -20 /* GWL_EXSTYLE */);

        // Remove the WS_EX_LAYOUTRTL style
        nFlags = nFlags & ~0x00400000;

        SetWindowLong(m_uc.Handle, -20 /* GWL_EXSTYLE */, nFlags);

        nRetVal = InsertPropSheetPageControls();

        // Change back
        SetCursor(hOldCursor);

        // Scale everything
        //
        // Why do we need to do this? All the property pages were designed with
        // a certain 'scale factor' in mind. If the user has changed the
        // system font, we need to resize our controls appropriately.
        
        m_uc.Scale((float)m_dWidthScaleFactor, (float)m_dHeightScaleFactor);
              
        return nRetVal;
    }// BeginInsertPropPageControls

    internal int ScaleWidth(int nWidth)
    {
        return (int)(nWidth*m_dWidthScaleFactor);
    }// ScaleWidth
    
    internal IntPtr SetCursorToWait()
    {
        // Change to a wait cursor
        // 32514 is IDC_WAIT
        IntPtr hWaitCursor = LoadCursor((IntPtr)0, 32514);

        // Make sure we grab onto the current cursor
        return SetCursor(hWaitCursor);
    }// SetCursorToWait


    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function should be used to create the Winforms
    // controls and parent them to the user control.
    //-------------------------------------------------
    internal virtual int InsertPropSheetPageControls()
    {
        return 1;
    }// InsertPropSheetPageControls

    //-------------------------------------------------
    // Title
    //
    // This will return the title of our property page
    //-------------------------------------------------
    internal String Title()
    {
        return m_sTitle;
    }// Title

    //-------------------------------------------------
    // Icon
    //
    // This function will return the icon that will be displayed in the
    // "tab" of the property page. 
    // Generally, we don't want to show an icon, so if a
    // property page actually wants to show it's icon, it
    // will have to override this method.
    //-------------------------------------------------
    internal virtual IntPtr Icon()
    {
        return (IntPtr)(-1);
    }// Icon

    //-------------------------------------------------
    // HeaderSubTitle
    //
    // This function will return the sub-title/description
    // found on wizard pages
    //-------------------------------------------------
    internal String HeaderSubTitle()
    {
        return m_sHeaderSubTitle;
    }// HeaderSubTitle

    //-------------------------------------------------
    // HeaderTitle
    //
    // This function will return the title found on 
    // wizard pages
    //-------------------------------------------------
    internal String HeaderTitle()
    {
        return m_sHeaderTitle;
    }// HeaderTitle

    //-------------------------------------------------
    // DialogProc - Property
    //
    // Allows access to the PropSheetDialogProc function
    //-------------------------------------------------
    internal DialogProc DialogProc
    {
        get
        {
            return m_dlgProc;
        }

    }// DialogProc

    //-------------------------------------------------
    // DialogProcHook - Property
    //
    // Allows owners/inherited property pages to insert a 
    // 'hook' to get first crack at processing dialogproc
    // messages
    //-------------------------------------------------
    internal DialogProc DialogProcHook
    {
        get
        {
            return m_dlgHook;
        }
        set
        {
            m_dlgHook = value;
        }

    }// DialogProcHook

    //-------------------------------------------------
    // PropSheetDialogProc
    //
    // This function will handle all messages coming sent
    // to the property page
    //-------------------------------------------------
    internal bool PropPageDialogProc(IntPtr hwndDlg, uint msg, IntPtr wParam, IntPtr lParam)
    {
        try
        {
        // See if we've been subclassed...
        if (m_dlgHook != null)
        {
            // If our hook handled the message, then we don't need to do
            // anything anymore. :)
            if (m_dlgHook(hwndDlg, msg, wParam, lParam))
                return true;
        }
        switch (msg)
        {
            case WM.INITDIALOG:
                BeginInsertPropSheetPageControls(hwndDlg);
                return true;

            case WM.DESTROY:

                // We're not going to make changes to this
                m_fChanges=false;

                // tell MMC that we're done with the property sheet 
                if (m_iCookie != -1)
                {
                    CNodeManager.GetNode(m_iCookie).FreePropertySheetNotifyHandle();
                    return true;
                }
                // If we don't belong to a specific node, then we can't handle
                // this message
                return false;

            case WM.PAINT:
                // WinForms has problems repainting managed controls on an unmanaged
                // form. We'll intercept every paint message and force all the 
                // managed controls to repaint themselves. This will create a little
                // flicker, but it's better (for now) than having controls not show
                // up at all.
                if (m_uc != null)
                    m_uc.Refresh();
                return false;

            case WM.NOTIFY:

                // lParam really is a pointer to a NMHDR structure....
                NMHDR nm = new NMHDR();
                nm = (NMHDR)Marshal.PtrToStructure(lParam, nm.GetType());

                // We're about to lose focus of this property page. Make sure the data
                // is valid before we allow that
                //
                // We only want to do validation though if they've made changes
                if (nm.code == PSN.KILLACTIVE && m_fChanges)
                {
                    if (!ValidateData())
                    {
                        // The data on the page had errors
                        SetWindowLong(hwndDlg, 0, 1);
                    }
                    return true;
                }
                
                // If we're being told to apply changes made in the property pages....
                else if (nm.code == PSN.APPLY)
                {
                    // We'll only run through the Validate/Apply if the user made changes
                    if (m_fChanges)
                    {
                        // First, call a validate on the current page
                        if (!ValidateData() || !ApplyData())
                        // There were errors on this page...
                        // Set the appropriate return code here.
                            SetWindowLong(hwndDlg, 0, (int)PSNRET.INVALID_NOCHANGEPAGE);
                        else
                            m_fChanges=false;

                        return true;
                    }
                }
                else if (nm.code == PSN.QUERYCANCEL)
                {
                    // Ok, so this may look odd. Why do we send an WM_INITDIALOG right
                    // after we get a QUERYCANCEL?
                    //
                    // Well, our dialogs expect WM.INITDIALOG to be sent to them each time
                    // they are shown. Well, unfortunately, that doesn't seem to be the case
                    // now. It is sent once, when it is first shown. Now, we'll make
                    // sure it gets send again.
                    PostMessage(hwndDlg, WM.INITDIALOG, 0, 0);
                }
                break;
            default:
                // We'll let the default windows message handler handle the rest of
                // the messages
                return false;
        }
        }
        catch(Exception)
        {
            // We encountered an exception... let's just swallow the error and 
            // hope everything will be ok.
            //
            // If we let this exception continue, it will kill the thread that's pumping
            // messages for the property page. This will cause MMC to hang. Not what we want.
        }
        return false;
    }// PropPageDialogProc

    //-------------------------------------------------
    // ActivateApply
    //
    // This function will turn on the apply button by sending
    // a message to the parent window
    //-------------------------------------------------
    internal void ActivateApply()
    {
        SendMessage(GetParent(m_hWnd), PSM.CHANGED, (uint)m_hWnd, 0);
        m_fChanges=true;
    }// ActivateApply

    //-------------------------------------------------
    // ValidateData
    //
    // This function gets called when someone clicks OK, APPLY,
    // Finish, Next, or tries to move to a different property
    // page. It should return 'true' if everything is ok,
    // or false if things are not ok
    //-------------------------------------------------
    internal virtual bool ValidateData()
    {
        return true;
    }// ValidateData

    //-------------------------------------------------
    // ApplyData
    //
    // This function gets called when somebody clicks 
    // OK, APPLY, or FINISH on our property page/wizard.
    // It should return true if everything is ok, or false
    // if things are not ok.
    //-------------------------------------------------
    internal virtual bool ApplyData()
    {
        return true;
    }// ApplyData

    internal void CloseSheet()
    {
        if (m_iCookie != -1)
            CNodeManager.GetNode(m_iCookie).FreePropertySheetNotifyHandle();

        m_iCookie = -1;
        PostMessage(GetParent(m_hWnd), WM.COMMAND, 2 /*IDCANCEL*/, 0);
        // Set focus to the sheet to make sure it goes away.
        PostMessage(GetParent(m_hWnd), WM.SETFOCUS, 0, 0);



    }// CloseSheet

    internal int MessageBox(String Message, String Header, uint type)
    {
        return MessageBox(m_hWnd, Message, Header, type);
    } // MessageBox

    //-------------------------------------------------
    // StringToByteArray
    //
    // This function will convert a string to a byte array so
    // it can be sent across the global stream in CDO 
    //-------------------------------------------------
    protected unsafe byte[] StringToByteArray(String input)
    {
        int i;
        int iStrLength = input.Length;

        // Since MMC treats all its strings as unicode, 
        // each character must be 2 bytes long
        byte[] output = new byte[(iStrLength + 1)*2];
        char[] cinput = input.ToCharArray();

        int j=0;
        
        for(i=0; i<iStrLength; i++)
        {
            output[j++] = (byte)cinput[i];
            output[j++] = 0;
        }

        output[j++]=0;
        // For the double null
        output[j]=0;
        
        return output;

     }// StringToByteArray

    private bool myProc(IntPtr hwndDlg, uint msg, IntPtr wParam, IntPtr lParam)
    {
        return false;
    }
    
    void FindGoodSizes()
    {
        IntPtr hwndDlg = IntPtr.Zero;
        try
        {
            // Ok, so here's the deal.

            // To convert from pixels to dialog units, we use the following formula
            //
            // DUx = (4 * Pixelx) / (Average Character Width of System Font)
            // DUy = (8 * Pixely) / (Average Character Height of System Font)
            //
            // So, figuring out the Average Character Width and Height of the System Font
            // seems to be almost an impossibity. You'll see people do crud like
            // width of "abcdefghi..." / 26. That works all fine and dandy with a Latin-based
            // character set, but once we get those nice Chinese and other Asia symbols, we
            // get messed up.
            //
            // So, what do we do?
            // 
            // If we have a dialog created, there is a Win32 API that will convert from dialog
            // units to pixels. Not quite what we need, but close enough...
            //
            // What we'll do is create a dummy dialog that we'll never show. Then we'll ask
            // Windows to compute some Pixel widths for us from some dialog units. That will
            // allow us to 'reverse engineer' the above equations and figure out what the
            // average width and height of the system font really is. Once we get those numbers,
            // we can to the translations.
             

            RECT r = new RECT();

            IntPtr hInst = LoadLibrary("COMCTL32");

            DialogProc dp = new DialogProc(myProc);

            // Find the dialog resource for a property sheet or wizard page.
            //
            // These constants can be found at \\index2\w2krtm\private\shell\comctl32\rcids.h
            //
            // They correspond to DLG_WIZARD and DLG_PROPSHEET
            
            IntPtr nTemplate = (this is CWizardPage)?(IntPtr)1020:(IntPtr)1006;

            // Get the Template from COMCTL32
            IntPtr hresinfo = FindResource(hInst, nTemplate, 5);
            IntPtr h = LoadResource(hInst, hresinfo);
            int nSize = SizeofResource(hInst, hresinfo);
            IntPtr pstr = LockResource(h);
            Byte[] nResource = new Byte[nSize];
            
            Marshal.Copy(pstr, nResource, 0, nSize);  

            // Remove the WS_VISIBLE from the styles attribute
            byte WS_VISIBLE = 0x10;
            nResource[3] &= (byte)(~ WS_VISIBLE);

            IntPtr pResource = Marshal.AllocHGlobal(nSize);
            Marshal.Copy(nResource, 0, pResource, nSize);

            hwndDlg = CreateDialogIndirectParam(hInst, pResource, CNodeManager.MMChWnd, dp, IntPtr.Zero);
           
            r.left = 0;
            r.top = 0;
            r.right = 100;
            r.bottom = 100;

            MapDialogRect(hwndDlg, ref r);

            double nMagicXNumber = 4.0*r.right/100.0;
            double nMagicYNumber = 8.0*r.bottom/100.0;

            // Add the 1 to round up
            DlgWidth = (int)((4.0 * PageSize.Width / nMagicXNumber)+1);
            DlgHeight = (int)((8.0 * PageSize.Height / nMagicYNumber)+1);

         }
        catch(Exception)
        {}
        if (hwndDlg != IntPtr.Zero)
            DestroyWindow(hwndDlg);
    }// FindGoodSizes

 

    //-------------------------------------------------
    // We need to import the Win32 API calls used to deal with
    // window messaging.
    //-------------------------------------------------
    [DllImport("user32.dll")]
    internal static extern int SetParent(IntPtr hWndChild, IntPtr hWndNewParent);
    [DllImport("user32.dll")]
    internal static extern int SendMessage(IntPtr hWnd, uint Msg, uint wParam, uint lParam);
    [DllImport("user32.dll")]
    internal static extern int PostMessage(IntPtr hWnd, uint Msg, uint wParam, uint lParam);
    [DllImport("user32.dll")]
    internal static extern IntPtr GetParent(IntPtr hWnd);  
    [DllImport("user32.dll")]
    internal static extern int SetWindowLong(IntPtr hWnd, int nIndex, int dwNewLong);
    [DllImport("user32.dll")]
    internal static extern int GetWindowLong(IntPtr hWnd, int nIndex);
    [DllImport("user32.dll")]
    internal static extern IntPtr SetCursor(IntPtr hCursor);
    [DllImport("user32.dll")]
    internal static extern IntPtr LoadCursor(IntPtr hInstance, int lpCursorName);
    [DllImport("user32.dll")]
    internal static extern int GetWindowInfo(IntPtr hWnd, out WINDOWINFO pwi);
    [DllImport("kernel32.dll", CharSet=CharSet.Auto)]
    private static extern IntPtr LoadLibrary(String sLibrary);
    [DllImport("mscortim.dll")]
    internal static extern int callMMCPropertyChangeNotify(IntPtr lNotifyHandle, int lparam);
    [DllImport("mscortim.dll")]
    internal static extern int GetPropSheetCharSizes(out uint xCharSize, out uint yCharSize);
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    internal static extern uint GetDialogBaseUnits();
    // We wrap this function (so the caller doesn't need to supply the hWnd)
    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    private static extern int MessageBox(IntPtr hWnd, String Message, String Header, uint type);


    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern int EndDialog(IntPtr hWnd, IntPtr nResult);

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern int DestroyWindow(IntPtr hWnd);


    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern IntPtr CreateDialogIndirectParam(IntPtr hInstance,  // handle to module
                                                   IntPtr lpTemplate,   // dialog box template name
                                                   IntPtr hWndParent,      // handle to owner window
                                                   DialogProc lpDialogFunc,
                                                   IntPtr dwInitParam);  // dialog box procedure

    [DllImport("user32.dll", CharSet=CharSet.Auto)]
    static private extern int MapDialogRect(IntPtr hDlg,      // handle to dialog box
                                            ref RECT lpRect);   // dialog box coordinates

    [DllImport("kernel32.dll", CharSet=CharSet.Ansi)]
    internal static extern IntPtr FindResource(IntPtr mod, IntPtr nResource, int type);
    [DllImport("kernel32.dll")]
    internal static extern IntPtr LoadResource(IntPtr mod, IntPtr hresinfo);
    [DllImport("kernel32.dll")]
	internal static extern IntPtr LockResource(IntPtr h);
	[DllImport("kernel32.dll")]
	internal static extern int SizeofResource(IntPtr hModule, IntPtr hResInfo);
 
}// CPropPage
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\csecurityadjustmentwiz1.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections;
using System.ComponentModel;


internal class CSecurityAdjustmentWiz1 : CTrustAppWiz1
{
    // Controls on the page

    internal CSecurityAdjustmentWiz1(bool fMachineReadOnly, bool fUserReadOnly) : base(fMachineReadOnly, fUserReadOnly)
    {
        m_sTitle=CResourceStore.GetString("CSecurityAdjustmentWiz1:Title"); 
        m_sHeaderTitle = CResourceStore.GetString("CSecurityAdjustmentWiz1:HeaderTitle");
        m_sHeaderSubTitle = CResourceStore.GetString("CSecurityAdjustmentWiz1:HeaderSubTitle");
    }// CSecurityAdjustmentWiz1
   
}// class CSecurityAdjustmentWiz1
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cremotingprop3.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CRemotingProp3.cs
//
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections.Specialized;
using System.Collections;
using System.ComponentModel;
using System.Globalization;


internal class CRemotingProp3 : CPropPage
{
    // Controls on the page
    private ComboBox m_cbChannel;
    private Label m_lblGenHelp;
    private Label m_lblHelp;
    private Label m_lblChooseChannel;
        
    private MyDataGrid       m_dg;
    private DataTable        m_dt;
    private DataSet          m_ds;

    // Internal Data
    private int              m_nPrevSelection;
    private ArrayList        m_alRemotingChannels; 
    private String           m_sConfigFile;

    //-------------------------------------------------
    // CRemotingProp3 - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CRemotingProp3(String sConfigFile)
    {
        m_sConfigFile = sConfigFile;
        m_sTitle = CResourceStore.GetString("CRemotingProp3:PageTitle");
    }// CRemotingProp3

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CRemotingProp3));
        this.m_cbChannel = new System.Windows.Forms.ComboBox();
        this.m_lblGenHelp = new System.Windows.Forms.Label();
        this.m_lblHelp = new System.Windows.Forms.Label();
        this.m_lblChooseChannel = new System.Windows.Forms.Label();
        this.m_dg = new MyDataGrid();
        this.m_cbChannel.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
        this.m_cbChannel.DropDownWidth = 152;
        this.m_cbChannel.Location = ((System.Drawing.Point)(resources.GetObject("m_cbChannel.Location")));
        this.m_cbChannel.Size = ((System.Drawing.Size)(resources.GetObject("m_cbChannel.Size")));
        this.m_cbChannel.TabIndex = ((int)(resources.GetObject("m_cbChannel.TabIndex")));
        m_cbChannel.Name = "Channels";
        this.m_lblGenHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblGenHelp.Location")));
        this.m_lblGenHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblGenHelp.Size")));
        this.m_lblGenHelp.TabIndex = ((int)(resources.GetObject("m_lblGenHelp.TabIndex")));
        this.m_lblGenHelp.Text = resources.GetString("m_lblGenHelp.Text");
        m_lblGenHelp.Name = "GeneralHelp";
        this.m_lblHelp.Location = ((System.Drawing.Point)(resources.GetObject("m_lblHelp.Location")));
        this.m_lblHelp.Size = ((System.Drawing.Size)(resources.GetObject("m_lblHelp.Size")));
        this.m_lblHelp.TabIndex = ((int)(resources.GetObject("m_lblHelp.TabIndex")));
        this.m_lblHelp.Text = resources.GetString("m_lblHelp.Text");
        m_lblHelp.Name = "Help";
        this.m_lblChooseChannel.Location = ((System.Drawing.Point)(resources.GetObject("m_lblChooseChannel.Location")));
        this.m_lblChooseChannel.Size = ((System.Drawing.Size)(resources.GetObject("m_lblChooseChannel.Size")));
        this.m_lblChooseChannel.TabIndex = ((int)(resources.GetObject("m_lblChooseChannel.TabIndex")));
        this.m_lblChooseChannel.Text = resources.GetString("m_lblChooseChannel.Text");
        m_lblChooseChannel.Name = "ChooseChannel";
        this.m_dg.DataMember = "";
        this.m_dg.Location = ((System.Drawing.Point)(resources.GetObject("m_dg.Location")));
        this.m_dg.Size = ((System.Drawing.Size)(resources.GetObject("m_dg.Size")));
        this.m_dg.TabIndex = ((int)(resources.GetObject("m_dg.TabIndex")));
        m_dg.Name = "Grid";
        m_dg.BackgroundColor = Color.White;

        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_dg,
                        this.m_lblHelp,
                        m_lblGenHelp,
                        this.m_lblChooseChannel,
                        this.m_cbChannel});

        //---------- Begin Data Table ----------------
        m_dt = new DataTable("Attributes");
        m_ds = new DataSet();
        m_ds.Tables.Add(m_dt);

        m_dt.DefaultView.AllowNew=false;

        // Create the "Attribute" Column
        DataColumn dcAttribute = new DataColumn();
        dcAttribute.ColumnName = "Attribute";
        dcAttribute.DataType = typeof(String);
        m_dt.Columns.Add(dcAttribute);

        // Create the "Value" Column
        DataColumn dcValue = new DataColumn();
        dcValue.ColumnName = "Value";
        dcValue.DataType = typeof(String);
        m_dt.Columns.Add(dcValue);

        // Now set up any column-specific behavioral stuff....
        // like setting column widths, etc.

        DataGridTableStyle dgtsAct = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcAttribute = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcValue = new DataGridTextBoxColumn();
         
        m_dg.TableStyles.Add(dgtsAct);
        dgtsAct.MappingName = "Attributes";
        dgtsAct.RowHeadersVisible=false;
        dgtsAct.AllowSorting=false;
        dgtsAct.ReadOnly=false;

        // Set up the column info for the Object Type column
        dgtbcAttribute.MappingName = "Attribute";
        dgtbcAttribute.HeaderText = CResourceStore.GetString("CRemotingProp3:AttributeColumn");
        dgtbcAttribute.ReadOnly = true;
        dgtbcAttribute.Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp3:AttributeColumnWidth"));
        dgtbcAttribute.NullText = "";

        dgtsAct.GridColumnStyles.Add(dgtbcAttribute);

        // Set up the column info for the value column
        dgtbcValue.MappingName = "Value";
        dgtbcValue.HeaderText = CResourceStore.GetString("CRemotingProp3:ValueColumn");
        dgtbcValue.ReadOnly = false;
        dgtbcValue.Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp3:ValueColumnWidth"));
        dgtbcValue.NullText = "";
        dgtbcValue.TextBox.TextChanged+=new EventHandler(onChange);


        dgtsAct.GridColumnStyles.Add(dgtbcValue);
  
        m_dg.DataSource = m_dt;
        //---------- End Data Table ----------------

        // Fill in the data
        PutValuesinPage();

        // Do some UI tweaks
        m_dg.ReadOnly=false;
        m_dg.CaptionVisible=false;
        m_dg.ParentRowsVisible=false;

        // Now finally hook up event handlers
        m_cbChannel.SelectedIndexChanged += new EventHandler(onChannelChange);
        m_dg.TheVertScrollBar.VisibleChanged += new EventHandler(onVisibleChange);

        return 1;
    }// InsertPropSheetPageControls

    void onKeyPress(Object o, KeyPressEventArgs e)
    {
        ActivateApply();
    }// onKeyPress

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onKeyPress

    internal void onVisibleChange(Object o, EventArgs e)
    {
        // See if we should shrink one of the columns
        if (m_dg.TheVertScrollBar.Visible)
        {
            // The vertical scrollbar is visible. It takes up 13 pixels
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp3:ValueColumnWidth")) - m_dg.TheVertScrollBar.Width;
            m_dg.Refresh();
        }
        else
        {
            m_dg.TableStyles[0].GridColumnStyles[1].Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp3:ValueColumnWidth"));
            m_dg.Refresh();
        }
    }// onVisibleChange


    private void PutValuesinPage()
    {
        m_nPrevSelection=-1;

        String sSettingCommand = "RemotingChannels";
        if (m_sConfigFile != null)
            sSettingCommand += "," + m_sConfigFile;
        try
        {
            m_alRemotingChannels = (ArrayList)CConfigStore.GetSetting(sSettingCommand);

            m_cbChannel.Items.Clear();
            for(int i=0; i<m_alRemotingChannels.Count; i++)
            {
                // Go searching for the "displayname" attribute
                int j;
                for(j=0; j<((RemotingChannel)m_alRemotingChannels[i]).scAttributeName.Count; j++)
                    if (((RemotingChannel)m_alRemotingChannels[i]).scAttributeName[j].ToLower(CultureInfo.InvariantCulture).Equals("displayname"))
                    {
                        m_cbChannel.Items.Add(((RemotingChannel)m_alRemotingChannels[i]).scAttributeValue[j]);
                        break;
                    }
                // This is funny... this channel didn't have a name....
                if (j == ((RemotingChannel)m_alRemotingChannels[i]).scAttributeName.Count)
                    m_cbChannel.Items.Add(CResourceStore.GetString("<no name>"));
   
            }

            if (m_alRemotingChannels.Count > 0)
            {
                m_cbChannel.SelectedIndex=0;
                onChannelChange(null, null);
            }
            else
                m_cbChannel.Text = CResourceStore.GetString("<none>");
        }
        catch(Exception)
        {
            // An exception will get thrown if there was an error reading
            // the remoting config info. Don't allow the property page to open.
            CloseSheet();
        }
    }// PutValuesinPage

    void onChannelChange(Object o, EventArgs e)
    {
        m_dg.CurrentCell = new DataGridCell(0,0);
    
        if (m_cbChannel.SelectedIndex != -1)
        {
            RemotingChannel rc;
            
            if (m_nPrevSelection != -1)
            {
                rc = (RemotingChannel)m_alRemotingChannels[m_nPrevSelection];

                // Capture the changes the user made to the URL 
                // We need to keep track of the Row number, since we don't display
                // all of the Channel's attributes in the table.
                int nRowNum=0;
                for (int i=0; i<rc.scAttributeName.Count; i++)
                    if (!rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals("displayname") && 
                        !rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals("type") && 
                        !rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals("ref"))
                    {
                        String sValue = m_dt.Rows[nRowNum]["Value"] as String;
                        if (sValue == null)
                            sValue = "";

                        rc.scAttributeValue[i]=sValue;           
                        nRowNum++;
                    }
            }   
            
            m_dt.Clear();
            
            rc = (RemotingChannel)m_alRemotingChannels[m_cbChannel.SelectedIndex];

            DataRow newRow;

            // Build the Attributes/Value Table
            for (int i=0; i<rc.scAttributeValue.Count; i++)
            {
                if (!rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals("displayname")  && 
                    !rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals("type") && 
                    !rc.scAttributeName[i].ToLower(CultureInfo.InvariantCulture).Equals("ref"))
                {
                    newRow = m_dt.NewRow();
                    newRow["Attribute"]=rc.scAttributeName[i];
                    newRow["Value"]=rc.scAttributeValue[i];
                    m_dt.Rows.Add(newRow);
                }
            }

        }

        m_nPrevSelection = m_cbChannel.SelectedIndex;
    }// onChannelChange

    internal override bool ApplyData()
    {
        m_dg.CurrentCell = new DataGridCell(0,0);
        // This call will copy all the current table stuff into our ArrayList
        onChannelChange(null, null);

        String sSettingCommand = "RemotingChannels";
        if (m_sConfigFile != null)
            sSettingCommand += "," + m_sConfigFile;

        return CConfigStore.SetSetting(sSettingCommand, m_alRemotingChannels);               
    }// ApplyData

}// class CRemotingProp3
}// namespace Microsoft.CLRAdmin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\toolbox\urtui\snapin\cremotingprop2.cs ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//-------------------------------------------------------------
// CRemotingProp2.cs
//
//-------------------------------------------------------------

namespace Microsoft.CLRAdmin
{
using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Drawing;
using System.Windows.Forms;
using System.Text;
using System.Data;
using System.Collections.Specialized;
using System.ComponentModel;
using System.Globalization;


internal class CRemotingProp2 : CPropPage
{
    // Controls on the page
	
    Label m_lblObjectURIs;
    MyDataGrid m_dgObjectURIs;

	private DataTable        m_dtObjectURIs;
	private DataSet          m_ds;

	// Internal Data
	private ExposedTypes     m_et;
	private String           m_sConfigFile;

    //-------------------------------------------------
    // CRemotingProp2 - Constructor
    //
    // Sets up some member variables
    //-------------------------------------------------
    internal CRemotingProp2(String sConfigFile)
    {
        m_sConfigFile = sConfigFile;
        m_sTitle = CResourceStore.GetString("CRemotingProp2:PageTitle");
    }// CRemotingProp2

    //-------------------------------------------------
    // InsertPropSheetPageControls
    //
    // This function will create all the winforms controls
    // and parent them to the passed-in Window Handle.
    //
    // Note: For some winforms controls, such as radio buttons
    // and datagrids, we need to create a container, parent the
    // container to our window handle, and then parent our
    // winform controls to the container.
    //-------------------------------------------------
    internal override int InsertPropSheetPageControls()
    {
        System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CRemotingProp2));
        this.m_lblObjectURIs = new System.Windows.Forms.Label();
        this.m_dgObjectURIs = new MyDataGrid();
        this.m_lblObjectURIs.Location = ((System.Drawing.Point)(resources.GetObject("m_lblObjectURIs.Location")));
        this.m_lblObjectURIs.Size = ((System.Drawing.Size)(resources.GetObject("m_lblObjectURIs.Size")));
        this.m_lblObjectURIs.TabIndex = ((int)(resources.GetObject("m_lblObjectURIs.TabIndex")));
        this.m_lblObjectURIs.Text = resources.GetString("m_lblObjectURIs.Text");
        m_lblObjectURIs.Name = "ObjectURILabel";
        this.m_dgObjectURIs.Location = ((System.Drawing.Point)(resources.GetObject("m_dgObjectURIs.Location")));
        this.m_dgObjectURIs.Size = ((System.Drawing.Size)(resources.GetObject("m_dgObjectURIs.Size")));
        this.m_dgObjectURIs.TabIndex = ((int)(resources.GetObject("m_dgObjectURIs.TabIndex")));
        m_dgObjectURIs.Name = "Grid";
        m_dgObjectURIs.BackgroundColor = Color.White;

        PageControls.AddRange(new System.Windows.Forms.Control[] {this.m_dgObjectURIs,
                        this.m_lblObjectURIs});

        //---------- Begin Object URI table ----------------
        // Build the first data table
        
      
        m_dtObjectURIs = new DataTable("ObjectURIs");
        m_ds = new DataSet();
        m_ds.Tables.Add(m_dtObjectURIs);
        m_dtObjectURIs.DefaultView.AllowNew=false;

        // Create the "Object Name" Column
        DataColumn dcKnownOName = new DataColumn();
        dcKnownOName.ColumnName = "Object Name";
        dcKnownOName.DataType = typeof(String);
        m_dtObjectURIs.Columns.Add(dcKnownOName);

        // Create the "URI" Column
        DataColumn dcKnownURI = new DataColumn();
        dcKnownURI.ColumnName = "URI";
        dcKnownURI.DataType = typeof(String);
        m_dtObjectURIs.Columns.Add(dcKnownURI);

        // Set up the GUI-type stuff for the data grid
        m_dgObjectURIs.ReadOnly=false;
        m_dgObjectURIs.CaptionVisible=false;
        m_dgObjectURIs.ParentRowsVisible=false;

        // Now set up any column-specific behavioral stuff....
        // like setting column widths, etc.

        DataGridTableStyle dgtsKnown = new DataGridTableStyle();
        DataGridTextBoxColumn dgtbcKnownOName = new DataGridTextBoxColumn();
        DataGridTextBoxColumn dgtbcKnownURI = new DataGridTextBoxColumn();

        m_dgObjectURIs.TableStyles.Add(dgtsKnown);
        dgtsKnown.MappingName = "ObjectURIs";
        dgtsKnown.RowHeadersVisible=false;
        dgtsKnown.AllowSorting=false;
        dgtsKnown.ReadOnly=false;

        // Set up the column info for the Object Type column
        dgtbcKnownOName.MappingName = "Object Name";
        dgtbcKnownOName.HeaderText = CResourceStore.GetString("CRemotingProp2:ObjectNameColumn");
        dgtbcKnownOName.ReadOnly=true;
        dgtbcKnownOName.Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp2:ObjectNameColumnWidth"));
        dgtsKnown.GridColumnStyles.Add(dgtbcKnownOName);

        // Set up the column info for the URI column
        dgtbcKnownURI.MappingName = "URI";
        dgtbcKnownURI.HeaderText = CResourceStore.GetString("CRemotingProp2:URIColumn");
        dgtbcKnownURI.ReadOnly=false;
        dgtbcKnownURI.Width = ScaleWidth(CResourceStore.GetInt("CRemotingProp2:URIColumnWidth"));
        dgtbcKnownURI.TextBox.TextChanged +=new EventHandler(onChange);

        dgtsKnown.GridColumnStyles.Add(dgtbcKnownURI);

        m_dgObjectURIs.DataSource = m_dtObjectURIs;

        //---------- End Data Table2 ----------------


        // Fill in the data
        PutValuesinPage();

        // See if we should shrink one of the columns
        if (m_dgObjectURIs.TheVertScrollBar.Visible)
            // The vertical scrollbar is visible. It takes up 13 pixels
            m_dgObjectURIs.TableStyles[0].GridColumnStyles[1].Width -= m_dgObjectURIs.TheVertScrollBar.Width;

		return 1;
    }// InsertPropSheetPageControls

    void onChange(Object o, EventArgs e)
    {
        ActivateApply();
    }// onRowChange

    protected void onKeyPress(Object o, KeyPressEventArgs e)
    {
        ActivateApply();
    }// onKeyPress

    private String GetNumberFromTimeString(String s)
    {
        // See where the last number is that we want
        int nIndex = s.Length-1;
        while(nIndex >=0 && !Char.IsNumber(s[nIndex]))
            nIndex--;
        
        return s.Substring(0, nIndex+1);
    }// GetNumberFromTimeString

    private String GetTimeUnitFromTimeString(String s)
    {
        int nIndex = s.Length-1;
        while(nIndex >=0 && !Char.IsNumber(s[nIndex]))
            nIndex--;
   
        String sUnit = s.Substring(nIndex+1);
        
        if (sUnit.ToLower(CultureInfo.InvariantCulture).Equals("d"))
            return CResourceStore.GetString("Days");
        if (sUnit.ToLower(CultureInfo.InvariantCulture).Equals("m"))
            return CResourceStore.GetString("Minutes");
        if (sUnit.ToLower(CultureInfo.InvariantCulture).Equals("s"))
            return CResourceStore.GetString("Seconds");
        if (sUnit.ToLower(CultureInfo.InvariantCulture).Equals("ms"))
            return CResourceStore.GetString("Milliseconds");
        // If we don't know the time value, let's make it seconds
        return CResourceStore.GetString("Seconds");    
    }// GetTimeUnitFromTimeString

    private void PutValuesinPage()
    {
        String sSettingCommand = "ExposedTypes";
        if (m_sConfigFile != null)
            sSettingCommand += "," + m_sConfigFile;
   
        m_et = (ExposedTypes)CConfigStore.GetSetting(sSettingCommand);
		
        DataRow newRow;

        // Now build the Well Known objects table
        for (int i=0; i<m_et.scWellKnownMode.Count; i++)
        {
            newRow = m_dtObjectURIs.NewRow();
            // Find a good name
			
			String sName = m_et.scWellKnownObjectName[i];
            if (sName == null || sName.Length == 0)
                // We'll show the type instead
                sName = m_et.scWellKnownType[i];
            
            newRow["Object Name"]=sName;
            newRow["URI"]=m_et.scWellKnownUri[i];

            m_dtObjectURIs.Rows.Add(newRow);
        }
 
    }// PutValuesinPage

    internal override bool ValidateData()
    {
        // Let's jump to a new cell, to make sure the current cell we
        // were editing has it's changes 'saved'
        m_dgObjectURIs.CurrentCell = new DataGridCell(0,1);
        m_dgObjectURIs.CurrentCell = new DataGridCell(0,0);

        /* We won't do checking on this right now
        int nLen = m_et.scWellKnownMode.Count;
        
        for(int i=0; i<nLen; i++)
        {
            try
            {
                new Uri((String)m_dgKnownObjects[i,3]);
            }
            catch(Exception)
            {
                // Catch the error that is was an invalid version
                MessageBox(0, 
                           "'" + (String)m_dgKnownObjects[i,3] + "' " + 
                           CResourceStore.GetString("IsNotAValidURL"),
                           CResourceStore.GetString("IsNotAValidURLTitle"),
                           MB.ICONEXCLAMATION);
                m_dgKnownObjects.CurrentCell = new DataGridCell(i,3);

                return false;                                       
            }
        }
        */
        return true;
    }// ValidateData

    internal override bool ApplyData()
    {
